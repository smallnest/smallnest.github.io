<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="https://ashki23.github.io/styles.css">
         </head>
   <body>
            <div class="container">
         
         <h2 id="索引">索引</h2>
<h3 id="a">A</h3>
<ul>
<li>AArch64（参见 ARM64）</li>
<li>ABA 问题，<a href="./2_Atomics.md#index-ABAproblem">#</a></li>
<li>终止进程，<a
href="./2_Atomics.md#index-abortingtheprocess">#</a></li>
<li>AcqRel，<a href="./3_Memory_Ordering.md#index-AcqRel">#</a>
<ul>
<li>（参见 release 和 acquire 内存排序）</li>
</ul></li>
<li>acquire 内存排序（参见 release 和 acquire 内存排序）</li>
<li>add 指令（ARM），<a
href="./7_Understanding_the_Processor.md#index-addinstructionARM">#</a></li>
<li>add 指令（x86），<a
href="./7_Understanding_the_Processor.md#index-addinstructionx86">#</a></li>
<li>基于地址的等待（Windows），<a
href="./8_Operating_System_Primitives.md#基于地址的等待">#</a>
<ul>
<li>（参见 futex）</li>
</ul></li>
<li>凭空出现的值，<a
href="./3_Memory_Ordering.md#凭空出现的值">#</a></li>
<li>alignment，<a
href="./7_Understanding_the_Processor.md#index-alignment">#</a></li>
<li>分配（参见 ID 分配）</li>
<li>AMD 处理器，<a
href="./7_Understanding_the_Processor.md#index-AMDprocessors">#</a></li>
<li>and 指令（x86），<a
href="./7_Understanding_the_Processor.md#index-x86-64instructions-and">#</a></li>
<li>Arc，<a href="./1_Basic_of_Rust_Concurrency.md#index-Arc">#</a>
<ul>
<li>构建我们自己的 Arc，<a
href="./6_Building_Our_Own_Arc.md#index-buildingourown-Arc">#</a></li>
<li>循环结构，<a
href="./6_Building_Our_Own_Arc.md#index-Arc-cyclicstructures">#</a></li>
<li>get_mut，<a
href="./6_Building_Our_Own_Arc.md#index-Arc-getmut">#</a></li>
<li>内存排序，<a
href="./6_Building_Our_Own_Arc.md#index-Arc-memoryordering">#</a>，<a
href="./6_Building_Our_Own_Arc.md#index-happens-beforerelationships-inArc-2">#</a>，<a
href="./6_Building_Our_Own_Arc.md#index-Arc-memoryordering-3">#</a>，<a
href="./6_Building_Our_Own_Arc.md#index-Arc-memoryordering-4">#</a></li>
<li>命名克隆，<a
href="./1_Basic_of_Rust_Concurrency.md#命名克隆">#</a></li>
<li>用于 Channel 的情况，<a
href="./5_Building_Our_Own_Channels.md#index-Arc-usingforchannelstate">#</a></li>
<li>weak 指针，<a href="./6_Building_Our_Own_Arc.md#weak-指针">#</a>
<ul>
<li>性能开销，<a
href="./6_Building_Our_Own_Arc.md#index-Arc-weakpointers-performancecost">#</a></li>
</ul></li>
</ul></li>
<li>arguments，consuming，<a
href="./5_Building_Our_Own_Channels.md#index-argumentsconsuming">#</a></li>
<li>ARM64（处理器架构），<a
href="./7_Understanding_the_Processor.md#index-ARM64processorarchitecture">#</a>
<ul>
<li>aarch64-unknown-linux-musl target，<a
href="./7_Understanding_the_Processor.md#index-ARM64processorarchitecture-aarch64-unknown-linux-musltarget">#</a></li>
<li>other-multi-copy atomic，<a
href="./7_Understanding_the_Processor.md#index-ARM64processorarchitecture-other-multi-copyatomic">#</a></li>
<li>weakly ordered，<a
href="./7_Understanding_the_Processor.md#arm64弱排序">#</a></li>
</ul></li>
<li>ARM64 指令
<ul>
<li>add，#</li>
<li>ARMv8.1 atomic instructions，#，#</li>
<li>b.ne (branch if not equal)，#</li>
<li>cbnz (compare and branch on nonzero)，#</li>
<li>clrex (clear exclusive)，#</li>
<li>cmp (compare)，#</li>
<li>dmb (data memory barrier)，#</li>
<li>ldar (load-acquire register)，#</li>
<li>ldaxr (load-acquire exclusive register)，#</li>
<li>ldr (load register)，#</li>
<li>ldxr (load exclusive register)，#</li>
<li>load-linked and store-conditional instructions，#</li>
<li>mov (move)，#</li>
<li>overview，#</li>
<li>ret (return)，#</li>
<li>stlr (store-release register)，#</li>
<li>stlxr (store-release exclusive register)，#</li>
<li>str (store register)，#</li>
<li>stxr (store exclusive register)，#</li>
</ul></li>
<li>ARMv8 (see ARM64)</li>
<li>ARMv8.1 atomic instructions，#，#
<ul>
<li>overview，#</li>
</ul></li>
<li>array::from_fn，#</li>
<li>assembler，#</li>
<li>assembly，#
<ul>
<li>inspecting compiler output，#</li>
</ul></li>
<li>atomic，#，#
<ul>
<li>compare-and-exchange operations，#
<ul>
<li>weak，#，#，#，#，#，#，#，#，#，#，#，#</li>
</ul></li>
<li>fetch-and-modify operations，#
<ul>
<li>wrapping behavior (add and sub)，#，#，#，#</li>
</ul></li>
<li>load and store operations，#
<ul>
<li>example，stop flag，#，#，#，#，#</li>
</ul></li>
<li>memory ordering (see memory ordering)</li>
<li>reference counting (see Arc)</li>
</ul></li>
<li>atomic barriers (see fences)</li>
<li>atomic fences (see fences)</li>
<li>atomic types，#，#
<ul>
<li>compare_exchange，#</li>
<li>compare_exchange_weak，#</li>
<li>fetch_add，#
<ul>
<li>wrapping behavior，#</li>
<li>(see also overflows)</li>
</ul></li>
<li>fetch_and，#</li>
<li>fetch_max，#</li>
<li>fetch_min，#</li>
<li>fetch_nand，#</li>
<li>fetch_or，#</li>
<li>fetch_store (see swap)</li>
<li>fetch_sub，#
<ul>
<li>wrapping behavior，#</li>
<li>(see also overflows)</li>
</ul></li>
<li>fetch_update，#</li>
<li>fetch_xor，#</li>
<li>get_mut，#</li>
<li>load，#</li>
<li>store，#</li>
<li>swap，#</li>
</ul></li>
<li>atomic-wait crate，#</li>
<li>AtomicBool，#
<ul>
<li>(see also atomic types)</li>
<li>locking using，#，#</li>
</ul></li>
<li>AtomicI8 (see atomic types)</li>
<li>AtomicI16 (see atomic types)</li>
<li>AtomicI32 (see atomic types)</li>
<li>AtomicI64 (see atomic types)</li>
<li>AtomicIsize (see atomic types)</li>
<li>AtomicPtr，#
<ul>
<li>(see also atomic types)</li>
<li>compare-and-exchange，#</li>
<li>lazy initialization，#</li>
</ul></li>
<li>AtomicU8 (see atomic types)</li>
<li>AtomicU16 (see atomic types)</li>
<li>AtomicU32 (see atomic types)</li>
<li>AtomicU64 (see atomic types)</li>
<li>AtomicUsize (see atomic types)</li>
<li>auto traits，#</li>
</ul>
<h3 id="b">B</h3>
<ul>
<li>b.ne (branch if not equal) instruction (ARM)，#</li>
<li>barriers (see fences)</li>
<li>basics，#</li>
<li>benchmarking，#，#
<ul>
<li>black_box，avoiding optimizations with，#，#</li>
</ul></li>
<li>binary semaphore，#</li>
<li>black_box，#，#</li>
<li>blocking，#
<ul>
<li>channel，#</li>
<li>condition variables，#</li>
<li>futex wait operation，#</li>
<li>(see also futex)</li>
<li>mutexes，#</li>
<li>Once and OnceLock，#，#</li>
<li>semaphores，#</li>
<li>spin loop，#</li>
<li>thread parking (see thread parking)</li>
</ul></li>
<li>boolean (atomic) (see AtomicBool)</li>
<li>borrowing，#
<ul>
<li>bending the rules，#</li>
<li>error，#</li>
<li>exclusive，#</li>
<li>from multiple threads (Sync)，#</li>
<li>immutable，#</li>
<li>(see also shared)</li>
<li>local variables in a thread，#</li>
<li>mutable，#</li>
<li>(see also exclusive)</li>
<li>shared，#</li>
<li>splitting，#</li>
<li>undefined behavior，#</li>
</ul></li>
<li>Box
<ul>
<li>from_raw，#，#</li>
<li>into_raw，#</li>
<li>leak，#，#</li>
<li>unmovable type，wrapping in，#</li>
</ul></li>
<li>btc (bit test and complement) instruction (x86)，#</li>
<li>btr (bit test and reset) instruction (x86)，#</li>
<li>bts (bit test and set) instruction (x86)，#</li>
<li>building our own
<ul>
<li>Arc，#</li>
<li>channels，#</li>
<li>condition variables，#</li>
<li>mutexes，#</li>
<li>reader-writer locks，#</li>
<li>spin locks，#</li>
</ul></li>
<li>busy-looping，#
<ul>
<li>(see also spinning)</li>
</ul></li>
</ul>
<h3 id="c">C</h3>
<ul>
<li>C standard library，#
<ul>
<li>(see also libc)</li>
</ul></li>
<li>cache coherence，#
<ul>
<li>protocol，#
<ul>
<li>write-through，#，#，#，#</li>
</ul></li>
</ul></li>
<li>cache lines，#
<ul>
<li>performance experiment，#</li>
</ul></li>
<li>cache miss，#</li>
<li>caching (processors)，#
<ul>
<li>(see also cache coherence)</li>
<li>compare-and-exchange operations，effect of，#</li>
<li>per core，#</li>
<li>performance experiment，#</li>
</ul></li>
<li>cargo-show-asm，#</li>
<li>cas (compare and swap) instruction (ARM)，#</li>
<li>casa (compare and swap，acquire) instruction (ARM)，#</li>
<li>casal (compare and swap，acquire and release) instruction
(ARM)，#</li>
<li>casl (compare and swap，release) instruction (ARM)，#</li>
<li>cbnz (compare and branch on nonzero) instruction (ARM)，#</li>
<li>Cell，#
<ul>
<li>unsafe (see UnsafeCell)</li>
</ul></li>
<li>channels
<ul>
<li>blocking，#</li>
<li>borrowing，#</li>
<li>building our own，#</li>
<li>dropping，#</li>
<li>one-shot，#</li>
<li>safe interface，#</li>
<li>Sender and Receiver types，#，#</li>
<li>storing in Arc，#
<ul>
<li>avoiding，#</li>
</ul></li>
<li>unsafe interface，#</li>
</ul></li>
<li>Clone trait，#，#，#，#，#</li>
<li>closures
<ul>
<li>captured values
<ul>
<li>moving，#，#</li>
</ul></li>
<li>spawning scoped threads using，#</li>
<li>spawning threads using，#</li>
</ul></li>
<li>clrex (clear exclusive) instruction (ARM)，#</li>
<li>cmp (compare) instruction (ARM)，#</li>
<li>cmpxchg (compare and exchange) instruction (x86)，#</li>
<li><code>#[cold]</code>，#</li>
<li>compare-and-exchange operations (atomic)，#
<ul>
<li>on ARM64，#</li>
<li>caching，effect on，#</li>
<li>compiler optimization，#</li>
<li>example，ID allocation，#</li>
<li>example，lazy initialization，#，#</li>
<li>memory ordering，#</li>
<li>using for channel state，#</li>
<li>using for mutex state，#</li>
<li>using for reader-writer lock state，#</li>
<li>using on AtomicPtr，#</li>
<li>using to lock reference counter，#</li>
<li>weak，#
<ul>
<li>on ARM64，#</li>
</ul></li>
<li>on x86-64，#</li>
</ul></li>
<li>Compiler Explorer，#</li>
<li>compiler fence，#，#</li>
<li>compiler optimization
<ul>
<li>black_box，avoiding with，#，#</li>
<li><code>#[cold]</code>，#</li>
<li>of compare-and-exchange loops，#</li>
<li>enabling，#，#</li>
<li><code>#[inline]</code> #</li>
<li>reordering，#</li>
</ul></li>
<li>complex instruction set computer (CISC)，#</li>
<li>concurrency，basics，#</li>
<li>condition variables，#
<ul>
<li>building our own，#</li>
<li>example，#</li>
<li>memory ordering，#</li>
<li>pthread_cond_t，#</li>
<li>thundering herd problem，#</li>
<li>timeout，#</li>
<li>using to build a channel，#</li>
<li>Windows，#</li>
</ul></li>
<li>Condvar，#
<ul>
<li>(see also condition variables)</li>
</ul></li>
<li>consume memory ordering，#</li>
<li>consuming arguments by value，#</li>
<li>contention (mutexes)，#，#
<ul>
<li>benchmarking，#</li>
</ul></li>
<li>Copy trait，#，#
<ul>
<li>atomic types，not implementing，#</li>
<li>moving，#</li>
</ul></li>
<li>critical section (Windows)，#</li>
<li>current thread，#，#，#</li>
<li>cyclic structures (Arc)，#</li>
</ul>
<h3 id="d">D</h3>
<ul>
<li>data races，#
<ul>
<li>avoiding using atomics，#，#</li>
</ul></li>
<li>Deref trait，#，#，#</li>
<li>DerefMut trait，#，#，#，#</li>
<li>disassembler，#，#</li>
<li>dmb (data memory barrier) instruction (ARM)，#</li>
<li>drop function，#，#，#</li>
<li>Drop trait，#，#，#，#，#，#，#，#，#，#，#，#</li>
<li>dword，#</li>
</ul>
<h3 id="e">E</h3>
<ul>
<li>–emit=asm (rustc)，#</li>
<li>exclusive references，#</li>
</ul>
<h3 id="f">F</h3>
<ul>
<li>fair locks，#</li>
<li>false sharing，#</li>
<li>fences，#，#，#
<ul>
<li>on ARM64，#</li>
<li>compiler fence，#，#</li>
<li>instructions，#</li>
<li>process-wide memory barriers，#</li>
<li>on x86-64，#</li>
</ul></li>
<li>fetch-and-modify operations (atomic)，#
<ul>
<li>on ARM64，#</li>
<li>example，ID allocation，#</li>
<li>example，progress reporting，#</li>
<li>example，statistics，#</li>
<li>wrapping behavior (add and sub)，#
<ul>
<li>(see also overflows)</li>
</ul></li>
<li>on x86-64，#</li>
</ul></li>
<li>fetch_store operation (atomic) (see swap operation)</li>
<li>fetch_update (atomic)，#</li>
<li>FlushProcessWriteBuffers (Windows)，#</li>
<li>forgetting (see leaking)</li>
<li>FreeBSD，umtx_op syscall，#
<ul>
<li>(see also futex)</li>
</ul></li>
<li>from_fn (array)，#</li>
<li>futex，#
<ul>
<li>cross-platform futex-like functionality，#</li>
<li>example，#</li>
<li>memory safety，#</li>
<li>on other platforms，#</li>
<li>operations (Linux)，#
<ul>
<li>FUTEX_WAIT，#，#，#，#，#，#，#，#，#，#，#</li>
</ul></li>
<li>requeuing，#，#</li>
<li>spurious wake-ups，#</li>
<li>timeout，#，#</li>
<li>wait operation，#</li>
<li>wake operation，#</li>
</ul></li>
</ul>
<h3 id="g">G</h3>
<ul>
<li>globally consistent order，#
<ul>
<li>(see also sequentially consistent memory ordering)</li>
</ul></li>
<li>Godbolt，#</li>
<li>good luck，#</li>
<li>guards
<ul>
<li>dropping，#</li>
<li>join guard，#</li>
<li>mutex guard，#，#</li>
<li>read guard，#，#</li>
<li>spin lock guard，#</li>
<li>write guard，#，#</li>
</ul></li>
</ul>
<h3 id="h">H</h3>
<ul>
<li>hand，things getting out of，#</li>
<li>happens-before relationships，#
<ul>
<li>in Arc，#，#</li>
<li>between threads，#</li>
<li>locking and unlocking，#，#</li>
<li>spawning and joining threads，#</li>
<li>through a release-acquire pair，#，#
<ul>
<li>chaining，#</li>
</ul></li>
<li>within the same thread，#</li>
</ul></li>
<li>hint::black_box，#，#</li>
<li>hint::spin_loop，#</li>
</ul>
<h3 id="i">I</h3>
<ul>
<li>ID allocation
<ul>
<li>using compare_exchange_weak，#</li>
<li>using fetch_add，#</li>
<li>using fetch_update，#</li>
</ul></li>
<li>ideas and inspiration，#</li>
<li>if let statement
<ul>
<li>lifetime of temporaries，#</li>
</ul></li>
<li>ignorance，blissful，#</li>
<li>immutable references，#
<ul>
<li>(see also shared references)</li>
</ul></li>
<li>indivisible，#</li>
<li><code>#[inline]</code>，#</li>
<li>inspiration，#</li>
<li>Instant，#</li>
<li>instruction reordering (see reordering)</li>
<li>instructions，#
<ul>
<li>(see also ARM64 instructions; x86-64 instructions)</li>
<li>compare-and-exchange operations，#，#</li>
<li>fences，#</li>
<li>load and store operations，#</li>
<li>load-linked/store-conditional (LL/SC) instructions，#</li>
<li>memory ordering，#</li>
<li>overview，#</li>
<li>read-modify-write operations，#</li>
</ul></li>
<li>Intel processors，#</li>
<li>interior mutability，#，#，#</li>
<li>invalidation queues，#</li>
</ul>
<h3 id="j">J</h3>
<ul>
<li>jne (jump if not equal) instruction (x86)，#</li>
<li>join method，#</li>
<li>JoinGuard，#</li>
<li>JoinHandle，#</li>
<li>joining threads，#
<ul>
<li>happens-before relationship，#</li>
</ul></li>
</ul>
<h3 id="k">K</h3>
<ul>
<li>kernel，#，#
<ul>
<li>interfacing with，#</li>
<li>kernel-managed objects (Windows)，#</li>
</ul></li>
</ul>
<h3 id="l">L</h3>
<ul>
<li>L1/L2/L3/L4 cache，#</li>
<li>label (assembly)，#</li>
<li>lazy initialization
<ul>
<li>using compare_exchange，#</li>
<li>using compare_exchange and allocation，#</li>
<li>using load and store，#</li>
</ul></li>
<li>ldadd (load and add) instruction (ARM)，#</li>
<li>ldadda (load and add，acquire) instruction (ARM)，#</li>
<li>ldaddal (load and add，acquire and release) instruction
(ARM)，#</li>
<li>ldaddl (load and add，release) instruction (ARM)，#</li>
<li>ldar (load-acquire register) instruction (ARM)，#</li>
<li>ldaxr (load-acquire exclusive register) instruction (ARM)，#</li>
<li>ldr (load register) instruction (ARM)，#</li>
<li>ldxr (load exclusive register) instruction (ARM)，#</li>
<li>leaking，#，#
<ul>
<li>by mistake，#</li>
<li>a MutexGuard，#</li>
</ul></li>
<li>“Leakpocalypse”，#</li>
<li>libc，#
<ul>
<li>pthreads functionality in，#</li>
</ul></li>
<li>libpthread，#
<ul>
<li>(see also pthreads)</li>
</ul></li>
<li>lifetime
<ul>
<li>elision，#，#</li>
<li>in a struct，#</li>
<li>of mutex guard，#</li>
<li>specifying using plain English，#</li>
<li>static，#</li>
</ul></li>
<li>linked list，#
<ul>
<li>Linux
<ul>
<li>futex syscall，#</li>
<li>(see also futex)</li>
</ul></li>
<li>arguments，#</li>
<li>futex_waitv syscall，#</li>
<li>interfacing with the kernel，#</li>
<li>libc，role of，#</li>
<li>membarrier syscall，#</li>
<li>process-wide memory barrier，#</li>
<li>RCU，#</li>
</ul></li>
<li>load and store operations (atomic)，#
<ul>
<li>on ARM64 and x86-64，#</li>
<li>compared to non-atomic operations，#，#</li>
<li>example，lazy initialization，#</li>
<li>example，progress reporting，#</li>
<li>example，stop flag，#</li>
</ul></li>
<li>load-linked/store-conditional (LL/SC) loop，#
<ul>
<li>on ARM64，#</li>
<li>compiler optimization，#</li>
</ul></li>
<li>lock poisoning，#</li>
<li>lock prefix (x86)，#</li>
<li>lock_api crate，#</li>
<li>luck，good，#</li>
</ul>
<h3 id="m">M</h3>
<ul>
<li>machine code，#</li>
<li>machine instructions (see instructions)</li>
<li>macOS
<ul>
<li>futex-like functionality on，#</li>
<li>interfacing with the kernel，#，#</li>
<li>os_unfair_lock，#</li>
</ul></li>
<li>main thread，#</li>
<li>ManuallyDrop，#</li>
<li>MaybeUninit，#，#，#</li>
<li>mem::forget，#</li>
<li>membarrier syscall，#</li>
<li>memory barriers (see fences)</li>
<li>memory fences (see fences)</li>
<li>memory model，#</li>
<li>memory ordering，#，#
<ul>
<li>on ARM64，#</li>
<li>compiler fence，#，#</li>
<li>consume，#</li>
<li>experiment，using relaxed instead of release and acquire，#</li>
<li>fences，#，#，#</li>
<li>happens-before relationship，#，#</li>
<li>Miri，detecting problems with，#</li>
<li>misconceptons about，#</li>
<li>out-of-thin-air values，#</li>
<li>at processor level，#</li>
<li>reference counting，#，#，#，#，#</li>
<li>relaxed，#，#</li>
<li>release and acquire，#
<ul>
<li>(see also release and acquire memory ordering)</li>
<li>locking and unlocking，#</li>
</ul></li>
<li>sequentially consistent，#
<ul>
<li>(see also sequentially consistent memory ordering)</li>
</ul></li>
<li>specifying using plain English，#</li>
<li>total modification order，#，#，#，#</li>
<li>on x86-64，#</li>
</ul></li>
<li>MESI cache coherence protocol，#</li>
<li>MESIF cache coherence protocol，#</li>
<li>mfence (memory fence) instruction (x86)，#</li>
<li>microinstructions，#</li>
<li>Miri，#</li>
<li>MOESI cache coherence protocol，#</li>
<li>mov (move) instruction (ARM)，#</li>
<li>mov (move) instruction (x86)，#</li>
<li>movable，not
<ul>
<li>critical section (Windows)，#</li>
<li>Pin，#</li>
<li>pthread types，#</li>
<li>wrapping in Box，#</li>
</ul></li>
<li>move closure，#</li>
<li>multi-copy atomicity，#</li>
<li>mutability，interior (see interior mutability)</li>
<li>mutable references，#
<ul>
<li>(see also exclusive references)</li>
</ul></li>
<li>Mutex，#，#
<ul>
<li>(see also mutexes)</li>
</ul></li>
<li>mutexes，#
<ul>
<li>building our own，#</li>
<li>as container，#</li>
<li>contention，#，#</li>
<li>example，#</li>
<li>fair，#</li>
<li>happens-before relationship，#</li>
<li>into_inner，#</li>
<li>lifetime of mutex guard，#</li>
<li>memory ordering，#</li>
<li>Mutex type in Rust，#</li>
<li>os_unfair_lock (macOS)，#</li>
<li>in other languages，#</li>
<li>poisoning，#</li>
<li>pthread
<ul>
<li>wrapping in Rust，#</li>
</ul></li>
<li>pthread_mutex_t，#</li>
<li>recursive，#</li>
<li>robust，#</li>
<li>Send requirement，#</li>
<li>spin locks，#
<ul>
<li>(see also spin locks)</li>
</ul></li>
<li>spinning，#，#</li>
<li>using to build a channel，#</li>
</ul></li>
<li>MutexGuard，#
<ul>
<li>dropping，#</li>
<li>lifetime of，#</li>
</ul></li>
<li>mutual exclusion (see mutexes)</li>
</ul>
<h3 id="n">N</h3>
<ul>
<li>name of a thread，#</li>
<li>NetBSD，futex support，#
<ul>
<li>(see also futex)</li>
</ul></li>
<li>NonNull，#</li>
</ul>
<h3 id="o">O</h3>
<ul>
<li>-O flag (rustc)，#，#</li>
<li>Once and OnceLock，#，#</li>
<li>one-shot channels，#</li>
<li>OpenBSD，limited futex support，#
<ul>
<li>(see also futex)</li>
</ul></li>
<li>operating systems，#
<ul>
<li>(see also Linux; macOS; Windows)</li>
<li>libraries shipped with，#</li>
<li>synchronization primitives，#</li>
</ul></li>
<li>optimization (see compiler optimization)</li>
<li>or instruction (x86)，#，#</li>
<li>Ordering，#，#
<ul>
<li>AcqRel，#
<ul>
<li>(see also release and acquire memory ordering)</li>
</ul></li>
<li>Acquire，#
<ul>
<li>(see also release and acquire memory ordering)</li>
</ul></li>
<li>Consume，#</li>
<li>Relaxed，#，#</li>
<li>Release，#
<ul>
<li>(see also release and acquire memory ordering)</li>
</ul></li>
<li>SeqCst，#
<ul>
<li>(see also sequentially consistent memory ordering)</li>
</ul></li>
</ul></li>
<li>os_unfair_lock (macOS)，#</li>
<li>other-multi-copy atomicity，#</li>
<li>out of order execution (see reordering)</li>
<li>out-of-thin-air values，#</li>
<li>output locking，#</li>
<li>overflows (atomic)，#
<ul>
<li>(see also wrapping behavior)</li>
<li>aborting on，#</li>
<li>notification counter，#</li>
<li>panicking on，#</li>
<li>preventing (compare-and-exchange)，#</li>
<li>reference counter，#</li>
<li>usize，big enough，#</li>
</ul></li>
<li>overview of atomic instructions，#</li>
<li>ownership
<ul>
<li>moving，#，#</li>
<li>sharing，#</li>
<li>transferring to another thread (Send)，#</li>
</ul></li>
</ul>
<h3 id="p">P</h3>
<ul>
<li>panicking
<ul>
<li>poisoned mutexes，#</li>
<li>RefCell，borrowing，#</li>
<li>thread name in panic messages，#</li>
<li>using a Condvar with multiple mutexes，#</li>
<li>when joining a thread，#，#</li>
<li>when spawning a thread，#</li>
</ul></li>
<li>parking (see thread parking)</li>
<li>parking lot-based locks，#</li>
<li>parking_lot crate，#</li>
<li>PhantomData，#，#</li>
<li>Pin，#</li>
<li>pipelining，#</li>
<li>pointers
<ul>
<li>atomic (see AtomicPtr)</li>
<li>neither Send nor Sync，#</li>
<li>NonNull，#</li>
</ul></li>
<li>poisoning，lock，#</li>
<li>POSIX，#
<ul>
<li>pthreads，#</li>
</ul></li>
<li>println，use of output locking，#</li>
<li>priority inheritance，#</li>
<li>priority inversion，#</li>
<li>privacy (modules)，#</li>
<li>process-wide memory barriers，#</li>
<li>processes，#</li>
<li>processor architecture，#
<ul>
<li>(see also ARM64; x86-64)</li>
<li>strongly ordered，#</li>
<li>weakly ordered，#</li>
</ul></li>
<li>processor caching (see caching)</li>
<li>processor instructions (see instructions)</li>
<li>processor registers，#
<ul>
<li>return value，#</li>
</ul></li>
<li>pthreads，#
<ul>
<li>pthread_cond_t，#，#</li>
<li>pthread_mutex_t，#</li>
<li>dropping while locked，#</li>
<li>pthread_rwlock_t，#</li>
<li>wrapping in Rust，#</li>
</ul></li>
</ul>
<h3 id="q">Q</h3>
<ul>
<li>queue-based locks，#</li>
</ul>
<h3 id="r">R</h3>
<ul>
<li>racing，#</li>
<li>Rc，#</li>
<li>RCU (read，copy，update)，#，#</li>
<li>reader-writer locks，#
<ul>
<li>avoiding accidental spinning，#</li>
<li>building our own，#</li>
<li>pthread_rwlock_t，#</li>
<li>Send requirement，#</li>
<li>SRW locks (Windows)，#</li>
<li>Sync requirement，#</li>
<li>writer starvation，#，#</li>
</ul></li>
<li>recursive locking，#，#</li>
<li>reduced instruction set computer (RISC)，#</li>
<li>RefCell，#
<ul>
<li>RwLock compared to，#</li>
</ul></li>
<li>reference counting，#
<ul>
<li>(see also Arc)</li>
</ul></li>
<li>references
<ul>
<li>exclusive，#</li>
<li>immutable，#
<ul>
<li>(see also shared)</li>
</ul></li>
<li>mutable，#
<ul>
<li>(see also exclusive)</li>
</ul></li>
<li>shared，#</li>
</ul></li>
<li>registers，#
<ul>
<li>return value，#</li>
</ul></li>
<li>relaxed memory ordering，#，#，#
<ul>
<li>counter-intuitive results，#</li>
<li>misconceptions about，#，#</li>
<li>out-of-thin-air values，#</li>
<li>reference counting，#</li>
<li>total modification order，#，#，#，#</li>
</ul></li>
<li>release and acquire memory ordering，#
<ul>
<li>acquire fence，#，#，#，#，#</li>
<li>on ARM64，#</li>
<li>example，lazy initialization，#</li>
<li>experiment，using relaxed instead，#</li>
<li>happens-before relationship，#，#
<ul>
<li>chaining，#</li>
</ul></li>
<li>locking and unlocking，#，#</li>
<li>reference counting，#，#，#，#</li>
<li>release fence，#</li>
<li>on x86-64，#</li>
</ul></li>
<li>–release flag (cargo)，#，#</li>
<li>reordering (instructions)，#，#
<ul>
<li>memory ordering，#</li>
</ul></li>
<li><code>#[repr(align)]</code>，#</li>
<li>requeuing waiting threads，#，#</li>
<li>ret (return) instruction (ARM)，#</li>
<li>ret (return) instruction (x86)，#</li>
<li>robust mutexes，#</li>
<li>rustup，#</li>
<li>RwLock，#，#
<ul>
<li>(see also reader-writer locks)</li>
</ul></li>
<li>RwLockReadGuard，#</li>
<li>RwLockWriteGuard，#</li>
</ul>
<h3 id="s">S</h3>
<ul>
<li>safe interface，#，#，#</li>
<li>safety requirements of unsafe functions，#</li>
<li>scheduler，#</li>
<li>scoped threads，#</li>
<li>semaphores，#</li>
<li>Send trait，#，#，#
<ul>
<li>error，#</li>
<li>implementing for Arc，#</li>
<li>requirement by Mutex and RwLock，#</li>
</ul></li>
<li>SeqCst (see sequentially consistent memory ordering)</li>
<li>sequence locks，#</li>
<li>sequentially consistent memory ordering，#
<ul>
<li>on ARM64，#</li>
<li>fence，#</li>
<li>misconceptions about，#，#</li>
<li>on x86-64，#</li>
</ul></li>
<li>shadowing，#</li>
<li>shared ownership，#
<ul>
<li>leaking，#</li>
<li>reference counting，#</li>
<li>statics，#</li>
</ul></li>
<li>shared references，#
<ul>
<li>mutating atomics through，#</li>
</ul></li>
<li>slim reader-writer locks (Windows)，#，#</li>
<li>spawning threads，#
<ul>
<li>failing to，#</li>
<li>happens-before relationship，#</li>
<li>scoped，#</li>
</ul></li>
<li>spin locks
<ul>
<li>building our own，#</li>
<li>cache lines，effect of，#</li>
<li>compare-and-exchange，(not) using，#</li>
<li>experiment，using wrong memory ordering，#</li>
<li>guard，#</li>
<li>memory ordering，#</li>
</ul></li>
<li>spin loop hint，#，#</li>
<li>spinning，#，#，#
<ul>
<li>avoiding accidental (reader-writer lock)，#</li>
</ul></li>
<li>splitting (borrowing)，#</li>
<li>spurious wake-ups，#，#，#</li>
<li>SRW locks (Windows)，#，#</li>
<li>stack size，#</li>
<li>starvation，#，#</li>
<li>static lifetime，#</li>
<li>statics，#</li>
<li>stlr (store-release register) instruction (ARM)，#</li>
<li>stlxr (store-release exclusive register) instruction (ARM)，#</li>
<li>stop flag，#</li>
<li>store buffers，#</li>
<li>store operations (atomic) (see load and store operations)</li>
<li>store-conditional (see load-linked/store-conditional)</li>
<li>str (store register) instruction (ARM)，#</li>
<li>stress，reducing，#</li>
<li>strongly ordered architecture，#</li>
<li>stxr (store exclusive register) instruction (ARM)，#</li>
<li>sub (subtract) instruction (x86)，#</li>
<li>swap operation (atomic)，#
<ul>
<li>locking using，#</li>
</ul></li>
<li>Sync trait，#，#
<ul>
<li>implementing for Arc，#</li>
<li>implementing for channel，#</li>
<li>implementing for mutex，#</li>
<li>implementing for reader-writer lock，#</li>
<li>implementing for spin lock，#</li>
<li>requirement by RwLock，#</li>
</ul></li>
<li>SYS_futex (Linux)，#
<ul>
<li>(see also futex)</li>
<li>arguments，#</li>
</ul></li>
<li>syscalls，#
<ul>
<li>avoiding，#，#</li>
</ul></li>
</ul>
<h3 id="t">T</h3>
<ul>
<li>–target (rustc)，#</li>
<li>teaching，#</li>
<li>thin air，out of，#</li>
<li>thread builder，#</li>
<li>thread name，#</li>
<li>Thread object，#
<ul>
<li>id，#</li>
<li>unpark，#，#</li>
</ul></li>
<li>thread parking，#，#，#，#
<ul>
<li>spurious wake-ups，#</li>
</ul></li>
<li>timeout，#
<ul>
<li>example，#</li>
</ul></li>
<li>thread safety，#，#
<ul>
<li>keeping objects on one thread，#</li>
</ul></li>
<li>ThreadId，#</li>
<li>threads，#
<ul>
<li>joining，#</li>
<li>panicking，#，#</li>
<li>returning a value，#</li>
<li>scoped，#</li>
<li>spawning，#</li>
</ul></li>
<li>thundering herd problem，#</li>
<li>time travel，#</li>
<li>timeout
<ul>
<li>condition variables，#</li>
<li>futex，#，#</li>
</ul></li>
<li>thread parking，#
<ul>
<li>example，#</li>
</ul></li>
<li>total modification order，#，#，#，#</li>
</ul>
<h3 id="u">U</h3>
<ul>
<li>uncontended (mutexes)，#，#
<ul>
<li>benchmarking，#</li>
</ul></li>
<li>undefined behavior，#
<ul>
<li>borrowing，#</li>
<li>data races，#</li>
<li>Miri，detecting with，#</li>
<li>time travel，#</li>
</ul></li>
<li>uninitialized memory，#</li>
<li>Unix systems
<ul>
<li>interfacing with the kernel，#</li>
<li>libc，role of，#</li>
</ul></li>
<li>unmovable
<ul>
<li>critical section (Windows)，#</li>
<li>Pin，#</li>
<li>pthread types，#</li>
<li>wrapping in Box，#</li>
</ul></li>
<li>unpark (Thread)，#</li>
<li>unparking (see thread parking)</li>
<li>unsafe code，#</li>
<li>unsafe functions，#</li>
<li>unsafe trait implementation，#</li>
<li>UnsafeCell，#，#，#
<ul>
<li>get_mut，#</li>
</ul></li>
<li>unsound，#</li>
</ul>
<h3 id="v">V</h3>
<ul>
<li>VecDeque，#</li>
</ul>
<h3 id="w">W</h3>
<ul>
<li>waiting (see blocking)</li>
<li>WaitOnAddress (Windows)，#</li>
<li>WakeByAddressAll (Windows)，#</li>
<li>WakeByAddressSingle (Windows)，#</li>
<li>Weak (see Arc; weak pointers)</li>
<li>weakly ordered architecture，#
<ul>
<li>experiment，using relaxed instead of release and acquire，#</li>
</ul></li>
<li>Windows，#
<ul>
<li>condition variables，#</li>
<li>critical section，#</li>
<li>FlushProcessWriteBuffers，#</li>
<li>interfacing with the kernel，#</li>
<li>kernel-managed objects，#</li>
<li>Native API，#</li>
<li>process-wide memory barrier，#</li>
<li>SRW locks，#，#</li>
</ul></li>
<li>WaitOnAddress，#</li>
<li>WakeByAddressAll，#</li>
<li>WakeByAddressSingle，#</li>
<li>Win32 API，#</li>
<li>windows crate，#</li>
<li>windows-sys crate，#</li>
<li>wrapping behavior (fetch_add and fetch_sub)，#
<ul>
<li>(see also overflows (atomic))</li>
</ul></li>
<li>wrapping unmovable object in Box，#</li>
<li>write-through cache coherence protocol，#</li>
<li>writer starvation，#，#</li>
</ul>
<h3 id="x">X</h3>
<ul>
<li>x86-64 (processor architecture)，#
<ul>
<li>other-multi-copy atomic，#</li>
<li>strongly ordered，#</li>
<li>x86_64-unknown-linux-musl target，#</li>
</ul></li>
<li>x86-64 instructions
<ul>
<li>add，#</li>
<li>and，#</li>
<li>btc (bit test and complement)，#</li>
<li>btr (bit test and reset)，#</li>
<li>bts (bit test and set)，#</li>
<li>cmpxchg (compare and exchange)，#</li>
<li>jne (jump if not equal)，#</li>
<li>lock prefix，#</li>
<li>mfence (memory fence)，#</li>
<li>mov (move)，#</li>
<li>or，#，#</li>
<li>overview，#</li>
<li>ret (return)，#</li>
<li>sub (subtract)，#</li>
<li>xadd (exchange and add)，#</li>
<li>xchg (exchange)，#，#</li>
<li>xor，#</li>
</ul></li>
<li>xadd (exchange and add) instruction (x86)，#</li>
<li>xchg (exchange) instruction (x86)，#，#</li>
<li>xor instruction (x86)，#</li>
</ul>
<h2 id="译注">译注</h2>
<table>
<thead>
<tr class="header">
<th>英文</th>
<th>中译</th>
<th>可能出现章节</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>allocation</td>
<td>内存分配</td>
<td>1、3、5、6、8、10</td>
</tr>
<tr class="even">
<td>atomic</td>
<td>原子</td>
<td>all</td>
</tr>
<tr class="odd">
<td>benchmark</td>
<td>基准测试</td>
<td>4、9</td>
</tr>
<tr class="even">
<td>borrow</td>
<td>借用</td>
<td>1、4、5</td>
</tr>
<tr class="odd">
<td>building block</td>
<td>基石</td>
<td>1、2、8、10</td>
</tr>
<tr class="even">
<td>cache coherence</td>
<td>缓存一致性</td>
<td>7</td>
</tr>
<tr class="odd">
<td>compare and exchange</td>
<td>比较并交换</td>
<td>3、4、6、9</td>
</tr>
<tr class="even">
<td>condition variable</td>
<td>条件变量</td>
<td>1、2、5、8、9</td>
</tr>
<tr class="odd">
<td>drop</td>
<td>丢弃</td>
<td>1、3、4、5、6、9</td>
</tr>
<tr class="even">
<td>fetch and modify</td>
<td>获取并修改</td>
<td>1、3</td>
</tr>
<tr class="odd">
<td>fence</td>
<td>屏障</td>
<td>3、6、7、8</td>
</tr>
<tr class="even">
<td>formalize</td>
<td>形式化的</td>
<td>3</td>
</tr>
<tr class="odd">
<td>guard</td>
<td>守卫</td>
<td>4、9</td>
</tr>
<tr class="even">
<td>happens-before</td>
<td>happens-before</td>
<td>3、4、5、6、7、9</td>
</tr>
<tr class="odd">
<td>Invalidation queue</td>
<td>失效队列</td>
<td>7</td>
</tr>
<tr class="even">
<td>leak</td>
<td>（内存）泄漏</td>
<td>1、3、5、8、10</td>
</tr>
<tr class="odd">
<td>load operation</td>
<td>load 操作</td>
<td>2、3、5、6、7、8、9</td>
</tr>
<tr class="even">
<td>lock（v）</td>
<td>锁定</td>
<td>all</td>
</tr>
<tr class="odd">
<td>memory ordering</td>
<td>内存排序</td>
<td>2、3、4、5、6、7、9</td>
</tr>
<tr class="even">
<td>mutex</td>
<td>互斥锁</td>
<td>1、2、3、4、8、9</td>
</tr>
<tr class="odd">
<td>mutation</td>
<td>可变性</td>
<td>1、2、4、6、8</td>
</tr>
<tr class="even">
<td>notify</td>
<td>通知</td>
<td>1、4、5、8、9</td>
</tr>
<tr class="odd">
<td>notify_all</td>
<td>notify all</td>
<td>9</td>
</tr>
<tr class="even">
<td>notify_one</td>
<td>notify one</td>
<td>9</td>
</tr>
<tr class="odd">
<td>park/block</td>
<td>阻塞</td>
<td>all</td>
</tr>
<tr class="even">
<td>pipeline</td>
<td>流水线</td>
<td>7</td>
</tr>
<tr class="odd">
<td>reader-writer lock</td>
<td>读写锁</td>
<td>1、3、4、8、9</td>
</tr>
<tr class="even">
<td>reader</td>
<td>reader</td>
<td>1、4、8、9、10</td>
</tr>
<tr class="odd">
<td>receiver</td>
<td>接收者</td>
<td>5</td>
</tr>
<tr class="even">
<td>reference</td>
<td>引用</td>
<td>all</td>
</tr>
<tr class="odd">
<td>spinLock</td>
<td>自旋锁</td>
<td>3、4、8、9</td>
</tr>
<tr class="even">
<td>sender</td>
<td>发送者</td>
<td>5</td>
</tr>
<tr class="odd">
<td>spurious</td>
<td>虚假的</td>
<td>1、2、5、8、9</td>
</tr>
<tr class="even">
<td>static</td>
<td>静态值</td>
<td>1</td>
</tr>
<tr class="odd">
<td>stop the world</td>
<td>停止其他活动</td>
<td>7</td>
</tr>
<tr class="even">
<td>store buffer</td>
<td>存储缓冲区</td>
<td>7</td>
</tr>
<tr class="odd">
<td>store operation</td>
<td>store 操作</td>
<td>2、3、5、6、7、8、9</td>
</tr>
<tr class="even">
<td>swap operation</td>
<td>swap 操作</td>
<td>2、3、5、6、7、8、9</td>
</tr>
<tr class="odd">
<td>syscall</td>
<td>系统调用</td>
<td>8、9</td>
</tr>
<tr class="even">
<td>unlock（v）</td>
<td>解锁</td>
<td>all</td>
</tr>
<tr class="odd">
<td>unpark</td>
<td>释放</td>
<td>all</td>
</tr>
<tr class="even">
<td>use cases</td>
<td>用例</td>
<td>all</td>
</tr>
<tr class="odd">
<td>wait(er)</td>
<td>等待（者）</td>
<td>all</td>
</tr>
<tr class="even">
<td>writer</td>
<td>writer</td>
<td>1、4、8、9、10</td>
</tr>
</tbody>
</table>      </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
