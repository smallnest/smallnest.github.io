<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="https://ashki23.github.io/styles.css">
         </head>
   <body>
            <div class="container">
         
         <h1
id="第九章构建我们自己的锁">第九章：构建我们自己的「锁」</h1>
<p>（<a href="https://marabos.nl/atomics/building-locks.html" target="_blank">英文版本</a>）</p>
<p>在该章节，我们将建造属于我们自己的互斥锁（<code>mutex</code>）<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>、条件变量（<code>condition variable</code>）<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>以及读写锁（<code>reader-writer lock</code>）<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>。对于它们中的任何一个，我们都会从一个非常基础的版本开始，然后逐步扩展它以使其更高效。</p>
<p>由于我们并不会使用来自标准库中的锁类型（因为这将是作弊行为），因此我们将不得不使用来自<a
href="./8_Operating_System_Primitives.md">第八章</a>的工具，才能够在不忙碌循环（<code>busy-looping</code><a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>）的情况下使线程等待。然而，正如我们在该章节了解的，不同操作系统提供的可用工具因平台而异，因此构建跨平台工作的东西颇具挑战性。</p>
<p>幸运地是，更多现代化操作系统都支持类似 <code>futex</code>
的功能，或者至少支持唤醒（<code>wake</code>）和等待（<code>wait</code>）操作。正如我们在<a
href="./8_Operating_System_Primitives.md">第八章</a>看到的，Linux 自从
2003 年就一直支持 futex 系统调用，Windows 自从 2012 年就支持
<code>WaitOnAddress</code> 系列函数，FreeBSD 自从 2016 年就将
<code>_umtx_op</code> 作为系统调用的一部分，等等。</p>
<p>最让人意外的是
macOS。尽管它的内核支持这些操作，但是它并没有暴露任意稳定、公共的 C
函数给我们使用。然而，macOS 附带了一个最新版本的
<code>libc++</code>（这是一个 C++ 标准库的实现）。该标准库包含对 C++20
的支持，该版本内置了非常基础对原子等待和唤醒操作（像
<code>std::atomic&lt;T&gt;::wait()</code>）。尽管由于各种原因，Rust
利用这些还非常的棘手，然而，这当然是可能的，这也可以让我们在 macOS
上访问基本的像 futex 的等待和唤醒功能。</p>
<p>我们将不再深入研究那些复杂的细节，而是选择利用 <code>crates.io</code>
的 <code>atomic-wait</code>
crate，为我们的「锁」原语提供基础的构建模块。该 crate
提供了三个函数：<code>wait()</code>、<code>wake_one()</code> 以及
<code>wake_all()</code>。它使用我们上面讨论的特定于平台规范的实现，为所有主要的平台实现了这些功能。这意味着我们只要坚持使用这三个函数，我们不再需要考虑任何平台的特定细节。</p>
<p>这些函数的行为就像我们在 Linux <a
href="./8_Operating_System_Primitives.md#Futex">第八章中的“Futex”</a>中实现的同名函数一样，不过让我们快速回顾一下如何工作的。</p>
<ul>
<li><p><em>wait(&amp;AtomicU32, u32)</em></p>
<p>该函数用于等待直到原子变量不再包含给定的值。如果原子变量中存储的值等于给定值，它将阻塞。当另一个线程修改了原子变量的值，该线程需要在同一原子变量上调用以下的任意一个唤醒函数，以将等待的线程从睡眠中唤醒。</p>
<p>该函数可能没有对应的唤醒操作，从而虚假地返回。因此，请确保在原子变量返回后检查其值，并在必要时重复
<code>wait()</code>。</p></li>
<li><p><em>wake_one(&amp;AtomicU32)</em></p>
<p>该函数将唤醒单个线程，其是当前在相同原子变量上通过
<code>wait()</code>
方法阻塞的线程。在修改原子变量后，立即使用它，以通知一个正在等待的线程该原子变量发生了变化。</p></li>
<li><p><em>wake_all(&amp;AtomicU32)</em></p>
<p>该函数将唤醒所有线程，其是当前在相同原子变量上通过
<code>wait()</code>
方法阻塞的线程。在修改原子变量后，立即使用它，以通知正在等待的线程该原子变量发生了变化。</p></li>
</ul>
<p>仅支持 32 位原子，因为在所有主要平台这是唯一受支持的大小。</p>
<blockquote>
<p>在<a
href="./8_Operating_System_Primitives.md#Futex">第八章中的“Futex”</a>中，我们讨论了一个最小示例，以展示这些函数在实践中是如何使用的。如果你已经忘记，请务必在继续之前查看该示例。</p>
</blockquote>
<p>为了使用 atomic-wait crate，在你的 <code>Cargo.toml</code>
中<strong>增加</strong> <code>atomic-wait="1"</code> 到
<code>[dependencies]</code>；或者运行
<code>cargo add atomic-wait@1</code>，这样也同样达到相同的目的。这三个函数在
crate 的根中定义，你可以使用
<code>atomic_wait::{wait, wake_one, wake_all};</code> 导入它们。</p>
<blockquote>
<p>当你阅读到这篇文章时，该 crate
可能有后续的可用版本，但该章节将使用主版本为 1
的构建。而后续的版本可能有不兼容的接口。</p>
</blockquote>
<p>现在，我们已经有基础的知识，让我们开始吧。</p>
<h2 id="mutex">Mutex</h2>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#mutex" target="_blank">英文版本</a>）</p>
<p>在构建 <code>Mutex&lt;T&gt;</code> 时，我们将参考来自<a
href="./4_Building_Our_Own_Spin_Lock.md">第四章</a>的
<code>SpinLock&lt;T&gt;</code>
类型。在不涉及阻塞的部分，例如守卫类型的设计，将保持不变。</p>
<p>让我们从类型定义开始。与自旋锁相比，我们必须做一个更改：而不是将
<code>AtomicBool</code> 设置为 <code>false</code> 或者
<code>true</code>，我们将使用 <code>AtomicU32</code>，将其设为 0 或者
1，所以我们可以将其与原子等待和唤醒函数一起使用。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Mutex<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 0: 解锁</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 1: 锁定</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> UnsafeCell<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>就像是自旋锁一样，我们也需要保证 <code>Mutex&lt;T&gt;</code>
可以在线程之间共享，即使它包含一个可怕的 <code>UnsafeCell</code>：</p>
<p>我们将<strong>增加</strong>一个 <code>MutexGuard</code>
类型，该类型实现了 <code>Deref</code>
trait，以提供一个完全安全的锁接口，就像我们在<a
href="./4_Building_Our_Own_Spin_Lock.md#使用锁守卫的安全接口">第四章：使用锁守卫的安全接口</a>：</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    mutex<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> Mutex<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Deref</span> <span class="cf">for</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Target <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deref(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span>T <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span><span class="kw">self</span><span class="op">.</span>mutex<span class="op">.</span>value<span class="op">.</span>get() <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">DerefMut</span> <span class="cf">for</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deref_mut(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="kw">mut</span> T <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="op">*</span><span class="kw">self</span><span class="op">.</span>mutex<span class="op">.</span>value<span class="op">.</span>get() <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>对于锁守卫类型的设计和操作，参见<a
href="./4_Building_Our_Own_Spin_Lock.md#使用锁守卫的安全接口">第四章：使用锁守卫的安全接口</a>。</p>
</blockquote>
<p>在我们进入有趣的部分之前，让我们也将 <code>Mutex::new</code>
函数拿出来。</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> Mutex<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> new(value<span class="op">:</span> T) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">,</span> <span class="co">// 解锁状态</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="pp">UnsafeCell::</span>new(value)<span class="op">,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//…</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>现在，我们已经完成了，然而还有剩下的两块未完成：锁定（<code>Mutex::lock()</code>）和解锁（为
<code>MutexGuard&lt;T&gt;</code> 的 <code>Drop</code>）。</p>
<p>我们为自旋锁实现的 lock
函数，使用了一个原子交换（<code>swap</code>）操作以试图去获取锁，如果它成功的将状态从“解锁”更改到“锁定”，则返回。如果未成功，它将立刻再次尝试。</p>
<p>为了锁定我们的
mutex，我们将做几乎相同的操作，除了在再次尝试之前，我们会使用
<code>wait()</code> 等待：</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> lock(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> MutexGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 设置 state 到 1：锁定</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>swap(<span class="dv">1</span><span class="op">,</span> Acquire) <span class="op">==</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 如果它已经锁定..</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// .. 等待，直到 state 不再是 1。</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>state<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        MutexGuard <span class="op">{</span> mutex<span class="op">:</span> <span class="kw">self</span> <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<blockquote>
<p>对于内存排序，与我们的自旋锁相同。对于该细节，可以参考：<a
href="https://marabos.nl/atomics/building-spinlock.html">第四章</a>。</p>
</blockquote>
<p>注意，仅有在我们调用它，state 仍设置为
1（锁定）时，<code>wait()</code> 函数才会阻塞，这样我们就不必担心在 swap
和 wait 调用之间失去唤醒调用的可能性。</p>
<p>守卫类型的 Drop 实现是负责解锁
mutex。解锁我们的自旋锁是简单的：仅需要设置 state 到
false（解锁锁）。然而，对于我们的 mutex
来说，这还不够。如果有一个线程等待锁定
mutex，除非我们使用唤醒操作通知它，否则它不会知道 mutex
已经被解锁。如果我们不唤醒它，它将更可能永远保持睡眠。（也许它很幸运，在正确的时间被虚假地唤醒（spurious
wake-up）<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>，但是我们不要指望这一点。）</p>
<p>因此，我们不仅将 state 设置回 0（解锁），而且还会在之后立即调用
<code>wake_one()</code>：</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 设置 state 回到 0：解锁。</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>mutex<span class="op">.</span>state<span class="op">.</span>store(<span class="dv">0</span><span class="op">,</span> Release)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 如果有，唤醒其中一个等待的线程。</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>mutex<span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>唤醒一个线程就足够了，因为即使有多个线程在等待，也仅有其中的一个线程能够认领锁。锁定它的下一个线程将在锁定完成后唤醒另一个线程，以此类推。同时唤醒多个线程，只会让这些线程感到不满，浪费宝贵的处理器时间，因为其中除了一个幸运的线程能够获取锁，其它线程都会在意识到自己失去机会后，从而再次进入休眠状态。</p>
<p>注意，我们不能保证唤醒的每一个线程都能抓住锁。其它线程可能仍然在它有机会之前立刻抓住锁。</p>
<p>这里做出的一个重要的观察是，如果没有等待和唤醒功能，这个 mutex
的实现在技术上仍然是正确的（即内存安全）。因为 <code>wait()</code>
操作可以虚假地唤醒，我们无法对他何时返回作出任何假设。我们仍然得去管理我们锁定原语的状态。如果我们移除等待和唤醒函数调用，我们的
mutex 将与我们的自旋锁状态基本相同。</p>
<p>一般来说，从内存安全方面，原子等待和唤醒函数从不会影响正确性。它们仅是一个（非常重要的）优化，以避免忙碌循环。这并不意味着由任何实际标准都无法使用的低效锁将是“正确的”，但是尝试去推理关于不安全的
Rust 代码时，这种见解可能是有帮助的。</p>
<div class="box">
<h2 style="text-align: center;">
Lock API
</h2>
<p>
如果你正在计划将实现 Rust
锁当作一个新的爱好，那么你可能很快对涉及提供安全接口的样板代码感到厌烦。也就是说，UnsafeCell、Sync
实现、守卫类型、Deref 实现等等。
</p>
<p>
crate.io 上的 <code>lock_api</code>
可以自动地去处理这些事情。你仅需要制作一个锁定状态的类型，并通过（不安全）<code>lock_api::RawMutex</code>
trait 提供（不安全）锁定和解锁功能。<code>lock_api::Mutex</code>
类型将根据你的锁实现，提供一个完全安全的和符合人体工学的 mutex
类型作为返回，包括 mutex 守卫。
</p>
</div>
<h3 id="避免系统调用">避免系统调用</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#mutex-avoid-syscalls" target="_blank">英文版本</a>）</p>
<p>到目前为止，我们 mutex
中最慢的部分是等待和唤醒，因为这（可能）导致一个<em>系统调用</em>，即对操作系统内核的调用。像这样与内核交互是一个相当复杂的过程，往往相当缓慢，尤其是与原子操作比较。因此，对于一个高性能
mutex 的实现，我们应该尽可能尝试去避免等待和唤醒调用。</p>
<p>幸运地是，我们已经走了一半。因为在 <code>wait()</code>
调用之前，我们的锁定函数 <code>while</code> 循环才会检查状态，因此在
mutex
未锁定的情况下，等待操作在这种情况下将完全地跳过，我们并不需要等待。然而，我们在解锁时，会无条件地调用
<code>wake_one()</code> 函数。</p>
<p>如果我们知道没有其它线程在等待，我们可以跳过
<code>wake_one()</code>。为了知道是否有等待线程，我们需要自己跟踪这些信息。</p>
<p>我们可以通过将“锁定”状态分割成两个单独的状态来完成这一点：“没有等待者的锁定”和“有等待者的锁定”。我们将使用值
1 和 2 做这些，并更新我们文档中结构体定义中的状态字段的注释。</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Mutex<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 0: 解锁</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 1: 锁定，没有其他线程等待</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 2: 锁定，有其他线程等待</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> UnsafeCell<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>现在，对于一个解锁的 mutex，我们的 lock 函数仍然需要将 state 设置为 1
才能锁定它。然而，如果它已经锁定，我们的 lock 函数需要在睡眠之前将 state
设置为 2，以便解锁（unlock）函数可以判断这有一个等待线程。</p>
<p>为了做到这一点，我们首先使用「比较并交换」函数，试图改变 state 从 0
到 1。如果成功，我们就已经锁定了
mutex，并且我们知道，这没有其它的等待者，因为 mutex
之前没有锁定。如果它失败了，那一定是因为 mutex 当前被锁定（在 state 为 1
或 2）。在这种情况下，我们将使用一个原子 swap 操作将其设置为 2。如果
swap 操作返回 1 或 2 的旧值，那这意味着 mutex
事实上仍然被锁定，并且仅有这样，我们才会使用 <code>wait()</code>
去阻塞，直到它改变。如果 swap 操作返回 0，这意味着我们通过改变它的 state
从 0 到 2 已经成功锁定 mutex。</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> lock(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> MutexGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed)<span class="op">.</span>is_err() <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>swap(<span class="dv">2</span><span class="op">,</span> Acquire) <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>state<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        MutexGuard <span class="op">{</span> mutex<span class="op">:</span> <span class="kw">self</span> <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>现在，我们解锁功能可以在必要时通过跳过 <code>wake_one()</code>
调用来利用新信息。我们现在使用 swap 操作，而不是仅仅存储一个 0 去解锁
mutex，这样我们就可以检查它之前的值。仅当值为 2
时，我们将继续唤醒一个线程：</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>mutex<span class="op">.</span>state<span class="op">.</span>swap(<span class="dv">0</span><span class="op">,</span> Release) <span class="op">==</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>            wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>mutex<span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>注意，将 state 设置回 0
后，它不再指示是否有任何其它的等待线程。唤醒的线程负责将 state 设置为
2，以确保没有任何其它的线程忘记。这是为什么在我们的 lock
函数中「比较并交换」操作不是我们 while 循环的一部分。</p>
<p>这确实意味着，每当线程在锁定时不得不
<code>wait()</code>，当解锁时，它将也调用
<code>wake_one()</code>。然而，更重要的是，<em>没有争议</em>的情况是，线程不试图同时获取锁的理想状况，这完全地避免了
<code>wait()</code> 和 <code>wake_one()</code> 调用。</p>
<p>图 9-1 展示了两个线程同时尝试锁定我们的 mutex 操作的情况下的
happens-before 关系。首先线程通过改变 state 从 0 到 1 锁定
mutex。此时，第二个线程将无法获取锁，并且在改变 state 从 1 到 2
后进入睡眠。当第一个线程解锁 mutex 时，它会交换 state 回 0。因为是
2，表示一个等待线程，它调用 <code>wake_one()</code>
来唤醒第二个线程。注意，我们不能依赖于唤醒和等待操作之间的任何
happens-before 关系。虽然唤醒操作可能是负责唤醒等待线程的操作，但
happens-before 关系是通过 <code>acquire</code> swap 操作建立的，观察
<code>release</code> swap 操作存储的值。</p>
<p><img
src="https://github.com/rustcc/Rust_Atomics_and_Locks/raw/main/picture/raal_0901.png" />
<em>图 9-1。同时试图锁定我们的 mutex 的两个线程之间 happens-before
的关系。</em></p>
<h3 id="进一步优化">进一步优化</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#optimizing-further" target="_blank">英文版本</a>）</p>
<p>在这一点上，我们似乎没有什么可以进一步优化的了。在无竞争的情况下，我们执行零系统调用，并且剩下的只是两个非常简单的原子操作。</p>
<p>避免等待和唤醒操作的唯一方式是回到我们的自旋锁实现。尽管自旋通常是非常低效的，但它至少避免了系统调用的潜在开销。唯一能提高自旋效率的情况是仅等待很短的时间。</p>
<p>对于锁定一个 mutex，自旋等待仅在以下情况有效：当前持有 mutex
锁的线程和想要锁定 mutex 的线程在不同的 CPU
核心上并行运行，并且当前线程只持有锁很短的时间。然而，这是一个非常常见的场景。</p>
<p>我们可以尝试将两种方法的优点结合起来，在调用 <code>wait()</code>
之前进行非常短暂的自旋。这样，如果锁被很快释放，我们根本不需要调用
<code>wait()</code>，但我们仍然避免了消耗其它线程更好利用的不合理的处理器时间。</p>
<p>实现这个仅需要改变我们的 lock 函数。</p>
<p>为了在无竞争的情况下尽可能保持性能，我们将在 lock
函数开始时保留原始的「比较并交换」操作。我们将使自旋等待作为一个单独的函数。</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> Mutex<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">//…</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> lock(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> MutexGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed)<span class="op">.</span>is_err() <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 锁已经被锁定。:(</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            lock_contended(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        MutexGuard <span class="op">{</span> mutex<span class="op">:</span> <span class="kw">self</span> <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> lock_contended(state<span class="op">:</span> <span class="op">&amp;</span>AtomicU32) <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//…</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在 <code>lock_contended</code>
中，在继续等待循环之前，我们可能简单地重复相同的「比较并交换」操作几百次。然而，一个「比较并交换」操作通常尝试去获取相关缓存行（cache
line）的独占访问（<a
href="./7_Understanding_the_Processor.md#mesi-协议">第七章 MESI
协议</a>），当重复执行时，这可能比简单的 load 操作更昂贵。</p>
<p>考虑到这一点，我们来到了以下 <code>lock_contented</code> 的实现：</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> lock_contended(state<span class="op">:</span> <span class="op">&amp;</span>AtomicU32) <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> spin_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> state<span class="op">.</span>load(Relaxed) <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> spin_count <span class="op">&lt;</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        spin_count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">std::hint::</span>spin_loop()<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state<span class="op">.</span>compare_exchange(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed)<span class="op">.</span>is_ok() <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> state<span class="op">.</span>swap(<span class="dv">2</span><span class="op">,</span> Acquire) <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        wait(state<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>首先，我们自旋最多 100 次，这是我们像在<a
href="./4_Building_Our_Own_Spin_Lock.md">第四章</a>时使用
<em><code>spin loop</code> 提示</em>。只要 mutex
没被锁定，并且没有等待者，我们就会自旋。如果另一个线程已经在等待，这意味着它放弃了自旋，因为它花费的时间太长，这可能表明自旋对这个线程也不是很有用。</p>
<blockquote>
<p>一百个周期的自旋时间大多数是任意选择的。迭代花费的时间和系统调用的时间长短（我们试图避免）很大程度上取决于平台。大范围的基准测试可以帮助我们选择一个正确的数字，但是不幸地是，没有一个准确的答案。</p>
<p>Rust 标准库的 <code>std::sync::Mutex</code> 的 Linux 实现（至少在
Rust 1.66.0 中）使用的是 100 次的自旋计数。</p>
</blockquote>
<p>锁定状态改变后，我们再次尝试将其设定为 1
来锁定它，然后我们再放弃并且开始自旋等待。正如我们之前讨论的，我们调用
<code>wait()</code> 后，我们不能再通过设定它的 state 到 1 来锁定
mutex，因为这可能导致其它的等待者被忘记。</p>
<div class="box">
<h2 style="text-align: center;">
Cold 和 Inline 属性
</h2>
<p>
你可以增加 <code>#[cold]</code> 属性到 <code>lock_contented</code>
函数定义，以帮助编译器理解在常见（无竞争）情况下不会调用这个函数，这有助<code>lock</code>
方法的优化。
</p>
<p>
此外，你也可以增加 <code>#[inline]</code> 属性到 Mutex 和 MutexGuard
方法，以通知编译器将其内联可能是一个好主意：将生成的指令将其放置在调用方法的地方。一般来说，是否能提高性能很难说，但对于这些非常小的函数，通常可以。
</p>
</div>
<h3 id="基准测试">基准测试</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#benchmarking" target="_blank">英文版本</a>）</p>
<p>测试 mutex
实现的性能是很难的。写基准测试和得到一些数字很容易，但是很难去得到一些有意义的数字。</p>
<p>优化 mutex
的实现以在特定基准测试表现良好是相对容易的，但这并没有很有用。毕竟，关键是去做一些在真实世界表现良好的东西，而不仅是在测试程序中。</p>
<p>我们将试图去写两个简单的基准测试，表明我们的优化至少对一些用例产生了一些积极影响，但请注意，任何结论在不同场景都不一定成立。</p>
<p>在我们的第一次测试中，我们将创建一个 Mutex
并在同一线程上锁定和解锁它几百万次，测量它所需的总时间。这是对简单无竞争场景的测试，其中永远没有任何需要唤醒的线程。希望这将向我们展示两状态和三状态版本的显著差异。</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">std::hint::</span>black_box(<span class="op">&amp;</span>m)<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> start <span class="op">=</span> <span class="pp">Instant::</span>now()<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">5_000_000</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>m<span class="op">.</span>lock() <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> duration <span class="op">=</span> start<span class="op">.</span>elapsed()<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;locked {} times in {:?}&quot;</span><span class="op">,</span> <span class="op">*</span>m<span class="op">.</span>lock()<span class="op">,</span> duration)<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>我们使用 <code>std::hint::black_box</code>（像我们在<a
href="./7_Understanding_the_Processor.md#对性能的影响">第七章“对性能的影响”</a>）去强制编译器假设有更多的代码去访问
mutex，阻止它优化循环或者锁定操作。</p>
</blockquote>
<p>结果将因硬件和操作系统不同而不同。在一台配备最新 AMD 处理器的特定
Linux 计算机上尝试，对于我们为优化的两状态的 mutex 花费时间大约
400ms，对于我们优化过后的三状态的 mutex 大约
40ms。一个因素获得十倍的性能提升！在另一个有着老式 Intel 处理器 Linux
计算机中，差异甚至更大：大约 1800ms 比上
60ms。这证实了，第三个状态的加入确实是一个非常大的优化。</p>
<p>然而，在 macOS 上运行，这会产生一个完全不同的结果：这两个版本大约都是
50ms，这展示了非常高的平台依赖性。</p>
<p>事实证明，我们在 macOS 上使用的 libc++ 的
<code>std::atomic&lt;T&gt;::wake()</code>
实现，已经进行了自己的内部管理，独立于内核，以避免不必要的系统调用。Windows
上的 <code>WakeByAddressSingle()</code> 也是如此。</p>
<p>避免调用这些函数仍然可能带来稍微更好的性能，因为它们的实现并非是微不足道的，尤其因为它们并不能在原子变量本身中存储任何信息。然而，如果我们的目标仅针对这些操作系统，我们将质疑在我们的
mutex 中<strong>增加</strong>第三个状态是否是值得的。</p>
<p>为了看看我们的自旋优化是否有任何积极的影响，我们需要一个不同的基准测试：一个有着大量竞争的测试，多个线程反复尝试去锁定一个已经上锁的
mutex。</p>
<p>让我们尝试一个场景，四个线程都尝试锁定和解锁 mutex 上百万次：</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">std::hint::</span>black_box(<span class="op">&amp;</span>m)<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> start <span class="op">=</span> <span class="pp">Instant::</span>now()<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>scope(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">4</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            s<span class="op">.</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">5_000_000</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                    <span class="op">*</span>m<span class="op">.</span>lock() <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> duration <span class="op">=</span> start<span class="op">.</span>elapsed()<span class="op">;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;locked {} times in {:?}&quot;</span><span class="op">,</span> <span class="op">*</span>m<span class="op">.</span>lock()<span class="op">,</span> duration)<span class="op">;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>注意，这是一个极端和不切实际的场景。mutex
仅能保留一个极短的时间（仅<strong>增加</strong>一个整数），并且在解锁后，线程将立刻试图再次锁定
mutex。不同的场景将导致非常不同的结果。</p>
<p>让我们像以前一样，在两台相同的 Linux
计算机上运行基准测试。在那台较旧的 Intel
处理器的计算机上，不使用自旋版本大约需要 900ms，而使用自旋版本大约需要
750ms。这是一个改进。而在那台新的 AMD
处理器计算机上，我们得到一个相反的结果：不使用自旋大约
650ms，而使用自旋大约需要 800ms。</p>
<p>总之，不幸的是，关于自旋是否真正提高性能的答案是“这取决于平台等”，即使只看一个场景。</p>
<h2 id="条件变量">条件变量</h2>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#condition-variable" target="_blank">英文版本</a>）</p>
<p>让我们做一些更有趣的事情：实现一个条件变量。</p>
<p>正如我们在<a
href="./1_Basic_of_Rust_Concurrency.md#条件变量">第一章“条件变量”</a>中见到的，条件变量与
mutex 一起使用，以等待受 mutex
保护的数据匹配某些条件。它有一个等待方法解锁
mutex，等待一个信号，并再次锁定相同的
mutex。通常由其它线程发送信号，在修改 mutex
保护的数据后立即发送给一个等待的线程（通常叫做“notify
one”或“signal”）或者通知所有等待的线程（通常叫做“notify
all”或“broadcast”）。</p>
<p>虽然条件变量试图让等待线程保持睡眠状态，直到它收到一个信号，但等待线程可能没有相应信号的情况下被虚假唤醒。然而，条件变量的等待操作在返回之前仍会重新锁定
mutex。</p>
<p>注意，此接口与我们的类 futex
<code>wait()</code>、<code>wake_one()</code> 以及
<code>wake_all()</code>
函数几乎相同。主要的不同是在于防止信号丢失的机制。条件变量在解锁 mutex
之前开始“监听”信号，以便不错过任何信号，而我们的 futex 风格的
<code>wait()</code>
函数依赖于原子变量状态的检查，以确保等待仍然是一个好的方式。</p>
<p>这导致了条件变量以下最小实现的想法：如果我们确保每个通知都更改原子变量（例如计数器），那么我们的
<code>Condvar::wait()</code> 方法需要做的就是在解锁 mutex
之前，检查该变量的值，并且在解锁它之后，传递它到 futex 风格的
<code>wait()</code> 函数。这样，如果自解锁 mutex
以来，收到任意通知信号，它将不再睡眠。</p>
<p>我们试试吧！</p>
<p>我们开始从 Condaver 结构体开始，该结构体仅包含单个 AtomicU32，我们用
0 初始化：</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Condvar <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    counter<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Condvar <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> new() <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span> counter<span class="op">:</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>) <span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//…</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>通知方法是简单的。它们仅需要改变 counter
以及使用相应的唤醒操作去通知任意的等待线程：</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> notify_one(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>counter)<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> notify_all(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        wake_all(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>counter)<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>（稍后我们会讨论内存排序）</p>
<p>等待方法将接收 <code>MutexGuard</code> 作为参数，因为它表示已锁定
mutex 的证明。它将也返回
<code>MutexGuard</code>，因为它要确保在返回之前，再次锁定 mutex。</p>
<p>正如我们之前概述的那样，该方法将首先检查 counter 当前的值，然后再解锁
mutex。解锁 mutex 之后，如果 counter
仍未改变，它将继续等待，以确保我们不会失去任意信号。以下是代码的内容：</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">pub</span> <span class="kw">fn</span> wait<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> guard<span class="op">:</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span>) <span class="op">-&gt;</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> counter_value <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>counter<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 通过丢弃 guard 解锁 mutex，</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 但要记住 mutex，以便稍后可以再次锁定它。</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mutex <span class="op">=</span> guard<span class="op">.</span>mutex<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        drop(guard)<span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 等待，但仅当 counter 自解锁以来仍为改变。</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>counter<span class="op">,</span> counter_value)<span class="op">;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        mutex<span class="op">.</span>lock()</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<blockquote>
<p>这里用了 MutexGuard 的私有 mutex 字段。Rust
中的私有性是基于模块的，所以如果你正在与 MutexGuard
不同的模块定义这个，则需要将 MutexGuard 的 mutex
字段标记如下，例如，<code>pub(crate)</code> 使其在 crate
中的其它模块可见。</p>
</blockquote>
<p>在我们成功的完成我们的条件变量之前，让我们开始考虑一下内存排序。</p>
<p>当 mutex 锁定时，没有其它线程可以改变受保护的 mutex
数据。因此，我们并不需要担心来自我们解锁 mutex
之前的通知，因为只要我们保持 mutex
锁定，数据就不会发生任何变化，这会让我们改变关于想要睡眠和等待的想法。</p>
<p>我们唯一感兴趣的情况是，我们释放 mutex 后，另一个线程出现并且锁定
mutex，改变受保护的数据，并且向我们发出信号（希望在解锁 mutex
之后）。</p>
<p>在这种情况下，在 <code>Condvar::wait()</code> 解锁 mutex
和在通知线程中锁定 mutex 之间有一个 happens-before
关系。该关系是确保我们的 Relaxed 加载（在解锁之前发生）会观察到通知的
Relaxed 自增操作（在锁定之后发生）之前的值。</p>
<p>我们并不知道 <code>wait()</code>
操作是否会看到在自增之前还是之后的值，因为此时没有任何东西可以保证排序。然而，这并不重要，因为
<code>wait()</code>
在相应的唤醒操作中具有原子性行为。要么它看见新值，在这种情况下，它根本不会进入睡眠，或者它看见旧值，在这种情况下，它会进入睡眠，并由来自通知中相应的
<code>wake_one()</code> 或者 <code>wake_all()</code> 唤醒。</p>
<p>图 9-2 展示了操作和 happens-before 关系，在这种情况下，一个线程使用
<code>Condvar::wait()</code> 等待一些受 mutex
保护的数据更改，并由第二个线程唤醒，该线程修改数据并且调用
<code>Condvar::wake_one()</code>。请注意，由于解锁和锁定操作，第一次
load 操作能够保证值递增之前观察到该值。</p>
<p><img
src="https://github.com/rustcc/Rust_Atomics_and_Locks/raw/main/picture/raal_0902.png" />
<em>图 9-2。一个线程使用 <code>Condvar::wait()</code> 被另一个使用
<code>Condvar::notify_one()</code> 的线程唤醒的操作和 happens-before
的关系。</em></p>
<p>我们应该也考虑如果 counter 溢出会发生什么。</p>
<p>只要每次通知之后计数器是不同的，它的真实值就无关紧要。不幸的是，在超过
40 亿个通知之后，计数器将溢出，并以 0
重新启动，回到之前使用过的值。从技术上讲，我们的
<code>Condvar::wait()</code>
实现可能在不应该的时候进入睡眠状态：如果它正好错过了 4,292,967,296
条通知（或者任意它的倍数），它会溢出计数器到它之前拥有过的值。</p>
<p>认为这种情况发生的可能性可以忽略不计是完全合理的。与我们在 mutex
锁定方法所做的事不同，我们不会在这里唤醒后，重新检查 state 和重复
<code>wait()</code> 调用，所以我们仅需要关心在 counter 的 relaxed load
操作和 <code>wait()</code>
调用之间的那一刻发生溢出往返（round-trip）。如果一个线程中断太久，以至于（确切地）允许发生许多通知，那么可能已经出现大问题，并且程序已经变得没有响应。此时，人们可能会合理地争辩到：线程保持睡眠的微小额外风险不再重要。</p>
<blockquote>
<p>在支持有时间限制的 futex
式等待的平台上，可以对等待操作使用几秒钟的超时来降低溢出的风险。发送 40
亿条通知将花费更长的时间，此时，额外的几秒钟的风险将产生非常小的影响。这完全消除了由于等待线程错误地一直待在睡眠状态而导致程序锁定的的任何风险。</p>
</blockquote>
<p>让我们看看它是否工作！</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> test_condvar() <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mutex <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> condvar <span class="op">=</span> <span class="pp">Condvar::</span>new()<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> wakeups <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>scope(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>mutex<span class="op">.</span>lock() <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            condvar<span class="op">.</span>notify_one()<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> m <span class="op">=</span> mutex<span class="op">.</span>lock()<span class="op">;</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">*</span>m <span class="op">&lt;</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>            m <span class="op">=</span> condvar<span class="op">.</span>wait(m)<span class="op">;</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>            wakeups <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(<span class="op">*</span>m<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 检查主线程是否确实等待（不是忙碌循环），</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 同时仍然允许一些虚假的唤醒。</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert!</span>(wakeups <span class="op">&lt;</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>我们计算条件变量从它的 wait
方法返回的次数，以确保它实际上进入了的睡眠。如果它返回的数值非常大，那就表明我们不小心自旋了。重要的是测试这个，因为从未睡眠的条件变量仍然会导致“正确的”行为，但会有效地将等待循环变成一个自旋循环。</p>
<p>如果我们运行这个测试，我们会看到它编译并顺利通过，确认我们的条件变量确实将我们的主线程置于睡眠状态。当然，这并不能证明它的实现是正确的。如果有必要，可以使用涉及多个线程的长时间压力测试，理想情况下，在弱序处理器架构的计算机上运行，以获得更多信心。</p>
<h3 id="避免系统调用2">避免系统调用2</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#avoiding-syscalls" target="_blank">英文版本</a>）</p>
<p>正如我们在<a
href="#避免系统调用">“Mutex：避免系统调用”</a>中的那样，优化一个锁定原语主要是避免不需要的等待和唤醒操作。</p>
<p>就我们的条件变量而言，在我们的 <code>Condvar::wait()</code>
实现中尝试避免 <code>wait()</code>
调用没有多大用处。当线程决定条件变量时，它已经检查了它正在等待的事情还没有发生，并且它需要进入睡眠。如果不需要等待，它根本就不用调用
<code>Condvar::wait()</code>。</p>
<p>然而，我们可以避免调用 <code>wake_one()</code> 和
<code>wake_all()</code> 调用，就像我们为 Mutex 所做的那样。</p>
<p>一个简单的方式是去保持跟踪正在等待线程的数量。我们的等待方法需要在等待之前递增，并且在完成的时候递减。然后如果跟踪的数值是
0，通知方法会跳过发送它们的信号。</p>
<p>所以，我们<strong>增加</strong>了一个新的字段到我们的
<code>Condvar</code> 结构体，以跟踪激活的等待者的数量：</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Condvar <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    counter<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    num_waiters<span class="op">:</span> AtomicUsize<span class="op">,</span> <span class="co">// 新增！</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Condvar <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> new() <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            counter<span class="op">:</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">,</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            num_waiters<span class="op">:</span> <span class="pp">AtomicUsize::</span>new(<span class="dv">0</span>)<span class="op">,</span> <span class="co">// 新增！</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">//…</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>通过将 AtomicUsize 用于 num_waiters，我们不必要担心它溢出。usize
是足够大的，能够计算内存中的每个字节，所以如果我们假设每个激活的线程占用至少内存的一个字节，它是绝对的足够大，能够计算任意数量的并发的存在线程。</p>
<p>下一步，我们更新我们的通知功能，如果没有等待线程，则什么也不做：</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> notify_one(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>num_waiters<span class="op">.</span>load(Relaxed) <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span> <span class="co">// 新增！</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>            wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>counter)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> notify_all(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>num_waiters<span class="op">.</span>load(Relaxed) <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span> <span class="co">// 新增！</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            wake_all(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>counter)<span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>（我们稍后会讨论内存排序）。</p>
<p>最后，最重要的是，我们在等待方法开始时递增它，并在它唤醒后立即递减：</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> wait<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> guard<span class="op">:</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span>) <span class="op">-&gt;</span> MutexGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>num_waiters<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span> <span class="co">// 新增！</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> counter_value <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>counter<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mutex <span class="op">=</span> guard<span class="op">.</span>mutex<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        drop(guard)<span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>counter<span class="op">,</span> counter_value)<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>num_waiters<span class="op">.</span>fetch_sub(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span> <span class="co">// 新增！</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        mutex<span class="op">.</span>lock()</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>我们应该再次仔细询问我们自己，对于所有这些原子操作，Relaxed
内存排序是否应该足够。</p>
<p>我们引入的一个新的潜在风险是，通知方法在 num_waiters 中观察到
0，跳过了它的唤醒操作，实际上却有一个线程需要唤醒。这种情况可能当通知方法在递增操作之前或者递减操作之后观察到值时发生。</p>
<p>就像从 counter 中的 relaxed load 操作一样，事实上，在递增 num_waiters
时，等待者将仍然持有 mutex，这确保了在解锁 mutex 之后发生的任何
num_waiters load 操作都不会看到它被递增之前的值。</p>
<p>我们也不需要担心通知线程观察到递减值“太快”，因为一旦执行递减操作，或许在虚假唤醒之后，等待线程不再需要被唤醒。</p>
<p>换句话说，mutex 建立的 happens-before
关系仍然提供了我们需要的所有保证。</p>
<h3 id="避免虚假唤醒">避免虚假唤醒</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#avoiding-spurious-wake-ups" target="_blank">英文版本</a>）</p>
<p>另一个方式是通过避免虚假唤醒来优化我们的条件变量。每次线程被唤醒时，它将尝试锁定
mutex，这可能与其它线程产生竞争，这可能在性能上有一个巨大的影响。</p>
<p>底层 <code>wait()</code>
操作偶尔会虚假唤醒是很罕见的，但是我们的条件变量实现很容易使得
<code>notify_one()</code>
导致不止一个线程去停止等待。如果一个线程正在进入睡眠的过程，刚刚加载了
counter 的值，但是仍然没有进入睡眠，那么调用 <code>notify_one()</code>
将由于更新的 counter 从而阻止线程进入睡眠状态，但也会因为后续的
<code>wake_one()</code> 操作导致第二个线程唤醒。这两个线程将先后竞争
mutex，浪费宝贵的处理器时间。</p>
<p>这听起来像是一个罕见的现象，但因为 mutex
最终同步线程的方式，这实际上很容易发生。在条件变量上调用
<code>notify_one()</code> 的线程最有可能在此之前立即锁定和解锁
mutex，以改变等待线程正在等待的数据的某些内容。这意味着，一旦
<code>Condvar::wait()</code> 方法解锁了
mutex，那就有可能立刻解除了正在等待 mutex
的通知线程的阻塞。此刻，这两个线程正在竞争：等待线程正在进入睡眠，通知线程正在锁定和解锁
mutex 并且通知条件变量。如果通知线程赢得竞争，等待线程将由于 counter
递增而不会进入睡眠，但是通知线程仍然调用
<code>wake_one()</code>。这正是上面描述的问题情况，它可能会不必要地唤醒一个额外线程。</p>
<p>一个相对简单的解决方案是跟踪允许唤醒的线程数量（即从
<code>Condvar::wait()</code> 返回）。<code>notify_one()</code>
方法会将其递增 1，并且如果它不是 0，等待方法会试图将其递减 1。如果
counter 是 0，它可以进入（返回）睡眠状态，而不是试图重新锁定 mutex
并且返回。（通知添加另一个专门用于 <code>notify_all</code>
的计数器来通知所有线程来完成，该 counter
永远不会<strong>减少</strong>。）</p>
<p>这种方式是有效的，但是带来一个新的、更微妙的问题：通知可能唤醒一个甚至还没有调用
<code>Condvar::wait()</code> 的线程，包括它自身。调用
<code>Condvar::notify_one()</code>
将<strong>增加</strong>应该唤醒的线程数量，并且使用
<code>wake_one()</code>
去唤醒一个等待线程。然而，如果在已经等待的线程有机会醒来之前，另一个（甚至相同的）线程随后调用
<code>Condvar::wait()</code>，新等待的线程可以看到一个通知待处理，并通过将
counter 递减到 0
来认领它，并立即返回。正在等待的第一个线程将返回睡眠状态，因为另一个线程已经获取了一个通知。</p>
<p>根据用例，这可能完全没有问题，也可能是一个大问题，导致一些线程永远无法取得进展。</p>
<blockquote>
<p>GNU libc 的 <code>pthread_cond_t</code>
的实现曾经受到这个问题影响。后来，经过大量关于 POSIX
规范是否允许的讨论，这个问题最后随着 2017 的 GNU libc 2.25
的发布而最终解决，这包含一个全新的条件变量实现。</p>
</blockquote>
<p>在很多使用条件变量的情况下，等待线程会抢走一个更早的通知。然而，当为一般类型而不是特定用例的类型实现条件变量时，该行为可能是不可接受的。</p>
<p>同样，我们必须得出结论，我们是否应该使用一个优化方式的答案是，不出意外的是，“这取决于平台等”。</p>
<blockquote>
<p>有一些方法去避免这个问题，同时仍然避免虚假唤醒，但这些方法要比其它方法复杂得多。</p>
<p>GNU libc
的新条件变量解决方案包括将等待线程分为两组，仅允许第一组去消费通知，并在第一组没有等待线程时交换组。</p>
<p>这种算法的一个缺点是，不仅是算法的复杂性，同时也显著<strong>增加</strong>条件变量类型的大小，因为它现在需要跟踪更多的信息。</p>
</blockquote>
<div class="box">
<h2 style="text-align: center;">
惊群问题（Thundering Herd Problem）
</h2>
<p>
当使用 notify_one()
唤醒正在等待很多相同事情的线程时，当使用条件变量时可能遇到的高性能问题。
</p>
<p>
问题是，在唤醒后，所有这些线程都将立即尝试锁定相同的
mutex。更可能地是，仅有一个线程将成功，并且所有其它线程都将回到睡眠状态。很多线程都急于宣称相同资源的资源浪费问题被称为<i>惊群问题</i>。
</p>
<p>
认为 <code>Condvar::notify_all()</code>
是从根本上不值得优化的反模式不是没有原因的。条件变量的目的是去解锁 mutex
并且当接受通知时重新锁定它，因此也许一次通知多个线程从来不是任何好主意。
</p>
<p>
即便如此，如果我们想针对这种情况进行优化，我们可以在支持类似 futex
<i>重新排队</i> 这种操作的操作系统上，例如在 Linux 上的
FUTEX_REQUEUE（参见<a href="./8_Operating_System_Primitives.html">第八章“Futex
操作”</a>）
</p>
<p>
与其唤醒许多线程，除一个线程外的其它线程一旦意识到锁已被占用都将立刻回到睡眠状态，我们可以将除一个线程外的其它所有线程<i>重新</i>排队，以便它们的
futex 等待操作不再等待条件变量的 counter，而是开始等待 mutex 的状态。
</p>
<p>
重新排队一个等待线程不会唤醒它。事实上，线程甚至不知道自己已经在重新排队。不幸地是，这可能导致一些非常细微的陷阱。
</p>
<p>
例如，还记得三状态 mutex
总是在唤醒后必须锁定到正确的状态（“有着等待线程的锁定”），以确保其它等待线程不会被遗忘？这意味着我们应该不在我们的
<code>Condvar::wait()</code> 实现中使用常规的 mutex 方法，这可能将 mutex
设置到一个错误的状态。
</p>
<p>
一个重新排队的条件变量实现需要存储等待线程使用的 mutex
的指针。否则，通知线程将不知道等待线程重新排队到哪个原子变量（互斥状态）。这就是为什么条件变量通常不允许两个线程去等待不同的
mutex。尽管许多条件变量的实现并未利用重新排队，但为未来版本保留利用此功能的可能性是有用的。
</p>
</div>
<h2 id="读写锁">读写锁</h2>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#reader-writer-lock" target="_blank">英文版本</a>）</p>
<p>是时候实现读写锁了。</p>
<p>回想一下，与互斥锁不同，读写锁支持两种类型的锁：读锁和写锁，有时称为共享锁定和排他性锁定。写锁的行为与锁定
mutex 相同，一次仅允许一个锁，而读锁则一次可以允许多个 reader
锁定。换句话说，它与 Rust
中的独占引用（<code>&amp;mut T</code>）和共享引用（<code>&amp;T</code>）密切相关，仅允许一个独占引用，或者任意数量的共享引用同时处于活动状态。</p>
<p>对于我们的
mutex，我们仅需要去跟踪它是否是锁定的。对于我们的读写锁，然而，我们也需要去知道当前持有多少个（读）锁，以确保所有写锁释放它们的锁后才会发生写锁。</p>
<p>让我们开始编写 <code>RwLock</code> 结构体，该结构体使用 AtomicU32
作为它的状态。我们将使用它去表示当前当前可获取的读锁数量，因此，值为 0
意味着它是未锁定的。为了表示写锁的 state，让我们使用一个特殊的值
<code>u32::MAX</code>。</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// reader 的数量，或者如果写锁定则是 u32::MAX。</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> UnsafeCell<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>对于我们的
<code>Mutex&lt;T&gt;</code>，我们必须限制它的同步实现，其类型 T 必须实现
<code>Send</code>，以确保它们不能将 <code>Rc</code>
发送到另一个线程。对于我们的新
<code>RwLock&lt;T&gt;</code>，我们还需要要求 T 也实现
<code>Sync</code>，因为多个 reader 将能够同时访问数据。</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Sync</span> <span class="cf">for</span> Rwlock<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">where</span> T<span class="op">:</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">{}</span></span></code></pre></div>
<p>因为我们的 RwLock
可以两种不同的方式锁定，我们将有两个单独的锁定函数，每个都有属于自己的守卫：</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> new(value<span class="op">:</span> T) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">,</span> <span class="co">// 解锁！</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="pp">UnsafeCell::</span>new(value)<span class="op">,</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> ReadGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// …</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> write(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> WriteGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// …</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> ReadGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    rwlock<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> WriteGuard<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    rwlock<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>写守卫应该表现得像一个排他性引用（<code>&amp;mut T</code>），我们通过为它实现
<code>Deref</code> 和 <code>DerefMut</code> 来实现这一点：</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Deref</span> <span class="cf">for</span> WriteGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Target <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deref(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span>T <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{&amp;*</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>value<span class="op">.</span>get()<span class="op">}</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">DerefMut</span> <span class="cf">for</span> WriteGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Target <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deref_mut(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span>T <span class="op">{</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{&amp;</span><span class="kw">mut</span> <span class="op">*</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>value<span class="op">.</span>get()<span class="op">}</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>然而，读守卫将仅实现 <code>Deref</code>，不用
<code>DerefMut</code>，因为它并不用独占数据的访问，这使它的行为像一个共享引用（<code>&amp;T</code>）：</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Deref</span> <span class="cf">for</span> ReadGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Target <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deref(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span>T <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{</span> <span class="op">&amp;*</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>value<span class="op">.</span>get() <span class="op">}</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>既然，我们已经摆出了样板代码，那让我们谈谈有趣的部分：锁定和解锁。</p>
<p>为了读取锁定我们的 <code>RwLock</code>，我们必须将 state
递增，但是前提它必须还没有写锁定。我们将使用一个「比较并交换」循环（<a
href="./2_Atomics.md#比较并交换操作">第二章“「比较并交换」操作”</a>）去做这些。如果
state 是 <code>u32::MAX</code>，这意味着 RwLock 是写锁，我们将使用一个
<code>wait()</code> 操作去睡眠并且稍后重试。</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> ReadGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">&lt;</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span> <span class="op">{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>                <span class="pp">assert!</span>(s <span class="op">!=</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span> <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;too many readers&quot;</span>)<span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange_weak(</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">,</span> s <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>                ) <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="cf">return</span> ReadGuard <span class="op">{</span> rwlock<span class="op">:</span> <span class="kw">self</span> <span class="op">},</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> s <span class="op">=</span> e<span class="op">,</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">==</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span> <span class="op">{</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>                wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>state<span class="op">,</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span>)<span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>写锁定是简单的；我们仅需要改变 state 从 0 到
<code>u32::MAX</code>，或者如果它已经锁定则是 <code>wait()</code>：</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> write(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> WriteGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">let</span> <span class="cn">Err</span>(s) <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange(</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span><span class="op">,</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        ) <span class="op">{</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 当它已锁定，则等待</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>            wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>state<span class="op">,</span> s)<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        WriteGuard <span class="op">{</span> rwlock<span class="op">:</span> <span class="kw">self</span> <span class="op">}</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>注意，锁定的 <code>RwLock</code> 确切 state 值是如何变化的，但是
<code>wait()</code> 操作希望我们给它一个确切的值去与 state
比较。这是为什么我们将来自「比较并交换」操作的返回值用于
<code>wait()</code> 操作。</p>
<p>解锁 reader 涉及到递减 state。最终解锁 RwLock 的 reader，会将 state
从 1 改变到 0，负责唤醒等待的 writer（如果有的话）。</p>
<p>仅唤醒一个线程就足够了，因为我们知道目前没有任何正在等待的
reader。reader 根本没有理由正在等待一个读锁定的 RwLock。</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> ReadGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state<span class="op">.</span>fetch_sub(<span class="dv">1</span><span class="op">,</span> Release) <span class="op">==</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 如果有，唤醒一个等待的 writer。</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>            wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>writer 必须重设 state 到 0 以解锁，之后它应该唤醒一个等待的 writer
或者所有正在等待的 writer。</p>
<p>我们并不知道 reader 或者 writer 正在等待，我们也没有办法去唤醒一个
writer 或者只唤醒 reader。所以，我们只需要唤醒所有的线程：</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> WriteGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state<span class="op">.</span>store(<span class="dv">0</span><span class="op">,</span> Release)<span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 唤醒所有等待的 reader 和 writer。</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        wake_all(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>仅此而已！我们建立了一个非常简单但完全可用的读写锁。</p>
<p>是时候解决一些问题了。</p>
<h3 id="避免-writer-忙碌循环">避免 writer 忙碌循环</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#avoiding-busy-looping-writers" target="_blank">英文版本</a>）</p>
<p>我们实现的一个问题是写锁可能导致意外地忙碌循环。</p>
<p>如果我们有一个很多 reader 重复锁定和解锁的
RwLock，那么锁定状态可能会持续变化，上下快速波动。对于我们的
<code>write</code> 方法，这导致了在「比较并交换」操作和随后的
<code>wait()</code> 操作之间发生锁定状态的变化可能很大，尤其
<code>wait()</code> 操作作为（相对缓慢的）系统调用直接实现。这意味着
<code>wait()</code> 操作将立即返回，即使锁从未解锁；它只是 reader
数量与预期的不同。</p>
<p>解决方案是使用一个不同的 AtomicU32
让等待者去等待，并且仅有在我们真正想唤醒 writer 时，才改变原子的值。</p>
<p>让我们尝试这个，通过<strong>增加</strong>一个新的
<code>writer_wake_counter</code> 字段到我们的 RwLock：</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// reader 的数量，或者如果写锁定，则是 u32::MAX。</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 唤醒 writer 的数量。</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    writer_wake_counter<span class="op">:</span> AtomicU32<span class="op">,</span> <span class="co">// 新增！</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> UnsafeCell<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> new(value<span class="op">:</span> T) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>            state<span class="op">:</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">,</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>            writer_wake_counter<span class="op">:</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">,</span> <span class="co">// 新增！</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="pp">UnsafeCell::</span>new(value)<span class="op">,</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// …</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>read</code> 方法仍然保留未改变，但是 <code>write</code>
方法现在需要等待新的原子变量。为了确保我们在看到 RwLock
被读锁定和实际进入睡眠之间不失去任何通知，我们将使用类似于实现条件变量的模式：在检查我们是否仍然想要睡眠之前，检查
<code>writer_wake_counter</code>：</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> write(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> WriteGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange(</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span><span class="op">,</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        )<span class="op">.</span>is_err() <span class="op">{</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> w <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>writer_wake_counter<span class="op">.</span>load(Acquire)<span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed) <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 如果 RwLock 仍然锁定，但前提是</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 自从我们检查以来仍然没有唤醒信号，则等待。</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>                wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>writer_wake_counter<span class="op">,</span> w)<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        WriteGuard <span class="op">{</span> rwlock<span class="op">:</span> <span class="kw">self</span> <span class="op">}</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>writer_wake_counter 的 <code>Acquire</code> load 操作将与
<code>Release</code> 递增操作形成一个 happens-before
关系，该操作在解锁状态后立即执行，然后唤醒等待的 writer：</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> ReadGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state<span class="op">.</span>fetch_sub(<span class="dv">1</span><span class="op">,</span> Release) <span class="op">==</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Release)<span class="op">;</span> <span class="co">// 新增！</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>            wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter)<span class="op">;</span> <span class="co">// 改变!</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>happens-before 关系确保 write 方法不能观察到递增的
writer_wake_counter
值，而之后仍然看到尚未<strong>减少</strong>的状态值。否则，写锁定的线程可能认为
<code>RwLock</code> 仍然被锁定，而错过唤醒通知。</p>
<p>正如之前的一样，写解锁应该唤醒一个 writer 或者所有等待的
reader。由于我们仍然不知道是否有 writer 或者 reader
正在等待，我们不得不唤醒一个等待的 writer（通过 wake_one）和所有等待的
reader（使用 wake_all）：</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> WriteGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state<span class="op">.</span>store(<span class="dv">0</span><span class="op">,</span> Release)<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Release)<span class="op">;</span> <span class="co">// 新增！</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter)<span class="op">;</span> <span class="co">// 新增！</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        wake_all(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>在一些操作系统中，唤醒操作背后的操作会返回它唤醒的线程数量。它可能表示低于唤醒线程实际数量的个数（由于虚假唤醒），但是它的返回值仍然可以用于优化。</p>
<p>在以上的 <code>drop</code> 实现中，例如，如果 <code>wake_one()</code>
操作表明它实际唤醒了一个线程，我们可以跳过 <code>wake_all()</code>
调用。</p>
</blockquote>
<h3 id="避免-writer-陷入饥饿">避免 writer 陷入饥饿</h3>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#avoiding-writer-starvation" target="_blank">英文版本</a>）</p>
<p>RwLock 的一个通常用例是频繁使用 reader
的情况，但是非常少（通常仅有一个）不经常的 writer
的情况。例如，一个线程可能负责读取一些传感器输入或者定期下载许多其它线程需要使用的新数据。</p>
<p>在这种情况下，我们很快就会遇到一个叫做 <em>writer
饥饿</em>的问题：一种情况是，writer 从未得到一个机会去锁定
RwLock，因为周围总是有 reader 保持 <code>RwLock</code> 读锁定。</p>
<p>一个解决方式是去防止任何新的 reader 在有 writer 时取得锁，即使 RwLock
仍然是读锁定。这样，所有新的 reader 都将等待直到轮到 writer，这确保了
reader 将获取到 writer 想要共享的最新的数据。</p>
<p>让我们实现这个。</p>
<p>为了完成这个，我们需要跟踪是否有任意的等待 writer。为了在 state
变量中为这些信息腾出空间，我们可以将 reader 的数量乘以 2，并且有 writer
等待的情况下加 1。这意味着 6 或者 7 的 state 都表示有 3 个激活的 read
锁定的情况：6 没有一个等待的 writer，7 有一个等待的 writer。</p>
<p>如果我们将
<code>u32::MAX</code>（这是一个奇数）保持为写锁定的状态，那么如果 state
是奇数，那么 reader 将必须等待。但是如果 state 是偶数，reader
就可以通过递增 2 它来获取一个读锁。</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> RwLock<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 读锁的数量乘以 2，如果有一个 writer 正在等待，则加 1。</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 如果已写锁定，则是 u32::MAX。</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 这意味着当 state 是偶数时，reader 可能获取锁，</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 但当 state 是奇数时，则是需要阻塞</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    state<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 唤醒 writer 的数量。</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    writer_wake_counter<span class="op">:</span> AtomicU32<span class="op">,</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> UnsafeCell<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>我们必须更改我们 <code>read</code> 方法中的两个 <code>if</code>
语句，不再将 state 与 <code>u32::MAX</code> 进行比较，而是检查 state
是否是偶数还是奇数。我们还需要以确保我们<strong>增加</strong> 2 而不是 1
来锁定。</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> ReadGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span> <span class="co">// 偶数</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>                <span class="pp">assert!</span>(s <span class="op">!=</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span> <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> <span class="st">&quot;too many readers&quot;</span>)<span class="op">;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange_weak(</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">,</span> s <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>                ) <span class="op">{</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="cf">return</span> ReadGuard <span class="op">{</span> rwlock<span class="op">:</span> <span class="kw">self</span> <span class="op">},</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> s <span class="op">=</span> e<span class="op">,</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">{</span> <span class="co">// 奇数</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>                wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>state<span class="op">,</span> s)<span class="op">;</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>我们的 write
方法必须经历更大的改变。我们将使用一个「比较并交换」循环，就像我们上面的
read 方法那样。如果 state 是 0 或者 1，这意味着 RwLock
是解锁的，我们将试图去改变 state 到 <code>u32::MAX</code>
以写锁定它。否则，我们将不得不等待。然而，在这样做之前，我们需要确保
state 是奇数，以停止新的 reader 获取锁。在确保 state 是奇数后，我们等待
<code>writer_wake_counter</code>
变量，同时需要确保锁在此期间一直没有解锁。</p>
<p>在代码中，这看起来像：</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> write(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> WriteGuard<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 如果解锁，尝试去锁定。</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">&lt;=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange(</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">,</span> <span class="dt">u32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">,</span> Acquire<span class="op">,</span> Relaxed</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>                ) <span class="op">{</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="cf">return</span> WriteGuard <span class="op">{</span> rwlock<span class="op">:</span> <span class="kw">self</span> <span class="op">},</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="op">{</span> s <span class="op">=</span> e<span class="op">;</span> <span class="cf">continue</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 通过确保 state 是奇数，阻塞新的 reader。</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>compare_exchange(</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">,</span> s <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> Relaxed<span class="op">,</span> Relaxed</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>                ) <span class="op">{</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="op">{}</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="op">{</span> s <span class="op">=</span> e<span class="op">;</span> <span class="cf">continue</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 如果它仍然锁定，则等待。</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> w <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>writer_wake_counter<span class="op">.</span>load(Acquire)<span class="op">;</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s <span class="op">&gt;=</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>                wait(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>writer_wake_counter<span class="op">,</span> w)<span class="op">;</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>state<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>因为我们现在跟踪是否有任意等待的
writer，读解锁现在可以在不需要的时候跳过 <code>wake_one()</code>
调用：</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> ReadGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 将 state 递减 2，以移除一个读锁。</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state<span class="op">.</span>fetch_sub(<span class="dv">2</span><span class="op">,</span> Release) <span class="op">==</span> <span class="dv">3</span> <span class="op">{</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 如果我们从 3 减少到 1，那意味着 RwLock</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 现在是解锁状态，*并且*有一个等待的 writer。</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 我们会唤醒它。</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Release)<span class="op">;</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>            wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter)<span class="op">;</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>当写锁定（state 是
<code>u32::MAX</code>）时，我们并不跟踪任何关于是否有线程正在等待的的信息。所以，我们没有用于用于写解锁的的新信息，这些将保持不变：</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Drop</span> <span class="cf">for</span> WriteGuard<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state<span class="op">.</span>store(<span class="dv">0</span><span class="op">,</span> Release)<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Release)<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        wake_one(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>writer_wake_counter)<span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        wake_all(<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>rwlock<span class="op">.</span>state)<span class="op">;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>对于针对“频繁读和频繁写”用例进行优化的读写锁，这是完全可以接受的，因为写锁定（并且因此写解锁）很少发生。</p>
<p>然而，对于更普遍目的的读写锁定，这绝对是值得进一步优化的，这使写锁定和解锁的性能接近于高效的三状态的互斥锁性能。这对读者来说是一个有趣的练习。</p>
<h2 id="总结">总结</h2>
<p>（<a href="https://marabos.nl/atomics/building-locks.html#summary" target="_blank">英文版本</a>）</p>
<ul>
<li>atomic-wait crate 提供了一个基础的类 futex
功能，适用于所有主要的操作系统（最新版本）。</li>
<li>一个最小的实现仅需要两个状态，像我们来自<a
href="./4_Building_Our_Own_Spin_Lock.md">第四章</a>的
<code>SpinLock</code>。</li>
<li>一个更有效的 mutex
追踪是否有任何的等待线程，所以它可以避免一个不需要的唤醒操作。</li>
<li>在进行睡眠之前自旋可能对一些用例是有益的，但这很大程度取决于情况、操作系统和硬件。</li>
<li>一个最小的条件变量的实现仅需要一个通知
counter，<code>Condvar::wait()</code> 将不得不在解锁 mutex
之前和之后检查。</li>
<li>条件变量可能跟踪等待线程的数量，以避免不需要的唤醒操作。</li>
<li>避免从 <code>Condvar::wait</code>
虚假唤醒可能很棘手，需要额外的内部管理。</li>
<li>一个最小的读写锁仅需要一个原子计数作为状态。</li>
<li>一个额外的原子变量可以用于独立于 reader 唤醒 writer。</li>
<li>为了避免 writer 饥饿，需要额外的状态优先考虑一个等待的 writer
而不是新的 reader。</li>
</ul>
<p style="text-align: center; padding-block-start: 5rem;">
<a href="./10_Ideas_and_Inspiration.html">下一篇，第十章：理念和灵感</a>
</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/惊群问题"
class="uri">https://zh.wikipedia.org/wiki/惊群问题</a></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://zh.wikipedia.org/wiki/互斥锁"
class="uri">https://zh.wikipedia.org/wiki/互斥锁</a><a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://zh.wikipedia.org/zh-cn/監視器_(程序同步化)"
class="uri">https://zh.wikipedia.org/zh-cn/監視器_(程序同步化)</a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://zh.wikipedia.org/wiki/读写锁"
class="uri">https://zh.wikipedia.org/wiki/读写锁</a><a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://zh.wikipedia.org/wiki/忙碌等待"
class="uri">https://zh.wikipedia.org/wiki/忙碌等待</a><a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn5"><p>虚假唤醒是一个线程在没有收到明确的信号的情况下，从等待状态中被唤醒<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>      </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
