<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="https://ashki23.github.io/styles.css">
         </head>
   <body>
            <div class="container">
         
         <h1 id="第二章atomic">第二章：Atomic</h1>
<p>（<a href="https://marabos.nl/atomics/atomics.html" target="_blank">英文版本</a>）</p>
<p><em>原子</em>（atomic）这个单词来自于希腊语
<code>ἄτομος</code>，意味着不可分割的，不能被切割成更小的块。在计算机科学中，它被用于描述一个不可分割的操作：它要么完全完成，要么还没发生。</p>
<p>正如在<a
href="./1_Basic_of_Rust_Concurrency.md#借用和数据竞争">第一章“借用和数据竞争”</a>中提及的，多线程并发地读取和修改相同的变量会导致未定义行为。然而，原子操作确实允许不同线程去安全地读取和修改相同的变量。因为该操作是不可分割的，它要么完全地在一个操作之前完成，要么在另一个操作之后完成，从而避免未定义行为。稍后，在<a
href="./7_Understanding_the_Processor.md">第七章</a>，我们将在硬件层面查看它们是如何工作的。</p>
<p>原子操作是任何涉及多线程的主要基石。所有其它的并发原语，例如互斥锁，条件变量都使用原子操作实现。</p>
<p>在 Rust 中，原子操作可以作为 <code>std::sync::atomic</code>
标准原子类型的方法使用。它们的名称都以 Atomic 开头，例如 AtomicI32 或
AtomicUsize。可用的原子类型取决于硬件架构和一些操作系统，但几乎所有的平台都提供了指针大小的所有原子类型。</p>
<p>与大多数类型不同，它们允许通过共享引用进行修改（例如，<code>&amp;AtomicU8</code>）。正如<a
href="./1_Basic_of_Rust_Concurrency.md#内部可变性">第一章“内部可变性”</a>讨论的那样，这都要归功于它。</p>
<p>每一个可用的原子类型都有着相同的接口，包括存储（store）和加载（load）、原子“获取并修改（fetch-and-modify）”操作方法、和一些更高级的“比较并交换”（compare-and-exchange）<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>方法。我们将在这章节的后半部分讨论它们。</p>
<p>但是，在我们研究不同原子操作之前，我们需要简要谈谈叫做<em>内存排序</em><a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>的概念：</p>
<p>每一个原子操作都接收 <code>std::sync::atomic::Ordering</code>
类型的参数，这决定了我们对操作相对排序的保证。保证最少的简单变体是
<code>Relaxed</code>。<code>Relaxed</code>
只保证在单个原子变量中的一致性，但是在不同变量的相对操作顺序没有任何保证。</p>
<p>这意味着两个线程可能看到不同变量的操作以不同的顺序下发生。例如，如果一个线程首先写入一个变量，然后非常快速的写入第二个变量，另一个线程可能看见这以相反的顺序发生。</p>
<p>在这章节，我们将仅关注不会出现这种问题的使用情况，并且在所有地方都简单地使用
<code>Relaxed</code>，而不深入讨论更多细节。我们将在<a
href="./3_Memory_Ordering.md">第三章</a>讨论内存排序的所有细节以及其它可用内存排序。</p>
<h2 id="atomic-的加载和存储操作">Atomic 的加载和存储操作</h2>
<p>（<a href="https://marabos.nl/atomics/atomics.html#atomic-load-and-store-operations" target="_blank">英文版本</a>）</p>
<p>我们将查看的前两个原子操作是最基本的：load 和
store。它们的函数签名如下，使用 AtomicI32 作为示例：</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> AtomicI32 <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> load(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> store(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> value<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering)<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>load 方法以原子方式加载存储在原子变量中的值，并且 store
方法原子方式存储新值。注意，store
方法采用共享引用（<code>&amp;T</code>），而不是独占引用（<code>&amp;mut T</code>），即使它修改了值。</p>
<p>让我们来看看这两种方式的使用示例。</p>
<h3 id="示例停止标识">示例：停止标识</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-stop-flag" target="_blank">英文版本</a>）</p>
<p>第一个示例使用 AtomicBool
作为<em>停止标识</em>。这个标识被用于告诉其它线程去停止运行：</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span>AtomicBool<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::Ordering::</span>Relaxed<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> STOP<span class="op">:</span> AtomicBool <span class="op">=</span> <span class="pp">AtomicBool::</span>new(<span class="cn">false</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 产生一个线程，去做一些工作。</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> background_thread <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">!</span>STOP<span class="op">.</span>load(Relaxed) <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            some_work()<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 使用主线程监听用户的输入。</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> <span class="pp">std::io::</span>stdin()<span class="op">.</span>lines() <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> line<span class="op">.</span>unwrap()<span class="op">.</span>as_str() <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;help&quot;</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;commands: help, stop&quot;</span>)<span class="op">,</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;stop&quot;</span> <span class="op">=&gt;</span> <span class="cf">break</span><span class="op">,</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            cmd <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;unknown command: {cmd:?}&quot;</span>)<span class="op">,</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 告知后台线程需要停止。</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    STOP<span class="op">.</span>store(<span class="cn">true</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 等待直到后台线程完成。</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    background_thread<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在本示例中，后台线程反复地运行
<code>some_work()</code>，而主线程允许用户输入一些命令与其它线程交互程序。在这个示例中，唯一有用的命令是
<code>stop</code>，来使程序停止。</p>
<p>为了使后台线程停止，原子 <strong>STOP</strong>
布尔值使用此条件与后台线程交互。当前台线程读取到 <code>stop</code>
命令，它设置标识到
true，在每次新迭代之前，后台线程都会检查。主线程等待直到后台线程使用
join 方法完成它当前的迭代。</p>
<p>只要后台线程定期检查标识，这个简单的工作方案就是好的。如果它在
<code>some_work()</code> 卡住很长时间，这可能在 stop
命令和程序退出之间出现不可接受的延迟。</p>
<h3 id="示例进度报道">示例：进度报道</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-progress-reporting" target="_blank">英文版本</a>）</p>
<p>在我们的下一个示例中，我们通过后台线程逐步地处理 100
个元素，而主线程为用户提供定期地更新：</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span>AtomicUsize<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> num_done <span class="op">=</span> <span class="pp">AtomicUsize::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>scope(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 一个后台线程，去处理所有 100 个元素。</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">100</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                process_item(i)<span class="op">;</span> <span class="co">// 假设该处理需要一些时间。</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                num_done<span class="op">.</span>store(i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 主线程没秒展示一次状态更新。</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> n <span class="op">=</span> num_done<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> n <span class="op">==</span> <span class="dv">100</span> <span class="op">{</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Working.. {n}/100 done&quot;</span>)<span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Done!&quot;</span>)<span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这次，我们使用一个<a
href="./1_Basic_of_Rust_Concurrency.md#作用域内的线程">作用域内的线程</a>，它将自动地为我们处理线程的
join，并且也允许我们借用局部变量。</p>
<p>每次后台线程完成处理元素时，它都会将处理的元素数量存储在 AtomicUsize
中。与此同时，主线程向用户显示该数字，告知该进度，大约每秒一次。一旦主线程看见所有
10 个元素已经被处理，它就会退出作用域，它会隐式地 join
后台线程，并且告知用户所有都完成。</p>
<h4 id="同步">同步</h4>
<p>（<a href="https://marabos.nl/atomics/atomics.html#synchronization" target="_blank">英文版本</a>）</p>
<p>一旦最后一个元素处理完成，主线程可能需要整整一秒才知道，这在最后引入了不必要的延迟。为了解决这个问题，我们在每当有新的消息有用时，使用线程阻塞（<a
href="./1_Basic_of_Rust_Concurrency.md#线程阻塞">第一章“线程阻塞”</a>）去唤醒睡眠中的主线程。</p>
<p>以下是相同的示例，但是现在使用 <code>thread::park_timeout</code>
而不是 <code>thread::sleep</code>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> num_done <span class="op">=</span> <span class="pp">AtomicUsize::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> main_thread <span class="op">=</span> <span class="pp">thread::</span>current()<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>scope(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// // 一个后台线程，去处理所有 100 个元素。</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">100</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                process_item(i)<span class="op">;</span> <span class="co">// 假设该处理需要一些时间。</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                num_done<span class="op">.</span>store(i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                main_thread<span class="op">.</span>unpark()<span class="op">;</span> <span class="co">// 唤醒主线程</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 主线程展示的状态更新</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> n <span class="op">=</span> num_done<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> n <span class="op">==</span> <span class="dv">100</span> <span class="op">{</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Working.. {n}/100 done&quot;</span>)<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>park_timeout(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Done!&quot;</span>)<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>没有什么变化，我们通过 <code>thread::current()</code>
获取主线程的句柄，该句柄现在被用于在每次后台线程状态更新后，阻塞主线程。主线程现在使用
park_timeout 而不是 sleep，这样它就可以被中断。</p>
<p>现在，任何状态更新都会立即告知用户，同时仍然每秒重复上一次更新，以展示程序仍然在运行。</p>
<h3 id="示例惰性初始化">示例：惰性初始化</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-lazy-init" target="_blank">英文版本</a>）</p>
<p>在移动到更高级的原子操作之前，我们来看最后一个关于<em>惰性初始化</em>的示例。</p>
<p>想象有一个值
x，我们可以从一个文件读取它、从操作系统获取或者以其他方式计算得到，我们期待去在程序运行期间它是一个常量。或许
x 是操作系统的版本、内存的总数或者 tau 的第 400
位。对于这个示例，这不重要。</p>
<p>因为我们不期待它去发生变化，我们仅在第一次请求或计算时需要它，并且记住它的结果。需要它的第一个线程必须计算值，但它可以存储它到一个
<code>static</code> 的原子中，使所有线程可用，包括稍后的自己。</p>
<p>让我们看看这个示例。为了使这些简单，我们将假设 x 永远不会是
0，这样我们就可以在计算之前使用 0 作为占位符。</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span>AtomicU64<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> get_x() <span class="op">-&gt;</span> <span class="dt">u64</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> X<span class="op">:</span> AtomicU64 <span class="op">=</span> <span class="pp">AtomicU64::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> X<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> calculate_x()<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        X<span class="op">.</span>store(x<span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>第一个线程调用 <code>get_x()</code> 将检查 <code>static X</code>
并看见它仍然是 0，计算它的值并且存回结果到 static X
中，使它在未来可用。稍后，任意对 <code>get_x()</code>
的调用都将看见静态值不是 0，并立即返回，没有立即计算。</p>
<p>然而，如果第二个线程调用
<code>get_x()</code>，而第一个线程仍然正在计算 x，第二个线程将也看见
0，并且也在并行的计算
x。其中一个线程将最后复写另一个线程的结果，这取决于哪一个线程先完成。这被叫做<em>竞争</em>。并不是数据竞争（这是一个未定义行为），在
Rust 中不使用 unsafe
的情况下是不可能发生的，但这仍然有一个不可预测的赢者的竞争。</p>
<p>因为我们期待 x
是常量，那么谁赢得比赛并不重要，因为无论如何结果都是一样。依赖于
<code>calculate_x()</code> 会花费多少时间，这可能非常好或者很糟糕。</p>
<p>如果 <code>calculate_x()</code>
预计花费很长时间，则最好在第一个线程仍在初始化 X
时等待，以避免不必要的浪费处理器时间。你可以使用一个条件变量或者线程阻塞（<a
href="./1_Basic_of_Rust_Concurrency.md#等待-阻塞park和条件变量">第一章“等待-阻塞和条件变量”</a>）来实现这个，但是对于一个小例子来说，这很快将变得复杂。Rust
标准库通过 <code>std::sync::Once</code> 和
<code>std::sync::OnceLock</code>
提供了此功能，所以通常这些不需要由你自己实现。</p>
<h2 id="获取并修改操作">获取并修改操作</h2>
<p>（<a href="https://marabos.nl/atomics/atomics.html#fetch-and-modify-operations" target="_blank">英文版本</a>）</p>
<p>注意，我们已经看见基础 load 和 store
操作的一些用例，让我们继续更有趣的操作：<em>获取并修改</em>（fetch-and-modify）操作。这些操作修改原子变量，但也加载（获取）原始值，作为一个单原子操作。</p>
<p>最常用的是 <code>fetch_add</code> 和
<code>fetch_sub</code>，它们分别执行加和减运算。一些其他可获得的操作是位操作
<code>fetch_or</code> 和
<code>fetch_and</code>，以及用于比较最大值和最小值的
<code>fetch_max</code> 和 <code>fetch_min</code>。</p>
<p>它们的函数签名如下，使用 AtomicI32 作为示例：</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> AtomicI32 <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_add(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_sub(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_or(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_and(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_nand(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_xor(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_max(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> fetch_min(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> swap(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> v<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> ordering<span class="op">:</span> Ordering) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span> <span class="co">// &quot;fetch_store&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>最后一个例外的操作是将一个新值存储到原子变量中，而不考虑原来的值。它不叫做
<code>fetch_store</code>，而是称为 <code>swap</code>。</p>
<p>这里有一个快速的演示，展示了 <code>fetch_add</code>
如何在操作之前返回值：</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span>AtomicI32<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="pp">AtomicI32::</span>new(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> a<span class="op">.</span>fetch_add(<span class="dv">23</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c <span class="op">=</span> a<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(b<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(c<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></span></code></pre></div>
<p>fetch_add 操作从 100 递增到 123，但是返回给我们还是旧值
100。任意下一个操作将看见 123。</p>
<p>来自这些操作的返回值并不总是相关的。如果你仅需要将操作用于原子值，但是值本身并没有用，那么你可以忽略该返回值。</p>
<p>需要记住的一个重要的事情是，fetch_add 和 fetch_sub
为溢出实现了环绕（wrapping）行为。将值递增超过最大可表示值将导致环绕到最小可表示值。这与常规整数上的递增和递减行为是不同的，后者在调试模式下的溢出将
panic。</p>
<p>在<a
href="#比较并交换操作">“「比较并交换」操作”</a>中，我们将看见如何使用溢出检查进行原子加运算。</p>
<p>但首先，让我们看看这些方法的现实使用示例。</p>
<h3 id="示例来自多线程的进度报道">示例：来自多线程的进度报道</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-progress-reporting-from-multiple-threads" target="_blank">英文版本</a>）</p>
<p>在<a href="#示例进度报道">“示例：进度报道”</a>中，我们使用一个
AtomicUsize
去报道后台线程的进度。如果我们把工作分开，例如，四个线程，每个处理 25
个元素，我们将需要知道所有 4 个线程的进度。</p>
<p>我们可以为每个线程使用单独的 AtomicUsize
并且在主线程加载它们并进行汇总，但是更简单的解决方案是，使用单个
AtomicUsize 去跟踪所有线程处理元素的总数。</p>
<p>为了使其工作，我们不再使用 store
方法，因为这会覆盖其他线程的进度。相反，我们可以使用原子自增操作在每个处理元素之后递增计数器。</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> num_done <span class="op">=</span> <span class="op">&amp;</span><span class="pp">AtomicUsize::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>scope(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 4 个后台线程，去处理所有 100 个元素，每个 25 次。</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">4</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            s<span class="op">.</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">25</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                    process_item(t <span class="op">*</span> <span class="dv">25</span> <span class="op">+</span> i)<span class="op">;</span> <span class="co">// 假设此处理需要花费一些时间。</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                    num_done<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 主线程每秒展示一次状态更新。</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> n <span class="op">=</span> num_done<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> n <span class="op">==</span> <span class="dv">100</span> <span class="op">{</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Working.. {n}/100 done&quot;</span>)<span class="op">;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Done!&quot;</span>)<span class="op">;</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>一些东西已经改变。更重要地是，我们现在产生了 4 个后台线程而不是 1
个，并且使用 fetch_add 而不是 store 去修改 <code>num_done</code>
原子变量。</p>
<p>更巧妙的是，我们现在对后台线程使用一个 move 闭包，并且 num_done
现在是一个引用。这与我们使用 fetch_add 无关，而是我们如何在循环中产生 4
个线程有关。此闭包捕获 t，以了解它是 4
个线程中的哪一个，从而确定是从元素 0、25、50 还是 75 开始。没有 move
关键字，闭包将尝试通过引用捕获
t。这是不允许的，因为它仅在循环期间短暂地存在。</p>
<p>由于 move 闭包，它移动（或复制）它的捕获而不是借用它们，这使它得到 t
的复制。因为它也捕获
num_done，我们已经改变该变量为一个引用，因为我们仍然想要借用相同的
AtomicUsize。注意，原子类型并没有实现 Copy
trait，所以如果我们尝试移动一个原子类型的变量到多个线程，我们将得到错误。</p>
<p>撇开闭包的微妙不谈，在这里使用 fetch_add
更改是非常简单的。我们并不知道线程将以哪种顺序递增
num_done，但由于加运算是原子的，我们并不担心任何事情，并且当所有线程完成时，可以确信它将是
100。</p>
<h3 id="示例统计数据">示例：统计数据</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-statistics" target="_blank">英文版本</a>）</p>
<p>继续通过原子报道其他线程正在做什么的概念，让我们拓展我们的示例，也可以收集和报道一些关于处理元素所花费时间的统计数据。</p>
<p>在 num_done 旁边，我们递增了两个原子变量 <code>total_time</code> 和
<code>max_time</code>，以便跟踪处理元素所花费的时间。我们将使用这些报道平均和峰值处理时间。</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> num_done <span class="op">=</span> <span class="op">&amp;</span><span class="pp">AtomicUsize::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total_time <span class="op">=</span> <span class="op">&amp;</span><span class="pp">AtomicU64::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> max_time <span class="op">=</span> <span class="op">&amp;</span><span class="pp">AtomicU64::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>scope(<span class="op">|</span>s<span class="op">|</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// 4 个后台线程，去处理所有 100 个元素，每个 25 次。</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">4</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            s<span class="op">.</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">25</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> start <span class="op">=</span> <span class="pp">Instant::</span>now()<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                    process_item(t <span class="op">*</span> <span class="dv">25</span> <span class="op">+</span> i)<span class="op">;</span> <span class="co">// 假设此处理需要花费一些时间。</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> time_taken <span class="op">=</span> start<span class="op">.</span>elapsed()<span class="op">.</span>as_micros() <span class="kw">as</span> <span class="dt">u64</span><span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                    num_done<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                    total_time<span class="op">.</span>fetch_add(time_taken<span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                    max_time<span class="op">.</span>fetch_max(time_taken<span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 主线程每秒展示一次状态更新。</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> total_time <span class="op">=</span> <span class="pp">Duration::</span>from_micros(total_time<span class="op">.</span>load(Relaxed))<span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> max_time <span class="op">=</span> <span class="pp">Duration::</span>from_micros(max_time<span class="op">.</span>load(Relaxed))<span class="op">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> n <span class="op">=</span> num_done<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> n <span class="op">==</span> <span class="dv">100</span> <span class="op">{</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Working.. nothing done yet.&quot;</span>)<span class="op">;</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;Working.. {n}/100 done, {:?} average, {:?} peak&quot;</span><span class="op">,</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>                    total_time <span class="op">/</span> n <span class="kw">as</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>                    max_time<span class="op">,</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>                )<span class="op">;</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Done!&quot;</span>)<span class="op">;</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>后台线程现在使用 <code>Install::now()</code> 和
<code>Install::elapsed()</code> 去衡量它们在 <code>process_item()</code>
所花费的时间。原子的递增操作用于将微秒数递增到 total_time，并且原子的
max 操作用于跟踪 max_time 中的最高测量值。</p>
<p>主线程将总时间除以处理器元素的数量以获取平均处理时间，然后将它与
max_time 的峰值时间一起报道。</p>
<p>由于三个原子变量是单独更新的，因此主线程可能在线程递增 num_done
后而在更新 total_time 之前加载值，导致低估了平均值。更微妙的是，因为
Relaxed 内存排序不能保证从另一个线程中看到操作的相对顺序，它甚至可能看到
total_time 新更新的值，同时仍然看到 num_done
的旧值，导致平均值的高估。</p>
<p>在我们的示例中，这两个都不是大问题。最糟糕的情况是向用户提交了不准确的平均值。</p>
<p>如果我们想要避免这个，我们可以把这三个统计数据放到一个 Mutex
中。然后，在更新三个数字时，我们短暂地锁定
mutex，这三个数字本身就不再是原子的。这有效地转变三次更新为单个原子操作，代价是锁定和解锁
mutex 的开销，并且可能临时地阻塞线程。</p>
<h3 id="示例id-分配">示例：ID 分配</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-id-allocation" target="_blank">英文版本</a>）</p>
<p>让我们转到一个用例，我们实际上需要 <code>fetch_add</code>
的返回值。</p>
<p>假设我们需要一些函数，<code>allocate_new_id()</code>，每次调用它时，都会给出新的唯一的数字。我们可能使用这些数字标识程序中的任务或其它事情；需要一个小而易于存储和在线程之间传递的东西来唯一标识事物，例如整数。</p>
<p>使用 <code>fetch_add</code> 实现此函数是轻松的：</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span>AtomicU32<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> allocate_new_id() <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> NEXT_ID<span class="op">:</span> AtomicU32 <span class="op">=</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    NEXT_ID<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>我们只是跟踪了<em>下一个</em>要给出的数字，并在每次加载时递增它。第一个调用者将得到
0，第二个调用者将得到 1，以此类推。</p>
<p>这里唯一的问题是溢出时包装行为。第 4,294,967,296 次调用将溢出 32
位整数，因此下一次调用将再次返回 0。</p>
<p>这是否是一个问题取决于用例：经常被这样调用的可能性是多大，如果数字不是唯一的，最糟糕的情况是什么？虽然这似乎是一个巨大的数字，现代计算机也可以在几秒内的轻松执行我们的函数。如果内存安全取决于这些数字的唯一性，那么我们上面的实现是不可接受的。</p>
<p>为了解决这个问题，如果调用次数太多，我们可以试图去使函数
panic，例如这样：</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 这个版本是有问题的。</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> allocate_new_id() <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> NEXT_ID<span class="op">:</span> AtomicU32 <span class="op">=</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> id <span class="op">=</span> NEXT_ID<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert!</span>(id <span class="op">&lt;</span> <span class="dv">1000</span><span class="op">,</span> <span class="st">&quot;too many IDs!&quot;</span>)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    id</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>现在，assert 语句将在 1000 次调用后
panic。然而，这在原子加运算已经发生后发生，这意味着当我们 panic
时，<code>NEXT_ID</code> 已经递增到
1001。如果另一个线程在之后调用该函数，它将在 panic 之前递增到
1002，以此类推。虽然需要很长时间，我们将在 4,294,966,296 次 panic
过后，NEXT_ID 将再次溢出到 0 时，遇到相同的问题。</p>
<p>有三个通常的方式解决这个问题。第一种是在溢出时不使用
panic，而是完全终止进程。<code>std::process::abort</code>
函数将终止整个函数，排除任何继续调用我们函数的可能性。<a class="indexterm" id="index-abortingtheprocess"></a>尽管终止进程可能需要短暂的时间，但是函数仍然可能通过其它线程调用，但在程序真正的终止之前，发生数十亿次调用的可能性几乎可以忽略不计。</p>
<p>事实上，在标准库中的 <code>Arc::clone()</code>
溢出检查就是这么实现的，以防你在某种方式下克隆 <code>isize::MAX</code>
次。在 64 位计算机上，这需要上百年的时间，但如果 isize 只有 32
位，这仅需要几秒钟。</p>
<p>处理溢出的第二种方法是使用 fetch_sub 在 panic
之前再次递减计数器，就像这样：</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> allocate_new_id() <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> NEXT_ID<span class="op">:</span> AtomicU32 <span class="op">=</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> id <span class="op">=</span> NEXT_ID<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> id <span class="op">&gt;=</span> <span class="dv">1000</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        NEXT_ID<span class="op">.</span>fetch_sub(<span class="dv">1</span><span class="op">,</span> Relaxed)<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">panic!</span>(<span class="st">&quot;too many IDs!&quot;</span>)<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    id</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>当多个线程在相同时间执行这个函数，计数器仍然有可能在非常短暂的时间超过
100，但这受到活动线程数量的限制。合理地假设是永远不会有数十亿个激活的线程，并非所有线程都在
fetch_add 和 fetch_sub 之间的短暂时间内同时执行相同的函数。</p>
<p>这就是标准库 <code>thread::scope</code>
实现中处理运行线程数量溢出的方式。</p>
<p>第三种处理溢出的方式可以说是唯一正确的方式，因为如果它溢出，它完全可以阻止加运算发生。然而，我们不能使用迄今为止看到的原子操作实现这一点。为此，我们需要「比较并交换」操作，接下来我们将探索。</p>
<h2 id="比较并交换操作">比较并交换操作</h2>
<p>（<a href="https://marabos.nl/atomics/atomics.html#cas" target="_blank">英文版本</a>）</p>
<p>更加高级和灵活的原子操作是「<em>比较并交换</em>」操作。这个操作检查是否原子值等同于给定的值，只有在这种情况下，它才以原子地方式使用新值替换它，作为单个操作完成。它会返回先前的值，并告诉我们是否进行了替换。</p>
<p>它的签名比我们到目前为止看到的要复杂一些。以 AtomicI32
为例，它看起来像这样：</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> AtomicI32 <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> compare_exchange(</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        expected<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        new<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        success_order<span class="op">:</span> Ordering<span class="op">,</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        failure_order<span class="op">:</span> Ordering</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">&gt;;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>暂时忽略内存排序，它基本上与以下实现相同，只是这一切都发生在单个不可分割原子操作上：</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> AtomicI32 <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> compare_exchange(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> expected<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> new<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 在实际中，加载、比较以及存储操作，</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 这些所有都是以单个原子操作发生的。</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>load()<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> expected <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 值符合预期</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 替换它并报道成功。</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>store(new)<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(v)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 值不符合预期。</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 保持不变并报道失败。</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(v)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>使用该函数，我们可以从原子变量中加载值，执行我们喜欢的任何计算，并且然后仅原子变量在此期间没有改变值的情况下，再存储新的计算值。如果我们把这个放在一个循环中重试，如果它确实发生了变化，我们可以使用它来实现所有其它原子操作，使它成为最通用的一个。</p>
<p>为了演示，让我们在不使用 <code>fetch_add</code> 的情况下将 AtomicU32
递增 1，仅是为了看看 compare_exchange 是如何使用的：</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> increment(a<span class="op">:</span> <span class="op">&amp;</span>AtomicU32) <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> current <span class="op">=</span> a<span class="op">.</span>load(Relaxed)<span class="op">;</span> <span class="co">// 1</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> new <span class="op">=</span> current <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 2</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> a<span class="op">.</span>compare_exchange(current<span class="op">,</span> new<span class="op">,</span> Relaxed<span class="op">,</span> Relaxed) <span class="op">{</span> <span class="co">// 3</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="cf">return</span><span class="op">,</span> <span class="co">// 4</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(v) <span class="op">=&gt;</span> current <span class="op">=</span> v<span class="op">,</span> <span class="co">// 5</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol type="1">
<li>首先，我们加载 a 的当前值。</li>
<li>我们计算我们想要存储在 a 的新值，而不考虑其他线程的并发修改。</li>
<li>我们使用 compare_exchange 去更新 a
的值，但<em>仅</em>当它的值仍然与我们之前加载的值相同时。</li>
<li>如果 a 确实和之前一样，它现在被我们的新值所取代，我们就完成了。</li>
<li>如果 a
并不和之前相同，那么自从我们加载它以来，它一定短时间被另一个线程改变了。<code>compare_exchange</code>
操作给我们提供了 a
的改变值，并且我们将再次尝试使用该值。加载和更新之间的时间非常短暂，它不可能循环超过几次迭代。</li>
</ol>
<blockquote>
<p>如果原子变量从某个值 A 更改到 B，但在 load 操作之后和
compare_exchange 操作之前又变回
A，即使原子变量在此期间发生了变化（并且回变），compare_exchange
操作也会成功。在很多示例中，就像在我们的递增示例中一样，这并不是问题。然而，有几种算法，通常涉及原子指针，这样的情况就会产生问题。这就是所谓的
<a id="index-ABAproblem"></a> ABA 问题。</p>
</blockquote>
<p>在 <code>compare_exchange</code> 旁边，有一个名为
<code>compare_exchange_weak</code> 的类似方法。区别是 weak
版本有时可能仍然保留不改变值并且返回
Err，即使原子值匹配期待值。在某些平台，这个方法可以更有效地实现，并且对于虚假的「比较并交换」失败的后果不重要的情况下，比如上面的递增函数，应该优先使用它。在<a
href="./7_Understanding_the_Processor.md">第七章节</a>，我们将深入研究底层细节，以找出为什么
weak 版本会更有效。</p>
<h3 id="示例没有溢出的-id-分配">示例：没有溢出的 ID 分配</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-handle-overflow" target="_blank">英文版本</a>）</p>
<p>现在，从<a href="#示例id-分配">“示例：ID 分配”</a>中回到
<code>allocate_new_id()</code> 的溢出问题。</p>
<p>为了停止递增 NEXT_ID 超过某个限制以阻止溢出，我们可以使用
compare_exchange
去实现具有上限的原子操作加。使用这个想法，让我们制作一个始终正确处理溢出
allocate_new_id 的版本，即使在几乎不可能的情况下也是如此：</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> allocate_new_id() <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> NEXT_ID<span class="op">:</span> AtomicU32 <span class="op">=</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> id <span class="op">=</span> NEXT_ID<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert!</span>(id <span class="op">&lt;</span> <span class="dv">1000</span><span class="op">,</span> <span class="st">&quot;too many IDs!&quot;</span>)<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> NEXT_ID<span class="op">.</span>compare_exchange_weak(id<span class="op">,</span> id <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> Relaxed<span class="op">,</span> Relaxed) <span class="op">{</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="cf">return</span> id<span class="op">,</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(v) <span class="op">=&gt;</span> id <span class="op">=</span> v<span class="op">,</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>现在，我们在修改 NEXT_ID 之前，检查并 panic，保证它将从不递增超出
1000，使溢出变得不可能。如果我们愿意，我们现在可以将上限从 1000 提高到
<code>u32::MAX</code>，而不必担心它可能会超过极限的边缘情况。</p>
<div class="box">
<h2 style="text-align: center;">
Fetch-Update
</h2>
<p>
原子类型有一个名为 <code>fetch_update</code>
的简写方法，用于「比较并交换」循环模式。它相当于 load
操作，然后就是重复计算和 <code>compare_exchange_weak</code>
的循环，就像我们上面做的那样。
</p>
<p>
使用它，我们可以使用一行实现我们的 allocate_new_id：
</p>
<pre>
  NEXT_ID.fetch_update(Relaxed, Relaxed,
      |n| n.checked_add(1)).expect("too many IDs!")</pre>
<p>
有关详细信息，请查看该方法的文档。
</p>
<p>
我们不会在本书中使用 <code>fetch_update</code>
方法，因此我们可以专注于单个原子操作。
</p>
</div>
<h3 id="示例惰性一次性初始化">示例：惰性一次性初始化</h3>
<p>（<a href="https://marabos.nl/atomics/atomics.html#example-racy-init" target="_blank">英文版本</a>）</p>
<p>在<a
href="#示例惰性初始化">“示例：惰性初始化”</a>中，我们查看常量值的惰性初始化示例。我们做了一个函数，在第一次调用时惰性地初始化一个值，但在以后的调用中重用它。当多个线程并发地运行这个函数，多个线程可能执行初始化，并且它们将以不可预期的顺序覆盖彼此的结果。</p>
<p>对于我们期望值是常量，或者当我们不关心改变值时，这很好。然而，也有些用例，这些值每次都会初始化为不同的值，即便我们需要在程序的一次运行中返回相同的值。</p>
<p>例如，想象一个函数
<code>get_key()</code>，它返回一个随机生成的密钥，该密钥仅在程序每次运行时生成。它可能是用于与程序通信的加密密钥，该密钥每次运行程序时都需要是唯一的，但在进程中保持不变。</p>
<p>这意味着我们不能在生成密钥之后，简单地使用一个 store
操作，因为这可能仅在片刻之后由其他线程复写这个生成的密钥，导致两个线程使用不同的密钥。相反，我们可以使用
compare_exchange
去确保我们仅当没有其他线程完成该操作，去存储这个密钥，否则，扔掉我们的密钥，改用存储的密钥。</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> get_key() <span class="op">-&gt;</span> <span class="dt">u64</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static</span> KEY<span class="op">:</span> AtomicU64 <span class="op">=</span> <span class="pp">AtomicU64::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> key <span class="op">=</span> KEY<span class="op">.</span>load(Relaxed)<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> key <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> new_key <span class="op">=</span> generate_random_key()<span class="op">;</span> <span class="co">// 1</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> KEY<span class="op">.</span>compare_exchange(<span class="dv">0</span><span class="op">,</span> new_key<span class="op">,</span> Relaxed<span class="op">,</span> Relaxed) <span class="op">{</span> <span class="co">// 2</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> new_key<span class="op">,</span> <span class="co">// 3</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(k) <span class="op">=&gt;</span> k<span class="op">,</span> <span class="co">// 4</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        key</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol type="1">
<li>我们仅在 KEY 仍然没有初始化时，生成一个新的密钥。</li>
<li>我们用新生成的密钥替换 KEY，但前提是它仍然是 0。</li>
<li>如果我们将 0
换成新密钥，我们将返回新生成的密钥。<code>get_key()</code>
的新调用将返回现在存储在 KEY 中的相同新密钥。</li>
<li>如果我们输给了另一个初始化 KEY
的线程，我们忘记我们的新密钥，而是使用来自 KEY 的密钥。</li>
</ol>
<p>这是一个很好的例子，在这里 <code>compare_exchange</code> 比
<code>weak</code>
变体更合适。我们不会在循环中运行「比较并交换」操作，如果操作虚假失败，我们不想返回
0。</p>
<p>正如<a href="#示例惰性初始化">“示例：惰性初始化”</a>中提到的，如果
<code>generate_random_key()</code>
需要大量时间，那么在初始化期间阻塞线程可能更有意义，以避免可能花费时间生成不会使用的密钥。Rust
标准库通过 <code>std::sync::Once</code> 和
<code>std::sync::OnceLock</code> 提供此类功能。</p>
<h2 id="总结">总结</h2>
<p>（<a href="https://marabos.nl/atomics/atomics.html#summary" target="_blank">英文版本</a>）</p>
<ul>
<li>原子操作是不可分割的；它们要么完整的完成，要么它们还没有发生。</li>
<li>在 Rust 中的原子操作是通过 <code>std::sync::atomic</code>
原子类型完成的，例如 <code>AtomicI32</code>。</li>
<li>不是所有原子类型在所有平台都是可获得的。</li>
<li>当涉及多个变量时，原子操作的相对顺序是棘手的。更多细节，请看<a
href="./3_Memory_Ordering.md">第三章</a>。</li>
<li>简单的 load 和 store
操作非常适合非常简单的基本线程间通信，例如停止标识和状态报道。</li>
<li>我们可以使用竞争条件<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>来惰性始化，而不会引发数据竞争<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>。</li>
<li>「获取并修改」操作允许进行一小组基本的原子修改操作，当多个线程同时修改同一个原子变量时，非常有用。</li>
<li>原子加和减运算在溢出时会默默地进行环绕（wrap around）操作。</li>
<li>「比较并交换」操作是最灵活和通用的，并且是任意其它原子操作的基石。</li>
<li><em>weak</em> 版本「比较并交换」稍微更有效。</li>
</ul>
<p style="text-align: center; padding-block-start: 5rem;">
<a href="./3_Memory_Ordering.html">下一篇，第三章：内存排序</a>
</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://zh.wikipedia.org/wiki/比较并交换"
class="uri">https://zh.wikipedia.org/wiki/比较并交换</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://zh.wikipedia.org/wiki/内存排序"
class="uri">https://zh.wikipedia.org/wiki/内存排序</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>竞争条件是指多个线程并发访问和修改共享数据时，其最终结果依赖于线程执行的具体顺序。在某些情况下，我们可以利用竞争条件来实现延迟初始化。也就是说，多个线程可以同时尝试对共享资源进行初始化，但只有第一个成功的线程会完成初始化，而其他线程会放弃初始化操作。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn4"><p>数据竞争是指多个线程同时访问共享数据，并且至少有一个线程进行写操作，而没有适当的同步机制来保证正确的访问顺序。<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>      </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
