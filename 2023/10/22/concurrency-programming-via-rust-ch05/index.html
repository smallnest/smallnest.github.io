<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  
  <title>Rust并发编程5 - 基本并发原语</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="同步是多线程程序中的一个重要概念。在多线程环境下,多个线程可能同时访问某个共享资源,这就可能导致数据竞争或者数据不一致的问题。为了保证数据安全,需要进行同步操作。
常见的同步需求包括:

互斥:线程在使用共享资源时,同一时刻只允许一个线程访问共享资源,在一个线程使用时,其他线程需要等待,不能同时访问,需要互斥访问。
限制同时访问线程数:对某些共享资源,可能需要限制同一时刻访问的线程数。
线程间通信">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust并发编程5 - 基本并发原语">
<meta property="og:url" content="https://colobu.com/2023/10/22/concurrency-programming-via-rust-ch05/">
<meta property="og:site_name" content="鸟窝">
<meta property="og:description" content="同步是多线程程序中的一个重要概念。在多线程环境下,多个线程可能同时访问某个共享资源,这就可能导致数据竞争或者数据不一致的问题。为了保证数据安全,需要进行同步操作。
常见的同步需求包括:

互斥:线程在使用共享资源时,同一时刻只允许一个线程访问共享资源,在一个线程使用时,其他线程需要等待,不能同时访问,需要互斥访问。
限制同时访问线程数:对某些共享资源,可能需要限制同一时刻访问的线程数。
线程间通信">
<meta property="og:image" content="ch05.png">
<meta property="og:image" content="05/atomic.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rust并发编程5 - 基本并发原语">
<meta name="twitter:description" content="同步是多线程程序中的一个重要概念。在多线程环境下,多个线程可能同时访问某个共享资源,这就可能导致数据竞争或者数据不一致的问题。为了保证数据安全,需要进行同步操作。
常见的同步需求包括:

互斥:线程在使用共享资源时,同一时刻只允许一个线程访问共享资源,在一个线程使用时,其他线程需要等待,不能同时访问,需要互斥访问。
限制同时访问线程数:对某些共享资源,可能需要限制同一时刻访问的线程数。
线程间通信">

  
  <link rel="alternative" href="/atom.xml" title="鸟窝" type="application/atom+xml">
  
  
  <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <link href="//cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.min.css" rel="stylesheet">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/css/jquery.fancybox.min.css"
    media="screen" type="text/css">
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" media="screen"
    type="text/css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap" class="animated bounceInLeft">
        <a href="/" id="logo">鸟窝</a>
      </h1>
      
        <!-- <h2 id="subtitle-wrap" class="animated bounceInLeft"> -->
        <h2 id="subtitle-wrap">
          <!-- <a href="/" id="subtitle">大道至简 Simplicity is the ultimate form of sophistication</a> -->
          <a href="https://item.jd.com/14283252.html" target="_blank" style="color: #e32d40;text-decoration: none;"><b>《Go語言全功能開發養成書》繁体中文版发售。一书在手，并发无忧</b></a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class="fa fa-home">&nbsp;</i>首页</a>
          
          
          
            <a class="main-nav-link" href="/archives"><i class="fa fa-folder-o">&nbsp;</i>归档</a>
          
          
          
            <a class="main-nav-link" href="https://github.com/smallnest"><i class="fa fa-github">&nbsp;</i>github</a>
          
          
          
            <div class="dropdown main-nav-link"><a class="main-nav-link" href="#"><i class="fa fa-bars">&nbsp;</i>网站群</a>
              <div class="dropdown-content">
          
            
              <a href="/goasm"><i class="fa fa-language"></i>&nbsp;Go汇编示例</a>
            
                
          
            
              <a href="https://gowebexamples.com"><i class="fa fa-external-link"></i>&nbsp;Go Web开发示例</a>
            
                
          
            
              <a href="http://go-database-sql.org"><i class="fa fa-external-link"></i>&nbsp;Go 数据库开发教程</a>
            
                
          
            
              <a href="https://colobu.com/gotips/"><i class="fa fa-external-link"></i>&nbsp;Go 语言编程技巧</a>
            
                
          
            
              <hr>
            
                
          
            
              <a href="/perf-book"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust高性能编程指南</a>
            
                
          
            
              <a href="/rust100"><i class="fa fa-brands fa-rust"></i>&nbsp;100个练习题学习Rust</a>
            
                
          
            
              <a href="https://github.com/rustcc/Rust_Atomics_and_Locks"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust原子操作和锁</a>
            
                
          
            
              <a href="https://rustx-labs.github.io/effective-rust-cn/"><i class="fa fa-brands fa-rust"></i>&nbsp;高效Rust编程</a>
            
                
          
            
              <a href="https://rustwiki.org/zh-CN/book/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust程序设计语言</a>
            
                
          
            
              <a href="https://nomicon.purewhite.io/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust死灵书</a>
            
                
          
            
              <a href="https://rustwiki.org/zh-CN/reference/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust参考手册</a>
            
                
          
            
              <a href="https://zjp-cn.github.io/tlborm/translation_statement.html"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust宏小册</a>
            
                
          
            
              <a href="https://huangjj27.github.io/async-book/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust异步编程书</a>
            
                
          
            
              <a href="https://rustwiki.org/zh-CN/rust-by-example/hello.html"><i class="fa fa-brands fa-rust"></i>&nbsp;通过例子学Rust</a>
            
                
          
            
              <a href="https://rust-chinese-translation.github.io/api-guidelines/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust API 编写指南</a>
            
                
          
            
              <a href="https://google.github.io/comprehensive-rust/zh-CN/"><i class="fa fa-brands fa-rust"></i>&nbsp;全面Rust课程</a>
            
                
          
            
              <hr>
            
                
          
            
              <a href="http://rpcx.io"><i class="fa undefined"></i>&nbsp;RPCX官网</a>
            
                
          
            
              <a href="http://cn.doc.rpcx.io"><i class="fa undefined"></i>&nbsp;RPC开发指南</a>
            
                
          
          </div>
        </div>
          
          
          
            <a class="main-nav-link" href="/ScalaCollectionsCookbook"><i class="fa fa-solid fa-book">&nbsp;</i>Scala集合技术手册</a>
          
          
          
            <a class="main-nav-link" href="/about"><i class="fa fa-lemon-o">&nbsp;</i>关于</a>
          
          


      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="https://www.google.com/search" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" id="search-word" name="q" maxlength="20" class="search-form-input" placeholder="Search">
          <input type=hidden name=ie value="utf-8">
          <input type=hidden name=oe value="utf-8">
          <input type=hidden name=hl value="zh-CN">
          <input type="submit" id="search-submit" value="" class="search-form-submit">
        </form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-concurrency-programming-via-rust-ch05" class="article article-type-post" itemscope
  itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/10/22/concurrency-programming-via-rust-ch05/" class="article-date">
  <time datetime="2023-10-22T14:40:50.000Z" itemprop="datePublished">2023年10月22日</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Rust/">Rust</a>
  </div>

    
  <div class="article-author"> by smallnest</div>

  </div>
  <div class="article-inner">
    
    
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      Rust并发编程5 - 基本并发原语
	  
    </h1>
  

    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
      
      <script>function show_answer(btn, x) { if (btn.value === "显示答案") { btn.value = "隐藏答案" } else { btn.value = "显示答案" } var as = document.getElementById(x); if (as.style.display === "none") { as.style.display = "block" } else { as.style.display = "none" } }</script>
      <p>同步是多线程程序中的一个重要概念。在多线程环境下,多个线程可能同时访问某个共享资源,这就可能导致数据竞争或者数据不一致的问题。为了保证数据安全,需要进行同步操作。</p>
<p>常见的同步需求包括:</p>
<ul>
<li>互斥:线程在使用共享资源时,同一时刻只允许一个线程访问共享资源,在一个线程使用时,其他线程需要等待,不能同时访问,需要互斥访问。</li>
<li>限制同时访问线程数:对某些共享资源,可能需要限制同一时刻访问的线程数。</li>
<li>线程间通信:一个线程需要基于另一个线程的处理结果才能继续执行,需要线程间通信。</li>
<li>有序访问:对共享资源的访问需要按某种顺序进行。</li>
</ul>
<a id="more"></a>
<p><img src="ch05.png" alt=""></p>
<p>为了实现这些同步需求,就需要使用同步原语。常见的同步原语有互斥锁、信号量、条件变量等。</p>
<p>互斥锁可以保证同一时刻只有一个线程可以访问共享资源。信号量可以限制同时访问的线程数。条件变量可以实现线程间的通信和协调。这些同步原语的使用可以避免同步问题,帮助我们正确有效地处理多线程之间的同步需求。</p>
<h2 id="Arc">Arc</h2>
<blockquote>
<p><code>Arc</code>已改放在前一章的，这一章补上。我这里介绍的时候分类不一定精确，只是方便给大家介绍各种库和并发原语，不用追求分类的准确性。</p>
</blockquote>
<p>Rust的Arc代表<code>原子引用计数</code>（Atomic Reference Counting），是一种用于多线程环境的智能指针。它允许在多个地方共享数据，同时确保线程安全性。Arc的全称是<code>std::sync::Arc</code>，属于标准库的一部分。</p>
<p>在Rust中，通常情况下，变量是被所有权管理的，但有时候我们需要在多个地方共享数据。这就是<code>Arc</code>的用武之地。它通过在堆上分配内存，并使用引用计数来跟踪数据的所有者数量，确保在不需要的时候正确地释放资源。</p>
<p>下面是一个简单的例子，演示了如何使用<code>Arc</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::Arc;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的整数</span></div><div class="line">    <span class="keyword">let</span> data = Arc::new(<span class="number">46</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建两个线程，共享对data的引用</span></div><div class="line">    <span class="keyword">let</span> thread1 = {</div><div class="line">        <span class="keyword">let</span> data = Arc::clone(&data);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 在线程中使用data</span></div><div class="line">            println!(<span class="string">"Thread 1: {}"</span>, data);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> thread2 = {</div><div class="line">        <span class="keyword">let</span> data = Arc::clone(&data);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 在另一个线程中使用data</span></div><div class="line">            println!(<span class="string">"Thread 2: {}"</span>, data);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 等待两个线程完成</span></div><div class="line">    thread1.join().unwrap();</div><div class="line">    thread2.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Arc（原子引用计数）和Rc（引用计数）都是Rust中用于多所有权的智能指针，但它们有一些关键的区别。</p>
<ul>
<li>线程安全性：<ul>
<li><code>Arc</code> 是线程安全的，可以安全地在多线程环境中共享。它使用原子操作来更新引用计数，确保并发访问时的线程安全性。</li>
<li><code>Rc</code> 不是线程安全的。它只适用于单线程环境，因为它的引用计数操作不是原子的，可能导致在多线程中的竞态条件和不安全行为。</li>
</ul>
</li>
<li>性能开销：<ul>
<li>由于Arc使用原子操作来更新引用计数，相对于Rc，Arc的性能开销更大。原子操作通常比非原子操作更昂贵。</li>
<li>Rc在单线程环境中性能更好，因为它不需要进行原子操作。</li>
</ul>
</li>
<li>可变性：<ul>
<li><code>Arc</code> 不能用于可变数据。如果需要在多线程环境中共享可变数据，通常会使用Mutex、RwLock等同步原语和<code>Arc</code>。</li>
<li><code>Rc</code> 也不能用于可变数据，因为它无法提供并发访问的安全性。</li>
</ul>
</li>
<li>引用计数减少时的行为：<ul>
<li>当Arc 的引用计数减少为零时，由于它是原子的，它会正确地释放底层资源（比如堆上的数据）。</li>
<li>Rc 在单线程中引用计数减少为零时会正确释放资源，但在多线程中可能存在问题，因为它没有考虑并发情况。</li>
</ul>
</li>
</ul>
<p>总之你记住在多线程的情况下使用<code>Arc</code>，单线程的情况下使用<code>Rc</code>就好了。</p>
<p>当你需要在多线程环境中共享可变数据时，常常会结合使用<code>Arc</code>和<code>Mutex</code>。<code>Mutex</code>（互斥锁）用于确保在任意时刻只有一个线程能够访问被锁定的数据。下面是一个简单的例子，演示了如何使用<code>Arc</code>和<code>Mutex</code>来在多线程中共享可变数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc, Mutex};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁，确保只有一个线程能够访问计数器</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Arc</code>和 <code>RefCell</code> 结合使用的场景通常发生在多线程中需要共享可变状态，但又不需要互斥锁的场合。<code>RefCell</code>允许在运行时进行借用检查，因此在单线程环境下使用时，它不会像 <code>Mutex</code> 那样引入锁的开销。</p>
<p>以下是一个使用 <code>Arc</code> 和 <code>RefCell</code> 的简单例子，演示了在多线程环境中共享可变状态,注意这个例子只是用来演示，我们并不期望num的最终结果和上面的例子一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc};</div><div class="line"><span class="keyword">use</span> std::cell::RefCell;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RefCell::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 使用RefCell获取可变引用，确保运行时借用检查</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.borrow_mut();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.borrow());</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="互斥锁_Mutex">互斥锁 Mutex</h2>
<p>互斥锁历史悠久，在很多编程语言中都有实现。</p>
<p><code>Mutex</code> 是 Rust 中的互斥锁，用于解决多线程并发访问共享数据时可能出现的竞态条件。Mutex 提供了一种机制，只有拥有锁的线程才能访问被锁定的数据，其他线程必须等待锁的释放。</p>
<h3 id="Lock">Lock</h3>
<p>在标准库中，Mutex 位于 <code>std::sync</code> 模块下。下面是一个简单的例子，演示了如何使用 Mutex：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁，确保只有一个线程能够访问计数器</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，counter 是一个 <code>Mutex</code> 保护(且包装)的可变整数，然后使用 <code>Arc</code> 来多线程共享。在每个线程中，通过 <code>counter.lock().unwrap()</code> 获取锁，确保一次只有一个线程能够修改计数器的值。这样可以确保在并发情况下不会发生竞态条件。</p>
<p>需要注意的是，<code>lock</code> 方法返回一个 <code>MutexGuard</code>，它是一个智能指针，实现了 <code>Deref</code> 和 <code>Drop</code> trait。当 <code>MutexGuard</code> 被销毁时，会自动释放锁，确保在任何情况下都能正确释放锁。</p>
<p>这里注意三个知识点：</p>
<ul>
<li>为了跨线程支持，一般<code>Mutex</code>会和<code>Arc</code>组合使用,这样<code>Mutex</code>对象在每个线程中都能安全访问</li>
<li><code>lock</code>方法返回实现了 <code>Deref</code> trait的<code>MutexGuard</code>对象，所以它会自动解引用，你可以直接调用被保护对象上的方法</li>
<li><code>MutexGuard</code>还实现了<code>Drop</code>, 所以锁会自动解锁，一般你不需要主动调用<code>drop</code>去解锁</li>
</ul>
<p>目前nightly版本的rust提供了一个实验性的方法<code>unlock</code>,功能和<code>drop</code>一样，也是释放互斥锁。</p>
<h3 id="try_lock">try_lock</h3>
<p>Mutex 的 <code>try_lock</code> 方法尝试获取锁，如果锁已经被其他线程持有，则立即返回 <code>Err</code> 而不是阻塞线程。这对于在尝试获取锁时避免线程阻塞很有用。</p>
<p>以下是一个使用 <code>try_lock</code> 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 尝试获取锁，如果获取失败就继续尝试或者放弃</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> Ok(<span class="keyword">mut</span> num) = counter.try_lock() {</div><div class="line">                *num += <span class="number">1</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                println!(<span class="string">"Thread failed to acquire lock."</span>);</div><div class="line">            }</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>try_lock</code> 方法被用于尝试获取锁。如果获取成功，线程就可以修改计数器的值，否则它会打印一条消息表示没有获取到锁。</p>
<p>需要注意的是，<code>try_lock</code> 方法返回一个 <code>Result</code>，如果获取锁成功，返回 <code>Ok</code> 包含 <code>MutexGuard</code>，否则返回 <code>Err</code>。这使得你可以根据获取锁的结果执行不同的逻辑。</p>
<h3 id="Poisoning">Poisoning</h3>
<p>在 Rust 中，<code>poisoning</code> 是一种用于处理线程 <code>panic</code> 导致的不可恢复的状态的机制。这个概念通常与 <code>Mutex</code> 和 <code>RwLock</code> 相关。<br>当一个线程在持有锁的情况下 <code>panic</code> 时，这就会导致锁进入一种不一致的状态，因为锁的内部状态可能已经被修改，而没有机会进行清理。为了避免这种情况，Rust 的标准库使用 <code>poisoning</code> 机制(形象的比喻)。<br>具体来说，在 <code>Mutex</code> 和 <code>RwLock</code> 中，当一个线程在持有锁的时候 <code>panic</code>，锁就会被标记为 <code>poisoned</code>。此后任何线程尝试获取这个锁时，都会得到一个 <code>PoisonError</code>，它包含一个标识锁是否被 <code>poisoned</code> 的标志。这样，线程可以检测到之前的 <code>panic</code>，并进行相应的处理。</p>
<p><code>Mutex</code> 通过在 <code>LockResult</code> 中包装 <code>PoisonError</code> 来表示这种情况。具体来说，<code>LockResult</code> 的 <code>Err</code> 分支是一个 <code>PoisonError</code>，其中包含一个 <code>MutexGuard</code>。你可以通过 <code>into_inner</code> 方法来获取 <code>MutexGuard</code>，然后继续操作。</p>
<p>以下是一个简单的例子，演示了锁的 &quot;poisoning&quot;，以及如何处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc, LockResult, PoisonError};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁</span></div><div class="line">            <span class="keyword">let</span> result: LockResult&lt;<span class="number">_</span>&gt; = counter.lock();</div><div class="line">            </div><div class="line">            <span class="comment">// 尝试获取锁，如果获取失败就打印错误信息</span></div><div class="line">            <span class="keyword">match</span> result {</div><div class="line">                Ok(<span class="keyword">mut</span> num) =&gt; {</div><div class="line">                    *num += <span class="number">1</span>;</div><div class="line">                    <span class="comment">// 模拟 panic</span></div><div class="line">                    <span class="keyword">if</span> *num == <span class="number">3</span> {</div><div class="line">                        panic!(<span class="string">"Simulated panic!"</span>);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                Err(poisoned) =&gt; {</div><div class="line">                    <span class="comment">// 锁被 "poisoned"，处理错误</span></div><div class="line">                    println!(<span class="string">"Thread encountered a poisoned lock: {:?}"</span>, poisoned);</div><div class="line"></div><div class="line">                    <span class="comment">// 获取 MutexGuard，继续操作</span></div><div class="line">                    <span class="keyword">let</span> <span class="keyword">mut</span> num = poisoned.into_inner();</div><div class="line">                    *num += <span class="number">1</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，当计数器的值达到3时，一个线程故意引发了 panic，其他线程在尝试获取锁时就会得到一个 <code>PoisonError</code>。在错误处理分支，我们打印错误信息，然后使用 <code>into_inner</code> 方法获取 <code>MutexGuard</code>，以确保锁被正确释放。这样其他线程就能够继续正常地使用锁。</p>
<h3 id="更快的释放互斥锁">更快的释放互斥锁</h3>
<p>前面说了，因为<code>MutexGuard</code>实现了<code>Drop</code>了，所以锁可以自动释放，可是如果锁的scope太大，我们想尽快的释放，该怎么办呢？</p>
<p>第一种方式你可以通过创建一个新的内部的作用域(<code>scope</code>)来达到类似手动释放 Mutex 的效果。在新的作用域中，<code>MutexGuard</code> 将在离开作用域时自动释放锁。这是通过作用域的离开而触发的 <code>Drop</code> trait 的实现。：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 进入一个新的作用域!!!!!!!!!!!!!!</span></div><div class="line">            {</div><div class="line">                <span class="comment">// 获取锁</span></div><div class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">                *num += <span class="number">1</span>;</div><div class="line">                <span class="comment">// MutexGuard 在这个作用域结束时自动释放锁</span></div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 在这里，锁已经被释放</span></div><div class="line">            <span class="comment">// 这里可以进行其他操作</span></div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第二种方法就是主动<code>drop</code>或者<code>unlock</code>,以下是一个演示手动释放 Mutex 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 手动释放锁!!!!!!!!</span></div><div class="line">            drop(num);</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Mutex</code>是可重入锁吗？ 应该不是，但是官方文档把它标记为<a href="https://github.com/rust-lang/rust/issues/32260" target="_blank" rel="external">未定义的行为</a>，所以不要试图在同一个线程中获取两次锁, 如果你想使用可重入锁，请使用我将来要介绍的第三方并发库。同样需要注意的是读写锁<code>RWMutex</code>。</p>
<h2 id="读写锁_RWMutex">读写锁 RWMutex</h2>
<p><code>RWMutex</code> 是 Rust 中的读写锁（Read-Write Lock），允许多个线程同时获取共享数据的读取访问权限，但在写入时会排他。这意味着多个线程可以同时读取数据，但只有一个线程能够写入数据，且写入时不允许其他线程读取或写入。</p>
<p>读写锁一般使用在下面的场景中：</p>
<ul>
<li><strong>读多写少的情况</strong>： 当多个线程需要同时读取共享数据而写入操作较少时，使用 RWMutex 可以提高并发性能。多个线程可以同时获取读取锁，而写入操作会排他进行。</li>
<li><strong>只读访问和写入访问不冲突的情况</strong>： 如果在程序的逻辑中，读取操作和写入操作是独立的，没有冲突，那么使用 RWMutex 可以更好地利用并发性能。</li>
<li><strong>资源分配和释放阶段</strong>： 当需要在一段时间内只允许读取，然后在另一段时间内只允许写入时，RWMutex 可以提供更灵活的控制</li>
</ul>
<p>以下是使用 <code>RWMutex</code>的例子 ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{RwLock, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来读取计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> read_handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取读取锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Reader {}: {}"</span>, thread::current().id(), *num);</div><div class="line">        });</div><div class="line">        read_handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程来写入计数器的值</span></div><div class="line">    <span class="keyword">let</span> write_handle = thread::spawn(move || {</div><div class="line">        <span class="comment">// 获取写入锁</span></div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">        *num += <span class="number">1</span>;</div><div class="line">        println!(<span class="string">"Writer {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有读取线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> read_handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待写入线程完成</span></div><div class="line">    write_handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的使用和互斥锁类似，只不过需要调用<code>read()</code>方法获得读锁，使用<code>write()</code>方法获得写锁。</p>
<p>读写锁有以下的性质:</p>
<ul>
<li>多个线程可以同时获取读锁,实现并发读</li>
<li>只有一个线程可以获取写锁,写时会独占锁</li>
<li>如果已经获取了读锁,则不能获取写锁,防止数据竞争</li>
<li>如果已经获取了写锁,则不能再获取读锁或写锁,写独占时防止并发读写</li>
</ul>
<p>如果一个线程已经持有读锁，而另一个线程请求写锁，它必须等待读锁被释放。这确保在写入操作进行时，没有其他线程能够同时持有读锁。写锁确保了对共享数据的写入操作是独占的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{RwLock, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程持有读锁</span></div><div class="line">    <span class="keyword">let</span> read_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取读锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Reader {}: {}"</span>, thread::current().id(), *num);</div><div class="line"></div><div class="line">            <span class="comment">// 休眠模拟读取操作</span></div><div class="line">            thread::sleep(std::time::Duration::from_secs(<span class="number">10</span>));</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程请求写锁</span></div><div class="line">    <span class="keyword">let</span> write_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 休眠一小段时间，确保读锁已经被获取</span></div><div class="line">            thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</div><div class="line"></div><div class="line">            <span class="comment">// 尝试获取写锁</span></div><div class="line">            <span class="comment">// 注意：这里会等待读锁被释放</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">            println!(<span class="string">"Writer {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 等待读取线程和写入线程完成</span></div><div class="line">    read_handle.join().unwrap();</div><div class="line">    write_handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>更进一步，在写锁请求后，再有新的读锁请求进来，它是在等待写锁释放？还是直接获得读锁？答案是等待写锁释放，看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line"><span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">// 创建一个线程持有读锁</span></div><div class="line"><span class="keyword">let</span> read_handle = {</div><div class="line">    <span class="keyword">let</span> counter = counter.clone();</div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="comment">// 获取读锁</span></div><div class="line">        <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">        println!(<span class="string">"Reader#1: {}"</span>, *num);</div><div class="line"></div><div class="line">        <span class="comment">// 休眠模拟读取操作</span></div><div class="line">        thread::sleep(std::time::Duration::from_secs(<span class="number">10</span>));</div><div class="line">    })</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 创建一个线程请求写锁</span></div><div class="line"><span class="keyword">let</span> write_handle = {</div><div class="line">    <span class="keyword">let</span> counter = counter.clone();</div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="comment">// 休眠一小段时间，确保读锁已经被获取</span></div><div class="line">        thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 尝试获取写锁</span></div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">        *num += <span class="number">1</span>;</div><div class="line">        println!(<span class="string">"Writer : Incremented counter to {}"</span>,  *num);</div><div class="line">    })</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 创建一个线程请求读锁</span></div><div class="line"><span class="keyword">let</span> read_handle_2 = {</div><div class="line">    <span class="keyword">let</span> counter = counter.clone();</div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="comment">// 休眠一小段时间，确保写锁已经被获取</span></div><div class="line">        thread::sleep(std::time::Duration::from_secs(<span class="number">2</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 尝试获取读锁</span></div><div class="line">        <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">        println!(<span class="string">"Reader#2: {}"</span>, *num);</div><div class="line">    })</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 等待读取线程和写入线程完成</span></div><div class="line">read_handle.join().unwrap();</div><div class="line">write_handle.join().unwrap();</div><div class="line">read_handle_2.join().unwrap();</div></pre></td></tr></table></figure>

<p>死锁是一种并发编程中的常见问题，可能发生在 RwLock 使用不当的情况下。一个典型的死锁场景是，一个线程在持有读锁的情况下尝试获取写锁，而其他线程持有写锁并尝试获取读锁，导致彼此相互等待。</p>
<p>以下是一个简单的例子，演示了可能导致 RwLock 死锁的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{RwLock, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程持有读锁，尝试获取写锁</span></div><div class="line">    <span class="keyword">let</span> read_and_write_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取读锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Reader {}: {}"</span>, thread::current().id(), *num);</div><div class="line"></div><div class="line">            <span class="comment">// 尝试获取写锁，这会导致死锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">            println!(<span class="string">"Reader {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程持有写锁，尝试获取读锁</span></div><div class="line">    <span class="keyword">let</span> write_and_read_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取写锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">            println!(<span class="string">"Writer {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line"></div><div class="line">            <span class="comment">// 尝试获取读锁，这会导致死锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Writer {}: {}"</span>, thread::current().id(), *num);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    read_and_write_handle.join().unwrap();</div><div class="line">    write_and_read_handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和Mutex一样,RwLock在panic时也会变为中毒状态。但是请注意,只有在RwLock被独占式写入锁住时发生panic,它才会中毒。如果在任意reader中发生panic,该锁则不会中毒。</p>
<p>原因是:</p>
<ul>
<li>RwLock允许多个reader同时获取读锁,读是非独占的。</li>
<li>如果任一个reader panic,其他读者依然持有读锁,所以不能将状态标记为中毒。</li>
<li>只有当前线程独占式拥有写锁时发生panic,由于没有其他线程持有锁,这时可以安全地将状态标记为中毒。</li>
</ul>
<p>所以综上,RwLock只会在独占式写入时发生panic时中毒。而reader panic不会导致中毒。这是由RwLock读写锁语义决定的。</p>
<p>这种机制可以避免不必要的中毒,因为非独占的读锁之间不会互相影响,其中任一个锁持有者panic不应影响其他读者。只有独占写锁需要特殊处理。</p>
<h2 id="一次初始化_Once">一次初始化 Once</h2>
<p><code>std::sync::Once</code> 是 Rust 中的一种并发原语，用于确保某个操作在整个程序生命周期内只执行一次。<code>Once</code> 主要用于在多线程环境中执行初始化代码，确保该代码只被执行一次，即使有多个线程同时尝试执行它。</p>
<p>以下是使用<code>Once</code>的一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Once, ONCE_INIT};</div><div class="line"></div><div class="line"><span class="keyword">static</span> INIT: Once = ONCE_INIT;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 通过 call_once 方法确保某个操作只执行一次</span></div><div class="line">    INIT.call_once(|| {</div><div class="line">        <span class="comment">// 这里放置需要执行一次的初始化代码</span></div><div class="line">        println!(<span class="string">"Initialization code executed!"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 之后再调用 call_once，初始化代码不会再次执行</span></div><div class="line">    INIT.call_once(|| {</div><div class="line">        println!(<span class="string">"This won't be printed."</span>);</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用场景:</p>
<ul>
<li><strong>全局初始化</strong>： 在程序启动时执行一些全局初始化操作，例如初始化全局变量、加载配置等。</li>
<li><strong>懒加载</strong>： 在需要时进行一次性初始化，例如懒加载全局配置。</li>
<li><strong>单例模式</strong>： 通过 <code>Once</code> 可以实现线程安全的单例模式，确保某个对象在整个程序生命周期内只被初始化一次。</li>
</ul>
<p>下面这个例子是带返回值的例子，实现懒加载全局配置的场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Once, ONCE_INIT};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">mut</span> GLOBAL_CONFIG: Option&lt;String&gt; = None;</div><div class="line"><span class="keyword">static</span> INIT: Once = ONCE_INIT;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init_global_config</span></span>() {</div><div class="line">    <span class="keyword">unsafe</span> {</div><div class="line">        GLOBAL_CONFIG = Some(<span class="string">"Initialized global configuration"</span>.to_string());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_global_config</span></span>() -&gt; &'static <span class="keyword">str</span> {</div><div class="line">    INIT.call_once(|| init_global_config());</div><div class="line">    <span class="keyword">unsafe</span> {</div><div class="line">        GLOBAL_CONFIG.as_ref().unwrap()</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    println!(<span class="string">"{}"</span>, get_global_config());</div><div class="line">    println!(<span class="string">"{}"</span>, get_global_config()); <span class="comment">// 不会重新初始化，只会输出一次</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，get_global_config 函数通过 Once 确保 init_global_config 函数只会被调用一次，从而实现了全局配置的懒加载。</p>
<p>上一章我们还介绍了<code>OnceCell</code>和<code>OnceLock</code>,它们都是同一族的单次初始化的并发原语，主要区别是:</p>
<ul>
<li><code>Once</code> 是用于确保某个操作在整个程序生命周期内只执行一次的原语。它适用于全局初始化、懒加载和单例模式等场景。</li>
<li><code>OnceCell</code> 是一个针对某种数据类型进行包装的懒加载容器，可以在需要时执行一次性初始化，并在之后提供对初始化值的访问。</li>
<li><code>OnceLock</code> 是一个可用于线程安全的懒加载的原语，类似于 <code>OnceCell</code>，但是更简单，只能存储 Copy 类型的数据。</li>
</ul>
<p><code>OnceCell</code>不是线程安全的，而<code>OnceLock</code>是线程安全的，但是<code>OnceLock</code>只能存储Copy类型的数据，而<code>OnceCell</code>可以存储任意类型的数据。</p>
<p>还有一个被广泛使用的第三方库<code>once_cell</code>,它提供了线程安全和非线程安全的两种类型的<code>OnceCell</code>, 比如下面就是一个线程安全的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> once_cell::sync::OnceCell;</div><div class="line"></div><div class="line"><span class="keyword">static</span> CELL: OnceCell&lt;String&gt; = OnceCell::new();</div><div class="line">assert!(CELL.get().is_none());</div><div class="line"></div><div class="line">std::thread::spawn(|| {</div><div class="line">    <span class="keyword">let</span> value: &String = CELL.get_or_init(|| {</div><div class="line">        <span class="string">"Hello, World!"</span>.to_string()</div><div class="line">    });</div><div class="line">    assert_eq!(value, <span class="string">"Hello, World!"</span>);</div><div class="line">}).join().unwrap();</div><div class="line"></div><div class="line"><span class="keyword">let</span> value: Option&lt;&String&gt; = CELL.get();</div><div class="line">assert!(value.is_some());</div><div class="line">assert_eq!(value.unwrap().as_str(), <span class="string">"Hello, World!"</span>);</div></pre></td></tr></table></figure>

<h2 id="屏障/栅栏_Barrier">屏障/栅栏 Barrier</h2>
<p>Barrier 是 Rust 标准库中的一种并发原语，用于在多个线程之间创建一个同步点。它允许多个线程在某个点上等待，直到所有线程都到达该点，然后它们可以同时继续执行。</p>
<p>下面是一个使用<code>Barrier</code>的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc, Barrier};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个 Barrier，指定参与同步的线程数量</span></div><div class="line">    <span class="keyword">let</span> barrier = Arc::new(Barrier::new(<span class="number">3</span>)); <span class="comment">// 在这个例子中，有 3 个线程参与同步</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">        <span class="keyword">let</span> barrier = Arc::clone(&barrier);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 模拟一些工作</span></div><div class="line">            println!(<span class="string">"Thread {} working"</span>, id);</div><div class="line">            thread::sleep(std::time::Duration::from_secs(id <span class="keyword">as</span> <span class="keyword">u64</span>));</div><div class="line"></div><div class="line">            <span class="comment">// 线程到达同步点</span></div><div class="line">            barrier.wait();</div><div class="line"></div><div class="line">            <span class="comment">// 执行同步后的操作</span></div><div class="line">            println!(<span class="string">"Thread {} resumed"</span>, id);</div><div class="line">        });</div><div class="line"></div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个 <code>Barrier</code>，并指定了参与同步的线程数量为 3。然后，创建了三个线程，每个线程模拟一些工作，然后调用 <code>barrier.wait()</code> 来等待其他线程。当所有线程都调用了 wait 后，它们同时继续执行。</p>
<p>使用场景</p>
<ul>
<li><strong>并行计算</strong>： 当需要确保多个线程在某个点上同步，以便执行某些计算或任务时，可以使用 <code>Barrier</code>。</li>
<li><strong>迭代步骤同步</strong>： 在一些算法中，可能需要多个步骤，每个步骤的结果都依赖于其他步骤的完成。<code>Barrier</code> 可以用于确保所有线程完成当前步骤后再继续下一步。</li>
<li><strong>协同工作的阶段</strong>： 在多阶段的任务中，可以使用 Barrier 来同步各个阶段。</li>
</ul>
<p><code>Barrier</code> 的灵活性使得它在协调多个线程的执行流程时非常有用。</p>
<p>那么，Barrier可以循环使用吗？<br>一旦所有线程都通过 wait 方法达到同步点后，Barrier 就被重置，可以再次使用。这种重置操作是自动的。</p>
<p>当所有线程都调用 wait 方法后，Barrier 的内部状态会被重置，下一次调用 wait 方法时，线程会重新被阻塞，直到所有线程再次到达同步点。这样，Barrier 可以被循环使用，用于多轮的同步。</p>
<p>以下是一个简单的示例，演示了 Barrier 的循环使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> barrier = Arc::new(Barrier::new(<span class="number">10</span>));</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {</div><div class="line">    <span class="keyword">let</span> barrier = barrier.clone();</div><div class="line">    handles.push(thread::spawn(move || {</div><div class="line">        println!(<span class="string">"before wait1"</span>);</div><div class="line">        <span class="keyword">let</span> dur = rand::thread_rng().gen_range(<span class="number">100</span>..<span class="number">1000</span>);</div><div class="line">        thread::sleep(std::time::Duration::from_millis(dur));</div><div class="line"></div><div class="line">        <span class="comment">//step1</span></div><div class="line">        barrier.wait();</div><div class="line">        println!(<span class="string">"after wait1"</span>);</div><div class="line">        thread::sleep(time::Duration::from_secs(<span class="number">1</span>));</div><div class="line"></div><div class="line">        <span class="comment">//step2</span></div><div class="line">        barrier.wait();</div><div class="line">        println!(<span class="string">"after wait2"</span>);</div><div class="line">    }));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">    handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="条件变量_Condvar">条件变量 Condvar</h2>
<p><code>Condvar</code> 是 Rust 标准库中的条件变量（Condition Variable），用于在多线程之间进行线程间的协调和通信。条件变量允许线程等待某个特定的条件成立，当条件满足时，线程可以被唤醒并继续执行。</p>
<p>以下是 Condvar 的一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc, Mutex, Condvar};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个 Mutex 和 Condvar，用于共享状态和线程协调</span></div><div class="line">    <span class="keyword">let</span> mutex = Arc::new(Mutex::new(<span class="keyword">false</span>));</div><div class="line">    <span class="keyword">let</span> condvar = Arc::new(Condvar::new());</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">        <span class="keyword">let</span> mutex = Arc::clone(&mutex);</div><div class="line">        <span class="keyword">let</span> condvar = Arc::clone(&condvar);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取 Mutex 锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = mutex.lock().unwrap();</div><div class="line"></div><div class="line">            <span class="comment">// 线程等待条件变量为 true</span></div><div class="line">            <span class="keyword">while</span> !*guard {</div><div class="line">                guard = condvar.wait(guard).unwrap();</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 条件满足后执行的操作</span></div><div class="line">            println!(<span class="string">"Thread {} woke up"</span>, id);</div><div class="line">        });</div><div class="line"></div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 模拟条件满足后唤醒等待的线程</span></div><div class="line">    thread::sleep(std::time::Duration::from_secs(<span class="number">2</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 修改条件，并唤醒等待的线程</span></div><div class="line">    {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guard = mutex.lock().unwrap();</div><div class="line">        *guard = <span class="keyword">true</span>;</div><div class="line">        condvar.notify_all();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个 <code>Mutex</code> 和 <code>Condvar</code>，其中 <code>Mutex</code> 用于保护共享状态（条件），而 <code>Condvar</code> 用于等待和唤醒线程。多个线程在 <code>Mutex</code> 上加锁后，通过 <code>condvar.wait()</code> 方法等待条件满足，然后在主线程中修改条件，并通过 <code>condvar.notify_all()</code> 唤醒所有等待的线程。</p>
<p>使用场景</p>
<ul>
<li><strong>线程间同步</strong>： <code>Condvar</code> 可以用于线程之间的同步，使得线程能够等待某个条件的成立而不是轮询检查。</li>
<li><strong>生产者-消费者模型</strong>： 在多线程环境中，生产者线程可以通过条件变量通知消费者线程有新的数据产生。</li>
<li><strong>线程池</strong>： 在线程池中，任务线程可以等待条件变量，等待新的任务到达时被唤醒执行。</li>
</ul>
<p>需要注意的是，使用 <code>Condvar</code> 时，通常需要配合 <code>Mutex</code> 使用，以确保在等待和修改条件时的线程安全性。</p>
<p><code>Condvar</code> 可以通过调用 <code>notify_one()</code> 方法来发出信号。当 <code>notify_one()</code> 方法被调用时，<code>Condvar</code> 会随机选择一个正在等待信号的线程，并释放该线程。<br><code>Condvar</code> 也可以通过调用 <code>notify_all()</code> 方法来发出信号。当 <code>notify_all()</code> 方法被调用时，<code>Condvar</code> 会释放所有正在等待信号的线程。</p>
<h2 id="LazyCell_和_LazyLock">LazyCell 和 LazyLock</h2>
<p>我们介绍了<code>OnceCell</code>和<code>OnceLock</code>,我们再介绍两个类似的用于懒加载的并发原语<code>LazyCell</code>和<code>LazyLock</code>。</p>
<p>Rust 中的 LazyCell 和 LazyLock 都是用于懒惰初始化对象的工具。LazyCell 用于懒惰初始化值，LazyLock 用于懒惰初始化资源。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>初始化时机</th>
<th>线程安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>LazyCell</td>
<td>懒惰初始化值</td>
<td>第一次访问</td>
<td>否</td>
</tr>
<tr>
<td>LazyLock</td>
<td>懒惰初始化资源</td>
<td>第一次获取锁</td>
<td>是</td>
</tr>
<tr>
<td>OnceCell</td>
<td>懒惰初始化单例值</td>
<td>第一次调用</td>
<td>get_or_init() 方法</td>
<td>否</td>
</tr>
<tr>
<td>OnceLock</td>
<td>懒惰初始化互斥锁</td>
<td>第一次调用</td>
<td>lock() 方法</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="Exclusive">Exclusive</h2>
<p>Rust 中的 <code>Exclusive</code> 是一个用于保证某个资源只被一个线程访问的工具。<code>Exclusive</code> 可以通过导入 <code>std::sync::Exclusive</code> 来使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> exclusive = Exclusive::new(<span class="number">92</span>);</div><div class="line">println!(<span class="string">"ready"</span>);</div><div class="line">std::thread::spawn(move || {</div><div class="line">    <span class="keyword">let</span> counter = exclusive.get_mut();</div><div class="line">    println!(<span class="string">"{}"</span>, *counter);</div><div class="line">    *counter = <span class="number">100</span>;</div><div class="line">}).join().unwrap();</div></pre></td></tr></table></figure>

<p>和Mutex有什么区别？<code>Exclusive</code> 仅提供对底层值的<strong>可变</strong>访问，也称为对底层值的独占访问。它<strong>不提供</strong>对底层值的不可变或共享访问。</p>
<p>虽然这可能看起来不太有用，但它允许 <code>Exclusive</code> 无条件地实现 <code>Sync</code>。事实上，<code>Sync</code> 的安全要求是，对于 <code>Exclusive</code> 而言，它必须可以安全地跨线程共享，也就是说，&amp;Exclusive 跨越线程边界时必须是安全的。出于设计考虑，&amp;Exclusive 没有任何 API，使其无用，因此无害，因此内存安全。</p>
<p>这个类型还是一个nightly的实验性特性，所以我们不妨等它稳定后在学习和使用。</p>
<h2 id="mpsc">mpsc</h2>
<p><code>mpsc</code> 是 Rust 标准库中的一个模块，提供了多生产者、单消费者（Multiple Producers, Single Consumer）的消息传递通道。mpsc 是 multiple-producer, single-consumer 的缩写。<br>这个模块基于channel的基于消息传递的通讯，具体定义了三个类型：</p>
<ul>
<li><code>Sender</code>：发送者，用于异步发送消息。</li>
<li><code>SyncSender</code>：同步发送者，用于同步发送消息。</li>
<li><code>Receiver</code>：接收者，用于从同步channel或异步channel中接收消息，只能有一个线程访问。</li>
</ul>
<p><code>Sender</code> 或 <code>SyncSender</code> 用于向 <code>Receiver</code> 发送数据。两种 sender 都是可clone的(多生产者),这样多个线程就可以同时向一个 receiver(单消费者)发送。</p>
<p>这些通道有两种类型:</p>
<ul>
<li>异步的,无限缓冲区的通道。<code>channel</code> 函数将返回一个  <code>(Sender, Receiver)</code> 元组,其中所有发送将是异步的(永不阻塞)。该通道在概念上具有无限的缓冲区。</li>
<li>同步的,有界的通道。<code>sync_channel</code> 函数将返回一个 <code>(SyncSender, Receiver)</code> 元组,待发送消息的存储区是一个固定大小的预分配缓冲区。所有发送将是同步的,通过阻塞直到有空闲的缓冲区空间。注意绑定大小为 0 也是允许的,这将使通道变成一个“约定”通道,每个发送方原子地将一条消息交给接收方。</li>
</ul>
<p>使用场景</p>
<ul>
<li><strong>并发消息传递</strong>： 适用于多个线程（生产者）向一个线程（消费者）发送消息的场景。</li>
<li><strong>任务协调</strong>： 用于协调多个并发任务的执行流程。</li>
</ul>
<p>每当看到rust的mpsc,我总是和Go的channel作比较，事实上rust的channel使用起来也非常的简单。</p>
<p>一个简单的channel例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</div><div class="line"></div><div class="line"><span class="comment">// Create a simple streaming channel</span></div><div class="line"><span class="keyword">let</span> (tx, rx) = channel();</div><div class="line">thread::spawn(move|| {</div><div class="line">    tx.send(<span class="number">10</span>).unwrap();</div><div class="line">});</div><div class="line">assert_eq!(rx.recv().unwrap(), <span class="number">10</span>);</div></pre></td></tr></table></figure>

<p>一个多生产者单消费者的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</div><div class="line"></div><div class="line"><span class="comment">// Create a shared channel that can be sent along from many threads</span></div><div class="line"><span class="comment">// where tx is the sending half (tx for transmission), and rx is the receiving</span></div><div class="line"><span class="comment">// half (rx for receiving).</span></div><div class="line"><span class="keyword">let</span> (tx, rx) = channel();</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {</div><div class="line">    <span class="keyword">let</span> tx = tx.clone();</div><div class="line">    thread::spawn(move|| {</div><div class="line">        tx.send(i).unwrap();</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {</div><div class="line">    <span class="keyword">let</span> j = rx.recv().unwrap();</div><div class="line">    assert!(<span class="number">0</span> &lt;= j && j &lt; <span class="number">10</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一个同步channel的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::mpsc::sync_channel;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="keyword">let</span> (tx, rx) = sync_channel(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">    <span class="comment">// It would be the same without thread and clone here</span></div><div class="line">    <span class="comment">// since there will still be one `tx` left.</span></div><div class="line">    <span class="keyword">let</span> tx = tx.clone();</div><div class="line">    <span class="comment">// cloned tx dropped within thread</span></div><div class="line">    thread::spawn(move || tx.send(<span class="string">"ok"</span>).unwrap());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Drop the last sender to stop `rx` waiting for message.</span></div><div class="line"><span class="comment">// The program will not complete if we comment this out.</span></div><div class="line"><span class="comment">// **All** `tx` needs to be dropped for `rx` to have `Err`.</span></div><div class="line">drop(tx);</div><div class="line"></div><div class="line"><span class="comment">// Unbounded receiver waiting for all senders to complete.</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">let</span> Ok(msg) = rx.recv() {</div><div class="line">    println!(<span class="string">"{msg}"</span>);</div><div class="line">}</div><div class="line"></div><div class="line">println!(<span class="string">"completed"</span>);</div></pre></td></tr></table></figure>

<p>发送端释放的情况下，receiver会收到error:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</div><div class="line"></div><div class="line"><span class="comment">// The call to recv() will return an error because the channel has already</span></div><div class="line"><span class="comment">// hung up (or been deallocated)</span></div><div class="line"><span class="keyword">let</span> (tx, rx) = channel::&lt;<span class="keyword">i32</span>&gt;();</div><div class="line">drop(tx);</div><div class="line">assert!(rx.recv().is_err());</div></pre></td></tr></table></figure>

<p>在 Rust 标准库中，目前没有提供原生的 <code>MPMC</code>（Multiple Producers, Multiple Consumers）通道。<code>std::sync::mpsc</code> 模块提供的是单一消费者的通道，主要是出于设计和性能的考虑。</p>
<p>设计上，MPSC 通道的实现相对较简单，可以更容易地满足特定的性能需求，并且在很多情况下是足够的。同时，MPSC 通道的使用场景更为常见，例如在线程池中有一个任务队列，多个生产者将任务推送到队列中，而单个消费者负责执行这些任务。</p>
<p>未来我会在专门的章节中介绍更多的第三方库提供的channel以及类似的同步原语，如<code>oneshot</code>、<code>broadcaster</code>、<code>mpmc</code>等。</p>
<p>依照这个<a href="https://crates.io/crates/mpmc" target="_blank" rel="external">mpmc</a>的介绍，以前的rust标准库应该是实现了<code>mpmc</code>,这个库就是从老的标准库中抽取出来的。</p>
<h2 id="信号量_Semaphore">信号量 Semaphore</h2>
<p>标准库中没有Semaphore的实现，单这个是在是非常通用的一个并发原语，理论上也应该在这里介绍。</p>
<p>但是这一章内容也非常多了，而且我也会在tokio中介绍信号两，在一个专门的特殊并发原语(第十四章或者更多)，所以不在这个章节专门介绍了。</p>
<p>这个章节还是偏重标准库的并发原语的介绍。</p>
<h2 id="原子操作_atomic">原子操作 atomic</h2>
<p>Rust 中的原子操作（Atomic Operation）是一种特殊的操作，可以在多线程环境中以原子方式进行，即不会被其他线程的操作打断。原子操作可以保证数据的线程安全性，避免数据竞争。</p>
<p>在 Rust 中，<code>std::sync::atomic</code> 模块提供了一系列用于原子操作的类型和函数。原子操作是一种特殊的操作，可以在多线程环境中安全地执行，而不需要使用额外的锁。</p>
<p>atomic 可以用于各种场景，例如：</p>
<ul>
<li>保证某个值的一致性。</li>
<li>防止多个线程同时修改某个值。</li>
<li>实现互斥锁。</li>
</ul>
<p>目前Rust原子类型遵循与<a href="https://en.cppreference.com/w/cpp/atomic" target="_blank" rel="external">C++20 atomic</a>相同的规则,具体来说就是<code>atomic_ref</code>。基本上,创建Rust原子类型的一个共享引用,相当于在C++中创建一个<code>atomic_ref</code>;当共享引用的生命周期结束时,<code>atomic_ref</code>也会被销毁。(一个被独占拥有或者位于可变引用后面的Rust原子类型,并不对应C++中的“原子对象”,因为它可以通过非原子操作被访问。)</p>
<p>这个模块为一些基本类型定义了原子版本,包括<code>AtomicBool</code>、<code>AtomicIsize</code>、<code>AtomicUsize</code>、<code>AtomicI8</code>、<code>AtomicU16</code>等。原子类型提供的操作在正确使用时可以在线程间同步更新。<br><img src="05/atomic.png" alt=""></p>
<p>每个方法都带有一个<a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html" target="_blank" rel="external">Ordering</a>参数,表示该操作的内存屏障的强度。这些排序与<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="external">C++20原子排序</a>相同。更多信息请参阅<a href="https://doc.rust-lang.org/nomicon/atomics.html" target="_blank" rel="external">nomicon</a>。</p>
<p>原子变量在线程间安全共享(实现了Sync),但它本身不提供共享机制,遵循Rust的线程模型。共享一个原子变量最常见的方式是把它放到一个<code>Arc</code>中(一个原子引用计数的共享指针)。</p>
<p>原子类型可以存储在静态变量中,使用像<code>AtomicBool::new</code>这样的常量初始化器初始化。原子静态变量通常用于懒惰的全局初始化。</p>
<p>我们已经说了，这个模块为一些基本类型定义了原子版本，包括<code>AtomicBool</code>、<code>AtomicIsize</code>、<code>AtomicUsize</code>、<code>AtomicI8</code>、<code>AtomicU16</code>等，其实每一种类似的方法都比较类似的，所以我们以<code>AtomicI64</code>介绍。<br>可以通过<code>pub const fn new(v: i64) -&gt; AtomicI64</code>得到一个<code>AtomicI64</code>对象， <code>AtomicI64</code>定义了一些方法，用于对原子变量进行操作，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// i64 和 AtomicI64的转换，以及一组对象之间的转换</span></div><div class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_ptr</span></span>&lt;'a&gt;(ptr: *<span class="keyword">mut</span> <span class="keyword">i64</span>) -&gt; &'a AtomicI64</div><div class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_ptr</span></span>(&<span class="keyword">self</span>) -&gt; *<span class="keyword">mut</span> <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>(&<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &<span class="keyword">mut</span> <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_mut</span></span>(v: &<span class="keyword">mut</span> <span class="keyword">i64</span>) -&gt; &<span class="keyword">mut</span> AtomicI64</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut_slice</span></span>(this: &<span class="keyword">mut</span> [AtomicI64]) -&gt; &<span class="keyword">mut</span> [<span class="keyword">i64</span>]</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_mut_slice</span></span>(v: &<span class="keyword">mut</span> [<span class="keyword">i64</span>]) -&gt; &<span class="keyword">mut</span> [AtomicI64]</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">into_inner</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">i64</span></div><div class="line"></div><div class="line"><span class="comment">// 原子操作</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>(&<span class="keyword">self</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">store</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering)</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">swap</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compare_and_swap</span></span>(&<span class="keyword">self</span>, current: <span class="keyword">i64</span>, new: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span> <span class="comment">//   弃用</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compare_exchange</span></span>(</div><div class="line">    &<span class="keyword">self</span>,</div><div class="line">    current: <span class="keyword">i64</span>,</div><div class="line">    new: <span class="keyword">i64</span>,</div><div class="line">    success: Ordering,</div><div class="line">    failure: Ordering</div><div class="line">) -&gt; Result&lt;<span class="keyword">i64</span>, <span class="keyword">i64</span>&gt;</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compare_exchange_weak</span></span>(</div><div class="line">    &<span class="keyword">self</span>,</div><div class="line">    current: <span class="keyword">i64</span>,</div><div class="line">    new: <span class="keyword">i64</span>,</div><div class="line">    success: Ordering,</div><div class="line">    failure: Ordering</div><div class="line">) -&gt; Result&lt;<span class="keyword">i64</span>, <span class="keyword">i64</span>&gt;</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_add</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_sub</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_and</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_nand</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_or</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_xor</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_update</span></span>&lt;F&gt;(</div><div class="line">    &<span class="keyword">self</span>,</div><div class="line">    set_order: Ordering,</div><div class="line">    fetch_order: Ordering,</div><div class="line">    f: F</div><div class="line">) -&gt; Result&lt;<span class="keyword">i64</span>, <span class="keyword">i64</span>&gt;</div><div class="line">where</div><div class="line">    F: FnMut(<span class="keyword">i64</span>) -&gt; Option&lt;<span class="keyword">i64</span>&gt;,</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_max</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_min</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div></pre></td></tr></table></figure>

<p>如果你有一点原子操作的基础，就不难理解这些原子操作以及它们的变种了:</p>
<ul>
<li><code>store</code>:原子写入</li>
<li><code>load</code>:原子读取</li>
<li><code>swap</code>:原子交换</li>
<li><code>compare_and_swap</code>:原子比较并交换</li>
<li><code>fetch_add</code>:原子加法后返回旧值</li>
</ul>
<p>下面这个例子演示了<code>AtomicI64</code>的基本原子操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicI64, Ordering};</div><div class="line"></div><div class="line"><span class="keyword">let</span> atomic_num = AtomicI64::new(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 原子加载</span></div><div class="line"><span class="keyword">let</span> num = atomic_num.load(Ordering::Relaxed);</div><div class="line"></div><div class="line"><span class="comment">// 原子加法并返回旧值 </span></div><div class="line"><span class="keyword">let</span> old = atomic_num.fetch_add(<span class="number">10</span>, Ordering::SeqCst);</div><div class="line"></div><div class="line"><span class="comment">// 原子比较并交换  </span></div><div class="line">atomic_num.compare_and_swap(old, <span class="number">100</span>, Ordering::SeqCst);</div><div class="line"></div><div class="line"><span class="comment">// 原子交换  </span></div><div class="line"><span class="keyword">let</span> swapped = atomic_num.swap(<span class="number">200</span>, Ordering::Release);</div><div class="line"></div><div class="line"><span class="comment">// 原子存储</span></div><div class="line">atomic_num.store(<span class="number">1000</span>, Ordering::Relaxed);</div></pre></td></tr></table></figure>

<p>上面示例了:</p>
<ul>
<li>load: 原子加载</li>
<li>fetch_add: 原子加法并返回旧值</li>
<li>compare_and_swap: 原子比较并交换</li>
<li>swap: 原子交换</li>
<li>store: 原子存储</li>
</ul>
<p>这些原子操作都可以确保线程安全,不会出现数据竞争。</p>
<p>不同的<code>Ordering</code>表示内存序不同强度的屏障,可以根据需要选择。</p>
<p><code>AtomicI64</code>提供了丰富的原子操作,可以实现无锁的并发算法和数据结构</p>
<h3 id="原子操作的_Ordering">原子操作的 Ordering</h3>
<p>在 Rust 中，<code>Ordering</code> 枚举用于指定原子操作时的内存屏障（memory ordering）。这与 C++ 的内存模型中的原子操作顺序性有一些相似之处，但也有一些不同之处。下面是 Ordering 的三个主要成员以及它们与 C++ 中的内存顺序的对应关系：</p>
<ol>
<li><strong>Ordering::Relaxed</strong><ul>
<li><strong>Rust（Ordering::Relaxed）</strong>： 最轻量级的内存屏障，没有对执行顺序进行强制排序。允许编译器和处理器在原子操作周围进行指令重排。\</li>
<li><strong>C++（memory_order_relaxed</strong>）： 具有相似的语义，允许编译器和处理器在原子操作周围进行轻量级的指令重排。</li>
</ul>
</li>
<li><strong>Ordering::Acquire</strong><ul>
<li><strong>Rust（Ordering::Acquire）</strong>： 插入一个获取内存屏障，防止后续的读操作被重排序到当前操作之前。确保当前操作之前的所有读取操作都在当前操作之前执行。</li>
<li><strong>C++（memory_order_acquire）</strong>： 在 C++ 中，memory_order_acquire 表示获取操作，确保当前操作之前的读取操作都在当前操作之前执行。</li>
</ul>
</li>
<li><strong>Ordering::Release</strong><ul>
<li><strong>Rust（Ordering::Release）</strong>： 插入一个释放内存屏障，防止之前的写操作被重排序到当前操作之后。确保当前操作之后的所有写操作都在当前操作之后执行。</li>
<li><strong>C++（memory_order_release）</strong>： 在 C++ 中，memory_order_release 表示释放操作，确保之前的写操作都在当前操作之后执行。</li>
</ul>
</li>
<li><strong>Ordering::AcqRel</strong><ul>
<li><strong>Rust（Ordering::AcqRel）</strong>： 插入一个获取释放内存屏障，既确保当前操作之前的所有读取操作都在当前操作之前执行，又确保之前的所有写操作都在当前操作之后执行。这种内存屏障提供了一种平衡，适用于某些获取和释放操作交替进行的场景。</li>
<li><strong>C++（memory_order_acq_rel）</strong>： 也表示获取释放操作，它是获取和释放的组合。确保当前操作之前的所有读取操作都在当前操作之前执行，同时确保之前的所有写操作都在当前操作之后执行。</li>
</ul>
</li>
<li><strong>Ordering::SeqCst</strong><ul>
<li><strong>Rust（Ordering::SeqCst</strong>）： 插入一个全序内存屏障，保证所有线程都能看到一致的操作顺序。是最强的内存顺序，用于实现全局同步。</li>
<li><strong>C++（memory_order_seq_cst）</strong>： 在 C++ 中，memory_order_seq_cst 也表示全序操作，保证所有线程都能看到一致的操作顺序。是 C++ 中的最强的内存顺序。</li>
</ul>
</li>
</ol>
<p>合理选择Ordering可以最大程度提高性能,同时保证需要的内存序约束。</p>
<p>但是如何合理的选择，这就依赖开发者的基本账功了，使用原子操作时需要小心，确保正确地选择适当的 Ordering，以及避免竞态条件和数据竞争。</p>
<p>像Go语言，直接使用了<code>Ordering::SeqCst</code>作为它的默认的内存屏障，开发者使用起来就没有心智负担了，但是你如果想更精细化的使用<code>Ordering</code>,请确保你一定清晰的了解你的代码逻辑和Ordering的意义。</p>
<h3 id="Ordering::Relaxed">Ordering::Relaxed</h3>
<p><code>Ordering::Relaxed</code> 是最轻量级的内存顺序，允许编译器和处理器在原子操作周围进行指令重排，不提供强制的执行顺序。这通常在对程序执行的顺序没有严格要求时使用，以获得更高的性能。</p>
<p>以下是一个简单的例子，演示了 Ordering::Relaxed 的用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 这里可能会有指令重排，因为使用了 Ordering::Relaxed</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::Relaxed);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，检查布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 这里可能会有指令重排，因为使用了 Ordering::Relaxed</span></div><div class="line">        <span class="keyword">let</span> value = atomic_bool.load(Ordering::Relaxed);</div><div class="line">        println!(<span class="string">"Received value: {}"</span>, value);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Ordering::Acquire">Ordering::Acquire</h3>
<p><code>Ordering::Acquire</code> 在 Rust 中表示插入一个获取内存屏障，确保当前操作之前的所有读取操作都在当前操作之前执行。这个内存顺序常常用于同步共享数据，以确保线程能够正确地观察到之前的写入操作。</p>
<p>以下是一个使用 <code>Ordering::Acquire</code> 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::Release);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::Acquire) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 Acquire 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Ordering::Release">Ordering::Release</h3>
<p><code>Ordering::Release</code> 在 Rust 中表示插入一个释放内存屏障，确保之前的所有写入操作都在当前操作之后执行。这个内存顺序通常用于同步共享数据，以确保之前的写入操作对其他线程可见。</p>
<p>以下是一个使用 <code>Ordering::Release</code> 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::Release);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::Acquire) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 Release 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程使用 <code>store</code> 方法将布尔值设置为 <code>true</code>，而消费者线程使用 <code>load</code> 方法等待并读取布尔值的状态。由于使用了 <code>Ordering::Release</code>，在生产者线程设置布尔值之后，会插入释放内存屏障，确保之前的所有写入操作都在当前操作之后执行。这确保了消费者线程能够正确地观察到生产者线程的写入操作。</p>
<h3 id="Ordering::AcqRel">Ordering::AcqRel</h3>
<p><code>Ordering::AcqRel</code> 在 Rust 中表示插入一个获取释放内存屏障，即同时包含获取和释放操作。它确保当前操作之前的所有读取操作都在当前操作之前执行，并确保之前的所有写入操作都在当前操作之后执行。这个内存顺序通常用于同步共享数据，同时提供了一些平衡，适用于需要同时执行获取和释放操作的场景。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::AcqRel);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::AcqRel) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 AcqRel 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程使用 store 方法将布尔值设置为 true，而消费者线程使用 load 方法等待并读取布尔值的状态。由于使用了 Ordering::AcqRel，在生产者线程设置布尔值之后，会插入获取释放内存屏障，确保之前的所有读取操作都在当前操作之前执行，同时确保之前的所有写入操作都在当前操作之后执行。这确保了消费者线程能够正确地观察到生产者线程的写入操作。</p>
<h3 id="Ordering::SeqCst">Ordering::SeqCst</h3>
<p><code>Ordering::SeqCst</code> 在 Rust 中表示插入一个全序内存屏障，保证所有线程都能看到一致的操作顺序。这是最强的内存顺序，通常用于实现全局同步。</p>
<p>以下是一个使用 Ordering::SeqCst 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::SeqCst);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::SeqCst) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 SeqCst 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程使用 <code>store</code> 方法将布尔值设置为 true，而消费者线程使用 <code>load</code> 方法等待并读取布尔值的状态。由于使用了 <code>Ordering::SeqCst</code>，在生产者线程设置布尔值之后，会插入全序内存屏障，确保所有线程都能看到一致的操作顺序。这确保了消费者线程能够正确地观察到生产者线程的写入操作。<code>SeqCst</code> 是最强的内存顺序，提供了最高级别的同步保证。</p>
<p>在Rust中,<code>Ordering::Acquire</code>内存顺序通常与<code>Ordering::Release</code>配合使用。</p>
<p><code>Ordering::Acquire</code>和<code>Ordering::Release</code>之间形成<code>happens-before</code>关系,可以实现不同线程之间的同步。</p>
<p>其典型用法是:</p>
<ul>
<li>当一个线程使用Ordering::Release写一个变量时,这给写操作建立一个释放屏障。</li>
<li>其他线程使用Ordering::Acquire读这个变量时,这给读操作建立一个获取屏障。</li>
<li>获取屏障确保读操作必须发生在释放屏障之后。</li>
</ul>
<p>这样就可以实现:</p>
<ul>
<li>写线程确保写发生在之前的任何读之前</li>
<li>读线程可以看到最新的写入值</li>
</ul>
<p>此外, <code>Ordering::AcqRel</code>也经常被用来同时具有两者的语义。</p>
<p>如果用<code>happens-before</code>描述这五种内存顺序，那么:</p>
<ul>
<li>Relaxed: 没有happens-before关系</li>
<li>Release: 对于给定的写操作A,该释放操作happens-before读操作B,当B读取的是A写入的最新值。和<code>Acquire</code>配套使用。</li>
<li>Acquire: 对于给定的读操作A,该获取操作happens-after写操作B,当A读取的是B写入的最新值。和<code>Release</code>配套使用。</li>
<li>AcqRel: 同时满足Acquire和Release的happens-before关系。</li>
<li>SeqCst: 所有的SeqCst操作之间都存在happens-before关系,形成一个全序。</li>
</ul>
<p><code>happens-before</code>关系表示对给定两个操作A和B:</p>
<ul>
<li>如果<code>A happens-before B</code>,那么A对所有线程可见,必须先于B执行。</li>
<li>如果没有<code>happens-before</code>关系,则A和B之间可能存在重排序和可见性问题。</li>
</ul>
<p><code>Release</code>建立写之前的<code>happens-before</code>关系,<code>Acquire</code>建立读之后的关系。两者搭配可以实现写入对其他线程可见。、<br><code>SeqCst</code>强制一个全序,所有操作都是有序的。</p>

      
    </div>
    <footer class="article-footer">
      

      
      <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script> -->
      <section id="comments">
        <script src="https://utteranc.es/client.js"
                repo="smallnest/gitalk"
                issue-term="title"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
        <!-- <div id="gitalk-container"></div>
        <script type="text/javascript">
          var gitalkOpts = {
            id: '2023/10/22/concurrency-programming-via-rust-ch05',
            owner: 'smallnest',
            repo: 'gitalk',
            title: 'Rust并发编程5 - 基本并发原语',
            body: 'https://colobu.com/2023/10/22/concurrency-programming-via-rust-ch05/',
            clientID: 'bc02724130ed5b7ee275',
            clientSecret: '68cb0bae2f93a8b88b09e0eb9b08c844b06a9047',
            admin: ['smallnest'],
            distractionFreeMode: false
          };

          const gitalk = new Gitalk(gitalkOpts)
          gitalk.render('gitalk-container')
        </script> -->
        <noscript> 为正常使用评论功能请激活JavaScript</noscript>
      </section>

      

    </footer>
  </div>
  
  
<nav id="article-nav">
  
    <a href="/2023/10/22/how-to-use-pipe-in-Go-exec-Command/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          如何在Go语言中实现Unix风格的进程管道？
        
      </div>
    </a>
  
  
    <a href="/2023/10/19/better-http-server-routing-in-go-112/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">不看就落后了，Go 1.22 中更好的http router</div>
    </a>
  
</nav>

  
</article></section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title">访问者来源</h3>
  <div class="widget">
    <script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=Hf4EJSi2XvL6TMcuFSH51Qn6nf5nZ8qnjVBnWCQ4FGc"></script>
  </div>
</div>

<div class="widget-wrap">
  <h3 class="widget-title">微信公众号</h3>
  <div class="widget">
    <img width="100%" src="/images/widgets/gopatterns.jpg">
  </div>
</div>

<div class="widget-wrap">
  <h3 class="widget-title">极客时间专栏</h3>
  <div class="widget">
    <a href="https://time.geekbang.org/column/intro/100061801">
      <img width="100%" src="/images/widgets/geekbang.png">
    </a>
  </div>
</div>

<div class="widget-wrap">
    <h3 class="widget-title">出版图书</h3>
    <div class="widget">
      <a href="https://cpgo.colobu.com/">
        <img width="100%" src="/cpgolang/cpgo.png">
      </a>
    </div>
    <div class="widget">
      <a href="https://www.books.com.tw/products/0010991366">
        <img width="100%" src="/cpgolang/cpgo2.jpg">
      </a>
    </div>
    <div class="widget">
      <a href="https://item.jd.com/14347716.html">
        <img width="100%" src="/100gomistakes/cover.png">
      </a>
    </div>
    <div class="widget">
      <a href="/ScalaCollectionsCookbook/">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook.jpg">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook_tw.png">
      </a>
    </div>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DOTNET/">DOTNET</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">287</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">64</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rust/">rust</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">60</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理/">管理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高并发编程/">高并发编程</a><span class="category-list-count">20</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 15.71px;">Android</a><a href="/tags/ApacheBench/" style="font-size: 11.43px;">ApacheBench</a><a href="/tags/Bower/" style="font-size: 10.00px;">Bower</a><a href="/tags/C/" style="font-size: 10.00px;">C#</a><a href="/tags/CDN/" style="font-size: 10.00px;">CDN</a><a href="/tags/CQRS/" style="font-size: 10.00px;">CQRS</a><a href="/tags/CRC/" style="font-size: 10.00px;">CRC</a><a href="/tags/CSS/" style="font-size: 11.43px;">CSS</a><a href="/tags/CompletableFuture/" style="font-size: 10.00px;">CompletableFuture</a><a href="/tags/Comsat/" style="font-size: 10.00px;">Comsat</a><a href="/tags/Curator/" style="font-size: 18.57px;">Curator</a><a href="/tags/DSL/" style="font-size: 10.00px;">DSL</a><a href="/tags/Disruptor/" style="font-size: 10.00px;">Disruptor</a><a href="/tags/Docker/" style="font-size: 11.43px;">Docker</a><a href="/tags/Ember/" style="font-size: 11.43px;">Ember</a><a href="/tags/FastJson/" style="font-size: 10.00px;">FastJson</a><a href="/tags/Fiber/" style="font-size: 10.00px;">Fiber</a><a href="/tags/GAE/" style="font-size: 10.00px;">GAE</a><a href="/tags/GC/" style="font-size: 12.86px;">GC</a><a href="/tags/Gnuplot/" style="font-size: 10.00px;">Gnuplot</a><a href="/tags/Go/" style="font-size: 14.29px;">Go</a><a href="/tags/Gradle/" style="font-size: 10.00px;">Gradle</a><a href="/tags/Grunt/" style="font-size: 10.00px;">Grunt</a><a href="/tags/Gulp/" style="font-size: 10.00px;">Gulp</a><a href="/tags/Hadoop/" style="font-size: 10.00px;">Hadoop</a><a href="/tags/Hazelcast/" style="font-size: 10.00px;">Hazelcast</a><a href="/tags/IPFS/" style="font-size: 10.00px;">IPFS</a><a href="/tags/Ignite/" style="font-size: 10.00px;">Ignite</a><a href="/tags/JVM/" style="font-size: 10.00px;">JVM</a><a href="/tags/Java/" style="font-size: 17.14px;">Java</a><a href="/tags/Kafka/" style="font-size: 20.00px;">Kafka</a><a href="/tags/Lambda/" style="font-size: 14.29px;">Lambda</a><a href="/tags/Linux/" style="font-size: 12.86px;">Linux</a><a href="/tags/LongAdder/" style="font-size: 10.00px;">LongAdder</a><a href="/tags/MathJax/" style="font-size: 10.00px;">MathJax</a><a href="/tags/Maven/" style="font-size: 11.43px;">Maven</a><a href="/tags/Memcached/" style="font-size: 10.00px;">Memcached</a><a href="/tags/Metrics/" style="font-size: 10.00px;">Metrics</a><a href="/tags/Mongo/" style="font-size: 12.86px;">Mongo</a><a href="/tags/Netty/" style="font-size: 15.71px;">Netty</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/02/Russ-Cox-and-his-Oscar/">Russ Cox 引退以及他的新项目 Oscar</a>
          </li>
        
          <li>
            <a href="/2024/06/16/atomic128/">128位整数的原子操作</a>
          </li>
        
          <li>
            <a href="/2024/06/11/go-evolves-in-the-wrong-direction/">Go 朝着错误的方向发展</a>
          </li>
        
          <li>
            <a href="/2024/06/10/The-Analects-of-Rob-Pike/">Rob Pike 语录</a>
          </li>
        
          <li>
            <a href="/2024/06/09/rust-tips-81-90/">Rust tips #81 ~ #90</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
			 
            <a href="http://stackshare.io" target="_blank">技术栈</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="https://toutiao.io/" target="_blank">开发者头条</a>
			
          </li>
        
          <li>
			 
            <a href="http://weekly.manong.io/issues/" target="_blank">码农周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.tuicool.com/mags" target="_blank">编程狂人周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.importnew.com/" target="_blank">importnew</a>
			
          </li>
        
          <li>
			 
            <a href="http://ifeve.com/" target="_blank">并发编程网</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="http://github.com" target="_blank">github</a>
			
          </li>
        
          <li>
			 
            <a href="http://stackoverflow.com/" target="_blank">stackoverflow</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.javacodegeeks.com/" target="_blank">javacodegeeks</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.infoq.com/" target="_blank">infoq</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.dzone.com/links/index.html" target="_blank">dzone</a>
			
          </li>
        
          <li>
			 
            <a href="https://oj.leetcode.com/problems/" target="_blank">leetcode</a>
			
          </li>
        
          <li>
			 
            <a href="http://tutorials.jenkov.com" target="_blank">jenkov</a>
			
          </li>
        
          <li>
			 
            <a href="https://howtodoinjava.com" target="_blank">HowToDoInJava</a>
			
          </li>
        
          <li>
			 
            <a href="https://java-design-patterns.com/patterns/" target="_blank">java design patterns</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="https://medium.com/netflix-techblog" target="_blank">Netflix技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://www.techiedelight.com" target="_blank">Techie Delight</a>
			
          </li>
        
          <li>
			 
            <a href="https://engineering.linkedin.com/blog" target="_blank">Linkedin技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://blogs.dropbox.com/tech/" target="_blank">Dropbox技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://code.fb.com" target="_blank">Facebook技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="http://jm.taobao.org" target="_blank">淘宝中间件团队</a>
			
          </li>
        
          <li>
			 
            <a href="https://tech.meituan.com" target="_blank">美团技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="http://blogs.360.cn" target="_blank">360技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://xiaomi-info.github.io" target="_blank">小米信息部技术团队</a>
			
          </li>
        
      </ul>
    </div>
  </div>

  
      

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 smallnest<br>
	  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    
      <a href="/" class="mobile-nav-link"><i class="fa fa-home">&nbsp;</i>首页</a>
    
  
    
      <a href="/archives" class="mobile-nav-link"><i class="fa fa-folder-o">&nbsp;</i>归档</a>
    
  
    
      <a href="https://github.com/smallnest" class="mobile-nav-link"><i class="fa fa-github">&nbsp;</i>github</a>
    
  
    
      <a class="mobile-nav-link" href="#"><i class="fa fa-bars">&nbsp;</i>网站群</a>
    
      
            <a class="mobile-nav-link" href="/goasm">&nbsp;&nbsp;<i class="fa fa-language">&nbsp;</i>Go汇编示例</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://gowebexamples.com">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go Web开发示例</a>
          
          
    
      
            <a class="mobile-nav-link" href="http://go-database-sql.org">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go 数据库开发教程</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://colobu.com/gotips/">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go 语言编程技巧</a>
          
          
    
      
            
          
          
    
      
            <a class="mobile-nav-link" href="/perf-book">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust高性能编程指南</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust100">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>100个练习题学习Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://github.com/rustcc/Rust_Atomics_and_Locks">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust原子操作和锁</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustx-labs.github.io/effective-rust-cn/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>高效Rust编程</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustwiki.org/zh-CN/book/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust程序设计语言</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://nomicon.purewhite.io/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust死灵书</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustwiki.org/zh-CN/reference/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust参考手册</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://zjp-cn.github.io/tlborm/translation_statement.html">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust宏小册</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://huangjj27.github.io/async-book/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust异步编程书</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustwiki.org/zh-CN/rust-by-example/hello.html">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>通过例子学Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rust-chinese-translation.github.io/api-guidelines/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust API 编写指南</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://google.github.io/comprehensive-rust/zh-CN/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>全面Rust课程</a>
          
          
    
      
            
          
          
    
      
            <a class="mobile-nav-link" href="http://rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPCX官网</a>
          
          
    
      
            <a class="mobile-nav-link" href="http://cn.doc.rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPC开发指南</a>
          
          
    
    
  
    
      <a href="/ScalaCollectionsCookbook" class="mobile-nav-link"><i class="fa fa-solid fa-book">&nbsp;</i>Scala集合技术手册</a>
    
  
    
      <a href="/about" class="mobile-nav-link"><i class="fa fa-lemon-o">&nbsp;</i>关于</a>
    
  
</nav>
    
<script src="//cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script>
<script src="//cdn.bootcss.com/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>


<script src="/js/script.js" type="text/javascript"></script>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.6.0-beta.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div id="totop" style="position:fixed;bottom:150px;right:10px;cursor: pointer;z-index: 2000;">
	<a title="返回顶部"><img src="/images/scrollup.png"/></a>
</div>
<script src="/js/totop.js" type="text/javascript"></script>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e085d87993250aab11f3e0c15f1c2785";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </div>
</body>
</html>