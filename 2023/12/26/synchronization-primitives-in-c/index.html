<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  
  <title>C++中的同步原语</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++中的同步原语">
<meta property="og:url" content="https://colobu.com/2023/12/26/synchronization-primitives-in-c/">
<meta property="og:site_name" content="鸟窝">
<meta property="og:description" content="C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++中的同步原语">
<meta name="twitter:description" content="C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。">

  
  <link rel="alternative" href="/atom.xml" title="鸟窝" type="application/atom+xml">
  
  
  <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <link href="//cdn.bootcdn.net/ajax/libs/font-awesome/6.6.0/css/all.min.css" rel="stylesheet">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/css/jquery.fancybox.min.css"
    media="screen" type="text/css">
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" media="screen"
    type="text/css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap" class="animated bounceInLeft">
        <a href="/" id="logo">鸟窝</a>
      </h1>
      
        <!-- <h2 id="subtitle-wrap" class="animated bounceInLeft"> -->
        <h2 id="subtitle-wrap">
          <!-- <a href="/" id="subtitle">大道至简 Simplicity is the ultimate form of sophistication</a> -->
          <a href="https://item.jd.com/14283252.html" target="_blank" style="color: #e32d40;text-decoration: none;"><b>《Go語言全功能開發養成書》繁体中文版发售。一书在手，并发无忧</b></a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class="fa fa-home">&nbsp;</i>首页</a>
          
          
          
            <a class="main-nav-link" href="/archives"><i class="fa fa-regular fa-folder-open">&nbsp;</i>归档</a>
          
          
          
            <a class="main-nav-link" href="https://github.com/smallnest"><i class="fa fa-brands fa-github-alt">&nbsp;</i>github</a>
          
          
          
            <div class="dropdown main-nav-link"><a class="main-nav-link" href="#"><i class="fa fa-brands fa-golang">&nbsp;</i>Go学习资源</a>
              <div class="dropdown-content">
          
            
              <a href="/goasm"><i class="fa fa-brands fa-golang"></i>&nbsp;Go汇编示例</a>
            
                
          
            
              <a href="https://gowebexamples.com"><i class="fa fa-brands fa-golang"></i>&nbsp;Go Web开发示例</a>
            
                
          
            
              <a href="http://go-database-sql.org"><i class="fa fa-brands fa-golang"></i>&nbsp;Go 数据库开发教程</a>
            
                
          
            
              <a href="https://colobu.com/gotips/"><i class="fa fa-brands fa-golang"></i>&nbsp;Go 语言编程技巧</a>
            
                
          
            
              <hr>
            
                
          
            
              <a href="http://rpcx.io"><i class="fa undefined"></i>&nbsp;RPCX官网</a>
            
                
          
            
              <a href="http://cn.doc.rpcx.io"><i class="fa undefined"></i>&nbsp;RPC开发指南</a>
            
                
          
          </div>
        </div>
          
          
          
            <div class="dropdown main-nav-link"><a class="main-nav-link" href="#"><i class="fa fa-brands fa-rust">&nbsp;</i>Rust学习资源</a>
              <div class="dropdown-content">
          
            
              <a href="/perf-book"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust高性能编程指南</a>
            
                
          
            
              <a href="/rust100"><i class="fa fa-brands fa-rust"></i>&nbsp;100个练习题学习Rust</a>
            
                
          
            
              <a href="/atomics"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust原子操作和锁</a>
            
                
          
            
              <a href="/effective-rust"><i class="fa fa-brands fa-rust"></i>&nbsp;高效Rust编程</a>
            
                
          
            
              <a href="/thebook"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust程序设计语言</a>
            
                
          
            
              <a href="/nomicon"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust死灵书</a>
            
                
          
            
              <a href="/rust-reference"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust参考手册</a>
            
                
          
            
              <a href="/tlborm"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust宏小册</a>
            
                
          
            
              <a href="/async-book"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust异步编程书</a>
            
                
          
            
              <a href="/rust-by-example"><i class="fa fa-brands fa-rust"></i>&nbsp;通过例子学Rust</a>
            
                
          
            
              <a href="/api-guidelines"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust API 编写指南</a>
            
                
          
            
              <a href="/comprehensive-rust"><i class="fa fa-brands fa-rust"></i>&nbsp;全面Rust课程</a>
            
                
          
            
              <a href="/easy-rust"><i class="fa fa-brands fa-rust"></i>&nbsp;简单英语学Rust</a>
            
                
          
            
              <a href="/rust-patterns"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust设计模式</a>
            
                
          
            
              <a href="/2020/03/05/A-half-hour-to-learn-Rust/"><i class="fa fa-brands fa-rust"></i>&nbsp;半小时学会Rust</a>
            
                
          
            
              <a href="/rust-cookbook"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust实用指南(cookbook)</a>
            
                
          
            
              <a href="/rust-rand"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust随机库</a>
            
                
          
            
              <hr>
            
                
          
            
              <a href="https://rpcx.io/r/E6v8U"><i class="fa undefined"></i>&nbsp;Rust for the Polyglot Programmer</a>
            
                
          
            
              <a href="https://rpcx.io/r/oC5ii"><i class="fa undefined"></i>&nbsp;LifetimeKata</a>
            
                
          
            
              <a href="https://tfpk.github.io/macrokata/"><i class="fa undefined"></i>&nbsp;macrokata</a>
            
                
          
          </div>
        </div>
          
          
          
            <a class="main-nav-link" href="/ScalaCollectionsCookbook"><i class="fa fa-solid fa-book">&nbsp;</i>Scala集合技术手册</a>
          
          
          
            <a class="main-nav-link" href="/about"><i class="fa fa-regular fa-address-card">&nbsp;</i>关于</a>
          
          


      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="https://www.google.com/search" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" id="search-word" name="q" maxlength="20" class="search-form-input" placeholder="Search">
          <input type=hidden name=ie value="utf-8">
          <input type=hidden name=oe value="utf-8">
          <input type=hidden name=hl value="zh-CN">
          <input type="submit" id="search-submit" value="" class="search-form-submit">
        </form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-synchronization-primitives-in-c" class="article article-type-post" itemscope
  itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/12/26/synchronization-primitives-in-c/" class="article-date">
  <time datetime="2023-12-26T14:59:31.000Z" itemprop="datePublished">2023年12月26日</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

    
  <div class="article-author"> by smallnest</div>

  </div>
  <div class="article-inner">
    
    
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      C++中的同步原语
	  
    </h1>
  

    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
      
      <script>function show_answer(btn, x) { if (btn.value === "显示答案") { btn.value = "隐藏答案" } else { btn.value = "显示答案" } var as = document.getElementById(x); if (as.style.display === "none") { as.style.display = "block" } else { as.style.display = "none" } }</script>
      <p>C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。</p>
<a id="more"></a>
<h2 id="std::thread">std::thread</h2>
<p><code>std::thread</code>是在C++11中引入的，它表示一个可执行的线程。线程允许多个函数并发执行。</p>
<p>线程在关联的线程对象构造完成后立即开始执行（受操作系统调度延迟影响），从作为构造函数参数提供的顶级函数开始。顶级函数的返回值会被忽略，如果它通过抛出异常终止，std::terminate 会被调用。顶级函数可以通过 std::promise 或通过修改共享变量（可能需要同步，参见 std::mutex 和 std::atomic）向调用者传达其返回值或异常。</p>
<p>std::thread 对象也可能处于不表示任何线程的状态（在默认构造、移动构造、分离或加入之后），而且执行线程可能不与任何线程对象关联（在分离之后）。</p>
<p>没有两个 std::thread 对象可以表示同一个执行线程；std::thread 不可复制构造或复制赋值，尽管它是可移动构造和可移动赋值的。</p>
<p>你需要手动管理线程的生命周期，包括启动和加入（或分离）线程。如果你忘记在一个<code>std::thread</code>对象销毁之前加入（<code>join</code>）或分离（<code>detach</code>）它的线程，程序将会终止（因为<code>std::thread</code>的析构函数会调用<code>std::terminate</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> threadFunction() {</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from thread!\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::thread t(threadFunction);</div><div class="line">    <span class="comment">// 必须在t销毁之前对其调用join或detach</span></div><div class="line">    t.join(); <span class="comment">// 等待线程结束</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="std::jthread">std::jthread</h2>
<p><code>std::jthread</code>是在C++20中引入的，它提供了一些改进和附加功能，相比于<code>std::thread</code>，使得线程管理变得更加容易和安全。</p>
<p>它在std::thread的基础上增加了自动的线程加入功能。std::jthread的一个关键特性是它的析构函数会自动请求线程停止（如果支持的话）并等待线程完成，从而减少了程序员需要手动管理线程生命周期的需求。</p>
<p>此外，std::jthread支持协作式中断，它提供了一种机制，使得线程可以被请求停止执行。这是通过传递一个std::stop_token来实现的，线程函数可以定期检查这个stop_token来决定是否应该停止执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> threadFunction(std::stop_token stoken) {</div><div class="line">    <span class="keyword">while</span> (!stoken.stop_requested()) { <span class="comment">// 检查是否请求停止线程</span></div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from jthread!\n"</span>;</div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    }</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping as requested.\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::jthread jt(threadFunction);</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">3</span>));</div><div class="line">    <span class="comment">// 不需要手动调用join，析构函数会自动处理</span></div><div class="line">    <span class="comment">// jt.request_stop(); 如果需要提前请求停止线程，则调用这个</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的例子中，<code>std::jthread</code>的析构函数会自动调用<code>request_stop</code>来请求线程函数停止，然后等待线程完成。这使得使用<code>std::jthread</code>比<code>std::thread</code>更加安全和方便，因为它消除了忘记加入或分离线程时可能出现的问题。</p>
<p>总结来说，<code>std::jthread</code>在<code>std::thread</code>的基础上提供了自动加入和协作式中断的功能，从而简化了线程的管理。如果你使用的是C++20或更高版本，优先考虑使用<code>std::jthread</code>。</p>
<h2 id="atomic">atomic</h2>
<h3 id="std::atomic">std::atomic</h3>
<p><code>std::atomic</code> 是一个模板类，提供了一种机制来安全地在多线程环境中操作共享数据，而不需要使用互斥锁。<code>std::atomic</code> 类型保证了基本的原子操作，比如读取、写入、递增和递减等，都是原子性的，也就是说在一个操作执行完毕前，不会被其他线程打断。</p>
<p>原子性意味着当一个线程正在执行原子操作时，没有其他线程可以同时执行任何其他对同一数据的原子操作。此外，C++11 引入的内存模型定义了原子操作的内存顺序（memory order），这是一个非常复杂的主题，决定了在不同线程中操作之间的可见性和排序。我在《并发编程顶峰对决： Go vs Rust》讲了Rust的内存顺序模型，也提到了Rust的内存顺序模型和C++的内存顺序模型，这里就不赘述了,总之内存序包含下面几种类型，你应该正确且清晰的使用它们：</p>
<ul>
<li>std::memory_order_relaxed</li>
<li>std:: memory_order_consume</li>
<li>std::memory_order_acquire</li>
<li>std::memory_order_release</li>
<li>std::memory_order_acq_rel</li>
<li>std::memory_order_seq_cst</li>
</ul>
<p><code>std::atomic</code> 类型的对象可以通过调用成员函数<code>load</code>和<code>store</code>来读取和写入，也可以通过<code>operator++</code>和<code>operator--</code>来递增和递减。<code>std::atomic</code> 类型的对象还可以通过调用成员函数<code>exchange</code>来交换值，通过调用成员函数<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>来比较和交换值。</p>
<p><code>wait</code>、<code>notify</code>和<code>notify_all</code>函数可以用来等待和通知其他线程，这些函数在C++20中引入。有点像条件变量。</p>
<p>通过<code>std::atomic</code>类模板，我们可以创建原子类型的对象，比如<code>std::atomic&lt;int&gt;</code>，<code>std::atomic&lt;bool&gt;</code>，<code>std::atomic&lt;std::string&gt;</code>等等。<code>std::atomic</code>类模板还提供了一些特化版本，比如<code>std::atomic_flag</code>，<code>std::atomic_bool</code>，<code>std::atomic_int</code>，<code>std::atomic_uint</code>，<code>std::atomic_llong</code>等等。</p>
<p>下面是一个计数器的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::atomic&lt;<span class="keyword">int</span>&gt; counter(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> increment() {</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) {</div><div class="line">        counter.fetch_add(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment));</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& t : threads) {</div><div class="line">        t.join();</div><div class="line">    }</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Counter: "</span> &lt;&lt; counter.load() &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，10个线程并发地递增一个std::atomic<int>计数器。由于counter是原子类型，所以每个线程的修改都是原子操作，不会相互干扰。最终的计数器值应该是100000。</int></p>
<h3 id="std::atomic_flag">std::atomic_flag</h3>
<p><code>std::atomic_flag</code> 是 C++11 中引入的原子类型，它是最简单的原子类型，提供了一个布尔标志，可以用来进行简单的锁定操作。由于其简单性，<code>std::atomic_flag</code> 通常可以实现为一个非常高效的原子类型，因此它在实现自旋锁等低级同步原语时非常有用。</p>
<p><code>std::atomic_flag</code> 保证是 <code>lock-free</code> 的，即不会引起调用线程的阻塞。这是 <code>std::atomic_flag</code> 相对于其他原子类型的一个独特优点，因为其他原子类型在一些平台上可能不是 <code>lock-free</code> 的。</p>
<p>std::atomic_flag 提供以下几个主要操作：</p>
<ul>
<li>clear(): 将标志设置为 false。</li>
<li>test_and_set(): 测试标志的当前值，然后将其设置为 true。这个操作是原子的，即测试和设置是一个不可分割的步骤。</li>
<li>test(): C++20 新增的操作，测试标志的当前值而不修改它。</li>
<li>wait(): C++20 新增的操作，如果标志为 true，则阻塞调用线程。</li>
<li>notify_one(): C++20 新增的操作，通知等待线程中的一个线程。</li>
<li>notify_all(): C++20 新增的操作，通知等待线程中的所有线程。</li>
</ul>
<p>下面这个例子是检查 atomic_flag 是否已被设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"></div><div class="line">std::atomic_flag flag = ATOMIC_FLAG_INIT;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="comment">// 设置标志</span></div><div class="line">    flag.test_and_set();</div><div class="line">    </div><div class="line">    <span class="comment">// 检查标志是否已经设置</span></div><div class="line">    <span class="keyword">if</span> (flag.test()) {</div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Flag is set.\n"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 清除标志</span></div><div class="line">    flag.clear();</div><div class="line">    </div><div class="line">    <span class="comment">// 再次检查标志</span></div><div class="line">    <span class="keyword">if</span> (!flag.test()) {</div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Flag is cleared.\n"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="std::atomic_ref">std::atomic_ref</h3>
<p><code>std::atomic_ref</code> 是 C++20 引入的一个模板类，它提供了对非原子类型的原子操作。这意味着你可以将 <code>std::atomic_ref</code> 对象绑定到非原子类型的引用上，并执行原子操作，而无需将该类型本身声明为原子类型。这在你需要对现有数据结构中的某个成员进行原子操作，而不想更改数据结构定义时非常有用。</p>
<p><code>std::atomic_ref</code> 的特性</p>
<ul>
<li><code>std::atomic_ref</code> 通过引用传递给它的对象，并提供原子访问。</li>
<li>它对绑定的对象执行原子操作，如加载(load)、存储(store)、增加(fetch_add)、减少(fetch_sub)等。</li>
<li><code>std::atomic_ref</code> 不拥有它所绑定的对象，故该对象的生命周期必须超过 std::atomic_ref 对象的生命周期。</li>
<li>你可以在多个 <code>std::atomic_ref</code> 实例之间共享同一个对象，但是要保证这些实例不会同时访问该对象。</li>
</ul>
<p>std::atomic_ref 的主要成员函数</p>
<ul>
<li>store(T desired, std::memory_order order = std::memory_order_seq_cst): 将 desired 值原子地存储到引用的对象中。</li>
<li>T load(std::memory_order order = std::memory_order_seq_cst) const: 原子地加载并返回引用的对象的值。</li>
<li>T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst): 原子地将 arg 添加到引用的对象的当前值，并返回之前的值。</li>
<li>T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst): 原子地从引用的对象的当前值中减去 arg，并返回之前的值。</li>
<li>bool compare_exchange_weak(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst): 原子地比较引用的对象的值与 expected，如果相同，则将该对象的值设置为 desired。</li>
<li>bool compare_exchange_strong(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst): 类似于 compare_exchange_weak，但具有更强的保证，防止假失败。</li>
<li>wait(): C++20 新增的操作，如果标志为 true，则阻塞调用线程。</li>
<li>notify_one(): C++20 新增的操作，通知等待线程中的一个线程。</li>
<li>notify_all(): C++20 新增的操作，通知等待线程中的所有线程。</li>
</ul>
<p>以下是一个使用 std::atomic_ref 的简单示例，演示了如何对一个共享的 int 变量执行原子操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="keyword">int</span> shared_value = <span class="number">0</span>;</div><div class="line">    std::atomic_ref&lt;<span class="keyword">int</span>&gt; atomic_ref(shared_value);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> incrementer = [&atomic_ref]() {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">            atomic_ref.fetch_add(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子地增加 shared_value 的值</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    <span class="comment">// 创建 10 个线程，每个线程都增加 shared_value 的值</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.emplace_back(incrementer);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final value of shared_value: "</span> &lt;&lt; shared_value &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// 正确的输出应该是 1000</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个普通的 int 类型变量 <code>shared_value</code> 和一个 <code>std::atomic_ref&lt;int&gt;</code> 实例 <code>atomic_ref</code>，后者引用了前者。然后我们启动了 10 个线程，每个线程都通过 <code>atomic_ref</code> 原子地对 <code>shared_value</code> 执行 100 次增加操作。在所有线程完成后，我们期望 <code>shared_value</code> 的最终值为 1000。</p>
<h2 id="std::mutex">std::mutex</h2>
<p><code>std::mutex</code> 用于保护共享数据，避免多个线程同时访问导致的数据竞争和不一致性。当多个线程尝试同时修改同一数据时，<code>std::mutex</code> 提供了一种机制来确保只有一个线程能够访问数据，其余试图访问该数据的线程将被阻塞，直到拥有互斥锁的线程释放锁为止。</p>
<p><code>std::mutex</code> 的主要操作</p>
<ul>
<li>lock(): 阻塞当前线程，直到能够锁定该互斥锁。如果互斥锁已被其他线程锁定，则当前线程将等待（阻塞），直到互斥锁被解锁。</li>
<li>unlock(): 解锁互斥锁，允许其他正在等待的线程能够尝试锁定互斥锁。</li>
<li>try_lock(): 尝试锁定互斥锁，如果互斥锁当前未被锁定，则锁定它并立即返回 true；如果已被其他线程锁定，则不会阻塞当前线程，立即返回 false。</li>
</ul>
<p>使用 <code>std::mutex</code> 保护共享数据的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> increment_counter() {</div><div class="line">    mtx.lock(); <span class="comment">// 获取锁</span></div><div class="line">    ++counter; <span class="comment">// 修改共享数据</span></div><div class="line">    mtx.unlock(); <span class="comment">// 释放锁</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发环境</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment_counter));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : threads) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value: "</span> &lt;&lt; counter &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，100个线程尝试并发地增加一个共享计数器。没有互斥锁的情况下，多个线程可能同时读写同一内存位置，导致计数器的值不正确。通过使用 std::mutex，我们确保了每次只有一个线程能够增加计数器，从而保证了最终结果的正确性。</p>
<p>可以使用<code>std::lock_guard</code> 管理 <code>std::mutex</code> 的锁定和解锁,类似Rust:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> increment_counter() {</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mtx); <span class="comment">// 创建 lock_guard 对象时自动获取锁，并在作用域结束时自动释放锁</span></div><div class="line">    ++counter; <span class="comment">// 修改共享数据</span></div><div class="line">    <span class="comment">// lock_guard 对象析构时自动调用 unlock</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发环境</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment_counter));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : threads) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value: "</span> &lt;&lt; counter &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了基本的 <code>std::mutex</code>，还提供了几种其他类型的锁，用于满足不同的同步需求。以下是一些常见的锁类型：</p>
<ul>
<li>std::recursive_mutex<br><code>std::recursive_mutex</code> 是一种特殊类型的互斥锁，它允许同一个线程多次对同一个互斥锁加锁（即递归锁定）。每次对 <code>std::recursive_mutex</code> 的成功锁定都必须由相应数量的解锁操作与之匹配。这适用于递归函数调用，其中函数可能会直接或间接地多次请求同一互斥锁。</li>
<li>std::timed_mutex<br><code>std::timed_mutex</code> 是互斥锁的一个扩展，它提供了尝试锁定一段时间的功能。如果锁在指定时间内未被获取，则尝试锁定操作失败并返回。它提供了两个额外的成员函数：<code>try_lock_for()</code> 和 <code>try_lock_until()</code>，分别用于指定等待锁定的时间长度和绝对时间点。</li>
<li>std::recursive_timed_mutex<br><code>std::recursive_timed_mutex</code> 结合了 <code>std::recursive_mutex</code> 和 <code>std::timed_mutex</code> 的功能，允许一个线程对同一个互斥锁进行多次锁定，并提供了基于时间的锁定尝试。</li>
<li>std::shared_mutex<br><code>std::shared_mutex</code> 是一个读写锁，它允许多个线程同时读取共享数据（共享锁定），但一次只允许一个线程写入（独占锁定）。它提供了 <code>lock_shared()</code> 和 <code>unlock_shared()</code> 来管理共享锁定，以及 <code>lock()</code> 和 <code>unlock()</code> 来管理独占锁定。</li>
<li>std::shared_timed_mutex<br><code>std::shared_timed_mutex</code> 结合了 <code>std::shared_mutex</code> 和 <code>std::timed_mutex</code> 的特性，提供了时间限制的读写锁。它允许多个线程在一段时间内尝试以共享或独占方式锁定互斥锁。</li>
</ul>
<p>还有一些辅助管理mutex的类：</p>
<ul>
<li><p>std::lock_guard<br><code>std::lock_guard</code> 是一个作用域锁，当创建它的对象时自动获取互斥锁，并在该对象的生命周期结束时自动释放互斥锁。<code>std::lock_guard</code> 不支持显式的解锁操作或条件等待。</p>
</li>
<li><p>std::unique_lock<br><code>std::unique_lock</code> 是一个灵活的作用域锁，它提供了比 <code>std::lock_guard</code> 更多的功能，包括延迟锁定、时间限制的锁定尝试、递归锁定以及条件变量的支持。<code>std::unique_lock</code> 对象可以在其生命周期中多次锁定和解锁关联的互斥锁。</p>
</li>
<li><p>std::scoped_lock (C++17)<br><code>std::scoped_lock</code> 是 C++17 引入的一个作用域锁，它可以锁定一个或多个互斥锁，而无需担心死锁。它在内部使用了一个死锁避免算法（如锁的排序获取），确保在多个互斥锁的情况下不会发生死锁。</p>
</li>
</ul>
<p>一个读写锁的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;shared_mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::shared_mutex rw_mutex;</div><div class="line"><span class="keyword">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> reader(<span class="keyword">int</span> id) {</div><div class="line">    std::shared_lock&lt;std::shared_mutex&gt; lock(rw_mutex); <span class="comment">// 获取共享锁</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reader #"</span> &lt;&lt; id &lt;&lt; <span class="string">" read value: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> writer(<span class="keyword">int</span> id) {</div><div class="line">    std::unique_lock&lt;std::shared_mutex&gt; lock(rw_mutex); <span class="comment">// 获取独占锁</span></div><div class="line">    ++shared_data;</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writer #"</span> &lt;&lt; id &lt;&lt; <span class="string">" wrote value: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> readers;</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> writers;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建读者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</div><div class="line">        readers.push_back(std::thread(reader, i));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 创建写者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        writers.push_back(std::thread(writer, i));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待读者线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : readers) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待写者线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : writers) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::shared_mutex</code> 被用作一个读写锁来保护共享数据。读者线程使用 <code>std::shared_lock</code> 获取共享锁，这允许多个读者线程同时读取数据。写者线程使用 <code>std::unique_lock</code> 获取独占锁，这确保了在写入数据时只有一个写者线程可以访问数据。</p>
<h2 id="std::condition_variable">std::condition_variable</h2>
<p><code>std::condition_variable</code> 用于在多线程程序中进行线程间的通知和等待操作。它允许一个或多个线程在某些条件成立之前挂起（等待），直到另一个线程通知它们条件已经满足。<br><code>std::condition_variable</code> 通常与 <code>std::mutex</code>（或 <code>std::unique_lock</code>）一起使用，以保护共享数据并提供安全的同步机制。</p>
<p>主要方法：</p>
<ul>
<li>wait(): 阻塞当前线程，直到其他线程调用 notify_one() 或 notify_all()。在等待期间，互斥锁会被释放，以允许其他线程修改共享数据。当条件变量被通知时，线程会被唤醒，并在返回前重新获取互斥锁。</li>
<li>notify_one(): 唤醒一个等待的线程。如果没有线程在等待，则调用没有任何效果。</li>
<li>notify_all(): 唤醒所有等待的线程。如果没有线程在等待，则调用没有任何效果。</li>
<li>wait_for(): 阻塞当前线程一段时间，或直到被通知。如果在指定的时间段内没有接收到通知，线程会自动唤醒。</li>
<li>wait_until(): 阻塞当前线程直到指定的时间点，或直到被通知。如果到达指定的时间点时没有接收到通知，线程会自动唤醒。</li>
</ul>
<p>下面是一个使用 <code>std::condition_variable</code> 的简单示例，演示了生产者-消费者问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;condition_variable&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line">std::condition_variable cv; <span class="comment">// 条件变量</span></div><div class="line">std::<span class="stl_container"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span> product_queue; <span class="comment">// 共享数据队列</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> producer(<span class="keyword">int</span> id) {</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx); <span class="comment">// 加锁</span></div><div class="line">    product_queue.push(id); <span class="comment">// 生产产品</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer "</span> &lt;&lt; id &lt;&lt; <span class="string">" produced a product."</span> &lt;&lt; std::endl;</div><div class="line">    lck.unlock(); <span class="comment">// 解锁</span></div><div class="line">    cv.notify_one(); <span class="comment">// 通知一个消费者</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> consumer() {</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx); <span class="comment">// 加锁</span></div><div class="line">    <span class="keyword">while</span> (product_queue.empty()) { <span class="comment">// 如果队列为空，则等待</span></div><div class="line">        cv.wait(lck); <span class="comment">// 在这里，互斥锁会被释放</span></div><div class="line">    }</div><div class="line">    <span class="keyword">int</span> product = product_queue.front();</div><div class="line">    product_queue.pop();</div><div class="line">    lck.unlock(); <span class="comment">// 解锁</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer consumed product "</span> &lt;&lt; product &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::thread consumers[<span class="number">2</span>];</div><div class="line">    std::thread producers[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建消费者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        consumers[i] = std::thread(consumer);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 创建生产者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        producers[i] = std::thread(producer, i+<span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待生产者线程结束</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        producers[i].join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待消费者线程结束</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        consumers[i].join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程生产产品并将其放入队列中，然后通过调用 cv.notify_one() 唤醒一个等待的消费者线程。消费者线程在队列为空时调用 cv.wait() 进入等待状态，等待生产者的通知。当生产者生产了一个产品后，消费者线程被唤醒，从队列中取出产品并消费它。</p>
<p><strong>注意事项</strong>: (和Go的Cond类似)</p>
<ul>
<li>使用 <code>std::condition_variable</code> 时，应该总是和一个互斥锁一起使用，以避免竞争条件。</li>
<li>在调用 <code>wait()</code>、<code>wait_for()</code> 或 <code>wait_until()</code> 时，互斥锁必须已被锁定。这些函数会在开始等待时自动释放锁，并在线程被唤醒时重新获取锁。</li>
<li><code>std::condition_variable</code> 的 <code>wait()</code> 函数可能会出现&quot;虚假唤醒&quot;，即在没有收到通知的情况下线程可能被唤醒。因此，通常需要在一个循环中使用 <code>wait()</code>，并检查等待条件是否满足。</li>
<li><code>notify_one()</code> 和 <code>notify_all()</code> 不需要持有互斥锁，但通常会在更新共享数据并持有互斥锁后调用它们。</li>
<li><code>std::condition_variable</code> 只能与 <code>std::unique_lock&lt;std::mutex&gt;</code> 一起使用，不能直接与 <code>std::mutex</code> 一起使用。如果你需要和 <code>std::mutex</code> 一起使用条件变量，请使用 <code>std::condition_variable_any</code>。</li>
</ul>
<h2 id="semaphore">semaphore</h2>
<p>在 C++20 之前，标准库没有提供信号量（semaphore）的实现，但是在 C++20 中引入了两种类型的信号量：<code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code>。</p>
<h3 id="std::counting_semaphore">std::counting_semaphore</h3>
<p><code>std::counting_semaphore</code> 是一种通用的同步原语，用于控制对<strong>有限数量资源</strong>的访问。它维护一个内部的计数器，表示可用资源的数量。计数器的值可以增加（通过 <code>release()</code> 函数）或减少（通过 <code>acquire()</code> 函数）。</p>
<p>信号量的主要操作包括：</p>
<ul>
<li>acquire(): 减少信号量的计数器值。如果计数器的当前值大于零，调用 acquire() 将减少计数器的值，并允许线程继续执行。如果计数器值为零，则调用线程将阻塞，直到其他线程释放资源。</li>
<li>release(): 增加信号量的计数器值。调用 release() 会将计数器的值增加一定数量（默认为1），并可能唤醒正在等待的线程。</li>
<li>try_acquire(): 尝试获取资源，如果信号量的计数器值大于零，则减少计数器并返回 true；如果计数器值为零，则不阻塞，直接返回 false。</li>
</ul>
<p><code>std::counting_semaphore</code> 的计数器值可以大于1，因此它可以用于多个资源的同步。例如，可以用它来实现连接池，限制同时运行的线程数量，等等。</p>
<h3 id="std::binary_semaphore">std::binary_semaphore</h3>
<p><code>std::binary_semaphore</code> 是 <code>std::counting_semaphore</code> 的一个特例，其计数器值限定为最多1。这意味着它可以被看作是一个可以阻塞线程的布尔标志。</p>
<p><code>std::binary_semaphore</code> 的行为类似于互斥锁（<code>mutex</code>），但与互斥锁不同的是，<code>std::binary_semaphore</code> 不要求同一个线程执行 <code>acquire()</code> 和 <code>release()</code>。这使得信号量可以用于线程间的通知和同步，而不仅仅是互斥。</p>
<p>下面是一个使用<code>std::counting_semaphore</code>的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;semaphore&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 初始化信号量，允许同时有3个线程访问资源。</span></div><div class="line">std::counting_semaphore&lt;<span class="number">3</span>&gt; sem(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> access_resource(<span class="keyword">int</span> thread_id) {</div><div class="line">    <span class="comment">// 请求访问资源</span></div><div class="line">    sem.acquire();</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">" is accessing the resource."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 模拟资源访问</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">" is releasing the resource."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// 释放资源</span></div><div class="line">    sem.release();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发资源访问</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.emplace_back(access_resource, i);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="std::barrier">std::barrier</h2>
<p><code>std::barrier</code> 也是 C++20 引入的一个同步原语，它允许一组线程相互等待，直到所有线程都达到某个同步点（称为屏障点或栅栏点），然后再继续执行。<code>std::barrier</code> 可以用于协调并行算法中的线程，确保所有线程都完成了某个阶段的工作，然后再一起进入下一个阶段。</p>
<p>std::barrier 的主要特性</p>
<ul>
<li>std::barrier 可以配置一个可调用对象（通常是一个函数或 lambda 表达式），当所有线程都到达屏障点时，这个可调用对象会被执行。这可以用于在所有线程继续之前进行一些初始化或清理工作。</li>
<li>std::barrier 是可重用的，这意味着一旦所有线程通过了屏障点，它可以被用于下一个同步点。</li>
<li>std::barrier 的构造函数接受一个表示线程总数的参数，以及一个可选的可调用对象。</li>
</ul>
<p>std::barrier 的主要成员函数</p>
<ul>
<li>arrive_and_wait(): 该函数使调用线程到达屏障点并等待其他线程。当最后一个线程调用 arrive_and_wait() 时，所有线程都被释放，并且可调用对象（如果有）被执行。</li>
<li>arrive(): 该函数使调用线程到达屏障点但不等待。它可以用于线程通知已到达屏障点，但随后立即继续执行其他任务。</li>
<li>wait(): 该函数使已到达屏障点的线程等待其他线程。它通常与 arrive() 配合使用。</li>
<li>arrive_and_drop(): 该函数使调用线程到达屏障点并永久退出屏障。它将屏障点的期望线程总数减少一个。这对于动态线程管理很有用。</li>
</ul>
<p>以下是一个使用 std::barrier 的简单示例，演示了如何同步多个线程在屏障点上相互等待:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;barrier&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 创建一个屏障，用于同步三个线程</span></div><div class="line">std::barrier sync_point(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> work(<span class="keyword">int</span> id) {</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is doing some work before the barrier."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行前半部分的工作</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 等待屏障点，等待其他线程</span></div><div class="line">    sync_point.arrive_and_wait();</div><div class="line"></div><div class="line">    <span class="comment">// 当所有线程都达到屏障点时，继续执行后半部分的工作</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is doing some work after the barrier."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line"></div><div class="line">    <span class="comment">// 启动三个工作线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</div><div class="line">        threads.emplace_back(work, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::barrier</code> 对象 <code>sync_point</code>，它配置为同步三个线程。每个线程都执行一些工作，然后调用 <code>sync_point.arrive_and_wait()</code> 来等待其他线程。一旦所有三个线程都到达屏障点（即都调用了 <code>arrive_and_wait()</code>），它们将一起继续执行后面的代码。</p>
<p><code>std::barrier</code> 是一种强大的同步工具，特别适用于需要分阶段执行的并行算法，确保在算法的每个阶段开始前，所有线程都已完成前一个阶段的工作。这有助于避免竞争条件，确保算法的正确执行。</p>
<h2 id="std::latch">std::latch</h2>
<p><code>std::latch</code> 也是 C++20 引入的一个同步原语，它使一组线程可以等待直到一个给定数量的操作完成。它是一个一次性的屏障，一旦触发打开，就不能再重置或再次使用。<code>std::latch</code> 用于在多个线程之间同步操作，允许一个线程等待一个或多个线程完成某些操作。类似Java中的CountDownLatch。</p>
<p>std::latch 的主要特性</p>
<ul>
<li>std::latch 在构造时接受一个计数值，这个值表示需要等待的操作数。</li>
<li>当线程完成它的操作时，它调用 count_down() 方法来减少 std::latch 的计数器。</li>
<li>线程可以调用 wait() 方法来阻塞，直到 std::latch 的计数器达到零。</li>
<li>std::latch 可以有多个线程同时等待计数器达到零。</li>
<li>一旦 std::latch 的计数器达到零，所有调用 wait() 的线程都将被释放，之后的任何 wait() 调用都会立即返回。</li>
<li>std::latch 提供了一个 try_wait() 方法，该方法立即返回并告知调用者 std::latch 是否已经触发（计数器是否已经为零）。</li>
</ul>
<p>std::latch 的主要成员函数</p>
<ul>
<li>count_down(): 减少 std::latch 的计数器。如果计数器达到零，所有等待的线程都将被释放。</li>
<li>wait(): 阻塞调用线程，直到 std::latch 的计数器为零。</li>
<li>try_wait(): 检查 std::latch 的计数器是否为零，不阻塞调用线程。</li>
</ul>
<p>以下是一个使用 std::latch 的简单示例，演示了如何同步多个线程完成初始化操作后，主线程才继续执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;latch&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 创建一个 std::latch 对象，用于等待三个线程完成初始化</span></div><div class="line">std::latch initialization_latch(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> initialize_system(<span class="keyword">int</span> id) {</div><div class="line">    <span class="comment">// 模拟一些初始化工作</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is initializing."</span> &lt;&lt; std::endl;</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; id &lt;&lt; <span class="string">" initialization complete."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 完成工作后，调用 count_down() 减少 latch 的计数</span></div><div class="line">    initialization_latch.count_down();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line"></div><div class="line">    <span class="comment">// 启动三个线程以执行系统初始化</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</div><div class="line">        threads.emplace_back(initialize_system, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 主线程等待所有初始化完成</span></div><div class="line">    initialization_latch.wait();</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All systems are initialized. Main thread is proceeding."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::latch</code> 用于确保三个并发运行的初始化操作都完成了，主线程才开始执行后续的任务。每个初始化线程在完成初始化后调用 <code>initialization_latch.count_down()</code>，这将减少 <code>std::latch</code> 的计数器。主线程调用 <code>initialization_latch.wait()</code> 来等待所有的初始化操作完成。一旦所有的初始化操作都调用了 <code>count_down()</code>，<code>std::latch</code> 的计数器达到零，主线程将继续执行。</p>
<p><code>std::latch</code> 是一个非常有用的同步工具，特别是在涉及一次性事件或需要多个线程完成启动步骤之后才能继续的场景中。它简化了在这些情况下的线程协调。</p>
<h2 id="std::promise、std::future_和_std::async">std::promise、std::future 和 std::async</h2>
<p><code>std::promise</code> 和 <code>std::future</code> 是 C++11 引入的同步原语，它们提供了一种在线程之间传递值的机制，也可以用于线程之间的同步。<code>std::async</code> 是 C++11 引入的一个函数模板，用于异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便在将来某个时间点获取该函数的结果。</p>
<h3 id="std::promise">std::promise</h3>
<p><code>std::promise</code> 允许你在某个线程中存储一个值或异常，该值或异常可以在将来某个时刻被另一个线程检索。当创建 <code>std::promise</code> 对象时，它与一个 <code>std::future</code> 对象相关联，<code>std::future</code> 对象可用于访问 <code>std::promise</code> 中存储的值。</p>
<p>主要成员函数包括：</p>
<ul>
<li>set_value(const T&amp; value): 用来设置值，这会导致与之相关联的 std::future 对象变为 ready 状态，之后可以从中获取这个值。</li>
<li>set_exception(std::exception_ptr p): 用来设置异常，这也会导致相关联的 std::future 对象变为 ready 状态，但尝试从中获取值会引发异常。</li>
<li>get_future(): 返回与 std::promise 对象相关联的 std::future 对象。</li>
</ul>
<h3 id="std::future">std::future</h3>
<p><code>std::future</code> 提供了一种访问异步操作结果的机制。它与 <code>std::promise</code> 对象相关联，用于获取通过 <code>promise</code> 设置的值或异常。</p>
<p>主要成员函数包括：</p>
<ul>
<li>get(): 获取存储在 std::promise 中的值，如果值还未被设置，会阻塞调用线程直到值变为可用。如果 promise 中存储了异常，则调用 get() 会抛出该异常。</li>
<li>wait(): 等待异步操作完成，不返回结果。</li>
<li>valid(): 检查 future 对象是否与一个共享状态相关联（即它是否有值可以获取）。</li>
</ul>
<h2 id="std::async">std::async</h2>
<p><code>std::async</code> 是一个函数模板，用于启动一个异步任务，它的返回类型是 <code>std::future</code>，通过该 <code>future</code> 可以访问异步任务的结果。当调用 <code>std::async</code> 时，可以指定一个函数或可调用对象，以及传递给该函数的参数。<code>std::async</code> 可以指定启动策略，例如 <code>std::launch::async</code>（在新线程中运行）或 <code>std::launch::deferred</code>（延迟执行，直到调用 <code>std::future::get()</code> 或 <code>wait()</code>）。</p>
<p>以下是一个使用 <code>std::promise</code> 和 <code>std::future</code> 的简单示例，模拟了一个异步计算任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;future&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="comment">// 创建一个 promise 对象</span></div><div class="line">    std::promise&lt;<span class="keyword">int</span>&gt; prom;</div><div class="line"></div><div class="line">    <span class="comment">// 从 promise 中获取 future</span></div><div class="line">    std::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future();</div><div class="line"></div><div class="line">    <span class="comment">// 启动一个线程来完成一个计算任务并设置 promise 的值</span></div><div class="line">    std::thread t([&prom]() {</div><div class="line">        <span class="comment">// 模拟一些计算</span></div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">2</span>));</div><div class="line">        prom.set_value(<span class="number">42</span>); <span class="comment">// 设置 promise 的值</span></div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 在主线程中，我们可以等待 future 变为 ready 并获取值</span></div><div class="line">    <span class="keyword">int</span> result = fut.get();  <span class="comment">// 这里会阻塞直到线程设置了 promise 的值</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span> &lt;&lt; result &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    t.join();  <span class="comment">// 等待线程完成</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::async</code> 用于启动一个新线程来执行 <code>compute</code> 函数。通过返回的 <code>std::future</code> 对象，主线程可以在稍后获取异步计算的结果。如果在此期间尚未完成计算，调用 <code>fut.get()</code> 将会阻塞主线程。</p>
<p><code>std::promise</code>、<code>std::future</code> 和 <code>std::async</code> 提供了 C++ 中进行异步编程的基础设施，允许开发者在不同线程之间传递数据和同步操作，同时将并发复杂性降到最低。</p>

      
    </div>
    <footer class="article-footer">
      

      
      <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script> -->
      <section id="comments">
        <script src="https://utteranc.es/client.js"
                repo="smallnest/gitalk"
                issue-term="title"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
        <!-- <div id="gitalk-container"></div>
        <script type="text/javascript">
          var gitalkOpts = {
            id: '2023/12/26/synchronization-primitives-in-c/',
            owner: 'smallnest',
            repo: 'gitalk',
            title: 'C++中的同步原语',
            body: 'https://colobu.com/2023/12/26/synchronization-primitives-in-c/',
            clientID: 'bc02724130ed5b7ee275',
            clientSecret: '68cb0bae2f93a8b88b09e0eb9b08c844b06a9047',
            admin: ['smallnest'],
            distractionFreeMode: false
          };

          const gitalk = new Gitalk(gitalkOpts)
          gitalk.render('gitalk-container')
        </script> -->
        <noscript> 为正常使用评论功能请激活JavaScript</noscript>
      </section>

      

    </footer>
  </div>
  
  
<nav id="article-nav">
  
    <a href="/2024/01/06/extend-atomic/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          学习C++20, 为Go的atomic类型插上一双翅膀
        
      </div>
    </a>
  
  
    <a href="/2023/12/25/patterns-in-ServeMux-HandleFunc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Go http.ServeMux中的模式匹配</div>
    </a>
  
</nav>

  
</article></section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title">访问者来源</h3>
  <div class="widget">
    <script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=Hf4EJSi2XvL6TMcuFSH51Qn6nf5nZ8qnjVBnWCQ4FGc"></script>
  </div>
</div>

<div class="widget-wrap">
  <h3 class="widget-title">微信公众号</h3>
  <div class="widget">
    <img width="100%" src="/images/widgets/gopatterns.jpg">
  </div>
</div>

<div class="widget-wrap">
  <h3 class="widget-title">极客时间专栏</h3>
  <div class="widget">
    <a href="https://time.geekbang.org/column/intro/100061801">
      <img width="100%" src="/images/widgets/geekbang.png">
    </a>
  </div>
</div>

<div class="widget-wrap">
    <h3 class="widget-title">出版图书</h3>
    <div class="widget">
      <a href="https://cpgo.colobu.com/">
        <img width="100%" src="/cpgolang/cpgo.png">
      </a>
    </div>
    <div class="widget">
      <a href="https://www.books.com.tw/products/0010991366">
        <img width="100%" src="/cpgolang/cpgo2.jpg">
      </a>
    </div>
    <div class="widget">
      <a href="https://item.jd.com/14347716.html">
        <img width="100%" src="/100gomistakes/cover.png">
      </a>
    </div>
    <div class="widget">
      <a href="/ScalaCollectionsCookbook/">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook.jpg">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook_tw.png">
      </a>
    </div>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DOTNET/">DOTNET</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">290</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">64</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rust/">rust</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">60</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理/">管理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高并发编程/">高并发编程</a><span class="category-list-count">20</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 15.71px;">Android</a><a href="/tags/ApacheBench/" style="font-size: 11.43px;">ApacheBench</a><a href="/tags/Bower/" style="font-size: 10.00px;">Bower</a><a href="/tags/C/" style="font-size: 10.00px;">C#</a><a href="/tags/CDN/" style="font-size: 10.00px;">CDN</a><a href="/tags/CQRS/" style="font-size: 10.00px;">CQRS</a><a href="/tags/CRC/" style="font-size: 10.00px;">CRC</a><a href="/tags/CSS/" style="font-size: 11.43px;">CSS</a><a href="/tags/CompletableFuture/" style="font-size: 10.00px;">CompletableFuture</a><a href="/tags/Comsat/" style="font-size: 10.00px;">Comsat</a><a href="/tags/Curator/" style="font-size: 18.57px;">Curator</a><a href="/tags/DSL/" style="font-size: 10.00px;">DSL</a><a href="/tags/Disruptor/" style="font-size: 10.00px;">Disruptor</a><a href="/tags/Docker/" style="font-size: 11.43px;">Docker</a><a href="/tags/Ember/" style="font-size: 11.43px;">Ember</a><a href="/tags/FastJson/" style="font-size: 10.00px;">FastJson</a><a href="/tags/Fiber/" style="font-size: 10.00px;">Fiber</a><a href="/tags/GAE/" style="font-size: 10.00px;">GAE</a><a href="/tags/GC/" style="font-size: 12.86px;">GC</a><a href="/tags/Gnuplot/" style="font-size: 10.00px;">Gnuplot</a><a href="/tags/Go/" style="font-size: 14.29px;">Go</a><a href="/tags/Gradle/" style="font-size: 10.00px;">Gradle</a><a href="/tags/Grunt/" style="font-size: 10.00px;">Grunt</a><a href="/tags/Gulp/" style="font-size: 10.00px;">Gulp</a><a href="/tags/Hadoop/" style="font-size: 10.00px;">Hadoop</a><a href="/tags/Hazelcast/" style="font-size: 10.00px;">Hazelcast</a><a href="/tags/IPFS/" style="font-size: 10.00px;">IPFS</a><a href="/tags/Ignite/" style="font-size: 10.00px;">Ignite</a><a href="/tags/JVM/" style="font-size: 10.00px;">JVM</a><a href="/tags/Java/" style="font-size: 17.14px;">Java</a><a href="/tags/Kafka/" style="font-size: 20.00px;">Kafka</a><a href="/tags/Lambda/" style="font-size: 14.29px;">Lambda</a><a href="/tags/Linux/" style="font-size: 12.86px;">Linux</a><a href="/tags/LongAdder/" style="font-size: 10.00px;">LongAdder</a><a href="/tags/MathJax/" style="font-size: 10.00px;">MathJax</a><a href="/tags/Maven/" style="font-size: 11.43px;">Maven</a><a href="/tags/Memcached/" style="font-size: 10.00px;">Memcached</a><a href="/tags/Metrics/" style="font-size: 10.00px;">Metrics</a><a href="/tags/Mongo/" style="font-size: 12.86px;">Mongo</a><a href="/tags/Netty/" style="font-size: 15.71px;">Netty</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/13/string-bytes-benchmark/">四种字符串和bytes互相转换方式的性能比较</a>
          </li>
        
          <li>
            <a href="/2024/08/08/access-the-unexported-fields/">没有什么不可能：修改 Go 结构体的私有字段</a>
          </li>
        
          <li>
            <a href="/2024/08/04/beetracer/">使用eBPF编写系统调用跟踪器</a>
          </li>
        
          <li>
            <a href="/2024/08/02/Russ-Cox-and-his-Oscar/">Russ Cox 引退以及他的新项目 Oscar</a>
          </li>
        
          <li>
            <a href="/2024/06/16/atomic128/">128位整数的原子操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
			 
            <a href="http://stackshare.io" target="_blank">技术栈</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="https://toutiao.io/" target="_blank">开发者头条</a>
			
          </li>
        
          <li>
			 
            <a href="http://weekly.manong.io/issues/" target="_blank">码农周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.tuicool.com/mags" target="_blank">编程狂人周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.importnew.com/" target="_blank">importnew</a>
			
          </li>
        
          <li>
			 
            <a href="http://ifeve.com/" target="_blank">并发编程网</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="http://github.com" target="_blank">github</a>
			
          </li>
        
          <li>
			 
            <a href="http://stackoverflow.com/" target="_blank">stackoverflow</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.javacodegeeks.com/" target="_blank">javacodegeeks</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.infoq.com/" target="_blank">infoq</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.dzone.com/links/index.html" target="_blank">dzone</a>
			
          </li>
        
          <li>
			 
            <a href="https://oj.leetcode.com/problems/" target="_blank">leetcode</a>
			
          </li>
        
          <li>
			 
            <a href="http://tutorials.jenkov.com" target="_blank">jenkov</a>
			
          </li>
        
          <li>
			 
            <a href="https://howtodoinjava.com" target="_blank">HowToDoInJava</a>
			
          </li>
        
          <li>
			 
            <a href="https://java-design-patterns.com/patterns/" target="_blank">java design patterns</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="https://medium.com/netflix-techblog" target="_blank">Netflix技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://www.techiedelight.com" target="_blank">Techie Delight</a>
			
          </li>
        
          <li>
			 
            <a href="https://engineering.linkedin.com/blog" target="_blank">Linkedin技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://blogs.dropbox.com/tech/" target="_blank">Dropbox技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://code.fb.com" target="_blank">Facebook技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="http://jm.taobao.org" target="_blank">淘宝中间件团队</a>
			
          </li>
        
          <li>
			 
            <a href="https://tech.meituan.com" target="_blank">美团技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="http://blogs.360.cn" target="_blank">360技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://xiaomi-info.github.io" target="_blank">小米信息部技术团队</a>
			
          </li>
        
      </ul>
    </div>
  </div>

  
      

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 smallnest<br>
	  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    
      <a href="/" class="mobile-nav-link"><i class="fa fa-home">&nbsp;</i>首页</a>
    
  
    
      <a href="/archives" class="mobile-nav-link"><i class="fa fa-regular fa-folder-open">&nbsp;</i>归档</a>
    
  
    
      <a href="https://github.com/smallnest" class="mobile-nav-link"><i class="fa fa-brands fa-github-alt">&nbsp;</i>github</a>
    
  
    
      <a class="mobile-nav-link" href="#"><i class="fa fa-brands fa-golang">&nbsp;</i>Go学习资源</a>
    
      
            <a class="mobile-nav-link" href="/goasm">&nbsp;&nbsp;<i class="fa fa-brands fa-golang">&nbsp;</i>Go汇编示例</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://gowebexamples.com">&nbsp;&nbsp;<i class="fa fa-brands fa-golang">&nbsp;</i>Go Web开发示例</a>
          
          
    
      
            <a class="mobile-nav-link" href="http://go-database-sql.org">&nbsp;&nbsp;<i class="fa fa-brands fa-golang">&nbsp;</i>Go 数据库开发教程</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://colobu.com/gotips/">&nbsp;&nbsp;<i class="fa fa-brands fa-golang">&nbsp;</i>Go 语言编程技巧</a>
          
          
    
      
            
          
          
    
      
            <a class="mobile-nav-link" href="http://rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPCX官网</a>
          
          
    
      
            <a class="mobile-nav-link" href="http://cn.doc.rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPC开发指南</a>
          
          
    
    
  
    
      <a class="mobile-nav-link" href="#"><i class="fa fa-brands fa-rust">&nbsp;</i>Rust学习资源</a>
    
      
            <a class="mobile-nav-link" href="/perf-book">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust高性能编程指南</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust100">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>100个练习题学习Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="/atomics">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust原子操作和锁</a>
          
          
    
      
            <a class="mobile-nav-link" href="/effective-rust">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>高效Rust编程</a>
          
          
    
      
            <a class="mobile-nav-link" href="/thebook">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust程序设计语言</a>
          
          
    
      
            <a class="mobile-nav-link" href="/nomicon">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust死灵书</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust-reference">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust参考手册</a>
          
          
    
      
            <a class="mobile-nav-link" href="/tlborm">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust宏小册</a>
          
          
    
      
            <a class="mobile-nav-link" href="/async-book">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust异步编程书</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust-by-example">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>通过例子学Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="/api-guidelines">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust API 编写指南</a>
          
          
    
      
            <a class="mobile-nav-link" href="/comprehensive-rust">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>全面Rust课程</a>
          
          
    
      
            <a class="mobile-nav-link" href="/easy-rust">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>简单英语学Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust-patterns">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust设计模式</a>
          
          
    
      
            <a class="mobile-nav-link" href="/2020/03/05/A-half-hour-to-learn-Rust/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>半小时学会Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust-cookbook">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust实用指南(cookbook)</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust-rand">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust随机库</a>
          
          
    
      
            
          
          
    
      
            <a class="mobile-nav-link" href="https://rpcx.io/r/E6v8U">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>Rust for the Polyglot Programmer</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rpcx.io/r/oC5ii">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>LifetimeKata</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://tfpk.github.io/macrokata/">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>macrokata</a>
          
          
    
    
  
    
      <a href="/ScalaCollectionsCookbook" class="mobile-nav-link"><i class="fa fa-solid fa-book">&nbsp;</i>Scala集合技术手册</a>
    
  
    
      <a href="/about" class="mobile-nav-link"><i class="fa fa-regular fa-address-card">&nbsp;</i>关于</a>
    
  
</nav>
    
<script src="//cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script>
<script src="//cdn.bootcss.com/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>


<script src="/js/script.js" type="text/javascript"></script>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.6.0-beta.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div id="totop" style="position:fixed;bottom:150px;right:10px;cursor: pointer;z-index: 2000;">
	<a title="返回顶部"><img src="/images/scrollup.png"/></a>
</div>
<script src="/js/totop.js" type="text/javascript"></script>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e085d87993250aab11f3e0c15f1c2785";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </div>
</body>
</html>