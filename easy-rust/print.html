<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ç®€å•è‹±è¯­å­¦Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong>  æ›´æ–°</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong>  ä»‹ç»</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong>  æˆ‘æ˜¯è°ï¼Ÿ</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong>  ç®€å•è‹±è¯­å­¦Rust</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong>  Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong>  ğŸš§å’Œâš ï¸</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong>  æ³¨é‡Š</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong>  ç±»å‹</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong>  ç±»å‹æ¨å¯¼</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong>  æ‰“å°hello, world!</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong>  æ˜¾ç¤ºå’Œè°ƒè¯•</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong>  å¯å˜æ€§</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong>  æ ˆã€å †å’ŒæŒ‡é’ˆ</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong>  å…³äºæ‰“å°çš„æ›´å¤šä¿¡æ¯</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong>  å­—ç¬¦ä¸²</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong>  constå’Œstatic</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong>  å…³äºå¼•ç”¨çš„æ›´å¤šä¿¡æ¯</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong>  å¯å˜å¼•ç”¨</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong>  å‡½æ•°çš„å¼•ç”¨</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong>  æ‹·è´ç±»å‹</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong>  é›†åˆç±»å‹</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong>  å‘é‡</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong>  å…ƒç»„</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong>  æ§åˆ¶æµ</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong>  ç»“æ„ä½“</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong>  æšä¸¾</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong>  å¾ªç¯</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong>  å®ç°ç»“æ„ä½“å’Œæšä¸¾</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong>  è§£æ„</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong>  å¼•ç”¨å’Œç‚¹è¿ç®—ç¬¦</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong>  æ³›å‹</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong>  Optionå’ŒResult</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong>  å…¶ä»–é›†åˆç±»å‹</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong>  ?æ“ä½œç¬¦</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong>  ç‰¹æ€§</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong>  é“¾å¼æ–¹æ³•</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong>  è¿­ä»£å™¨</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong>  é—­åŒ…</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong>  dbg! å®å’Œ.inspect</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong>  &strçš„ç±»å‹</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong>  ç”Ÿå‘½æœŸ</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong>  å†…éƒ¨å¯å˜æ€§</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong>  Cow</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong>  ç±»å‹åˆ«å</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong>  todo!å®</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong>  Rc</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong>  å¤šçº¿ç¨‹</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong>  å‡½æ•°ä¸­çš„é—­åŒ…</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong>  impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong>  Arc</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong>  Channels</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong>  é˜…è¯»Rustæ–‡æ¡£</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong>  å±æ€§</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong>  Box</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong>  ç”¨BoxåŒ…è£¹trait</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong>  é»˜è®¤å€¼å’Œå»ºé€ è€…æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong>  Derefå’ŒDerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong>  Crateå’Œæ¨¡å—</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong>  æµ‹è¯•</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong>  å¤–éƒ¨crate</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong>  æ ‡å‡†åº“ä¹‹æ—…</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong>  ç¼–å†™å®</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong>  cargo</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong>  æ¥å—ç”¨æˆ·è¾“å…¥</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong>  ä½¿ç”¨æ–‡ä»¶</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong>  cargoæ–‡æ¡£</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong>  ç»“æŸäº†å—ï¼Ÿ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ç®€å•è‹±è¯­å­¦Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="æ›´æ–°"><a class="header" href="#æ›´æ–°">æ›´æ–°</a></h2>
<p><img src="https://github.com/kumakichi/easy_rust_chs/workflows/github%20pages/badge.svg" alt="example workflow name" /></p>
<p>2021å¹´2æœˆ1æ—¥: <a href="https://www.youtube.com/playlist?list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk">Youtubeè§†é¢‘</a></p>
<p>2021å¹´1æœˆ4æ—¥: æ”¯æŒåœ¨çº¿æŸ¥çœ‹ <a href="https://kumakichi.github.io/easy_rust_chs">ç‚¹å‡»é˜…è¯»</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ä»‹ç»"><a class="header" href="#ä»‹ç»">ä»‹ç»</a></h2>
<p>Rustæ˜¯ä¸€ç§æ–°çš„è¯­è¨€ï¼Œå·²ç»æœ‰äº†å¾ˆå¥½çš„æ•™ç§‘ä¹¦ã€‚ä½†æ˜¯æœ‰æ—¶å€™å®ƒçš„æ•™æå¾ˆéš¾ï¼Œå› ä¸ºå®ƒçš„æ•™ææ˜¯ç»™ä»¥è‹±è¯­ä¸ºæ¯è¯­çš„äººçœ‹çš„ã€‚ç°åœ¨å¾ˆå¤šå…¬å¸å’Œäººå­¦ä¹ Rustï¼Œå¦‚æœæœ‰ä¸€æœ¬è‹±è¯­ç®€å•çš„ä¹¦ï¼Œä»–ä»¬å¯ä»¥å­¦å¾—æ›´å¿«ã€‚è¿™æœ¬æ•™æå°±æ˜¯ç»™è¿™äº›å…¬å¸å’Œäººç”¨ç®€å•çš„è‹±è¯­æ¥å­¦ä¹ Rustçš„ã€‚</p>
<p>Rustæ˜¯ä¸€é—¨å¾ˆæ–°çš„è¯­è¨€ï¼Œä½†å·²ç»éå¸¸æµè¡Œã€‚å®ƒä¹‹æ‰€ä»¥å—æ¬¢è¿ï¼Œæ˜¯å› ä¸ºå®ƒç»™ä½ æä¾›äº†Cæˆ–C++çš„é€Ÿåº¦å’Œæ§åˆ¶åŠ›ï¼Œä½†ä¹Ÿç»™ä½ æä¾›äº†Pythonç­‰å…¶ä»–è¾ƒæ–°è¯­è¨€çš„å†…å­˜å®‰å…¨ã€‚å®ƒç”¨ä¸€äº›æ–°çš„æƒ³æ³•æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œè¿™äº›æƒ³æ³•æœ‰æ—¶ä¸å…¶ä»–è¯­è¨€ä¸åŒã€‚è¿™æ„å‘³ç€æœ‰ä¸€äº›æ–°çš„ä¸œè¥¿éœ€è¦å­¦ä¹ ï¼Œä½ ä¸èƒ½åªæ˜¯ "è¾¹èµ°è¾¹æƒ³"ã€‚Rustæ˜¯ä¸€é—¨è¯­è¨€ï¼Œä½ å¿…é¡»æ€è€ƒä¸€æ®µæ—¶é—´æ‰èƒ½ç†è§£ã€‚ä½†å¦‚æœä½ æ‡‚å…¶ä»–è¯­è¨€çš„è¯ï¼Œå®ƒçœ‹èµ·æ¥è¿˜æ˜¯å¾ˆç†Ÿæ‚‰çš„ï¼Œå®ƒæ˜¯ä¸ºäº†å¸®åŠ©ä½ å†™å¥½ä»£ç è€Œç”Ÿçš„ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æˆ‘æ˜¯è°"><a class="header" href="#æˆ‘æ˜¯è°">æˆ‘æ˜¯è°ï¼Ÿ</a></h2>
<p>æˆ‘æ˜¯ä¸€ä¸ªç”Ÿæ´»åœ¨éŸ©å›½çš„åŠ æ‹¿å¤§äººï¼Œæˆ‘åœ¨å†™Easy Rustçš„åŒæ—¶ï¼Œä¹Ÿåœ¨æ€è€ƒå¦‚ä½•è®©è¿™é‡Œçš„å…¬å¸å¼€å§‹ä½¿ç”¨å®ƒã€‚æˆ‘å¸Œæœ›å…¶ä»–ä¸ä»¥è‹±è¯­ä¸ºç¬¬ä¸€è¯­è¨€çš„å›½å®¶ä¹Ÿèƒ½ä½¿ç”¨å®ƒã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç®€å•è‹±è¯­å­¦rust"><a class="header" href="#ç®€å•è‹±è¯­å­¦rust">ç®€å•è‹±è¯­å­¦Rust</a></h2>
<p><em>ç®€å•è‹±è¯­å­¦Rust</em>å†™äº2020å¹´7æœˆè‡³8æœˆï¼Œé•¿è¾¾400å¤šé¡µã€‚å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜ï¼Œå¯ä»¥åœ¨è¿™é‡Œæˆ–<a href="https://www.linkedin.com/in/davemacleod">åœ¨LinkedInä¸Š</a>æˆ–<a href="https://twitter.com/mithridates">åœ¨Twitterä¸Š</a>è”ç³»æˆ‘ã€‚å¦‚æœä½ å‘ç°æœ‰ä»€ä¹ˆä¸å¯¹çš„åœ°æ–¹ï¼Œæˆ–è€…è¦æå‡ºpull requestï¼Œè¯·ç»§ç»­ã€‚å·²ç»æœ‰è¶…è¿‡20äººå¸®åŠ©æˆ‘ä»¬ä¿®å¤äº†ä»£ç ä¸­çš„é”™åˆ«å­—å’Œé—®é¢˜ï¼Œæ‰€ä»¥ä½ ä¹Ÿå¯ä»¥ã€‚æˆ‘ä¸æ˜¯ä¸–ç•Œä¸Šæœ€å¥½çš„Rustä¸“å®¶ï¼Œæ‰€ä»¥æˆ‘æ€»æ˜¯å–œæ¬¢å¬åˆ°æ–°çš„æƒ³æ³•ï¼Œæˆ–è€…çœ‹çœ‹å“ªé‡Œå¯ä»¥è®©è¿™æœ¬ä¹¦å˜å¾—æ›´å¥½ã€‚</p>
<ul>
<li><a href="Chapter_3.html#%E7%AC%AC1%E9%83%A8%E5%88%86---%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84Rust">ç¬¬1éƒ¨åˆ† - æµè§ˆå™¨ä¸­çš„Rust</a>
<ul>
<li><a href="Chapter_3.html#rust-playground">Rust Playground</a></li>
<li><a href="Chapter_3.html#%E5%92%8C%EF%B8%8F">ğŸš§ and âš ï¸</a></li>
<li><a href="Chapter_3.html#%E6%B3%A8%E9%87%8A">æ³¨é‡Š</a></li>
<li><a href="Chapter_3.html#%E7%B1%BB%E5%9E%8B">ç±»å‹</a>
<ul>
<li><a href="Chapter_3.html#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B">åŸå§‹ç±»å‹</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">ç±»å‹æ¨å¯¼</a>
<ul>
<li><a href="Chapter_3.html#%E6%B5%AE%E7%82%B9%E6%95%B0">æµ®ç‚¹æ•°</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E6%89%93%E5%8D%B0hello-world">æ‰“å°hello, world!</a>
<ul>
<li><a href="Chapter_3.html#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97">å£°æ˜å˜é‡å’Œä»£ç å—</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E6%98%BE%E7%A4%BA%E5%92%8C%E8%B0%83%E8%AF%95">æ˜¾ç¤ºå’Œè°ƒè¯•</a>
<ul>
<li><a href="Chapter_3.html#%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0">æœ€å°å’Œæœ€å¤§çš„æ•°</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%8F%AF%E5%8F%98%E6%80%A7">å¯å˜æ€§</a>
<ul>
<li><a href="Chapter_3.html#%E9%81%AE%E8%94%BD">é®è”½</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E6%A0%88%E5%A0%86%E5%92%8C%E6%8C%87%E9%92%88">æ ˆï¼Œå †å’ŒæŒ‡é’ˆ</a></li>
<li><a href="Chapter_3.html#%E5%85%B3%E4%BA%8E%E6%89%93%E5%8D%B0%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">å…³äºæ‰“å°çš„æ›´å¤šä¿¡æ¯</a></li>
<li><a href="Chapter_3.html#%E5%AD%97%E7%AC%A6%E4%B8%B2">å­—ç¬¦ä¸²</a></li>
<li><a href="Chapter_3.html#const%E5%92%8Cstatic">constå’Œstatic</a></li>
<li><a href="Chapter_3.html#%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">å…³äºå¼•ç”¨çš„æ›´å¤šä¿¡æ¯</a></li>
<li><a href="Chapter_3.html#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">å¯å˜å¼•ç”¨</a>
<ul>
<li><a href="Chapter_3.html#%E5%86%8D%E8%B0%88shadowing">å†è°ˆshadowing</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%95%E7%94%A8">å‡½æ•°çš„å¼•ç”¨</a></li>
<li><a href="Chapter_3.html#%E6%8B%B7%E8%B4%9D%E7%B1%BB%E5%9E%8B">æ‹·è´ç±»å‹</a>
<ul>
<li><a href="Chapter_3.html#%E6%97%A0%E5%80%BC%E5%8F%98%E9%87%8F">æ— å€¼å˜é‡</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">é›†åˆç±»å‹</a>
<ul>
<li><a href="Chapter_3.html#%E6%95%B0%E7%BB%84">æ•°ç»„</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%90%91%E9%87%8F">å‘é‡</a></li>
<li><a href="Chapter_3.html#%E5%85%83%E7%BB%84">å…ƒç»„</a></li>
<li><a href="Chapter_3.html#%E6%8E%A7%E5%88%B6%E6%B5%81">æ§åˆ¶æµ</a></li>
<li><a href="Chapter_3.html#%E7%BB%93%E6%9E%84%E4%BD%93">ç»“æ„ä½“</a></li>
<li><a href="Chapter_3.html#%E6%9E%9A%E4%B8%BE">æšä¸¾</a>
<ul>
<li><a href="Chapter_3.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%9A%E4%B8%BE">ä½¿ç”¨å¤šç§ç±»å‹çš„æšä¸¾</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%BE%AA%E7%8E%AF">å¾ªç¯</a></li>
<li><a href="Chapter_3.html#%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E5%92%8C%E6%9E%9A%E4%B8%BE">å®ç°ç»“æ„å’Œæšä¸¾</a></li>
<li><a href="Chapter_3.html#%E8%A7%A3%E6%9E%84">è§£æ„</a></li>
<li><a href="Chapter_3.html#%E5%BC%95%E7%94%A8%E5%92%8C%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6">å¼•ç”¨å’Œç‚¹è¿ç®—ç¬¦</a></li>
<li><a href="Chapter_3.html#%E6%B3%9B%E5%9E%8B">æ³›å‹</a></li>
<li><a href="Chapter_3.html#%E9%80%89%E9%A1%B9%E5%92%8C%E7%BB%93%E6%9E%9C">é€‰é¡¹å’Œç»“æœ</a>
<ul>
<li><a href="Chapter_3.html#%E9%80%89%E9%A1%B9">é€‰é¡¹</a></li>
<li><a href="Chapter_3.html#%E7%BB%93%E6%9E%9C">ç»“æœ</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%85%B6%E4%BB%96%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">å…¶ä»–é›†åˆç±»å‹</a>
<ul>
<li><a href="Chapter_3.html#HashMap%E5%92%8CBTreeMap">HashMapå’ŒBTreeMap</a></li>
<li><a href="Chapter_3.html#hashset%E5%92%8Cbtreeset">HashSetå’ŒBTreeSet</a></li>
<li><a href="Chapter_3.html#%E4%BA%8C%E5%8F%89%E5%A0%86">äºŒå‰å †</a></li>
<li><a href="Chapter_3.html#vecdeque">VecDeque</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E6%93%8D%E4%BD%9C%E7%AC%A6">?æ“ä½œç¬¦</a>
<ul>
<li><a href="Chapter_3.html#when-panic-and-unwrap-are-good">When panic and unwrap are good</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#trait">trait</a>
<ul>
<li><a href="Chapter_3.html#from-trait">From trait</a></li>
<li><a href="Chapter_3.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C&amp;str">åœ¨å‡½æ•°ä¸­ä½¿ç”¨å­—ç¬¦ä¸²å’Œ&amp;str</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E9%93%BE%E5%BC%8F%E6%96%B9%E6%B3%95">é“¾å¼æ–¹æ³•</a></li>
<li><a href="Chapter_3.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">è¿­ä»£å™¨</a>
<ul>
<li><a href="Chapter_3.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">è¿­ä»£å™¨å¦‚ä½•å·¥ä½œ</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E9%97%AD%E5%8C%85">é—­åŒ…</a>
<ul>
<li><a href="Chapter_3.html#%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84_">é—­åŒ…ä¸­çš„_</a></li>
<li><a href="Chapter_3.html#%E9%97%AD%E5%8C%85%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%9C%89%E7%94%A8%E6%96%B9%E6%B3%95">é—­åŒ…å’Œè¿­ä»£å™¨çš„æœ‰ç”¨æ–¹æ³•</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#dbg%E5%AE%8F%E5%92%8Cinspect">dbg! å®å’Œ.æ£€æŸ¥å™¨</a></li>
<li><a href="Chapter_3.html#str%E7%9A%84%E7%B1%BB%E5%9E%8B">&amp;strçš„ç±»å‹</a></li>
<li><a href="Chapter_3.html#%E7%94%9F%E5%91%BD%E6%9C%9F">ç”Ÿå‘½æœŸ</a></li>
<li><a href="Chapter_3.html#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">å†…éƒ¨å¯å˜æ€§</a>
<ul>
<li><a href="Chapter_3.html#cell">Cell</a></li>
<li><a href="Chapter_3.html#refcell">RefCell</a></li>
<li><a href="Chapter_3.html#mutex">Mutex</a></li>
<li><a href="Chapter_3.html#rwlock">RwLock</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#cow">Cow</a></li>
<li><a href="Chapter_3.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">ç±»å‹åˆ«å</a>
<ul>
<li><a href="Chapter_3.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%92%8C%E9%87%8D%E5%91%BD%E5%90%8D">åœ¨å‡½æ•°ä¸­å¯¼å…¥å’Œé‡å‘½å</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#todo%E5%AE%8F">todo!å®</a></li>
<li><a href="Chapter_3.html#rc">Rc</a></li>
<li><a href="Chapter_3.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B">å¤šçº¿ç¨‹</a></li>
<li><a href="Chapter_3.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85">å‡½æ•°ä¸­çš„é—­åŒ…</a></li>
<li><a href="Chapter_3.html#impl-trait">impl Trait</a></li>
<li><a href="Chapter_3.html#arc">Arc</a></li>
<li><a href="Chapter_3.html#channels">Channels</a></li>
<li><a href="Chapter_3.html#%E9%98%85%E8%AF%BBRust%E6%96%87%E6%A1%A3">é˜…è¯»Rustæ–‡æ¡£</a>
<ul>
<li><a href="Chapter_3.html#assert_eq">assert_eq! </a></li>
<li><a href="Chapter_3.html#%E6%90%9C%E7%B4%A2">æœç´¢</a></li>
<li><a href="Chapter_3.html#src-%E6%8C%89%E9%92%AE">[src]æŒ‰é’®</a></li>
<li><a href="Chapter_3.html#trait%E4%BF%A1%E6%81%AF">traitä¿¡æ¯</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%B1%9E%E6%80%A7">å±æ€§</a></li>
<li><a href="Chapter_3.html#box">Box</a></li>
<li><a href="Chapter_3.html#box-around-traits">Box around traits</a></li>
<li><a href="Chapter_3.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">é»˜è®¤å€¼å’Œå»ºé€ è€…æ¨¡å¼</a></li>
<li><a href="Chapter_3.html#Deref%E5%92%8CDerefMut">Derefå’ŒDerefMut</a></li>
<li><a href="Chapter_3.html#Crate%E5%92%8C%E6%A8%A1%E5%9D%97">Crateå’Œæ¨¡å—</a></li>
<li><a href="Chapter_3.html#%E6%B5%8B%E8%AF%95">æµ‹è¯•</a>
<ul>
<li><a href="Chapter_3.html#%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BC%80%E5%8F%91">æµ‹è¯•é©±åŠ¨çš„å¼€å‘</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E5%A4%96%E9%83%A8crate">å¤–éƒ¨crate</a>
<ul>
<li><a href="Chapter_3.html#rand">rand</a></li>
<li><a href="Chapter_3.html#rayon">rayon</a></li>
<li><a href="Chapter_3.html#serde">serde</a></li>
<li><a href="Chapter_3.html#regex">regex</a></li>
<li><a href="Chapter_3.html#chrono">chrono</a></li>
</ul>
</li>
<li><a href="Chapter_3.html#%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B%E6%97%85">æ ‡å‡†åº“ä¹‹æ—…</a>
<ul>
<li><a href="Chapter_3.html#%E6%95%B0%E7%BB%84-1">æ•°ç»„</a></li>
<li><a href="Chapter_3.html#char">char</a></li>
<li><a href="Chapter_3.html#integers">Integer</a></li>
<li><a href="Chapter_3.html#floats">Floats</a></li>
<li><a href="Chapter_3.html#bool">Bool</a></li>
<li><a href="Chapter_3.html#vec">Vec</a></li>
<li><a href="Chapter_3.html#string">String</a></li>
<li><a href="Chapter_3.html#OsString%E5%92%8CCString">OsStringå’ŒCString</a></li>
<li><a href="Chapter_3.html#mem">Mem</a></li>
<li><a href="Chapter_3.html#prelude">Prelude</a></li>
<li><a href="Chapter_3.html#time">Time</a></li>
<li><a href="Chapter_3.html#%E5%85%B6%E4%BB%96%E5%AE%8F">å…¶ä»–å®</a></li>
<li><a href="Chapter_3.html#%E7%BC%96%E5%86%99%E5%AE%8F">ç¼–å†™å®</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Chapter_3.html#%E7%AC%AC2%E9%83%A8%E5%88%86---%E7%94%B5%E8%84%91%E4%B8%8A%E7%9A%84Rust">ç¬¬2éƒ¨åˆ† - ç”µè„‘ä¸Šçš„Rust</a>
<ul>
<li><a href="Chapter_3.html#cargo">cargo</a></li>
<li><a href="Chapter_3.html#%E6%8E%A5%E5%8F%97%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">æ¥å—ç”¨æˆ·è¾“å…¥</a></li>
<li><a href="Chapter_3.html#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6">ä½¿ç”¨æ–‡ä»¶</a></li>
<li><a href="Chapter_3.html#cargo%E6%96%87%E6%A1%A3">cargoæ–‡æ¡£</a></li>
<li><a href="Chapter_3.html#%E7%BB%93%E6%9D%9F%E4%BA%86%E5%90%97%EF%BC%9F">ç»“æŸäº†å—ï¼Ÿ</a></li>
</ul>
</li>
</ul>
<h1 id="ç¬¬1éƒ¨åˆ†---æµè§ˆå™¨ä¸­çš„rust"><a class="header" href="#ç¬¬1éƒ¨åˆ†---æµè§ˆå™¨ä¸­çš„rust">ç¬¬1éƒ¨åˆ† - æµè§ˆå™¨ä¸­çš„Rust</a></h1>
<p>æœ¬ä¹¦æœ‰ä¸¤ä¸ªéƒ¨åˆ†ã€‚ç¬¬1éƒ¨åˆ†ï¼Œä½ å°†åœ¨æµè§ˆå™¨ä¸­å°±èƒ½å­¦åˆ°å°½å¯èƒ½å¤šçš„RustçŸ¥è¯†ã€‚å®é™…ä¸Šä½ å‡ ä¹å¯ä»¥åœ¨ä¸å®‰è£…Rustçš„æƒ…å†µä¸‹å­¦åˆ°æ‰€æœ‰ä½ éœ€è¦çŸ¥é“çš„ä¸œè¥¿ï¼Œæ‰€ä»¥ç¬¬1éƒ¨åˆ†éå¸¸é•¿ã€‚æœ€åæ˜¯ç¬¬äºŒéƒ¨åˆ†ã€‚å®ƒè¦çŸ­å¾—å¤šï¼Œæ˜¯å…³äºç”µè„‘ä¸Šçš„Rustã€‚åœ¨è¿™é‡Œï¼Œä½ å°†å­¦ä¹ åˆ°å…¶ä»–ä¸€åˆ‡ä½ éœ€è¦çŸ¥é“çš„ã€åªèƒ½åœ¨æµè§ˆå™¨ä¹‹å¤–è¿›è¡Œçš„äº‹æƒ…ã€‚ä¾‹å¦‚:å¤„ç†æ–‡ä»¶ã€æ¥å—ç”¨æˆ·è¾“å…¥ã€å›¾å½¢å’Œä¸ªäººè®¾ç½®ã€‚å¸Œæœ›åœ¨ç¬¬ä¸€éƒ¨åˆ†ç»“æŸæ—¶ï¼Œä½ ä¼šå–œæ¬¢Rustï¼Œä»¥è‡³äºä½ ä¼šå®‰è£…å®ƒã€‚å¦‚æœä½ ä¸å–œæ¬¢ï¼Œä¹Ÿæ²¡é—®é¢˜--ç¬¬ä¸€éƒ¨åˆ†æ•™äº†ä½ å¾ˆå¤šï¼Œä½ ä¸ä¼šä»‹æ„çš„ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>ä¹Ÿè®¸ä½ è¿˜ä¸æƒ³å®‰è£…Rustï¼Œè¿™ä¹Ÿæ²¡å…³ç³»ã€‚ä½ å¯ä»¥å»<a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>ï¼Œåœ¨ä¸ç¦»å¼€æµè§ˆå™¨çš„æƒ…å†µä¸‹å¼€å§‹å†™Rustã€‚ä½ å¯ä»¥åœ¨é‚£é‡Œå†™ä¸‹ä½ çš„ä»£ç ï¼Œç„¶åç‚¹å‡»Runæ¥æŸ¥çœ‹ç»“æœã€‚ä½ å¯ä»¥åœ¨æµè§ˆå™¨çš„Playgroundé‡Œé¢è¿è¡Œæœ¬ä¹¦ä¸­çš„å¤§éƒ¨åˆ†ç¤ºä¾‹ã€‚åªæœ‰åœ¨æ¥è¿‘ç»“å°¾çš„æ—¶å€™ï¼Œä½ æ‰ä¼šçœ‹åˆ°æ— æ³•åœ¨Playgroundè¿è¡Œçš„ç¤ºä¾‹(æ¯”å¦‚æ‰“å¼€æ–‡ä»¶)ã€‚</p>
<p>ä»¥ä¸‹æ˜¯ä½¿ç”¨Rust Playgroundæ—¶çš„ä¸€äº›æç¤ºã€‚</p>
<ul>
<li>
<p>ç”¨"Run"æ¥è¿è¡Œä½ çš„ä»£ç </p>
</li>
<li>
<p>å¦‚æœä½ æƒ³è®©ä½ çš„ä»£ç æ›´å¿«ï¼Œå°±æŠŠDebugæ”¹ä¸ºReleaseã€‚Debug:ç¼–è¯‘é€Ÿåº¦æ›´å¿«ï¼Œè¿è¡Œé€Ÿåº¦æ›´æ…¢ï¼ŒåŒ…å«è°ƒè¯•ä¿¡æ¯ã€‚Release:ç¼–è¯‘é€Ÿåº¦æ›´æ…¢ï¼Œè¿è¡Œé€Ÿåº¦æ›´å¿«ï¼Œåˆ é™¤è°ƒè¯•ä¿¡æ¯ã€‚</p>
</li>
<li>
<p>ç‚¹å‡»Shareï¼Œå¾—åˆ°ä¸€ä¸ªç½‘å€é“¾æ¥ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥åˆ†äº«ä½ çš„ä»£ç ã€‚å¦‚æœä½ éœ€è¦å¸®åŠ©ï¼Œå¯ä»¥ç”¨å®ƒæ¥åˆ†äº«ä½ çš„ä»£ç ã€‚ç‚¹å‡»åˆ†äº«åï¼Œä½ å¯ä»¥ç‚¹å‡»<code>Open a new thread in the Rust user forum</code>ï¼Œé©¬ä¸Šå‘é‚£é‡Œçš„äººå¯»æ±‚å¸®åŠ©ã€‚</p>
</li>
<li>
<p>Rustfmtå·¥å…·: Rustfmtä¼šå¾ˆå¥½åœ°æ ¼å¼åŒ–ä½ çš„ä»£ç ã€‚</p>
</li>
<li>
<p>TOOLS: Rustfmtä¼šå¾ˆå¥½åœ°æ ¼å¼åŒ–ä½ çš„ä»£ç ã€‚Clippyä¼šç»™ä½ é¢å¤–çš„ä¿¡æ¯ï¼Œå‘Šè¯‰ä½ å¦‚ä½•è®©ä½ çš„ä»£ç æ›´å¥½ã€‚</p>
</li>
<li>
<p>CONFIG: åœ¨è¿™é‡Œä½ å¯ä»¥æŠŠä½ çš„ä¸»é¢˜æ”¹æˆé»‘æš—æ¨¡å¼ï¼Œè¿™æ ·ä½ å°±å¯ä»¥åœ¨æ™šä¸Šå·¥ä½œäº†ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–é…ç½®ã€‚</p>
</li>
</ul>
<p>å¦‚æœä½ æƒ³å®‰è£…Rustï¼Œè¯·åˆ°è¿™é‡Œ<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>ï¼Œç„¶åæŒ‰ç…§è¯´æ˜æ“ä½œã€‚é€šå¸¸ä½ ä¼šä½¿ç”¨<code>rustup</code>æ¥å®‰è£…å’Œæ›´æ–°Rustã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å’Œ"><a class="header" href="#å’Œ">ğŸš§å’Œâš ï¸</a></h2>
<p>æœ‰æ—¶ä¹¦ä¸­çš„ä»£ç ä¾‹å­ä¸èƒ½ç”¨ã€‚å¦‚æœä¸€ä¸ªä¾‹å­ä¸å·¥ä½œï¼Œå®ƒå°†ä¼šæœ‰ä¸€ä¸ªğŸš§æˆ–âš ï¸åœ¨é‡Œé¢ã€‚ğŸš§å°±åƒ "æ­£åœ¨å»ºè®¾ä¸­"ä¸€æ ·:å®ƒæ„å‘³ç€ä»£ç ä¸å®Œæ•´ã€‚Rustéœ€è¦ä¸€ä¸ª<code>fn main()</code>(ä¸€ä¸ªä¸»å‡½æ•°)æ¥è¿è¡Œï¼Œä½†æœ‰æ—¶æˆ‘ä»¬åªæ˜¯æƒ³çœ‹ä¸€äº›å°çš„ä»£ç ï¼Œæ‰€ä»¥å®ƒä¸ä¼šæœ‰<code>fn main()</code>ã€‚è¿™äº›ä¾‹å­æ˜¯æ­£ç¡®çš„ï¼Œä½†éœ€è¦ä¸€ä¸ª<code>fn main()</code>è®©ä½ è¿è¡Œã€‚è€Œæœ‰äº›ä»£ç ç¤ºä¾‹å‘ä½ å±•ç¤ºäº†ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†è§£å†³è¿™ä¸ªé—®é¢˜ã€‚é‚£äº›å¯èƒ½æœ‰ä¸€ä¸ª<code>fn main()</code>ï¼Œä½†ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯ï¼Œæ‰€ä»¥å®ƒä»¬ä¼šæœ‰ä¸€ä¸ªâš ï¸ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ³¨é‡Š"><a class="header" href="#æ³¨é‡Š">æ³¨é‡Š</a></h2>
<p>æ³¨é‡Šæ˜¯ç»™ç¨‹åºå‘˜çœ‹çš„ï¼Œè€Œä¸æ˜¯ç»™ç”µè„‘çœ‹çš„ã€‚å†™æ³¨é‡Šæ˜¯ä¸ºäº†å¸®åŠ©åˆ«äººç†è§£ä½ çš„ä»£ç ã€‚ è¿™ä¹Ÿæœ‰åˆ©äºå¸®åŠ©ä½ ä»¥åç†è§£ä½ çš„ä»£ç ã€‚ (å¾ˆå¤šäººå†™äº†å¾ˆå¥½çš„ä»£ç ï¼Œä½†åæ¥å´å¿˜è®°äº†ä»–ä»¬ä¸ºä»€ä¹ˆè¦å†™å®ƒã€‚)åœ¨Rustä¸­å†™æ³¨é‡Šï¼Œä½ é€šå¸¸ä½¿ç”¨ <code>//</code>ï¼</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Rust programs start with fn main()
    // You put the code inside a block. It starts with { and ends with }
    let some_number = 100; // We can write as much as we want here and the compiler won't look at it
}</code></pre></pre>
<p>å½“ä½ è¿™æ ·åšæ—¶ï¼Œç¼–è¯‘å™¨ä¸ä¼šçœ‹<code>//</code>å³è¾¹çš„ä»»ä½•ä¸œè¥¿ã€‚</p>
<p>è¿˜æœ‰ä¸€ç§æ³¨é‡Šï¼Œä½ ç”¨<code>/*</code>å¼€å§‹å†™ï¼Œ<code>*/</code>ç»“æŸå†™ã€‚è¿™ä¸ªå†™åœ¨ä½ çš„ä»£ç ä¸­é—´å¾ˆæœ‰ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number/*: i16*/ = 100;
}</code></pre></pre>
<p>å¯¹ç¼–è¯‘å™¨æ¥è¯´ï¼Œ<code>let some_number/*: i16*/ = 100;</code>çœ‹èµ·æ¥åƒ<code>let some_number = 100;</code>ã€‚</p>
<p><code>/* */</code>å½¢å¼å¯¹äºè¶…è¿‡ä¸€è¡Œçš„éå¸¸é•¿çš„æ³¨é‡Šä¹Ÿå¾ˆæœ‰ç”¨ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯ä»¥çœ‹åˆ°ä½ éœ€è¦ä¸ºæ¯ä¸€è¡Œå†™<code>//</code>ã€‚ä½†æ˜¯å¦‚æœæ‚¨è¾“å…¥ <code>/*</code>ï¼Œå®ƒä¸ä¼šåœæ­¢ï¼Œç›´åˆ°æ‚¨ç”¨ <code>*/</code> å®Œæˆå®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 100; /* Let me tell you
    a little about this number.
    It's 100, which is my favourite number.
    It's called some_number but actually I think that... */

    let some_number = 100; // Let me tell you
    // a little about this number.
    // It's 100, which is my favourite number.
    // It's called some_number but actually I think that...
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç±»å‹"><a class="header" href="#ç±»å‹">ç±»å‹</a></h2>
<p>Rustæœ‰å¾ˆå¤šç±»å‹ï¼Œè®©ä½ å¯ä»¥å¤„ç†æ•°å­—ã€å­—ç¬¦ç­‰ã€‚æœ‰äº›ç±»å‹å¾ˆç®€å•ï¼Œæœ‰äº›ç±»å‹æ¯”è¾ƒå¤æ‚ï¼Œä½ ç”šè‡³å¯ä»¥åˆ›å»ºè‡ªå·±çš„ç±»å‹ã€‚</p>
<h3 id="åŸå§‹ç±»å‹"><a class="header" href="#åŸå§‹ç±»å‹">åŸå§‹ç±»å‹</a></h3>
<p>Rustæœ‰ç®€å•çš„ç±»å‹ï¼Œè¿™äº›ç±»å‹è¢«ç§°ä¸º<strong>åŸå§‹ç±»å‹</strong>(åŸå§‹=éå¸¸åŸºæœ¬)ã€‚æˆ‘ä»¬å°†ä»æ•´æ•°å’Œ<code>char</code>(å­—ç¬¦)å¼€å§‹ã€‚æ•´æ•°æ˜¯æ²¡æœ‰å°æ•°ç‚¹çš„æ•´æ•°ã€‚æ•´æ•°æœ‰ä¸¤ç§ç±»å‹ã€‚</p>
<ul>
<li>æœ‰ç¬¦å·çš„æ•´æ•°</li>
<li>æ— ç¬¦å·æ•´æ•°</li>
</ul>
<p>ç¬¦å·æ˜¯æŒ‡<code>+</code>(åŠ å·)å’Œ<code>-</code>(å‡å·)ï¼Œæ‰€ä»¥æœ‰ç¬¦å·çš„æ•´æ•°å¯ä»¥æ˜¯æ­£æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯è´Ÿæ•°(å¦‚+8ï¼Œ-8)ã€‚ä½†æ— ç¬¦å·æ•´æ•°åªèƒ½æ˜¯æ­£æ•°ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰ç¬¦å·ã€‚</p>
<p>æœ‰ç¬¦å·çš„æ•´æ•°æ˜¯ <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, å’Œ <code>isize</code>ã€‚</p>
<p>æ— ç¬¦å·çš„æ•´æ•°æ˜¯ <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, å’Œ <code>usize</code>ã€‚</p>
<p>iæˆ–uåé¢çš„æ•°å­—è¡¨ç¤ºè¯¥æ•°å­—çš„ä½æ•°ï¼Œæ‰€ä»¥ä½æ•°å¤šçš„æ•°å­—å¯ä»¥å¤§ä¸€äº›ã€‚8ä½=ä¸€ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥<code>i8</code>æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œ<code>i64</code>æ˜¯8ä¸ªå­—èŠ‚ï¼Œä»¥æ­¤ç±»æ¨ã€‚å°ºå¯¸è¾ƒå¤§çš„æ•°å­—ç±»å‹å¯ä»¥å®¹çº³æ›´å¤§çš„æ•°å­—ã€‚ä¾‹å¦‚ï¼Œ<code>u8</code>æœ€å¤šå¯ä»¥å®¹çº³255ï¼Œä½†<code>u16</code>æœ€å¤šå¯ä»¥å®¹çº³65535ã€‚è€Œ<code>u128</code>æœ€å¤šå¯ä»¥å®¹çº³340282366920938463463374607431768211455ã€‚</p>
<p>é‚£ä¹ˆä»€ä¹ˆæ˜¯<code>isize</code>å’Œ<code>usize</code>å‘¢ï¼Ÿè¿™è¡¨ç¤ºä½ ç”µè„‘çš„ä½æ•°ã€‚(ä½ çš„ç”µè„‘ä¸Šçš„ä½æ•°å«åšä½ ç”µè„‘çš„<strong>æ¶æ„</strong>)ã€‚æ‰€ä»¥32ä½è®¡ç®—æœºä¸Šçš„<code>isize</code>å’Œ<code>usize</code>å°±åƒ<code>i32</code>å’Œ<code>u32</code>ï¼Œ64ä½è®¡ç®—æœºä¸Šçš„<code>isize</code>å’Œ<code>usize</code>å°±åƒ<code>i64</code>å’Œ<code>u64</code>ã€‚</p>
<p>æ•´æ•°ç±»å‹ä¸åŒçš„åŸå› æœ‰å¾ˆå¤šã€‚å…¶ä¸­ä¸€ä¸ªåŸå› æ˜¯è®¡ç®—æœºæ€§èƒ½:è¾ƒå°çš„å­—èŠ‚æ•°å¤„ç†é€Ÿåº¦æ›´å¿«ã€‚ä¾‹å¦‚ï¼Œæ•°å­—-10ä½œä¸º<code>i8</code>æ˜¯<code>11110110</code>ï¼Œä½†ä½œä¸º<code>i128</code>æ˜¯<code>11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110</code>ã€‚ä½†è¿™é‡Œè¿˜æœ‰ä¸€äº›å…¶ä»–ç”¨æ³•ã€‚</p>
<p>Rustä¸­çš„å­—ç¬¦å«åš<code>char</code>. æ¯ä¸€ä¸ª<code>char</code>éƒ½æœ‰ä¸€ä¸ªæ•°å­—:å­—æ¯<code>A</code>æ˜¯æ•°å­—65ï¼Œè€Œå­—ç¬¦<code>å‹</code>(ä¸­æ–‡çš„ "æœ‹å‹")æ˜¯æ•°å­—21451ã€‚è¿™ä¸ªæ•°å­—åˆ—è¡¨è¢«ç§°ä¸º "Unicode"ã€‚Unicodeå¯¹ä½¿ç”¨è¾ƒå¤šçš„å­—ç¬¦ä½¿ç”¨è¾ƒå°çš„æ•°å­—ï¼Œå¦‚Aåˆ°Zï¼Œæˆ–0åˆ°9çš„æ•°å­—ï¼Œæˆ–ç©ºæ ¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_letter = 'A';
    let space = ' '; // A space inside ' ' is also a char
    let other_language_char = 'á„'; // Thanks to Unicode, other languages like Cherokee display just fine too
    let cat_face = 'ğŸ˜º'; // Emojis are chars too
}</code></pre></pre>
<p>ä½¿ç”¨æœ€å¤šçš„å­—ç¬¦çš„æ•°å­—å°äº256ï¼Œå®ƒä»¬å¯ä»¥è£…è¿›<code>u8</code>ã€‚è®°ä½ï¼Œ<code>u8</code>æ˜¯0åŠ ä¸Š255ä»¥å†…çš„æ‰€æœ‰æ•°å­—ï¼Œæ€»å…±256ä¸ªã€‚è¿™æ„å‘³ç€ Rust å¯ä»¥ä½¿ç”¨ <code>as</code> å°† <code>u8</code> å®‰å…¨åœ° <strong>cast</strong>æˆ <code>char</code>ã€‚("æŠŠ <code>u8</code> castæˆ <code>char</code>"æ„å‘³ç€ "æŠŠ <code>u8</code> å‡è£…æˆ <code>char</code>")</p>
<p>ç”¨ <code>as</code> castæ˜¯æœ‰ç”¨çš„ï¼Œå› ä¸º Rust æ˜¯éå¸¸ä¸¥æ ¼çš„ã€‚å®ƒæ€»æ˜¯éœ€è¦çŸ¥é“ç±»å‹ã€‚
è€Œä¸ä¼šè®©ä½ åŒæ—¶ä½¿ç”¨ä¸¤ç§ä¸åŒçš„ç±»å‹ï¼Œå³ä½¿å®ƒä»¬éƒ½æ˜¯æ•´æ•°ã€‚ä¾‹å¦‚ï¼Œè¿™å°†æ— æ³•å·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // main() is where Rust programs start to run. Code goes inside {} (curly brackets)

    let my_number = 100; // We didn't write a type of integer,
                         // so Rust chooses i32. Rust always
                         // chooses i32 for integers if you don't
                         // tell it to use a different type

    println!("{}", my_number as char); // âš ï¸
}</code></pre></pre>
<p>åŸå› æ˜¯è¿™æ ·çš„:</p>
<pre><code class="language-text">error[E0604]: only `u8` can be cast as `char`, not `i32`
 --&gt; src\main.rs:3:20
  |
3 |     println!("{}", my_number as char);
  |                    ^^^^^^^^^^^^^^^^^
</code></pre>
<p>å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨<code>as</code>è½»æ¾è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬ä¸èƒ½æŠŠ<code>i32</code>è½¬æˆ<code>char</code>ï¼Œä½†æˆ‘ä»¬å¯ä»¥æŠŠ<code>i32</code>è½¬æˆ<code>u8</code>ï¼Œç„¶åæŠŠ<code>u8</code>è½¬æ¢æˆ<code>char</code>ã€‚æ‰€ä»¥åœ¨ä¸€è¡Œä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ <code>as</code> å°† my_number å˜ä¸º <code>u8</code>ï¼Œå†å°†å…¶å˜ä¸º <code>char</code>ã€‚ç°åœ¨å¯ä»¥ç¼–è¯‘äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 100;
    println!("{}", my_number as u8 as char);
}</code></pre></pre>
<p>å®ƒæ‰“å°çš„æ˜¯<code>d</code>ï¼Œå› ä¸ºé‚£æ˜¯100å¯¹åº”çš„<code>char</code>ã€‚</p>
<p>ç„¶è€Œï¼Œæ›´ç®€å•çš„æ–¹æ³•æ˜¯å‘Šè¯‰ Rust <code>my_number</code> æ˜¯ <code>u8</code>ã€‚ä¸‹é¢æ˜¯ä½ çš„åšæ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 100; //  change my_number to my_number: u8
    println!("{}", my_number as char);
}</code></pre></pre>
<p>æ‰€ä»¥è¿™å°±æ˜¯Rustä¸­æ‰€æœ‰ä¸åŒæ•°å­—ç±»å‹çš„ä¸¤ä¸ªåŸå› ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªåŸå› :<code>usize</code>æ˜¯Rustç”¨äº<em>ç´¢å¼•</em>çš„å¤§å°ã€‚(ç´¢å¼•çš„æ„æ€æ˜¯ "å“ªé¡¹æ˜¯ç¬¬ä¸€"ï¼Œ"å“ªé¡¹æ˜¯ç¬¬äºŒ"ç­‰ç­‰)<code>usize</code>æ˜¯ç´¢å¼•çš„æœ€ä½³å¤§å°ï¼Œå› ä¸º:</p>
<ul>
<li>ç´¢å¼•ä¸èƒ½æ˜¯è´Ÿæ•°ï¼Œæ‰€ä»¥å®ƒéœ€è¦æ˜¯ä¸€ä¸ªå¸¦uçš„æ•°å­—</li>
<li>å®ƒåº”è¯¥æ˜¯å¤§çš„ï¼Œå› ä¸ºæœ‰æ—¶ä½ éœ€è¦ç´¢å¼•å¾ˆå¤šä¸œè¥¿ï¼Œä½†ã€‚</li>
<li>ä¸å¯èƒ½æ˜¯u64ï¼Œå› ä¸º32ä½ç”µè„‘ä¸èƒ½ä½¿ç”¨u64ã€‚</li>
</ul>
<p>æ‰€ä»¥Rustä½¿ç”¨äº†<code>usize</code>ï¼Œè¿™æ ·ä½ çš„è®¡ç®—æœºå°±å¯ä»¥å¾—åˆ°å®ƒèƒ½è¯»åˆ°çš„æœ€å¤§çš„æ•°å­—è¿›è¡Œç´¢å¼•ã€‚</p>
<p>æˆ‘ä»¬å†æ¥äº†è§£ä¸€ä¸‹<code>char</code>ã€‚ä½ çœ‹åˆ°<code>char</code>æ€»æ˜¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”ä½¿ç”¨<code>''</code>è€Œä¸æ˜¯<code>""</code>ã€‚</p>
<p>æ‰€æœ‰çš„ <code>å­—ç¬¦</code> éƒ½ä½¿ç”¨4ä¸ªå­—èŠ‚çš„å†…å­˜ï¼Œå› ä¸º4ä¸ªå­—èŠ‚è¶³ä»¥å®¹çº³ä»»ä½•ç§ç±»çš„å­—ç¬¦:</p>
<ul>
<li>åŸºæœ¬å­—æ¯å’Œç¬¦å·é€šå¸¸éœ€è¦4ä¸ªå­—èŠ‚ä¸­çš„1ä¸ªï¼š<code>a b 1 2 + - = $ @</code></li>
<li>å…¶ä»–å­—æ¯ï¼Œå¦‚å¾·è¯­çš„ Umlauts æˆ–é‡éŸ³ï¼Œéœ€è¦4ä¸ªå­—èŠ‚ä¸­çš„2ä¸ªï¼š <code>Ã¤ Ã¶ Ã¼ ÃŸ Ã¨ Ã© Ã  Ã±</code></li>
<li>éŸ©æ–‡ã€æ—¥æ–‡æˆ–ä¸­æ–‡å­—ç¬¦éœ€è¦3æˆ–4ä¸ªå­—èŠ‚ï¼š <code>å›½ ì•ˆ ë…•</code></li>
</ul>
<p>å½“ä½¿ç”¨å­—ç¬¦ä½œä¸ºå­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†æ—¶ï¼Œå­—ç¬¦ä¸²è¢«ç¼–ç ä»¥ä½¿ç”¨æ¯ä¸ªå­—ç¬¦æ‰€éœ€çš„æœ€å°å†…å­˜é‡ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥ç”¨<code>.len()</code>æ¥çœ‹ä¸€ä¸‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Size of a char: {}", std::mem::size_of::&lt;char&gt;()); // 4 bytes
    println!("Size of string containing 'a': {}", "a".len()); // .len() gives the size of the string in bytes
    println!("Size of string containing 'ÃŸ': {}", "ÃŸ".len());
    println!("Size of string containing 'å›½': {}", "å›½".len());
    println!("Size of string containing 'ğ“…±': {}", "ğ“…±".len());
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºæ¥ã€‚</p>
<pre><code class="language-text">Size of a char: 4
Size of string containing 'a': 1
Size of string containing 'ÃŸ': 2
Size of string containing 'å›½': 3
Size of string containing 'ğ“…±': 4
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œ<code>a</code>æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œå¾·æ–‡çš„<code>ÃŸ</code>æ˜¯ä¸¤ä¸ªå­—èŠ‚ï¼Œæ—¥æ–‡çš„<code>å›½</code>æ˜¯ä¸‰ä¸ªå­—èŠ‚ï¼Œå¤åŸƒåŠçš„<code>ğ“…±</code>æ˜¯4ä¸ªå­—èŠ‚ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice = "Hello!";
    println!("Slice is {} bytes.", slice.len());
    let slice2 = "ì•ˆë…•!"; // Korean for "hi"
    println!("Slice2 is {} bytes.", slice2.len());
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Slice is 6 bytes.
Slice2 is 7 bytes.
</code></pre>
<p><code>slice</code>çš„é•¿åº¦æ˜¯6ä¸ªå­—ç¬¦ï¼Œ6ä¸ªå­—èŠ‚ï¼Œä½†<code>slice2</code>çš„é•¿åº¦æ˜¯3ä¸ªå­—ç¬¦ï¼Œ7ä¸ªå­—èŠ‚ã€‚</p>
<p>å¦‚æœ<code>.len()</code>ç»™å‡ºçš„æ˜¯ä»¥å­—èŠ‚ä¸ºå•ä½çš„å¤§å°ï¼Œé‚£ä¹ˆä»¥å­—ç¬¦ä¸ºå•ä½çš„å¤§å°å‘¢ï¼Ÿè¿™äº›æ–¹æ³•æˆ‘ä»¬åé¢ä¼šå­¦ä¹ ï¼Œä½†ä½ åªè¦è®°ä½<code>.chars().count()</code>å°±å¯ä»¥äº†ã€‚<code>.chars().count()</code> å°†ä½ å†™çš„ä¸œè¥¿å˜æˆå­—ç¬¦ï¼Œç„¶åè®¡ç®—æœ‰å¤šå°‘ä¸ªå­—ç¬¦ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice = "Hello!";
    println!("Slice is {} bytes and also {} characters.", slice.len(), slice.chars().count());
    let slice2 = "ì•ˆë…•!";
    println!("Slice2 is {} bytes but only {} characters.", slice2.len(), slice2.chars().count());
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡ºæ¥äº†ã€‚</p>
<pre><code class="language-text">Slice is 6 bytes and also 6 characters.
Slice2 is 7 bytes but only 3 characters.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç±»å‹æ¨å¯¼"><a class="header" href="#ç±»å‹æ¨å¯¼">ç±»å‹æ¨å¯¼</a></h2>
<p>ç±»å‹æ¨å¯¼çš„æ„æ€æ˜¯ï¼Œå¦‚æœä½ ä¸å‘Šè¯‰ç¼–è¯‘å™¨ç±»å‹ï¼Œä½†å®ƒå¯ä»¥è‡ªå·±å†³å®šï¼Œå®ƒå°±ä¼šå†³å®šã€‚ç¼–è¯‘å™¨æ€»æ˜¯éœ€è¦çŸ¥é“å˜é‡çš„ç±»å‹ï¼Œä½†ä½ å¹¶ä¸æ€»æ˜¯éœ€è¦å‘Šè¯‰å®ƒã€‚å®é™…ä¸Šï¼Œé€šå¸¸ä½ ä¸éœ€è¦å‘Šè¯‰å®ƒã€‚ä¾‹å¦‚ï¼Œå¯¹äº<code>let my_number = 8</code>ï¼Œ<code>my_number</code>å°†æ˜¯ä¸€ä¸ª<code>i32</code>ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœä½ ä¸å‘Šè¯‰å®ƒï¼Œç¼–è¯‘å™¨ä¼šé€‰æ‹©i32ä½œä¸ºæ•´æ•°ã€‚ä½†æ˜¯å¦‚æœä½ è¯´<code>let my_number: u8 = 8</code>ï¼Œå®ƒå°±ä¼šæŠŠ<code>my_number</code>å˜æˆ<code>u8</code>ï¼Œå› ä¸ºä½ å‘Šè¯‰å®ƒ<code>u8</code>ã€‚</p>
<p>é€šå¸¸ç¼–è¯‘å™¨éƒ½èƒ½çŒœåˆ°ã€‚ä½†æœ‰æ—¶ä½ éœ€è¦å‘Šè¯‰å®ƒï¼ŒåŸå› æœ‰ä¸¤ä¸ªã€‚</p>
<ol>
<li>ä½ æ­£åœ¨åšä¸€äº›éå¸¸å¤æ‚çš„äº‹æƒ…ï¼Œè€Œç¼–è¯‘å™¨ä¸çŸ¥é“ä½ æƒ³è¦çš„ç±»å‹ã€‚</li>
<li>ä½ æƒ³è¦ä¸€ä¸ªä¸åŒçš„ç±»å‹(ä¾‹å¦‚ï¼Œä½ æƒ³è¦ä¸€ä¸ª<code>i128</code>ï¼Œè€Œä¸æ˜¯<code>i32</code>)ã€‚</li>
</ol>
<p>è¦æŒ‡å®šä¸€ä¸ªç±»å‹ï¼Œè¯·åœ¨å˜é‡ååæ·»åŠ ä¸€ä¸ªå†’å·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let small_number: u8 = 10;
}</code></pre></pre>
<p>å¯¹äºæ•°å­—ï¼Œä½ å¯ä»¥åœ¨æ•°å­—åé¢åŠ ä¸Šç±»å‹ã€‚ä½ ä¸éœ€è¦ç©ºæ ¼--åªéœ€è¦åœ¨æ•°å­—åé¢ç›´æ¥è¾“å…¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let small_number = 10u8; // 10u8 = 10 of type u8
}</code></pre></pre>
<p>å¦‚æœä½ æƒ³è®©æ•°å­—ä¾¿äºé˜…è¯»ï¼Œä¹Ÿå¯ä»¥åŠ ä¸Š<code>_</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let small_number = 10_u8; // This is easier to read
    let big_number = 100_000_000_i32; // 100 million is easy to read with _
}</code></pre></pre>
<p><code>_</code>ä¸ä¼šæ”¹å˜æ•°å­—ã€‚å®ƒåªæ˜¯ä¸ºäº†è®©ä½ æ–¹ä¾¿é˜…è¯»ã€‚è€Œä¸”ä½ ç”¨å¤šå°‘ä¸ª<code>_</code>éƒ½æ²¡æœ‰å…³ç³»ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 0________u8;
    let number2 = 1___6______2____4______i32;
    println!("{}, {}", number, number2);
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºçš„æ˜¯<code>0, 1624</code>ã€‚</p>
<h3 id="æµ®ç‚¹æ•°"><a class="header" href="#æµ®ç‚¹æ•°">æµ®ç‚¹æ•°</a></h3>
<p>æµ®ç‚¹æ•°æ˜¯å¸¦æœ‰å°æ•°ç‚¹çš„æ•°å­—ã€‚5.5æ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°ï¼Œ6æ˜¯ä¸€ä¸ªæ•´æ•°ã€‚5.0ä¹Ÿæ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°ï¼Œç”šè‡³5.ä¹Ÿæ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float = 5.; // Rust sees . and knows that it is a float
}</code></pre></pre>
<p>ä½†ç±»å‹ä¸å«<code>float</code>ï¼Œå«<code>f32</code>å’Œ<code>f64</code>ã€‚è¿™å’Œæ•´æ•°ä¸€æ ·:<code>f</code>åé¢çš„æ•°å­—æ˜¾ç¤ºçš„æ˜¯ä½æ•°ã€‚å¦‚æœä½ ä¸å†™ç±»å‹ï¼ŒRustä¼šé€‰æ‹©<code>f64</code>ã€‚</p>
<p>å½“ç„¶ï¼Œåªæœ‰åŒä¸€ç±»å‹çš„æµ®ç‚¹æ•°å¯ä»¥ä¸€èµ·ä½¿ç”¨ã€‚æ‰€ä»¥ä½ ä¸èƒ½æŠŠ<code>f32</code>åŠ åˆ°<code>f64</code>ä¸Šã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f64 = 5.0; // This is an f64
    let my_other_float: f32 = 8.5; // This is an f32

    let third_float = my_float + my_other_float; // âš ï¸
}</code></pre></pre>
<p>å½“ä½ å°è¯•è¿è¡Œè¿™ä¸ªæ—¶ï¼ŒRustä¼šè¯´ã€‚</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src\main.rs:5:34
  |
5 |     let third_float = my_float + my_other_float;
  |                                  ^^^^^^^^^^^^^^ expected `f64`, found `f32`
</code></pre>
<p>å½“ä½ ä½¿ç”¨é”™è¯¯çš„ç±»å‹æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå†™ "expected (type), found (type)"ã€‚å®ƒè¿™æ ·è¯»å–ä½ çš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f64 = 5.0; // The compiler sees an f64
    let my_other_float: f32 = 8.5; // The compiler sees an f32. It is a different type.
    let third_float = my_float + // You want to add my_float to something, so it must be an f64 plus another f64. Now it expects an f64...
    let third_float = my_float + my_other_float;  // âš ï¸ but it found an f32. It can't add them.
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œå½“ä½ çœ‹åˆ° "expected(type)ï¼Œfound(type)"æ—¶ï¼Œä½ å¿…é¡»æ‰¾åˆ°ä¸ºä»€ä¹ˆç¼–è¯‘å™¨é¢„æœŸçš„æ˜¯ä¸åŒçš„ç±»å‹ã€‚</p>
<p>å½“ç„¶ï¼Œç”¨ç®€å•çš„æ•°å­—å¾ˆå®¹æ˜“è§£å†³ã€‚ä½ å¯ä»¥ç”¨<code>as</code>æŠŠ<code>f32</code>è½¬æˆ<code>f64</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f64 = 5.0;
    let my_other_float: f32 = 8.5;

    let third_float = my_float + my_other_float as f64; // my_other_float as f64 = use my_other_float like an f64
}</code></pre></pre>
<p>æˆ–è€…æ›´ç®€å•ï¼Œå»æ‰ç±»å‹å£°æ˜ã€‚("å£°æ˜ä¸€ä¸ªç±»å‹"="å‘Šè¯‰Rustä½¿ç”¨è¯¥ç±»å‹")Rustä¼šé€‰æ‹©å¯ä»¥åŠ åœ¨ä¸€èµ·çš„ç±»å‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float = 5.0; // Rust will choose f64
    let my_other_float = 8.5; // Here again it will choose f64

    let third_float = my_float + my_other_float;
}</code></pre></pre>
<p>Rustç¼–è¯‘å™¨å¾ˆèªæ˜ï¼Œå¦‚æœä½ éœ€è¦f32ï¼Œå°±ä¸ä¼šé€‰æ‹©f64ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_float: f32 = 5.0;
    let my_other_float = 8.5; // Usually Rust would choose f64,

    let third_float = my_float + my_other_float; // but now it knows that you need to add it to an f32. So it chooses f32 for my_other_float too
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ‰“å°hello-world"><a class="header" href="#æ‰“å°hello-world">æ‰“å°hello, world!</a></h2>
<p>å½“ä½ å¯åŠ¨ä¸€ä¸ªæ–°çš„Rustç¨‹åºæ—¶ï¼Œå®ƒæ€»æ˜¯æœ‰è¿™æ ·çš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<ul>
<li>
<p><code>fn</code>çš„æ„æ€æ˜¯å‡½æ•°ã€‚</p>
</li>
<li>
<p><code>main</code>æ˜¯å¯åŠ¨ç¨‹åºçš„å‡½æ•°ã€‚</p>
</li>
<li>
<p><code>()</code>è¡¨ç¤ºæˆ‘ä»¬æ²¡æœ‰ç»™å‡½æ•°ä»»ä½•å˜é‡æ¥å¯åŠ¨ã€‚</p>
</li>
</ul>
<p><code>{}</code>è¢«ç§°ä¸º<strong>ä»£ç å—</strong>ã€‚è¿™æ˜¯ä»£ç æ‰€åœ¨çš„ç©ºé—´ã€‚</p>
<p><code>println!</code>æ˜¯ä¸€ä¸ª<strong>å®</strong>ï¼Œæ‰“å°åˆ°æ§åˆ¶å°ã€‚ä¸€ä¸ª<strong>å®</strong>å°±åƒä¸€ä¸ªå‡½æ•°ï¼Œä¸ºä½ å†™ä»£ç ã€‚å®åé¢æœ‰ä¸€ä¸ª<code>!</code>ã€‚æˆ‘ä»¬ä»¥åä¼šå­¦ä¹ å¦‚ä½•åˆ›å»ºå®ã€‚ç°åœ¨ï¼Œè¯·è®°ä½ï¼Œ<code>!</code>è¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªå®ã€‚</p>
<p>ä¸ºäº†å­¦ä¹ <code>;</code>ï¼Œæˆ‘ä»¬å°†åˆ›å»ºå¦ä¸€ä¸ªå‡½æ•°ã€‚é¦–å…ˆï¼Œåœ¨<code>main</code>ä¸­ï¼Œæˆ‘ä»¬å°†æ‰“å°ä¸€ä¸ªæ•°å­—8ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world number {}!", 8);
}</code></pre></pre>
<p><code>println!</code>ä¸­çš„<code>{}</code>çš„æ„æ€æ˜¯ "æŠŠå˜é‡æ”¾åœ¨è¿™é‡Œé¢"ã€‚è¿™æ ·å°±ä¼šæ‰“å°å‡º<code>Hello, world number 8!</code>ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥åƒä¹‹å‰ä¸€æ ·ï¼Œæ”¾æ›´å¤šçš„ä¸œè¥¿è¿›å»ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, worlds number {} and {}!", 8, 9);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>Hello, worlds number 8 and 9!</code>ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬æ¥åˆ›å»ºå‡½æ•°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn number() -&gt; i32 {
    8
}

fn main() {
    println!("Hello, world number {}!", number());
}</code></pre></pre>
<p>è¿™ä¹Ÿä¼šæ‰“å°å‡º <code>Hello, world number 8!</code>ã€‚å½“RustæŸ¥çœ‹<code>number()</code>æ—¶ï¼Œå®ƒçœ‹åˆ°ä¸€ä¸ªå‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°:</p>
<ul>
<li>æ²¡æœ‰å‚æ•°(å› ä¸ºå®ƒæœ‰<code>()</code>)</li>
<li>è¿”å›ä¸€ä¸ª<code>i32</code>ã€‚<code>-&gt;</code>(ç§°ä¸º "ç˜¦ç®­")æ˜¾ç¤ºäº†å‡½æ•°è¿”å›çš„å†…å®¹</li>
</ul>
<p>å‡½æ•°å†…éƒ¨åªæœ‰<code>8</code>ã€‚å› ä¸ºæ²¡æœ‰<code>;</code>ï¼Œæ‰€ä»¥è¿™å°±æ˜¯å®ƒè¿”å›çš„å€¼ã€‚å¦‚æœå®ƒæœ‰ä¸€ä¸ª<code>;</code>ï¼Œå®ƒå°†ä¸ä¼šè¿”å›ä»»ä½•ä¸œè¥¿(å®ƒä¼šè¿”å›ä¸€ä¸ª<code>()</code>)ã€‚å¦‚æœå®ƒæœ‰ <code>;</code>ï¼ŒRust ä¸ä¼šç¼–è¯‘é€šè¿‡ï¼Œå› ä¸ºéœ€è¦è¿”å›çš„æ˜¯ <code>i32</code>ï¼Œè€Œ <code>;</code> è¿”å› <code>()</code>ï¼Œä¸æ˜¯ <code>i32</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world number {}", number());
}

fn number() -&gt; i32 {
    8;  // âš ï¸
}</code></pre></pre>
<pre><code class="language-text">5 | fn number() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
6 |     8;
  |      - help: consider removing this semicolon
</code></pre>
<p>è¿™æ„å‘³ç€ "ä½ å‘Šè¯‰æˆ‘<code>number()</code>è¿”å›çš„æ˜¯<code>i32</code>ï¼Œä½†ä½ åŠ äº†ä¸€ä¸ª<code>;</code>ï¼Œæ‰€ä»¥å®ƒä»€ä¹ˆéƒ½ä¸è¿”å›"ã€‚æ‰€ä»¥ç¼–è¯‘å™¨å»ºè®®å»æ‰åˆ†å·ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥å†™<code>return 8;</code>ï¼Œä½†åœ¨Rustä¸­ï¼Œæ­£å¸¸æƒ…å†µä¸‹åªéœ€å°†<code>;</code>æ”¹ä¸º<code>return</code>å³å¯ã€‚</p>
<p>å½“ä½ æƒ³ç»™ä¸€ä¸ªå‡½æ•°èµ‹äºˆå˜é‡æ—¶ï¼ŒæŠŠå®ƒä»¬æ”¾åœ¨<code>()</code>é‡Œé¢ã€‚ä½ å¿…é¡»ç»™å®ƒä»¬èµ·ä¸ªåå­—ï¼Œå†™ä¸Šç±»å‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn multiply(number_one: i32, number_two: i32) { // Two i32s will enter the function. We will call them number_one and number_two.
    let result = number_one * number_two;
    println!("{} times {} is {}", number_one, number_two, result);
}

fn main() {
    multiply(8, 9); // We can give the numbers directly
    let some_number = 10; // Or we can declare two variables
    let some_other_number = 2;
    multiply(some_number, some_other_number); // and put them in the function
}</code></pre></pre>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿”å›ä¸€ä¸ª<code>i32</code>ã€‚åªè¦æŠŠæœ€åçš„åˆ†å·å»æ‰å°±å¯ä»¥äº†:</p>
<pre><pre class="playground"><code class="language-rust">fn multiply(number_one: i32, number_two: i32) -&gt; i32 {
    let result = number_one * number_two;
    println!("{} times {} is {}", number_one, number_two, result);
    result // this is the i32 that we return
}

fn main() {
    let multiply_result = multiply(8, 9); // We used multiply() to print and to give the result to multiply_result
}</code></pre></pre>
<h3 id="å£°æ˜å˜é‡å’Œä»£ç å—"><a class="header" href="#å£°æ˜å˜é‡å’Œä»£ç å—">å£°æ˜å˜é‡å’Œä»£ç å—</a></h3>
<p>ä½¿ç”¨<code>let</code>å£°æ˜ä¸€ä¸ªå˜é‡(å£°æ˜ä¸€ä¸ªå˜é‡=å‘Šè¯‰Ruståˆ›å»ºä¸€ä¸ªå˜é‡)ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    println!("Hello, number {}", my_number);
}</code></pre></pre>
<p>å˜é‡åœ¨ä»£ç å—<code>{}</code>å†…å¼€å§‹å’Œç»“æŸã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ<code>my_number</code>åœ¨æˆ‘ä»¬è°ƒç”¨<code>println!</code>ä¹‹å‰ç»“æŸï¼Œå› ä¸ºå®ƒåœ¨è‡ªå·±çš„ä»£ç å—é‡Œé¢ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let my_number = 8; // my_number starts here
                           // my_number ends here!
    }

    println!("Hello, number {}", my_number); // âš ï¸ there is no my_number and
                                             // println!() can't find it
}</code></pre></pre>
<p>ä½ å¯ä»¥ä½¿ç”¨ä»£ç å—æ¥è¿”å›ä¸€ä¸ªå€¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = {
    let second_number = 8;
        second_number + 9 // No semicolon, so the code block returns 8 + 9.
                          // It works just like a function
    };

    println!("My number is: {}", my_number);
}</code></pre></pre>
<p>å¦‚æœåœ¨ä»£ç å—å†…éƒ¨æ·»åŠ åˆ†å·ï¼Œå®ƒå°†è¿”å› <code>()</code> (æ— )ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = {
    let second_number = 8; // declare second_number,
        second_number + 9; // add 9 to second_number
                           // but we didn't return it!
                           // second_number dies now
    };

    println!("My number is: {:?}", my_number); // my_number is ()
}</code></pre></pre>
<p>é‚£ä¹ˆä¸ºä»€ä¹ˆæˆ‘ä»¬è¦å†™<code>{:?}</code>è€Œä¸æ˜¯<code>{}</code>å‘¢ï¼Ÿæˆ‘ä»¬ç°åœ¨å°±æ¥è°ˆè°ˆè¿™ä¸ªé—®é¢˜ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ˜¾ç¤ºå’Œè°ƒè¯•"><a class="header" href="#æ˜¾ç¤ºå’Œè°ƒè¯•">æ˜¾ç¤ºå’Œè°ƒè¯•</a></h2>
<p>Rustä¸­ç®€å•çš„å˜é‡å¯ä»¥ç”¨<code>{}</code>é‡Œé¢çš„<code>println!</code>æ‰“å°ã€‚ä½†æ˜¯æœ‰äº›å˜é‡ä¸èƒ½ï¼Œä½ éœ€è¦<strong>debug print</strong>ã€‚Debugæ‰“å°æ˜¯ç»™ç¨‹åºå‘˜æ‰“å°çš„ï¼Œå› ä¸ºå®ƒé€šå¸¸ä¼šæ˜¾ç¤ºæ›´å¤šçš„ä¿¡æ¯ã€‚Debugæœ‰æ—¶çœ‹èµ·æ¥å¹¶ä¸æ¼‚äº®ï¼Œå› ä¸ºå®ƒæœ‰é¢å¤–çš„ä¿¡æ¯æ¥å¸®åŠ©ä½ ã€‚</p>
<p>ä½ æ€ä¹ˆçŸ¥é“ä½ æ˜¯å¦éœ€è¦<code>{:?}</code>è€Œä¸æ˜¯<code>{}</code>ï¼Ÿç¼–è¯‘å™¨ä¼šå‘Šè¯‰ä½ ã€‚æ¯”å¦‚è¯´</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let doesnt_print = ();
    println!("This will not print: {}", doesnt_print); // âš ï¸
}</code></pre></pre>
<p>å½“æˆ‘ä»¬è¿è¡Œè¿™ä¸ªæ—¶ï¼Œç¼–è¯‘å™¨ä¼šè¯´:</p>
<pre><code class="language-text">error[E0277]: `()` doesn't implement `std::fmt::Display`
 --&gt; src\main.rs:3:41
  |
3 |     println!("This will not print: {}", doesnt_print);
  |                                         ^^^^^^^^^^^^ `()` cannot be formatted with the default formatter
  |
  = help: the trait `std::fmt::Display` is not implemented for `()`
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: required by `std::fmt::Display::fmt`
  = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>ä¿¡æ¯æ¯”è¾ƒå¤šï¼Œä½†é‡è¦çš„éƒ¨åˆ†æ˜¯ <code>you may be able to use {:?} (or {:#?} for pretty-print) instead</code>. è¿™æ„å‘³ç€ä½ å¯ä»¥è¯•è¯•<code>{:?}</code>ï¼Œä¹Ÿå¯ä»¥è¯•è¯•<code>{:#?}</code> <code>{:#?}</code>å«åš "æ¼‚äº®æ‰“å°"ã€‚å®ƒå’Œ<code>{:?}</code>ä¸€æ ·ï¼Œä½†æ˜¯åœ¨æ›´å¤šçš„è¡Œä¸Šæ‰“å°å‡ºä¸åŒçš„æ ¼å¼ã€‚</p>
<p>æ‰€ä»¥Displayå°±æ˜¯ç”¨<code>{}</code>æ‰“å°ï¼ŒDebugå°±æ˜¯ç”¨<code>{:?}</code>æ‰“å°ã€‚</p>
<p>è¿˜æœ‰ä¸€ç‚¹:å¦‚æœä½ ä¸æƒ³è¦æ–°çš„ä¸€è¡Œï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨<code>print!</code>è€Œä¸ç”¨<code>ln</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!("This will not print a new line");
    println!(" so this will be on the same line");
}</code></pre></pre>
<p>è¿™å°†æ‰“å°<code>This will not print a new line so this will be on the same line</code>ã€‚</p>
<h3 id="æœ€å°å’Œæœ€å¤§çš„æ•°"><a class="header" href="#æœ€å°å’Œæœ€å¤§çš„æ•°">æœ€å°å’Œæœ€å¤§çš„æ•°</a></h3>
<p>å¦‚æœä½ æƒ³çœ‹æœ€å°å’Œæœ€å¤§çš„æ•°å­—ï¼Œä½ å¯ä»¥ç”¨MINå’ŒMAXã€‚<code>std</code>çš„æ„æ€æ˜¯ "æ ‡å‡†åº“"ï¼Œæ‹¥æœ‰Rustçš„æ‰€æœ‰ä¸»è¦å‡½æ•°ç­‰ã€‚æˆ‘ä»¬å°†åœ¨ä»¥åå­¦ä¹ æ ‡å‡†åº“ã€‚ä½†ä¸æ­¤åŒæ—¶ï¼Œä½ å¯ä»¥è®°ä½ï¼Œè¿™å°±æ˜¯ä½ å¦‚ä½•è·å¾—ä¸€ä¸ªç±»å‹çš„æœ€å°å’Œæœ€å¤§çš„æ•°å­—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("The smallest i8 is {} and the biggest i8 is {}.", std::i8::MIN, std::i8::MAX); // hint: printing std::i8::MIN means "print MIN inside of the i8 section in the standard library"
    println!("The smallest u8 is {} and the biggest u8 is {}.", std::u8::MIN, std::u8::MAX);
    println!("The smallest i16 is {} and the biggest i16 is {}.", std::i16::MIN, std::i16::MAX);
    println!("The smallest u16 is {} and the biggest u16 is {}.", std::u16::MIN, std::u16::MAX);
    println!("The smallest i32 is {} and the biggest i32 is {}.", std::i32::MIN, std::i32::MAX);
    println!("The smallest u32 is {} and the biggest u32 is {}.", std::u32::MIN, std::u32::MAX);
    println!("The smallest i64 is {} and the biggest i64 is {}.", std::i64::MIN, std::i64::MAX);
    println!("The smallest u64 is {} and the biggest u64 is {}.", std::u64::MIN, std::u64::MAX);
    println!("The smallest i128 is {} and the biggest i128 is {}.", std::i128::MIN, std::i128::MAX);
    println!("The smallest u128 is {} and the biggest u128 is {}.", std::u128::MIN, std::u128::MAX);

}</code></pre></pre>
<p>å°†ä¼šæ‰“å°:</p>
<pre><code class="language-text">The smallest i8 is -128 and the biggest i8 is 127.
The smallest u8 is 0 and the biggest u8 is 255.
The smallest i16 is -32768 and the biggest i16 is 32767.
The smallest u16 is 0 and the biggest u16 is 65535.
The smallest i32 is -2147483648 and the biggest i32 is 2147483647.
The smallest u32 is 0 and the biggest u32 is 4294967295.
The smallest i64 is -9223372036854775808 and the biggest i64 is 9223372036854775807.
The smallest u64 is 0 and the biggest u64 is 18446744073709551615.
The smallest i128 is -170141183460469231731687303715884105728 and the biggest i128 is 170141183460469231731687303715884105727.
The smallest u128 is 0 and the biggest u128 is 340282366920938463463374607431768211455.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¯å˜æ€§"><a class="header" href="#å¯å˜æ€§">å¯å˜æ€§</a></h2>
<p>å½“ä½ ç”¨<code>let</code>å£°æ˜ä¸€ä¸ªå˜é‡æ—¶ï¼Œå®ƒæ˜¯ä¸å¯æ”¹å˜çš„(ä¸èƒ½æ”¹å˜)ã€‚</p>
<p>è¿™å°†æ— æ³•å·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    my_number = 10; // âš ï¸
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´:<code>error[E0384]: cannot assign twice to immutable variable my_number</code>ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœä½ åªå†™<code>let</code>ï¼Œå˜é‡æ˜¯ä¸å¯å˜çš„ã€‚</p>
<p>ä½†æœ‰æ—¶ä½ æƒ³æ”¹å˜ä½ çš„å˜é‡ã€‚è¦åˆ›å»ºä¸€ä¸ªå¯ä»¥æ”¹å˜çš„å˜é‡ï¼Œå°±åœ¨<code>let</code>åé¢åŠ ä¸Š<code>mut</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 8;
    my_number = 10;
}</code></pre></pre>
<p>ç°åœ¨æ²¡æœ‰é—®é¢˜äº†ã€‚</p>
<p>ä½†æ˜¯ï¼Œä½ ä¸èƒ½æ”¹å˜ç±»å‹:ç”šè‡³<code>mut</code>ä¹Ÿä¸èƒ½è®©ä½ è¿™æ ·åš:è¿™å°†æ— æ³•å·¥ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_variable = 8; // it is now an i32. That can't be changed
    my_variable = "Hello, world!"; // âš ï¸
}</code></pre></pre>
<p>ä½ ä¼šçœ‹åˆ°ç¼–è¯‘å™¨å‘å‡ºçš„åŒæ ·çš„ "é¢„æœŸ"ä¿¡æ¯ã€‚<code>expected integer, found &amp;str</code>. <code>&amp;str</code>æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼Œæˆ‘ä»¬å¾ˆå¿«å°±ä¼šçŸ¥é“ã€‚</p>
<h3 id="é®è”½"><a class="header" href="#é®è”½">é®è”½</a></h3>
<p>shadowingæ˜¯æŒ‡ä½¿ç”¨<code>let</code>å£°æ˜ä¸€ä¸ªä¸å¦ä¸€ä¸ªå˜é‡åŒåçš„æ–°å˜é‡ã€‚å®ƒçœ‹èµ·æ¥åƒå¯å˜æ€§ï¼Œä½†å®Œå…¨ä¸åŒã€‚shadowingçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8; // This is an i32
    println!("{}", my_number); // prints 8
    let my_number = 9.2; // This is an f64 with the same name. But it's not the first my_number - it is completely different!
    println!("{}", my_number) // Prints 9.2
}</code></pre></pre>
<p>è¿™é‡Œæˆ‘ä»¬è¯´æˆ‘ä»¬ç”¨ä¸€ä¸ªæ–°çš„ "letç»‘å®š"å¯¹<code>my_number</code>è¿›è¡Œäº† "shadowing"ã€‚</p>
<p>é‚£ä¹ˆç¬¬ä¸€ä¸ª<code>my_number</code>æ˜¯å¦è¢«é”€æ¯äº†å‘¢ï¼Ÿæ²¡æœ‰ï¼Œä½†æ˜¯å½“æˆ‘ä»¬è°ƒç”¨<code>my_number</code>æ—¶ï¼Œæˆ‘ä»¬ç°åœ¨å¾—åˆ°<code>my_number</code>çš„<code>f64</code>ã€‚å› ä¸ºå®ƒä»¬åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸå—ä¸­(åŒä¸€ä¸ª <code>{}</code>)ï¼Œæˆ‘ä»¬ä¸èƒ½å†çœ‹åˆ°ç¬¬ä¸€ä¸ª <code>my_number</code>ã€‚</p>
<p>ä½†å¦‚æœå®ƒä»¬åœ¨ä¸åŒçš„å—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åŒæ—¶çœ‹åˆ°ä¸¤ä¸ªã€‚
ä¾‹å¦‚:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8; // This is an i32
    println!("{}", my_number); // prints 8
    {
        let my_number = 9.2; // This is an f64. It is not my_number - it is completely different!
        println!("{}", my_number) // Prints 9.2
                                  // But the shadowed my_number only lives until here.
                                  // The first my_number is still alive!
    }
    println!("{}", my_number); // prints 8
}</code></pre></pre>
<p>å› æ­¤ï¼Œå½“ä½ å¯¹ä¸€ä¸ªå˜é‡è¿›è¡Œshadowingå¤„ç†æ—¶ï¼Œä½ ä¸ä¼šç ´åå®ƒã€‚ä½ <strong>å±è”½</strong>äº†å®ƒã€‚</p>
<p>é‚£ä¹ˆshadowingçš„å¥½å¤„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå½“ä½ éœ€è¦ç»å¸¸æ”¹å˜ä¸€ä¸ªå˜é‡çš„æ—¶å€™ï¼Œshadowingæ˜¯å¾ˆå¥½çš„ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æƒ³ç”¨ä¸€ä¸ªå˜é‡åšå¾ˆå¤šç®€å•çš„æ•°å­¦è¿ç®—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn times_two(number: i32) -&gt; i32 {
    number * 2
}

fn main() {
    let final_number = {
        let y = 10;
        let x = 9; // x starts at 9
        let x = times_two(x); // shadow with new x: 18
        let x = x + y; // shadow with new x: 28
        x // return x: final_number is now the value of x
    };
    println!("The number is now: {}", final_number)
}</code></pre></pre>
<p>å¦‚æœæ²¡æœ‰shadowingï¼Œä½ å°†ä¸å¾—ä¸è€ƒè™‘ä¸åŒçš„åç§°ï¼Œå°½ç®¡ä½ å¹¶ä¸å…³å¿ƒxã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn times_two(number: i32) -&gt; i32 {
    number * 2
}

fn main() {
    // Pretending we are using Rust without shadowing
    let final_number = {
        let y = 10;
        let x = 9; // x starts at 9
        let x_twice = times_two(x); // second name for x
        let x_twice_and_y = x_twice + y; // third name for x!
        x_twice_and_y // too bad we didn't have shadowing - we could have just used x
    };
    println!("The number is now: {}", final_number)
}</code></pre></pre>
<p>ä¸€èˆ¬æ¥è¯´ï¼Œä½ åœ¨Rustä¸­çœ‹åˆ°çš„shadowingå°±æ˜¯è¿™ç§æƒ…å†µã€‚å®ƒå‘ç”Ÿåœ¨ä½ æƒ³å¿«é€Ÿå–ç”¨å˜é‡ï¼Œå¯¹å®ƒåšä¸€äº›äº‹æƒ…ï¼Œç„¶åå†åšå…¶ä»–äº‹æƒ…çš„åœ°æ–¹ã€‚è€Œä½ é€šå¸¸å°†å®ƒç”¨äºé‚£äº›ä½ ä¸å¤ªå…³å¿ƒçš„å¿«é€Ÿå˜é‡ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ ˆå †å’ŒæŒ‡é’ˆ"><a class="header" href="#æ ˆå †å’ŒæŒ‡é’ˆ">æ ˆã€å †å’ŒæŒ‡é’ˆ</a></h2>
<p>æ ˆã€å †å’ŒæŒ‡é’ˆåœ¨Rustä¸­éå¸¸é‡è¦ã€‚</p>
<p>æ ˆå’Œå †æ˜¯è®¡ç®—æœºä¸­ä¿å­˜å†…å­˜çš„ä¸¤ä¸ªåœ°æ–¹ã€‚é‡è¦çš„åŒºåˆ«æ˜¯:</p>
<p>æ ˆçš„é€Ÿåº¦éå¸¸å¿«, ä½†å †çš„é€Ÿåº¦å°±ä¸é‚£ä¹ˆå¿«äº†. å®ƒä¹Ÿä¸æ˜¯è¶…æ…¢ï¼Œä½†æ ˆæ€»æ˜¯æ›´å¿«ã€‚ä½†æ˜¯ä½ ä¸èƒ½ä¸€ç›´ä½¿ç”¨æ ˆï¼Œå› ä¸º:</p>
<ul>
<li>Rustéœ€è¦åœ¨ç¼–è¯‘æ—¶çŸ¥é“ä¸€ä¸ªå˜é‡çš„å¤§å°ã€‚æ‰€ä»¥åƒ<code>i32</code>è¿™æ ·çš„ç®€å•å˜é‡å°±æ”¾åœ¨å †æ ˆä¸Šï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“å®ƒä»¬çš„ç¡®åˆ‡å¤§å°ã€‚ä½ æ€»æ˜¯çŸ¥é“<code>i32</code>è¦4å­—èŠ‚ï¼Œå› ä¸º32ä½=4å­—èŠ‚ã€‚æ‰€ä»¥<code>i32</code>æ€»æ˜¯å¯ä»¥æ”¾åœ¨æ ˆä¸Šã€‚</li>
<li>ä½†æœ‰äº›ç±»å‹åœ¨ç¼–è¯‘æ—¶ä¸çŸ¥é“å¤§å°ã€‚ä½†æ˜¯æ ˆéœ€è¦çŸ¥é“ç¡®åˆ‡çš„å¤§å°ã€‚é‚£ä¹ˆä½ è¯¥æ€ä¹ˆåšå‘¢ï¼Ÿé¦–å…ˆä½ æŠŠæ•°æ®æ”¾åœ¨å †ä¸­ï¼Œå› ä¸ºå †ä¸­å¯ä»¥æœ‰ä»»ä½•å¤§å°çš„æ•°æ®ã€‚ç„¶åä¸ºäº†æ‰¾åˆ°å®ƒï¼Œä¸€ä¸ªæŒ‡é’ˆå°±ä¼šè¿›å…¥æ ˆã€‚è¿™å¾ˆå¥½ï¼Œå› ä¸ºæˆ‘ä»¬æ€»æ˜¯çŸ¥é“æŒ‡é’ˆçš„å¤§å°ã€‚æ‰€ä»¥ï¼Œè®¡ç®—æœºå°±ä¼šå…ˆå»æ ˆï¼Œè¯»å–æŒ‡é’ˆï¼Œç„¶åè·Ÿç€æŒ‡é’ˆåˆ°æ•°æ®æ‰€åœ¨çš„å †ã€‚</li>
</ul>
<p>æŒ‡é’ˆå¬èµ·æ¥å¾ˆå¤æ‚ï¼Œä½†å®ƒä»¬å¾ˆå®¹æ˜“ã€‚æŒ‡é’ˆå°±åƒä¸€æœ¬ä¹¦çš„ç›®å½•ã€‚æƒ³è±¡ä¸€ä¸‹è¿™æœ¬ä¹¦ã€‚</p>
<pre><code class="language-text">MY BOOK

TABLE OF CONTENTS

Chapter                        Page
Chapter 1: My life              1
Chapter 2: My cat               15
Chapter 3: My job               23
Chapter 4: My family            30
Chapter 5: Future plans         43
</code></pre>
<p>æ‰€ä»¥è¿™å°±åƒäº”ä¸ªæŒ‡é’ˆã€‚ä½ å¯ä»¥é˜…è¯»å®ƒä»¬ï¼Œæ‰¾åˆ°å®ƒä»¬æ‰€è¯´çš„ä¿¡æ¯ã€‚"æˆ‘çš„ç”Ÿæ´»"è¿™ä¸€ç« åœ¨å“ªé‡Œï¼Ÿåœ¨ç¬¬1é¡µ(å®ƒ<em>æŒ‡å‘</em>ç¬¬1é¡µ)ã€‚"æˆ‘çš„å·¥ä½œ"è¿™ä¸€ç« åœ¨å“ªé‡Œï¼Ÿå®ƒåœ¨ç¬¬23é¡µã€‚</p>
<p>åœ¨Rustä¸­é€šå¸¸çœ‹åˆ°çš„æŒ‡é’ˆå«åš<strong>å¼•ç”¨</strong>ã€‚è¿™æ˜¯é‡è¦çš„éƒ¨åˆ†ï¼Œè¦çŸ¥é“:ä¸€ä¸ªå¼•ç”¨æŒ‡å‘å¦ä¸€ä¸ªå€¼çš„å†…å­˜ã€‚å¼•ç”¨æ„å‘³ç€ä½ <em>å€Ÿ</em>äº†è¿™ä¸ªå€¼ï¼Œä½†ä½ å¹¶ä¸æ‹¥æœ‰å®ƒã€‚è¿™å’Œæˆ‘ä»¬çš„ä¹¦ä¸€æ ·:ç›®å½•å¹¶ä¸æ‹¥æœ‰ä¿¡æ¯ã€‚ç« èŠ‚æ‰æ˜¯ä¿¡æ¯çš„ä¸»äººã€‚åœ¨Rustä¸­ï¼Œå¼•ç”¨æ–‡çŒ®çš„å‰é¢æœ‰ä¸€ä¸ª<code>&amp;</code>ã€‚æ‰€ä»¥:</p>
<ul>
<li><code>let my_variable = 8</code>æ˜¯ä¸€ä¸ªæ™®é€šçš„å˜é‡ï¼Œä½†æ˜¯:</li>
<li><code>let my_reference = &amp;my_variable</code>æ˜¯ä¸€ä¸ªå¼•ç”¨ã€‚</li>
</ul>
<p>ä½ æŠŠ <code>my_reference = &amp;my_variable</code> è¯»æˆè¿™æ ·: "my_referenceæ˜¯å¯¹my_variableçš„å¼•ç”¨". æˆ–è€…:"my_referenceæ˜¯å¯¹my_variableçš„å¼•ç”¨"ã€‚</p>
<p>è¿™æ„å‘³ç€<code>my_reference</code>åªçœ‹<code>my_variable</code>çš„æ•°æ®ã€‚<code>my_variable</code>ä»ç„¶æ‹¥æœ‰å®ƒçš„æ•°æ®ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ªå¼•ç”¨çš„å¼•ç”¨ï¼Œæˆ–è€…ä»»ä½•æ•°é‡çš„å¼•ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 15; // This is an i32
    let single_reference = &amp;my_number; //  This is a &amp;i32
    let double_reference = &amp;single_reference; // This is a &amp;&amp;i32
    let five_references = &amp;&amp;&amp;&amp;&amp;my_number; // This is a &amp;&amp;&amp;&amp;&amp;i32
}</code></pre></pre>
<p>è¿™äº›éƒ½æ˜¯ä¸åŒçš„ç±»å‹ï¼Œå°±åƒ "æœ‹å‹çš„æœ‹å‹"å’Œ "æœ‹å‹"ä¸åŒä¸€æ ·ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å…³äºæ‰“å°çš„æ›´å¤šä¿¡æ¯"><a class="header" href="#å…³äºæ‰“å°çš„æ›´å¤šä¿¡æ¯">å…³äºæ‰“å°çš„æ›´å¤šä¿¡æ¯</a></h2>
<p>åœ¨Rustä¸­ï¼Œä½ å‡ ä¹å¯ä»¥ç”¨ä»»ä½•ä½ æƒ³è¦çš„æ–¹å¼æ‰“å°ä¸œè¥¿ã€‚è¿™é‡Œæœ‰ä¸€äº›å…³äºæ‰“å°çš„äº‹æƒ…éœ€è¦çŸ¥é“ã€‚</p>
<p>æ·»åŠ  <code>\n</code> å°†ä¼šäº§ç”Ÿä¸€ä¸ªæ–°è¡Œï¼Œè€Œ <code>\t</code> å°†ä¼šäº§ç”Ÿä¸€ä¸ªæ ‡ç­¾ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Note: this is print!, not println!
    print!("\t Start with a tab\nand move to a new line");
}</code></pre></pre>
<p>è¿™æ ·å°±å¯ä»¥æ‰“å°äº†ã€‚</p>
<pre><code class="language-text">         Start with a tab
and move to a new line
</code></pre>
<p><code>""</code>é‡Œé¢å¯ä»¥å†™è¿‡å¾ˆå¤šè¡Œéƒ½æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯è¦æ³¨æ„é—´è·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Note: After the first line you have to start on the far left.
    // If you write directly under println!, it will add the spaces
    println!("Inside quotes
you can write over
many lines
and it will print just fine.");

    println!("If you forget to write
    on the left side, the spaces
    will be added when you print.");
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°å‡ºæ¥çš„ã€‚</p>
<pre><code class="language-text">Inside quotes
you can write over
many lines
and it will print just fine.
If you forget to write
    on the left side, the spaces
    will be added when you print.
</code></pre>
<p>å¦‚æœä½ æƒ³æ‰“å°<code>\n</code>è¿™æ ·çš„å­—ç¬¦(ç§°ä¸º "è½¬ä¹‰å­—ç¬¦")ï¼Œä½ å¯ä»¥å¤šåŠ ä¸€ä¸ª<code>\</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Here are two escape characters: \\n and \\t");
}</code></pre></pre>
<p>è¿™æ ·å°±å¯ä»¥æ‰“å°äº†ã€‚</p>
<pre><code class="language-text">Here are two escape characters: \n and \t
</code></pre>
<p>æœ‰æ—¶ä½ æœ‰å¤ªå¤šçš„ <code>"</code> å’Œè½¬ä¹‰å­—ç¬¦ï¼Œå¹¶å¸Œæœ› Rust å¿½ç•¥æ‰€æœ‰çš„å­—ç¬¦ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæ‚¨å¯ä»¥åœ¨å¼€å¤´æ·»åŠ  <code>r#</code>ï¼Œåœ¨ç»“å°¾æ·»åŠ  <code>#</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("He said, \"You can find the file at c:\\files\\my_documents\\file.txt.\" Then I found the file."); // We used \ five times here
    println!(r#"He said, "You can find the file at c:\files\my_documents\file.txt." Then I found the file."#)
}</code></pre></pre>
<p>è¿™æ‰“å°çš„æ˜¯åŒæ ·çš„ä¸œè¥¿ï¼Œä½†ä½¿ç”¨ <code>r#</code> ä½¿äººç±»æ›´å®¹æ˜“é˜…è¯»ã€‚</p>
<pre><code class="language-text">He said, "You can find the file at c:\files\my_documents\file.txt." Then I found the file.
He said, "You can find the file at c:\files\my_documents\file.txt." Then I found the file.
</code></pre>
<p>å¦‚æœä½ éœ€è¦åœ¨é‡Œé¢æ‰“å°<code>#</code>ï¼Œé‚£ä¹ˆä½ å¯ä»¥ç”¨<code>r##</code>å¼€å¤´ï¼Œç”¨<code>##</code>ç»“å°¾ã€‚å¦‚æœä½ éœ€è¦æ‰“å°å¤šä¸ªè¿ç»­çš„<code>#</code>ï¼Œå¯ä»¥åœ¨æ¯è¾¹å¤šåŠ ä¸€ä¸ª#ã€‚</p>
<p>ä¸‹é¢æ˜¯å››ä¸ªä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let my_string = "'Ice to see you,' he said."; // single quotes
    let quote_string = r#""Ice to see you," he said."#; // double quotes
    let hashtag_string = r##"The hashtag #IceToSeeYou had become very popular."##; // Has one # so we need at least ##
    let many_hashtags = r####""You don't have to type ### to use a hashtag. You can just use #.""####; // Has three ### so we need at least ####

    println!("{}\n{}\n{}\n{}\n", my_string, quote_string, hashtag_string, many_hashtags);

}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">'Ice to see you,' he said.
"Ice to see you," he said.
The hashtag #IceToSeeYou had become very popular.
"You don't have to type ### to use a hashtag. You can just use #."
</code></pre>
<p><code>r#</code>è¿˜æœ‰å¦ä¸€ä¸ªç”¨é€”:ä½¿ç”¨å®ƒï¼Œä½ å¯ä»¥ä½¿ç”¨å…³é”®å­—(å¦‚<code>let</code>ã€<code>fn</code>ç­‰)ä½œä¸ºå˜é‡åã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r#let = 6; // The variable's name is let
    let mut r#mut = 10; // This variable's name is mut
}</code></pre></pre>
<p><code>r#</code>ä¹‹æ‰€ä»¥æœ‰è¿™ä¸ªåŠŸèƒ½ï¼Œæ˜¯å› ä¸ºæ—§ç‰ˆæœ¬çš„Rustçš„å…³é”®å­—æ¯”ç°åœ¨çš„Rustå°‘ã€‚æ‰€ä»¥æœ‰äº†<code>r#</code>å°±å¯ä»¥é¿å…ä»¥å‰ä¸æ˜¯å…³é”®å­—çš„å˜é‡åçš„é”™è¯¯ã€‚</p>
<p>åˆæˆ–è€…å› ä¸ºæŸäº›åŸå› ï¼Œä½ <em>ç¡®å®</em>éœ€è¦ä¸€ä¸ªå‡½æ•°çš„åå­—ï¼Œæ¯”å¦‚<code>return</code>ã€‚é‚£ä¹ˆä½ å¯ä»¥è¿™æ ·å†™:</p>
<pre><pre class="playground"><code class="language-rust">fn r#return() -&gt; u8 {
    println!("Here is your number.");
    8
}

fn main() {
    let my_number = r#return();
    println!("{}", my_number);
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºæ¥çš„ç»“æœæ˜¯:</p>
<pre><code class="language-text">Here is your number.
8
</code></pre>
<p>æ‰€ä»¥ä½ å¯èƒ½ä¸éœ€è¦å®ƒï¼Œä½†æ˜¯å¦‚æœä½ çœŸçš„éœ€è¦ä¸ºä¸€ä¸ªå˜é‡ä½¿ç”¨ä¸€ä¸ªå…³é”®å­—ï¼Œé‚£ä¹ˆä½ å¯ä»¥ä½¿ç”¨<code>r#</code>ã€‚</p>
<p>å¦‚æœä½ æƒ³æ‰“å°<code>&amp;str</code>æˆ–<code>char</code>çš„å­—èŠ‚ï¼Œä½ å¯ä»¥åœ¨å­—ç¬¦ä¸²å‰å†™ä¸Š<code>b</code>å°±å¯ä»¥äº†ã€‚è¿™é€‚ç”¨äºæ‰€æœ‰ASCIIå­—ç¬¦ã€‚è¿™äº›æ˜¯æ‰€æœ‰çš„ASCIIå­—ç¬¦ã€‚</p>
<pre><code class="language-text">â˜ºâ˜»â™¥â™¦â™£â™ â™«â˜¼â–ºâ—„â†•â€¼Â¶Â§â–¬â†¨â†‘â†“â†’âˆŸâ†”â–²â–¼123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code></pre>
<p>æ‰€ä»¥ï¼Œå½“ä½ æ‰“å°è¿™ä¸ª</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{:?}", b"This will look like numbers");
}</code></pre></pre>
<p>è¿™å°±æ˜¯ç»“æœ:</p>
<pre><code class="language-text">[84, 104, 105, 115, 32, 119, 105, 108, 108, 32, 108, 111, 111, 107, 32, 108, 105, 107, 101, 32, 110, 117, 109, 98, 101, 114, 115]
</code></pre>
<p>å¯¹äº<code>char</code>æ¥è¯´ï¼Œè¿™å«åšä¸€ä¸ª<em>å­—èŠ‚</em>ï¼Œå¯¹äº<code>&amp;str</code>æ¥è¯´ï¼Œè¿™å«åšä¸€ä¸ª<em>å­—èŠ‚å­—ç¬¦ä¸²</em>ã€‚</p>
<p>å¦‚æœä½ éœ€è¦çš„è¯ï¼Œä¹Ÿå¯ä»¥æŠŠ<code>b</code>å’Œ<code>r</code>æ”¾åœ¨ä¸€èµ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{:?}", br##"I like to write "#"."##);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>[73, 32, 108, 105, 107, 101, 32, 116, 111, 32, 119, 114, 105, 116, 101, 32, 34, 35, 34, 46]</code>ã€‚</p>
<p>è¿˜æœ‰ä¸€ä¸ªUnicodeè½¬ä¹‰ï¼Œå¯ä»¥è®©ä½ åœ¨å­—ç¬¦ä¸²ä¸­æ‰“å°ä»»ä½•Unicodeå­—ç¬¦: <code>\u{}</code>ã€‚<code>{}</code>é‡Œé¢æœ‰ä¸€ä¸ªåå…­è¿›åˆ¶æ•°å­—å¯ä»¥æ‰“å°ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€çŸ­çš„ä¾‹å­ï¼Œè¯´æ˜å¦‚ä½•è·å¾—Unicodeæ•°å­—ï¼Œä»¥åŠå¦‚ä½•å†æ¬¡æ‰“å°å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{:X}", 'í–‰' as u32); // Cast char as u32 to get the hexadecimal value
    println!("{:X}", 'H' as u32);
    println!("{:X}", 'å±…' as u32);
    println!("{:X}", 'ã„' as u32);

    println!("\u{D589}, \u{48}, \u{5C45}, \u{3044}"); // Try printing them with unicode escape \u
}</code></pre></pre>
<p>æˆ‘ä»¬çŸ¥é“ï¼Œ<code>println!</code>å¯ä»¥å’Œ<code>{}</code>(ç”¨äºæ˜¾ç¤º)æˆ–<code>{:?}</code>(ç”¨äºè°ƒè¯•)ä¸€èµ·æ‰“å°ï¼Œå†åŠ ä¸Š<code>{:#?}</code>å°±å¯ä»¥è¿›è¡Œæ¼‚äº®çš„æ‰“å°ã€‚ä½†æ˜¯è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æ‰“å°æ–¹å¼ã€‚</p>
<p>ä¾‹å¦‚ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªå¼•ç”¨ï¼Œä½ å¯ä»¥ç”¨<code>{:p}</code>æ¥æ‰“å°<em>æŒ‡é’ˆåœ°å€</em>ã€‚æŒ‡é’ˆåœ°å€æŒ‡çš„æ˜¯ç”µè„‘å†…å­˜ä¸­çš„ä½ç½®ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 9;
    let number_ref = &amp;number;
    println!("{:p}", number_ref);
}</code></pre></pre>
<p>è¿™å¯ä»¥æ‰“å°<code>0xe2bc0ffcfc</code>æˆ–å…¶ä»–åœ°å€ã€‚æ¯æ¬¡å¯èƒ½éƒ½ä¸ä¸€æ ·ï¼Œè¿™å–å†³äºä½ çš„è®¡ç®—æœºå­˜å‚¨çš„ä½ç½®ã€‚</p>
<p>æˆ–è€…ä½ å¯ä»¥æ‰“å°äºŒè¿›åˆ¶ã€åå…­è¿›åˆ¶å’Œå…«è¿›åˆ¶ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 555;
    println!("Binary: {:b}, hexadecimal: {:x}, octal: {:o}", number, number, number);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º<code>Binary: 1000101011, hexadecimal: 22b, octal: 1053</code>ã€‚</p>
<p>æˆ–è€…ä½ å¯ä»¥æ·»åŠ æ•°å­—æ¥æ”¹å˜é¡ºåºã€‚ç¬¬ä¸€ä¸ªå˜é‡å°†åœ¨ç´¢å¼•0ä¸­ï¼Œä¸‹ä¸€ä¸ªåœ¨ç´¢å¼•1ä¸­ï¼Œä»¥æ­¤ç±»æ¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let father_name = "Vlad";
    let son_name = "Adrian Fahrenheit";
    let family_name = "ÈšepeÈ™";
    println!("This is {1} {2}, son of {0} {2}.", father_name, son_name, family_name);
}</code></pre></pre>
<p><code>father_name</code>åœ¨0ä½ï¼Œ<code>son_name</code>åœ¨1ä½ï¼Œ<code>family_name</code>åœ¨2ä½ã€‚æ‰€ä»¥å®ƒæ‰“å°çš„æ˜¯<code>This is Adrian Fahrenheit ÈšepeÈ™, son of Vlad ÈšepeÈ™</code>ã€‚</p>
<p>ä¹Ÿè®¸ä½ æœ‰ä¸€ä¸ªéå¸¸å¤æ‚çš„å­—ç¬¦ä¸²è¦æ‰“å°ï¼Œ<code>{}</code>å¤§æ‹¬å·å†…æœ‰å¤ªå¤šçš„å˜é‡ã€‚æˆ–è€…ä½ éœ€è¦ä¸æ­¢ä¸€æ¬¡çš„æ‰“å°ä¸€ä¸ªå˜é‡ã€‚é‚£ä¹ˆåœ¨<code>{}</code>ä¸­æ·»åŠ åç§°å°±ä¼šæœ‰å¸®åŠ©ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(
        "{city1} is in {country} and {city2} is also in {country},
but {city3} is not in {country}.",
        city1 = "Seoul",
        city2 = "Busan",
        city3 = "Tokyo",
        country = "Korea"
    );
}</code></pre></pre>
<p>è¿™æ ·å°±å¯ä»¥æ‰“å°äº†ã€‚</p>
<pre><code class="language-text">Seoul is in Korea and Busan is also in Korea,
but Tokyo is not in Korea.
</code></pre>
<p>å¦‚æœä½ æ„¿æ„ï¼Œä¹Ÿå¯ä»¥åœ¨Rustä¸­è¿›è¡Œéå¸¸å¤æ‚çš„æ‰“å°ã€‚ä¸‹é¢å±•ç¤ºæ€æ ·åšï¼š</p>
<p>{variable:padding alignment minimum.maximum}</p>
<p>è¦ç†è§£è¿™ä¸€ç‚¹ï¼Œè¯·çœ‹</p>
<ol>
<li>ä½ æƒ³è¦ä¸€ä¸ªå˜é‡åå—ï¼Ÿå…ˆå†™å‡ºæ¥ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢å†™{country}ä¸€æ ·ã€‚
(å¦‚æœä½ æƒ³åšæ›´å¤šçš„äº‹æƒ…ï¼Œå°±åœ¨åé¢åŠ ä¸€ä¸ª<code>:</code>)</li>
<li>ä½ æƒ³è¦ä¸€ä¸ªå¡«å……å­—ç¬¦å—ï¼Ÿä¾‹å¦‚ï¼Œ55åŠ ä¸Šä¸‰ä¸ª "å¡«å……é›¶"å°±åƒ00055ã€‚</li>
<li>paddingçš„å¯¹é½æ–¹å¼(å·¦/ä¸­/å³)ï¼Ÿ</li>
<li>ä½ æƒ³è¦ä¸€ä¸ªæœ€å°é•¿åº¦å—ï¼Ÿ(å†™ä¸€ä¸ªæ•°å­—å°±å¯ä»¥äº†)</li>
<li>ä½ æƒ³è¦ä¸€ä¸ªæœ€å¤§é•¿åº¦å—ï¼Ÿ(å†™ä¸€ä¸ªæ•°å­—ï¼Œå‰é¢æœ‰ä¸€ä¸ª<code>.</code>)</li>
</ol>
<p>ä¾‹å¦‚ï¼Œæˆ‘æƒ³å†™ "a"ï¼Œå·¦è¾¹æœ‰äº”ä¸ªã…ï¼Œå³è¾¹æœ‰äº”ä¸ªã…ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let letter = "a";
    println!("{:ã…^11}", letter);
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºæ¥çš„ç»“æœæ˜¯<code>ã…ã…ã…ã…ã…aã…ã…ã…ã…ã…</code>ã€‚æˆ‘ä»¬çœ‹çœ‹1)åˆ°5)çš„è¿™ä¸ªæƒ…å†µï¼Œå°±èƒ½æ˜ç™½ç¼–è¯‘å™¨æ˜¯æ€ä¹ˆè§£è¯»çš„ï¼š</p>
<ul>
<li>ä½ è¦ä¸è¦å˜é‡åï¼Ÿ<code>{:ã…^11}</code>æ²¡æœ‰å˜é‡åã€‚<code>:</code>ä¹‹å‰æ²¡æœ‰ä»»ä½•å†…å®¹ã€‚</li>
<li>ä½ éœ€è¦ä¸€ä¸ªå¡«å……å­—ç¬¦å—ï¼Ÿ<code>{:ã…^11}</code> æ˜¯çš„:ã…"åœ¨<code>:</code>åé¢ï¼Œæœ‰ä¸€ä¸ª<code>^</code>ã€‚<code>&lt;</code>è¡¨ç¤ºå˜é‡åœ¨å¡«å……å­—ç¬¦å·¦è¾¹ï¼Œ<code>&gt;</code>è¡¨ç¤ºåœ¨å¡«å……å­—ç¬¦å³è¾¹ï¼Œ<code>^</code>è¡¨ç¤ºåœ¨å¡«å……å­—ç¬¦ä¸­é—´ã€‚</li>
<li>è¦ä¸è¦è®¾ç½®æœ€å°é•¿åº¦ï¼Ÿ<code>{:ã…^11}</code>æ˜¯:åé¢æœ‰ä¸€ä¸ª11ã€‚</li>
<li>ä½ æƒ³è¦ä¸€ä¸ªæœ€å¤§é•¿åº¦å—ï¼Ÿ<code>{:ã…^11}</code> ä¸æ˜¯:å‰é¢æ²¡æœ‰<code>.</code>çš„æ•°å­—ã€‚</li>
</ul>
<p>ä¸‹é¢æ˜¯å¤šç§ç±»å‹çš„æ ¼å¼åŒ–çš„ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let title = "TODAY'S NEWS";
    println!("{:-^30}", title); // no variable name, pad with -, put in centre, 30 characters long
    let bar = "|";
    println!("{: &lt;15}{: &gt;15}", bar, bar); // no variable name, pad with space, 15 characters each, one to the left, one to the right
    let a = "SEOUL";
    let b = "TOKYO";
    println!("{city1:-&lt;15}{city2:-&gt;15}", city1 = a, city2 = b); // variable names city1 and city2, pad with -, one to the left, one to the right
}</code></pre></pre>
<p>å®ƒæ‰“å°å‡ºæ¥äº†ã€‚</p>
<pre><code class="language-text">---------TODAY'S NEWS---------
|                            |
SEOUL--------------------TOKYO
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å­—ç¬¦ä¸²"><a class="header" href="#å­—ç¬¦ä¸²">å­—ç¬¦ä¸²</a></h2>
<p>Rustæœ‰ä¸¤ç§ä¸»è¦ç±»å‹çš„å­—ç¬¦ä¸²ã€‚<code>String</code>å’Œ<code>&amp;str</code>. æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ</p>
<ul>
<li><code>&amp;str</code>æ˜¯ä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²ã€‚å½“ä½ å†™<code>let my_variable = "Hello, world!"</code>æ—¶ï¼Œä½ ä¼šåˆ›å»ºä¸€ä¸ª<code>&amp;str</code>ã€‚<code>&amp;str</code>æ˜¯éå¸¸å¿«çš„ã€‚</li>
<li><code>String</code>æ˜¯ä¸€ä¸ªæ›´å¤æ‚çš„å­—ç¬¦ä¸²ã€‚å®ƒæ¯”è¾ƒæ…¢ï¼Œä½†å®ƒæœ‰æ›´å¤šçš„åŠŸèƒ½ã€‚<code>String</code>æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæ•°æ®åœ¨å †ä¸Šã€‚</li>
</ul>
<p>å¦å¤–æ³¨æ„ï¼Œ<code>&amp;str</code>å‰é¢æœ‰<code>&amp;</code>ï¼Œå› ä¸ºä½ éœ€è¦ä¸€ä¸ªå¼•ç”¨æ¥ä½¿ç”¨<code>str</code>ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„åŸå› :å †éœ€è¦çŸ¥é“å¤§å°ã€‚æ‰€ä»¥æˆ‘ä»¬ç»™å®ƒä¸€ä¸ª<code>&amp;</code>ï¼Œå®ƒçŸ¥é“å¤§å°ï¼Œç„¶åå®ƒå°±é«˜å…´äº†ã€‚å¦å¤–ï¼Œå› ä¸ºä½ ç”¨ä¸€ä¸ª<code>&amp;</code>ä¸ä¸€ä¸ª<code>str</code>äº¤äº’ï¼Œä½ å¹¶ä¸æ‹¥æœ‰å®ƒã€‚ä½†æ˜¯ä¸€ä¸ª<code>String</code>æ˜¯ä¸€ä¸ª<em>æ‹¥æœ‰</em>çš„ç±»å‹ã€‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçŸ¥é“ä¸ºä»€ä¹ˆè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚</p>
<p><code>&amp;str</code>å’Œ<code>String</code>éƒ½æ˜¯UTF-8ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å†™</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name = "ì„œíƒœì§€"; // This is a Korean name. No problem, because a &amp;str is UTF-8.
    let other_name = String::from("Adrian Fahrenheit ÈšepeÈ™"); // Èš and È™ are no problem in UTF-8.
}</code></pre></pre>
<p>ä½ å¯ä»¥åœ¨<code>String::from("Adrian Fahrenheit ÈšepeÈ™")</code>ä¸­çœ‹åˆ°ï¼Œå¾ˆå®¹æ˜“ä»<code>&amp;str</code>ä¸­åˆ›å»ºä¸€ä¸ª<code>String</code>ã€‚è¿™ä¸¤ç§ç±»å‹è™½ç„¶ä¸åŒï¼Œä½†è”ç³»éå¸¸ç´§å¯†ã€‚</p>
<p>ä½ ç”šè‡³å¯ä»¥å†™è¡¨æƒ…ç¬¦å·ï¼Œè¿™è¦æ„Ÿè°¢UTF-8ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name = "ğŸ˜‚";
    println!("My name is actually {}", name);
}</code></pre></pre>
<p>åœ¨ä½ çš„ç”µè„‘ä¸Šï¼Œä¼šæ‰“å°<code>My name is actually ğŸ˜‚</code>ï¼Œé™¤éä½ çš„å‘½ä»¤è¡Œä¸èƒ½æ‰“å°ã€‚é‚£ä¹ˆå®ƒä¼šæ˜¾ç¤º<code>My name is actually ï¿½</code>ã€‚ä½†Rustå¯¹emojisæˆ–å…¶ä»–Unicodeæ²¡æœ‰é—®é¢˜ã€‚</p>
<p>æˆ‘ä»¬å†æ¥çœ‹çœ‹<code>str</code>ä½¿ç”¨<code>&amp;</code>çš„åŸå› ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬ç†è§£ã€‚</p>
<ul>
<li><code>str</code>æ˜¯ä¸€ä¸ªåŠ¨æ€å¤§å°çš„ç±»å‹(åŠ¨æ€å¤§å°=å¤§å°å¯ä»¥ä¸åŒ)ã€‚æ¯”å¦‚ "ì„œíƒœì§€"å’Œ "Adrian Fahrenheit ÈšepeÈ™"è¿™ä¸¤ä¸ªåå­—çš„å¤§å°æ˜¯ä¸ä¸€æ ·çš„ã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {

    println!("A String is always {:?} bytes. It is Sized.", std::mem::size_of::&lt;String&gt;()); // std::mem::size_of::&lt;Type&gt;() gives you the size in bytes of a type
    println!("And an i8 is always {:?} bytes. It is Sized.", std::mem::size_of::&lt;i8&gt;());
    println!("And an f64 is always {:?} bytes. It is Sized.", std::mem::size_of::&lt;f64&gt;());
    println!("But a &amp;str? It can be anything. 'ì„œíƒœì§€' is {:?} bytes. It is not Sized.", std::mem::size_of_val("ì„œíƒœì§€")); // std::mem::size_of_val() gives you the size in bytes of a variable
    println!("And 'Adrian Fahrenheit ÈšepeÈ™' is {:?} bytes. It is not Sized.", std::mem::size_of_val("Adrian Fahrenheit ÈšepeÈ™"));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">A String is always 24 bytes. It is Sized.
And an i8 is always 1 bytes. It is Sized.
And an f64 is always 8 bytes. It is Sized.
But a &amp;str? It can be anything. 'ì„œíƒœì§€' is 9 bytes. It is not Sized.
And 'Adrian Fahrenheit ÈšepeÈ™' is 25 bytes. It is not Sized.
</code></pre>
<p>è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ª &amp;ï¼Œå› ä¸º <code>&amp;</code> æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œ Rust çŸ¥é“æŒ‡é’ˆçš„å¤§å°ã€‚æ‰€ä»¥æŒ‡é’ˆä¼šæ”¾åœ¨æ ˆä¸­ã€‚å¦‚æœæˆ‘ä»¬å†™<code>str</code>ï¼ŒRustå°±ä¸çŸ¥é“è¯¥æ€ä¹ˆåšäº†ï¼Œå› ä¸ºå®ƒä¸çŸ¥é“æŒ‡é’ˆçš„å¤§å°ã€‚</p>
<p>æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥åˆ›å»º<code>String</code>ã€‚ä¸‹é¢æ˜¯ä¸€äº›ã€‚</p>
<ul>
<li><code>String::from("This is the string text");</code> è¿™æ˜¯Stringçš„ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒæ¥å—æ–‡æœ¬å¹¶åˆ›å»ºä¸€ä¸ªString.</li>
<li><code>"This is the string text".to_string()</code>. è¿™æ˜¯&amp;strçš„ä¸€ä¸ªæ–¹æ³•ï¼Œä½¿å…¶æˆä¸ºä¸€ä¸ªStringã€‚</li>
<li><code>format!</code> å®ã€‚
è¿™å’Œ<code>println!</code>ä¸€æ ·ï¼Œåªæ˜¯å®ƒåˆ›å»ºäº†ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯æ‰“å°ã€‚æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·åš:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = "Billybrobby";
    let my_country = "USA";
    let my_home = "Korea";

    let together = format!(
        "I am {} and I come from {} but I live in {}.",
        my_name, my_country, my_home
    );
}</code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªä¸€èµ·å‘½åçš„å­—ç¬¦ä¸²ï¼Œä½†è¿˜æ²¡æœ‰æ‰“å°å‡ºæ¥ã€‚</p>
<p>è¿˜æœ‰ä¸€ç§åˆ›å»ºStringçš„æ–¹æ³•å«åš<code>.into()</code>ï¼Œä½†å®ƒæœ‰ç‚¹ä¸åŒï¼Œå› ä¸º<code>.into()</code>å¹¶ä¸åªæ˜¯ç”¨æ¥åˆ›å»º<code>String</code>ã€‚æœ‰äº›ç±»å‹å¯ä»¥å¾ˆå®¹æ˜“åœ°ä½¿ç”¨<code>From</code>å’Œ<code>.into()</code>è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ï¼Œå¹¶ä»å¦ä¸€ç§ç±»å‹è½¬æ¢å‡ºæ¥ã€‚è€Œå¦‚æœä½ æœ‰<code>From</code>ï¼Œé‚£ä¹ˆä½ ä¹Ÿæœ‰<code>.into()</code>ã€‚<code>From</code> æ›´åŠ æ¸…æ™°ï¼Œå› ä¸ºä½ å·²ç»çŸ¥é“äº†ç±»å‹:ä½ çŸ¥é“ <code>String::from("Some str")</code> æ˜¯ä¸€ä¸ªæ¥è‡ª <code>&amp;str</code> çš„ <code>String</code>ã€‚ä½†æ˜¯å¯¹äº<code>.into()</code>ï¼Œæœ‰æ—¶å€™ç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = "Try to make this a String".into(); // âš ï¸
}</code></pre></pre>
<p>Rustä¸çŸ¥é“ä½ è¦çš„æ˜¯ä»€ä¹ˆç±»å‹ï¼Œå› ä¸ºå¾ˆå¤šç±»å‹éƒ½å¯ä»¥ä»ä¸€ä¸ª<code>&amp;str</code>åˆ›å»ºå‡ºæ¥ã€‚å®ƒè¯´:"æˆ‘å¯ä»¥æŠŠä¸€ä¸ª&amp;stråšæˆå¾ˆå¤šä¸œè¥¿ã€‚ä½ æƒ³è¦å“ªä¸€ç§ï¼Ÿ"</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src\main.rs:2:9
  |
2 |     let my_string = "Try to make this a String".into();
  |         ^^^^^^^^^ consider giving `my_string` a type
</code></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string: String = "Try to make this a String".into();
}</code></pre></pre>
<p>ç°åœ¨ä½ å¾—åˆ°äº†ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="constå’Œstatic"><a class="header" href="#constå’Œstatic">constå’Œstatic</a></h2>
<p>æœ‰ä¸¤ç§å£°æ˜å€¼çš„æ–¹æ³•ï¼Œä¸ä»…ä»…æ˜¯ç”¨<code>let</code>ã€‚å®ƒä»¬æ˜¯<code>const</code>å’Œ<code>static</code>ã€‚å¦å¤–ï¼ŒRustä¸ä¼šä½¿ç”¨ç±»å‹æ¨ç†ï¼šä½ éœ€è¦ä¸ºå®ƒä»¬ç¼–å†™ç±»å‹ã€‚è¿™äº›éƒ½æ˜¯ç”¨äºä¸æ”¹å˜çš„å€¼ï¼ˆ<code>const</code>æ„å‘³ç€å¸¸é‡ï¼‰ã€‚åŒºåˆ«åœ¨äº:</p>
<ul>
<li><code>const</code>æ˜¯ç”¨äºä¸æ”¹å˜çš„å€¼ï¼Œå½“ä½¿ç”¨å®ƒæ—¶ï¼Œåå­—ä¼šè¢«æ›¿æ¢æˆå€¼ã€‚</li>
<li><code>static</code>ä¸<code>const</code>ç±»ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªå›ºå®šçš„å†…å­˜ä½ç½®ï¼Œå¯ä»¥ä½œä¸ºä¸€ä¸ªå…¨å±€å˜é‡ä½¿ç”¨ã€‚</li>
</ul>
<p>æ‰€ä»¥å®ƒä»¬å‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚Rustç¨‹åºå‘˜å‡ ä¹æ€»æ˜¯ä½¿ç”¨<code>const</code>ã€‚</p>
<p>ä¸€èˆ¬ç”¨å…¨å¤§å†™å­—æ¯ä½œä¸ºåå­—ï¼Œè€Œä¸”é€šå¸¸åœ¨<code>main</code>ä¹‹å¤–ï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥åœ¨æ•´ä¸ªç¨‹åºä¸­ç”Ÿå­˜ã€‚</p>
<p>ä¸¤ä¸ªä¾‹å­æ˜¯ <code>const NUMBER_OF_MONTHS: u32 = 12;</code> å’Œ <code>static SEASONS: [&amp;str; 4] = ["Spring", "Summer", "Fall", "Winter"];</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å…³äºå¼•ç”¨çš„æ›´å¤šä¿¡æ¯"><a class="header" href="#å…³äºå¼•ç”¨çš„æ›´å¤šä¿¡æ¯">å…³äºå¼•ç”¨çš„æ›´å¤šä¿¡æ¯</a></h2>
<p>å¼•ç”¨åœ¨Rustä¸­éå¸¸é‡è¦ã€‚Rustä½¿ç”¨å¼•ç”¨æ¥ç¡®ä¿æ‰€æœ‰çš„å†…å­˜è®¿é—®æ˜¯å®‰å…¨çš„ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œæˆ‘ä»¬ä½¿ç”¨<code>&amp;</code>æ¥åˆ›å»ºä¸€ä¸ªå¼•ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from("Austria");
    let ref_one = &amp;country;
    let ref_two = &amp;country;

    println!("{}", ref_one);
}</code></pre></pre>
<p>è¿™æ ·å°±ä¼šæ‰“å°å‡º<code>Austria</code>ã€‚</p>
<p>åœ¨ä»£ç ä¸­ï¼Œ<code>country</code>æ˜¯ä¸€ä¸ª<code>String</code>ã€‚ç„¶åæˆ‘ä»¬åˆ›å»ºäº†ä¸¤ä¸ª<code>country</code>çš„å¼•ç”¨ã€‚å®ƒä»¬çš„ç±»å‹æ˜¯<code>&amp;String</code>ï¼Œä½ è¯´è¿™æ˜¯ä¸€ä¸ª "å­—ç¬¦ä¸²çš„å¼•ç”¨"ã€‚æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸‰ä¸ªå¼•ç”¨æˆ–è€…ä¸€ç™¾ä¸ªå¯¹ <code>country</code> çš„å¼•ç”¨ï¼Œè¿™éƒ½æ²¡æœ‰é—®é¢˜ã€‚</p>
<p>ä½†è¿™æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn return_str() -&gt; &amp;str {
    let country = String::from("Austria");
    let country_ref = &amp;country;
    country_ref // âš ï¸
}

fn main() {
    let country = return_str();
}</code></pre></pre>
<p><code>return_str()</code>å‡½æ•°åˆ›å»ºäº†ä¸€ä¸ªStringï¼Œç„¶åå®ƒåˆ›å»ºäº†ä¸€ä¸ªå¯¹Stringçš„å¼•ç”¨ã€‚ç„¶åå®ƒè¯•å›¾è¿”å›å¼•ç”¨ã€‚ä½†æ˜¯<code>country</code>è¿™ä¸ªStringåªæ´»åœ¨å‡½æ•°é‡Œé¢ï¼Œç„¶åå®ƒå°±æ­»äº†ã€‚ä¸€æ—¦ä¸€ä¸ªå˜é‡æ¶ˆå¤±äº†ï¼Œè®¡ç®—æœºå°±ä¼šæ¸…ç†å†…å­˜ï¼Œå¹¶å°†å…¶ç”¨äºå…¶ä»–ç”¨é€”ã€‚æ‰€ä»¥åœ¨å‡½æ•°ç»“æŸåï¼Œ<code>country_ref</code>å¼•ç”¨çš„æ˜¯å·²ç»æ¶ˆå¤±çš„å†…å­˜ï¼Œè¿™æ˜¯ä¸å¯¹çš„ã€‚Rusté˜²æ­¢æˆ‘ä»¬åœ¨è¿™é‡ŒçŠ¯å†…å­˜çš„é”™è¯¯ã€‚</p>
<p>è¿™å°±æ˜¯æˆ‘ä»¬ä¸Šé¢è®²åˆ°çš„ "æ‹¥æœ‰"ç±»å‹çš„é‡è¦éƒ¨åˆ†ã€‚å› ä¸ºä½ æ‹¥æœ‰ä¸€ä¸ª<code>String</code>ï¼Œä½ å¯ä»¥æŠŠå®ƒä¼ ç»™åˆ«äººã€‚ä½†æ˜¯å¦‚æœ <code>&amp;String</code> çš„ <code>String</code> æ­»äº†ï¼Œé‚£ä¹ˆ <code>&amp;String</code> å°±ä¼šæ­»æ‰ï¼Œæ‰€ä»¥ä½ ä¸èƒ½æŠŠå®ƒçš„ "æ‰€æœ‰æƒ"ä¼ ç»™åˆ«äººã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¯å˜å¼•ç”¨"><a class="header" href="#å¯å˜å¼•ç”¨">å¯å˜å¼•ç”¨</a></h2>
<p>å¦‚æœæ‚¨æƒ³ä½¿ç”¨ä¸€ä¸ªå¼•ç”¨æ¥æ”¹å˜æ•°æ®ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚å¯¹äºå¯å˜å¼•ç”¨ï¼Œæ‚¨å¯ä»¥å†™ <code>&amp;mut</code> è€Œä¸æ˜¯ <code>&amp;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 8; // don't forget to write mut here!
    let num_ref = &amp;mut my_number;
}</code></pre></pre>
<p>é‚£ä¹ˆè¿™ä¸¤ç§ç±»å‹æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ<code>my_number</code>æ˜¯<code>i32</code>ï¼Œ<code>num_ref</code>æ˜¯<code>&amp;mut i32</code>(æˆ‘ä»¬è¯´æ˜¯ "å¯å˜å¼•ç”¨<code>i32</code>")ã€‚</p>
<p>æ‰€ä»¥æˆ‘ä»¬ç”¨å®ƒæ¥ç»™my_numberåŠ 10ã€‚ä½†æ˜¯ä½ ä¸èƒ½å†™<code>num_ref += 10</code>ï¼Œå› ä¸º<code>num_ref</code>ä¸æ˜¯<code>i32</code>çš„å€¼ï¼Œå®ƒæ˜¯ä¸€ä¸ª<code>&amp;i32</code>ã€‚å…¶å®è¿™ä¸ªå€¼å°±åœ¨<code>i32</code>é‡Œé¢ã€‚ä¸ºäº†è¾¾åˆ°å€¼æ‰€åœ¨çš„åœ°æ–¹ï¼Œæˆ‘ä»¬ç”¨<code>*</code>ã€‚<code>*</code>çš„æ„æ€æ˜¯ "æˆ‘ä¸è¦å¼•ç”¨ï¼Œæˆ‘è¦å¼•ç”¨å¯¹åº”çš„å€¼"ã€‚æ¢å¥è¯è¯´ï¼Œä¸€ä¸ª<code>*</code>ä¸<code>&amp;</code>æ˜¯ç›¸åçš„ã€‚å¦å¤–ï¼Œä¸€ä¸ª<code>*</code>æŠ¹å»äº†ä¸€ä¸ª<code>&amp;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 8;
    let num_ref = &amp;mut my_number;
    *num_ref += 10; // Use * to change the i32 value.
    println!("{}", my_number);

    let second_number = 800;
    let triple_reference = &amp;&amp;&amp;second_number;
    println!("Second_number = triple_reference? {}", second_number == ***triple_reference);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">18
Second_number = triple_reference? true
</code></pre>
<p>å› ä¸ºä½¿ç”¨<code>&amp;</code>å«åš "å¼•ç”¨"ï¼Œæ‰€ä»¥ä½¿ç”¨<code>*</code>å«åš "<strong>de</strong>referencing"ã€‚</p>
<p>Rustæœ‰ä¸¤ä¸ªè§„åˆ™ï¼Œåˆ†åˆ«æ˜¯å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ã€‚å®ƒä»¬éå¸¸é‡è¦ï¼Œä½†ä¹Ÿå¾ˆå®¹æ˜“è®°ä½ï¼Œå› ä¸ºå®ƒä»¬å¾ˆæœ‰æ„ä¹‰ã€‚</p>
<ul>
<li><strong>è§„åˆ™1</strong>ã€‚å¦‚æœä½ åªæœ‰ä¸å¯å˜å¼•ç”¨ï¼Œä½ å¯ä»¥æœ‰ä»»æ„å¤šçš„å¼•ç”¨ã€‚1ä¸ªä¹Ÿè¡Œï¼Œ3ä¸ªä¹Ÿè¡Œï¼Œ1000ä¸ªä¹Ÿè¡Œï¼Œæ²¡é—®é¢˜ã€‚</li>
<li><strong>è§„åˆ™2</strong>: å¦‚æœä½ æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œä½ åªèƒ½æœ‰ä¸€ä¸ªã€‚å¦å¤–ï¼Œä½ ä¸èƒ½åŒæ—¶ä½¿ç”¨ä¸€ä¸ªä¸å¯å˜å¼•ç”¨<strong>å’Œ</strong>ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚</li>
</ul>
<p>è¿™æ˜¯å› ä¸ºå¯å˜å¼•ç”¨å¯ä»¥æ”¹å˜æ•°æ®ã€‚å¦‚æœä½ åœ¨å…¶ä»–å¼•ç”¨è¯»å–æ•°æ®æ—¶æ”¹å˜æ•°æ®ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°é—®é¢˜ã€‚</p>
<p>ä¸€ä¸ªå¾ˆå¥½çš„ç†è§£æ–¹å¼æ˜¯æ€è€ƒä¸€ä¸ªPowerpointæ¼”ç¤ºã€‚</p>
<p>æƒ…å†µä¸€æ˜¯å…³äº<strong>åªæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨</strong></p>
<p>æƒ…å¢ƒä¸€ ä¸€ä¸ªå‘˜å·¥æ­£åœ¨ç¼–å†™ä¸€ä¸ªPowerpointæ¼”ç¤ºæ–‡ç¨¿ï¼Œä»–å¸Œæœ›ä»–çš„ç»ç†èƒ½å¸®åŠ©ä»–ã€‚ä»–å¸Œæœ›ä»–çš„ç»ç†èƒ½å¸®åŠ©ä»–ã€‚è¯¥å‘˜å·¥å°†è‡ªå·±çš„ç™»å½•ä¿¡æ¯æä¾›ç»™ç»ç†ï¼Œå¹¶è¯·ä»–å¸®å¿™è¿›è¡Œç¼–è¾‘ã€‚ç°åœ¨ï¼Œç»ç†å¯¹è¯¥å‘˜å·¥çš„æ¼”ç¤ºæ–‡ç¨¿æœ‰äº†ä¸€ä¸ª "å¯å˜å¼•ç”¨"ã€‚ç»ç†å¯ä»¥åšä»»ä½•ä»–æƒ³åšçš„ä¿®æ”¹ï¼Œç„¶åæŠŠç”µè„‘è¿˜ç»™ä»–ã€‚è¿™å¾ˆå¥½ï¼Œå› ä¸ºæ²¡æœ‰äººåœ¨çœ‹è¿™ä¸ªæ¼”ç¤ºæ–‡ç¨¿ã€‚</p>
<p>æƒ…å†µäºŒæ˜¯å…³äº<strong>åªæœ‰ä¸å¯å˜å¼•ç”¨</strong></p>
<p>æƒ…å†µäºŒ è¯¥å‘˜å·¥è¦ç»™100ä¸ªäººåšæ¼”ç¤ºã€‚ç°åœ¨è¿™100ä¸ªäººéƒ½å¯ä»¥çœ‹åˆ°è¯¥å‘˜å·¥çš„æ•°æ®ã€‚
ä»–ä»¬éƒ½æœ‰ä¸€ä¸ª "ä¸å¯æ”¹å˜çš„å¼•ç”¨"ï¼Œå³å‘˜å·¥çš„ä»‹ç»ã€‚è¿™å¾ˆå¥½ï¼Œå› ä¸ºä»–ä»¬å¯ä»¥çœ‹åˆ°å®ƒï¼Œä½†æ²¡æœ‰äººå¯ä»¥æ”¹å˜æ•°æ®ã€‚</p>
<p>æƒ…å†µä¸‰æ˜¯<strong>æœ‰é—®é¢˜çš„æƒ…å†µ</strong></p>
<p>æƒ…å†µä¸‰ å‘˜å·¥æŠŠä»–çš„ç™»å½•ä¿¡æ¯ç»™äº†ç»ç† ä»–çš„ç»ç†ç°åœ¨æœ‰äº†ä¸€ä¸ª "å¯å˜å¼•ç”¨"ã€‚ç„¶åå‘˜å·¥å»ç»™100ä¸ªäººåšæ¼”ç¤ºï¼Œä½†æ˜¯ç»ç†è¿˜æ˜¯å¯ä»¥ç™»å½•ã€‚è¿™æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºç»ç†å¯ä»¥ç™»å½•ï¼Œå¯ä»¥åšä»»ä½•äº‹æƒ…ã€‚ä¹Ÿè®¸ä»–çš„ç»ç†ä¼šç™»å½•ç”µè„‘ï¼Œç„¶åå¼€å§‹ç»™ä»–çš„æ¯äº²æ‰“ä¸€å°é‚®ä»¶! ç°åœ¨è¿™100äººä¸å¾—ä¸çœ‹ç€ç»ç†ç»™ä»–æ¯äº²å†™é‚®ä»¶ï¼Œè€Œä¸æ˜¯æ¼”ç¤ºã€‚è¿™ä¸æ˜¯ä»–ä»¬æœŸæœ›çœ‹åˆ°çš„ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªå¯å˜å€Ÿç”¨ä¸ä¸å¯å˜å€Ÿç”¨çš„ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 10;
    let number_ref = &amp;number;
    let number_change = &amp;mut number;
    *number_change += 10;
    println!("{}", number_ref); // âš ï¸
}</code></pre></pre>
<p>ç¼–è¯‘å™¨æ‰“å°äº†ä¸€ä¸ªæœ‰ç”¨çš„ä¿¡æ¯æ¥å‘Šè¯‰æˆ‘ä»¬é—®é¢˜æ‰€åœ¨ã€‚</p>
<pre><code class="language-text">error[E0502]: cannot borrow `number` as mutable because it is also borrowed as immutable
 --&gt; src\main.rs:4:25
  |
3 |     let number_ref = &amp;number;
  |                      ------- immutable borrow occurs here
4 |     let number_change = &amp;mut number;
  |                         ^^^^^^^^^^^ mutable borrow occurs here
5 |     *number_change += 10;
6 |     println!("{}", number_ref);
  |                    ---------- immutable borrow later used here
</code></pre>
<p>ç„¶è€Œï¼Œè¿™æ®µä»£ç å¯ä»¥å·¥ä½œã€‚ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿ</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 10;
    let number_change = &amp;mut number; // create a mutable reference
    *number_change += 10; // use mutable reference to add 10
    let number_ref = &amp;number; // create an immutable reference
    println!("{}", number_ref); // print the immutable reference
}</code></pre></pre>
<p>å®ƒæ‰“å°å‡º<code>20</code>æ²¡æœ‰é—®é¢˜ã€‚å®ƒèƒ½å·¥ä½œæ˜¯å› ä¸ºç¼–è¯‘å™¨è¶³å¤Ÿèªæ˜ï¼Œèƒ½å¤Ÿç†è§£æˆ‘ä»¬çš„ä»£ç ã€‚å®ƒçŸ¥é“æˆ‘ä»¬ä½¿ç”¨äº†<code>number_change</code>æ¥æ”¹å˜<code>number</code>ï¼Œä½†æ²¡æœ‰å†ä½¿ç”¨å®ƒã€‚æ‰€ä»¥è¿™é‡Œæ²¡æœ‰é—®é¢˜ã€‚æˆ‘ä»¬å¹¶æ²¡æœ‰å°†ä¸å¯å˜å’Œå¯å˜å¼•ç”¨ä¸€èµ·ä½¿ç”¨ã€‚</p>
<p>æ—©æœŸåœ¨Rustä¸­ï¼Œè¿™ç§ä»£ç å®é™…ä¸Šä¼šäº§ç”Ÿé”™è¯¯ï¼Œä½†ç°åœ¨çš„ç¼–è¯‘å™¨æ›´èªæ˜äº†ã€‚å®ƒä¸ä»…èƒ½ç†è§£æˆ‘ä»¬è¾“å…¥çš„å†…å®¹ï¼Œè¿˜èƒ½ç†è§£æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨æ‰€æœ‰çš„ä¸œè¥¿ã€‚</p>
<h3 id="å†è°ˆshadowing"><a class="header" href="#å†è°ˆshadowing">å†è°ˆshadowing</a></h3>
<p>è¿˜è®°å¾—æˆ‘ä»¬è¯´è¿‡ï¼Œshadowingä¸ä¼š<strong>ç ´å</strong>ä¸€ä¸ªå€¼ï¼Œè€Œæ˜¯<strong>å±è”½</strong>å®ƒå—ï¼Ÿç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨å¼•ç”¨æ¥çœ‹çœ‹è¿™ä¸ªé—®é¢˜ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from("Austria");
    let country_ref = &amp;country;
    let country = 8;
    println!("{}, {}", country_ref, country);
}</code></pre></pre>
<p>è¿™æ˜¯æ‰“å°<code>Austria, 8</code>è¿˜æ˜¯<code>8, 8</code>ï¼Ÿå®ƒæ‰“å°çš„æ˜¯<code>Austria, 8</code>ã€‚é¦–å…ˆæˆ‘ä»¬å£°æ˜ä¸€ä¸ª<code>String</code>ï¼Œå«åš<code>country</code>ã€‚ç„¶åæˆ‘ä»¬ç»™è¿™ä¸ªå­—ç¬¦ä¸²åˆ›å»ºä¸€ä¸ªå¼•ç”¨<code>country_ref</code>ã€‚ç„¶åæˆ‘ä»¬ç”¨8æ¥shadowingå›½å®¶ï¼Œè¿™æ˜¯ä¸€ä¸ª<code>i32</code>ã€‚ä½†æ˜¯ç¬¬ä¸€ä¸ª<code>country</code>å¹¶æ²¡æœ‰è¢«é”€æ¯ï¼Œæ‰€ä»¥<code>country_ref</code>ä»ç„¶å†™ç€ "Austria"ï¼Œè€Œä¸æ˜¯ "8"ã€‚ä¸‹é¢æ˜¯åŒæ ·çš„ä»£ç ï¼Œå¹¶åŠ äº†ä¸€äº›æ³¨é‡Šæ¥è¯´æ˜å®ƒçš„å·¥ä½œåŸç†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from("Austria"); // Now we have a String called country
    let country_ref = &amp;country; // country_ref is a reference to this data. It's not going to change
    let country = 8; // Now we have a variable called country that is an i8. But it has no relation to the other one, or to country_ref
    println!("{}, {}", country_ref, country); // country_ref still refers to the data of String::from("Austria") that we gave it.
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‡½æ•°çš„å¼•ç”¨"><a class="header" href="#å‡½æ•°çš„å¼•ç”¨">å‡½æ•°çš„å¼•ç”¨</a></h2>
<p>å¼•ç”¨å¯¹å‡½æ•°éå¸¸æœ‰ç”¨ã€‚Rustä¸­å…³äºå€¼çš„è§„åˆ™æ˜¯:ä¸€ä¸ªå€¼åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚</p>
<p>è¿™æ®µä»£ç å°†æ— æ³•å·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">fn print_country(country_name: String) {
    println!("{}", country_name);
}

fn main() {
    let country = String::from("Austria");
    print_country(country); // We print "Austria"
    print_country(country); // âš ï¸ That was fun, let's do it again!
}</code></pre></pre>
<p>å®ƒä¸èƒ½å·¥ä½œï¼Œå› ä¸º<code>country</code>è¢«ç ´åäº†ã€‚ä¸‹é¢æ˜¯å¦‚ä½•æ“ä½œçš„ã€‚</p>
<ul>
<li>ç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬åˆ›å»º<code>String</code>ï¼Œç§°ä¸º<code>country</code>ã€‚<code>country</code>æ˜¯æ‰€æœ‰è€…ã€‚</li>
<li>ç¬¬äºŒæ­¥:æˆ‘ä»¬æŠŠ<code>country</code>ç»™<code>print_country</code>ã€‚<code>print_country</code>æ²¡æœ‰<code>-&gt;</code>ï¼Œæ‰€ä»¥å®ƒä¸è¿”å›ä»»ä½•ä¸œè¥¿ã€‚<code>print_country</code>å®Œæˆåï¼Œæˆ‘ä»¬çš„<code>String</code>ç°åœ¨å·²ç»æ­»äº†ã€‚</li>
<li>ç¬¬ä¸‰æ­¥:æˆ‘ä»¬å°è¯•æŠŠ<code>country</code>ç»™<code>print_country</code>ï¼Œä½†æˆ‘ä»¬å·²ç»è¿™æ ·åšäº†ã€‚æˆ‘ä»¬å·²ç»æ²¡æœ‰<code>country</code>å¯ä»¥ç»™äº†ã€‚</li>
</ul>
<p>æˆ‘ä»¬å¯ä»¥è®©<code>print_country</code>ç»™<code>String</code>å›æ¥ï¼Œä½†æ˜¯æœ‰ç‚¹å°´å°¬ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn print_country(country_name: String) -&gt; String {
    println!("{}", country_name);
    country_name // return it here
}

fn main() {
    let country = String::from("Austria");
    let country = print_country(country); // we have to use let here now to get the String back
    print_country(country);
}</code></pre></pre>
<p>ç°åœ¨æ‰“å°å‡ºæ¥äº†ã€‚</p>
<pre><code class="language-text">Austria
Austria
</code></pre>
<p>æ›´å¥½çš„è§£å†³æ–¹æ³•æ˜¯å¢åŠ <code>&amp;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn print_country(country_name: &amp;String) {
    println!("{}", country_name);
}

fn main() {
    let country = String::from("Austria");
    print_country(&amp;country); // We print "Austria"
    print_country(&amp;country); // That was fun, let's do it again!
}</code></pre></pre>
<p>ç°åœ¨ <code>print_country()</code> æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å— <code>String</code> çš„å¼•ç”¨: <code>&amp;String</code>ã€‚å¦å¤–ï¼Œæˆ‘ä»¬ç»™countryä¸€ä¸ªå¼•ç”¨ï¼Œå†™ä½œ<code>&amp;country</code>ã€‚è¿™è¡¨ç¤º "ä½ å¯ä»¥çœ‹å®ƒï¼Œä½†æˆ‘è¦ä¿ç•™å®ƒ"ã€‚</p>
<p>ç°åœ¨è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªå¯å˜å¼•ç”¨æ¥åšç±»ä¼¼çš„äº‹æƒ…ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨å¯å˜å˜é‡çš„å‡½æ•°çš„ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn add_hungary(country_name: &amp;mut String) { // first we say that the function takes a mutable reference
    country_name.push_str("-Hungary"); // push_str() adds a &amp;str to a String
    println!("Now it says: {}", country_name);
}

fn main() {
    let mut country = String::from("Austria");
    add_hungary(&amp;mut country); // we also need to give it a mutable reference.
}</code></pre></pre>
<p>æ­¤æ‰“å°<code>Now it says: Austria-Hungary</code>ã€‚</p>
<p>æ‰€ä»¥å¾—å‡ºç»“è®º:</p>
<ul>
<li><code>fn function_name(variable: String)</code>æ¥æ”¶äº†<code>String</code>ï¼Œå¹¶æ‹¥æœ‰å®ƒã€‚å¦‚æœå®ƒä¸è¿”å›ä»»ä½•ä¸œè¥¿ï¼Œé‚£ä¹ˆè¿™ä¸ªå˜é‡å°±ä¼šåœ¨å‡½æ•°é‡Œé¢æ­»äº¡ã€‚</li>
<li><code>fn function_name(variable: &amp;String)</code> å€Ÿç”¨ <code>String</code> å¹¶å¯ä»¥æŸ¥çœ‹å®ƒ</li>
<li><code>fn function_name(variable: &amp;mut String)</code>å€Ÿç”¨<code>String</code>ï¼Œå¯ä»¥æ›´æ”¹ã€‚</li>
</ul>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªçœ‹èµ·æ¥åƒå¯å˜å¼•ç”¨çš„ä¾‹å­ï¼Œä½†å®ƒæ˜¯ä¸åŒçš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let country = String::from("Austria"); // country is not mutable, but we are going to print Austria-Hungary. How?
    adds_hungary(country);
}

fn adds_hungary(mut country: String) { // Here's how: adds_hungary takes the String and declares it mutable!
    country.push_str("-Hungary");
    println!("{}", country);
}</code></pre></pre>
<p>è¿™æ€ä¹ˆå¯èƒ½å‘¢ï¼Ÿå› ä¸º<code>mut country</code>ä¸æ˜¯å¼•ç”¨ã€‚<code>adds_hungary</code>ç°åœ¨æ‹¥æœ‰<code>country</code>ã€‚(è®°ä½ï¼Œå®ƒå ç”¨çš„æ˜¯<code>String</code>è€Œä¸æ˜¯<code>&amp;String</code>)ã€‚å½“ä½ è°ƒç”¨<code>adds_hungary</code>çš„é‚£ä¸€åˆ»ï¼Œå®ƒå°±å®Œå…¨æˆäº†countryçš„ä¸»äººã€‚<code>country</code>ä¸<code>String::from("Austria")</code>æ²¡æœ‰å…³ç³»äº†ã€‚æ‰€ä»¥ï¼Œ<code>adds_hungary</code>å¯ä»¥æŠŠ<code>country</code>å½“ä½œå¯å˜çš„ï¼Œè¿™æ ·åšæ˜¯å®Œå…¨å®‰å…¨çš„ã€‚</p>
<p>è¿˜è®°å¾—æˆ‘ä»¬ä¸Šé¢çš„å‘˜å·¥Powerpointå’Œç»ç†çš„æƒ…å†µå—ï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°±å¥½æ¯”å‘˜å·¥åªæ˜¯æŠŠè‡ªå·±çš„æ•´å°ç”µè„‘äº¤ç»™äº†ç»ç†ã€‚å‘˜å·¥ä¸ä¼šå†ç¢°å®ƒï¼Œæ‰€ä»¥ç»ç†å¯ä»¥å¯¹å®ƒåšä»»ä½•ä»–æƒ³åšçš„äº‹æƒ…ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ‹·è´ç±»å‹"><a class="header" href="#æ‹·è´ç±»å‹">æ‹·è´ç±»å‹</a></h2>
<p>Rustä¸­çš„ä¸€äº›ç±»å‹éå¸¸ç®€å•ã€‚å®ƒä»¬è¢«ç§°ä¸º<strong>æ‹·è´ç±»å‹</strong>ã€‚è¿™äº›ç®€å•çš„ç±»å‹éƒ½åœ¨æ ˆä¸­ï¼Œç¼–è¯‘å™¨çŸ¥é“å®ƒä»¬çš„å¤§å°ã€‚è¿™æ„å‘³ç€å®ƒä»¬éå¸¸å®¹æ˜“å¤åˆ¶ï¼Œæ‰€ä»¥å½“ä½ æŠŠå®ƒå‘é€åˆ°ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨æ€»æ˜¯ä¼šå¤åˆ¶ã€‚å®ƒæ€»æ˜¯å¤åˆ¶ï¼Œå› ä¸ºå®ƒä»¬æ˜¯å¦‚æ­¤çš„å°è€Œç®€å•ï¼Œæ²¡æœ‰ç†ç”±ä¸å¤åˆ¶ã€‚æ‰€ä»¥ä½ ä¸éœ€è¦æ‹…å¿ƒè¿™äº›ç±»å‹çš„æ‰€æœ‰æƒé—®é¢˜ã€‚</p>
<p>è¿™äº›ç®€å•çš„ç±»å‹åŒ…æ‹¬:æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼(<code>true</code>å’Œ<code>false</code>)å’Œ<code>char</code>ã€‚</p>
<p>å¦‚ä½•çŸ¥é“ä¸€ä¸ªç±»å‹æ˜¯å¦<strong>å®ç°</strong>å¤åˆ¶ï¼Ÿ(å®ç° = èƒ½å¤Ÿä½¿ç”¨)ä½ å¯ä»¥æŸ¥çœ‹æ–‡æ¡£ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæ˜¯ char çš„æ–‡æ¡£:</p>
<p><a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>åœ¨å·¦è¾¹ä½ å¯ä»¥çœ‹åˆ°<strong>Trait Implementations</strong>ã€‚ä¾‹å¦‚ä½ å¯ä»¥çœ‹åˆ°<strong>Copy</strong>, <strong>Debug</strong>, å’Œ <strong>Display</strong>ã€‚æ‰€ä»¥ä½ çŸ¥é“ï¼Œå½“ä½ æŠŠä¸€ä¸ª<code>char</code>:</p>
<ul>
<li>å½“ä½ æŠŠå®ƒå‘é€åˆ°ä¸€ä¸ªå‡½æ•°(<strong>Copy</strong>)æ—¶ï¼Œå®ƒå°±è¢«å¤åˆ¶äº†ã€‚</li>
<li>å¯ä»¥ç”¨<code>{}</code>æ‰“å°(<strong>Display</strong>)</li>
<li>å¯ä»¥ç”¨<code>{:?}</code>æ‰“å°(<strong>Debug</strong>)</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_number(number: i32) { // There is no -&gt; so it's not returning anything
                             // If number was not copy type, it would take it
                             // and we couldn't use it again
    println!("{}", number);
}

fn main() {
    let my_number = 8;
    prints_number(my_number); // Prints 8. prints_number gets a copy of my_number
    prints_number(my_number); // Prints 8 again.
                              // No problem, because my_number is copy type!
}</code></pre></pre>
<p>ä½†æ˜¯å¦‚æœä½ çœ‹ä¸€ä¸‹Stringçš„æ–‡æ¡£ï¼Œå®ƒä¸æ˜¯æ‹·è´ç±»å‹ã€‚</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>åœ¨å·¦è¾¹çš„<strong>Trait Implementations</strong>ä¸­ï¼Œä½ å¯ä»¥æŒ‰å­—æ¯é¡ºåºæŸ¥æ‰¾ã€‚Aã€Bã€C......Cä¸­æ²¡æœ‰<strong>Copy</strong>ï¼Œä½†æ˜¯æœ‰<strong>Clone</strong>ã€‚<strong>Clone</strong>å’Œ<strong>Copy</strong>ç±»ä¼¼ï¼Œä½†é€šå¸¸éœ€è¦æ›´å¤šçš„å†…å­˜ã€‚å¦å¤–ï¼Œä½ å¿…é¡»ç”¨<code>.clone()</code>æ¥è°ƒç”¨å®ƒ--å®ƒä¸ä¼šè‡ªå·±å…‹éš†ã€‚</p>
<p>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ<code>prints_country()</code>æ‰“å°çš„æ˜¯å›½å®¶åç§°ï¼Œä¸€ä¸ª<code>String</code>ã€‚æˆ‘ä»¬æƒ³æ‰“å°ä¸¤æ¬¡ï¼Œä½†æˆ‘ä»¬ä¸èƒ½ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!("{}", country_name);
}

fn main() {
    let country = String::from("Kiribati");
    prints_country(country);
    prints_country(country); // âš ï¸
}</code></pre></pre>
<p>ä½†ç°åœ¨æˆ‘ä»¬æ˜ç™½äº†è¿™ä¸ªä¿¡æ¯ã€‚</p>
<pre><code class="language-text">error[E0382]: use of moved value: `country`
 --&gt; src\main.rs:4:20
  |
2 |     let country = String::from("Kiribati");
  |         ------- move occurs because `country` has type `std::string::String`, which does not implement the `Copy` trait
3 |     prints_country(country);
  |                    ------- value moved here
4 |     prints_country(country);
  |                    ^^^^^^^ value used here after move
</code></pre>
<p>é‡è¦çš„éƒ¨åˆ†æ˜¯<code>which does not implement the Copy trait</code>ã€‚ä½†æ˜¯åœ¨æ–‡æ¡£ä¸­æˆ‘ä»¬çœ‹åˆ°Stringå®ç°äº†<code>Clone</code>çš„ç‰¹æ€§ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ä»£ç ä¸­æ·»åŠ <code>.clone()</code>ã€‚è¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ªå…‹éš†ï¼Œç„¶åæˆ‘ä»¬å°†å…‹éš†å‘é€åˆ°å‡½æ•°ä¸­ã€‚ç°åœ¨ <code>country</code> è¿˜æ´»ç€ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn prints_country(country_name: String) {
    println!("{}", country_name);
}

fn main() {
    let country = String::from("Kiribati");
    prints_country(country.clone()); // make a clone and give it to the function. Only the clone goes in, and country is still alive
    prints_country(country);
}</code></pre></pre>
<p>å½“ç„¶ï¼Œå¦‚æœ<code>String</code>éå¸¸å¤§ï¼Œ<code>.clone()</code>å°±ä¼šå ç”¨å¾ˆå¤šå†…å­˜ã€‚ä¸€ä¸ª<code>String</code>å¯ä»¥æ˜¯ä¸€æ•´æœ¬ä¹¦çš„é•¿åº¦ï¼Œæˆ‘ä»¬æ¯æ¬¡è°ƒç”¨<code>.clone()</code>éƒ½ä¼šå¤åˆ¶è¿™æœ¬ä¹¦ã€‚æ‰€ä»¥ï¼Œå¦‚æœå¯ä»¥çš„è¯ï¼Œä½¿ç”¨<code>&amp;</code>æ¥åšå¼•ç”¨æ˜¯æ¯”è¾ƒå¿«çš„ã€‚ä¾‹å¦‚ï¼Œè¿™æ®µä»£ç å°†<code>&amp;str</code>æ¨é€åˆ°<code>String</code>ä¸Šï¼Œç„¶åæ¯æ¬¡åœ¨å‡½æ•°ä¸­ä½¿ç”¨æ—¶éƒ½ä¼šè¿›è¡Œå…‹éš†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: String) { // Takes ownership of a String
    println!("It's {} words long.", input.split_whitespace().count()); // splits to count the number of words
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str("Here are some more words "); // push the words on
        get_length(my_string.clone()); // gives it a clone every time
    }
}</code></pre></pre>
<p>å®ƒçš„æ‰“å°ã€‚</p>
<pre><code class="language-text">It's 5 words long.
It's 10 words long.
...
It's 250 words long.
</code></pre>
<p>è¿™å°±æ˜¯50ä¸ªå…‹éš†ã€‚è¿™é‡Œæ˜¯ç”¨å¼•ç”¨ä»£æ›¿æ›´å¥½:</p>
<pre><pre class="playground"><code class="language-rust">fn get_length(input: &amp;String) {
    println!("It's {} words long.", input.split_whitespace().count());
}

fn main() {
    let mut my_string = String::new();
    for _ in 0..50 {
        my_string.push_str("Here are some more words ");
        get_length(&amp;my_string);
    }
}</code></pre></pre>
<p>ä¸æ˜¯50ä¸ªå…‹éš†ï¼Œè€Œæ˜¯0ä¸ªã€‚</p>
<h3 id="æ— å€¼å˜é‡"><a class="header" href="#æ— å€¼å˜é‡">æ— å€¼å˜é‡</a></h3>
<p>ä¸€ä¸ªæ²¡æœ‰å€¼çš„å˜é‡å«åš "æœªåˆå§‹åŒ–"å˜é‡ã€‚æœªåˆå§‹åŒ–çš„æ„æ€æ˜¯ "è¿˜æ²¡æœ‰å¼€å§‹"ã€‚å®ƒä»¬å¾ˆç®€å•:åªéœ€å†™ä¸Š<code>let</code>å’Œå˜é‡åã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_variable; // âš ï¸
}</code></pre></pre>
<p>ä½†æ˜¯ä½ è¿˜ä¸èƒ½ä½¿ç”¨å®ƒï¼Œå¦‚æœä»»ä½•ä¸œè¥¿éƒ½æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼ŒRustå°±ä¸ä¼šç¼–è¯‘ã€‚</p>
<p>ä½†æœ‰æ—¶å®ƒä»¬ä¼šå¾ˆæœ‰ç”¨ã€‚ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­æ˜¯å½“:</p>
<ul>
<li>ä½ æœ‰ä¸€ä¸ªä»£ç å—ï¼Œè€Œä½ çš„å˜é‡å€¼å°±åœ¨é‡Œé¢ï¼Œå¹¶ä¸”</li>
<li>å˜é‡éœ€è¦æ´»åœ¨ä»£ç å—ä¹‹å¤–ã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn loop_then_return(mut counter: i32) -&gt; i32 {
    loop {
        counter += 1;
        if counter % 50 == 0 {
            break;
        }
    }
    counter
}

fn main() {
    let my_number;

    {
        // Pretend we need to have this code block
        let number = {
            // Pretend there is code here to make a number
            // Lots of code, and finally:
            57
        };

        my_number = loop_then_return(number);
    }

    println!("{}", my_number);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>100</code>ã€‚</p>
<p>ä½ å¯ä»¥çœ‹åˆ° <code>my_number</code> æ˜¯åœ¨ <code>main()</code> å‡½æ•°ä¸­å£°æ˜çš„ï¼Œæ‰€ä»¥å®ƒä¸€ç›´æ´»åˆ°æœ€åã€‚ä½†æ˜¯å®ƒçš„å€¼æ˜¯åœ¨å¾ªç¯é‡Œé¢å¾—åˆ°çš„ã€‚ç„¶è€Œï¼Œè¿™ä¸ªå€¼å’Œ<code>my_number</code>ä¸€æ ·é•¿ï¼Œå› ä¸º<code>my_number</code>æœ‰è¿™ä¸ªå€¼ã€‚è€Œå¦‚æœä½ åœ¨å—é‡Œé¢å†™äº†<code>let my_number = loop_then_return(number)</code>ï¼Œå®ƒå°±ä¼šé©¬ä¸Šæ­»æ‰ã€‚</p>
<p>å¦‚æœä½ ç®€åŒ–ä»£ç ï¼Œå¯¹æƒ³è±¡æ˜¯æœ‰å¸®åŠ©çš„ã€‚<code>loop_then_return(number)</code>ç»™å‡ºçš„ç»“æœæ˜¯100ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ é™¤å®ƒï¼Œæ”¹å†™<code>100</code>ã€‚å¦å¤–ï¼Œç°åœ¨æˆ‘ä»¬ä¸éœ€è¦ <code>number</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿåˆ é™¤å®ƒã€‚ç°åœ¨å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number;
    {
        my_number = 100;
    }

    println!("{}", my_number);
}</code></pre></pre>
<p>æ‰€ä»¥è¯´<code>let my_number = { 100 };</code>å·®ä¸å¤šã€‚</p>
<p>å¦å¤–æ³¨æ„ï¼Œ<code>my_number</code>ä¸æ˜¯<code>mut</code>ã€‚æˆ‘ä»¬åœ¨ç»™å®ƒ50ä¹‹å‰å¹¶æ²¡æœ‰ç»™å®ƒä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥å®ƒçš„å€¼ä¸€ç›´æ²¡æœ‰æ”¹å˜ã€‚æœ€åï¼Œ<code>my_number</code>çš„çœŸæ­£ä»£ç åªæ˜¯<code>let my_number = 100;</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é›†åˆç±»å‹"><a class="header" href="#é›†åˆç±»å‹">é›†åˆç±»å‹</a></h2>
<p>Rustæœ‰å¾ˆå¤šç±»å‹ç”¨äºåˆ›å»ºé›†åˆã€‚å½“ä½ éœ€è¦åœ¨ä¸€ä¸ªåœ°æ–¹æœ‰å¤šä¸ªå€¼æ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨é›†åˆã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥åœ¨ä¸€ä¸ªå˜é‡ä¸­åŒ…å«ä½ æ‰€åœ¨å›½å®¶çš„æ‰€æœ‰åŸå¸‚çš„ä¿¡æ¯ã€‚æˆ‘ä»¬å…ˆä»æ•°ç»„å¼€å§‹ï¼Œæ•°ç»„çš„é€Ÿåº¦æœ€å¿«ï¼Œä½†åŠŸèƒ½ä¹Ÿæœ€å°‘ã€‚å®ƒä»¬åœ¨è¿™æ–¹é¢æœ‰ç‚¹åƒ<code>&amp;str</code>ã€‚</p>
<h3 id="æ•°ç»„"><a class="header" href="#æ•°ç»„">æ•°ç»„</a></h3>
<p>æ•°ç»„æ˜¯æ–¹æ‹¬å·å†…çš„æ•°æ®ã€‚<code>[]</code>. æ•°ç»„:</p>
<ul>
<li>ä¸èƒ½æ”¹å˜å…¶å¤§å°ã€‚</li>
<li>å¿…é¡»åªåŒ…å«ç›¸åŒçš„ç±»å‹ã€‚</li>
</ul>
<p>ä½†æ˜¯ï¼Œå®ƒä»¬çš„é€Ÿåº¦éå¸¸å¿«ã€‚</p>
<p>æ•°ç»„çš„ç±»å‹æ˜¯:<code>[type; number]</code>ã€‚ä¾‹å¦‚ï¼Œ<code>["One", "Two"]</code>çš„ç±»å‹æ˜¯<code>[&amp;str; 2]</code>ã€‚è¿™æ„å‘³ç€ï¼Œå³ä½¿è¿™ä¸¤ä¸ªæ•°ç»„ä¹Ÿæœ‰ä¸åŒçš„ç±»å‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array1 = ["One", "Two"]; // This one is type [&amp;str; 2]
    let array2 = ["One", "Two", "Five"]; // But this one is type [&amp;str; 3]. Different type!
}</code></pre></pre>
<p>è¿™é‡Œæœ‰ä¸€ä¸ªå¾ˆå¥½çš„æç¤º:è¦æƒ³çŸ¥é“ä¸€ä¸ªå˜é‡çš„ç±»å‹ï¼Œä½ å¯ä»¥é€šè¿‡ç»™ç¼–è¯‘å™¨ä¸‹åæŒ‡ä»¤æ¥ "è¯¢é—®"å®ƒã€‚æ¯”å¦‚è¯´</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let seasons = ["Spring", "Summer", "Autumn", "Winter"];
    let seasons2 = ["Spring", "Summer", "Fall", "Autumn", "Winter"];
    seasons.ddd(); // âš ï¸
    seasons2.thd(); // âš ï¸ as well
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´:"ä»€ä¹ˆï¼Ÿseasonsæ²¡æœ‰<code>.ddd()</code>çš„æ–¹æ³•ï¼Œseasons2ä¹Ÿæ²¡æœ‰<code>.thd()</code>çš„æ–¹æ³•ï¼ï¼"ä½ å¯ä»¥çœ‹åˆ°:</p>
<pre><code class="language-text">error[E0599]: no method named `ddd` found for array `[&amp;str; 4]` in the current scope
 --&gt; src\main.rs:4:13
  |
4 |     seasons.ddd(); // 
  |             ^^^ method not found in `[&amp;str; 4]`

error[E0599]: no method named `thd` found for array `[&amp;str; 5]` in the current scope
 --&gt; src\main.rs:5:14
  |
5 |     seasons2.thd(); // 
  |              ^^^ method not found in `[&amp;str; 5]`
</code></pre>
<p>æ‰€ä»¥å®ƒå‘Šè¯‰ä½ <code>method not found in `[&amp;str; 4]`</code>ï¼Œè¿™å°±æ˜¯ç±»å‹ã€‚</p>
<p>å¦‚æœä½ æƒ³è¦ä¸€ä¸ªæ•°å€¼éƒ½ä¸€æ ·çš„æ•°ç»„ï¼Œä½ å¯ä»¥è¿™æ ·å£°æ˜ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_array = ["a"; 10];
    println!("{:?}", my_array);
}</code></pre></pre>
<p>è¿™æ ·å°±æ‰“å°å‡ºäº†<code>["a", "a", "a", "a", "a", "a", "a", "a", "a", "a"]</code>ã€‚</p>
<p>è¿™ä¸ªæ–¹æ³•ç»å¸¸ç”¨æ¥åˆ›å»ºç¼“å†²åŒºã€‚ä¾‹å¦‚ï¼Œ<code>let mut buffer = [0; 640]</code>åˆ›å»ºä¸€ä¸ª640ä¸ªé›¶çš„æ•°ç»„ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥å°†é›¶æ”¹ä¸ºå…¶ä»–æ•°å­—ï¼Œä»¥ä¾¿æ·»åŠ æ•°æ®ã€‚</p>
<p>ä½ å¯ä»¥ç”¨[]æ¥ç´¢å¼•(è·å–)æ•°ç»„ä¸­çš„æ¡ç›®ã€‚ç¬¬ä¸€ä¸ªæ¡ç›®æ˜¯[0]ï¼Œç¬¬äºŒä¸ªæ˜¯[1]ï¼Œä»¥æ­¤ç±»æ¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_numbers = [0, 10, -20];
    println!("{}", my_numbers[1]); // prints 10
}</code></pre></pre>
<p>ä½ å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ•°ç»„çš„ä¸€ä¸ªç‰‡æ–­(ä¸€å—)ã€‚é¦–å…ˆä½ éœ€è¦ä¸€ä¸ª&amp;ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸çŸ¥é“å¤§å°ã€‚ç„¶åä½ å¯ä»¥ä½¿ç”¨<code>..</code>æ¥æ˜¾ç¤ºèŒƒå›´ã€‚</p>
<p>ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªæ•°ç»„ã€‚<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array_of_ten = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let three_to_five = &amp;array_of_ten[2..5];
    let start_at_two = &amp;array_of_ten[1..];
    let end_at_five = &amp;array_of_ten[..5];
    let everything = &amp;array_of_ten[..];

    println!("Three to five: {:?}, start at two: {:?}, end at five: {:?}, everything: {:?}", three_to_five, start_at_two, end_at_five, everything);
}</code></pre></pre>
<p>è®°ä½è¿™ä¸€ç‚¹ã€‚</p>
<ul>
<li>ç´¢å¼•å·ä»0å¼€å§‹(ä¸æ˜¯1)</li>
<li>ç´¢å¼•èŒƒå›´æ˜¯<strong>ä¸åŒ…å«çš„</strong>(ä¸åŒ…æ‹¬æœ€åä¸€ä¸ªæ•°å­—)ã€‚</li>
</ul>
<p>æ‰€ä»¥<code>[0..2]</code>æ˜¯æŒ‡ç¬¬ä¸€ä¸ªæŒ‡æ•°å’Œç¬¬äºŒä¸ªæŒ‡æ•°(0å’Œ1)ã€‚æˆ–è€…ä½ ä¹Ÿå¯ä»¥ç§°å®ƒä¸º "é›¶ç‚¹å’Œç¬¬ä¸€"æŒ‡æ•°ã€‚å®ƒæ²¡æœ‰ç¬¬ä¸‰é¡¹ï¼Œä¹Ÿå°±æ˜¯ç´¢å¼•2ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ª<strong>åŒ…å«çš„</strong>èŒƒå›´ï¼Œè¿™æ„å‘³ç€å®ƒä¹ŸåŒ…æ‹¬æœ€åä¸€ä¸ªæ•°å­—ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ã€‚
æ·»åŠ <code>=</code>ï¼Œå†™æˆ<code>..=</code>ï¼Œè€Œä¸æ˜¯<code>..</code>ã€‚æ‰€ä»¥ï¼Œå¦‚æœä½ æƒ³è¦ç¬¬ä¸€é¡¹ã€ç¬¬äºŒé¡¹å’Œç¬¬ä¸‰é¡¹ï¼Œå¯ä»¥å†™æˆ<code>[0..=2]</code>ï¼Œè€Œä¸æ˜¯<code>[0..2]</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‘é‡"><a class="header" href="#å‘é‡">å‘é‡</a></h2>
<p>å°±åƒæˆ‘ä»¬æœ‰<code>&amp;str</code>å’Œ<code>String</code>ä¸€æ ·ï¼Œæˆ‘ä»¬æœ‰æ•°ç»„å’Œå‘é‡ã€‚æ•°ç»„çš„åŠŸèƒ½å°‘äº†å°±å¿«ï¼Œå‘é‡çš„åŠŸèƒ½å¤šäº†å°±æ…¢ã€‚(å½“ç„¶ï¼ŒRustçš„é€Ÿåº¦ä¸€ç›´éƒ½æ˜¯éå¸¸å¿«çš„ï¼Œæ‰€ä»¥å‘é‡å¹¶ä¸æ…¢ï¼Œåªæ˜¯æ¯”æ•°ç»„æ…¢<em>ä¸€ç‚¹</em>)ã€‚ç±»å‹å†™æˆ<code>Vec</code>ï¼Œä½ ä¹Ÿå¯ä»¥ç›´æ¥å«å®ƒ "vec"ã€‚</p>
<p>å‘é‡çš„å£°æ˜ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ã€‚ä¸€ç§æ˜¯åƒ<code>String</code>ä¸€æ ·ä½¿ç”¨<code>new</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name1 = String::from("Windy");
    let name2 = String::from("Gomesy");

    let mut my_vec = Vec::new();
    // If we run the program now, the compiler will give an error.
    // It doesn't know the type of vec.

    my_vec.push(name1); // Now it knows: it's Vec&lt;String&gt;
    my_vec.push(name2);
}</code></pre></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°<code>Vec</code>é‡Œé¢æ€»æ˜¯æœ‰å…¶ä»–ä¸œè¥¿ï¼Œè¿™å°±æ˜¯<code>&lt;&gt;</code>(è§’æ‹¬å·)çš„ä½œç”¨ã€‚<code>Vec&lt;String&gt;</code>æ˜¯ä¸€ä¸ªæœ‰ä¸€ä¸ªæˆ–å¤šä¸ª<code>String</code>çš„å‘é‡ã€‚ä½ è¿˜å¯ä»¥åœ¨é‡Œé¢æœ‰æ›´å¤šçš„ç±»å‹ã€‚æ¯”å¦‚è¯´</p>
<ul>
<li><code>Vec&lt;(i32, i32)&gt;</code> è¿™æ˜¯ä¸€ä¸ª <code>Vec</code> å…¶ä¸­æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå…ƒç»„ã€‚<code>(i32, i32)</code>.</li>
<li><code>Vec&lt;Vec&lt;String&gt;&gt;</code>è¿™æ˜¯ä¸€ä¸ª<code>Vec</code>ï¼Œå…¶ä¸­æœ‰<code>Vec</code>çš„<code>Strings</code>ã€‚æ¯”å¦‚è¯´ä½ æƒ³æŠŠä½ å–œæ¬¢çš„ä¹¦ä¿å­˜ä¸º<code>Vec&lt;String&gt;</code>ã€‚ç„¶åä½ å†ç”¨å¦ä¸€æœ¬ä¹¦æ¥åšï¼Œå°±ä¼šå¾—åˆ°å¦ä¸€ä¸ª<code>Vec&lt;String&gt;</code>ã€‚ä¸ºäº†ä¿å­˜è¿™ä¸¤æœ¬ä¹¦ï¼Œä½ ä¼šæŠŠå®ƒä»¬æ”¾å…¥å¦ä¸€ä¸ª<code>Vec</code>ä¸­ï¼Œè¿™å°±æ˜¯<code>Vec&lt;Vec&lt;String&gt;&gt;</code>ã€‚</li>
</ul>
<p>ä¸å…¶ä½¿ç”¨ <code>.push()</code> è®© Rust å†³å®šç±»å‹ï¼Œä¸å¦‚ç›´æ¥å£°æ˜ç±»å‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec: Vec&lt;String&gt; = Vec::new(); // The compiler knows the type
                                              // so there is no error.
}</code></pre></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œå‘é‡ä¸­çš„å…ƒç´ å¿…é¡»å…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚</p>
<p>å¦ä¸€ä¸ªåˆ›å»ºå‘é‡çš„ç®€å•æ–¹æ³•æ˜¯ä½¿ç”¨ <code>vec!</code> å®ã€‚å®ƒçœ‹èµ·æ¥åƒä¸€ä¸ªæ•°ç»„å£°æ˜ï¼Œä½†å‰é¢æœ‰ <code>vec!</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![8, 10, 10];
}</code></pre></pre>
<p>ç±»å‹æ˜¯<code>Vec&lt;i32&gt;</code>ã€‚ä½ ç§°å®ƒä¸º "i32çš„Vec"ã€‚è€Œ<code>Vec&lt;String&gt;</code>æ˜¯ "Stringçš„Vec"ã€‚<code>Vec&lt;Vec&lt;String&gt;&gt;</code>æ˜¯ "Stringçš„Vecçš„Vec"ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥å¯¹ä¸€ä¸ªå‘é‡è¿›è¡Œåˆ†ç‰‡ï¼Œå°±åƒåœ¨æ•°ç»„ä¸­ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec_of_ten = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    // Everything is the same as above except we added vec!.
    let three_to_five = &amp;vec_of_ten[2..5];
    let start_at_two = &amp;vec_of_ten[1..];
    let end_at_five = &amp;vec_of_ten[..5];
    let everything = &amp;vec_of_ten[..];

    println!("Three to five: {:?},
start at two: {:?}
end at five: {:?}
everything: {:?}", three_to_five, start_at_two, end_at_five, everything);
}</code></pre></pre>
<p>å› ä¸ºVectoræ¯”æ•°ç»„æ…¢ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€äº›æ–¹æ³•è®©å®ƒæ›´å¿«ã€‚ä¸€ä¸ªvecæœ‰ä¸€ä¸ª<strong>å®¹é‡</strong>ï¼Œä¹Ÿå°±æ˜¯ç»™å‘é‡çš„ç©ºé—´ã€‚å½“ä½ åœ¨å‘é‡ä¸Šæ¨é€ä¸€ä¸ªæ–°çš„å…ƒç´ æ—¶ï¼Œå®ƒä¼šè¶Šæ¥è¶Šæ¥è¿‘å®¹é‡ã€‚ç„¶åï¼Œå¦‚æœä½ è¶…è¿‡äº†å®¹é‡ï¼Œå®ƒå°†ä½¿å…¶å®¹é‡ç¿»å€ï¼Œå¹¶å°†å…ƒç´ å¤åˆ¶åˆ°æ–°çš„ç©ºé—´ã€‚è¿™å°±æ˜¯æ‰€è°“çš„é‡æ–°åˆ†é…ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ç§åä¸º<code>.capacity()</code>çš„æ–¹æ³•æ¥æŸ¥çœ‹å‘é‡çš„å®¹é‡ï¼Œåœ¨æˆ‘ä»¬å‘å®ƒæ·»åŠ å…ƒç´ æ—¶ã€‚</p>
<p>ä¾‹å¦‚ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨åä¸º<code>.capacity()</code>çš„æ–¹æ³•æ¥è§‚å¯Ÿä¸€ä¸ªå‘é‡çš„å®¹é‡ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::new();
    println!("{}", num_vec.capacity()); // 0 elements: prints 0
    num_vec.push('a'); // add one character
    println!("{}", num_vec.capacity()); // 1 element: prints 4. Vecs with 1 item always start with capacity 4
    num_vec.push('a'); // add one more
    num_vec.push('a'); // add one more
    num_vec.push('a'); // add one more
    println!("{}", num_vec.capacity()); // 4 elements: still prints 4.
    num_vec.push('a'); // add one more
    println!("{}", num_vec.capacity()); // prints 8. We have 5 elements, but it doubled 4 to 8 to make space
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">0
4
4
8
</code></pre>
<p>æ‰€ä»¥è¿™ä¸ªå‘é‡æœ‰ä¸¤æ¬¡é‡åˆ†é…: 0åˆ°4ï¼Œ4åˆ°8ã€‚æˆ‘ä»¬å¯ä»¥è®©å®ƒæ›´å¿«:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut num_vec = Vec::with_capacity(8); // Give it capacity 8
    num_vec.push('a'); // add one character
    println!("{}", num_vec.capacity()); // prints 8
    num_vec.push('a'); // add one more
    println!("{}", num_vec.capacity()); // prints 8
    num_vec.push('a'); // add one more
    println!("{}", num_vec.capacity()); // prints 8.
    num_vec.push('a'); // add one more
    num_vec.push('a'); // add one more // Now we have 5 elements
    println!("{}", num_vec.capacity()); // Still 8
}</code></pre></pre>
<p>è¿™ä¸ªå‘é‡æœ‰0ä¸ªé‡åˆ†é…ï¼Œè¿™æ˜¯æ¯”è¾ƒå¥½çš„ã€‚æ‰€ä»¥å¦‚æœä½ è®¤ä¸ºä½ çŸ¥é“ä½ éœ€è¦å¤šå°‘å…ƒç´ ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>Vec::with_capacity()</code>æ¥ä½¿å®ƒæ›´å¿«ã€‚</p>
<p>ä½ è®°å¾—ä½ å¯ä»¥ç”¨<code>.into()</code>æŠŠ<code>&amp;str</code>å˜æˆ<code>String</code>ã€‚ä½ ä¹Ÿå¯ä»¥ç”¨å®ƒæŠŠä¸€ä¸ªæ•°ç»„å˜æˆ<code>Vec</code>ã€‚ä½ å¿…é¡»å‘Šè¯‰ <code>.into()</code> ä½ æƒ³è¦ä¸€ä¸ª <code>Vec</code>ï¼Œä½†ä½ ä¸å¿…é€‰æ‹© <code>Vec</code> çš„ç±»å‹ã€‚å¦‚æœä½ ä¸æƒ³é€‰æ‹©ï¼Œä½ å¯ä»¥å†™<code>Vec&lt;_&gt;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;u8&gt; = [1, 2, 3].into();
    let my_vec2: Vec&lt;_&gt; = [9, 0, 10].into(); // Vec&lt;_&gt; means "choose the Vec type for me"
                                             // Rust will choose Vec&lt;i32&gt;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å…ƒç»„"><a class="header" href="#å…ƒç»„">å…ƒç»„</a></h2>
<p>Rustä¸­çš„å…ƒç»„ä½¿ç”¨<code>()</code>ã€‚æˆ‘ä»¬å·²ç»è§è¿‡å¾ˆå¤šç©ºå…ƒç»„äº†ï¼Œå› ä¸ºå‡½æ•°ä¸­çš„<em>nothing</em>å®é™…ä¸Šæ„å‘³ç€ä¸€ä¸ªç©ºå…ƒç»„ã€‚</p>
<pre><code class="language-text">fn do_something() {}
</code></pre>
<p>å…¶å®æ˜¯å®ƒçš„ç®€å†™:</p>
<pre><code class="language-text">fn do_something() -&gt; () {}
</code></pre>
<p>è¿™ä¸ªå‡½æ•°ä»€ä¹ˆä¹Ÿå¾—ä¸åˆ°(ä¸€ä¸ªç©ºå…ƒç»„)ï¼Œä¹Ÿä¸è¿”å›ä»€ä¹ˆ(ä¸€ä¸ªç©ºå…ƒç»„)ã€‚æ‰€ä»¥æˆ‘ä»¬å·²ç»ç»å¸¸ä½¿ç”¨å…ƒç»„äº†ã€‚å½“ä½ åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ä¸è¿”å›ä»»ä½•ä¸œè¥¿æ—¶ï¼Œä½ å®é™…ä¸Šè¿”å›çš„æ˜¯ä¸€ä¸ªç©ºå…ƒç»„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn just_prints() {
    println!("I am printing"); // Adding ; means we return an empty tuple
}

fn main() {}</code></pre></pre>
<p>ä½†æ˜¯å…ƒç»„å¯ä»¥å®¹çº³å¾ˆå¤šä¸œè¥¿ï¼Œä¹Ÿå¯ä»¥å®¹çº³ä¸åŒçš„ç±»å‹ã€‚å…ƒç»„é‡Œé¢çš„å…ƒç´ ä¹Ÿæ˜¯ç”¨æ•°å­—0ã€1ã€2ç­‰æ¥åšç´¢å¼•çš„ï¼Œä½†è¦è®¿é—®å®ƒä»¬ï¼Œä½ è¦ç”¨<code>.</code>è€Œä¸æ˜¯<code>[]</code>ã€‚è®©æˆ‘ä»¬æŠŠä¸€å¤§å †ç±»å‹æ”¾åˆ°ä¸€ä¸ªå…ƒç»„ä¸­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let random_tuple = ("Here is a name", 8, vec!['a'], 'b', [8, 9, 10], 7.7);
    println!(
        "Inside the tuple is: First item: {:?}
Second item: {:?}
Third item: {:?}
Fourth item: {:?}
Fifth item: {:?}
Sixth item: {:?}",
        random_tuple.0,
        random_tuple.1,
        random_tuple.2,
        random_tuple.3,
        random_tuple.4,
        random_tuple.5,
    )
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Inside the tuple is: First item: "Here is a name"
Second item: 8
Third item: ['a']
Fourth item: 'b'
Fifth item: [8, 9, 10]
Sixth item: 7.7
</code></pre>
<p>è¿™ä¸ªå…ƒç»„çš„ç±»å‹æ˜¯ <code>(&amp;str, i32, Vec&lt;char&gt;, char, [i32; 3], f64)</code>ã€‚</p>
<p>ä½ å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå…ƒç»„æ¥åˆ›å»ºå¤šä¸ªå˜é‡ã€‚çœ‹çœ‹è¿™æ®µä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec!["one", "two", "three"];
}</code></pre></pre>
<p><code>str_vec</code>é‡Œé¢æœ‰ä¸‰ä¸ªå…ƒç´ ã€‚å¦‚æœæˆ‘ä»¬æƒ³æŠŠå®ƒä»¬æ‹‰å‡ºæ¥å‘¢ï¼Ÿè¿™æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…ƒç»„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec!["one", "two", "three"];

    let (a, b, c) = (str_vec[0], str_vec[1], str_vec[2]); // call them a, b, and c
    println!("{:?}", b);
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡º<code>"two"</code>ï¼Œä¹Ÿå°±æ˜¯<code>b</code>ã€‚è¿™å°±æ˜¯æ‰€è°“çš„<em>è§£æ„</em>ã€‚è¿™æ˜¯å› ä¸ºé¦–å…ˆå˜é‡æ˜¯åœ¨ç»“æ„ä½“é‡Œé¢çš„ï¼Œä½†æ˜¯æˆ‘ä»¬åˆåšäº†<code>a</code>ã€<code>b</code>ã€<code>c</code>è¿™äº›ä¸æ˜¯åœ¨ç»“æ„ä½“é‡Œé¢çš„å˜é‡ã€‚</p>
<p>å¦‚æœä½ éœ€è¦è§£æ„ï¼Œä½†åˆä¸æƒ³è¦æ‰€æœ‰çš„å˜é‡ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>_</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let str_vec = vec!["one", "two", "three"];

    let (_, _, variable) = (str_vec[0], str_vec[1], str_vec[2]);
}</code></pre></pre>
<p>ç°åœ¨å®ƒåªåˆ›å»ºäº†ä¸€ä¸ªå«<code>variable</code>çš„å˜é‡ï¼Œä½†æ²¡æœ‰ä¸ºå…¶ä»–å€¼åšå˜é‡ã€‚</p>
<p>è¿˜æœ‰å¾ˆå¤šé›†åˆç±»å‹ï¼Œè¿˜æœ‰å¾ˆå¤šä½¿ç”¨æ•°ç»„ã€vecå’Œtupleçš„æ–¹æ³•ã€‚æˆ‘ä»¬ä¹Ÿå°†å­¦ä¹ æ›´å¤šå…³äºå®ƒä»¬çš„çŸ¥è¯†ï¼Œä½†é¦–å…ˆæˆ‘ä»¬å°†å­¦ä¹ æ§åˆ¶æµã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ§åˆ¶æµ"><a class="header" href="#æ§åˆ¶æµ">æ§åˆ¶æµ</a></h2>
<p>æ§åˆ¶æµçš„æ„æ€æ˜¯å‘Šè¯‰ä½ çš„ä»£ç åœ¨ä¸åŒçš„æƒ…å†µä¸‹è¯¥æ€ä¹ˆåšã€‚æœ€ç®€å•çš„æ§åˆ¶æµæ˜¯<code>if</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!("It's seven");
    }
}</code></pre></pre>
<p>å¦å¤–æ³¨æ„ï¼Œä½ ç”¨çš„æ˜¯<code>==</code>è€Œä¸æ˜¯<code>=</code>ã€‚<code>==</code>æ˜¯ç”¨æ¥æ¯”è¾ƒçš„ï¼Œ<code>=</code>æ˜¯ç”¨æ¥<em>èµ‹å€¼</em>çš„(ç»™ä¸€ä¸ªå€¼)ã€‚å¦å¤–æ³¨æ„ï¼Œæˆ‘ä»¬å†™çš„æ˜¯<code>if my_number == 7</code>è€Œä¸æ˜¯<code>if (my_number == 7)</code>ã€‚åœ¨Rustä¸­ï¼Œä½ ä¸éœ€è¦ç”¨<code>if</code>çš„æ‹¬å·ã€‚</p>
<p><code>else if</code>å’Œ<code>else</code>ç»™ä½ æ›´å¤šçš„æ§åˆ¶:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number == 7 {
        println!("It's seven");
    } else if my_number == 6 {
        println!("It's six")
    } else {
        println!("It's a different number")
    }
}</code></pre></pre>
<p>è¿™æ‰“å°å‡º<code>It's a different number</code>ï¼Œå› ä¸ºå®ƒä¸ç­‰äº7æˆ–6ã€‚</p>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ <code>&amp;&amp;</code>(å’Œ)å’Œ <code>||</code>(æˆ–)æ·»åŠ æ›´å¤šæ¡ä»¶ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    if my_number % 2 == 1 &amp;&amp; my_number &gt; 0 { // % 2 means the number that remains after diving by two
        println!("It's a positive odd number");
    } else if my_number == 6 {
        println!("It's six")
    } else {
        println!("It's a different number")
    }
}</code></pre></pre>
<p>è¿™æ‰“å°å‡ºçš„æ˜¯<code>It's a positive odd number</code>ï¼Œå› ä¸ºå½“ä½ æŠŠå®ƒé™¤ä»¥2æ—¶ï¼Œä½ æœ‰ä¸€ä¸ª1çš„ä½™æ•°ï¼Œå®ƒå¤§äº0ã€‚</p>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œè¿‡å¤šçš„<code>if</code>ã€<code>else</code>å’Œ<code>else if</code>ä¼šå¾ˆéš¾è¯»ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>match</code>æ¥ä»£æ›¿ï¼Œå®ƒçœ‹èµ·æ¥æ›´å¹²å‡€ã€‚ä½†æ˜¯æ‚¨å¿…é¡»ä¸ºæ¯ä¸€ä¸ªå¯èƒ½çš„ç»“æœè¿›è¡ŒåŒ¹é…ã€‚ä¾‹å¦‚ï¼Œè¿™å°†æ— æ³•å·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!("it's zero"),
        1 =&gt; println!("it's one"),
        2 =&gt; println!("it's two"),
        // âš ï¸
    }
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `3u8..=std::u8::MAX` not covered
 --&gt; src\main.rs:3:11
  |
3 |     match my_number {
  |           ^^^^^^^^^ pattern `3u8..=std::u8::MAX` not covered
</code></pre>
<p>è¿™å°±æ„å‘³ç€ "ä½ å‘Šè¯‰æˆ‘0åˆ°2ï¼Œä½†<code>u8</code>å¯ä»¥åˆ°255ã€‚é‚£3å‘¢ï¼Ÿé‚£4å‘¢ï¼Ÿ5å‘¢ï¼Ÿ" ä»¥æ­¤ç±»æ¨ã€‚æ‰€ä»¥ä½ å¯ä»¥åŠ ä¸Š<code>_</code>ï¼Œæ„æ€æ˜¯ "å…¶ä»–ä»»ä½•ä¸œè¥¿"ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number: u8 = 5;
    match my_number {
        0 =&gt; println!("it's zero"),
        1 =&gt; println!("it's one"),
        2 =&gt; println!("it's two"),
        _ =&gt; println!("It's some other number"),
    }
}</code></pre></pre>
<p>é‚£æ‰“å°<code>It's some other number</code>ã€‚</p>
<p>è®°ä½åŒ¹é…çš„è§„åˆ™:</p>
<ul>
<li>ä½ å†™ä¸‹<code>match</code>ï¼Œç„¶ååˆ›å»ºä¸€ä¸ª<code>{}</code>çš„ä»£ç å—ã€‚</li>
<li>åœ¨å·¦è¾¹å†™ä¸Š<em>æ¨¡å¼</em>ï¼Œç”¨<code>=&gt;</code>èƒ–ç®­å¤´è¯´æ˜åŒ¹é…æ—¶è¯¥æ€ä¹ˆåšã€‚</li>
<li>æ¯ä¸€è¡Œç§°ä¸ºä¸€ä¸ª "arm"ã€‚</li>
<li>åœ¨armä¹‹é—´æ”¾ä¸€ä¸ªé€—å·(ä¸æ˜¯åˆ†å·)ã€‚</li>
</ul>
<p>ä½ å¯ä»¥ç”¨åŒ¹é…æ¥å£°æ˜ä¸€ä¸ªå€¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 5;
    let second_number = match my_number {
        0 =&gt; 0,
        5 =&gt; 10,
        _ =&gt; 2,
    };
}</code></pre></pre>
<p><code>second_number</code>å°†æ˜¯10ã€‚ä½ çœ‹åˆ°æœ€åçš„åˆ†å·äº†å—ï¼Ÿé‚£æ˜¯å› ä¸ºï¼Œåœ¨matchç»“æŸåï¼Œæˆ‘ä»¬å®é™…ä¸Šå‘Šè¯‰äº†ç¼–è¯‘å™¨è¿™ä¸ªä¿¡æ¯:<code>let second_number = 10;</code></p>
<p>ä½ ä¹Ÿå¯ä»¥åœ¨æ›´å¤æ‚çš„äº‹æƒ…ä¸Šè¿›è¡ŒåŒ¹é…ã€‚ä½ ç”¨ä¸€ä¸ªå…ƒç»„æ¥åšã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let sky = "cloudy";
    let temperature = "warm";

    match (sky, temperature) {
        ("cloudy", "cold") =&gt; println!("It's dark and unpleasant today"),
        ("clear", "warm") =&gt; println!("It's a nice day"),
        ("cloudy", "warm") =&gt; println!("It's dark but not bad"),
        _ =&gt; println!("Not sure what the weather is."),
    }
}</code></pre></pre>
<p>è¿™æ‰“å°äº†<code>It's dark but not bad</code>ï¼Œå› ä¸ºå®ƒä¸<code>sky</code>å’Œ<code>temperature</code>çš„ "å¤šäº‘"å’Œ "æ¸©æš–"ç›¸åŒ¹é…ã€‚</p>
<p>ä½ ç”šè‡³å¯ä»¥æŠŠ<code>if</code>æ”¾åœ¨<code>match</code>é‡Œé¢ã€‚è¿™å°±æ˜¯æ‰€è°“çš„ "match guard"ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let children = 5;
    let married = true;

    match (children, married) {
        (children, married) if married == false =&gt; println!("Not married with {} children", children),
        (children, married) if children == 0 &amp;&amp; married == true =&gt; println!("Married but no children"),
        _ =&gt; println!("Married? {}. Number of children: {}.", married, children),
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°<code>Married? true. Number of children: 5.</code></p>
<p>åœ¨ä¸€æ¬¡åŒ¹é…ä¸­ï¼Œä½ å¯ä»¥éšæ„ä½¿ç”¨ _ ã€‚åœ¨è¿™ä¸ªå…³äºé¢œè‰²çš„åŒ¹é…ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸‰ä¸ªé¢œè‰²ï¼Œä½†ä¸€æ¬¡åªèƒ½é€‰ä¸­ä¸€ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    match rbg {
        (r, _, _) if r &lt; 10 =&gt; println!("Not much red"),
        (_, b, _) if b &lt; 10 =&gt; println!("Not much blue"),
        (_, _, g) if g &lt; 10 =&gt; println!("Not much green"),
        _ =&gt; println!("Each colour has at least 10"),
    }
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);

}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">Not much blue
Each colour has at least 10
Not much green
</code></pre>
<p>è¿™ä¹Ÿè¯´æ˜äº†<code>match</code>è¯­å¥çš„ä½œç”¨ï¼Œå› ä¸ºåœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œå®ƒåªæ‰“å°äº†<code>Not much blue</code>ã€‚ä½†æ˜¯<code>first</code>ä¹Ÿæ²¡æœ‰å¤šå°‘ç»¿è‰²ã€‚<code>match</code>è¯­å¥æ€»æ˜¯åœ¨æ‰¾åˆ°ä¸€ä¸ªåŒ¹é…é¡¹æ—¶åœæ­¢ï¼Œè€Œä¸æ£€æŸ¥å…¶ä»–çš„ã€‚è¿™å°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼Œä»£ç ç¼–è¯‘å¾—å¾ˆå¥½ï¼Œä½†ä¸æ˜¯ä½ æƒ³è¦çš„ä»£ç ã€‚</p>
<p>ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªéå¸¸å¤§çš„ <code>match</code> è¯­å¥æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯ä½¿ç”¨ <code>for</code> å¾ªç¯å¯èƒ½æ›´å¥½ã€‚æˆ‘ä»¬å°†å¾ˆå¿«è®¨è®ºå¾ªç¯ã€‚</p>
<p>åŒ¹é…å¿…é¡»è¿”å›ç›¸åŒçš„ç±»å‹ã€‚æ‰€ä»¥ä½ ä¸èƒ½è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;
    let some_variable = match my_number {
        10 =&gt; 8,
        _ =&gt; "Not ten", // âš ï¸
    };
}</code></pre></pre>
<p>ç¼–è¯‘å™¨å‘Šè¯‰ä½ :</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
  --&gt; src\main.rs:17:14
   |
15 |       let some_variable = match my_number {
   |  _________________________-
16 | |         10 =&gt; 8,
   | |               - this is found to be of type `{integer}`
17 | |         _ =&gt; "Not ten",
   | |              ^^^^^^^^^ expected integer, found `&amp;str`
18 | |     };
   | |_____- `match` arms have incompatible types
</code></pre>
<p>è¿™æ ·ä¹Ÿä¸è¡Œï¼ŒåŸå› åŒä¸Šã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_variable = if my_number == 10 { 8 } else { "something else "}; // âš ï¸
}</code></pre></pre>
<p>ä½†æ˜¯è¿™æ ·å°±å¯ä»¥äº†ï¼Œå› ä¸ºä¸æ˜¯<code>match</code>ï¼Œæ‰€ä»¥ä½ æ¯æ¬¡éƒ½æœ‰ä¸åŒçš„<code>let</code>è¯­å¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 10;

    if my_number == 10 {
        let some_variable = 8;
    } else {
        let some_variable = "Something else";
    }
}</code></pre></pre>
<p>ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ <code>@</code> ç»™ <code>match</code> è¡¨è¾¾å¼çš„å€¼èµ·ä¸€ä¸ªåå­—ï¼Œç„¶åä½ å°±å¯ä»¥ä½¿ç”¨å®ƒã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨ä¸€ä¸ªå‡½æ•°ä¸­åŒ¹é…ä¸€ä¸ª <code>i32</code> è¾“å…¥ã€‚å¦‚æœæ˜¯4æˆ–13ï¼Œæˆ‘ä»¬è¦åœ¨<code>println!</code>è¯­å¥ä¸­ä½¿ç”¨è¿™ä¸ªæ•°å­—ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn match_number(input: i32) {
    match input {
    number @ 4 =&gt; println!("{} is an unlucky number in China (sounds close to æ­»)!", number),
    number @ 13 =&gt; println!("{} is unlucky in North America, lucky in Italy! In bocca al lupo!", number),
    _ =&gt; println!("Looks like a normal number"),
    }
}

fn main() {
    match_number(50);
    match_number(13);
    match_number(4);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Looks like a normal number
13 is unlucky in North America, lucky in Italy! In bocca al lupo!
4 is an unlucky number in China (sounds close to æ­»)!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç»“æ„ä½“"><a class="header" href="#ç»“æ„ä½“">ç»“æ„ä½“</a></h2>
<p>æœ‰äº†ç»“æ„ä½“ï¼Œä½ å¯ä»¥åˆ›å»ºè‡ªå·±çš„ç±»å‹ã€‚åœ¨ Rust ä¸­ï¼Œä½ ä¼šä¸€ç›´ä½¿ç”¨ç»“æ„ä½“ï¼Œå› ä¸ºå®ƒä»¬éå¸¸æ–¹ä¾¿ã€‚ç»“æ„ä½“æ˜¯ç”¨å…³é”®å­— <code>struct</code> åˆ›å»ºçš„ã€‚ç»“æ„ä½“çš„åç§°åº”è¯¥ç”¨UpperCamelCase(æ¯ä¸ªå­—ç”¨å¤§å†™å­—æ¯ï¼Œä¸è¦ç”¨ç©ºæ ¼)ã€‚å¦‚æœä½ ç”¨å…¨å°å†™çš„ç»“æ„ï¼Œç¼–è¯‘å™¨ä¼šå‘Šè¯‰ä½ ã€‚</p>
<p>æœ‰ä¸‰ç§ç±»å‹çš„ç»“æ„ã€‚ä¸€ç§æ˜¯ "å•å…ƒç»“æ„"ã€‚å•å…ƒçš„æ„æ€æ˜¯ "æ²¡æœ‰ä»»ä½•ä¸œè¥¿"ã€‚å¯¹äºä¸€ä¸ªå•å…ƒç»“æ„ï¼Œä½ åªéœ€è¦å†™åå­—å’Œä¸€ä¸ªåˆ†å·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct FileDirectory;
fn main() {}</code></pre></pre>
<p>æ¥ä¸‹æ¥æ˜¯ä¸€ä¸ªå…ƒç»„ç»“æ„ï¼Œæˆ–è€…è¯´æ˜¯ä¸€ä¸ªæœªå‘½åç»“æ„ã€‚ä¹‹æ‰€ä»¥æ˜¯ "æœªå‘½å"ï¼Œæ˜¯å› ä¸ºä½ åªéœ€è¦å†™ç±»å‹ï¼Œè€Œä¸æ˜¯å­—æ®µåã€‚å½“ä½ éœ€è¦ä¸€ä¸ªç®€å•çš„ç»“æ„ï¼Œå¹¶ä¸”ä¸éœ€è¦è®°ä½åå­—æ—¶ï¼Œå…ƒç»„ç»“æ„æ˜¯å¾ˆå¥½çš„é€‰æ‹©ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8);

fn main() {
    let my_colour = Colour(50, 0, 50); // Make a colour out of RGB (red, green, blue)
    println!("The second part of the colour is: {}", my_colour.1);
}</code></pre></pre>
<p>è¿™æ—¶æ‰“å°å‡º<code>The second part of the colour is: 0</code>ã€‚</p>
<p>ç¬¬ä¸‰ç§ç±»å‹æ˜¯å‘½åç»“æ„ã€‚è¿™å¯èƒ½æ˜¯æœ€å¸¸è§çš„ç»“æ„ã€‚åœ¨è¿™ä¸ªç»“æ„ä¸­ï¼Œä½ åœ¨ä¸€ä¸ª <code>{}</code> ä»£ç å—ä¸­å£°æ˜å­—æ®µåå’Œç±»å‹ã€‚è¯·æ³¨æ„ï¼Œåœ¨å‘½åç»“æ„åé¢ä¸è¦å†™åˆ†å·ï¼Œå› ä¸ºåé¢æœ‰ä¸€æ•´ä¸ªä»£ç å—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
    size: u32,
    colour: Colour, // And we put it in our new named struct
}

fn main() {
    let my_colour = Colour(50, 0, 50);

    let size_and_colour = SizeAndColour {
        size: 150,
        colour: my_colour
    };
}</code></pre></pre>
<p>åœ¨ä¸€ä¸ªå‘½åç»“æ„ä¸­ï¼Œä½ ä¹Ÿå¯ä»¥ç”¨é€—å·æ¥åˆ†éš”å­—æ®µã€‚å¯¹äºæœ€åä¸€ä¸ªå­—æ®µï¼Œä½ å¯ä»¥åŠ ä¸€ä¸ªé€—å·æˆ–ä¸åŠ --è¿™å–å†³äºä½ ã€‚<code>SizeAndColour</code> åœ¨ <code>colour</code> åé¢æœ‰ä¸€ä¸ªé€—å·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
    size: u32,
    colour: Colour, // And we put it in our new named struct
}

fn main() {}</code></pre></pre>
<p>ä½†ä½ ä¸éœ€è¦å®ƒã€‚ä½†æ€»æ˜¯æ”¾ä¸€ä¸ªé€—å·å¯èƒ½æ˜¯ä¸ªå¥½ä¸»æ„ï¼Œå› ä¸ºæœ‰æ—¶ä½ ä¼šæ”¹å˜å­—æ®µçš„é¡ºåºã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
    size: u32,
    colour: Colour // No comma here
}

fn main() {}</code></pre></pre>
<p>ç„¶åæˆ‘ä»¬å†³å®šæ”¹å˜é¡ºåº...</p>
<pre><pre class="playground"><code class="language-rust">struct SizeAndColour {
    colour: Colour // âš ï¸ Whoops! Now this doesn't have a comma.
    size: u32,
}

fn main() {}</code></pre></pre>
<p>ä½†æ— è®ºå“ªç§æ–¹å¼éƒ½ä¸æ˜¯å¾ˆé‡è¦ï¼Œæ‰€ä»¥ä½ å¯ä»¥é€‰æ‹©æ˜¯å¦ä½¿ç”¨é€—å·ã€‚</p>
<p>æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª<code>Country</code>ç»“æ„æ¥ä¸¾ä¾‹è¯´æ˜ã€‚<code>Country</code>ç»“æ„æœ‰<code>population</code>ã€<code>capital</code>å’Œ<code>leader_name</code>ä¸‰ä¸ªå­—æ®µã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Country {
    population: u32,
    capital: String,
    leader_name: String
}

fn main() {
    let population = 500_000;
    let capital = String::from("Elista");
    let leader_name = String::from("Batu Khasikov");

    let kalmykia = Country {
        population: population,
        capital: capital,
        leader_name: leader_name,
    };
}</code></pre></pre>
<p>ä½ æœ‰æ²¡æœ‰æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬æŠŠåŒæ ·çš„ä¸œè¥¿å†™äº†ä¸¤æ¬¡ï¼Ÿæˆ‘ä»¬å†™äº†<code>population: population</code>ã€<code>capital: capital</code>å’Œ<code>leader_name: leader_name</code>ã€‚å®é™…ä¸Šï¼Œä½ ä¸éœ€è¦è¿™æ ·åš:å¦‚æœå­—æ®µåå’Œå˜é‡åæ˜¯ä¸€æ ·çš„ï¼Œä½ å°±ä¸ç”¨å†™ä¸¤æ¬¡ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Country {
    population: u32,
    capital: String,
    leader_name: String
}

fn main() {
    let population = 500_000;
    let capital = String::from("Elista");
    let leader_name = String::from("Batu Khasikov");

    let kalmykia = Country {
        population,
        capital,
        leader_name,
    };
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æšä¸¾"><a class="header" href="#æšä¸¾">æšä¸¾</a></h2>
<p><code>enum</code>æ˜¯enumerationsçš„ç®€ç§°ã€‚å®ƒä»¬çœ‹èµ·æ¥ä¸ç»“æ„ä½“éå¸¸ç›¸ä¼¼ï¼Œä½†åˆæœ‰æ‰€ä¸åŒã€‚è¿™å°±æ˜¯åŒºåˆ«:</p>
<ul>
<li>å½“ä½ æƒ³è¦ä¸€ä¸ªä¸œè¥¿<strong>å’Œ</strong>å¦ä¸€ä¸ªä¸œè¥¿æ—¶ï¼Œä½¿ç”¨<code>struct</code>.</li>
<li>å½“ä½ æƒ³è¦ä¸€ä¸ªä¸œè¥¿<strong>æˆ–</strong>å¦ä¸€ä¸ªä¸œè¥¿æ—¶ï¼Œè¯·ä½¿ç”¨ <code>enum</code>ã€‚</li>
</ul>
<p>æ‰€ä»¥ï¼Œç»“æ„ä½“æ˜¯ç”¨äº<strong>å¤šä¸ªäº‹ç‰©</strong>åœ¨ä¸€èµ·ï¼Œè€Œæšä¸¾åˆ™æ˜¯ç”¨äº<strong>å¤šä¸ªé€‰æ‹©</strong>åœ¨ä¸€èµ·ã€‚</p>
<p>è¦å£°æ˜ä¸€ä¸ªæšä¸¾ï¼Œè¯·å†™<code>enum</code>ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªåŒ…å«é€‰é¡¹çš„ä»£ç å—ï¼Œç”¨é€—å·åˆ†éš”ã€‚å°±åƒ <code>struct</code> ä¸€æ ·ï¼Œæœ€åä¸€éƒ¨åˆ†å¯ä»¥æœ‰é€—å·ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªåä¸º <code>ThingsInTheSky</code> çš„æšä¸¾ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum ThingsInTheSky {
    Sun,
    Stars,
}

fn main() {}</code></pre></pre>
<p>è¿™æ˜¯ä¸€ä¸ªæšä¸¾ï¼Œå› ä¸ºä½ å¯ä»¥çœ‹åˆ°å¤ªé˜³ï¼Œ<strong>æˆ–</strong>æ˜Ÿæ˜Ÿ:ä½ å¿…é¡»é€‰æ‹©ä¸€ä¸ªã€‚è¿™äº›å«åš<strong>å˜ä½“</strong>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// create the enum with two choices
enum ThingsInTheSky {
    Sun,
    Stars,
}

// With this function we can use an i32 to create ThingsInTheSky.
fn create_skystate(time: i32) -&gt; ThingsInTheSky {
    match time {
        6..=18 =&gt; ThingsInTheSky::Sun, // Between 6 and 18 hours we can see the sun
        _ =&gt; ThingsInTheSky::Stars, // Otherwise, we can see stars
    }
}

// With this function we can match against the two choices in ThingsInTheSky.
fn check_skystate(state: &amp;ThingsInTheSky) {
    match state {
        ThingsInTheSky::Sun =&gt; println!("I can see the sun!"),
        ThingsInTheSky::Stars =&gt; println!("I can see the stars!")
    }
}

fn main() {
    let time = 8; // it's 8 o'clock
    let skystate = create_skystate(time); // create_skystate returns a ThingsInTheSky
    check_skystate(&amp;skystate); // Give it a reference so it can read the variable skystate
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º<code>I can see the sun!</code>ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥å°†æ•°æ®æ·»åŠ åˆ°ä¸€ä¸ªæšä¸¾ä¸­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum ThingsInTheSky {
    Sun(String), // Now each variant has a string
    Stars(String),
}

fn create_skystate(time: i32) -&gt; ThingsInTheSky {
    match time {
        6..=18 =&gt; ThingsInTheSky::Sun(String::from("I can see the sun!")), // Write the strings here
        _ =&gt; ThingsInTheSky::Stars(String::from("I can see the stars!")),
    }
}

fn check_skystate(state: &amp;ThingsInTheSky) {
    match state {
        ThingsInTheSky::Sun(description) =&gt; println!("{}", description), // Give the string the name description so we can use it
        ThingsInTheSky::Stars(n) =&gt; println!("{}", n), // Or you can name it n. Or anything else - it doesn't matter
    }
}

fn main() {
    let time = 8; // it's 8 o'clock
    let skystate = create_skystate(time); // create_skystate returns a ThingsInTheSky
    check_skystate(&amp;skystate); // Give it a reference so it can read the variable skystate
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºæ¥çš„ç»“æœæ˜¯ä¸€æ ·çš„:<code>I can see the sun!</code>ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥ "å¯¼å…¥"ä¸€ä¸ªæšä¸¾ï¼Œè¿™æ ·ä½ å°±ä¸ç”¨æ‰“é‚£ä¹ˆå¤šå­—äº†ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬æ¯æ¬¡åœ¨å¿ƒæƒ…ä¸ŠåŒ¹é…æ—¶éƒ½è¦è¾“å…¥ <code>Mood::</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Mood {
    Happy,
    Sleepy,
    NotBad,
    Angry,
}

fn match_mood(mood: &amp;Mood) -&gt; i32 {
    let happiness_level = match mood {
        Mood::Happy =&gt; 10, // Here we type Mood:: every time
        Mood::Sleepy =&gt; 6,
        Mood::NotBad =&gt; 7,
        Mood::Angry =&gt; 2,
    };
    happiness_level
}

fn main() {
    let my_mood = Mood::NotBad;
    let happiness_level = match_mood(&amp;my_mood);
    println!("Out of 1 to 10, my happiness is {}", happiness_level);
}</code></pre></pre>
<p>å®ƒæ‰“å°çš„æ˜¯<code>Out of 1 to 10, my happiness is 7</code>ã€‚è®©æˆ‘ä»¬å¯¼å…¥ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å°‘æ‰“ç‚¹å­—äº†ã€‚è¦å¯¼å…¥æ‰€æœ‰çš„ä¸œè¥¿ï¼Œå†™<code>*</code>ã€‚æ³¨æ„:å®ƒå’Œ<code>*</code>çš„è§£å¼•ç”¨é”®æ˜¯ä¸€æ ·çš„ï¼Œä½†å®Œå…¨ä¸åŒã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Mood {
    Happy,
    Sleepy,
    NotBad,
    Angry,
}

fn match_mood(mood: &amp;Mood) -&gt; i32 {
    use Mood::*; // We imported everything in Mood. Now we can just write Happy, Sleepy, etc.
    let happiness_level = match mood {
        Happy =&gt; 10, // We don't have to write Mood:: anymore
        Sleepy =&gt; 6,
        NotBad =&gt; 7,
        Angry =&gt; 2,
    };
    happiness_level
}

fn main() {
    let my_mood = Mood::Happy;
    let happiness_level = match_mood(&amp;my_mood);
    println!("Out of 1 to 10, my happiness is {}", happiness_level);
}</code></pre></pre>
<p><code>enum</code> çš„éƒ¨åˆ†ä¹Ÿå¯ä»¥å˜æˆä¸€ä¸ªæ•´æ•°ã€‚è¿™æ˜¯å› ä¸º Rust ç»™ <code>enum</code> çš„æ¯ä¸ªarmæä¾›äº†ä¸€ä¸ªä»¥ 0 å¼€å¤´çš„æ•°å­—ï¼Œä¾›å®ƒè‡ªå·±ä½¿ç”¨ã€‚å¦‚æœä½ çš„æšä¸¾ä¸­æ²¡æœ‰ä»»ä½•å…¶ä»–æ•°æ®ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥åšä¸€äº›äº‹æƒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Season {
    Spring, // If this was Spring(String) or something it wouldn't work
    Summer,
    Autumn,
    Winter,
}

fn main() {
    use Season::*;
    let four_seasons = vec![Spring, Summer, Autumn, Winter];
    for season in four_seasons {
        println!("{}", season as u32);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">0
1
2
3
</code></pre>
<p>ä¸è¿‡å¦‚æœä½ æƒ³çš„è¯ï¼Œä½ å¯ä»¥ç»™å®ƒä¸€ä¸ªä¸åŒçš„æ•°å­—--Rustå¹¶ä¸åœ¨æ„ï¼Œå¯ä»¥ç”¨åŒæ ·çš„æ–¹å¼æ¥ä½¿ç”¨å®ƒã€‚åªéœ€åœ¨ä½ æƒ³è¦çš„å˜ä½“ä¸ŠåŠ ä¸€ä¸ª <code>=</code> å’Œä½ çš„æ•°å­—ã€‚ä½ ä¸å¿…ç»™æ‰€æœ‰çš„éƒ½åˆ†é…ä¸€ä¸ªæ•°å­—ã€‚ä½†å¦‚æœä½ ä¸è¿™æ ·åšï¼ŒRustå°±ä¼šä»å‰ä¸€ä¸ªarmåŠ 1æ¥èµ‹å€¼ç»™å½“å‰armã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Star {
    BrownDwarf = 10,
    RedDwarf = 50,
    YellowStar = 100,
    RedGiant = 1000,
    DeadStar, // Think about this one. What number will it have?
}

fn main() {
    use Star::*;
    let starvec = vec![BrownDwarf, RedDwarf, YellowStar, RedGiant];
    for star in starvec {
        match star as u32 {
            size if size &lt;= 80 =&gt; println!("Not the biggest star."), // Remember: size doesn't mean anything. It's just a name we chose so we can print it
            size if size &gt;= 80 =&gt; println!("This is a good-sized star."),
            _ =&gt; println!("That star is pretty big!"),
        }
    }
    println!("What about DeadStar? It's the number {}.", DeadStar as u32);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Not the biggest star.
Not the biggest star.
This is a good-sized star.
This is a good-sized star.
What about DeadStar? It's the number 1001.
</code></pre>
<p><code>DeadStar</code>æœ¬æ¥æ˜¯4å·ï¼Œä½†ç°åœ¨æ˜¯1001ã€‚</p>
<h3 id="ä½¿ç”¨å¤šç§ç±»å‹çš„æšä¸¾"><a class="header" href="#ä½¿ç”¨å¤šç§ç±»å‹çš„æšä¸¾">ä½¿ç”¨å¤šç§ç±»å‹çš„æšä¸¾</a></h3>
<p>ä½ çŸ¥é“<code>Vec</code>ã€æ•°ç»„ç­‰ä¸­çš„å…ƒç´ éƒ½éœ€è¦ç›¸åŒçš„ç±»å‹(åªæœ‰tupleä¸åŒ)ã€‚ä½†å…¶å®ä½ å¯ä»¥ç”¨ä¸€ä¸ªæšä¸¾æ¥æ”¾ä¸åŒçš„ç±»å‹ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æƒ³æœ‰ä¸€ä¸ª<code>Vec</code>ï¼Œæœ‰<code>u32</code>æˆ–<code>i32</code>ã€‚å½“ç„¶ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ª<code>Vec&lt;(u32, i32)&gt;</code>(ä¸€ä¸ªå¸¦æœ‰<code>(u32, i32)</code>å…ƒç»„çš„vec)ï¼Œä½†æ˜¯æˆ‘ä»¬æ¯æ¬¡åªæƒ³è¦ä¸€ä¸ªã€‚æ‰€ä»¥è¿™é‡Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæšä¸¾ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Number {
    U32(u32),
    I32(i32),
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥æœ‰ä¸¤ä¸ªå˜ä½“:<code>U32</code>å˜ä½“é‡Œé¢æœ‰<code>u32</code>ï¼Œ<code>I32</code>å˜ä½“é‡Œé¢æœ‰<code>i32</code>ã€‚<code>U32</code>å’Œ<code>I32</code>åªæ˜¯æˆ‘ä»¬èµ·çš„åå­—ã€‚å®ƒä»¬å¯èƒ½æ˜¯<code>UThirtyTwo</code>æˆ–<code>IThirtyTwo</code>æˆ–å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚</p>
<p>ç°åœ¨ï¼Œå¦‚æœæˆ‘ä»¬æŠŠå®ƒä»¬æ”¾åˆ° <code>Vec</code> ä¸­ï¼Œæˆ‘ä»¬å°±ä¼šæœ‰ä¸€ä¸ª <code>Vec&lt;Number&gt;</code>ï¼Œç¼–è¯‘å™¨å¾ˆé«˜å…´ï¼Œå› ä¸ºéƒ½æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚ç¼–è¯‘å™¨å¹¶ä¸åœ¨ä¹æˆ‘ä»¬æœ‰ <code>u32</code> æˆ– <code>i32</code>ï¼Œå› ä¸ºå®ƒä»¬éƒ½åœ¨ä¸€ä¸ªå«åš <code>Number</code> çš„å•ä¸€ç±»å‹é‡Œé¢ã€‚å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªæšä¸¾ï¼Œä½ å¿…é¡»é€‰æ‹©ä¸€ä¸ªï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨<code>.is_positive()</code>æ–¹æ³•æ¥æŒ‘é€‰ã€‚å¦‚æœæ˜¯ <code>true</code>ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†é€‰æ‹© <code>U32</code>ï¼Œå¦‚æœæ˜¯ <code>false</code>ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†é€‰æ‹© <code>I32</code>ã€‚</p>
<p>ç°åœ¨çš„ä»£ç æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Number {
    U32(u32),
    I32(i32),
}

fn get_number(input: i32) -&gt; Number {
    let number = match input.is_positive() {
        true =&gt; Number::U32(input as u32), // change it to u32 if it's positive
        false =&gt; Number::I32(input), // otherwise just give the number because it's already i32
    };
    number
}


fn main() {
    let my_vec = vec![get_number(-800), get_number(8)];

    for item in my_vec {
        match item {
            Number::U32(number) =&gt; println!("It's a u32 with the value {}", number),
            Number::I32(number) =&gt; println!("It's an i32 with the value {}", number),
        }
    }
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡ºäº†æˆ‘ä»¬æƒ³çœ‹åˆ°çš„ä¸œè¥¿ã€‚</p>
<pre><code class="language-text">It's an i32 with the value -800
It's a u32 with the value 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¾ªç¯"><a class="header" href="#å¾ªç¯">å¾ªç¯</a></h2>
<p>æœ‰äº†å¾ªç¯ï¼Œä½ å¯ä»¥å‘Šè¯‰ Rust ç»§ç»­æŸäº‹ï¼Œç›´åˆ°ä½ æƒ³è®©å®ƒåœæ­¢ã€‚æ‚¨ä½¿ç”¨ <code>loop</code> æ¥å¯åŠ¨ä¸€ä¸ªä¸ä¼šåœæ­¢çš„å¾ªç¯ï¼Œé™¤éæ‚¨å‘Šè¯‰å®ƒä½•æ—¶<code>break</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() { // This program will never stop
    loop {

    }
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œæˆ‘ä»¬è¦å‘Šè¯‰ç¼–è¯‘å™¨ä»€ä¹ˆæ—¶å€™èƒ½åœæ­¢:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0; // set a counter to 0
    loop {
        counter +=1; // increase the counter by 1
        println!("The counter is now: {}", counter);
        if counter == 5 { // stop when counter == 5
            break;
        }
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">The counter is now: 1
The counter is now: 2
The counter is now: 3
The counter is now: 4
The counter is now: 5
</code></pre>
<p>å¦‚æœä½ åœ¨ä¸€ä¸ªå¾ªç¯é‡Œé¢æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œä½ å¯ä»¥ç»™å®ƒä»¬å‘½åã€‚æœ‰äº†åå­—ï¼Œä½ å¯ä»¥å‘Šè¯‰ Rust è¦ä»å“ªä¸ªå¾ªç¯ä¸­ <code>break</code> å‡ºæ¥ã€‚ä½¿ç”¨ <code>'</code> (ç§°ä¸º "tick") å’Œ <code>:</code> æ¥ç»™å®ƒå‘½åã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;
    let mut counter2 = 0;
    println!("Now entering the first loop.");

    'first_loop: loop {
        // Give the first loop a name
        counter += 1;
        println!("The counter is now: {}", counter);
        if counter &gt; 9 {
            // Starts a second loop inside this loop
            println!("Now entering the second loop.");

            'second_loop: loop {
                // now we are inside 'second_loop
                println!("The second counter is now: {}", counter2);
                counter2 += 1;
                if counter2 == 3 {
                    break 'first_loop; // Break out of 'first_loop so we can exit the program
                }
            }
        }
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">Now entering the first loop.
The counter is now: 1
The counter is now: 2
The counter is now: 3
The counter is now: 4
The counter is now: 5
The counter is now: 6
The counter is now: 7
The counter is now: 8
The counter is now: 9
The counter is now: 10
Now entering the second loop.
The second counter is now: 0
The second counter is now: 1
The second counter is now: 2
</code></pre>
<p><code>while</code>å¾ªç¯æ˜¯æŒ‡åœ¨æŸä»¶äº‹æƒ…è¿˜åœ¨<code>true</code>æ—¶ç»§ç»­çš„å¾ªç¯ã€‚æ¯ä¸€æ¬¡å¾ªç¯ï¼ŒRust éƒ½ä¼šæ£€æŸ¥å®ƒæ˜¯å¦ä»ç„¶æ˜¯ <code>true</code>ã€‚å¦‚æœå˜æˆ<code>false</code>ï¼ŒRustä¼šåœæ­¢å¾ªç¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    while counter &lt; 5 {
        counter +=1;
        println!("The counter is now: {}", counter);
    }
}</code></pre></pre>
<p><code>for</code>å¾ªç¯å¯ä»¥è®©ä½ å‘Šè¯‰Rustæ¯æ¬¡è¦åšä»€ä¹ˆã€‚ä½†æ˜¯åœ¨ <code>for</code> å¾ªç¯ä¸­ï¼Œå¾ªç¯ä¼šåœ¨ä¸€å®šæ¬¡æ•°ååœæ­¢ã€‚<code>for</code>å¾ªç¯ç»å¸¸ä½¿ç”¨<strong>èŒƒå›´</strong>ã€‚ä½ ä½¿ç”¨ <code>..</code> å’Œ <code>..=</code> æ¥åˆ›å»ºä¸€ä¸ªèŒƒå›´ã€‚</p>
<ul>
<li><code>..</code>åˆ›å»ºä¸€ä¸ª<strong>æ’ä»–çš„</strong>èŒƒå›´:<code>0..3</code>åˆ›å»ºäº†<code>0, 1, 2</code>.</li>
<li><code>..=</code>åˆ›å»ºä¸€ä¸ª<strong>åŒ…å«çš„</strong>èŒƒå›´: <code>0..=3</code>åˆ›å»º<code>0, 1, 2</code>ã€‚<code>0..=3</code> = <code>0, 1, 2, 3</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in 0..3 {
        println!("The number is: {}", number);
    }

    for number in 0..=3 {
        println!("The next number is: {}", number);
    }
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">The number is: 0
The number is: 1
The number is: 2
The next number is: 0
The next number is: 1
The next number is: 2
The next number is: 3
</code></pre>
<p>åŒæ—¶æ³¨æ„åˆ°ï¼Œ<code>number</code>æˆä¸º0..3çš„å˜é‡åã€‚æˆ‘ä»¬å¯ä»¥æŠŠå®ƒå«åš <code>n</code>ï¼Œæˆ–è€… <code>ntod_het___hno_f</code>ï¼Œæˆ–è€…ä»»ä½•åå­—ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨<code>println!</code>ä¸­ä½¿ç”¨è¿™ä¸ªåå­—ã€‚</p>
<p>å¦‚æœä½ ä¸éœ€è¦å˜é‡åï¼Œå°±ç”¨<code>_</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..3 {
        println!("Printing the same thing three times");
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Printing the same thing three times
Printing the same thing three times
Printing the same thing three times
</code></pre>
<p>å› ä¸ºæˆ‘ä»¬æ¯æ¬¡éƒ½æ²¡æœ‰ç»™å®ƒä»»ä½•æ•°å­—æ¥æ‰“å°ã€‚</p>
<p>è€Œå®é™…ä¸Šï¼Œå¦‚æœä½ ç»™äº†ä¸€ä¸ªå˜é‡åå´ä¸ç”¨ï¼ŒRustä¼šå‘Šè¯‰ä½ :</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in 0..3 {
        println!("Printing the same thing three times");
    }
}</code></pre></pre>
<p>è¿™æ‰“å°çš„å†…å®¹å’Œä¸Šé¢ä¸€æ ·ã€‚ç¨‹åºç¼–è¯‘æ­£å¸¸ï¼Œä½†Rustä¼šæé†’ä½ æ²¡æœ‰ä½¿ç”¨<code>number</code>:</p>
<pre><code class="language-text">warning: unused variable: `number`
 --&gt; src\main.rs:2:9
  |
2 |     for number in 0..3 {
  |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_number`
</code></pre>
<p>Rust å»ºè®®å†™ <code>_number</code> è€Œä¸æ˜¯ <code>_</code>ã€‚åœ¨å˜é‡åå‰åŠ ä¸Š <code>_</code> æ„å‘³ç€ "ä¹Ÿè®¸æˆ‘ä»¥åä¼šç”¨åˆ°å®ƒ"ã€‚ä½†æ˜¯åªç”¨<code>_</code>æ„å‘³ç€ "æˆ‘æ ¹æœ¬ä¸å…³å¿ƒè¿™ä¸ªå˜é‡"ã€‚æ‰€ä»¥ï¼Œå¦‚æœä½ ä»¥åä¼šä½¿ç”¨å®ƒä»¬ï¼Œå¹¶ä¸”ä¸æƒ³è®©ç¼–è¯‘å™¨å‘Šè¯‰ä½ ï¼Œä½ å¯ä»¥åœ¨å˜é‡åå‰é¢åŠ ä¸Š<code>_</code>ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥ç”¨<code>break</code>æ¥è¿”å›ä¸€ä¸ªå€¼ã€‚
ä½ æŠŠå€¼å†™åœ¨ <code>break</code> ä¹‹åï¼Œå¹¶ä½¿ç”¨ <code>;</code>ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç”¨ <code>loop</code> å’Œä¸€ä¸ªæ–­ç‚¹ç»™å‡º <code>my_number</code> å€¼çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 5;
    let my_number = loop {
        counter +=1;
        if counter % 53 == 3 {
            break counter;
        }
    };
    println!("{}", my_number);
}</code></pre></pre>
<p>è¿™æ—¶æ‰“å°å‡º<code>56</code>ã€‚<code>break counter;</code>çš„æ„æ€æ˜¯ "ä¸­æ–­å¹¶è¿”å›è®¡æ•°å™¨çš„å€¼"ã€‚è€Œä¸”å› ä¸ºæ•´ä¸ªå—ä»¥<code>let</code>å¼€å§‹ï¼Œæ‰€ä»¥<code>my_number</code>å¾—åˆ°å€¼ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬çŸ¥é“äº†å¦‚ä½•ä½¿ç”¨å¾ªç¯ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæ›´å¥½çš„è§£å†³æ–¹æ¡ˆæ¥è§£å†³æˆ‘ä»¬ä¹‹å‰çš„é¢œè‰² "åŒ¹é…"é—®é¢˜ã€‚è¿™æ˜¯ä¸€ä¸ªæ›´å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œå› ä¸ºæˆ‘ä»¬è¦æ¯”è¾ƒæ‰€æœ‰çš„ä¸œè¥¿ï¼Œè€Œ "for"å¾ªç¯ä¼šæŸ¥çœ‹æ¯ä¸€é¡¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn match_colours(rbg: (i32, i32, i32)) {
    println!("Comparing a colour with {} red, {} blue, and {} green:", rbg.0, rbg.1, rbg.2);
    let new_vec = vec![(rbg.0, "red"), (rbg.1, "blue"), (rbg.2, "green")]; // Put the colours in a vec. Inside are tuples with the colour names
    let mut all_have_at_least_10 = true; // Start with true. We will set it to false if one colour is less than 10
    for item in new_vec {
        if item.0 &lt; 10 {
            all_have_at_least_10 = false; // Now it's false
            println!("Not much {}.", item.1) // And we print the colour name.
        }
    }
    if all_have_at_least_10 { // Check if it's still true, and print if true
        println!("Each colour has at least 10.")
    }
    println!(); // Add one more line
}

fn main() {
    let first = (200, 0, 0);
    let second = (50, 50, 50);
    let third = (200, 50, 0);

    match_colours(first);
    match_colours(second);
    match_colours(third);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Comparing a colour with 200 red, 0 blue, and 0 green:
Not much blue.
Not much green.

Comparing a colour with 50 red, 50 blue, and 50 green:
Each colour has at least 10.

Comparing a colour with 200 red, 50 blue, and 0 green:
Not much green.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å®ç°ç»“æ„ä½“å’Œæšä¸¾"><a class="header" href="#å®ç°ç»“æ„ä½“å’Œæšä¸¾">å®ç°ç»“æ„ä½“å’Œæšä¸¾</a></h2>
<p>åœ¨è¿™é‡Œä½ å¯ä»¥å¼€å§‹èµ‹äºˆä½ çš„ç»“æ„ä½“å’Œæšä¸¾ä¸€äº›çœŸæ­£çš„åŠ›é‡ã€‚è¦è°ƒç”¨ <code>struct</code> æˆ– <code>enum</code> ä¸Šçš„å‡½æ•°ï¼Œè¯·ä½¿ç”¨ <code>impl</code> å—ã€‚è¿™äº›å‡½æ•°è¢«ç§°ä¸º<strong>æ–¹æ³•</strong>ã€‚<code>impl</code>å—ä¸­æœ‰ä¸¤ç§æ–¹æ³•ã€‚</p>
<ul>
<li>æ–¹æ³•ï¼šè¿™äº›æ–¹æ³•å–<strong>self</strong>ï¼ˆæˆ– <strong>&amp;self</strong> æˆ– <strong>&amp;mut self</strong> ï¼‰ã€‚å¸¸è§„æ–¹æ³•ä½¿ç”¨"."ï¼ˆä¸€ä¸ªå¥å·ï¼‰ã€‚<code>.clone()</code>æ˜¯ä¸€ä¸ªå¸¸è§„æ–¹æ³•çš„ä¾‹å­ã€‚</li>
<li>å…³è”å‡½æ•°ï¼ˆåœ¨æŸäº›è¯­è¨€ä¸­è¢«ç§°ä¸º "é™æ€ "æ–¹æ³•ï¼‰ï¼šè¿™äº›å‡½æ•°ä¸ä½¿ç”¨selfã€‚å…³è”çš„æ„æ€æ˜¯ "ä¸ä¹‹ç›¸å…³"ã€‚å®ƒä»¬çš„ä¹¦å†™æ–¹å¼ä¸åŒï¼Œä½¿ç”¨<code>::</code>ã€‚<code>String::from()</code>æ˜¯ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œ<code>Vec::new()</code>ä¹Ÿæ˜¯ã€‚ä½ çœ‹åˆ°çš„å…³è”å‡½æ•°æœ€å¸¸è¢«ç”¨æ¥åˆ›å»ºæ–°çš„å˜é‡ã€‚</li>
</ul>
<p>åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»ºAnimalå¹¶æ‰“å°å®ƒä»¬ã€‚</p>
<p>å¯¹äºæ–°çš„<code>struct</code>æˆ–<code>enum</code>ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨<code>{:?}</code>æ¥æ‰“å°ï¼Œä½ éœ€è¦ç»™å®ƒ<strong>Debug</strong>ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†è¿™æ ·åš:å¦‚æœä½ åœ¨ç»“æ„ä½“æˆ–æšä¸¾ä¸Šé¢å†™äº†<code>#[derive(Debug)]</code>ï¼Œé‚£ä¹ˆä½ å°±å¯ä»¥ç”¨<code>{:?}</code>æ¥æ‰“å°ã€‚è¿™äº›å¸¦æœ‰<code>#[]</code>çš„ä¿¡æ¯è¢«ç§°ä¸º<strong>å±æ€§</strong>ã€‚ä½ æœ‰æ—¶å¯ä»¥ç”¨å®ƒä»¬æ¥å‘Šè¯‰ç¼–è¯‘å™¨ç»™ä½ çš„ç»“æ„ä½“ä¸€ä¸ªèƒ½åŠ›ï¼Œæ¯”å¦‚<code>Debug</code>ã€‚å±æ€§æœ‰å¾ˆå¤šï¼Œæˆ‘ä»¬ä»¥åä¼šå­¦ä¹ å®ƒä»¬ã€‚ä½†æ˜¯<code>derive</code>å¯èƒ½æ˜¯æœ€å¸¸è§çš„ï¼Œä½ ç»å¸¸åœ¨ç»“æ„ä½“å’Œæšä¸¾ä¸Šé¢çœ‹åˆ°å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Animal {
    age: u8,
    animal_type: AnimalType,
}

#[derive(Debug)]
enum AnimalType {
    Cat,
    Dog,
}

impl Animal {
    fn new() -&gt; Self {
        // Self means Animal.
        //You can also write Animal instead of Self

        Self {
            // When we write Animal::new(), we always get a cat that is 10 years old
            age: 10,
            animal_type: AnimalType::Cat,
        }
    }

    fn change_to_dog(&amp;mut self) { // because we are inside Animal, &amp;mut self means &amp;mut Animal
                                  // use .change_to_dog() to change the cat to a dog
                                  // with &amp;mut self we can change it
        println!("Changing animal to dog!");
        self.animal_type = AnimalType::Dog;
    }

    fn change_to_cat(&amp;mut self) {
        // use .change_to_cat() to change the dog to a cat
        // with &amp;mut self we can change it
        println!("Changing animal to cat!");
        self.animal_type = AnimalType::Cat;
    }

    fn check_type(&amp;self) {
        // we want to read self
        match self.animal_type {
            AnimalType::Dog =&gt; println!("The animal is a dog"),
            AnimalType::Cat =&gt; println!("The animal is a cat"),
        }
    }
}



fn main() {
    let mut new_animal = Animal::new(); // Associated function to create a new animal
                                        // It is a cat, 10 years old
    new_animal.check_type();
    new_animal.change_to_dog();
    new_animal.check_type();
    new_animal.change_to_cat();
    new_animal.check_type();
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">The animal is a cat
Changing animal to dog!
The animal is a dog
Changing animal to cat!
The animal is a cat
</code></pre>
<p>è®°ä½ï¼ŒSelf(ç±»å‹Self)å’Œself(å˜é‡self)æ˜¯ç¼©å†™ã€‚(ç¼©å†™=ç®€å†™æ–¹å¼)</p>
<p>æ‰€ä»¥ï¼Œåœ¨æˆ‘ä»¬çš„ä»£ç ä¸­ï¼ŒSelf = Animalã€‚å¦å¤–ï¼Œ<code>fn change_to_dog(&amp;mut self)</code>çš„æ„æ€æ˜¯<code>fn change_to_dog(&amp;mut Animal)</code>ã€‚</p>
<p>ä¸‹é¢å†ä¸¾ä¸€ä¸ªå°ä¾‹å­ã€‚è¿™æ¬¡æˆ‘ä»¬å°†åœ¨<code>enum</code>ä¸Šä½¿ç”¨<code>impl</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Mood {
    Good,
    Bad,
    Sleepy,
}

impl Mood {
    fn check(&amp;self) {
        match self {
            Mood::Good =&gt; println!("Feeling good!"),
            Mood::Bad =&gt; println!("Eh, not feeling so good"),
            Mood::Sleepy =&gt; println!("Need sleep NOW"),
        }
    }
}

fn main() {
    let my_mood = Mood::Sleepy;
    my_mood.check();
}</code></pre></pre>
<p>æ‰“å°å‡º<code>Need sleep NOW</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="è§£æ„"><a class="header" href="#è§£æ„">è§£æ„</a></h2>
<p>æˆ‘ä»¬å†æ¥çœ‹ä¸€äº›è§£æ„ã€‚ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨<code>let</code>å€’è¿‡æ¥ä»ä¸€ä¸ªç»“æ„ä½“æˆ–æšä¸¾ä¸­è·å–å€¼ã€‚æˆ‘ä»¬äº†è§£åˆ°è¿™æ˜¯<code>destructuring</code>ï¼Œå› ä¸ºä½ å¾—åˆ°çš„å˜é‡ä¸æ˜¯ç»“æ„ä½“çš„ä¸€éƒ¨åˆ†ã€‚ç°åœ¨ä½ åˆ†åˆ«å¾—åˆ°äº†å®ƒä»¬çš„å€¼ã€‚é¦–å…ˆæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Person { // make a simple struct for a person
    name: String,
    real_name: String,
    height: u8,
    happiness: bool
}

fn main() {
    let papa_doc = Person { // create variable papa_doc
        name: "Papa Doc".to_string(),
        real_name: "Clarence".to_string(),
        height: 170,
        happiness: false
    };

    let Person { // destructure papa_doc
        name: a,
        real_name: b,
        height: c,
        happiness: d
    } = papa_doc;

    println!("They call him {} but his real name is {}. He is {} cm tall and is he happy? {}", a, b, c, d);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:<code>They call him Papa Doc but his real name is Clarence. He is 170 cm tall and is he happy? false</code></p>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œè¿™æ˜¯å€’è¿‡æ¥çš„ã€‚é¦–å…ˆæˆ‘ä»¬è¯´<code>let papa_doc = Person { fields }</code>æ¥åˆ›å»ºç»“æ„ã€‚ç„¶åæˆ‘ä»¬è¯´ <code>let Person { fields } = papa_doc</code> æ¥è§£æ„å®ƒã€‚</p>
<p>ä½ ä¸å¿…å†™<code>name: a</code>--ä½ å¯ä»¥ç›´æ¥å†™<code>name</code>ã€‚ä½†è¿™é‡Œæˆ‘ä»¬å†™ <code>name: a</code> æ˜¯å› ä¸ºæˆ‘ä»¬æƒ³ä½¿ç”¨ä¸€ä¸ªåå­—ä¸º <code>a</code> çš„å˜é‡ã€‚</p>
<p>ç°åœ¨å†ä¸¾ä¸€ä¸ªæ›´å¤§çš„ä¾‹å­ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª <code>City</code> ç»“æ„ã€‚æˆ‘ä»¬ç»™å®ƒä¸€ä¸ª<code>new</code>å‡½æ•°æ¥åˆ›å»ºå®ƒã€‚ç„¶åæˆ‘ä»¬æœ‰ä¸€ä¸ª <code>process_city_values</code> å‡½æ•°æ¥å¤„ç†è¿™äº›å€¼ã€‚åœ¨å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯åˆ›å»ºäº†ä¸€ä¸ª <code>Vec</code>ï¼Œä½†ä½ å¯ä»¥æƒ³è±¡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è§£æ„å®ƒä¹‹ååšæ›´å¤šçš„äº‹æƒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct City {
    name: String,
    name_before: String,
    population: u32,
    date_founded: u32,
}

impl City {
    fn new(name: String, name_before: String, population: u32, date_founded: u32) -&gt; Self {
        Self {
            name,
            name_before,
            population,
            date_founded,
        }
    }
}

fn process_city_values(city: &amp;City) {
    let City {
        name,
        name_before,
        population,
        date_founded,
    } = city;
        // now we have the values to use separately
    let two_names = vec![name, name_before];
    println!("The city's two names are {:?}", two_names);
}

fn main() {
    let tallinn = City::new("Tallinn".to_string(), "Reval".to_string(), 426_538, 1219);
    process_city_values(&amp;tallinn);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º<code>The city's two names are ["Tallinn", "Reval"]</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¼•ç”¨å’Œç‚¹è¿ç®—ç¬¦"><a class="header" href="#å¼•ç”¨å’Œç‚¹è¿ç®—ç¬¦">å¼•ç”¨å’Œç‚¹è¿ç®—ç¬¦</a></h2>
<p>æˆ‘ä»¬äº†è§£åˆ°ï¼Œå½“ä½ æœ‰ä¸€ä¸ªå¼•ç”¨æ—¶ï¼Œä½ éœ€è¦ä½¿ç”¨<code>*</code>æ¥è·å–å€¼ã€‚å¼•ç”¨æ˜¯ä¸€ç§ä¸åŒçš„ç±»å‹ï¼Œæ‰€ä»¥è¿™æ˜¯æ— æ³•è¿è¡Œçš„:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 9;
    let reference = &amp;my_number;

    println!("{}", my_number == reference); // âš ï¸
}</code></pre></pre>
<p>ç¼–è¯‘å™¨æ‰“å°ã€‚</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src\main.rs:5:30
  |
5 |     println!("{}", my_number == reference);
  |                              ^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>æ‰€ä»¥æˆ‘ä»¬æŠŠç¬¬5è¡Œæ”¹æˆ<code>println!("{}", my_number == *reference);</code>ï¼Œç°åœ¨æ‰“å°çš„æ˜¯<code>true</code>ï¼Œå› ä¸ºç°åœ¨æ˜¯<code>i32</code> == <code>i32</code>ï¼Œè€Œä¸æ˜¯<code>i32</code> == <code>&amp;i32</code>ã€‚è¿™å°±æ˜¯æ‰€è°“çš„è§£å¼•ç”¨ã€‚</p>
<p>ä½†æ˜¯å½“ä½ ä½¿ç”¨ä¸€ä¸ªæ–¹æ³•æ—¶ï¼ŒRustä¼šä¸ºä½ è§£é™¤å¼•ç”¨ã€‚æ–¹æ³•ä¸­çš„ <code>.</code> è¢«ç§°ä¸ºç‚¹è¿ç®—ç¬¦ï¼Œå®ƒå¯ä»¥å…è´¹è¿›è¡Œé€’å½’ã€‚</p>
<p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæœ‰ä¸€ä¸ª <code>u8</code> å­—æ®µçš„ç»“æ„ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†å¯¹å®ƒè¿›è¡Œå¼•ç”¨ï¼Œå¹¶å°è¯•è¿›è¡Œæ¯”è¾ƒã€‚å®ƒå°†æ— æ³•å·¥ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    number: u8,
}

fn main() {
    let item = Item {
        number: 8,
    };

    let reference_number = &amp;item.number; // reference number type is &amp;u8

    println!("{}", reference_number == 8); // âš ï¸ &amp;u8 and u8 cannot be compared
}</code></pre></pre>
<p>ä¸ºäº†è®©å®ƒå·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦å–æ¶ˆå®šä¹‰ã€‚<code>println!("{}", *reference_number == 8);</code>.</p>
<p>ä½†å¦‚æœä½¿ç”¨ç‚¹è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬ä¸éœ€è¦<code>*</code>ã€‚ä¾‹å¦‚</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    number: u8,
}

fn main() {
    let item = Item {
        number: 8,
    };

    let reference_item = &amp;item;

    println!("{}", reference_item.number == 8); // we don't need to write *reference_item.number
}</code></pre></pre>
<p>ç°åœ¨è®©æˆ‘ä»¬ä¸º <code>Item</code> åˆ›å»ºä¸€ä¸ªæ–¹æ³•ï¼Œå°† <code>number</code> ä¸å¦ä¸€ä¸ªæ•°å­—è¿›è¡Œæ¯”è¾ƒã€‚æˆ‘ä»¬ä¸éœ€è¦åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨ <code>*</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Item {
    number: u8,
}

impl Item {
    fn compare_number(&amp;self, other_number: u8) { // takes a reference to self
        println!("Are {} and {} equal? {}", self.number, other_number, self.number == other_number);
            // We don't need to write *self.number
    }
}

fn main() {
    let item = Item {
        number: 8,
    };

    let reference_item = &amp;item; // This is type &amp;Item
    let reference_item_two = &amp;reference_item; // This is type &amp;&amp;Item

    item.compare_number(8); // the method works
    reference_item.compare_number(8); // it works here too
    reference_item_two.compare_number(8); // and here

}</code></pre></pre>
<p>æ‰€ä»¥åªè¦è®°ä½:å½“ä½ ä½¿ç”¨<code>.</code>è¿ç®—ç¬¦æ—¶ï¼Œä½ ä¸éœ€è¦æ‹…å¿ƒ<code>*</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ³›å‹"><a class="header" href="#æ³›å‹">æ³›å‹</a></h2>
<p>åœ¨å‡½æ•°ä¸­ï¼Œä½ è¦å†™å‡ºé‡‡å–ä»€ä¹ˆç±»å‹ä½œä¸ºè¾“å…¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn return_number(number: i32) -&gt; i32 {
    println!("Here is your number.");
    number
}

fn main() {
    let number = return_number(5);
}</code></pre></pre>
<p>ä½†æ˜¯å¦‚æœä½ æƒ³ç”¨çš„ä¸ä»…ä»…æ˜¯<code>i32</code>å‘¢ï¼Ÿä½ å¯ä»¥ç”¨æ³›å‹æ¥è§£å†³ã€‚Genericsçš„æ„æ€æ˜¯ "ä¹Ÿè®¸æ˜¯ä¸€ç§ç±»å‹ï¼Œä¹Ÿè®¸æ˜¯å¦ä¸€ç§ç±»å‹"ã€‚</p>
<p>å¯¹äºæ³›å‹ï¼Œä½ å¯ä»¥ä½¿ç”¨è§’æ‹¬å·ï¼Œé‡Œé¢åŠ ä¸Šç±»å‹ï¼Œåƒè¿™æ ·ã€‚<code>&lt;T&gt;</code> è¿™æ„å‘³ç€ "ä»»ä½•ç±»å‹ä½ éƒ½å¯ä»¥æ”¾å…¥å‡½æ•°ä¸­" é€šå¸¸æƒ…å†µä¸‹ï¼Œgenericsä½¿ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯çš„ç±»å‹(Tã€Uã€Vç­‰)ï¼Œå°½ç®¡ä½ ä¸å¿…åªä½¿ç”¨ä¸€ä¸ªå­—æ¯ã€‚</p>
<p>è¿™å°±æ˜¯ä½ å¦‚ä½•æ”¹å˜å‡½æ•°ä½¿å…¶é€šç”¨çš„æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn return_number&lt;T&gt;(number: T) -&gt; T {
    println!("Here is your number.");
    number
}

fn main() {
    let number = return_number(5);
}</code></pre></pre>
<p>é‡è¦çš„éƒ¨åˆ†æ˜¯å‡½æ•°ååçš„<code>&lt;T&gt;</code>ã€‚å¦‚æœæ²¡æœ‰è¿™ä¸ªï¼ŒRustä¼šè®¤ä¸ºTæ˜¯ä¸€ä¸ªå…·ä½“çš„(å…·ä½“çš„=ä¸æ˜¯é€šç”¨çš„)ç±»å‹ã€‚
å¦‚<code>String</code>æˆ–<code>i8</code>ã€‚</p>
<p>å¦‚æœæˆ‘ä»¬å†™å‡ºä¸€ä¸ªç±»å‹åï¼Œè¿™å°±æ›´å®¹æ˜“ç†è§£äº†ã€‚çœ‹çœ‹æˆ‘ä»¬æŠŠ <code>T</code> æ”¹æˆ <code>MyType</code> ä¼šå‘ç”Ÿä»€ä¹ˆã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_number(number: MyType) -&gt; MyType { // âš ï¸
    println!("Here is your number.");
    number
}
<span class="boring">}</span></code></pre></pre>
<p>å¤§å®¶å¯ä»¥çœ‹åˆ°ï¼Œ<code>MyType</code>æ˜¯å…·ä½“çš„ï¼Œä¸æ˜¯é€šç”¨çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦å†™è¿™ä¸ªï¼Œæ‰€ä»¥ç°åœ¨å°±å¯ä»¥äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn return_number&lt;MyType&gt;(number: MyType) -&gt; MyType {
    println!("Here is your number.");
    number
}

fn main() {
    let number = return_number(5);
}</code></pre></pre>
<p>æ‰€ä»¥å•å­—æ¯<code>T</code>æ˜¯äººçš„çœ¼ç›ï¼Œä½†å‡½æ•°ååé¢çš„éƒ¨åˆ†æ˜¯ç¼–è¯‘å™¨çš„ "çœ¼ç›"ã€‚æ²¡æœ‰äº†å®ƒï¼Œå°±ä¸é€šç”¨äº†ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬å†å›åˆ°ç±»å‹<code>T</code>ï¼Œå› ä¸ºRustä»£ç é€šå¸¸ä½¿ç”¨<code>T</code>ã€‚</p>
<p>ä½ ä¼šè®°å¾—Rustä¸­æœ‰äº›ç±»å‹æ˜¯<strong>Copy</strong>ï¼Œæœ‰äº›æ˜¯<strong>Clone</strong>ï¼Œæœ‰äº›æ˜¯<strong>Display</strong>ï¼Œæœ‰äº›æ˜¯<strong>Debug</strong>ï¼Œç­‰ç­‰ã€‚ç”¨<strong>Debug</strong>ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨<code>{:?}</code>æ¥æ‰“å°ã€‚æ‰€ä»¥ç°åœ¨å¤§å®¶å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å¦‚æœè¦æ‰“å°<code>T</code>å°±æœ‰é—®é¢˜äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn print_number&lt;T&gt;(number: T) {
    println!("Here is your number: {:?}", number); // âš ï¸
}

fn main() {
    print_number(5);
}</code></pre></pre>
<p><code>print_number</code>éœ€è¦<strong>Debug</strong>æ‰“å°<code>number</code>ï¼Œä½†æ˜¯<code>T</code>ä¸<code>Debug</code>æ˜¯ä¸€ä¸ªç±»å‹å—ï¼Ÿä¹Ÿè®¸ä¸æ˜¯ã€‚ä¹Ÿè®¸å®ƒæ²¡æœ‰<code>#[derive(Debug)]</code>ï¼Œè°çŸ¥é“å‘¢ï¼Ÿç¼–è¯‘å™¨ä¹Ÿä¸çŸ¥é“ï¼Œæ‰€ä»¥å®ƒç»™å‡ºäº†ä¸€ä¸ªé”™è¯¯ã€‚</p>
<pre><code class="language-text">error[E0277]: `T` doesn't implement `std::fmt::Debug`
  --&gt; src\main.rs:29:43
   |
29 |     println!("Here is your number: {:?}", number);
   |                                           ^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`
</code></pre>
<p>Tæ²¡æœ‰å®ç°<strong>Debug</strong>ã€‚é‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦è¦ä¸ºTå®ç°Debugå‘¢ï¼Ÿä¸ï¼Œå› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“Tæ˜¯ä»€ä¹ˆã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥å‘Šè¯‰å‡½æ•°ã€‚"åˆ«æ‹…å¿ƒï¼Œå› ä¸ºä»»ä½•Tç±»å‹çš„å‡½æ•°éƒ½ä¼šæœ‰Debug"</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug; // Debug is located at std::fmt::Debug. So now we can just write 'Debug'.

fn print_number&lt;T: Debug&gt;(number: T) { // &lt;T: Debug&gt; is the important part
    println!("Here is your number: {:?}", number);
}

fn main() {
    print_number(5);
}</code></pre></pre>
<p>æ‰€ä»¥ç°åœ¨ç¼–è¯‘å™¨çŸ¥é“:"å¥½çš„ï¼Œè¿™ä¸ªç±»å‹Tè¦æœ‰Debug"ã€‚ç°åœ¨ä»£ç å·¥ä½œäº†ï¼Œå› ä¸º<code>i32</code>æœ‰Debugã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»™å®ƒå¾ˆå¤šç±»å‹ã€‚<code>String</code>, <code>&amp;str</code>, ç­‰ç­‰ï¼Œå› ä¸ºå®ƒä»¬éƒ½æœ‰Debug.</p>
<p>ç°åœ¨æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªç»“æ„ï¼Œå¹¶ç”¨#[derive(Debug)]ç»™å®ƒDebugï¼Œæ‰€ä»¥ç°åœ¨æˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰“å°å®ƒã€‚æˆ‘ä»¬çš„å‡½æ•°å¯ä»¥å–<code>i32</code>ï¼ŒAnimalç»“æ„ç­‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

#[derive(Debug)]
struct Animal {
    name: String,
    age: u8,
}

fn print_item&lt;T: Debug&gt;(item: T) {
    println!("Here is your item: {:?}", item);
}

fn main() {
    let charlie = Animal {
        name: "Charlie".to_string(),
        age: 1,
    };

    let number = 55;

    print_item(charlie);
    print_item(number);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Here is your item: Animal { name: "Charlie", age: 1 }
Here is your item: 55
</code></pre>
<p>æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬åœ¨ä¸€ä¸ªé€šç”¨å‡½æ•°ä¸­éœ€è¦ä¸æ­¢ä¸€ä¸ªç±»å‹ã€‚æˆ‘ä»¬å¿…é¡»å†™å‡ºæ¯ä¸ªç±»å‹çš„åç§°ï¼Œå¹¶è€ƒè™‘å¦‚ä½•ä½¿ç”¨å®ƒã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦ä¸¤ä¸ªç±»å‹ã€‚é¦–å…ˆæˆ‘ä»¬è¦æ‰“å°ä¸€ä¸ªç±»å‹ä¸ºTçš„è¯­å¥ã€‚ç”¨<code>{}</code>æ‰“å°æ¯”è¾ƒå¥½ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šè¦æ±‚ç”¨<code>Display</code>æ¥æ‰“å°<code>T</code>ã€‚</p>
<p>å…¶æ¬¡æ˜¯ç±»å‹Uï¼Œ<code>num_1</code>å’Œ<code>num_2</code>è¿™ä¸¤ä¸ªå˜é‡çš„ç±»å‹ä¸ºU(Uæ˜¯æŸç§æ•°å­—)ã€‚æˆ‘ä»¬æƒ³è¦æ¯”è¾ƒå®ƒä»¬ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦<code>PartialOrd</code>ã€‚è¿™ä¸ªç‰¹æ€§è®©æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>&lt;</code>ã€<code>&gt;</code>ã€<code>==</code>ç­‰ã€‚æˆ‘ä»¬ä¹Ÿæƒ³æ‰“å°å®ƒä»¬ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿéœ€è¦<code>Display</code>æ¥æ‰“å°<code>U</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::cmp::PartialOrd;

fn compare_and_display&lt;T: Display, U: Display + PartialOrd&gt;(statement: T, num_1: U, num_2: U) {
    println!("{}! Is {} greater than {}? {}", statement, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compare_and_display("Listen up!", 9, 8);
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡ºäº†<code>Listen up!! Is 9 greater than 8? true</code>ã€‚</p>
<p>æ‰€ä»¥<code>fn compare_and_display&lt;T: Display, U: Display + PartialOrd&gt;(statement: T, num_1: U, num_2: U)</code>è¯´ã€‚</p>
<ul>
<li>å‡½æ•°åç§°æ˜¯<code>compare_and_display</code>,</li>
<li>ç¬¬ä¸€ä¸ªç±»å‹æ˜¯Tï¼Œå®ƒæ˜¯é€šç”¨çš„ã€‚å®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå¯ä»¥ç”¨{}æ‰“å°çš„ç±»å‹ã€‚</li>
<li>ä¸‹ä¸€ä¸ªç±»å‹æ˜¯Uï¼Œå®ƒæ˜¯é€šç”¨çš„ã€‚å®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå¯ä»¥ç”¨{}æ‰“å°çš„ç±»å‹ã€‚å¦å¤–ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå¯ä»¥æ¯”è¾ƒçš„ç±»å‹(ä½¿ç”¨ <code>&gt;</code>ã€<code>&lt;</code> å’Œ <code>==</code>)ã€‚</li>
</ul>
<p>ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»™<code>compare_and_display</code>ä¸åŒçš„ç±»å‹ã€‚<code>statement</code>å¯ä»¥æ˜¯ä¸€ä¸ª<code>String</code>ï¼Œä¸€ä¸ª<code>&amp;str</code>ï¼Œä»»ä½•æœ‰Displayçš„ç±»å‹ã€‚</p>
<p>ä¸ºäº†è®©é€šç”¨å‡½æ•°æ›´å®¹æ˜“è¯»æ‡‚ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼Œåœ¨ä»£ç å—ä¹‹å‰å°±å†™ä¸Š<code>where</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::cmp::PartialOrd;
use std::fmt::Display;

fn compare_and_display&lt;T, U&gt;(statement: T, num_1: U, num_2: U)
where
    T: Display,
    U: Display + PartialOrd,
{
    println!("{}! Is {} greater than {}? {}", statement, num_1, num_2, num_1 &gt; num_2);
}

fn main() {
    compare_and_display("Listen up!", 9, 8);
}</code></pre></pre>
<p>å½“ä½ æœ‰å¾ˆå¤šé€šç”¨ç±»å‹æ—¶ï¼Œä½¿ç”¨<code>where</code>æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚</p>
<p>è¿˜è¦æ³¨æ„ã€‚</p>
<ul>
<li>å¦‚æœä½ æœ‰ä¸€ä¸ªç±»å‹Tå’Œå¦ä¸€ä¸ªç±»å‹Tï¼Œå®ƒä»¬å¿…é¡»æ˜¯ç›¸åŒçš„ã€‚</li>
<li>å¦‚æœä½ æœ‰ä¸€ä¸ªç±»å‹Tå’Œå¦ä¸€ä¸ªç±»å‹Uï¼Œå®ƒä»¬å¯ä»¥æ˜¯ä¸åŒçš„ã€‚ä½†å®ƒä»¬ä¹Ÿå¯ä»¥æ˜¯ç›¸åŒçš„ã€‚</li>
</ul>
<p>æ¯”å¦‚è¯´</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn say_two&lt;T: Display, U: Display&gt;(statement_1: T, statement_2: U) { // Type T needs Display, type U needs Display
    println!("I have two things to say: {} and {}", statement_1, statement_2);
}

fn main() {

    say_two("Hello there!", String::from("I hate sand.")); // Type T is a &amp;str, but type U is a String.
    say_two(String::from("Where is Padme?"), String::from("Is she all right?")); // Both types are String.
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">I have two things to say: Hello there! and I hate sand.
I have two things to say: Where is Padme? and Is she all right?
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="optionå’Œresult"><a class="header" href="#optionå’Œresult">Optionå’ŒResult</a></h2>
<p>æˆ‘ä»¬ç°åœ¨ç†è§£äº†æšä¸¾å’Œæ³›å‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç†è§£<code>Option</code>å’Œ<code>Result</code>ã€‚Rustä½¿ç”¨è¿™ä¸¤ä¸ªæšä¸¾æ¥ä½¿ä»£ç æ›´å®‰å…¨ã€‚</p>
<p>æˆ‘ä»¬å°†ä»<code>Option</code>å¼€å§‹ã€‚</p>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<p>å½“ä½ æœ‰ä¸€ä¸ªå¯èƒ½å­˜åœ¨ï¼Œä¹Ÿå¯èƒ½ä¸å­˜åœ¨çš„å€¼æ—¶ï¼Œä½ å°±ç”¨<code>Option</code>ã€‚å½“ä¸€ä¸ªå€¼å­˜åœ¨çš„æ—¶å€™å°±æ˜¯<code>Some(value)</code>ï¼Œä¸å­˜åœ¨çš„æ—¶å€™å°±æ˜¯<code>None</code>ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªåä»£ç çš„ä¾‹å­ï¼Œå¯ä»¥ç”¨<code>Option</code>æ¥æ”¹è¿›ã€‚</p>
<pre><pre class="playground"><code class="language-rust">    // âš ï¸
fn take_fifth(value: Vec&lt;i32&gt;) -&gt; i32 {
    value[4]
}

fn main() {
    let new_vec = vec![1, 2];
    let index = take_fifth(new_vec);
}</code></pre></pre>
<p>å½“æˆ‘ä»¬è¿è¡Œè¿™æ®µä»£ç æ—¶ï¼Œå®ƒå´©æºƒã€‚ä»¥ä¸‹æ˜¯ä¿¡æ¯ã€‚</p>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 2 but the index is 4', src\main.rs:34:5
</code></pre>
<p>å´©æºƒçš„æ„æ€æ˜¯ï¼Œç¨‹åºåœ¨é—®é¢˜å‘ç”Ÿä¹‹å‰å°±åœæ­¢äº†ã€‚Rustçœ‹åˆ°å‡½æ•°æƒ³è¦åšä¸€äº›ä¸å¯èƒ½çš„äº‹æƒ…ï¼Œå°±ä¼šåœæ­¢ã€‚å®ƒ "è§£å¼€å †æ ˆ"(ä»å †æ ˆä¸­å–å€¼)ï¼Œå¹¶å‘Šè¯‰ä½  "å¯¹ä¸èµ·ï¼Œæˆ‘ä¸èƒ½è¿™æ ·åš"ã€‚</p>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å°†è¿”å›ç±»å‹ä»<code>i32</code>æ”¹ä¸º<code>Option&lt;i32&gt;</code>ã€‚è¿™æ„å‘³ç€ "å¦‚æœæœ‰çš„è¯ç»™æˆ‘ä¸€ä¸ª<code>Some(i32)</code>ï¼Œå¦‚æœæ²¡æœ‰çš„è¯ç»™æˆ‘ä¸€ä¸ª<code>None</code>"ã€‚æˆ‘ä»¬è¯´<code>i32</code>æ˜¯ "åŒ…"åœ¨ä¸€ä¸ª<code>Option</code>é‡Œé¢ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒåœ¨ä¸€ä¸ª<code>Option</code>é‡Œé¢ã€‚ä½ å¿…é¡»åšä¸€äº›äº‹æƒ…æ‰èƒ½æŠŠè¿™ä¸ªå€¼å¼„å‡ºæ¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 { // .len() gives the length of the vec.
                         // It must be at least 5.
        None
    } else {
        Some(value[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!("{:?}, {:?}", take_fifth(new_vec), take_fifth(bigger_vec));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°çš„æ˜¯<code>None, Some(5)</code>ã€‚è¿™ä¸‹å¥½äº†ï¼Œå› ä¸ºç°åœ¨æˆ‘ä»¬å†ä¹Ÿä¸å´©æºƒäº†ã€‚ä½†æ˜¯æˆ‘ä»¬å¦‚ä½•å¾—åˆ°5çš„å€¼å‘¢ï¼Ÿ</p>
<p>æˆ‘ä»¬å¯ä»¥ç”¨ <code>.unwrap()</code> åœ¨ä¸€ä¸ªOptionä¸­è·å–å€¼ï¼Œä½†è¦å°å¿ƒ <code>.unwrap()</code>ã€‚è¿™å°±åƒæ‹†ç¤¼ç‰©ä¸€æ ·:ä¹Ÿè®¸é‡Œé¢æœ‰å¥½ä¸œè¥¿ï¼Œä¹Ÿè®¸é‡Œé¢æœ‰ä¸€æ¡æ„¤æ€’çš„è›‡ã€‚åªæœ‰åœ¨ä½ ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œä½ æ‰ä¼šæƒ³è¦<code>.unwrap()</code>ã€‚å¦‚æœä½ æ‹†å¼€ä¸€ä¸ª<code>None</code>çš„å€¼ï¼Œç¨‹åºå°±ä¼šå´©æºƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 {
        None
    } else {
        Some(value[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    println!("{:?}, {:?}",
        take_fifth(new_vec).unwrap(), // this one is None. .unwrap() will panic!
        take_fifth(bigger_vec).unwrap()
    );
}</code></pre></pre>
<p>æ¶ˆæ¯æ˜¯:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src\main.rs:14:9
</code></pre>
<p>ä½†æˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨<code>.unwrap()</code>ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>match</code>ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æŠŠæˆ‘ä»¬æœ‰<code>Some</code>çš„å€¼æ‰“å°å‡ºæ¥ï¼Œå¦‚æœæœ‰<code>None</code>çš„å€¼å°±ä¸è¦ç¢°ã€‚æ¯”å¦‚è¯´</p>
<pre><pre class="playground"><code class="language-rust">fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 {
        None
    } else {
        Some(value[4])
    }
}

fn handle_option(my_option: Vec&lt;Option&lt;i32&gt;&gt;) {
  for item in my_option {
    match item {
      Some(number) =&gt; println!("Found a {}!", number),
      None =&gt; println!("Found a None!"),
    }
  }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let mut option_vec = Vec::new(); // Make a new vec to hold our options
                                     // The vec is type: Vec&lt;Option&lt;i32&gt;&gt;. That means a vec of Option&lt;i32&gt;.

    option_vec.push(take_fifth(new_vec)); // This pushes "None" into the vec
    option_vec.push(take_fifth(bigger_vec)); // This pushes "Some(5)" into the vec

    handle_option(option_vec); // handle_option looks at every option in the vec.
                               // It prints the value if it is Some. It doesn't touch it if it is None.
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Found a None!
Found a 5!
</code></pre>
<p>å› ä¸ºæˆ‘ä»¬çŸ¥é“æ³›å‹ï¼Œæ‰€ä»¥æˆ‘ä»¬èƒ½å¤Ÿè¯»æ‡‚<code>Option</code>çš„ä»£ç ã€‚å®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

fn main() {}</code></pre></pre>
<p>è¦è®°ä½çš„é‡è¦ä¸€ç‚¹æ˜¯:æœ‰äº†<code>Some</code>ï¼Œä½ å°±æœ‰äº†ä¸€ä¸ªç±»å‹ä¸º<code>T</code>çš„å€¼(ä»»ä½•ç±»å‹)ã€‚è¿˜è¦æ³¨æ„çš„æ˜¯ï¼Œ<code>enum</code>åå­—åé¢çš„è§’æ‹¬å·å›´ç»•ç€<code>T</code>æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨å®ƒæ˜¯é€šç”¨çš„ã€‚å®ƒæ²¡æœ‰<code>Display</code>è¿™æ ·çš„traitæˆ–ä»»ä½•ä¸œè¥¿æ¥é™åˆ¶å®ƒï¼Œæ‰€ä»¥å®ƒå¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ã€‚ä½†æ˜¯å¯¹äº<code>None</code>ï¼Œä½ ä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚</p>
<p>æ‰€ä»¥åœ¨<code>match</code>è¯­å¥ä¸­ï¼Œå¯¹äºOptionï¼Œä½ ä¸èƒ½è¯´ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
Some(value) =&gt; println!("The value is {}", value),
None(value) =&gt; println!("The value is {}", value),
<span class="boring">}</span></code></pre></pre>
<p>å› ä¸º<code>None</code>åªæ˜¯<code>None</code>ã€‚</p>
<p>å½“ç„¶ï¼Œè¿˜æœ‰æ›´ç®€å•çš„æ–¹æ³•æ¥ä½¿ç”¨Optionã€‚åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªå«åš <code>.is_some()</code> çš„æ–¹æ³•æ¥å‘Šè¯‰æˆ‘ä»¬æ˜¯å¦æ˜¯ <code>Some</code>ã€‚(æ˜¯çš„ï¼Œè¿˜æœ‰ä¸€ä¸ªå«åš<code>.is_none()</code>çš„æ–¹æ³•ã€‚)åœ¨è¿™ä¸ªæ›´ç®€å•çš„æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦<code>handle_option()</code>äº†ã€‚æˆ‘ä»¬ä¹Ÿä¸éœ€è¦Optionçš„vecäº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn take_fifth(value: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    if value.len() &lt; 5 {
        None
    } else {
        Some(value[4])
    }
}

fn main() {
    let new_vec = vec![1, 2];
    let bigger_vec = vec![1, 2, 3, 4, 5];
    let vec_of_vecs = vec![new_vec, bigger_vec];
    for vec in vec_of_vecs {
        let inside_number = take_fifth(vec);
        if inside_number.is_some() {
            // .is_some() returns true if we get Some, false if we get None
            println!("We got: {}", inside_number.unwrap()); // now it is safe to use .unwrap() because we already checked
        } else {
            println!("We got nothing.");
        }
    }
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">We got nothing.
We got: 5
</code></pre>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p>Resultå’ŒOptionç±»ä¼¼ï¼Œä½†è¿™é‡Œçš„åŒºåˆ«æ˜¯ã€‚</p>
<ul>
<li>Optionå¤§çº¦æ˜¯<code>Some</code>æˆ–<code>None</code>(æœ‰å€¼æˆ–æ— å€¼)ã€‚</li>
<li>Resultå¤§çº¦æ˜¯<code>Ok</code>æˆ–<code>Err</code>(è¿˜å¥½çš„ç»“æœï¼Œæˆ–é”™è¯¯çš„ç»“æœ)ã€‚</li>
</ul>
<p>æ‰€ä»¥ï¼Œ<code>Option</code>æ˜¯å¦‚æœä½ åœ¨æƒ³:"ä¹Ÿè®¸ä¼šæœ‰ï¼Œä¹Ÿè®¸ä¸ä¼šæœ‰ã€‚"ä¹Ÿè®¸ä¼šæœ‰ä¸€äº›ä¸œè¥¿ï¼Œä¹Ÿè®¸ä¸ä¼šæœ‰ã€‚" ä½†<code>Result</code>æ˜¯å¦‚æœä½ åœ¨æƒ³: "ä¹Ÿè®¸ä¼šå¤±è´¥"</p>
<p>æ¯”è¾ƒä¸€ä¸‹ï¼Œè¿™é‡Œæ˜¯Optionå’ŒResultçš„ç­¾åã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥Resultåœ¨ "Ok "é‡Œé¢æœ‰ä¸€ä¸ªå€¼ï¼Œåœ¨ "Err "é‡Œé¢æœ‰ä¸€ä¸ªå€¼ã€‚è¿™æ˜¯å› ä¸ºé”™è¯¯é€šå¸¸åŒ…å«æè¿°é”™è¯¯çš„ä¿¡æ¯ã€‚</p>
<p><code>Result&lt;T, E&gt;</code>çš„æ„æ€æ˜¯ä½ è¦æƒ³å¥½<code>Ok</code>è¦è¿”å›ä»€ä¹ˆï¼Œ<code>Err</code>è¦è¿”å›ä»€ä¹ˆã€‚å…¶å®ï¼Œä½ å¯ä»¥å†³å®šä»»ä½•äº‹æƒ…ã€‚ç”šè‡³è¿™ä¸ªä¹Ÿå¯ä»¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn check_error() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    check_error();
}</code></pre></pre>
<p><code>check_error</code>è¯´ "å¦‚æœå¾—åˆ°<code>Ok</code>å°±è¿”å›<code>()</code>ï¼Œå¦‚æœå¾—åˆ°<code>Err</code>å°±è¿”å›<code>()</code>"ã€‚ç„¶åæˆ‘ä»¬ç”¨<code>()</code>è¿”å›<code>Ok</code>ã€‚</p>
<p>ç¼–è¯‘å™¨ç»™äº†æˆ‘ä»¬ä¸€ä¸ªæœ‰è¶£çš„è­¦å‘Šã€‚</p>
<pre><code class="language-text">warning: unused `std::result::Result` that must be used
 --&gt; src\main.rs:6:5
  |
6 |     check_error();
  |     ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>è¿™æ˜¯çœŸçš„:æˆ‘ä»¬åªè¿”å›äº†<code>Result</code>ï¼Œä½†å®ƒå¯èƒ½æ˜¯ä¸€ä¸ª<code>Err</code>ã€‚æ‰€ä»¥è®©æˆ‘ä»¬ç¨å¾®å¤„ç†ä¸€ä¸‹è¿™ä¸ªé”™è¯¯ï¼Œå°½ç®¡æˆ‘ä»¬ä»ç„¶æ²¡æœ‰çœŸæ­£åšä»»ä½•äº‹æƒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn give_result(input: i32) -&gt; Result&lt;(), ()&gt; {
    if input % 2 == 0 {
        return Ok(())
    } else {
        return Err(())
    }
}

fn main() {
    if give_result(5).is_ok() {
        println!("It's okay, guys")
    } else {
        println!("It's an error, guys")
    }
}</code></pre></pre>
<p>æ‰“å°å‡º<code>It's an error, guys</code>ã€‚æ‰€ä»¥æˆ‘ä»¬åªæ˜¯å¤„ç†äº†ç¬¬ä¸€ä¸ªé”™è¯¯ã€‚</p>
<p>è®°ä½ï¼Œè½»æ¾æ£€æŸ¥çš„å››ç§æ–¹æ³•æ˜¯<code>.is_some()</code>ã€<code>is_none()</code>ã€<code>is_ok()</code>å’Œ<code>is_err()</code>ã€‚</p>
<p>æœ‰æ—¶ï¼Œä¸€ä¸ªå¸¦æœ‰Resultçš„å‡½æ•°ä¼šç”¨<code>String</code>æ¥è¡¨ç¤º<code>Err</code>çš„å€¼ã€‚è¿™ä¸æ˜¯æœ€å¥½çš„æ–¹æ³•ï¼Œä½†æ¯”æˆ‘ä»¬ç›®å‰æ‰€åšçš„è¦å¥½ä¸€äº›ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn check_if_five(number: i32) -&gt; Result&lt;i32, String&gt; {
    match number {
        5 =&gt; Ok(number),
        _ =&gt; Err("Sorry, the number wasn't five.".to_string()), // This is our error message
    }
}

fn main() {
    let mut result_vec = Vec::new(); // Create a new vec for the results

    for number in 2..7 {
        result_vec.push(check_if_five(number)); // push each result into the vec
    }

    println!("{:?}", result_vec);
}</code></pre></pre>
<p>æˆ‘ä»¬çš„Vecæ‰“å°:</p>
<pre><code class="language-text">[Err("Sorry, the number wasn\'t five."), Err("Sorry, the number wasn\'t five."), Err("Sorry, the number wasn\'t five."), Ok(5),
Err("Sorry, the number wasn\'t five.")]
</code></pre>
<p>å°±åƒOptionä¸€æ ·ï¼Œåœ¨<code>Err</code>ä¸Šç”¨<code>.unwrap()</code>å°±ä¼šå´©æºƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">    // âš ï¸
fn main() {
    let error_value: Result&lt;i32, &amp;str&gt; = Err("There was an error"); // Create a Result that is already an Err
    println!("{}", error_value.unwrap()); // Unwrap it
}</code></pre></pre>
<p>ç¨‹åºå´©æºƒï¼Œæ‰“å°ã€‚</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: "There was an error"', src\main.rs:30:20
</code></pre>
<p>è¿™äº›ä¿¡æ¯å¯ä»¥å¸®åŠ©ä½ ä¿®æ­£ä½ çš„ä»£ç ã€‚<code>src\main.rs:30:20</code>çš„æ„æ€æ˜¯ "åœ¨ç›®å½•srcçš„main.rså†…ï¼Œç¬¬30è¡Œå’Œç¬¬20åˆ—"ã€‚æ‰€ä»¥ä½ å¯ä»¥å»é‚£é‡ŒæŸ¥çœ‹ä½ çš„ä»£ç å¹¶ä¿®å¤é—®é¢˜ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥åˆ›å»ºè‡ªå·±çš„é”™è¯¯ç±»å‹ï¼Œæ ‡å‡†åº“ä¸­çš„Resultå‡½æ•°å’Œå…¶ä»–äººçš„ä»£ç é€šå¸¸éƒ½ä¼šè¿™æ ·åšã€‚ä¾‹å¦‚ï¼Œæ ‡å‡†åº“ä¸­çš„è¿™ä¸ªå‡½æ•°ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;
<span class="boring">}</span></code></pre></pre>
<p>è¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ªå­—èŠ‚å‘é‡(<code>u8</code>)ï¼Œå¹¶å°è¯•åˆ›å»ºä¸€ä¸ª<code>String</code>ï¼Œæ‰€ä»¥Resultçš„æˆåŠŸæƒ…å†µæ˜¯<code>String</code>ï¼Œé”™è¯¯æƒ…å†µæ˜¯<code>FromUtf8Error</code>ã€‚ä½ å¯ä»¥ç»™ä½ çš„é”™è¯¯ç±»å‹èµ·ä»»ä½•ä½ æƒ³è¦çš„åå­—ã€‚</p>
<p>ä½¿ç”¨ <code>match</code> ä¸ <code>Option</code> å’Œ <code>Result</code> æœ‰æ—¶éœ€è¦å¾ˆå¤šä»£ç ã€‚ä¾‹å¦‚ï¼Œ<code>.get()</code> æ–¹æ³•åœ¨ <code>Vec</code> ä¸Šè¿”å› <code>Option</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];
    let get_one = my_vec.get(0); // 0 to get the first number
    let get_two = my_vec.get(10); // Returns None
    println!("{:?}", get_one);
    println!("{:?}", get_two);
}</code></pre></pre>
<p>æ­¤æ‰“å°</p>
<pre><code class="language-text">Some(2)
None
</code></pre>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¯ä»¥åŒ¹é…å¾—åˆ°æ•°å€¼ã€‚è®©æˆ‘ä»¬ä½¿ç”¨0åˆ°10çš„èŒƒå›´ï¼Œçœ‹çœ‹æ˜¯å¦ç¬¦åˆ<code>my_vec</code>ä¸­çš„æ•°å­—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      match my_vec.get(index) {
        Some(number) =&gt; println!("The number is: {}", number),
        None =&gt; {}
      }
    }
}</code></pre></pre>
<p>è¿™æ˜¯å¥½çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯¹<code>None</code>ä¸åšä»»ä½•å¤„ç†ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å…³å¿ƒã€‚è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç”¨<code>if let</code>æŠŠä»£ç å˜å°ã€‚<code>if let</code>çš„æ„æ€æ˜¯ "ç¬¦åˆå°±åšï¼Œä¸ç¬¦åˆå°±ä¸åš"ã€‚<code>if let</code>æ˜¯åœ¨ä½ ä¸è¦æ±‚å¯¹æ‰€æœ‰çš„ä¸œè¥¿éƒ½åŒ¹é…çš„æ—¶å€™ä½¿ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![2, 3, 4];

    for index in 0..10 {
      if let Some(number) = my_vec.get(index) {
        println!("The number is: {}", number);
      }
    }
}</code></pre></pre>
<p><strong>é‡è¦çš„æ˜¯è¦è®°ä½</strong>ã€‚<code>if let Some(number) = my_vec.get(index)</code>çš„æ„æ€æ˜¯ "å¦‚æœä½ ä»<code>my_vec.get(index)</code>å¾—åˆ°<code>Some(number)</code>"ã€‚</p>
<p>å¦å¤–æ³¨æ„:å®ƒä½¿ç”¨çš„æ˜¯ä¸€ä¸ª<code>=</code>ã€‚å®ƒä¸æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ã€‚</p>
<p><code>while let</code>å°±åƒ<code>if let</code>çš„ä¸€ä¸ªwhileå¾ªç¯ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æœ‰è¿™æ ·çš„æ°”è±¡ç«™æ•°æ®ã€‚</p>
<pre><code class="language-text">["Berlin", "cloudy", "5", "-7", "78"]
["Athens", "sunny", "not humid", "20", "10", "50"]
</code></pre>
<p>æˆ‘ä»¬æƒ³å¾—åˆ°æ•°å­—ï¼Œä½†ä¸æƒ³å¾—åˆ°æ–‡å­—ã€‚å¯¹äºæ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«åš <code>parse::&lt;i32&gt;()</code> çš„æ–¹æ³•ã€‚<code>parse()</code>æ˜¯æ–¹æ³•ï¼Œ<code>::&lt;i32&gt;</code>æ˜¯ç±»å‹ã€‚å®ƒå°†å°è¯•æŠŠ <code>&amp;str</code> å˜æˆ <code>i32</code>ï¼Œå¦‚æœå¯ä»¥çš„è¯å°±æŠŠå®ƒç»™æˆ‘ä»¬ã€‚å®ƒè¿”å›ä¸€ä¸ª <code>Result</code>ï¼Œå› ä¸ºå®ƒå¯èƒ½æ— æ³•å·¥ä½œ(æ¯”å¦‚ä½ æƒ³è®©å®ƒè§£æ "Billybrobby"--é‚£ä¸æ˜¯ä¸€ä¸ªæ•°å­—)ã€‚</p>
<p>æˆ‘ä»¬è¿˜å°†ä½¿ç”¨ <code>.pop()</code>ã€‚è¿™å°†ä»å‘é‡ä¸­å–å‡ºæœ€åä¸€é¡¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let weather_vec = vec![
        vec!["Berlin", "cloudy", "5", "-7", "78"],
        vec!["Athens", "sunny", "not humid", "20", "10", "50"],
    ];
    for mut city in weather_vec {
        println!("For the city of {}:", city[0]); // In our data, every first item is the city name
        while let Some(information) = city.pop() {
            // This means: keep going until you can't pop anymore
            // When the vector reaches 0 items, it will return None
            // and it will stop.
            if let Ok(number) = information.parse::&lt;i32&gt;() {
                // Try to parse the variable we called information
                // This returns a result. If it's Ok(number), it will print it
                println!("The number is: {}", number);
            }  // We don't write anything here because we do nothing if we get an error. Throw them all away
        }
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">For the city of Berlin:
The number is: 78
The number is: -7
The number is: 5
For the city of Athens:
The number is: 50
The number is: 10
The number is: 20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å…¶ä»–é›†åˆç±»å‹"><a class="header" href="#å…¶ä»–é›†åˆç±»å‹">å…¶ä»–é›†åˆç±»å‹</a></h2>
<p>Rustè¿˜æœ‰å¾ˆå¤šé›†åˆç±»å‹ã€‚ä½ å¯ä»¥åœ¨æ ‡å‡†åº“ä¸­çš„ https://doc.rust-lang.org/beta/std/collections/ çœ‹åˆ°å®ƒä»¬ã€‚é‚£ä¸ªé¡µé¢å¯¹ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ä¸€ç§ç±»å‹æœ‰å¾ˆå¥½çš„è§£é‡Šï¼Œæ‰€ä»¥å¦‚æœä½ ä¸çŸ¥é“ä½ æƒ³è¦ä»€ä¹ˆç±»å‹ï¼Œå°±å»é‚£é‡Œã€‚è¿™äº›é›†åˆéƒ½åœ¨æ ‡å‡†åº“çš„<code>std::collections</code>é‡Œé¢ã€‚ä½¿ç”¨å®ƒä»¬çš„æœ€å¥½æ–¹æ³•æ˜¯ä½¿ç”¨ <code>use</code> è¯­å¥ã€‚
å°±åƒæˆ‘ä»¬çš„<code>enums</code>ä¸€æ ·ã€‚æˆ‘ä»¬å°†ä»<code>HashMap</code>å¼€å§‹ï¼Œè¿™æ˜¯å¾ˆå¸¸è§çš„ã€‚</p>
<h3 id="hashmapå’Œbtreemap"><a class="header" href="#hashmapå’Œbtreemap">HashMapå’ŒBTreeMap</a></h3>
<p>HashMapæ˜¯ç”±<em>keys</em>å’Œ<em>values</em>ç»„æˆçš„é›†åˆã€‚ä½ ä½¿ç”¨é”®æ¥æŸ¥æ‰¾ä¸é”®åŒ¹é…çš„å€¼ã€‚ä½ å¯ä»¥åªç”¨<code>HashMap::new()</code>åˆ›å»ºä¸€ä¸ªæ–°çš„<code>HashMap</code>ï¼Œå¹¶ä½¿ç”¨<code>.insert(key, value)</code>æ¥æ’å…¥å…ƒç´ ã€‚</p>
<p><code>HashMap</code>æ˜¯æ²¡æœ‰é¡ºåºçš„ï¼Œæ‰€ä»¥å¦‚æœä½ æŠŠ<code>HashMap</code>ä¸­çš„æ¯ä¸€ä¸ªé”®éƒ½æ‰“å°åœ¨ä¸€èµ·ï¼Œå¯èƒ½ä¼šæ‰“å°å‡ºä¸åŒçš„ç»“æœã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªä¾‹å­ä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap; // This is so we can just write HashMap instead of std::collections::HashMap every time

struct City {
    name: String,
    population: HashMap&lt;u32, u32&gt;, // This will have the year and the population for the year
}

fn main() {

    let mut tallinn = City {
        name: "Tallinn".to_string(),
        population: HashMap::new(), // So far the HashMap is empty
    };

    tallinn.population.insert(1372, 3_250); // insert three dates
    tallinn.population.insert(1851, 24_000);
    tallinn.population.insert(2020, 437_619);


    for (year, population) in tallinn.population { // The HashMap is HashMap&lt;u32, u32&gt; so it returns a two items each time
        println!("In the year {} the city of {} had a population of {}.", year, tallinn.name, population);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">In the year 1372 the city of Tallinn had a population of 3250.
In the year 2020 the city of Tallinn had a population of 437619.
In the year 1851 the city of Tallinn had a population of 24000.
</code></pre>
<p>æˆ–è€…å¯èƒ½ä¼šæ‰“å°ã€‚</p>
<pre><code class="language-text">In the year 1851 the city of Tallinn had a population of 24000.
In the year 2020 the city of Tallinn had a population of 437619.
In the year 1372 the city of Tallinn had a population of 3250.
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œå®ƒä¸æŒ‰é¡ºåºæ’åˆ—ã€‚</p>
<p>å¦‚æœä½ æƒ³è¦ä¸€ä¸ªå¯ä»¥æ’åºçš„<code>HashMap</code>ï¼Œä½ å¯ä»¥ç”¨<code>BTreeMap</code>ã€‚å…¶å®å®ƒä»¬ä¹‹é—´æ˜¯éå¸¸ç›¸ä¼¼çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¿«é€Ÿçš„æŠŠæˆ‘ä»¬çš„<code>HashMap</code>æ”¹æˆ<code>BTreeMap</code>æ¥çœ‹çœ‹ã€‚å¤§å®¶å¯ä»¥çœ‹åˆ°ï¼Œè¿™å‡ ä¹æ˜¯ä¸€æ ·çš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeMap; // Just change HashMap to BTreeMap

struct City {
    name: String,
    population: BTreeMap&lt;u32, u32&gt;, // Just change HashMap to BTreeMap
}

fn main() {

    let mut tallinn = City {
        name: "Tallinn".to_string(),
        population: BTreeMap::new(), // Just change HashMap to BTreeMap
    };

    tallinn.population.insert(1372, 3_250);
    tallinn.population.insert(1851, 24_000);
    tallinn.population.insert(2020, 437_619);

    for (year, population) in tallinn.population {
        println!("In the year {} the city of {} had a population of {}.", year, tallinn.name, population);
    }
}</code></pre></pre>
<p>ç°åœ¨ä¼šä¸€ç›´æ‰“å°ã€‚</p>
<pre><code class="language-text">In the year 1372 the city of Tallinn had a population of 3250.
In the year 1851 the city of Tallinn had a population of 24000.
In the year 2020 the city of Tallinn had a population of 437619.
</code></pre>
<p>ç°åœ¨æˆ‘ä»¬å†æ¥çœ‹çœ‹<code>HashMap</code>ã€‚</p>
<p>åªè¦æŠŠé”®æ”¾åœ¨<code>[]</code>çš„æ–¹æ‹¬å·é‡Œï¼Œå°±å¯ä»¥å¾—åˆ°<code>HashMap</code>çš„å€¼ã€‚åœ¨æ¥ä¸‹æ¥çš„è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†å¸¦å‡º<code>Bielefeld</code>è¿™ä¸ªé”®çš„å€¼ï¼Œä¹Ÿå°±æ˜¯<code>Germany</code>ã€‚ä½†æ˜¯è¦æ³¨æ„ï¼Œå› ä¸ºå¦‚æœæ²¡æœ‰é”®ï¼Œç¨‹åºä¼šå´©æºƒã€‚æ¯”å¦‚ä½ å†™äº†<code>println!("{:?}", city_hashmap["Bielefeldd"]);</code>ï¼Œé‚£ä¹ˆå°±ä¼šå´©æºƒï¼Œå› ä¸º<code>Bielefeldd</code>ä¸å­˜åœ¨ã€‚</p>
<p>å¦‚æœä½ ä¸ç¡®å®šä¼šæœ‰ä¸€ä¸ªé”®ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>.get()</code>ï¼Œå®ƒè¿”å›ä¸€ä¸ª<code>Option</code>ã€‚å¦‚æœå®ƒå­˜åœ¨ï¼Œå°†æ˜¯<code>Some(value)</code>ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œä½ å°†å¾—åˆ°<code>None</code>ï¼Œè€Œä¸æ˜¯ä½¿ç¨‹åºå´©æºƒã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ <code>.get()</code> æ˜¯ä» <code>HashMap</code> ä¸­è·å–ä¸€ä¸ªå€¼çš„æ¯”è¾ƒå®‰å…¨çš„æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let canadian_cities = vec!["Calgary", "Vancouver", "Gimli"];
    let german_cities = vec!["Karlsruhe", "Bad Doberan", "Bielefeld"];

    let mut city_hashmap = HashMap::new();

    for city in canadian_cities {
        city_hashmap.insert(city, "Canada");
    }
    for city in german_cities {
        city_hashmap.insert(city, "Germany");
    }

    println!("{:?}", city_hashmap["Bielefeld"]);
    println!("{:?}", city_hashmap.get("Bielefeld"));
    println!("{:?}", city_hashmap.get("Bielefeldd"));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">"Germany"
Some("Germany")
None
</code></pre>
<p>è¿™æ˜¯å› ä¸º<em>Bielefeld</em>å­˜åœ¨ï¼Œä½†<em>Bielefeldd</em>ä¸å­˜åœ¨ã€‚</p>
<p>å¦‚æœ<code>HashMap</code>å·²ç»æœ‰ä¸€ä¸ªé”®ï¼Œå½“ä½ è¯•å›¾æŠŠå®ƒæ”¾è¿›å»æ—¶ï¼Œå®ƒå°†è¦†ç›–å®ƒçš„å€¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, "L'Allemagne Moderne");
    book_hashmap.insert(1, "Le Petit Prince");
    book_hashmap.insert(1, "ì„€ë„ìš° ì˜¤ë¸Œ ìœ ì–´ ìŠ¤ë§ˆì¼");
    book_hashmap.insert(1, "Eye of the World");

    println!("{:?}", book_hashmap.get(&amp;1));
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>Some("Eye of the World")</code>ï¼Œå› ä¸ºå®ƒæ˜¯ä½ æœ€åä½¿ç”¨ <code>.insert()</code> çš„æ¡ç›®ã€‚</p>
<p>æ£€æŸ¥ä¸€ä¸ªæ¡ç›®æ˜¯å¦å­˜åœ¨æ˜¯å¾ˆå®¹æ˜“çš„ï¼Œå› ä¸ºä½ å¯ä»¥ç”¨ <code>.get()</code> æ£€æŸ¥ï¼Œå®ƒç»™å‡ºäº† <code>Option</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut book_hashmap = HashMap::new();

    book_hashmap.insert(1, "L'Allemagne Moderne");

    if book_hashmap.get(&amp;1).is_none() { // is_none() returns a bool: true if it's None, false if it's Some
        book_hashmap.insert(1, "Le Petit Prince");
    }

    println!("{:?}", book_hashmap.get(&amp;1));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°<code>Some("L\'Allemagne Moderne")</code>æ˜¯å› ä¸ºå·²ç»æœ‰äº†keyä¸º<code>1</code>çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ²¡æœ‰æ’å…¥<code>Le Petit Prince</code>ã€‚</p>
<p><code>HashMap</code>æœ‰ä¸€ä¸ªéå¸¸æœ‰è¶£çš„æ–¹æ³•ï¼Œå«åš<code>.entry()</code>ï¼Œä½ ä¸€å®šè¦è¯•è¯•ã€‚æœ‰äº†å®ƒï¼Œä½ å¯ä»¥åœ¨æ²¡æœ‰é”®çš„æƒ…å†µä¸‹ï¼Œç”¨å¦‚<code>.or_insert()</code>è¿™ç±»æ–¹æ³•æ¥æ’å…¥å€¼ã€‚æœ‰è¶£çš„æ˜¯ï¼Œå®ƒè¿˜ç»™å‡ºäº†ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥å¦‚æœä½ æƒ³çš„è¯ï¼Œä½ å¯ä»¥æ”¹å˜å®ƒã€‚é¦–å…ˆæ˜¯ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬åªæ˜¯åœ¨æ¯æ¬¡æ’å…¥ä¹¦ååˆ°<code>HashMap</code>æ—¶æ’å…¥ä¸€ä¸ª<code>true</code>ã€‚</p>
<p>è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå›¾ä¹¦é¦†ï¼Œå¹¶å¸Œæœ›è·Ÿè¸ªæˆ‘ä»¬çš„ä¹¦ç±ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec!["L'Allemagne Moderne", "Le Petit Prince", "Eye of the World", "Eye of the World"]; // Eye of the World appears twice

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        book_hashmap.entry(book).or_insert(true);
    }
    for (book, true_or_false) in book_hashmap {
        println!("Do we have {}? {}", book, true_or_false);
    }
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">Do we have Eye of the World? true
Do we have Le Petit Prince? true
Do we have L'Allemagne Moderne? true
</code></pre>
<p>ä½†è¿™å¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚ä¹Ÿè®¸æœ€å¥½æ˜¯æ•°ä¸€ä¸‹ä¹¦çš„æ•°é‡ï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“<em>ä¸–ç•Œä¹‹çœ¼</em> æœ‰ä¸¤æœ¬ã€‚é¦–å…ˆè®©æˆ‘ä»¬çœ‹çœ‹<code>.entry()</code>åšäº†ä»€ä¹ˆï¼Œä»¥åŠ<code>.or_insert()</code>åšäº†ä»€ä¹ˆã€‚<code>.entry()</code>å…¶å®æ˜¯è¿”å›äº†ä¸€ä¸ªåä¸º<code>Entry</code>çš„<code>enum</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn entry(&amp;mut self, key: K) -&gt; Entry&lt;K, V&gt; // ğŸš§
<span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">Entryæ–‡æ¡£é¡µ</a>ã€‚ä¸‹é¢æ˜¯å…¶ä»£ç çš„ç®€å•ç‰ˆæœ¬ã€‚<code>K</code>è¡¨ç¤ºkeyï¼Œ<code>V</code>è¡¨ç¤ºvalueã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
use std::collections::hash_map::*;

enum Entry&lt;K, V&gt; {
    Occupied(OccupiedEntry&lt;K, V&gt;),
    Vacant(VacantEntry&lt;K, V&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>ç„¶åå½“æˆ‘ä»¬è°ƒç”¨<code>.or_insert()</code>æ—¶ï¼Œå®ƒå°±ä¼šæŸ¥çœ‹æšä¸¾ï¼Œå¹¶å†³å®šè¯¥æ€ä¹ˆåšã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn or_insert(self, default: V) -&gt; &amp;mut V { // ğŸš§
    match self {
        Occupied(entry) =&gt; entry.into_mut(),
        Vacant(entry) =&gt; entry.insert(default),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>æœ‰è¶£çš„æ˜¯ï¼Œå®ƒè¿”å›ä¸€ä¸ª<code>mut</code>çš„å¼•ç”¨ã€‚<code>&amp;mut V</code>. è¿™æ„å‘³ç€ä½ å¯ä»¥ä½¿ç”¨<code>let</code>å°†å…¶é™„åŠ åˆ°ä¸€ä¸ªå˜é‡ä¸Šï¼Œå¹¶æ”¹å˜å˜é‡æ¥æ”¹å˜<code>HashMap</code>ä¸­çš„å€¼ã€‚æ‰€ä»¥å¯¹äºæ¯æœ¬ä¹¦ï¼Œå¦‚æœæ²¡æœ‰æ¡ç›®ï¼Œæˆ‘ä»¬å°±ä¼šæ’å…¥ä¸€ä¸ª0ã€‚è€Œå¦‚æœæœ‰çš„è¯ï¼Œæˆ‘ä»¬å°†åœ¨å¼•ç”¨ä¸Šä½¿ç”¨<code>+= 1</code>æ¥å¢åŠ æ•°å­—ã€‚ç°åœ¨å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let book_collection = vec!["L'Allemagne Moderne", "Le Petit Prince", "Eye of the World", "Eye of the World"];

    let mut book_hashmap = HashMap::new();

    for book in book_collection {
        let return_value = book_hashmap.entry(book).or_insert(0); // return_value is a mutable reference. If nothing is there, it will be 0
        *return_value +=1; // Now return_value is at least 1. And if there was another book, it will go up by 1
    }

    for (book, number) in book_hashmap {
        println!("{}, {}", book, number);
    }
}</code></pre></pre>
<p>é‡è¦çš„éƒ¨åˆ†æ˜¯<code>let return_value = book_hashmap.entry(book).or_insert(0);</code>ã€‚å¦‚æœå»æ‰ <code>let</code>ï¼Œä½ ä¼šå¾—åˆ° <code>book_hashmap.entry(book).or_insert(0)</code>ã€‚å¦‚æœæ²¡æœ‰<code>let</code>ï¼Œå®ƒä»€ä¹ˆä¹Ÿä¸åš:å®ƒæ’å…¥äº†0ï¼Œæ²¡æœ‰è·å–æŒ‡å‘0çš„å¯å˜å¼•ç”¨ã€‚æ‰€ä»¥æˆ‘ä»¬æŠŠå®ƒç»‘å®šåˆ°<code>return_value</code>ä¸Šï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¿ç•™0ã€‚ç„¶åæˆ‘ä»¬æŠŠå€¼å¢åŠ 1ï¼Œè¿™æ ·<code>HashMap</code>ä¸­çš„æ¯æœ¬ä¹¦éƒ½è‡³å°‘æœ‰1ã€‚ç„¶åå½“<code>.entry()</code>å†çœ‹<em>ä¸–ç•Œä¹‹çœ¼</em>æ—¶ï¼Œå®ƒä¸ä¼šæ’å…¥ä»»ä½•ä¸œè¥¿ï¼Œä½†å®ƒç»™æˆ‘ä»¬ä¸€ä¸ªå¯å˜çš„1ã€‚ç„¶åæˆ‘ä»¬æŠŠå®ƒå¢åŠ åˆ°2ï¼Œæ‰€ä»¥å®ƒæ‰ä¼šæ‰“å°å‡ºè¿™æ ·çš„ç»“æœã€‚</p>
<pre><code class="language-text">L'Allemagne Moderne, 1
Le Petit Prince, 1
Eye of the World, 2
</code></pre>
<p>ä½ ä¹Ÿå¯ä»¥ç”¨<code>.or_insert()</code>åšä¸€äº›äº‹æƒ…ï¼Œæ¯”å¦‚æ’å…¥ä¸€ä¸ªvecï¼Œç„¶åæ¨å…¥æ•°æ®ã€‚è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬é—®è¡—ä¸Šçš„ç”·äººå’Œå¥³äººä»–ä»¬å¯¹ä¸€ä¸ªæ”¿æ²»å®¶çš„çœ‹æ³•ã€‚ä»–ä»¬ç»™å‡ºçš„è¯„åˆ†ä»0åˆ°10ã€‚ç„¶åæˆ‘ä»¬è¦æŠŠè¿™äº›æ•°å­—æ”¾åœ¨ä¸€èµ·ï¼Œçœ‹çœ‹è¿™ä¸ªæ”¿æ²»å®¶æ˜¯æ›´å—ç”·äººæ¬¢è¿è¿˜æ˜¯å¥³äººæ¬¢è¿ã€‚å®ƒå¯ä»¥æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let data = vec![ // This is the raw data
        ("male", 9),
        ("female", 5),
        ("male", 0),
        ("female", 6),
        ("female", 5),
        ("male", 10),
    ];

    let mut survey_hash = HashMap::new();

    for item in data { // This gives a tuple of (&amp;str, i32)
        survey_hash.entry(item.0).or_insert(Vec::new()).push(item.1); // This pushes the number into the Vec inside
    }

    for (male_or_female, numbers) in survey_hash {
        println!("{:?}: {:?}", male_or_female, numbers);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">"female", [5, 6, 5]
"male", [9, 0, 10]
</code></pre>
<p>é‡è¦çš„ä¸€è¡Œæ˜¯:<code>survey_hash.entry(item.0).or_insert(Vec::new()).push(item.1);</code>ï¼Œæ‰€ä»¥å¦‚æœå®ƒçœ‹åˆ° "å¥³"ï¼Œå°±ä¼šæ£€æŸ¥<code>HashMap</code>ä¸­æ˜¯å¦å·²ç»æœ‰ "å¥³"ã€‚å¦‚æœæ²¡æœ‰ï¼Œå®ƒå°±ä¼šæ’å…¥ä¸€ä¸ª<code>Vec::new()</code>ï¼Œç„¶åæŠŠæ•°å­—æ¨å…¥ã€‚å¦‚æœå®ƒçœ‹åˆ° "å¥³æ€§"å·²ç»åœ¨<code>HashMap</code>ä¸­ï¼Œå®ƒå°†ä¸ä¼šæ’å…¥ä¸€ä¸ªæ–°çš„Vecï¼Œè€Œåªæ˜¯å°†æ•°å­—æ¨å…¥å…¶ä¸­ã€‚</p>
<h3 id="hashsetå’Œbtreeset"><a class="header" href="#hashsetå’Œbtreeset">HashSetå’ŒBTreeSet</a></h3>
<p><code>HashSet</code>å®é™…ä¸Šæ˜¯ä¸€ä¸ªåªæœ‰keyçš„<code>HashMap</code>ã€‚åœ¨<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">HashSetçš„é¡µé¢</a>ä¸Šé¢æœ‰è§£é‡Šã€‚</p>
<p><code>A hash set implemented as a HashMap where the value is ().</code> æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ª<code>HashMap</code>ï¼Œæœ‰é”®ï¼Œæ²¡æœ‰å€¼ã€‚</p>
<p>å¦‚æœä½ åªæ˜¯æƒ³çŸ¥é“ä¸€ä¸ªé”®æ˜¯å¦å­˜åœ¨ï¼Œæˆ–è€…ä¸å­˜åœ¨ï¼Œä½ ç»å¸¸ä¼šä½¿ç”¨<code>HashSet</code>ã€‚</p>
<p>æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æœ‰100ä¸ªéšæœºæ•°ï¼Œæ¯ä¸ªæ•°å­—åœ¨1å’Œ100ä¹‹é—´ã€‚å¦‚æœä½ è¿™æ ·åšï¼Œæœ‰äº›æ•°å­—ä¼šå‡ºç°ä¸æ­¢ä¸€æ¬¡ï¼Œè€Œæœ‰äº›æ•°å­—æ ¹æœ¬ä¸ä¼šå‡ºç°ã€‚å¦‚æœä½ æŠŠå®ƒä»¬æ”¾åˆ°<code>HashSet</code>ä¸­ï¼Œé‚£ä¹ˆä½ å°±ä¼šæœ‰ä¸€ä¸ªæ‰€æœ‰å‡ºç°çš„æ•°å­—çš„åˆ—è¡¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let many_numbers = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut number_hashset = HashSet::new();

    for number in many_numbers {
        number_hashset.insert(number);
    }

    let hashset_length = number_hashset.len(); // The length tells us how many numbers are in it
    println!("There are {} unique numbers, so we are missing {}.", hashset_length, 100 - hashset_length);

    // Let's see what numbers we are missing
    let mut missing_vec = vec![];
    for number in 0..100 {
        if number_hashset.get(&amp;number).is_none() { // If .get() returns None,
            missing_vec.push(number);
        }
    }

    print!("It does not contain: ");
    for number in missing_vec {
        print!("{} ", number);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">There are 66 unique numbers, so we are missing 34.
It does not contain: 1 2 4 6 7 9 12 21 23 27 30 31 39 40 45 47 48 50 52 53 62 65 69 70 72 75 77 78 83 85 88 97 98 99
</code></pre>
<p><code>BTreeSet</code>ä¸<code>HashSet</code>ç›¸ä¼¼ï¼Œå°±åƒ<code>BTreeMap</code>ä¸<code>HashMap</code>ç›¸ä¼¼ä¸€æ ·ã€‚å¦‚æœæˆ‘ä»¬æŠŠ<code>HashSet</code>ä¸­çš„æ¯ä¸€é¡¹éƒ½æ‰“å°å‡ºæ¥ï¼Œå°±ä¸çŸ¥é“é¡ºåºæ˜¯ä»€ä¹ˆäº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in number_hashset { // ğŸš§
    print!("{} ", entry);
}
<span class="boring">}</span></code></pre></pre>
<p>ä¹Ÿè®¸å®ƒèƒ½æ‰“å°å‡ºè¿™ä¸ªã€‚<code>67 28 42 25 95 59 87 11 5 81 64 34 8 15 13 86 10 89 63 93 49 41 46 57 60 29 17 22 74 43 32 38 36 76 71 18 14 84 61 16 35 90 56 54 91 19 94 44 3 0 68 80 51 92 24 20 82 26 58 33 55 96 37 66 79 73</code>. ä½†å®ƒå‡ ä¹ä¸ä¼šå†ä»¥åŒæ ·çš„æ–¹å¼æ‰“å°ã€‚</p>
<p>åœ¨è¿™é‡Œä¹Ÿä¸€æ ·ï¼Œå¦‚æœä½ å†³å®šéœ€è¦è®¢è´­çš„è¯ï¼Œå¾ˆå®¹æ˜“æŠŠä½ çš„<code>HashSet</code>æ”¹æˆ<code>BTreeSet</code>ã€‚åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦åšä¸¤å¤„æ”¹åŠ¨ï¼Œå°±å¯ä»¥ä»<code>HashSet</code>åˆ‡æ¢åˆ°<code>BTreeSet</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeSet; // Change HashSet to BTreeSet

fn main() {
    let many_numbers = vec![
        94, 42, 59, 64, 32, 22, 38, 5, 59, 49, 15, 89, 74, 29, 14, 68, 82, 80, 56, 41, 36, 81, 66,
        51, 58, 34, 59, 44, 19, 93, 28, 33, 18, 46, 61, 76, 14, 87, 84, 73, 71, 29, 94, 10, 35, 20,
        35, 80, 8, 43, 79, 25, 60, 26, 11, 37, 94, 32, 90, 51, 11, 28, 76, 16, 63, 95, 13, 60, 59,
        96, 95, 55, 92, 28, 3, 17, 91, 36, 20, 24, 0, 86, 82, 58, 93, 68, 54, 80, 56, 22, 67, 82,
        58, 64, 80, 16, 61, 57, 14, 11];

    let mut number_btreeset = BTreeSet::new(); // Change HashSet to BTreeSet

    for number in many_numbers {
        number_btreeset.insert(number);
    }
    for entry in number_btreeset {
        print!("{} ", entry);
    }
}</code></pre></pre>
<p>ç°åœ¨ä¼šæŒ‰é¡ºåºæ‰“å°ã€‚<code>0 3 5 8 10 11 13 14 15 16 17 18 19 20 22 24 25 26 28 29 32 33 34 35 36 37 38 41 42 43 44 46 49 51 54 55 56 57 58 59 60 61 63 64 66 67 68 71 73 74 76 79 80 81 82 84 86 87 89 90 91 92 93 94 95 96</code>.</p>
<h3 id="äºŒå‰å †"><a class="header" href="#äºŒå‰å †">äºŒå‰å †</a></h3>
<p><code>BinaryHeap</code>æ˜¯ä¸€ç§æœ‰è¶£çš„é›†åˆç±»å‹ï¼Œå› ä¸ºå®ƒå¤§éƒ¨åˆ†æ˜¯æ— åºçš„ï¼Œä½†ä¹Ÿæœ‰ä¸€ç‚¹ç§©åºã€‚å®ƒæŠŠæœ€å¤§çš„å…ƒç´ æ”¾åœ¨å‰é¢ï¼Œä½†å…¶ä»–å…ƒç´ æ˜¯æŒ‰ä»»ä½•é¡ºåºæ’åˆ—çš„ã€‚</p>
<p>æˆ‘ä»¬å°†ç”¨å¦ä¸€ä¸ªå…ƒç´ åˆ—è¡¨æ¥ä¸¾ä¾‹ï¼Œä½†è¿™æ¬¡æ•°æ®å°‘äº›ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn show_remainder(input: &amp;BinaryHeap&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { // This function shows the remainder in the BinaryHeap. Actually an iterator would be
                                                         // faster than a function - we will learn them later.
    let mut remainder_vec = vec![];
    for number in input {
        remainder_vec.push(*number)
    }
    remainder_vec
}

fn main() {
    let many_numbers = vec![0, 5, 10, 15, 20, 25, 30]; // These numbers are in order

    let mut my_heap = BinaryHeap::new();

    for number in many_numbers {
        my_heap.push(number);
    }

    while let Some(number) = my_heap.pop() { // .pop() returns Some(number) if a number is there, None if not. It pops from the front
        println!("Popped off {}. Remaining numbers are: {:?}", number, show_remainder(&amp;my_heap));
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Popped off 30. Remaining numbers are: [25, 15, 20, 0, 10, 5]
Popped off 25. Remaining numbers are: [20, 15, 5, 0, 10]
Popped off 20. Remaining numbers are: [15, 10, 5, 0]
Popped off 15. Remaining numbers are: [10, 0, 5]
Popped off 10. Remaining numbers are: [5, 0]
Popped off 5. Remaining numbers are: [0]
Popped off 0. Remaining numbers are: []
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œ0æŒ‡æ•°çš„æ•°å­—æ€»æ˜¯æœ€å¤§çš„ã€‚25, 20, 15, 10, 5, ç„¶åæ˜¯0.</p>
<p>ä½¿ç”¨<code>BinaryHeap&lt;(u8, &amp;str)&gt;</code>çš„ä¸€ä¸ªå¥½æ–¹æ³•æ˜¯ç”¨äºä¸€ä¸ªäº‹æƒ…çš„é›†åˆã€‚è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª<code>BinaryHeap&lt;(u8, &amp;str)&gt;</code>ï¼Œå…¶ä¸­<code>u8</code>æ˜¯ä»»åŠ¡é‡è¦æ€§çš„æ•°å­—ã€‚<code>&amp;str</code>æ˜¯å¯¹è¦åšçš„äº‹æƒ…çš„æè¿°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

fn main() {
    let mut jobs = BinaryHeap::new();

    // Add jobs to do throughout the day
    jobs.push((100, "Write back to email from the CEO"));
    jobs.push((80, "Finish the report today"));
    jobs.push((5, "Watch some YouTube"));
    jobs.push((70, "Tell your team members thanks for always working hard"));
    jobs.push((30, "Plan who to hire next for the team"));

    while let Some(job) = jobs.pop() {
        println!("You need to: {}", job.1);
    }
}</code></pre></pre>
<p>è¿™å°†ä¸€ç›´æ‰“å°:</p>
<pre><code class="language-text">You need to: Write back to email from the CEO
You need to: Finish the report today
You need to: Tell your team members thanks for always working hard
You need to: Plan who to hire next for the team
You need to: Watch some YouTube
</code></pre>
<h3 id="vecdeque"><a class="header" href="#vecdeque">VecDeque</a></h3>
<p><code>VecDeque</code>å°±æ˜¯ä¸€ä¸ª<code>Vec</code>ï¼Œæ—¢èƒ½ä»å‰é¢å¼¹å‡ºitemï¼Œåˆèƒ½ä»åé¢å¼¹å‡ºitemã€‚Rustæœ‰<code>VecDeque</code>æ˜¯å› ä¸º<code>Vec</code>å¾ˆé€‚åˆä»åé¢(æœ€åä¸€ä¸ªå…ƒç´ )å¼¹å‡ºï¼Œä½†ä»å‰é¢å¼¹å‡ºå°±ä¸é‚£ä¹ˆå¥½äº†ã€‚å½“ä½ åœ¨<code>Vec</code>ä¸Šä½¿ç”¨<code>.pop()</code>çš„æ—¶å€™ï¼Œå®ƒåªæ˜¯æŠŠå³è¾¹æœ€åä¸€ä¸ªitemå–ä¸‹æ¥ï¼Œå…¶ä»–çš„éƒ½ä¸ä¼šåŠ¨ã€‚ä½†æ˜¯å¦‚æœä½ æŠŠå®ƒä»å…¶ä»–éƒ¨åˆ†å–ä¸‹æ¥ï¼Œå³è¾¹çš„æ‰€æœ‰å…ƒç´ éƒ½ä¼šå‘å·¦ç§»åŠ¨ä¸€ä¸ªä½ç½®ã€‚ä½ å¯ä»¥åœ¨<code>.remove()</code>çš„æè¿°ä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><code class="language-text">Removes and returns the element at position index within the vector, shifting all elements after it to the left.
</code></pre>
<p>æ‰€ä»¥å¦‚æœä½ è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![9, 8, 7, 6, 5];
    my_vec.remove(0);
}</code></pre></pre>
<p>å®ƒå°†åˆ é™¤ <code>9</code>ã€‚ç´¢å¼•1ä¸­çš„<code>8</code>å°†ç§»åˆ°ç´¢å¼•0ï¼Œç´¢å¼•2ä¸­çš„<code>7</code>å°†ç§»åˆ°ç´¢å¼•1ï¼Œä»¥æ­¤ç±»æ¨ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªå¤§åœè½¦åœºï¼Œæ¯å½“æœ‰ä¸€è¾†è½¦ç¦»å¼€æ—¶ï¼Œå³è¾¹æ‰€æœ‰çš„è½¦éƒ½è¦ç§»è¿‡æ¥ã€‚</p>
<p>æ¯”å¦‚è¯´ï¼Œè¿™å¯¹è®¡ç®—æœºæ¥è¯´æ˜¯ä¸€ä¸ª<em>å¾ˆå¤§</em>çš„å·¥ä½œé‡ã€‚äº‹å®ä¸Šï¼Œå¦‚æœä½ åœ¨playgroundä¸Šè¿è¡Œå®ƒï¼Œå®ƒå¯èƒ½ä¼šå› ä¸ºå·¥ä½œå¤ªå¤šè€Œç›´æ¥æ”¾å¼ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![0; 600_000];
    for i in 0..600000 {
        my_vec.remove(0);
    }
}</code></pre></pre>
<p>è¿™æ˜¯60ä¸‡ä¸ªé›¶çš„<code>Vec</code>ã€‚æ¯æ¬¡ä½ ç”¨<code>remove(0)</code>ï¼Œå®ƒå°±ä¼šæŠŠæ¯ä¸ªé›¶å‘å·¦ç§»åŠ¨ä¸€ä¸ªç©ºæ ¼ã€‚ç„¶åå®ƒå°±ä¼šåš60ä¸‡æ¬¡ã€‚</p>
<p>ç”¨<code>VecDeque</code>å°±ä¸ç”¨æ‹…å¿ƒè¿™ä¸ªé—®é¢˜äº†ã€‚å®ƒé€šå¸¸æ¯”<code>Vec</code>æ…¢ä¸€ç‚¹ï¼Œä½†å¦‚æœä½ è¦åœ¨ä¸¤ç«¯éƒ½åšäº‹æƒ…ï¼Œé‚£ä¹ˆå®ƒå°±å¿«å¤šäº†ã€‚ä½ å¯ä»¥ç›´æ¥ç”¨<code>VecDeque::from</code>ä¸<code>Vec</code>æ¥åˆ›å»ºä¸€ä¸ªã€‚é‚£ä¹ˆæˆ‘ä»¬ä¸Šé¢çš„ä»£ç å°±æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn main() {
    let mut my_vec = VecDeque::from(vec![0; 600000]);
    for i in 0..600000 {
        my_vec.pop_front(); // pop_front is like .pop but for the front
    }
}</code></pre></pre>
<p>ç°åœ¨é€Ÿåº¦å¿«äº†å¾ˆå¤šï¼Œåœ¨playgroundä¸Šï¼Œå®ƒåœ¨ä¸€ç§’å†…å®Œæˆï¼Œè€Œä¸æ˜¯æ”¾å¼ƒã€‚</p>
<p>åœ¨æ¥ä¸‹æ¥çš„è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨ä¸€ä¸ª<code>Vec</code>ä¸Šåšä¸€äº›äº‹ã€‚æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª<code>VecDeque</code>ï¼Œç”¨<code>.push_front()</code>æŠŠå®ƒä»¬æ”¾åœ¨å‰é¢ï¼Œæ‰€ä»¥æˆ‘ä»¬æ·»åŠ çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¼šåœ¨å³è¾¹ã€‚ä½†æ˜¯æˆ‘ä»¬æ¨é€çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª<code>(&amp;str, bool)</code>:<code>&amp;str</code>æ˜¯æè¿°, <code>false</code>è¡¨ç¤ºè¿˜æ²¡æœ‰å®Œæˆã€‚æˆ‘ä»¬ç”¨<code>done()</code>å‡½æ•°ä»åé¢å¼¹å‡ºä¸€ä¸ªå…ƒç´ ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸æƒ³åˆ é™¤å®ƒã€‚ç›¸åï¼Œæˆ‘ä»¬æŠŠ<code>false</code>æ”¹æˆ<code>true</code>ï¼Œç„¶åæŠŠå®ƒæ¨åˆ°å‰é¢ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¿ç•™å®ƒã€‚</p>
<p>å®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

fn check_remaining(input: &amp;VecDeque&lt;(&amp;str, bool)&gt;) { // Each item is a (&amp;str, bool)
    for item in input {
        if item.1 == false {
            println!("You must: {}", item.0);
        }
    }
}

fn done(input: &amp;mut VecDeque&lt;(&amp;str, bool)&gt;) {
    let mut task_done = input.pop_back().unwrap(); // pop off the back
    task_done.1 = true;                            // now it's done - mark as true
    input.push_front(task_done);                   // put it at the front now
}

fn main() {
    let mut my_vecdeque = VecDeque::new();
    let things_to_do = vec!["send email to customer", "add new product to list", "phone Loki back"];

    for thing in things_to_do {
        my_vecdeque.push_front((thing, false));
    }

    done(&amp;mut my_vecdeque);
    done(&amp;mut my_vecdeque);

    check_remaining(&amp;my_vecdeque);

    for task in my_vecdeque {
        print!("{:?} ", task);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">You must: phone Loki back
("add new product to list", true) ("send email to customer", true) ("phone Loki back", false)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ“ä½œç¬¦"><a class="header" href="#æ“ä½œç¬¦">?æ“ä½œç¬¦</a></h2>
<p>æœ‰ä¸€ç§æ›´çŸ­çš„æ–¹æ³•æ¥å¤„ç†<code>Result</code>(å’Œ<code>Option</code>)ï¼Œå®ƒæ¯”<code>match</code>å’Œ<code>if let</code>æ›´çŸ­ã€‚å®ƒå«åš "é—®å·è¿ç®—ç¬¦"ï¼Œå°±æ˜¯<code>?</code>ã€‚åœ¨è¿”å›ç»“æœçš„å‡½æ•°åï¼Œå¯ä»¥åŠ ä¸Š<code>?</code>ã€‚è¿™æ ·å°±ä¼š:</p>
<ul>
<li>å¦‚æœæ˜¯<code>Ok</code>ï¼Œè¿”å›<code>Result</code>é‡Œé¢çš„å†…å®¹ã€‚</li>
<li>å¦‚æœæ˜¯<code>Err</code>ï¼Œåˆ™å°†é”™è¯¯ä¼ å›ã€‚</li>
</ul>
<p>æ¢å¥è¯è¯´ï¼Œå®ƒå‡ ä¹ä¸ºä½ åšäº†æ‰€æœ‰çš„äº‹æƒ…ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥ç”¨ <code>.parse()</code> å†è¯•ä¸€æ¬¡ã€‚æˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªåä¸º <code>parse_str</code> çš„å‡½æ•°ï¼Œè¯•å›¾å°† <code>&amp;str</code> å˜æˆ <code>i32</code>ã€‚å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?; // Here is the question mark
    Ok(parsed_number)
}

fn main() {}</code></pre></pre>
<p>è¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ª <code>&amp;str</code>ã€‚å¦‚æœæ˜¯ <code>Ok</code>ï¼Œåˆ™ç»™å‡ºä¸€ä¸ª <code>i32</code>ï¼ŒåŒ…è£¹åœ¨ <code>Ok</code> ä¸­ã€‚å¦‚æœæ˜¯ <code>Err</code>ï¼Œåˆ™è¿”å› <code>ParseIntError</code>ã€‚ç„¶åæˆ‘ä»¬å°è¯•è§£æè¿™ä¸ªæ•°å­—ï¼Œå¹¶åŠ ä¸Š<code>?</code>ã€‚ä¹Ÿå°±æ˜¯ "æ£€æŸ¥æ˜¯å¦é”™è¯¯ï¼Œå¦‚æœæ²¡é—®é¢˜å°±ç»™å‡ºResulté‡Œé¢çš„å†…å®¹"ã€‚å¦‚æœæœ‰é—®é¢˜ï¼Œå°±ä¼šè¿”å›é”™è¯¯å¹¶ç»“æŸã€‚ä½†å¦‚æœæ²¡é—®é¢˜ï¼Œå°±ä¼šè¿›å…¥ä¸‹ä¸€è¡Œã€‚ä¸‹ä¸€è¡Œæ˜¯<code>Ok()</code>é‡Œé¢çš„æ•°å­—ã€‚æˆ‘ä»¬éœ€è¦ç”¨<code>Ok</code>æ¥åŒ…è£…ï¼Œå› ä¸ºè¿”å›çš„æ˜¯<code>Result&lt;i32, ParseIntError&gt;</code>ï¼Œè€Œä¸æ˜¯<code>i32</code>ã€‚</p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥è¯•è¯•æˆ‘ä»¬çš„å‡½æ•°ã€‚è®©æˆ‘ä»¬çœ‹çœ‹å®ƒå¯¹<code>&amp;str</code>çš„vecæœ‰ä»€ä¹ˆä½œç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn parse_str(input: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    let parsed_number = input.parse::&lt;i32&gt;()?;
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec!["Seven", "8", "9.0", "nice", "6060"];
    for item in str_vec {
        let parsed = parse_str(item);
        println!("{:?}", parsed);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Err(ParseIntError { kind: InvalidDigit })
Ok(8)
Err(ParseIntError { kind: InvalidDigit })
Err(ParseIntError { kind: InvalidDigit })
Ok(6060)
</code></pre>
<p>æˆ‘ä»¬æ˜¯æ€ä¹ˆæ‰¾åˆ°<code>std::num::ParseIntError</code>çš„å‘¢ï¼Ÿä¸€ä¸ªç®€å•çš„æ–¹æ³•å°±æ˜¯å† "é—®"ä¸€ä¸‹ç¼–è¯‘å™¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let failure = "Not a number".parse::&lt;i32&gt;();
    failure.rbrbrb(); // âš ï¸ Compiler: "What is rbrbrb()???"
}</code></pre></pre>
<p>ç¼–è¯‘å™¨ä¸æ‡‚ï¼Œè¯´ã€‚</p>
<pre><code class="language-text">error[E0599]: no method named `rbrbrb` found for enum `std::result::Result&lt;i32, std::num::ParseIntError&gt;` in the current scope
 --&gt; src\main.rs:3:13
  |
3 |     failure.rbrbrb();
  |             ^^^^^^ method not found in `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>æ‰€ä»¥<code>std::result::Result&lt;i32, std::num::ParseIntError&gt;</code>å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ç­¾åã€‚</p>
<p>æˆ‘ä»¬ä¸éœ€è¦å†™ <code>std::result::Result</code>ï¼Œå› ä¸º <code>Result</code> æ€»æ˜¯ "åœ¨èŒƒå›´å†…"(åœ¨èŒƒå›´å†… = å‡†å¤‡å¥½ä½¿ç”¨)ã€‚Rustå¯¹æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„æ‰€æœ‰ç±»å‹éƒ½æ˜¯è¿™æ ·åšçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¿…å†™<code>std::result::Result</code>ã€<code>std::collections::Vec</code>ç­‰ã€‚</p>
<p>æˆ‘ä»¬ç°åœ¨è¿˜æ²¡æœ‰å¤„ç†æ–‡ä»¶è¿™æ ·çš„ä¸œè¥¿ï¼Œæ‰€ä»¥?æ“ä½œç¬¦çœ‹èµ·æ¥è¿˜ä¸æ˜¯å¤ªæœ‰ç”¨ã€‚ä½†è¿™é‡Œæœ‰ä¸€ä¸ªæ— ç”¨ä½†å¿«é€Ÿçš„ä¾‹å­ï¼Œè¯´æ˜ä½ å¦‚ä½•åœ¨å•è¡Œä¸Šä½¿ç”¨å®ƒã€‚ä¸å…¶ç”¨ <code>.parse()</code> åˆ›å»ºä¸€ä¸ª <code>i32</code>ï¼Œä¸å¦‚åšæ›´å¤šã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª <code>u16</code>ï¼Œç„¶åæŠŠå®ƒå˜æˆ <code>String</code>ï¼Œå†å˜æˆ <code>u32</code>ï¼Œç„¶åå†å˜æˆ <code>String</code>ï¼Œæœ€åå˜æˆ <code>i32</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn parse_str(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let parsed_number = input.parse::&lt;u16&gt;()?.to_string().parse::&lt;u32&gt;()?.to_string().parse::&lt;i32&gt;()?; // Add a ? each time to check and pass it on
    Ok(parsed_number)
}

fn main() {
    let str_vec = vec!["Seven", "8", "9.0", "nice", "6060"];
    for item in str_vec {
        let parsed = parse_str(item);
        println!("{:?}", parsed);
    }
}</code></pre></pre>
<p>è¿™æ‰“å°å‡ºåŒæ ·çš„ä¸œè¥¿ï¼Œä½†è¿™æ¬¡æˆ‘ä»¬åœ¨ä¸€è¡Œä¸­å¤„ç†äº†ä¸‰ä¸ª<code>Result</code>ã€‚ç¨åæˆ‘ä»¬å°†å¯¹æ–‡ä»¶è¿›è¡Œå¤„ç†ï¼Œå› ä¸ºå®ƒä»¬æ€»æ˜¯è¿”å›<code>Result</code>ï¼Œå› ä¸ºå¾ˆå¤šäº‹æƒ…éƒ½å¯èƒ½å‡ºé”™ã€‚</p>
<p>æƒ³è±¡ä¸€ä¸‹:ä½ æƒ³æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œå‘å®ƒå†™å…¥ï¼Œç„¶åå…³é—­å®ƒã€‚é¦–å…ˆä½ éœ€è¦æˆåŠŸæ‰¾åˆ°è¿™ä¸ªæ–‡ä»¶(è¿™å°±æ˜¯ä¸€ä¸ª<code>Result</code>)ã€‚ç„¶åä½ éœ€è¦æˆåŠŸåœ°å†™å…¥å®ƒ(é‚£æ˜¯ä¸€ä¸ª<code>Result</code>)ã€‚å¯¹äº<code>?</code>ï¼Œä½ å¯ä»¥åœ¨ä¸€è¡Œä¸Šå®Œæˆã€‚</p>
<h3 id="when-panic-and-unwrap-are-good"><a class="header" href="#when-panic-and-unwrap-are-good">When panic and unwrap are good</a></h3>
<p>Rustæœ‰ä¸€ä¸ª<code>panic!</code>çš„å®ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥è®©ç¨‹åºå´©æºƒã€‚å®ƒä½¿ç”¨èµ·æ¥å¾ˆæ–¹ä¾¿ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("Time to panic!");
}</code></pre></pre>
<p>è¿è¡Œç¨‹åºæ—¶ï¼Œä¼šæ˜¾ç¤ºä¿¡æ¯<code>"Time to panic!"</code>ã€‚<code>thread 'main' panicked at 'Time to panic!', src\main.rs:2:3</code></p>
<p>ä½ ä¼šè®°å¾—<code>src\main.rs</code>æ˜¯ç›®å½•å’Œæ–‡ä»¶åï¼Œ<code>2:3</code>æ˜¯è¡Œåå’Œåˆ—åã€‚æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œä½ å°±å¯ä»¥æ‰¾åˆ°ä»£ç å¹¶ä¿®å¤å®ƒã€‚</p>
<p><code>panic!</code>æ˜¯ä¸€ä¸ªå¾ˆå¥½ç”¨çš„å®ï¼Œä»¥ç¡®ä¿ä½ çŸ¥é“ä»€ä¹ˆæ—¶å€™æœ‰å˜åŒ–ã€‚ä¾‹å¦‚ï¼Œè¿™ä¸ªå«åš<code>prints_three_things</code>çš„å‡½æ•°æ€»æ˜¯ä»ä¸€ä¸ªå‘é‡ä¸­æ‰“å°å‡ºç´¢å¼•[0]ã€[1]å’Œ[2]ã€‚è¿™æ²¡å…³ç³»ï¼Œå› ä¸ºæˆ‘ä»¬æ€»æ˜¯ç»™å®ƒä¸€ä¸ªæœ‰ä¸‰ä¸ªå…ƒç´ çš„å‘é‡ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn prints_three_things(vector: Vec&lt;i32&gt;) {
    println!("{}, {}, {}", vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    prints_three_things(my_vec);
}</code></pre></pre>
<p>å®ƒæ‰“å°å‡º<code>8, 9, 10</code>ï¼Œä¸€åˆ‡æ­£å¸¸ã€‚</p>
<p>ä½†è¯•æƒ³ä¸€ä¸‹ï¼Œåæ¥æˆ‘ä»¬å†™çš„ä»£ç è¶Šæ¥è¶Šå¤šï¼Œå¿˜è®°äº†<code>my_vec</code>åªèƒ½æœ‰ä¸‰ä¸ªå…ƒç´ ã€‚ç°åœ¨<code>my_vec</code>åœ¨è¿™éƒ¨åˆ†æœ‰å…­ä¸ªå…ƒç´ ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn prints_three_things(vector: Vec&lt;i32&gt;) {
  println!("{}, {}, {}", vector[0], vector[1], vector[2]);
}

fn main() {
  let my_vec = vec![8, 9, 10, 10, 55, 99]; // Now my_vec has six things
  prints_three_things(my_vec);
}</code></pre></pre>
<p>ä¸ä¼šå‘ç”Ÿé”™è¯¯ï¼Œå› ä¸º[0]å’Œ[1]å’Œ[2]éƒ½åœ¨è¿™ä¸ªè¾ƒé•¿çš„<code>Vec</code>é‡Œé¢ã€‚ä½†å¦‚æœåªèƒ½æœ‰ä¸‰ä¸ªå…ƒç´ å‘¢ï¼Ÿæˆ‘ä»¬å°±ä¸ä¼šçŸ¥é“æœ‰é—®é¢˜äº†ï¼Œå› ä¸ºç¨‹åºä¸ä¼šå´©æºƒã€‚æˆ‘ä»¬åº”è¯¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn prints_three_things(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!("my_vec must always have three items") // will panic if the length is not 3
    }
    println!("{}, {}, {}", vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10];
    prints_three_things(my_vec);
}</code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬çŸ¥é“ï¼Œå¦‚æœå‘é‡æœ‰6ä¸ªå…ƒç´ ï¼Œå®ƒåº”è¯¥è¦å´©æºƒ:</p>
<pre><pre class="playground"><code class="language-rust">    // âš ï¸
fn prints_three_things(vector: Vec&lt;i32&gt;) {
    if vector.len() != 3 {
        panic!("my_vec must always have three items")
    }
    println!("{}, {}, {}", vector[0], vector[1], vector[2]);
}

fn main() {
    let my_vec = vec![8, 9, 10, 10, 55, 99];
    prints_three_things(my_vec);
}</code></pre></pre>
<p>è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†<code>thread 'main' panicked at 'my_vec must always have three items', src\main.rs:8:9</code>ã€‚å¤šäºäº†<code>panic!</code>ï¼Œæˆ‘ä»¬ç°åœ¨è®°å¾—<code>my_vec</code>åº”è¯¥åªæœ‰ä¸‰ä¸ªå…ƒç´ ã€‚æ‰€ä»¥<code>panic!</code>æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å®ï¼Œå¯ä»¥åœ¨ä½ çš„ä»£ç ä¸­åˆ›å»ºæé†’ã€‚</p>
<p>è¿˜æœ‰ä¸‰ä¸ªä¸<code>panic!</code>ç±»ä¼¼çš„å®ï¼Œä½ åœ¨æµ‹è¯•ä¸­ç»å¸¸ä½¿ç”¨ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯ <code>assert!</code>, <code>assert_eq!</code>, å’Œ <code>assert_ne!</code>.</p>
<p>ä¸‹é¢æ˜¯å®ƒä»¬çš„æ„æ€ã€‚</p>
<ul>
<li><code>assert!()</code>: å¦‚æœ<code>()</code>é‡Œé¢çš„éƒ¨åˆ†ä¸æ˜¯çœŸçš„, ç¨‹åºå°±ä¼šå´©æºƒ.</li>
<li><code>assert_eq!()</code>:<code>()</code>é‡Œé¢çš„ä¸¤ä¸ªå…ƒç´ å¿…é¡»ç›¸ç­‰ã€‚</li>
<li><code>assert_ne!()</code>:<code>()</code>é‡Œé¢çš„ä¸¤ä¸ªå…ƒç´ å¿…é¡»ä¸ç›¸ç­‰ã€‚(<em>ne</em>è¡¨ç¤ºä¸ç›¸ç­‰)</li>
</ul>
<p>ä¸€äº›ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = "Loki Laufeyson";

    assert!(my_name == "Loki Laufeyson");
    assert_eq!(my_name, "Loki Laufeyson");
    assert_ne!(my_name, "Mithridates");
}</code></pre></pre>
<p>è¿™ä¸ä¼šæœ‰ä»»ä½•ä½œç”¨ï¼Œå› ä¸ºä¸‰ä¸ªæ–­è¨€å®éƒ½æ²¡æœ‰é—®é¢˜ã€‚(è¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„)</p>
<p>å¦‚æœä½ æ„¿æ„ï¼Œè¿˜å¯ä»¥åŠ ä¸ªæç¤ºä¿¡æ¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = "Loki Laufeyson";

    assert!(
        my_name == "Loki Laufeyson",
        "{} should be Loki Laufeyson",
        my_name
    );
    assert_eq!(
        my_name, "Loki Laufeyson",
        "{} and Loki Laufeyson should be equal",
        my_name
    );
    assert_ne!(
        my_name, "Mithridates",
        "You entered {}. Input must not equal Mithridates",
        my_name
    );
}</code></pre></pre>
<p>è¿™äº›ä¿¡æ¯åªæœ‰åœ¨ç¨‹åºå´©æºƒæ—¶æ‰ä¼šæ˜¾ç¤ºã€‚æ‰€ä»¥å¦‚æœä½ è¿è¡Œè¿™ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_name = "Mithridates";

    assert_ne!(
        my_name, "Mithridates",
        "You enter {}. Input must not equal Mithridates",
        my_name
    );
}</code></pre></pre>
<p>å®ƒå°†æ˜¾ç¤º:</p>
<pre><code class="language-text">thread 'main' panicked at 'assertion failed: `(left != right)`
  left: `"Mithridates"`,
 right: `"Mithridates"`: You entered Mithridates. Input must not equal Mithridates', src\main.rs:4:5
</code></pre>
<p>æ‰€ä»¥å®ƒè¯´ "ä½ è¯´å·¦!=å³ï¼Œä½†å·¦==å³"ã€‚è€Œä¸”å®ƒæ˜¾ç¤ºæˆ‘ä»¬çš„ä¿¡æ¯è¯´<code>You entered Mithridates. Input must not equal Mithridates</code>ã€‚</p>
<p>å½“ä½ åœ¨å†™ç¨‹åºçš„æ—¶å€™ï¼Œæƒ³è®©å®ƒåœ¨å‡ºç°é—®é¢˜çš„æ—¶å€™å´©æºƒï¼Œ<code>unwrap</code>æ˜¯ä¸ªå¥½æ³¨æ„ã€‚å½“ä½ çš„ä»£ç å†™å®Œåï¼ŒæŠŠ<code>unwrap</code>æ”¹æˆå…¶ä»–ä¸ä¼šå´©æºƒçš„ä¸œè¥¿å°±å¥½äº†ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥ç”¨<code>expect</code>ï¼Œå®ƒå’Œ<code>unwrap</code>ä¸€æ ·ï¼Œä½†æ˜¯æ›´å¥½ä¸€äº›ï¼Œå› ä¸ºå®ƒæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰ä¿¡æ¯ã€‚æ•™ç§‘ä¹¦é€šå¸¸ä¼šç»™å‡ºè¿™æ ·çš„å»ºè®®:"å¦‚æœä½ ç»å¸¸ä½¿ç”¨<code>.unwrap()</code>, è‡³å°‘ä¹Ÿè¦ç”¨<code>.expect()</code>æ¥è·å¾—æ›´å¥½çš„é”™è¯¯ä¿¡æ¯."</p>
<p>è¿™æ ·ä¼šå´©æºƒçš„:</p>
<pre><pre class="playground"><code class="language-rust">   // âš ï¸
fn get_fourth(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let fourth = input.get(3).unwrap();
    *fourth
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let fourth = get_fourth(&amp;my_vec);
}</code></pre></pre>
<p>é”™è¯¯ä¿¡æ¯æ˜¯<code>thread 'main' panicked at 'called Option::unwrap() on a None value', src\main.rs:7:18</code>ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬ç”¨<code>expect</code>æ¥å†™è‡ªå·±çš„ä¿¡æ¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">   // âš ï¸
fn get_fourth(input: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let fourth = input.get(3).expect("Input vector needs at least 4 items");
    *fourth
}

fn main() {
    let my_vec = vec![9, 0, 10];
    let fourth = get_fourth(&amp;my_vec);
}</code></pre></pre>
<p>åˆå´©æºƒäº†ï¼Œä½†é”™è¯¯æ¯”è¾ƒå¤šã€‚<code>thread 'main' panicked at 'Input vector needs at least 4 items', src\main.rs:7:18</code>. <code>.expect()</code>å› ä¸ºè¿™ä¸ªåŸå› æ¯”<code>.unwrap()</code>è¦å¥½ä¸€ç‚¹ï¼Œä½†æ˜¯åœ¨<code>None</code>ä¸Šè¿˜æ˜¯ä¼šå´©æºƒã€‚ç°åœ¨è¿™é‡Œæœ‰ä¸€ä¸ªé”™è¯¯çš„æ¡ˆä¾‹ï¼Œä¸€ä¸ªå‡½æ•°è¯•å›¾unwrapä¸¤æ¬¡ã€‚å®ƒéœ€è¦ä¸€ä¸ª<code>Vec&lt;Option&lt;i32&gt;&gt;</code>ï¼Œæ‰€ä»¥å¯èƒ½æ¯ä¸ªéƒ¨åˆ†éƒ½ä¼šæœ‰ä¸€ä¸ª<code>Some&lt;i32&gt;</code>ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ª<code>None</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn try_two_unwraps(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!("Index 0 is: {}", input[0].unwrap());
    println!("Index 1 is: {}", input[1].unwrap());
}

fn main() {
    let vector = vec![None, Some(1000)]; // This vector has a None, so it will panic
    try_two_unwraps(vector);
}</code></pre></pre>
<p>æ¶ˆæ¯æ˜¯:<code>thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src\main.rs:2:32</code>ã€‚æˆ‘ä»¬ä¸æ£€æŸ¥è¡Œå·ï¼Œå°±ä¸çŸ¥é“æ˜¯ç¬¬ä¸€ä¸ª<code>.unwrap()</code>è¿˜æ˜¯ç¬¬äºŒä¸ª<code>.unwrap()</code>ã€‚æœ€å¥½æ˜¯æ£€æŸ¥ä¸€ä¸‹é•¿åº¦ï¼Œä¹Ÿä¸è¦unwrapã€‚ä¸è¿‡æœ‰äº†<code>.expect()</code>è‡³å°‘ä¼šå¥½<em>ä¸€ç‚¹</em>ã€‚ä¸‹é¢æ˜¯<code>.expect()</code>çš„æƒ…å†µï¼š</p>
<pre><pre class="playground"><code class="language-rust">fn try_two_unwraps(input: Vec&lt;Option&lt;i32&gt;&gt;) {
    println!("Index 0 is: {}", input[0].expect("The first unwrap had a None!"));
    println!("Index 1 is: {}", input[1].expect("The second unwrap had a None!"));
}

fn main() {
    let vector = vec![None, Some(1000)];
    try_two_unwraps(vector);
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œè¿™æ˜¯å¥½ä¸€ç‚¹çš„ã€‚<code>thread 'main' panicked at 'The first unwrap had a None!', src\main.rs:2:32</code>. æˆ‘ä»¬ä¹Ÿæœ‰è¡Œå·ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°å®ƒã€‚</p>
<p>å¦‚æœä½ æƒ³ä¸€ç›´æœ‰ä¸€ä¸ªä½ æƒ³é€‰æ‹©çš„å€¼ï¼Œä¹Ÿå¯ä»¥ç”¨<code>unwrap_or</code>ã€‚å¦‚æœä½ è¿™æ ·åšï¼Œå®ƒæ°¸è¿œä¸ä¼šå´©æºƒã€‚å°±æ˜¯è¿™æ ·çš„ã€‚</p>
<ul>
<li>1)å¥½ï¼Œå› ä¸ºä½ çš„ç¨‹åºä¸ä¼šå´©æºƒï¼Œä½†</li>
<li>2)å¦‚æœä½ æƒ³è®©ç¨‹åºåœ¨å‡ºç°é—®é¢˜æ—¶å´©æºƒï¼Œä¹Ÿè®¸ä¸å¥½ã€‚</li>
</ul>
<p>ä½†é€šå¸¸æˆ‘ä»¬éƒ½ä¸å¸Œæœ›è‡ªå·±çš„ç¨‹åºå´©æºƒï¼Œæ‰€ä»¥<code>unwrap_or</code>æ˜¯ä¸ªä¸é”™çš„æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or(&amp;0); // If .get doesn't work, we will make the value &amp;0.
                                              // .get returns a reference, so we need &amp;0 and not 0
                                              // You can write "let *fourth" with a * if you want fourth to be
                                              // a 0 and not a &amp;0, but here we just print so it doesn't matter

    println!("{}", fourth);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>0</code>ï¼Œå› ä¸º <code>.unwrap_or(&amp;0)</code> ç»™å‡ºäº†ä¸€ä¸ª 0ï¼Œå³ä½¿å®ƒæ˜¯ <code>None</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç‰¹æ€§"><a class="header" href="#ç‰¹æ€§">ç‰¹æ€§</a></h2>
<p>æˆ‘ä»¬ä»¥å‰è§è¿‡trait:<code>Debug</code>ã€<code>Copy</code>ã€<code>Clone</code>éƒ½æ˜¯traitã€‚è¦ç»™ä¸€ä¸ªç±»å‹ä¸€ä¸ªtraitï¼Œå°±å¿…é¡»å®ç°å®ƒã€‚å› ä¸º<code>Debug</code>å’Œå…¶ä»–çš„traitéƒ½å¾ˆå¸¸è§ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰è‡ªåŠ¨å®ç°çš„å±æ€§ã€‚è¿™å°±æ˜¯å½“ä½ å†™ä¸‹<code>#[derive(Debug)]</code>æ‰€å‘ç”Ÿçš„äº‹æƒ…:ä½ è‡ªåŠ¨å®ç°äº†<code>Debug</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyStruct {
    number: usize,
}

fn main() {}</code></pre></pre>
<p>ä½†æ˜¯å…¶ä»–çš„ç‰¹æ€§å°±æ¯”è¾ƒå›°éš¾äº†ï¼Œæ‰€ä»¥éœ€è¦ç”¨<code>impl</code>æ‰‹åŠ¨å®ç°ã€‚ä¾‹å¦‚ï¼Œ<code>Add</code>(åœ¨<code>std::ops::Add</code>å¤„æ‰¾åˆ°)æ˜¯ç”¨æ¥ç´¯åŠ ä¸¤ä¸ªä¸œè¥¿çš„ã€‚ä½†æ˜¯Rustå¹¶ä¸çŸ¥é“ä½ åˆ°åº•è¦æ€ä¹ˆç´¯åŠ ï¼Œæ‰€ä»¥ä½ å¿…é¡»å‘Šè¯‰å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct ThingsToAdd {
    first_thing: u32,
    second_thing: f32,
}

fn main() {}</code></pre></pre>
<p>æˆ‘ä»¬å¯ä»¥ç´¯åŠ <code>first_thing</code>å’Œ<code>second_thing</code>ï¼Œä½†æˆ‘ä»¬éœ€è¦æä¾›æ›´å¤šä¿¡æ¯ã€‚ä¹Ÿè®¸æˆ‘ä»¬æƒ³è¦ä¸€ä¸ª<code>f32</code>ï¼Œæ‰€ä»¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
let result = self.second_thing + self.first_thing as f32
<span class="boring">}</span></code></pre></pre>
<p>ä½†ä¹Ÿè®¸æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
let result = self.second_thing as u32 + self.first_thing
<span class="boring">}</span></code></pre></pre>
<p>æˆ–è€…æˆ‘ä»¬æƒ³æŠŠ<code>self.first_thing</code>æ”¾åœ¨<code>self.second_thing</code>æ—è¾¹ï¼Œè¿™æ ·åŠ ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬æŠŠ55åŠ åˆ°33.4ï¼Œæˆ‘ä»¬è¦çœ‹åˆ°çš„æ˜¯5533.4ï¼Œè€Œä¸æ˜¯88.4ã€‚</p>
<p>æ‰€ä»¥é¦–å…ˆæˆ‘ä»¬çœ‹ä¸€ä¸‹å¦‚ä½•åˆ›å»ºä¸€ä¸ªtraitã€‚å…³äº<code>trait</code>ï¼Œè¦è®°ä½çš„é‡è¦ä¸€ç‚¹æ˜¯ï¼Œå®ƒä»¬æ˜¯å…³äºè¡Œä¸ºçš„ã€‚è¦åˆ›å»ºä¸€ä¸ªtraitï¼Œå†™ä¸‹å•è¯<code>trait</code>ï¼Œç„¶ååˆ›å»ºä¸€äº›å‡½æ•°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // A simple struct - an Animal only has a name
    name: String,
}

trait Dog { // The dog trait gives some functionality
    fn bark(&amp;self) { // It can bark
        println!("Woof woof!");
    }
    fn run(&amp;self) { // and it can run
        println!("The dog is running!");
    }
}

impl Dog for Animal {} // Now Animal has the trait Dog

fn main() {
    let rover = Animal {
        name: "Rover".to_string(),
    };

    rover.bark(); // Now Animal can use bark()
    rover.run();  // and it can use run()
}</code></pre></pre>
<p>è¿™ä¸ªæ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸æƒ³æ‰“å° "ç‹—åœ¨è·‘"ã€‚å¦‚æœä½ æƒ³çš„è¯ï¼Œä½ å¯ä»¥æ”¹å˜<code>trait</code>ç»™ä½ çš„æ–¹æ³•ï¼Œä½†ä½ å¿…é¡»æœ‰ç›¸åŒçš„ç­¾åã€‚è¿™æ„å‘³ç€å®ƒéœ€è¦æ¥å—åŒæ ·çš„ä¸œè¥¿ï¼Œå¹¶è¿”å›åŒæ ·çš„ä¸œè¥¿ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹å˜ <code>.run()</code> çš„æ–¹æ³•ï¼Œä½†æˆ‘ä»¬å¿…é¡»éµå¾ªç­¾åã€‚ç­¾åè¯´</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
fn run(&amp;self) {
    println!("The dog is running!");
}
<span class="boring">}</span></code></pre></pre>
<p><code>fn run(&amp;self)</code>çš„æ„æ€æ˜¯ "fn <code>run()</code>ä»¥<code>&amp;self</code>ä¸ºå‚æ•°ï¼Œä¸è¿”å›ä»»ä½•å†…å®¹"ã€‚æ‰€ä»¥ä½ ä¸èƒ½è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;self) -&gt; i32 { // âš ï¸
    5
}
<span class="boring">}</span></code></pre></pre>
<p>Rustä¼šè¯´ã€‚</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>ä½†æˆ‘ä»¬å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // A simple struct - an Animal only has a name
    name: String,
}

trait Dog { // The dog trait gives some functionality
    fn bark(&amp;self) { // It can bark
        println!("Woof woof!");
    }
    fn run(&amp;self) { // and it can run
        println!("The dog is running!");
    }
}

impl Dog for Animal {
    fn run(&amp;self) {
        println!("{} is running!", self.name);
    }
}

fn main() {
    let rover = Animal {
        name: "Rover".to_string(),
    };

    rover.bark(); // Now Animal can use bark()
    rover.run();  // and it can use run()
}</code></pre></pre>
<p>ç°åœ¨å®ƒæ‰“å°çš„æ˜¯ <code>Rover is running!</code>ã€‚è¿™æ˜¯å¥½çš„ï¼Œå› ä¸ºæˆ‘ä»¬è¿”å›çš„æ˜¯ <code>()</code>ï¼Œæˆ–è€…è¯´ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œè¿™å°±æ˜¯traitæ‰€è¯´çš„ã€‚</p>
<p>å½“ä½ å†™ä¸€ä¸ªtraitçš„æ—¶å€™ï¼Œä½ å¯ä»¥ç›´æ¥å†™å‡½æ•°ç­¾åï¼Œä½†å¦‚æœä½ è¿™æ ·åšï¼Œç”¨æˆ·å°†ä¸å¾—ä¸å†™å‡½æ•°å®ç°ã€‚æˆ‘ä»¬æ¥è¯•è¯•ã€‚ç°åœ¨æˆ‘ä»¬æŠŠ<code>bark()</code>å’Œ<code>run()</code>æ”¹æˆåªè¯´<code>fn bark(&amp;self);</code>å’Œ<code>fn run(&amp;self);</code>ã€‚è¿™ä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„å‡½æ•°å®ç°ï¼Œæ‰€ä»¥å¿…é¡»ç”±ç”¨æˆ·æ¥å†™ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    name: String,
}

trait Dog {
    fn bark(&amp;self); // bark() says it needs a &amp;self and returns nothing
    fn run(&amp;self); // run() says it needs a &amp;self and returns nothing.
                   // So now we have to write them ourselves.
}

impl Dog for Animal {
    fn bark(&amp;self) {
        println!("{}, stop barking!!", self.name);
    }
    fn run(&amp;self) {
        println!("{} is running!", self.name);
    }
}

fn main() {
    let rover = Animal {
        name: "Rover".to_string(),
    };

    rover.bark();
    rover.run();
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œå½“ä½ åˆ›å»ºä¸€ä¸ªtraitæ—¶ï¼Œä½ å¿…é¡»æ€è€ƒ:"æˆ‘åº”è¯¥å†™å“ªäº›åŠŸèƒ½ï¼Ÿè€Œç”¨æˆ·åº”è¯¥å†™å“ªäº›å‡½æ•°ï¼Ÿ" å¦‚æœä½ è®¤ä¸ºç”¨æˆ·æ¯æ¬¡ä½¿ç”¨å‡½æ•°çš„æ–¹å¼åº”è¯¥æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆå°±æŠŠå‡½æ•°å†™å‡ºæ¥ã€‚å¦‚æœä½ è®¤ä¸ºç”¨æˆ·ä¼šä»¥ä¸åŒçš„æ–¹å¼ä½¿ç”¨ï¼Œé‚£å°±å†™å‡ºå‡½æ•°ç­¾åå³å¯ã€‚</p>
<p>æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬å°è¯•ä¸ºæˆ‘ä»¬çš„structå®ç°Displayç‰¹æ€§ã€‚é¦–å…ˆæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªç®€å•çš„ç»“æ„ä½“:</p>
<pre><pre class="playground"><code class="language-rust">struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };
}</code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬è¦æ‰“å°<code>mr_mantle</code>ã€‚è°ƒè¯•å¾ˆå®¹æ˜“å¾—å‡ºã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };

    println!("Mr. Mantle is a {:?}", mr_mantle);
}</code></pre></pre>
<p>ä½†Debugæ‰“å°ä¸æ˜¯æœ€æ¼‚äº®çš„æ–¹å¼ï¼Œå› ä¸ºå®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><code class="language-text">Mr. Mantle is a Cat { name: "Reggie Mantle", age: 4 }
</code></pre>
<p>å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦æ›´å¥½çš„æ‰“å°ï¼Œå°±éœ€è¦å®ç°<code>Display</code>ä¸º<code>Cat</code>ã€‚åœ¨<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a>ä¸Šæˆ‘ä»¬å¯ä»¥çœ‹åˆ°Displayçš„ä¿¡æ¯ï¼Œè¿˜æœ‰ä¸€ä¸ªä¾‹å­ã€‚å®ƒè¯´</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.longitude, self.latitude)
    }
}

fn main() {}</code></pre></pre>
<p>æœ‰äº›éƒ¨åˆ†æˆ‘ä»¬è¿˜ä¸æ˜ç™½ï¼Œæ¯”å¦‚<code>&lt;'_&gt;</code>å’Œ<code>f</code>åœ¨åšä»€ä¹ˆã€‚ä½†æˆ‘ä»¬ç†è§£<code>Position</code>ç»“æ„ä½“:å®ƒåªæ˜¯ä¸¤ä¸ª<code>f32</code>ã€‚æˆ‘ä»¬ä¹Ÿæ˜ç™½ï¼Œ<code>self.longitude</code>å’Œ<code>self.latitude</code>æ˜¯ç»“æ„ä½“ä¸­çš„å­—æ®µã€‚æ‰€ä»¥ï¼Œä¹Ÿè®¸æˆ‘ä»¬çš„ç»“æ„ä½“å°±å¯ä»¥ç”¨è¿™ä¸ªä»£ç ï¼Œç”¨<code>self.name</code>å’Œ<code>self.age</code>ã€‚å¦å¤–ï¼Œ<code>write!</code>çœ‹èµ·æ¥å¾ˆåƒ<code>println!</code>ï¼Œæ‰€ä»¥å¾ˆç†Ÿæ‚‰ã€‚æ‰€ä»¥æˆ‘ä»¬è¿™æ ·å†™ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{} is a cat who is {} years old.", self.name, self.age)
    }
}

fn main() {}</code></pre></pre>
<p>è®©æˆ‘ä»¬æ·»åŠ ä¸€ä¸ª<code>fn main()</code>ã€‚ç°åœ¨æˆ‘ä»¬çš„ä»£ç æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
      write!(f, "{} is a cat who is {} years old.", self.name, self.age)
  }
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };

    println!("{}", mr_mantle);
}</code></pre></pre>
<p>æˆåŠŸäº†! ç°åœ¨ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨<code>{}</code>æ‰“å°æ—¶ï¼Œæˆ‘ä»¬å¾—åˆ°<code>Reggie Mantle is a cat who is 4 years old.</code>ã€‚è¿™çœ‹èµ·æ¥å¥½å¤šäº†ã€‚</p>
<p>é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œå¦‚æœä½ å®ç°äº†<code>Display</code>ï¼Œé‚£ä¹ˆä½ å°±å¯ä»¥å…è´¹å¾—åˆ°<code>ToString</code>çš„ç‰¹æ€§ã€‚è¿™æ˜¯å› ä¸ºä½ ä½¿ç”¨<code>format!</code>å®æ¥å®ç°<code>.fmt()</code>å‡½æ•°ï¼Œè¿™è®©ä½ å¯ä»¥ç”¨<code>.to_string()</code>æ¥åˆ›å»ºä¸€ä¸ª<code>String</code>ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åšè¿™æ ·çš„äº‹æƒ…ï¼Œæˆ‘ä»¬æŠŠ<code>reggie_mantle</code>ä¼ ç»™ä¸€ä¸ªæƒ³è¦<code>String</code>çš„å‡½æ•°ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{} is a cat who is {} years old.", self.name, self.age)
    }
}

fn print_cats(pet: String) {
    println!("{}", pet);
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };

    print_cats(mr_mantle.to_string()); // Turn him into a String here
    println!("Mr. Mantle's String is {} letters long.", mr_mantle.to_string().chars().count()); // Turn him into chars and count them
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Reggie Mantle is a cat who is 4 years old.
Mr. Mantle's String is 42 letters long.
</code></pre>
<p>å…³äºtraitï¼Œè¦è®°ä½çš„æ˜¯ï¼Œå®ƒä»¬æ˜¯å…³äºæŸäº›ä¸œè¥¿çš„è¡Œä¸ºã€‚ä½ çš„<code>struct</code>æ˜¯å¦‚ä½•è¡ŒåŠ¨çš„ï¼Ÿå®ƒèƒ½åšä»€ä¹ˆï¼Ÿè¿™å°±æ˜¯traitçš„ä½œç”¨ã€‚å¦‚æœä½ æƒ³æƒ³æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢æ‰€çœ‹åˆ°çš„ä¸€äº›traitï¼Œå®ƒä»¬éƒ½æ˜¯å…³äºè¡Œä¸ºçš„:<code>Copy</code>æ˜¯ä¸€ä¸ªç±»å‹å¯ä»¥åšçš„äº‹æƒ…ã€‚<code>Display</code>ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ã€‚<code>ToString</code>æ˜¯å¦ä¸€ä¸ªtraitï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹å¯ä»¥åšçš„äº‹æƒ…:å®ƒå¯ä»¥å˜åŒ–æˆä¸€ä¸ª<code>String</code>ã€‚åœ¨æˆ‘ä»¬çš„ <code>Dog</code> traitä¸­ï¼Œ<em>Dog</em>è¿™ä¸ªè¯å¹¶ä¸æ„å‘³ç€ä½ èƒ½åšçš„äº‹æƒ…ï¼Œä½†å®ƒç»™å‡ºäº†ä¸€äº›è®©å®ƒåšäº‹æƒ…çš„æ–¹æ³•ã€‚
ä½ ä¹Ÿå¯ä»¥ä¸º <code>struct Poodle</code> æˆ– <code>struct Beagle</code> å®ç°å®ƒï¼Œå®ƒä»¬éƒ½ä¼šå¾—åˆ° <code>Dog</code> æ–¹æ³•ã€‚</p>
<p>è®©æˆ‘ä»¬å†çœ‹ä¸€ä¸ªä¸å•çº¯è¡Œä¸ºè”ç³»æ›´ç´§å¯†çš„ä¾‹å­ã€‚æˆ‘ä»¬å°†æƒ³è±¡ä¸€ä¸ªæœ‰ä¸€äº›ç®€å•è§’è‰²çš„å¹»æƒ³æ¸¸æˆã€‚ä¸€ä¸ªæ˜¯<code>Monster</code>ï¼Œå¦å¤–ä¸¤ä¸ªæ˜¯<code>Wizard</code>å’Œ<code>Ranger</code>ã€‚<code>Monster</code>åªæ˜¯æœ‰<code>health</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”»å‡»å®ƒï¼Œå…¶ä»–ä¸¤ä¸ªè¿˜æ²¡æœ‰ä»€ä¹ˆã€‚ä½†æ˜¯æˆ‘ä»¬åšäº†ä¸¤ä¸ªtraitã€‚ä¸€ä¸ªå«<code>FightClose</code>ï¼Œè®©ä½ è¿‘èº«ä½œæˆ˜ã€‚å¦ä¸€ä¸ªæ˜¯<code>FightFromDistance</code>ï¼Œè®©ä½ åœ¨è¿œå¤„æˆ˜æ–—ã€‚åªæœ‰<code>Ranger</code>å¯ä»¥ä½¿ç”¨<code>FightFromDistance</code>ã€‚ä¸‹é¢æ˜¯å®ƒçš„æ ·å­:</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

struct Wizard {}
struct Ranger {}

trait FightClose {
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            "You attack with your sword. Your opponent now has {} health left.",
            opponent.health
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            "You attack with your hand. Your opponent now has {} health left.",
            opponent.health
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance {
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                "You attack with your bow. Your opponent now has {} health left.",
                opponent.health
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            "You attack with your rock. Your opponent now has {} health left.",
            opponent.health
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard {};
    let aragorn = Ranger {};

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left.
You attack with your bow. Your opponent now has 20 health left.
</code></pre>
<p>æˆ‘ä»¬åœ¨traité‡Œé¢ä¸€ç›´ä¼ é€’<code>self</code>ï¼Œä½†æ˜¯æˆ‘ä»¬ç°åœ¨ä¸èƒ½ç”¨å®ƒåšä»€ä¹ˆã€‚é‚£æ˜¯å› ä¸º Rust ä¸çŸ¥é“ä»€ä¹ˆç±»å‹ä¼šä½¿ç”¨å®ƒã€‚å®ƒå¯èƒ½æ˜¯ä¸€ä¸ª <code>Wizard</code>ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ª <code>Ranger</code>ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªå«åš <code>Toefocfgetobjtnode</code> çš„æ–°ç»“æ„ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚ä¸ºäº†è®©<code>self</code>å…·æœ‰ä¸€å®šçš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨traitä¸­æ·»åŠ å¿…è¦çš„traitã€‚æ¯”å¦‚è¯´ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ç”¨<code>{:?}</code>æ‰“å°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦<code>Debug</code>ã€‚ä½ åªè¦æŠŠå®ƒå†™åœ¨<code>:</code>(å†’å·)åé¢ï¼Œå°±å¯ä»¥æŠŠå®ƒæ·»åŠ åˆ°traitä¸­ã€‚ç°åœ¨æˆ‘ä»¬çš„ä»£ç æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

#[derive(Debug)] // Now Wizard has Debug
struct Wizard {
    health: i32, // Now Wizard has health
}
#[derive(Debug)] // So does Ranger
struct Ranger {
    health: i32, // So does Ranger
}

trait FightClose: std::fmt::Debug { // Now a type needs Debug to use FightClose
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            "You attack with your sword. Your opponent now has {} health left. You are now at: {:?}", // We can now print self with {:?} because we have Debug
            opponent.health, &amp;self
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            "You attack with your hand. Your opponent now has {} health left.  You are now at: {:?}",
            opponent.health, &amp;self
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance: std::fmt::Debug { // We could also do trait FightFromDistance: FightClose because FightClose needs Debug
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                "You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}",
                opponent.health, self
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            "You attack with your rock. Your opponent now has {} health left.  You are now at: {:?}",
            opponent.health, self
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>ç°åœ¨è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
</code></pre>
<p>åœ¨çœŸå®çš„æ¸¸æˆä¸­ï¼Œå¯èƒ½æœ€å¥½ä¸ºæ¯ä¸ªç±»å‹é‡å†™è¿™ä¸ªï¼Œå› ä¸º<code>You are now at: Wizard { health: 60 }</code>çœ‹èµ·æ¥æœ‰ç‚¹å¯ç¬‘ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆtraité‡Œé¢çš„æ–¹æ³•é€šå¸¸å¾ˆç®€å•ï¼Œå› ä¸ºä½ ä¸çŸ¥é“ä»€ä¹ˆç±»å‹ä¼šä½¿ç”¨å®ƒã€‚ä¾‹å¦‚ï¼Œä½ ä¸èƒ½å†™å‡º <code>self.0 += 10</code> è¿™æ ·çš„ä¸œè¥¿ã€‚ä½†æ˜¯è¿™ä¸ªä¾‹å­è¡¨æ˜ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æˆ‘ä»¬æ­£åœ¨å†™çš„traité‡Œé¢ä½¿ç”¨å…¶ä»–çš„traitã€‚å½“æˆ‘ä»¬è¿™æ ·åšçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€äº›æˆ‘ä»¬å¯ä»¥ä½¿ç”¨çš„æ–¹æ³•ã€‚</p>
<p>å¦å¤–ä¸€ç§ä½¿ç”¨traitçš„æ–¹å¼æ˜¯ä½¿ç”¨æ‰€è°“çš„<code>trait bounds</code>ã€‚æ„æ€æ˜¯ "é€šè¿‡ä¸€ä¸ªtraitè¿›è¡Œé™åˆ¶"ã€‚traité™åˆ¶å¾ˆç®€å•ï¼Œå› ä¸ºä¸€ä¸ªtraitå®é™…ä¸Šä¸éœ€è¦ä»»ä½•æ–¹æ³•ï¼Œæˆ–è€…è¯´æ ¹æœ¬ä¸éœ€è¦ä»»ä½•ä¸œè¥¿ã€‚è®©æˆ‘ä»¬ç”¨ç±»ä¼¼ä½†ä¸åŒçš„ä¸œè¥¿é‡å†™æˆ‘ä»¬çš„ä»£ç ã€‚è¿™æ¬¡æˆ‘ä»¬çš„traitæ²¡æœ‰ä»»ä½•æ–¹æ³•ï¼Œä½†æˆ‘ä»¬æœ‰å…¶ä»–éœ€è¦traitä½¿ç”¨çš„å‡½æ•°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // So we don't have to write std::fmt::Debug every time now

struct Monster {
    health: i32,
}

#[derive(Debug)]
struct Wizard {
    health: i32,
}
#[derive(Debug)]
struct Ranger {
    health: i32,
}

trait Magic{} // No methods for any of these traits. They are just trait bounds
trait FightClose {}
trait FightFromDistance {}

impl FightClose for Ranger{} // Each type gets FightClose,
impl FightClose for Wizard {}
impl FightFromDistance for Ranger{} // but only Ranger gets FightFromDistance
impl Magic for Wizard{}  // and only Wizard gets Magic

fn attack_with_bow&lt;T: FightFromDistance + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 10 {
        opponent.health -= 10;
        println!(
            "You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}",
            opponent.health, character
        );
    }
}

fn attack_with_sword&lt;T: FightClose + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster) {
    opponent.health -= 10;
    println!(
        "You attack with your sword. Your opponent now has {} health left. You are now at: {:?}",
        opponent.health, character
    );
}

fn fireball&lt;T: Magic + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 15 {
        opponent.health -= 20;
        println!("You raise your hands and cast a fireball! Your opponent now has {} health left. You are now at: {:?}",
    opponent.health, character);
    }
}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    attack_with_sword(&amp;radagast, &amp;mut uruk_hai);
    attack_with_bow(&amp;aragorn, &amp;mut uruk_hai, 8);
    fireball(&amp;radagast, &amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°å‡ºæ¥çš„ä¸œè¥¿å‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
You raise your hands and cast a fireball! Your opponent now has 0 health left. You are now at: Wizard { health: 60 }
</code></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥çœ‹åˆ°ï¼Œå½“ä½ ä½¿ç”¨traitsæ—¶ï¼Œæœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥åšåŒæ ·çš„äº‹æƒ…ã€‚è¿™ä¸€åˆ‡éƒ½å–å†³äºä»€ä¹ˆå¯¹ä½ æ­£åœ¨ç¼–å†™çš„ç¨‹åºæœ€æœ‰æ„ä¹‰ã€‚</p>
<p>ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•å®ç°ä¸€äº›åœ¨Rustä¸­ä½¿ç”¨çš„ä¸»è¦traitã€‚</p>
<h3 id="from-trait"><a class="header" href="#from-trait">From trait</a></h3>
<p><em>From</em>æ˜¯ä¸€ä¸ªéå¸¸æ–¹ä¾¿çš„traitï¼Œä½ çŸ¥é“è¿™ä¸€ç‚¹ï¼Œå› ä¸ºä½ å·²ç»çœ‹åˆ°äº†å¾ˆå¤šã€‚ä½¿ç”¨<em>From</em>ï¼Œä½ å¯ä»¥ä»ä¸€ä¸ª<code>&amp;str</code>åˆ›å»ºä¸€ä¸ª<code>String</code>ï¼Œä½ ä¹Ÿå¯ä»¥ç”¨è®¸å¤šå…¶ä»–ç±»å‹åˆ›å»ºå¤šç§ç±»å‹ã€‚ä¾‹å¦‚ï¼ŒVecä½¿ç”¨<em>From</em>æ¥åˆ›å»ºä»¥ä¸‹ç±»å‹:</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>è¿™é‡Œæœ‰å¾ˆå¤š<code>Vec::from()</code>æˆ‘ä»¬è¿˜æ²¡æœ‰ç”¨è¿‡ã€‚æˆ‘ä»¬æ¥åšå‡ ä¸ªï¼Œçœ‹çœ‹ä¼šæ€ä¹ˆæ ·:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // We will make a generic function to print them so we want Display

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // Take any Vec&lt;T&gt; if type T has Display
    for item in input {
        print!("{} ", item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // Try from an array
    print_vec(&amp;array_vec);

    let str_vec = Vec::from("What kind of vec will I be?"); // An array from a &amp;str? This will be interesting
    print_vec(&amp;str_vec);

    let string_vec = Vec::from("What kind of vec will a String be?".to_string()); // Also from a String
    print_vec(&amp;string_vec);
}</code></pre></pre>
<p>å®ƒæ‰“å°çš„å†…å®¹å¦‚ä¸‹ã€‚</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>å¦‚æœä»ç±»å‹ä¸Šçœ‹ï¼Œç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªå‘é‡æ˜¯<code>Vec&lt;u8&gt;</code>ï¼Œä¹Ÿå°±æ˜¯<code>&amp;str</code>å’Œ<code>String</code>çš„å­—èŠ‚ã€‚æ‰€ä»¥ä½ å¯ä»¥çœ‹åˆ°<code>From</code>æ˜¯éå¸¸çµæ´»çš„ï¼Œç”¨çš„ä¹Ÿå¾ˆå¤šã€‚æˆ‘ä»¬ç”¨è‡ªå·±çš„ç±»å‹æ¥è¯•è¯•ã€‚</p>
<p>æˆ‘ä»¬å°†åˆ›å»ºä¸¤ä¸ªç»“æ„ä½“ï¼Œç„¶åä¸ºå…¶ä¸­ä¸€ä¸ªç»“æ„ä½“å®ç°<code>From</code>ã€‚ä¸€ä¸ªç»“æ„ä½“å°†æ˜¯<code>City</code>ï¼Œå¦ä¸€ä¸ªç»“æ„ä½“å°†æ˜¯<code>Country</code>ã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿåšåˆ°è¿™ä¸€ç‚¹ã€‚<code>let country_name = Country::from(vector_of_cities)</code>.</p>
<p>å®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // So we can print City
struct City {
    name: String,
    population: u32,
}

impl City {
    fn new(name: &amp;str, population: u32) -&gt; Self { // just a new function
        Self {
            name: name.to_string(),
            population,
        }
    }
}
#[derive(Debug)] // Country also needs to be printed
struct Country {
    cities: Vec&lt;City&gt;, // Our cities go in here
}

impl From&lt;Vec&lt;City&gt;&gt; for Country { // Note: we don't have to write From&lt;City&gt;, we can also do
                                   // From&lt;Vec&lt;City&gt;&gt;. So we can also implement on a type that
                                   // we didn't create
    fn from(cities: Vec&lt;City&gt;) -&gt; Self {
        Self { cities }
    }
}

impl Country {
    fn print_cities(&amp;self) { // function to print the cities in Country
        for city in &amp;self.cities {
            // &amp; because Vec&lt;City&gt; isn't Copy
            println!("{:?} has a population of {:?}.", city.name, city.population);
        }
    }
}

fn main() {
    let helsinki = City::new("Helsinki", 631_695);
    let turku = City::new("Turku", 186_756);

    let finland_cities = vec![helsinki, turku]; // This is the Vec&lt;City&gt;
    let finland = Country::from(finland_cities); // So now we can use From

    finland.print_cities();
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">"Helsinki" has a population of 631695.
"Turku" has a population of 186756.
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œ<code>From</code>å¾ˆå®¹æ˜“ä»ä½ æ²¡æœ‰åˆ›å»ºçš„ç±»å‹ä¸­å®ç°ï¼Œæ¯”å¦‚<code>Vec</code>ã€<code>i32</code>ç­‰ç­‰ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæœ‰ä¸¤ä¸ªå‘é‡çš„å‘é‡ã€‚ç¬¬ä¸€ä¸ªå‘é‡å­˜æ”¾å¶æ•°ï¼Œç¬¬äºŒä¸ªå‘é‡å­˜æ”¾å¥‡æ•°ã€‚å¯¹äº<code>From</code>ï¼Œä½ å¯ä»¥ç»™å®ƒä¸€ä¸ª<code>i32</code>çš„å‘é‡ï¼Œå®ƒä¼šæŠŠå®ƒå˜æˆ<code>Vec&lt;Vec&lt;i32&gt;&gt;</code>:ä¸€ä¸ªå®¹çº³<code>i32</code>çš„å‘é‡ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct EvenOddVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for EvenOddVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut even_odd_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // A vec with two empty vecs inside
                                                                    // This is the return value but first we must fill it
        for item in input {
            if item % 2 == 0 {
                even_odd_vec[0].push(item);
            } else {
                even_odd_vec[1].push(item);
            }
        }
        Self(even_odd_vec) // Now it is done so we return it as Self (Self = EvenOddVec)
    }
}

fn main() {
    let bunch_of_numbers = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = EvenOddVec::from(bunch_of_numbers);

    println!("Even numbers: {:?}\nOdd numbers: {:?}", new_vec.0[0], new_vec.0[1]);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Even numbers: [8, 222, 0, 8]
Odd numbers: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>åƒ <code>EvenOddVec</code> è¿™æ ·çš„ç±»å‹å¯èƒ½æœ€å¥½æ˜¯é€šç”¨ <code>T</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨è®¸å¤šæ•°å­—ç±»å‹ã€‚å¦‚æœä½ æƒ³ç»ƒä¹ çš„è¯ï¼Œä½ å¯ä»¥è¯•ç€æŠŠè¿™ä¸ªä¾‹å­åšæˆé€šç”¨çš„ã€‚</p>
<h3 id="åœ¨å‡½æ•°ä¸­ä½¿ç”¨å­—ç¬¦ä¸²å’Œstr"><a class="header" href="#åœ¨å‡½æ•°ä¸­ä½¿ç”¨å­—ç¬¦ä¸²å’Œstr">åœ¨å‡½æ•°ä¸­ä½¿ç”¨å­—ç¬¦ä¸²å’Œ&amp;str</a></h3>
<p>æœ‰æ—¶ä½ æƒ³è®©ä¸€ä¸ªå‡½æ•°å¯ä»¥åŒæ—¶æ¥å— <code>String</code> å’Œ <code>&amp;str</code>ã€‚ä½ å¯ä»¥é€šè¿‡æ³›å‹å’Œ <code>AsRef</code> ç‰¹æ€§æ¥å®ç°è¿™ä¸€ç‚¹ã€‚<code>AsRef</code> ç”¨äºä»ä¸€ä¸ªç±»å‹å‘å¦ä¸€ä¸ªç±»å‹æä¾›å¼•ç”¨ã€‚å¦‚æœä½ çœ‹çœ‹ <code>String</code> çš„æ–‡æ¡£ï¼Œä½ å¯ä»¥çœ‹åˆ°å®ƒå¯¹è®¸å¤šç±»å‹éƒ½æœ‰ <code>AsRef</code>ã€‚</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>ä¸‹é¢æ˜¯å®ƒä»¬çš„ä¸€äº›å‡½æ•°ç­¾åã€‚</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}</span></code></pre></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œå®ƒéœ€è¦<code>&amp;self</code>ï¼Œå¹¶ç»™å‡ºå¦ä¸€ä¸ªç±»å‹çš„å¼•ç”¨ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªé€šç”¨ç±»å‹Tï¼Œä½ å¯ä»¥è¯´å®ƒéœ€è¦<code>AsRef&lt;str&gt;</code>ã€‚å¦‚æœä½ è¿™æ ·åšï¼Œå®ƒå°†èƒ½å¤Ÿä½¿ç”¨ä¸€ä¸ª<code>&amp;str</code>å’Œä¸€ä¸ª<code>String</code>ã€‚</p>
<p>æˆ‘ä»¬å…ˆè¯´è¯´æ³›å‹å‡½æ•°ã€‚è¿™ä¸ªè¿˜ä¸èƒ½ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn print_it&lt;T&gt;(input: T) {
    println!("{}", input) // âš ï¸
}

fn main() {
    print_it("Please print me");
}</code></pre></pre>
<p>Rustè¯´<code>error[E0277]: T doesn't implement std::fmt::Display</code>ã€‚æ‰€ä»¥æˆ‘ä»¬ä¼šè¦æ±‚Tå®ç°Displayã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: Display&gt;(input: T) {
    println!("{}", input)
}

fn main() {
    print_it("Please print me");
}</code></pre></pre>
<p>ç°åœ¨å¯ä»¥ç”¨äº†ï¼Œæ‰“å°å‡º<code>Please print me</code>ã€‚è¿™æ˜¯å¥½çš„ï¼Œä½†Tä»ç„¶å¯ä»¥æ˜¯å¤šç§ç±»å‹ã€‚
å¯ä»¥æ˜¯<code>i8</code>ï¼Œä¹Ÿå¯ä»¥æ˜¯<code>f32</code>ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•å®ç°äº†<code>Display</code>çš„ç±»å‹ã€‚æˆ‘ä»¬åŠ ä¸Š<code>AsRef&lt;str&gt;</code>ï¼Œç°åœ¨Téœ€è¦<code>AsRef&lt;str&gt;</code>å’Œ<code>Display</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!("{}", input)
}

fn main() {
    print_it("Please print me");
    print_it("Also, please print me".to_string());
    // print_it(7); &lt;- This will not print
}</code></pre></pre>
<p>ç°åœ¨ï¼Œå®ƒä¸ä¼šæ¥å—<code>i8</code>è¿™æ ·çš„ç±»å‹ã€‚</p>
<p>ä¸è¦å¿˜äº†ï¼Œå½“å‡½æ•°å˜é•¿æ—¶ï¼Œä½ å¯ä»¥ç”¨<code>where</code>æ¥å†™ä¸åŒçš„å‡½æ•°ã€‚å¦‚æœæˆ‘ä»¬åŠ ä¸ŠDebugï¼Œé‚£ä¹ˆå°±ä¼šå˜æˆ<code>fn print_it&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code>ï¼Œè¿™ä¸€è¡Œå°±å¾ˆé•¿äº†ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // add Debug

fn print_it&lt;T&gt;(input: T) // Now this line is easy to read
where
    T: AsRef&lt;str&gt; + Debug + Display, // and these traits are easy to read
{
    println!("{}", input)
}

fn main() {
    print_it("Please print me");
    print_it("Also, please print me".to_string());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é“¾å¼æ–¹æ³•"><a class="header" href="#é“¾å¼æ–¹æ³•">é“¾å¼æ–¹æ³•</a></h2>
<p>Rustæ˜¯ä¸€ç§ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œå°±åƒCå’ŒC++ä¸€æ ·ï¼Œå®ƒçš„ä»£ç å¯ä»¥å†™æˆç‹¬ç«‹çš„å‘½ä»¤ï¼Œå•ç‹¬æˆè¡Œï¼Œä½†å®ƒä¹Ÿæœ‰å‡½æ•°å¼é£æ ¼ã€‚ä¸¤ç§é£æ ¼éƒ½å¯ä»¥ï¼Œä½†å‡½æ•°å¼é€šå¸¸æ¯”è¾ƒçŸ­ã€‚ä¸‹é¢ä»¥éå‡½æ•°å¼(ç§°ä¸º "å‘½ä»¤å¼")ä¸ºä¾‹ï¼Œè®©<code>Vec</code>ä»1åˆ°10ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut new_vec = Vec::new();
    let mut counter = 1;

    while counter &lt; 11 {
        new_vec.push(counter);
        counter += 1;
    }

    println!("{:?}", new_vec);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>ã€‚</p>
<p>è€Œè¿™é‡Œæ˜¯å‡½æ•°å¼é£æ ¼çš„ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = (1..=10).collect::&lt;Vec&lt;i32&gt;&gt;();
    // Or you can write it like this:
    // let new_vec: Vec&lt;i32&gt; = (1..=10).collect();
    println!("{:?}", new_vec);
}</code></pre></pre>
<p><code>.collect()</code>å¯ä»¥ä¸ºå¾ˆå¤šç±»å‹åšé›†åˆï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å‘Šè¯‰å®ƒç±»å‹ã€‚</p>
<p>ç”¨å‡½æ•°å¼å¯ä»¥é“¾æ¥æ–¹æ³•ã€‚"é“¾æ¥æ–¹æ³•"çš„æ„æ€æ˜¯æŠŠå¾ˆå¤šæ–¹æ³•æ”¾åœ¨ä¸€ä¸ªè¯­å¥ä¸­ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå¾ˆå¤šæ–¹æ³•é“¾åœ¨ä¸€èµ·çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let new_vec = my_vec.into_iter().skip(3).take(4).collect::&lt;Vec&lt;i32&gt;&gt;();

    println!("{:?}", new_vec);
}</code></pre></pre>
<p>è¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ª<code>[3, 4, 5, 6]</code>çš„Vecã€‚è¿™ä¸€è¡Œçš„ä¿¡æ¯é‡å¾ˆå¤§ï¼Œæ‰€ä»¥æŠŠæ¯ä¸ªæ–¹æ³•æ”¾åœ¨æ–°çš„ä¸€è¡Œä¸Šä¼šæœ‰å¸®åŠ©ã€‚è®©æˆ‘ä»¬è¿™æ ·åšï¼Œä»¥ä½¿å…¶æ›´å®¹æ˜“é˜…è¯»ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let new_vec = my_vec
        .into_iter() // "iterate" over the items (iterate = work with each item inside it). into_iter() gives us owned values, not references
        .skip(3) // skip over three items: 0, 1, and 2
        .take(4) // take the next four: 3, 4, 5, and 6
        .collect::&lt;Vec&lt;i32&gt;&gt;(); // put them in a new Vec&lt;i32&gt;

    println!("{:?}", new_vec);
}</code></pre></pre>
<p>å½“ä½ äº†è§£é—­åŒ…å’Œè¿­ä»£å™¨æ—¶ï¼Œä½ å¯ä»¥æœ€å¥½åœ°ä½¿ç”¨è¿™ç§å‡½æ•°å¼ã€‚æ‰€ä»¥æˆ‘ä»¬æ¥ä¸‹æ¥å°†å­¦ä¹ å®ƒä»¬ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="è¿­ä»£å™¨"><a class="header" href="#è¿­ä»£å™¨">è¿­ä»£å™¨</a></h2>
<p>è¿­ä»£å™¨æ˜¯ä¸€ä¸ªæ„é€ ï¼Œå®ƒå¯ä»¥ç»™ä½ é›†åˆä¸­çš„å…ƒç´ ï¼Œä¸€æ¬¡ä¸€ä¸ªã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨äº†å¾ˆå¤šè¿­ä»£å™¨:<code>for</code>å¾ªç¯ç»™ä½ ä¸€ä¸ªè¿­ä»£å™¨ã€‚å½“ä½ æƒ³åœ¨å…¶ä»–æ—¶å€™ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œä½ å¿…é¡»é€‰æ‹©ä»€ä¹ˆæ ·çš„è¿­ä»£å™¨:</p>
<ul>
<li><code>.iter()</code> å¼•ç”¨çš„è¿­ä»£å™¨</li>
<li><code>.iter_mut()</code> å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨</li>
<li><code>.into_iter()</code> å€¼çš„è¿­ä»£å™¨(ä¸æ˜¯å¼•ç”¨)</li>
</ul>
<p><code>for</code>å¾ªç¯å…¶å®åªæ˜¯ä¸€ä¸ªæ‹¥æœ‰å€¼çš„è¿­ä»£å™¨ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå¯ä»¥è®©å®ƒå˜å¾—å¯å˜ï¼Œç„¶åä½ å¯ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™æ”¹å˜å€¼ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨è¿­ä»£å™¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vector1 = vec![1, 2, 3]; // we will use .iter() and .into_iter() on this one
    let vector1_a = vector1.iter().map(|x| x + 1).collect::&lt;Vec&lt;i32&gt;&gt;();
    let vector1_b = vector1.into_iter().map(|x| x * 10).collect::&lt;Vec&lt;i32&gt;&gt;();

    let mut vector2 = vec![10, 20, 30]; // we will use .iter_mut() on this one
    vector2.iter_mut().for_each(|x| *x +=100);

    println!("{:?}", vector1_a);
    println!("{:?}", vector2);
    println!("{:?}", vector1_b);
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">[2, 3, 4]
[110, 120, 130]
[10, 20, 30]
</code></pre>
<p>å‰ä¸¤ä¸ªæˆ‘ä»¬ç”¨äº†ä¸€ä¸ªå«<code>.map()</code>çš„æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥è®©ä½ å¯¹æ¯ä¸€ä¸ªå…ƒç´ åšä¸€äº›äº‹æƒ…ï¼Œç„¶åæŠŠå®ƒä¼ é€’ä¸‹å»ã€‚æœ€åæˆ‘ä»¬ç”¨çš„æ˜¯ä¸€ä¸ªå«<code>.for_each()</code>çš„æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•åªæ˜¯è®©ä½ å¯¹æ¯ä¸€ä¸ªå…ƒç´ åšä¸€äº›äº‹æƒ…ã€‚<code>.iter_mut()</code>åŠ ä¸Š<code>for_each()</code>åŸºæœ¬ä¸Šå°±æ˜¯ä¸€ä¸ª<code>for</code>çš„å¾ªç¯ã€‚åœ¨æ¯ä¸€ä¸ªæ–¹æ³•é‡Œé¢ï¼Œæˆ‘ä»¬å¯ä»¥ç»™æ¯ä¸€ä¸ªå…ƒç´ èµ·ä¸€ä¸ªåå­—(æˆ‘ä»¬åˆšæ‰å«å®ƒ <code>x</code>)ï¼Œç„¶åç”¨å®ƒæ¥æ”¹å˜å®ƒã€‚è¿™äº›è¢«ç§°ä¸ºé—­åŒ…ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚å­¦ä¹ å®ƒä»¬ã€‚</p>
<p>è®©æˆ‘ä»¬å†æ¥çœ‹çœ‹å®ƒä»¬ï¼Œä¸€æ¬¡ä¸€ä¸ªã€‚</p>
<p>é¦–å…ˆæˆ‘ä»¬ç”¨<code>.iter()</code>å¯¹<code>vector1</code>è¿›è¡Œå¼•ç”¨ã€‚æˆ‘ä»¬ç»™æ¯ä¸ªå…ƒç´ éƒ½åŠ äº†1ï¼Œå¹¶ä½¿å…¶æˆä¸ºä¸€ä¸ªæ–°çš„Vecã€‚<code>vector1</code>è¿˜æ´»ç€ï¼Œå› ä¸ºæˆ‘ä»¬åªç”¨äº†å¼•ç”¨:æˆ‘ä»¬æ²¡æœ‰æŒ‰å€¼å–ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ <code>vector1</code>ï¼Œè¿˜æœ‰ä¸€ä¸ªæ–°çš„ Vec å« <code>vector1_a</code>ã€‚å› ä¸º<code>.map()</code>åªæ˜¯ä¼ é€’äº†å®ƒï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨<code>.collect()</code>æŠŠå®ƒå˜æˆä¸€ä¸ª<code>Vec</code>ã€‚</p>
<p>ç„¶åæˆ‘ä»¬ç”¨<code>into_iter</code>ä»<code>vector1</code>ä¸­æŒ‰å€¼å¾—åˆ°ä¸€ä¸ªè¿­ä»£å™¨ã€‚è¿™æ ·å°±ç ´åäº†<code>vector1</code>ï¼Œå› ä¸ºè¿™å°±æ˜¯<code>into_iter()</code>çš„ä½œç”¨ã€‚æ‰€ä»¥æˆ‘ä»¬åšäº†<code>vector1_b</code>ä¹‹åï¼Œå°±ä¸èƒ½å†ä½¿ç”¨<code>vector1</code>äº†ã€‚</p>
<p>æœ€åæˆ‘ä»¬åœ¨<code>vector2</code>ä¸Šä½¿ç”¨<code>.iter_mut()</code>ã€‚å®ƒæ˜¯å¯å˜çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨<code>.collect()</code>æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„Vecã€‚ç›¸åï¼Œæˆ‘ä»¬ç”¨å¯å˜å¼•ç”¨æ”¹å˜åŒä¸€Vecä¸­çš„å€¼ã€‚æ‰€ä»¥<code>vector2</code>ä»ç„¶å­˜åœ¨ã€‚å› ä¸ºæˆ‘ä»¬ä¸éœ€è¦ä¸€ä¸ªæ–°çš„Vecï¼Œæˆ‘ä»¬ä½¿ç”¨<code>for_each</code>:å®ƒå°±åƒä¸€ä¸ª<code>for</code>å¾ªç¯ã€‚</p>
<h3 id="è¿­ä»£å™¨å¦‚ä½•å·¥ä½œ"><a class="header" href="#è¿­ä»£å™¨å¦‚ä½•å·¥ä½œ">è¿­ä»£å™¨å¦‚ä½•å·¥ä½œ</a></h3>
<p>è¿­ä»£å™¨çš„å·¥ä½œåŸç†æ˜¯ä½¿ç”¨ä¸€ä¸ªå«åš <code>.next()</code> çš„æ–¹æ³•ï¼Œå®ƒç»™å‡ºä¸€ä¸ª <code>Option</code>ã€‚å½“ä½ ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼ŒRustä¼šä¸€éåˆä¸€éåœ°è°ƒç”¨<code>next()</code>ã€‚å¦‚æœå¾—åˆ° <code>Some</code>ï¼Œå®ƒå°±ä¼šç»§ç»­å‰è¿›ã€‚å¦‚æœå¾—åˆ° <code>None</code>ï¼Œå®ƒå°±åœæ­¢ã€‚</p>
<p>ä½ è¿˜è®°å¾— <code>assert_eq!</code> å®å—ï¼Ÿåœ¨æ–‡æ¡£ä¸­ï¼Œä½ ç»å¸¸çœ‹åˆ°å®ƒã€‚è¿™é‡Œå®ƒå±•ç¤ºäº†è¿­ä»£å™¨çš„å·¥ä½œåŸç†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec!['a', 'b', 'ê±°', 'æŸ³']; // Just a regular Vec

    let mut my_vec_iter = my_vec.iter(); // This is an Iterator type now, but we haven't called it yet

    assert_eq!(my_vec_iter.next(), Some(&amp;'a'));  // Call the first item with .next()
    assert_eq!(my_vec_iter.next(), Some(&amp;'b'));  // Call the next
    assert_eq!(my_vec_iter.next(), Some(&amp;'ê±°')); // Again
    assert_eq!(my_vec_iter.next(), Some(&amp;'æŸ³')); // Again
    assert_eq!(my_vec_iter.next(), None);        // Nothing is left: just None
    assert_eq!(my_vec_iter.next(), None);        // You can keep calling .next() but it will always be None
}</code></pre></pre>
<p>ä¸ºè‡ªå·±çš„structæˆ–enumå®ç°<code>Iterator</code>å¹¶ä¸éš¾ã€‚é¦–å…ˆæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¹¦åº“ï¼Œæƒ³ä¸€æƒ³ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // we want to print it with {:?}
struct Library {
    library_type: LibraryType, // this is our enum
    books: Vec&lt;String&gt;, // list of books
}

#[derive(Debug)]
enum LibraryType { // libraries can be city libraries or country libraries
    City,
    Country,
}

impl Library {
    fn add_book(&amp;mut self, book: &amp;str) { // we use add_book to add new books
        self.books.push(book.to_string()); // we take a &amp;str and turn it into a String, then add it to the Vec
    }

    fn new() -&gt; Self { // this creates a new Library
        Self {
            library_type: LibraryType::City, // most are in the city so we'll choose City
                                             // most of the time
            books: Vec::new(),
        }
    }
}

fn main() {
    let mut my_library = Library::new(); // make a new library
    my_library.add_book("The Doom of the Darksword"); // add some books
    my_library.add_book("Demian - die Geschichte einer Jugend");
    my_library.add_book("êµ¬ìš´ëª½");
    my_library.add_book("å¾è¼©ã¯çŒ«ã§ã‚ã‚‹");

    println!("{:?}", my_library.books); // we can print our list of books
}</code></pre></pre>
<p>è¿™å¾ˆå¥½ç”¨ã€‚ç°åœ¨æˆ‘ä»¬æƒ³ä¸ºåº“å®ç°<code>Iterator</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨<code>for</code>å¾ªç¯ä¸­ä½¿ç”¨å®ƒã€‚ç°åœ¨å¦‚æœæˆ‘ä»¬å°è¯• <code>for</code> å¾ªç¯ï¼Œå®ƒå°±æ— æ³•å·¥ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in my_library {
    println!("{}", item); // âš ï¸
}
<span class="boring">}</span></code></pre></pre>
<p>å®ƒè¯´:</p>
<pre><code class="language-text">error[E0277]: `Library` is not an iterator
  --&gt; src\main.rs:47:16
   |
47 |    for item in my_library {
   |                ^^^^^^^^^^ `Library` is not an iterator
   |
   = help: the trait `std::iter::Iterator` is not implemented for `Library`
   = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç”¨<code>impl Iterator for Library</code>æŠŠåº“åšæˆè¿­ä»£å™¨ã€‚<code>Iterator</code>traitçš„ä¿¡æ¯åœ¨æ ‡å‡†åº“ä¸­ã€‚<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a></p>
<p>åœ¨é¡µé¢çš„å·¦ä¸Šæ–¹å†™ç€:<code>Associated Types: Item</code>å’Œ<code>Required Methods: next</code>ã€‚"å…³è”ç±»å‹"çš„æ„æ€æ˜¯ "ä¸€èµ·ä½¿ç”¨çš„ç±»å‹"ã€‚æˆ‘ä»¬çš„å…³è”ç±»å‹å°†æ˜¯<code>String</code>ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›è¿­ä»£å™¨ç»™æˆ‘ä»¬æä¾›Stringã€‚</p>
<p>åœ¨é¡µé¢ä¸­ï¼Œå®ƒæœ‰ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// an iterator which alternates between Some and None
struct Alternate {
    state: i32,
}

impl Iterator for Alternate {
    type Item = i32;

    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let val = self.state;
        self.state = self.state + 1;

        // if it's even, Some(i32), else None
        if val % 2 == 0 {
            Some(val)
        } else {
            None
        }
    }
}

fn main() {}</code></pre></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°<code>impl Iterator for Alternate</code>ä¸‹é¢å†™ç€<code>type Item = i32</code>ã€‚è¿™å°±æ˜¯å…³è”ç±»å‹ã€‚æˆ‘ä»¬çš„è¿­ä»£å™¨å°†é’ˆå¯¹æˆ‘ä»¬çš„ä¹¦ç±åˆ—è¡¨ï¼Œè¿™æ˜¯ä¸€ä¸ª<code>Vec&lt;String&gt;</code>ã€‚å½“æˆ‘ä»¬è°ƒç”¨nextçš„æ—¶å€™ã€‚
å®ƒå°†ç»™æˆ‘ä»¬ä¸€ä¸ª<code>String</code>ã€‚æ‰€ä»¥æˆ‘ä»¬å°±å†™<code>type Item = String;</code>ã€‚è¿™å°±æ˜¯å…³è”é¡¹ã€‚</p>
<p>ä¸ºäº†å®ç° <code>Iterator</code>ï¼Œä½ éœ€è¦å†™ <code>fn next()</code> å‡½æ•°ã€‚è¿™æ˜¯ä½ å†³å®šè¿­ä»£å™¨åº”è¯¥åšä»€ä¹ˆçš„åœ°æ–¹ã€‚å¯¹äºæˆ‘ä»¬çš„ <code>Library</code>ï¼Œæˆ‘ä»¬é¦–å…ˆå¸Œæœ›å®ƒç»™æˆ‘ä»¬æœ€åä¸€æœ¬ä¹¦ã€‚æ‰€ä»¥æˆ‘ä»¬å°†<code>match</code>ä¸<code>.pop()</code>ä¸€èµ·ï¼Œå¦‚æœæ˜¯<code>Some</code>çš„è¯ï¼Œå°±æŠŠæœ€åä¸€é¡¹å»æ‰ã€‚æˆ‘ä»¬è¿˜æƒ³ä¸ºæ¯ä¸ªå…ƒç´ æ‰“å° "is found!"ã€‚ç°åœ¨å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Clone)]
struct Library {
    library_type: LibraryType,
    books: Vec&lt;String&gt;,
}

#[derive(Debug, Clone)]
enum LibraryType {
    City,
    Country,
}

impl Library {
    fn add_book(&amp;mut self, book: &amp;str) {
        self.books.push(book.to_string());
    }

    fn new() -&gt; Self {
        Self {
            library_type: LibraryType::City,
            // most of the time
            books: Vec::new(),
        }
    }
}

impl Iterator for Library {
    type Item = String;

    fn next(&amp;mut self) -&gt; Option&lt;String&gt; {
        match self.books.pop() {
            Some(book) =&gt; Some(book + " is found!"), // Rust allows String + &amp;str
            None =&gt; None,
        }
    }
}

fn main() {
    let mut my_library = Library::new();
    my_library.add_book("The Doom of the Darksword");
    my_library.add_book("Demian - die Geschichte einer Jugend");
    my_library.add_book("êµ¬ìš´ëª½");
    my_library.add_book("å¾è¼©ã¯çŒ«ã§ã‚ã‚‹");

    for item in my_library.clone() { // we can use a for loop now. Give it a clone so Library won't be destroyed
        println!("{}", item);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">å¾è¼©ã¯çŒ«ã§ã‚ã‚‹ is found!
êµ¬ìš´ëª½ is found!
Demian - die Geschichte einer Jugend is found!
The Doom of the Darksword is found!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é—­åŒ…"><a class="header" href="#é—­åŒ…">é—­åŒ…</a></h2>
<p>é—­åŒ…å°±åƒå¿«é€Ÿå‡½æ•°ï¼Œä¸éœ€è¦åå­—ã€‚æœ‰æ—¶å®ƒä»¬è¢«ç§°ä¸ºlambdaã€‚Closureså¾ˆå®¹æ˜“è¾¨è¯†ï¼Œå› ä¸ºå®ƒä»¬ä½¿ç”¨<code>||</code>è€Œä¸æ˜¯<code>()</code>ã€‚å®ƒä»¬åœ¨ Rust ä¸­éå¸¸å¸¸è§ï¼Œä¸€æ—¦ä½ å­¦ä¼šäº†ä½¿ç”¨å®ƒä»¬ï¼Œä½ å°±ä¼šçˆ±ä¸é‡Šæ‰‹ã€‚</p>
<p>ä½ å¯ä»¥å°†ä¸€ä¸ªé—­åŒ…ç»‘å®šåˆ°ä¸€ä¸ªå˜é‡ä¸Šï¼Œç„¶åå½“ä½ ä½¿ç”¨å®ƒæ—¶ï¼Œå®ƒçœ‹èµ·æ¥å°±åƒä¸€ä¸ªå‡½æ•°ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || println!("This is a closure");
    my_closure();
}</code></pre></pre>
<p>æ‰€ä»¥è¿™ä¸ªé—­åŒ…ä»€ä¹ˆéƒ½ä¸éœ€è¦:<code>||</code>ï¼Œå¹¶æ‰“å°ä¸€æ¡ä¿¡æ¯ã€‚<code>This is a closure</code>.</p>
<p>åœ¨<code>||</code>ä¹‹é—´æˆ‘ä»¬å¯ä»¥æ·»åŠ è¾“å…¥å˜é‡å’Œç±»å‹ï¼Œå°±åƒåœ¨<code>()</code>é‡Œé¢æ·»åŠ å‡½æ•°ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = |x: i32| println!("{}", x);

    my_closure(5);
    my_closure(5+5);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">5
10
</code></pre>
<p>å½“é—­åŒ…å˜å¾—æ›´å¤æ‚æ—¶ï¼Œä½ å¯ä»¥æ·»åŠ ä¸€ä¸ªä»£ç å—ã€‚é‚£å°±å¯ä»¥éšå¿ƒæ‰€æ¬²çš„é•¿ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || {
        let number = 7;
        let other_number = 10;
        println!("The two numbers are {} and {}.", number, other_number);
          // This closure can be as long as we want, just like a function.
    };

    my_closure();
}</code></pre></pre>
<p>ä½†æ˜¯é—­åŒ…æ˜¯ç‰¹æ®Šçš„ï¼Œå› ä¸ºå®ƒå¯ä»¥æ¥å—é—­åŒ…ä¹‹å¤–çš„å˜é‡ï¼Œå³ä½¿ä½ åªå†™<code>||</code>ã€‚æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = || println!("{}", number_one + number_two);
    my_closure();
}</code></pre></pre>
<p>æ‰€ä»¥è¿™å°±æ‰“å°å‡ºäº†<code>16</code>ã€‚ä½ ä¸éœ€è¦åœ¨ <code>||</code> ä¸­æ”¾å…¥ä»»ä½•ä¸œè¥¿ï¼Œå› ä¸ºå®ƒå¯ä»¥ç›´æ¥å– <code>number_one</code> å’Œ <code>number_two</code> å¹¶æ·»åŠ å®ƒä»¬ã€‚</p>
<p>é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œè¿™å°±æ˜¯<strong>closure</strong>è¿™ä¸ªåå­—çš„ç”±æ¥ï¼Œå› ä¸ºå®ƒä»¬ä¼šå–å˜é‡å¹¶å°†å®ƒä»¬ "åŒ…å›´"åœ¨é‡Œé¢ã€‚å¦‚æœä½ æƒ³å¾ˆæ­£ç¡®çš„è¯´ã€‚</p>
<ul>
<li>ä¸€ä¸ª<code>||</code>å¦‚æœä¸æŠŠå˜é‡ä»å¤–é¢åŒ…å›´èµ·æ¥ é‚£å°±æ˜¯ä¸€ä¸ª "åŒ¿åå‡½æ•°". åŒ¿åçš„æ„æ€æ˜¯ "æ²¡æœ‰åå­—"ã€‚å®ƒçš„å·¥ä½œåŸç†æ›´åƒä¸€ä¸ªæ™®é€šå‡½æ•°ã€‚</li>
<li><code>||</code> ä»å¤–éƒ¨åŒ…å›´å˜é‡çš„å‡½æ•°æ˜¯ "closure"ã€‚å®ƒæŠŠå‘¨å›´çš„å˜é‡ "å°é—­"èµ·æ¥ä½¿ç”¨ã€‚</li>
</ul>
<p>ä½†æ˜¯äººä»¬ç»å¸¸ä¼šæŠŠæ‰€æœ‰çš„<code>||</code>å‡½æ•°éƒ½å«åšé—­åŒ…ï¼Œæ‰€ä»¥ä½ ä¸ç”¨æ‹…å¿ƒåå­—çš„é—®é¢˜ã€‚æˆ‘ä»¬åªå¯¹ä»»ä½•å¸¦æœ‰<code>||</code>çš„å‡½æ•°è¯´ "closure"ï¼Œä½†è¯·è®°ä½ï¼Œå®ƒå¯èƒ½æ„å‘³ç€ä¸€ä¸ª "åŒ¿åå‡½æ•°"ã€‚</p>
<p>ä¸ºä»€ä¹ˆè¦çŸ¥é“è¿™ä¸¤è€…çš„åŒºåˆ«å‘¢ï¼Ÿå› ä¸ºåŒ¿åå‡½æ•°å…¶å®å’Œæœ‰åå­—çš„å‡½æ•°åšçš„æœºå™¨ä»£ç æ˜¯ä¸€æ ·çš„ã€‚å®ƒä»¬ç»™äººçš„æ„Ÿè§‰æ˜¯ "é«˜å±‚æŠ½è±¡"ï¼Œæ‰€ä»¥æœ‰æ—¶å€™å¤§å®¶ä¼šè§‰å¾—æœºå™¨ä»£ç ä¼šå¾ˆå¤æ‚ã€‚ä½†æ˜¯Rustç”¨å®ƒç”Ÿæˆçš„æœºå™¨ç å’Œæ™®é€šå‡½æ•°ä¸€æ ·å¿«ã€‚</p>
<p>æ‰€ä»¥æˆ‘ä»¬å†æ¥çœ‹çœ‹é—­åŒ…èƒ½åšçš„ä¸€äº›äº‹æƒ…ã€‚ä½ ä¹Ÿå¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = |x: i32| println!("{}", number_one + number_two + x);
    my_closure(5);
}</code></pre></pre>
<p>è¿™ä¸ªé—­åŒ…å–<code>number_one</code>å’Œ<code>number_two</code>ã€‚æˆ‘ä»¬è¿˜ç»™äº†å®ƒä¸€ä¸ªæ–°çš„å˜é‡ <code>x</code>ï¼Œå¹¶è¯´ <code>x</code> æ˜¯ 5.ç„¶åå®ƒæŠŠè¿™ä¸‰ä¸ªåŠ åœ¨ä¸€èµ·æ‰“å° <code>21</code>ã€‚</p>
<p>é€šå¸¸åœ¨Rustä¸­ï¼Œä½ ä¼šåœ¨ä¸€ä¸ªæ–¹æ³•é‡Œé¢çœ‹åˆ°é—­åŒ…ï¼Œå› ä¸ºé‡Œé¢æœ‰ä¸€ä¸ªé—­åŒ…æ˜¯éå¸¸æ–¹ä¾¿çš„ã€‚æˆ‘ä»¬åœ¨ä¸Šä¸€èŠ‚çš„ <code>.map()</code> å’Œ <code>.for_each()</code> ä¸­çœ‹åˆ°äº†é—­åŒ…ã€‚åœ¨é‚£ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å†™äº† <code>|x|</code> æ¥å¼•å…¥è¿­ä»£å™¨ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªé—­åŒ…ã€‚</p>
<p>ä¸‹é¢å†ä¸¾ä¸€ä¸ªä¾‹å­:æˆ‘ä»¬çŸ¥é“ï¼Œå¦‚æœ<code>unwrap</code>ä¸èµ·ä½œç”¨ï¼Œå¯ä»¥ç”¨<code>unwrap_or</code>æ–¹æ³•ç»™å‡ºä¸€ä¸ªå€¼ã€‚ä¹‹å‰æˆ‘ä»¬å†™çš„æ˜¯:<code>let fourth = my_vec.get(3).unwrap_or(&amp;0);</code>ã€‚ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ª<code>unwrap_or_else</code>æ–¹æ³•ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªé—­åŒ…ã€‚æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or_else(|| { // try to unwrap. If it doesn't work,
        if my_vec.get(0).is_some() {               // see if my_vec has something at index [0]
            &amp;my_vec[0]                             // Give the number at index 0 if there is something
        } else {
            &amp;0 // otherwise give a &amp;0
        }
    });

    println!("{}", fourth);
}</code></pre></pre>
<p>å½“ç„¶ï¼Œé—­åŒ…ä¹Ÿå¯ä»¥å¾ˆç®€å•ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥åªå†™<code>let fourth = my_vec.get(3).unwrap_or_else(|| &amp;0);</code>ã€‚ä½ ä¸éœ€è¦æ€»æ˜¯å› ä¸ºæœ‰ä¸€ä¸ªé—­åŒ…å°±ä½¿ç”¨<code>{}</code>å¹¶å†™å‡ºå¤æ‚çš„ä»£ç ã€‚åªè¦ä½ æŠŠ<code>||</code>æ”¾è¿›å»ï¼Œç¼–è¯‘å™¨å°±çŸ¥é“ä½ æ”¾äº†ä½ éœ€è¦çš„é—­åŒ…ã€‚</p>
<p>æœ€å¸¸ç”¨çš„é—­åŒ…æ–¹æ³•å¯èƒ½æ˜¯<code>.map()</code>ã€‚æˆ‘ä»¬å†æ¥çœ‹çœ‹å®ƒã€‚ä¸‹é¢æ˜¯ä¸€ç§ä½¿ç”¨æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec        // take num_vec
        .iter()                     // iterate over it
        .map(|number| number * 2)   // for each item, multiply by two
        .collect::&lt;Vec&lt;i32&gt;&gt;();     // then make a new Vec from this
    println!("{:?}", double_vec);
}</code></pre></pre>
<p>å¦ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­æ˜¯åœ¨<code>.enumerate()</code>ä¹‹åä½¿ç”¨<code>.for_each()</code>ã€‚<code>.enumerate()</code>æ–¹æ³•ç»™å‡ºä¸€ä¸ªå¸¦æœ‰ç´¢å¼•å·å’Œå…ƒç´ çš„è¿­ä»£å™¨ã€‚ä¾‹å¦‚:<code>[10, 9, 8]</code>å˜æˆ<code>(0, 10), (1, 9), (2, 8)</code>ã€‚è¿™é‡Œæ¯ä¸ªé¡¹çš„ç±»å‹æ˜¯<code>(usize, i32)</code>ã€‚æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()      // iterate over num_vec
        .enumerate() // get (index, number)
        .for_each(|(index, number)| println!("Index number {} has number {}", index, number)); // do something for each one
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">Index number 0 has number 10
Index number 1 has number 9
Index number 2 has number 8
</code></pre>
<p>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç”¨<code>for_each</code>ä»£æ›¿<code>map</code>ã€‚<code>map</code>æ˜¯ç”¨äºå¯¹<strong>æ¯ä¸ªå…ƒç´ åšä¸€äº›äº‹æƒ…ï¼Œå¹¶å°†å…¶ä¼ é€’å‡ºå»ï¼Œè€Œ<code>for_each</code>æ˜¯å½“ä½ çœ‹åˆ°æ¯ä¸ªå…ƒç´ </strong>æ—¶åšä¸€äº›äº‹æƒ…ã€‚å¦å¤–ï¼Œ<code>map</code>ä¸åšä»»ä½•äº‹æƒ…ï¼Œé™¤éä½ ä½¿ç”¨<code>collect</code>è¿™æ ·çš„æ–¹æ³•ã€‚</p>
<p>å…¶å®ï¼Œè¿™å°±æ˜¯è¿­ä»£å™¨çš„æœ‰è¶£ä¹‹å¤„ã€‚å¦‚æœä½ å°è¯•<code>map</code>è€Œä¸ä½¿ç”¨<code>collect</code>è¿™æ ·çš„æ–¹æ³•ï¼Œç¼–è¯‘å™¨ä¼šå‘Šè¯‰ä½ ï¼Œå®ƒä»€ä¹ˆä¹Ÿä¸åšã€‚å®ƒä¸ä¼šå´©æºƒï¼Œä½†ç¼–è¯‘å™¨ä¼šå‘Šè¯‰ä½ ï¼Œä½ ä»€ä¹ˆéƒ½æ²¡åšã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()
        .enumerate()
        .map(|(index, number)| println!("Index number {} has number {}", index, number));

}</code></pre></pre>
<p>å®ƒè¯´:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` that must be used
 --&gt; src\main.rs:4:5
  |
4 | /     num_vec
5 | |         .iter()
6 | |         .enumerate()
7 | |         .map(|(index, number)| println!("Index number {} has number {}", index, number));
  | |_________________________________________________________________________________________^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
</code></pre>
<p>è¿™æ˜¯ä¸€ä¸ª<strong>è­¦å‘Š</strong>ï¼Œæ‰€ä»¥è¿™ä¸æ˜¯ä¸€ä¸ªé”™è¯¯:ç¨‹åºè¿è¡Œæ­£å¸¸ã€‚ä½†æ˜¯ä¸ºä»€ä¹ˆnum_vecæ²¡æœ‰ä»»ä½•ä½œç”¨å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥çœ‹çœ‹ç±»å‹å°±çŸ¥é“äº†ã€‚</p>
<ul>
<li>
<p><code>let num_vec = vec![10, 9, 8];</code> ç°åœ¨æ˜¯ä¸€ä¸ª<code>Vec&lt;i32&gt;</code>ã€‚</p>
</li>
<li>
<p><code>.iter()</code> ç°åœ¨æ˜¯ä¸€ä¸ª <code>Iter&lt;i32&gt;</code>ã€‚æ‰€ä»¥å®ƒæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå…¶å…ƒç´ ä¸º <code>i32</code>ã€‚</p>
</li>
<li>
<p><code>.enumerate()</code>ç°åœ¨æ˜¯ä¸€ä¸ª<code>Enumerate&lt;Iter&lt;i32&gt;&gt;</code>å‹ã€‚æ‰€ä»¥å®ƒæ˜¯<code>Enumerate</code>å‹çš„<code>Iter</code>å‹çš„<code>i32</code>ã€‚</p>
</li>
<li>
<p><code>.map()</code>ç°åœ¨æ˜¯ä¸€ä¸ª<code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>çš„ç±»å‹ã€‚æ‰€ä»¥å®ƒæ˜¯ä¸€ä¸ªç±»å‹<code>Map</code>çš„ç±»å‹<code>Enumerate</code>çš„ç±»å‹<code>Iter</code>çš„ç±»å‹<code>i32</code>ã€‚</p>
</li>
</ul>
<p>æˆ‘ä»¬æ‰€åšçš„åªæ˜¯åšäº†ä¸€ä¸ªè¶Šæ¥è¶Šå¤æ‚çš„ç»“æ„ã€‚æ‰€ä»¥è¿™ä¸ª<code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>æ˜¯ä¸€ä¸ªå‡†å¤‡å¥½äº†çš„ç»“æ„ï¼Œä½†åªæœ‰å½“æˆ‘ä»¬å‘Šè¯‰å®ƒè¦åšä»€ä¹ˆçš„æ—¶å€™ï¼Œå®ƒæ‰ä¼šå»åšã€‚Rustè¿™æ ·åšæ˜¯å› ä¸ºå®ƒéœ€è¦ä¿è¯è¶³å¤Ÿå¿«ã€‚å®ƒä¸æƒ³è¿™æ ·åš:</p>
<ul>
<li>éå†Vecä¸­æ‰€æœ‰çš„<code>i32</code></li>
<li>ç„¶åä»è¿­ä»£å™¨ä¸­æšä¸¾å‡ºæ‰€æœ‰çš„<code>i32</code></li>
<li>ç„¶åå°†æ‰€æœ‰åˆ—ä¸¾çš„<code>i32</code>æ˜ å°„è¿‡æ¥</li>
</ul>
<p>Rust åªæƒ³åšä¸€æ¬¡è®¡ç®—ï¼Œæ‰€ä»¥å®ƒåˆ›å»ºç»“æ„å¹¶ç­‰å¾…ã€‚ç„¶åï¼Œå¦‚æœæˆ‘ä»¬è¯´<code>.collect::&lt;Vec&lt;i32&gt;&gt;()</code>ï¼Œå®ƒçŸ¥é“è¯¥æ€ä¹ˆåšï¼Œå¹¶å¼€å§‹ç§»åŠ¨ã€‚è¿™å°±æ˜¯<code>iterators are lazy and do nothing unless consumed</code>çš„æ„æ€ã€‚è¿­ä»£å™¨åœ¨ä½  "æ¶ˆè€—"å®ƒä»¬(ç”¨å®Œå®ƒä»¬)ä¹‹å‰ä¸ä¼šåšä»»ä½•äº‹æƒ…ã€‚</p>
<p>ä½ ç”šè‡³å¯ä»¥ç”¨<code>.collect()</code>åˆ›å»ºåƒ<code>HashMap</code>è¿™æ ·å¤æ‚çš„ä¸œè¥¿ï¼Œæ‰€ä»¥å®ƒéå¸¸å¼ºå¤§ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå¦‚ä½•å°†ä¸¤ä¸ªå‘é‡æ”¾å…¥<code>HashMap</code>çš„ä¾‹å­ã€‚é¦–å…ˆæˆ‘ä»¬æŠŠä¸¤ä¸ªå‘é‡åˆ›å»ºå‡ºæ¥ï¼Œç„¶åæˆ‘ä»¬ä¼šå¯¹å®ƒä»¬ä½¿ç”¨<code>.into_iter()</code>æ¥å¾—åˆ°ä¸€ä¸ªå€¼çš„è¿­ä»£å™¨ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨<code>.zip()</code>æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•å°†ä¸¤ä¸ªè¿­ä»£å™¨è¿æ¥åœ¨ä¸€èµ·ï¼Œå°±åƒæ‹‰é“¾ä¸€æ ·ã€‚æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨<code>.collect()</code>æ¥åˆ›å»º<code>HashMap</code>ã€‚</p>
<p>ä¸‹é¢æ˜¯ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // a Vec&lt;i32&gt;
    let some_words = vec!["zero", "one", "two", "three", "four", "five"]; // a Vec&lt;&amp;str&gt;

    let number_word_hashmap = some_numbers
        .into_iter()                 // now it is an iter
        .zip(some_words.into_iter()) // inside .zip() we put in the other iter. Now they are together.
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();

    println!("For key {} we get {}.", 2, number_word_hashmap.get(&amp;2).unwrap());
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">For key 2 we get two.
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å†™äº† <code>&lt;HashMap&lt;_, _&gt;&gt;</code>ï¼Œå› ä¸ºè¿™è¶³ä»¥è®© Rust å†³å®š <code>HashMap&lt;i32, &amp;str&gt;</code> çš„ç±»å‹ã€‚å¦‚æœä½ æƒ³å†™ <code>.collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();</code>ä¹Ÿè¡Œï¼Œä¹Ÿå¯ä»¥è¿™æ ·å†™:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // a Vec&lt;i32&gt;
    let some_words = vec!["zero", "one", "two", "three", "four", "five"]; // a Vec&lt;&amp;str&gt;
    let number_word_hashmap: HashMap&lt;_, _&gt; = some_numbers  // Because we tell it the type here...
        .into_iter()
        .zip(some_words.into_iter())
        .collect(); // we don't have to tell it here
}</code></pre></pre>
<p>è¿˜æœ‰ä¸€ç§æ–¹æ³•ï¼Œå°±åƒ<code>.enumerate()</code>çš„<code>char</code>ã€‚<code>char_indices()</code>. (Indicesçš„æ„æ€æ˜¯ "ç´¢å¼•")ã€‚ä½ ç”¨å®ƒçš„æ–¹æ³•æ˜¯ä¸€æ ·çš„ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç”±3ä½æ•°ç»„æˆçš„å¤§å­—ç¬¦ä¸²ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers_together = "140399923481800622623218009598281";

    for (index, number) in numbers_together.char_indices() {
        match (index % 3, number) {
            (0..=1, number) =&gt; print!("{}", number), // just print the number if there is a remainder
            _ =&gt; print!("{}\t", number), // otherwise print the number with a tab space
        }
    }
}</code></pre></pre>
<p>æ‰“å°<code>140     399     923     481     800     622     623     218     009     598    281</code>ã€‚</p>
<h3 id="é—­åŒ…ä¸­çš„_"><a class="header" href="#é—­åŒ…ä¸­çš„_">é—­åŒ…ä¸­çš„|_|</a></h3>
<p>æœ‰æ—¶ä½ ä¼šåœ¨ä¸€ä¸ªé—­åŒ…ä¸­çœ‹åˆ° <code>|_|</code>ã€‚è¿™æ„å‘³ç€è¿™ä¸ªé—­åŒ…éœ€è¦ä¸€ä¸ªå‚æ•°(æ¯”å¦‚ <code>x</code>)ï¼Œä½†ä½ ä¸æƒ³ä½¿ç”¨å®ƒã€‚æ‰€ä»¥ <code>|_|</code> æ„å‘³ç€ "å¥½å§ï¼Œè¿™ä¸ªé—­åŒ…éœ€è¦ä¸€ä¸ªå‚æ•°ï¼Œä½†æˆ‘ä¸ä¼šç»™å®ƒä¸€ä¸ªåå­—ï¼Œå› ä¸ºæˆ‘ä¸å…³å¿ƒå®ƒ"ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªé”™è¯¯çš„ä¾‹å­ï¼Œå½“ä½ ä¸è¿™æ ·åšçš„æ—¶å€™ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    println!("{:?}", my_vec.iter().for_each(|| println!("We didn't use the variables at all"))); // âš ï¸
}</code></pre></pre>
<p>Rustè¯´</p>
<pre><code class="language-text">error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments
  --&gt; src\main.rs:28:36
   |
28 |     println!("{:?}", my_vec.iter().for_each(|| println!("We didn't use the variables at all")));
   |                                    ^^^^^^^^ -- takes 0 arguments
   |                                    |
   |                                    expected closure that takes 1 argument
</code></pre>
<p>ç¼–è¯‘å™¨å…¶å®ç»™ä½ ä¸€äº›å¸®åŠ©ã€‚</p>
<pre><code class="language-text">help: consider changing the closure to take and ignore the expected argument
   |
28 |     println!("{:?}", my_vec.iter().for_each(|_| println!("We didn't use the variables at all")));
</code></pre>
<p>è¿™æ˜¯å¾ˆå¥½çš„å»ºè®®ã€‚å¦‚æœä½ æŠŠ<code>||</code>æ”¹æˆ<code>|_|</code>å°±å¯ä»¥äº†ã€‚</p>
<h3 id="é—­åŒ…å’Œè¿­ä»£å™¨çš„æœ‰ç”¨æ–¹æ³•"><a class="header" href="#é—­åŒ…å’Œè¿­ä»£å™¨çš„æœ‰ç”¨æ–¹æ³•">é—­åŒ…å’Œè¿­ä»£å™¨çš„æœ‰ç”¨æ–¹æ³•</a></h3>
<p>ä¸€æ—¦ä½ ç†Ÿæ‚‰äº†é—­åŒ…ï¼ŒRustå°±ä¼šæˆä¸ºä¸€ç§éå¸¸æœ‰è¶£çš„è¯­è¨€ã€‚æœ‰äº†é—­åŒ…ï¼Œä½ å¯ä»¥å°†æ–¹æ³•äº’ç›¸<em>é“¾æ¥</em>èµ·æ¥ï¼Œç”¨å¾ˆå°‘çš„ä»£ç åšå¾ˆå¤šäº‹æƒ…ã€‚ä¸‹é¢æ˜¯ä¸€äº›æˆ‘ä»¬è¿˜æ²¡æœ‰è§è¿‡çš„é—­åŒ…å’Œä½¿ç”¨é—­åŒ…çš„æ–¹æ³•ã€‚</p>
<p><code>.filter()</code>: è¿™å¯ä»¥è®©ä½ åœ¨è¿­ä»£å™¨ä¸­ä¿ç•™ä½ æƒ³ä¿ç•™çš„å…ƒç´ ã€‚è®©æˆ‘ä»¬è¿‡æ»¤ä¸€å¹´ä¸­çš„æœˆä»½ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let months = vec!["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    let filtered_months = months
        .into_iter()                         // make an iter
        .filter(|month| month.len() &lt; 5)     // We don't want months more than 5 bytes in length.
                                             // We know that each letter is one byte so .len() is fine
        .filter(|month| month.contains("u")) // Also we only like months with the letter u
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

    println!("{:?}", filtered_months);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°<code>["June", "July"]</code>ã€‚</p>
<p><code>.filter_map()</code>. è¿™ä¸ªå«åš<code>filter_map()</code>ï¼Œå› ä¸ºå®ƒåšäº†<code>.filter()</code>å’Œ<code>.map()</code>ã€‚é—­åŒ…å¿…é¡»è¿”å›ä¸€ä¸ª <code>Option&lt;T&gt;</code>ï¼Œç„¶åå¯¹æ¯ä¸ª<code>Option</code>, å¦‚æœæ˜¯ <code>Some</code>, <code>filter_map()</code>å°†å–å‡ºå®ƒçš„å€¼ã€‚æ‰€ä»¥æ¯”å¦‚è¯´ä½ <code>.filter_map()</code>ä¸€ä¸ª<code>vec![Some(2), None, Some(3)]</code>ï¼Œå®ƒå°±ä¼šè¿”å›<code>[2, 3]</code>ã€‚</p>
<p>æˆ‘ä»¬å°†ç”¨ä¸€ä¸ª<code>Company</code>ç»“æ„ä½“æ¥å†™ä¸€ä¸ªä¾‹å­ã€‚æ¯ä¸ªå…¬å¸éƒ½æœ‰ä¸€ä¸ª<code>name</code>ï¼Œæ‰€ä»¥è¿™ä¸ªå­—æ®µæ˜¯<code>String</code>ï¼Œä½†æ˜¯CEOå¯èƒ½æœ€è¿‘å·²ç»è¾èŒäº†ã€‚æ‰€ä»¥<code>ceo</code>å­—æ®µæ˜¯<code>Option&lt;String&gt;</code>ã€‚æˆ‘ä»¬ä¼š<code>.filter_map()</code>è¿‡ä¸€äº›å…¬å¸ï¼Œåªä¿ç•™CEOåå­—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            "" =&gt; None,
            name =&gt; Some(name.to_string()),
        }; // ceo is decided, so now we return Self
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone() // Just returns a clone of the CEO (struct is not Copy)
    }
}

fn main() {
    let company_vec = vec![
        Company::new("Umbrella Corporation", "Unknown"),
        Company::new("Ovintiv", "Doug Suttles"),
        Company::new("The Red-Headed League", ""),
        Company::new("Stark Enterprises", ""),
    ];

    let all_the_ceos = company_vec
        .into_iter()
        .filter_map(|company| company.get_ceo()) // filter_map needs Option&lt;T&gt;
        .collect::&lt;Vec&lt;String&gt;&gt;();

    println!("{:?}", all_the_ceos);
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡ºäº†<code>["Unknown", "Doug Suttles"]</code>ã€‚</p>
<p>æ—¢ç„¶ <code>.filter_map()</code> éœ€è¦ <code>Option</code>ï¼Œé‚£ä¹ˆ <code>Result</code> å‘¢ï¼Ÿæ²¡é—®é¢˜:æœ‰ä¸€ä¸ªå«åš <code>.ok()</code> çš„æ–¹æ³•ï¼Œå¯ä»¥æŠŠ <code>Result</code> å˜æˆ <code>Option</code>ã€‚ä¹‹æ‰€ä»¥å«<code>.ok()</code>ï¼Œæ˜¯å› ä¸ºå®ƒèƒ½å‘é€çš„åªæ˜¯<code>Ok</code>çš„ç»“æœ(<code>Err</code>çš„ä¿¡æ¯æ²¡æœ‰äº†)ã€‚ä½ è®°å¾—<code>Option</code>æ˜¯<code>Option&lt;T&gt;</code>ï¼Œè€Œ<code>Result</code>æ˜¯<code>Result&lt;T, E&gt;</code>ï¼ŒåŒæ—¶æœ‰<code>Ok</code>å’Œ<code>Err</code>çš„ä¿¡æ¯ã€‚æ‰€ä»¥å½“ä½ ä½¿ç”¨<code>.ok()</code>æ—¶ï¼Œä»»ä½•<code>Err</code>çš„ä¿¡æ¯éƒ½ä¼šä¸¢å¤±ï¼Œå˜æˆ<code>None</code>ã€‚</p>
<p>ä½¿ç”¨ <code>.parse()</code> æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„ä¾‹å­ï¼Œæˆ‘ä»¬å°è¯•è§£æä¸€äº›ç”¨æˆ·è¾“å…¥ã€‚<code>.parse()</code>åœ¨è¿™é‡Œæ¥å—ä¸€ä¸ª<code>&amp;str</code>ï¼Œå¹¶è¯•å›¾æŠŠå®ƒå˜æˆä¸€ä¸ª<code>f32</code>ã€‚å®ƒè¿”å›ä¸€ä¸ª <code>Result</code>ï¼Œä½†æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ <code>filter_map()</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€æŠ›å‡ºé”™è¯¯ã€‚<code>Err</code>çš„ä»»ä½•å†…å®¹éƒ½ä¼šå˜æˆ<code>None</code>ï¼Œå¹¶è¢«<code>.filter_map()</code>è¿‡æ»¤æ‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let user_input = vec!["8.9", "Nine point nine five", "8.0", "7.6", "eleventy-twelve"];

    let actual_numbers = user_input
        .into_iter()
        .filter_map(|input| input.parse::&lt;f32&gt;().ok())
        .collect::&lt;Vec&lt;f32&gt;&gt;();

    println!("{:?}", actual_numbers);
}</code></pre></pre>
<p>å°†æ‰“å°: <code>[8.9, 8.0, 7.6]</code>ã€‚</p>
<p>ä¸<code>.ok()</code>ç›¸å¯¹çš„æ˜¯<code>.ok_or()</code>å’Œ<code>ok_or_else()</code>ã€‚è¿™æ ·å°±æŠŠ<code>Option</code>å˜æˆäº†<code>Result</code>ã€‚ä¹‹æ‰€ä»¥å«<code>.ok_or()</code>ï¼Œæ˜¯å› ä¸º<code>Result</code>ç»™å‡ºäº†ä¸€ä¸ª<code>Ok</code><strong>æˆ–</strong><code>Err</code>ï¼Œæ‰€ä»¥ä½ å¿…é¡»è®©å®ƒçŸ¥é“<code>Err</code>çš„å€¼æ˜¯å¤šå°‘ã€‚è¿™æ˜¯å› ä¸º<code>None</code>ä¸­çš„<code>Option</code>æ²¡æœ‰ä»»ä½•ä¿¡æ¯ã€‚å¦å¤–ï¼Œä½ ç°åœ¨å¯ä»¥çœ‹åˆ°ï¼Œè¿™äº›æ–¹æ³•åç§°ä¸­çš„<em>else</em>éƒ¨åˆ†æ„å‘³ç€å®ƒæœ‰ä¸€ä¸ªé—­åŒ…ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥æŠŠæˆ‘ä»¬çš„<code>Option</code>ä»<code>Company</code>ç»“æ„ä¸­å–å‡ºæ¥ï¼Œç„¶åè¿™æ ·æŠŠå®ƒå˜æˆä¸€ä¸ª<code>Result</code>ã€‚å¯¹äºé•¿æœŸçš„é”™è¯¯å¤„ç†ï¼Œæœ€å¥½æ˜¯åˆ›å»ºè‡ªå·±çš„é”™è¯¯ç±»å‹ã€‚
ä½†æ˜¯ç°åœ¨æˆ‘ä»¬åªæ˜¯ç»™å®ƒä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œæ‰€ä»¥å®ƒå°±å˜æˆäº†<code>Result&lt;String, &amp;str&gt;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// Everything before main() is exactly the same
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            "" =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new("Umbrella Corporation", "Unknown"),
        Company::new("Ovintiv", "Doug Suttles"),
        Company::new("The Red-Headed League", ""),
        Company::new("Stark Enterprises", ""),
    ];

    let mut results_vec = vec![]; // Pretend we need to gather error results too

    company_vec
        .iter()
        .for_each(|company| results_vec.push(company.get_ceo().ok_or("No CEO found")));

    for item in results_vec {
        println!("{:?}", item);
    }
}</code></pre></pre>
<p>è¿™è¡Œæ˜¯æœ€å¤§çš„å˜åŒ–:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
.for_each(|company| results_vec.push(company.get_ceo().ok_or("No CEO found")));
<span class="boring">}</span></code></pre></pre>
<p>å®ƒçš„æ„æ€æ˜¯:"æ¯å®¶å…¬å¸ï¼Œç”¨<code>get_ceo()</code>. å¦‚æœä½ å¾—åˆ°äº†ï¼Œé‚£å°±æŠŠ<code>Ok</code>é‡Œé¢çš„æ•°å€¼ä¼ ç»™ä½ ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°±åœ¨<code>Err</code>é‡Œé¢ä¼ é€’ "æ²¡æœ‰æ‰¾åˆ°CEO"ã€‚ç„¶åæŠŠè¿™ä¸ªæ¨åˆ°vecé‡Œã€‚"</p>
<p>æ‰€ä»¥å½“æˆ‘ä»¬æ‰“å°<code>results_vec</code>çš„æ—¶å€™ï¼Œå°±ä¼šå¾—åˆ°è¿™æ ·çš„ç»“æœã€‚</p>
<pre><code class="language-text">Ok("Unknown")
Ok("Doug Suttles")
Err("No CEO found")
Err("No CEO found")
</code></pre>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æœ‰äº†æ‰€æœ‰å››ä¸ªæ¡ç›®ã€‚ç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨ <code>.ok_or_else()</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ä¸€ä¸ªé—­åŒ…ï¼Œå¹¶å¾—åˆ°ä¸€ä¸ªæ›´å¥½çš„é”™è¯¯ä¿¡æ¯ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ç©ºé—´ä½¿ç”¨<code>format!</code>æ¥åˆ›å»ºä¸€ä¸ª<code>String</code>ï¼Œå¹¶å°†å…¬å¸åç§°æ”¾åœ¨å…¶ä¸­ã€‚ç„¶åæˆ‘ä»¬è¿”å›<code>String</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// Everything before main() is exactly the same
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            "" =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new("Umbrella Corporation", "Unknown"),
        Company::new("Ovintiv", "Doug Suttles"),
        Company::new("The Red-Headed League", ""),
        Company::new("Stark Enterprises", ""),
    ];

    let mut results_vec = vec![];

    company_vec.iter().for_each(|company| {
        results_vec.push(company.get_ceo().ok_or_else(|| {
            let err_message = format!("No CEO found for {}", company.name);
            err_message
        }))
    });

    for item in results_vec {
        println!("{:?}", item);
    }
}</code></pre></pre>
<p>è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±æœ‰äº†ã€‚</p>
<pre><code class="language-text">Ok("Unknown")
Ok("Doug Suttles")
Err("No CEO found for The Red-Headed League")
Err("No CEO found for Stark Enterprises")
</code></pre>
<p><code>.and_then()</code>æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æ–¹æ³•ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ª<code>Option</code>ï¼Œç„¶åè®©ä½ å¯¹å®ƒçš„å€¼åšä¸€äº›äº‹æƒ…ï¼Œå¹¶æŠŠå®ƒä¼ é€’å‡ºå»ã€‚æ‰€ä»¥å®ƒçš„è¾“å…¥æ˜¯ä¸€ä¸ª <code>Option</code>ï¼Œè¾“å‡ºä¹Ÿæ˜¯ä¸€ä¸ª <code>Option</code>ã€‚è¿™æœ‰ç‚¹åƒä¸€ä¸ªå®‰å…¨çš„ "è§£åŒ…ï¼Œç„¶ååšä¸€äº›äº‹æƒ…ï¼Œç„¶åå†åŒ…"ã€‚</p>
<p>ä¸€ä¸ªç®€å•çš„ä¾‹å­æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ <code>.get()</code> ä»ä¸€ä¸ª vec ä¸­å¾—åˆ°ä¸€ä¸ªæ•°å­—ï¼Œå› ä¸ºå®ƒè¿”å›ä¸€ä¸ª <code>Option</code>ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥æŠŠå®ƒä¼ ç»™ <code>and_then()</code>ï¼Œå¦‚æœå®ƒæ˜¯ <code>Some</code>ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å®ƒåšä¸€äº›æ•°å­¦è¿ç®—ã€‚å¦‚æœæ˜¯<code>None</code>ï¼Œé‚£ä¹ˆ<code>None</code>å°±ä¼šè¢«ä¼ é€’è¿‡å»ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 0]; // just a vec with numbers

    let number_to_add = 5;       // use this in the math later
    let mut empty_vec = vec![];  // results go in here


    for index in 0..5 {
        empty_vec.push(
            new_vec
               .get(index)
                .and_then(|number| Some(number + 1))
                .and_then(|number| Some(number + number_to_add))
        );
    }
    println!("{:?}", empty_vec);
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡ºäº†<code>[Some(14), Some(15), Some(6), None, None]</code>ã€‚ä½ å¯ä»¥çœ‹åˆ°<code>None</code>å¹¶æ²¡æœ‰è¢«è¿‡æ»¤æ‰ï¼Œåªæ˜¯ä¼ é€’äº†ã€‚</p>
<p><code>.and()</code>æœ‰ç‚¹åƒ<code>Option</code>çš„<code>bool</code>ã€‚ä½ å¯ä»¥åŒ¹é…å¾ˆå¤šä¸ª<code>Option</code>ï¼Œå¦‚æœå®ƒä»¬éƒ½æ˜¯<code>Some</code>ï¼Œé‚£ä¹ˆå®ƒä¼šç»™å‡ºæœ€åä¸€ä¸ªã€‚è€Œå¦‚æœå…¶ä¸­ä¸€ä¸ªæ˜¯<code>None</code>ï¼Œé‚£ä¹ˆå°±ä¼šç»™å‡º<code>None</code>ã€‚</p>
<p>é¦–å…ˆè¿™é‡Œæœ‰ä¸€ä¸ª<code>bool</code>çš„ä¾‹å­æ¥å¸®åŠ©æƒ³è±¡ã€‚ä½ å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœä½ ç”¨çš„æ˜¯<code>&amp;&amp;</code>(å’Œ)ï¼Œå“ªæ€•æ˜¯ä¸€ä¸ª<code>false</code>ï¼Œä¹Ÿä¼šè®©ä¸€åˆ‡<code>false</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let one = true;
    let two = false;
    let three = true;
    let four = true;

    println!("{}", one &amp;&amp; three); // prints true
    println!("{}", one &amp;&amp; two &amp;&amp; three &amp;&amp; four); // prints false
}</code></pre></pre>
<p>ç°åœ¨è¿™é‡Œçš„<code>.and()</code>ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬åšäº†äº”æ¬¡æ“ä½œï¼Œå¹¶æŠŠç»“æœæ”¾åœ¨ä¸€ä¸ªVec&lt;Option&lt;&amp;str&gt;&gt;ä¸­ã€‚å¦‚æœæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªå€¼ï¼Œæˆ‘ä»¬å°±æŠŠ<code>Some("success!")</code>æ¨åˆ°Vecä¸­ã€‚ç„¶åæˆ‘ä»¬å†åšä¸¤æ¬¡è¿™æ ·çš„æ“ä½œã€‚ä¹‹åæˆ‘ä»¬ç”¨<code>.and()</code>æ¯æ¬¡åªæ˜¾ç¤ºå¾—åˆ°<code>Some</code>çš„ç´¢å¼•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_try = vec![Some("success!"), None, Some("success!"), Some("success!"), None];
    let second_try = vec![None, Some("success!"), Some("success!"), Some("success!"), Some("success!")];
    let third_try = vec![Some("success!"), Some("success!"), Some("success!"), Some("success!"), None];

    for i in 0..first_try.len() {
        println!("{:?}", first_try[i].and(second_try[i]).and(third_try[i]));
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">None
None
Some("success!")
Some("success!")
None
</code></pre>
<p>ç¬¬ä¸€ä¸ª(ç´¢å¼•0)æ˜¯<code>None</code>ï¼Œå› ä¸ºåœ¨<code>second_try</code>ä¸­æœ‰ä¸€ä¸ª<code>None</code>ä¸ºç´¢å¼•0ã€‚ç¬¬äºŒä¸ªæ˜¯<code>None</code>ï¼Œå› ä¸ºåœ¨<code>first_try</code>ä¸­æœ‰ä¸€ä¸ª<code>None</code>ã€‚å…¶æ¬¡æ˜¯<code>Some("success!")</code>ï¼Œå› ä¸º<code>first_try</code>ã€<code>second try</code>ã€<code>third_try</code>ä¸­æ²¡æœ‰<code>None</code>ã€‚</p>
<p><code>.any()</code>å’Œ<code>.all()</code>åœ¨è¿­ä»£å™¨ä¸­éå¸¸å®¹æ˜“ä½¿ç”¨ã€‚å®ƒä»¬æ ¹æ®ä½ çš„è¾“å…¥è¿”å›ä¸€ä¸ª<code>bool</code>ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åšäº†ä¸€ä¸ªéå¸¸å¤§çš„vec(å¤§çº¦20000ä¸ªå…ƒç´ )ï¼ŒåŒ…å«äº†ä»<code>'a'</code>åˆ°<code>'åƒ'</code>çš„æ‰€æœ‰å­—ç¬¦ã€‚ç„¶åæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå‡½æ•°æ¥æ£€æŸ¥æ˜¯å¦æœ‰å­—ç¬¦åœ¨å…¶ä¸­ã€‚</p>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ›´å°çš„vecï¼Œé—®å®ƒæ˜¯å¦éƒ½æ˜¯å­—æ¯(ç”¨<code>.is_alphabetic()</code>æ–¹æ³•)ã€‚ç„¶åæˆ‘ä»¬é—®å®ƒæ˜¯ä¸æ˜¯æ‰€æœ‰çš„å­—ç¬¦éƒ½å°äºéŸ©æ–‡å­—ç¬¦<code>'í–‰'</code>ã€‚</p>
<p>è¿˜è¦æ³¨æ„æ”¾ä¸€ä¸ªå‚ç…§ç‰©ï¼Œå› ä¸º<code>.iter()</code>ç»™äº†ä¸€ä¸ªå‚ç…§ç‰©ï¼Œä½ éœ€è¦ä¸€ä¸ª<code>&amp;</code>å’Œå¦ä¸€ä¸ª<code>&amp;</code>è¿›è¡Œæ¯”è¾ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn in_char_vec(char_vec: &amp;Vec&lt;char&gt;, check: char) {
    println!("Is {} inside? {}", check, char_vec.iter().any(|&amp;char| char == check));
}

fn main() {
    let char_vec = ('a'..'åƒ').collect::&lt;Vec&lt;char&gt;&gt;();
    in_char_vec(&amp;char_vec, 'i');
    in_char_vec(&amp;char_vec, 'ë·');
    in_char_vec(&amp;char_vec, 'é‘¿');

    let smaller_vec = ('A'..'z').collect::&lt;Vec&lt;char&gt;&gt;();
    println!("All alphabetic? {}", smaller_vec.iter().all(|&amp;x| x.is_alphabetic()));
    println!("All less than the character í–‰? {}", smaller_vec.iter().all(|&amp;x| x &lt; 'í–‰'));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Is i inside? true
Is ë· inside? false
Is é‘¿ inside? false
All alphabetic? false
All less than the character í–‰? true
</code></pre>
<p>é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œ<code>.any()</code>åªæ£€æŸ¥åˆ°ä¸€ä¸ªåŒ¹é…çš„å…ƒç´ ï¼Œç„¶åå°±åœæ­¢äº†ã€‚å¦‚æœå®ƒå·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªåŒ¹é…é¡¹ï¼Œå®ƒä¸ä¼šæ£€æŸ¥æ‰€æœ‰çš„å…ƒç´ ã€‚å¦‚æœæ‚¨è¦åœ¨ <code>Vec</code> ä¸Šä½¿ç”¨ <code>.any()</code>ï¼Œæœ€å¥½æŠŠå¯èƒ½åŒ¹é…çš„å…ƒç´ æ¨åˆ°å‰é¢ã€‚æˆ–è€…ä½ å¯ä»¥åœ¨ <code>.iter()</code> ä¹‹åä½¿ç”¨ <code>.rev()</code> æ¥åå‘è¿­ä»£ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªè¿™æ ·çš„vecã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);
}</code></pre></pre>
<p>æ‰€ä»¥è¿™ä¸ª<code>Vec</code>æœ‰1000ä¸ª<code>6</code>ï¼Œåé¢è¿˜æœ‰ä¸€ä¸ª<code>5</code>ã€‚æˆ‘ä»¬å‡è®¾æˆ‘ä»¬è¦ç”¨<code>.any()</code>æ¥çœ‹çœ‹å®ƒæ˜¯å¦åŒ…å«5ã€‚é¦–å…ˆè®©æˆ‘ä»¬ç¡®å®š<code>.rev()</code>æ˜¯æœ‰æ•ˆçš„ã€‚è®°ä½ï¼Œä¸€ä¸ª<code>Iterator</code>æ€»æ˜¯æœ‰<code>.next()</code>ï¼Œè®©ä½ æ¯æ¬¡éƒ½æ£€æŸ¥å®ƒçš„å·¥ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut iterator = big_vec.iter().rev();
    println!("{:?}", iterator.next());
    println!("{:?}", iterator.next());
}</code></pre></pre>
<p>å®ƒçš„æ‰“å°ã€‚</p>
<pre><code class="language-text">Some(5)
Some(6)
</code></pre>
<p>æˆ‘ä»¬æ˜¯å¯¹çš„:æœ‰ä¸€ä¸ª<code>Some(5)</code>ï¼Œç„¶å1000ä¸ª<code>Some(6)</code>å¼€å§‹ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    println!("{:?}", big_vec.iter().rev().any(|&amp;number| number == 5));
}</code></pre></pre>
<p>è€Œä¸”å› ä¸ºæ˜¯<code>.rev()</code>ï¼Œæ‰€ä»¥å®ƒåªè°ƒç”¨<code>.next()</code>ä¸€æ¬¡å°±åœæ­¢äº†ã€‚å¦‚æœæˆ‘ä»¬ä¸ç”¨<code>.rev()</code>ï¼Œé‚£ä¹ˆå®ƒå°†è°ƒç”¨<code>.next()</code> 1001æ¬¡æ‰åœæ­¢ã€‚è¿™æ®µä»£ç æ˜¾ç¤ºäº†å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut counter = 0; // Start counting
    let mut big_iter = big_vec.into_iter(); // Make it an Iterator

    loop {
        counter +=1;
        if big_iter.next() == Some(5) { // Keep calling .next() until we get Some(5)
            break;
        }
    }
    println!("Final counter is: {}", counter);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>Final counter is: 1001</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬çŸ¥é“å®ƒå¿…é¡»è°ƒç”¨ <code>.next()</code> 1001 æ¬¡æ‰èƒ½æ‰¾åˆ° 5ã€‚</p>
<p><code>.find()</code> å‘Šè¯‰ä½ ä¸€ä¸ªè¿­ä»£å™¨æ˜¯å¦æœ‰ä¸œè¥¿ï¼Œè€Œ <code>.position()</code> å‘Šè¯‰ä½ å®ƒåœ¨å“ªé‡Œã€‚<code>.find()</code>ä¸<code>.any()</code>ä¸åŒï¼Œå› ä¸ºå®ƒè¿”å›ä¸€ä¸ª<code>Option</code>ï¼Œé‡Œé¢æœ‰å€¼(æˆ–<code>None</code>)ã€‚åŒæ—¶ï¼Œ<code>.position()</code>ä¹Ÿæ˜¯ä¸€ä¸ªå¸¦æœ‰ä½ç½®å·çš„<code>Option</code>ï¼Œæˆ–<code>None</code>ã€‚æ¢å¥è¯è¯´</p>
<ul>
<li><code>.find()</code>: "æˆ‘å°½é‡å¸®ä½ æ‹¿"</li>
<li><code>.position()</code>:"æˆ‘å¸®ä½ æ‰¾æ‰¾çœ‹åœ¨å“ªé‡Œ"</li>
</ul>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    println!("{:?}", num_vec.iter().find(|&amp;number| number % 3 == 0)); // find takes a reference, so we give it &amp;number
    println!("{:?}", num_vec.iter().find(|&amp;number| number * 2 == 30));

    println!("{:?}", num_vec.iter().position(|&amp;number| number % 3 == 0));
    println!("{:?}", num_vec.iter().position(|&amp;number| number * 2 == 30));

}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Some(30) // This is the number itself
None // No number inside times 2 == 30
Some(2) // This is the position
None
</code></pre>
<p>ä½¿ç”¨ <code>.cycle()</code> ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªæ°¸è¿œå¾ªç¯çš„è¿­ä»£å™¨ã€‚è¿™ç§ç±»å‹çš„è¿­ä»£å™¨ä¸ <code>.zip()</code> å¾ˆå¥½åœ°ç»“åˆåœ¨ä¸€èµ·ï¼Œå¯ä»¥åˆ›å»ºæ–°çš„ä¸œè¥¿ï¼Œå°±åƒè¿™ä¸ªä¾‹å­ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ª <code>Vec&lt;(i32, &amp;str)&gt;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let even_odd = vec!["even", "odd"];

    let even_odd_vec = (0..6)
        .zip(even_odd.into_iter().cycle())
        .collect::&lt;Vec&lt;(i32, &amp;str)&gt;&gt;();
    println!("{:?}", even_odd_vec);
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œå³ä½¿<code>.cycle()</code>å¯èƒ½æ°¸è¿œä¸ä¼šç»“æŸï¼Œä½†å½“æŠŠå®ƒä»¬å‹ç¼©åœ¨ä¸€èµ·æ—¶ï¼Œå¦ä¸€ä¸ªè¿­ä»£å™¨åªè¿è¡Œäº†6æ¬¡ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œ<code>.cycle()</code>æ‰€åšçš„è¿­ä»£å™¨ä¸ä¼šå†è¢«<code>.next()</code>è°ƒç”¨ï¼Œæ‰€ä»¥å…­æ¬¡ä¹‹åå°±å®Œæˆäº†ã€‚è¾“å‡ºçš„ç»“æœæ˜¯</p>
<pre><code>[(0, "even"), (1, "odd"), (2, "even"), (3, "odd"), (4, "even"), (5, "odd")]
</code></pre>
<p>ç±»ä¼¼çš„äº‹æƒ…ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªæ²¡æœ‰ç»“å°¾çš„èŒƒå›´æ¥å®Œæˆã€‚å¦‚æœä½ å†™<code>0..</code>ï¼Œé‚£ä¹ˆä½ å°±åˆ›å»ºäº†ä¸€ä¸ªæ°¸ä¸åœæ­¢çš„èŒƒå›´ã€‚ä½ å¯ä»¥å¾ˆå®¹æ˜“åœ°ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ten_chars = ('a'..).take(10).collect::&lt;Vec&lt;char&gt;&gt;();
    let skip_then_ten_chars = ('a'..).skip(1300).take(10).collect::&lt;Vec&lt;char&gt;&gt;();

    println!("{:?}", ten_chars);
    println!("{:?}", skip_then_ten_chars);
}</code></pre></pre>
<p>ä¸¤è€…éƒ½æ˜¯æ‰“å°åä¸ªå­—ç¬¦ï¼Œä½†ç¬¬äºŒä¸ªè·³è¿‡1300ä½ï¼Œæ‰“å°çš„æ˜¯äºšç¾å°¼äºšè¯­çš„åä¸ªå­—æ¯ã€‚</p>
<pre><code>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
['Õµ', 'Õ¶', 'Õ·', 'Õ¸', 'Õ¹', 'Õº', 'Õ»', 'Õ¼', 'Õ½', 'Õ¾']
</code></pre>
<p>å¦ä¸€ç§æµè¡Œçš„æ–¹æ³•å«åš<code>.fold()</code>ã€‚è¿™ä¸ªæ–¹æ³•ç»å¸¸ç”¨äºå°†è¿­ä»£å™¨ä¸­çš„å…ƒç´ åŠ åœ¨ä¸€èµ·ï¼Œä½†ä½ ä¹Ÿå¯ä»¥åšæ›´å¤šçš„äº‹æƒ…ã€‚å®ƒä¸<code>.for_each()</code>æœ‰äº›ç±»ä¼¼ã€‚åœ¨ <code>.fold()</code> ä¸­ï¼Œä½ é¦–å…ˆæ·»åŠ ä¸€ä¸ªèµ·å§‹å€¼ (å¦‚æœä½ æ˜¯æŠŠå…ƒç´ åŠ åœ¨ä¸€èµ·ï¼Œé‚£ä¹ˆå°±æ˜¯ 0)ï¼Œç„¶åæ˜¯ä¸€ä¸ªé€—å·ï¼Œç„¶åæ˜¯é—­åŒ…ã€‚ç»“å°¾ç»™ä½ ä¸¤ä¸ªå…ƒç´ :åˆ°ç›®å‰ä¸ºæ­¢çš„æ€»æ•°ï¼Œå’Œä¸‹ä¸€ä¸ªå…ƒç´ ã€‚é¦–å…ˆè¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæ˜¾ç¤º<code>.fold()</code>å°†å…ƒç´ åŠ åœ¨ä¸€èµ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_numbers = vec![9, 6, 9, 10, 11];

    println!("{}", some_numbers
        .iter()
        .fold(0, |total_so_far, next_number| total_so_far + next_number)
    );
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œåœ¨ç¬¬1æ­¥ä¸­ï¼Œå®ƒä»0å¼€å§‹ï¼Œå†åŠ ä¸Šä¸‹ä¸€ä¸ªæ•°å­—:9ã€‚</p>
<ul>
<li>ç¬¬1æ­¥ï¼Œä»0å¼€å§‹ï¼ŒåŠ ä¸Šä¸‹ä¸€ä¸ªæ•°å­—9</li>
<li>ç„¶åæŠŠ9åŠ ä¸Š6: 15ã€‚</li>
<li>ç„¶åæŠŠ15åŠ ä¸Š9: 24ã€‚</li>
<li>ç„¶åå–24ï¼Œå†åŠ ä¸Š10: 34ã€‚</li>
<li>æœ€åå–34ï¼Œå†åŠ ä¸Š11: 45ã€‚æ‰€ä»¥å®ƒçš„æ‰“å°ç»“æœæ˜¯<code>45</code>.</li>
</ul>
<p>ä½†æ˜¯ä½ ä¸éœ€è¦åªç”¨å®ƒæ¥æ·»åŠ ä¸œè¥¿ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸€ä¸ªå­—ç¬¦ä¸ŠåŠ ä¸€ä¸ª'-'ï¼Œå°±ä¼šå˜æˆ<code>String</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a_string = "I don't have any dashes in me.";

    println!(
        "{}",
        a_string
            .chars() // Now it's an iterator
            .fold("-".to_string(), |mut string_so_far, next_char| { // Start with a String "-". Bring it in as mutable each time along with the next char
                string_so_far.push(next_char); // Push the char on, then '-'
                string_so_far.push('-');
                string_so_far} // Don't forget to pass it on to the next loop
            ));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">-I- -d-o-n-'-t- -h-a-v-e- -a-n-y- -d-a-s-h-e-s- -i-n- -m-e-.-
</code></pre>
<p>è¿˜æœ‰å¾ˆå¤šå…¶ä»–æ–¹ä¾¿çš„æ–¹æ³•ï¼Œæ¯”å¦‚</p>
<ul>
<li><code>.take_while()</code>ï¼Œåªè¦å¾—åˆ°<code>true</code>ï¼Œå°±ä¼šå¸¦å…¥ä¸€ä¸ªè¿­ä»£å™¨(ä¾‹å¦‚<code>take while x &gt; 5</code>)</li>
<li><code>.cloned()</code>ï¼Œå®ƒåœ¨è¿­ä»£å™¨å†…åšäº†ä¸€ä¸ªå…‹éš†ã€‚è¿™å°†ä¸€ä¸ªå¼•ç”¨å˜æˆäº†ä¸€ä¸ªå€¼ã€‚</li>
<li><code>.by_ref()</code>ï¼Œå®ƒä½¿è¿­ä»£å™¨å–ä¸€ä¸ªå¼•ç”¨ã€‚è¿™å¾ˆå¥½çš„ä¿è¯äº†ä½ ä½¿ç”¨<code>Vec</code>æˆ–ç±»ä¼¼çš„æ–¹æ³•æ¥åˆ›å»ºè¿­ä»£å™¨åå¯ä»¥ä½¿ç”¨å®ƒã€‚</li>
<li>è®¸å¤šå…¶ä»–çš„<code>_while</code>æ–¹æ³•:<code>.skip_while()</code>ã€<code>.map_while()</code>ç­‰ç­‰ã€‚</li>
<li><code>.sum()</code>:å°±æ˜¯æŠŠæ‰€æœ‰çš„ä¸œè¥¿åŠ åœ¨ä¸€èµ·ã€‚</li>
</ul>
<p><code>.chunks()</code>å’Œ<code>.windows()</code>æ˜¯å°†çŸ¢é‡åˆ‡å‰²æˆä½ æƒ³è¦çš„å°ºå¯¸çš„ä¸¤ç§æ–¹æ³•ã€‚ä½ æŠŠä½ æƒ³è¦çš„å°ºå¯¸æ”¾åœ¨æ‹¬å·é‡Œã€‚æ¯”å¦‚è¯´ä½ æœ‰ä¸€ä¸ªæœ‰10ä¸ªå…ƒç´ çš„çŸ¢é‡ï¼Œä½ æƒ³è¦ä¸€ä¸ª3çš„å°ºå¯¸ï¼Œå®ƒçš„å·¥ä½œåŸç†æ˜¯è¿™æ ·çš„ã€‚</p>
<ul>
<li>
<p><code>.chunks()</code>ä¼šç»™ä½ 4ä¸ªåˆ‡ç‰‡: [0, 1, 2], ç„¶åæ˜¯[3, 4, 5], ç„¶åæ˜¯[6, 7, 8], æœ€åæ˜¯[9]. æ‰€ä»¥å®ƒä¼šå°è¯•ç”¨ä¸‰ä¸ªå…ƒç´ åˆ›å»ºä¸€ä¸ªåˆ‡ç‰‡ï¼Œä½†å¦‚æœå®ƒæ²¡æœ‰ä¸‰ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå®ƒå°±ä¸ä¼šå´©æºƒã€‚å®ƒåªä¼šç»™ä½ å‰©ä¸‹çš„ä¸œè¥¿ã€‚</p>
</li>
<li>
<p><code>.windows()</code>ä¼šå…ˆç»™ä½ ä¸€ä¸ª[0, 1, 2]çš„åˆ‡ç‰‡ã€‚ç„¶åå®ƒå°†ç§»è¿‡ä¸€ç‰‡ï¼Œç»™ä½ [1, 2, 3]ã€‚å®ƒå°†ä¸€ç›´è¿™æ ·åšï¼Œç›´åˆ°æœ€ååˆ°è¾¾3çš„æœ€åä¸€ç‰‡ï¼Œç„¶ååœæ­¢ã€‚</p>
</li>
</ul>
<p>æ‰€ä»¥è®©æˆ‘ä»¬åœ¨ä¸€ä¸ªç®€å•çš„æ•°å­—å‘é‡ä¸Šä½¿ç”¨å®ƒä»¬ã€‚å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

    for chunk in num_vec.chunks(3) {
        println!("{:?}", chunk);
    }
    println!();
    for window in num_vec.windows(3) {
        println!("{:?}", window);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[0]

[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 0]
</code></pre>
<p>é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œå¦‚æœä½ ä»€ä¹ˆéƒ½ä¸ç»™å®ƒï¼Œ<code>.chunks()</code>ä¼šå´©æºƒã€‚ä½ å¯ä»¥ä¸ºä¸€ä¸ªåªæœ‰ä¸€é¡¹çš„å‘é‡å†™<code>.chunks(1000)</code>ï¼Œä½†ä½ ä¸èƒ½ä¸ºä»»ä½•é•¿åº¦ä¸º0çš„ä¸œè¥¿å†™<code>.chunks()</code>ã€‚ å¦‚æœä½ ç‚¹å‡»[src]ï¼Œä½ å¯ä»¥åœ¨å‡½æ•°ä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒè¯´<code>assert!(chunk_size != 0);</code>ã€‚</p>
<p><code>.match_indices()</code> è®©ä½ æŠŠ <code>String</code> æˆ– <code>&amp;str</code> é‡Œé¢æ‰€æœ‰ç¬¦åˆä½ çš„è¾“å…¥çš„ä¸œè¥¿éƒ½æå–å‡ºæ¥ï¼Œå¹¶ç»™ä½ ç´¢å¼•ã€‚å®ƒä¸ <code>.enumerate()</code> ç±»ä¼¼ï¼Œå› ä¸ºå®ƒè¿”å›ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªå…ƒç´ çš„å…ƒç»„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rules = "Rule number 1: No fighting. Rule number 2: Go to bed at 8 pm. Rule number 3: Wake up at 6 am.";
    let rule_locations = rules.match_indices("Rule").collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // This is Vec&lt;usize, &amp;str&gt; but we just tell Rust to do it
    println!("{:?}", rule_locations);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">[(0, "Rule"), (28, "Rule"), (62, "Rule")]
</code></pre>
<p><code>.peekable()</code> è®©ä½ åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œåœ¨é‚£é‡Œä½ å¯ä»¥çœ‹åˆ° (çª¥è§†) ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚å®ƒå°±åƒè°ƒç”¨ <code>.next()</code> (å®ƒç»™å‡ºäº†ä¸€ä¸ª <code>Option</code>)ï¼Œé™¤äº†è¿­ä»£å™¨ä¸ä¼šç§»åŠ¨ï¼Œæ‰€ä»¥ä½ å¯ä»¥éšæ„ä½¿ç”¨å®ƒã€‚å®é™…ä¸Šï¼Œä½ å¯ä»¥æŠŠpeekableçœ‹æˆæ˜¯ "å¯åœæ­¢"çš„ï¼Œå› ä¸ºä½ å¯ä»¥æƒ³åœå¤šä¹…å°±åœå¤šä¹…ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯¹æ¯ä¸ªå…ƒç´ éƒ½ä½¿ç”¨<code>.peek()</code>ä¸‰æ¬¡ã€‚æˆ‘ä»¬å¯ä»¥æ°¸è¿œä½¿ç”¨<code>.peek()</code>ï¼Œç›´åˆ°æˆ‘ä»¬ä½¿ç”¨<code>.next()</code>ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let just_numbers = vec![1, 5, 100];
    let mut number_iter = just_numbers.iter().peekable(); // This actually creates a type of iterator called Peekable

    for _ in 0..3 {
        println!("I love the number {}", number_iter.peek().unwrap());
        println!("I really love the number {}", number_iter.peek().unwrap());
        println!("{} is such a nice number", number_iter.peek().unwrap());
        number_iter.next();
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">I love the number 1
I really love the number 1
1 is such a nice number
I love the number 5
I really love the number 5
5 is such a nice number
I love the number 100
I really love the number 100
100 is such a nice number
</code></pre>
<p>ä¸‹é¢æ˜¯å¦ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬ä½¿ç”¨<code>.peek()</code>å¯¹ä¸€ä¸ªå…ƒç´ è¿›è¡ŒåŒ¹é…ã€‚ä½¿ç”¨å®Œåï¼Œæˆ‘ä»¬è°ƒç”¨<code>.next()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let locations = vec![
        ("Nevis", 25),
        ("Taber", 8428),
        ("Markerville", 45),
        ("Cardston", 3585),
    ];
    let mut location_iter = locations.iter().peekable();
    while location_iter.peek().is_some() {
        match location_iter.peek() {
            Some((name, number)) if *number &lt; 100 =&gt; { // .peek() gives us a reference so we need *
                println!("Found a hamlet: {} with {} people", name, number)
            }
            Some((name, number)) =&gt; println!("Found a town: {} with {} people", name, number),
            None =&gt; break,
        }
        location_iter.next();
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Found a hamlet: Nevis with 25 people
Found a town: Taber with 8428 people
Found a hamlet: Markerville with 45 people
Found a town: Cardston with 3585 people
</code></pre>
<p>æœ€åï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬ä¹Ÿä½¿ç”¨<code>.match_indices()</code>ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ ¹æ®<code>&amp;str</code>ä¸­çš„ç©ºæ ¼æ•°ï¼Œå°†åå­—æ”¾å…¥<code>struct</code>ä¸­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Names {
    one_word: Vec&lt;String&gt;,
    two_words: Vec&lt;String&gt;,
    three_words: Vec&lt;String&gt;,
}

fn main() {
    let vec_of_names = vec![
        "Caesar",
        "Frodo Baggins",
        "Bilbo Baggins",
        "Jean-Luc Picard",
        "Data",
        "Rand Al'Thor",
        "Paul Atreides",
        "Barack Hussein Obama",
        "Bill Jefferson Clinton",
    ];

    let mut iter_of_names = vec_of_names.iter().peekable();

    let mut all_names = Names { // start an empty Names struct
        one_word: vec![],
        two_words: vec![],
        three_words: vec![],
    };

    while iter_of_names.peek().is_some() {
        let next_item = iter_of_names.next().unwrap(); // We can use .unwrap() because we know it is Some
        match next_item.match_indices(' ').collect::&lt;Vec&lt;_&gt;&gt;().len() { // Create a quick vec using .match_indices and check the length
            0 =&gt; all_names.one_word.push(next_item.to_string()),
            1 =&gt; all_names.two_words.push(next_item.to_string()),
            _ =&gt; all_names.three_words.push(next_item.to_string()),
        }
    }

    println!("{:?}", all_names);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">Names { one_word: ["Caesar", "Data"], two_words: ["Frodo Baggins", "Bilbo Baggins", "Jean-Luc Picard", "Rand Al\'Thor", "Paul Atreides"], three_words:
["Barack Hussein Obama", "Bill Jefferson Clinton"] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dbg-å®å’Œinspect"><a class="header" href="#dbg-å®å’Œinspect">dbg! å®å’Œ.inspect</a></h2>
<p><code>dbg!</code>æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å®ï¼Œå¯ä»¥å¿«é€Ÿæ‰“å°ä¿¡æ¯ã€‚å®ƒæ˜¯ <code>println!</code> çš„ä¸€ä¸ªå¾ˆå¥½çš„æ›¿ä»£å“ï¼Œå› ä¸ºå®ƒçš„è¾“å…¥é€Ÿåº¦æ›´å¿«ï¼Œæä¾›çš„ä¿¡æ¯æ›´å¤šã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_number = 8;
    dbg!(my_number);
}</code></pre></pre>
<p>è¿™æ ·å°±å¯ä»¥æ‰“å°å‡º<code>[src\main.rs:4] my_number = 8</code>ã€‚</p>
<p>ä½†å®é™…ä¸Šï¼Œä½ å¯ä»¥æŠŠ<code>dbg!</code>æ”¾åœ¨å…¶ä»–å¾ˆå¤šåœ°æ–¹ï¼Œç”šè‡³å¯ä»¥æŠŠä»£ç åŒ…åœ¨é‡Œé¢ã€‚æ¯”å¦‚çœ‹è¿™æ®µä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = 9;
    my_number += 10;

    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;();
}</code></pre></pre>
<p>è¿™æ®µä»£ç åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¯å˜æ•°å­—ï¼Œå¹¶æ”¹å˜äº†å®ƒã€‚ç„¶ååˆ›å»ºä¸€ä¸ªvecï¼Œå¹¶ä½¿ç”¨<code>iter</code>å’Œ<code>map</code>ä»¥åŠ<code>collect</code>åˆ›å»ºä¸€ä¸ªæ–°çš„vecã€‚åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å‡ ä¹å¯ä»¥æŠŠ<code>dbg!</code>æ”¾åœ¨ä»»ä½•åœ°æ–¹ã€‚<code>dbg!</code>é—®ç¼–è¯‘å™¨ï¼š"æ­¤åˆ»ä½ åœ¨åšä»€ä¹ˆï¼Ÿ"ï¼Œç„¶åå‘Šè¯‰ä½ :</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_number = dbg!(9);
    dbg!(my_number += 10);

    let new_vec = dbg!(vec![8, 9, 10]);

    let double_vec = dbg!(new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());

    dbg!(double_vec);
}</code></pre></pre>
<p>æ‰€ä»¥è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">[src\main.rs:3] 9 = 9
</code></pre>
<p>å’Œï¼š</p>
<pre><code class="language-text">[src\main.rs:4] my_number += 10 = ()
</code></pre>
<p>å’Œï¼š</p>
<pre><code class="language-text">[src\main.rs:6] vec![8, 9, 10] = [
    8,
    9,
    10,
]
</code></pre>
<p>è€Œè¿™ä¸ªï¼Œç”šè‡³å¯ä»¥æ˜¾ç¤ºå‡ºè¡¨è¾¾å¼çš„å€¼ã€‚</p>
<pre><code class="language-text">[src\main.rs:8] new_vec.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;() = [
    16,
    18,
    20,
]
</code></pre>
<p>å’Œï¼š</p>
<pre><code class="language-text">[src\main.rs:10] double_vec = [
    16,
    18,
    20,
]
</code></pre>
<p><code>.inspect</code> ä¸ <code>dbg!</code> æœ‰ç‚¹ç±»ä¼¼ï¼Œå°±åƒåœ¨è¿­ä»£å™¨ä¸­ä½¿ç”¨<code>map</code>ä¸€æ ·ä½¿ç”¨å®ƒã€‚å®ƒç»™äº†ä½ è¿­ä»£é¡¹ï¼Œä½ å¯ä»¥æ‰“å°å®ƒæˆ–è€…åšä»»ä½•ä½ æƒ³åšçš„äº‹æƒ…ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å†çœ‹çœ‹æˆ‘ä»¬çš„ <code>double_vec</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .map(|x| x * 2)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}</code></pre></pre>
<p>æˆ‘ä»¬æƒ³çŸ¥é“æ›´å¤šå…³äºä»£ç çš„ä¿¡æ¯ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨ä¸¤ä¸ªåœ°æ–¹æ·»åŠ <code>inspect()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .inspect(|first_item| println!("The item is: {}", first_item))
        .map(|x| x * 2)
        .inspect(|next_item| println!("Then it is: {}", next_item))
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">The item is: 8
Then it is: 16
The item is: 9
Then it is: 18
The item is: 10
Then it is: 20
</code></pre>
<p>è€Œä¸”å› ä¸º<code>.inspect</code>é‡‡å–çš„æ˜¯å°é—­å¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥éšæ„å†™ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 10];

    let double_vec = new_vec
        .iter()
        .inspect(|first_item| {
            println!("The item is: {}", first_item);
            match **first_item % 2 { // first item is a &amp;&amp;i32 so we use **
                0 =&gt; println!("It is even."),
                _ =&gt; println!("It is odd."),
            }
            println!("In binary it is {:b}.", first_item);
        })
        .map(|x| x * 2)
        .collect::&lt;Vec&lt;i32&gt;&gt;();
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">The item is: 8
It is even.
In binary it is 1000.
The item is: 9
It is odd.
In binary it is 1001.
The item is: 10
It is even.
In binary it is 1010.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="strçš„ç±»å‹"><a class="header" href="#strçš„ç±»å‹">&amp;strçš„ç±»å‹</a></h2>
<p><code>&amp;str</code>çš„ç±»å‹ä¸æ­¢ä¸€ç§ã€‚æˆ‘ä»¬æœ‰ã€‚</p>
<ul>
<li>å­—ç¬¦ä¸²ï¼š å½“ä½ å†™<code>let my_str = "I am a &amp;str"</code>çš„æ—¶å€™ï¼Œä½ å°±ä¼šäº§ç”Ÿè¿™äº›å­—ç¬¦ã€‚å®ƒä»¬åœ¨æ•´ä¸ªç¨‹åºä¸­æŒç»­å­˜åœ¨ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ç›´æ¥å†™è¿›äºŒè¿›åˆ¶ä¸­çš„ï¼Œå®ƒä»¬çš„ç±»å‹æ˜¯ <code>&amp;'static str</code>ã€‚<code>'</code>çš„æ„æ€æ˜¯å®ƒçš„ç”Ÿå‘½æœŸï¼Œå­—ç¬¦ä¸²å­—å…ƒæœ‰ä¸€ä¸ªå«<code>static</code>çš„ç”Ÿå‘½æœŸã€‚</li>
<li>å€Ÿç”¨strï¼šè¿™æ˜¯å¸¸è§„çš„ <code>&amp;str</code> å½¢å¼ï¼Œæ²¡æœ‰ <code>static</code> ç”Ÿå‘½æœŸã€‚å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ª<code>String</code>ï¼Œå¹¶å¾—åˆ°äº†å®ƒçš„å¼•ç”¨ï¼Œå½“ä½ éœ€è¦å®ƒæ—¶ï¼ŒRustä¼šæŠŠå®ƒè½¬æ¢ä¸º<code>&amp;str</code>ã€‚æ¯”å¦‚è¯´</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn prints_str(my_str: &amp;str) { // it can use &amp;String like a &amp;str
    println!("{}", my_str);
}

fn main() {
    let my_string = String::from("I am a string");
    prints_str(&amp;my_string); // we give prints_str a &amp;String
}</code></pre></pre>
<p>é‚£ä¹ˆä»€ä¹ˆæ˜¯lifetimeå‘¢ï¼Ÿæˆ‘ä»¬ç°åœ¨å°±æ¥äº†è§£ä¸€ä¸‹ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç”Ÿå‘½æœŸ"><a class="header" href="#ç”Ÿå‘½æœŸ">ç”Ÿå‘½æœŸ</a></h2>
<p>ç”Ÿå‘½æœŸçš„æ„æ€æ˜¯ "å˜é‡çš„ç”Ÿå‘½æœŸæœ‰å¤šé•¿"ã€‚ä½ åªéœ€è¦è€ƒè™‘å¼•ç”¨çš„ç”Ÿå‘½æœŸã€‚è¿™æ˜¯å› ä¸ºå¼•ç”¨çš„ç”Ÿå‘½æœŸä¸èƒ½æ¯”å®ƒä»¬æ¥è‡ªçš„å¯¹è±¡æ›´é•¿ã€‚ä¾‹å¦‚ï¼Œè¿™ä¸ªå‡½æ•°å°±ä¸èƒ½ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn returns_reference() -&gt; &amp;str {
    let my_string = String::from("I am a string");
    &amp;my_string // âš ï¸
}

fn main() {}</code></pre></pre>
<p>é—®é¢˜æ˜¯<code>my_string</code>åªå­˜åœ¨äº<code>returns_reference</code>ä¸­ã€‚æˆ‘ä»¬è¯•å›¾è¿”å› <code>&amp;my_string</code>ï¼Œä½†æ˜¯ <code>&amp;my_string</code> ä¸èƒ½æ²¡æœ‰ <code>my_string</code>ã€‚æ‰€ä»¥ç¼–è¯‘å™¨è¯´ä¸è¡Œã€‚</p>
<p>è¿™ä¸ªä»£ç ä¹Ÿä¸è¡Œã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;str {
    let my_string = String::from("I am a string");
    "I am a str" // âš ï¸
}

fn main() {
    let my_str = returns_str();
    println!("{}", my_str);
}</code></pre></pre>
<p>ä½†å‡ ä¹æ˜¯æˆåŠŸçš„ã€‚ç¼–è¯‘å™¨è¯´:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:6:21
  |
6 | fn returns_str() -&gt; &amp;str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
6 | fn returns_str() -&gt; &amp;'static str {
  |                     ^^^^^^^^
</code></pre>
<p><code>missing lifetime specifier</code>çš„æ„æ€æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦åŠ ä¸€ä¸ª<code>'</code>çš„ç”Ÿå‘½æœŸã€‚ç„¶åè¯´å®ƒ<code>contains a borrowed value, but there is no value for it to be borrowed from</code>ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ<code>I am a str</code>ä¸æ˜¯å€Ÿæ¥çš„ã€‚å®ƒå†™<code>&amp;'static str</code>å°±è¯´<code>consider using the 'static lifetime</code>ã€‚æ‰€ä»¥å®ƒè®¤ä¸ºæˆ‘ä»¬åº”è¯¥å°è¯•è¯´è¿™æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ–‡å­—ã€‚</p>
<p>ç°åœ¨å®ƒå·¥ä½œäº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn returns_str() -&gt; &amp;'static str {
    let my_string = String::from("I am a string");
    "I am a str"
}

fn main() {
    let my_str = returns_str();
    println!("{}", my_str);
}</code></pre></pre>
<p>è¿™æ˜¯å› ä¸ºæˆ‘ä»¬è¿”å›äº†ä¸€ä¸ª <code>&amp;str</code>ï¼Œç”Ÿå‘½æœŸä¸º <code>static</code>ã€‚åŒæ—¶ï¼Œ<code>my_string</code>åªèƒ½ä»¥<code>String</code>çš„å½¢å¼è¿”å›:æˆ‘ä»¬ä¸èƒ½è¿”å›å¯¹å®ƒçš„å¼•ç”¨ï¼Œå› ä¸ºå®ƒå°†åœ¨ä¸‹ä¸€è¡Œæ­»äº¡ã€‚</p>
<p>æ‰€ä»¥ç°åœ¨<code>fn returns_str() -&gt; &amp;'static str</code>å‘Šè¯‰Rustï¼Œ "åˆ«æ‹…å¿ƒï¼Œæˆ‘ä»¬åªä¼šè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢é‡". å­—ç¬¦ä¸²å­—é¢é‡åœ¨æ•´ä¸ªç¨‹åºä¸­éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œæ‰€ä»¥Rustå¾ˆé«˜å…´ã€‚ä½ ä¼šæ³¨æ„åˆ°ï¼Œè¿™ä¸æ³›å‹ç±»ä¼¼ã€‚å½“æˆ‘ä»¬å‘Šè¯‰ç¼–è¯‘å™¨ç±»ä¼¼ <code>&lt;T: Display&gt;</code> çš„ä¸œè¥¿æ—¶ï¼Œæˆ‘ä»¬æ‰¿è¯ºæˆ‘ä»¬å°†åªä½¿ç”¨å®ç°äº† <code>Display</code> çš„è¾“å…¥ã€‚ç”Ÿå‘½æœŸä¹Ÿç±»ä¼¼:æˆ‘ä»¬å¹¶æ²¡æœ‰æ”¹å˜ä»»ä½•å˜é‡çš„ç”Ÿå‘½æœŸã€‚æˆ‘ä»¬åªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨è¾“å…¥çš„ç”Ÿå‘½æœŸæ˜¯å¤šå°‘ã€‚</p>
<p>ä½†æ˜¯<code>'static</code>å¹¶ä¸æ˜¯å”¯ä¸€çš„ç”Ÿå‘½æœŸã€‚å®é™…ä¸Šï¼Œæ¯ä¸ªå˜é‡éƒ½æœ‰ä¸€ä¸ªç”Ÿå‘½æœŸï¼Œä½†é€šå¸¸æˆ‘ä»¬ä¸å¿…å†™å‡ºæ¥ã€‚ç¼–è¯‘å™¨å¾ˆèªæ˜ï¼Œä¸€èˆ¬éƒ½èƒ½è‡ªå·±ç®—å‡ºæ¥ã€‚åªæœ‰åœ¨ç¼–è¯‘å™¨ä¸çŸ¥é“çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰éœ€è¦å†™å‡ºç”Ÿå‘½æœŸã€‚</p>
<p>ä¸‹é¢æ˜¯å¦ä¸€ä¸ªç”Ÿå‘½æœŸçš„ä¾‹å­ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æƒ³åˆ›å»ºä¸€ä¸ª<code>City</code>ç»“æ„ï¼Œå¹¶ç»™å®ƒä¸€ä¸ª<code>&amp;str</code>çš„åå­—ã€‚æˆ‘ä»¬å¯èƒ½æƒ³è¿™æ ·åšï¼Œå› ä¸ºè¿™æ ·åšçš„æ€§èƒ½æ¯”ç”¨<code>String</code>å¿«ã€‚æ‰€ä»¥æˆ‘ä»¬è¿™æ ·å†™ï¼Œä½†è¿˜ä¸èƒ½ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: &amp;str, // âš ï¸
    date_founded: u32,
}

fn main() {
    let my_city = City {
        name: "Ichinomiya",
        date_founded: 1921,
    };
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:3:11
  |
3 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 | struct City&lt;'a&gt; {
3 |     name: &amp;'a str,
  |
</code></pre>
<p>Rust éœ€è¦ <code>&amp;str</code> çš„ç”Ÿå‘½æœŸï¼Œå› ä¸º <code>&amp;str</code> æ˜¯ä¸€ä¸ªå¼•ç”¨ã€‚å¦‚æœ<code>name</code>æŒ‡å‘çš„å€¼è¢«ä¸¢å¼ƒäº†ä¼šæ€æ ·ï¼Ÿé‚£å°±ä¸å®‰å…¨äº†ã€‚</p>
<p><code>'static</code>å‘¢ï¼Œèƒ½ç”¨å—ï¼Ÿæˆ‘ä»¬ä»¥å‰ç”¨è¿‡ã€‚æˆ‘ä»¬è¯•è¯•å§ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: &amp;'static str, // change &amp;str to &amp;'static str
    date_founded: u32,
}

fn main() {
    let my_city = City {
        name: "Ichinomiya",
        date_founded: 1921,
    };

    println!("{} was founded in {}", my_city.name, my_city.date_founded);
}</code></pre></pre>
<p>å¥½çš„ï¼Œè¿™å°±å¯ä»¥äº†ã€‚ä¹Ÿè®¸è¿™å°±æ˜¯ä½ æƒ³è¦çš„ç»“æ„ã€‚ä½†æ˜¯ï¼Œè¯·æ³¨æ„ï¼Œæˆ‘ä»¬åªèƒ½æ¥å— "å­—ç¬¦ä¸²å­—é¢é‡"ï¼Œæ‰€ä»¥ä¸èƒ½æ¥å—å¯¹å…¶ä»–ä¸œè¥¿çš„å¼•ç”¨ã€‚æ‰€ä»¥è¿™å°†æ— æ³•å·¥ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: &amp;'static str, // must live for the whole program
    date_founded: u32,
}

fn main() {
    let city_names = vec!["Ichinomiya".to_string(), "Kurume".to_string()]; // city_names does not live for the whole program

    let my_city = City {
        name: &amp;city_names[0], // âš ï¸ This is a &amp;str, but not a &amp;'static str. It is a reference to a value inside city_names
        date_founded: 1921,
    };

    println!("{} was founded in {}", my_city.name, my_city.date_founded);
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´:</p>
<pre><code class="language-text">error[E0597]: `city_names` does not live long enough
  --&gt; src\main.rs:12:16
   |
12 |         name: &amp;city_names[0],
   |                ^^^^^^^^^^
   |                |
   |                borrowed value does not live long enough
   |                requires that `city_names` is borrowed for `'static`
...
18 | }
   | - `city_names` dropped here while still borrowed
</code></pre>
<p>è¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå› ä¸ºæˆ‘ä»¬ç»™å®ƒçš„å¼•ç”¨å…¶å®å·²ç»å¤Ÿé•¿å¯¿äº†ã€‚ä½†æ˜¯æˆ‘ä»¬æ‰¿è¯ºåªç»™å®ƒä¸€ä¸ª<code>&amp;'static str</code>ï¼Œè¿™å°±æ˜¯é—®é¢˜æ‰€åœ¨ã€‚</p>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å°±è¯•è¯•ä¹‹å‰ç¼–è¯‘å™¨çš„å»ºè®®ã€‚å®ƒè¯´å°è¯•å†™<code>struct City&lt;'a&gt;</code>å’Œ<code>name: &amp;'a str</code>ã€‚è¿™å°±æ„å‘³ç€ï¼Œåªæœ‰å½“<code>name</code>æ´»åˆ°<code>City</code>ä¸€æ ·å¯¿å‘½çš„æƒ…å†µä¸‹ï¼Œå®ƒæ‰ä¼šæ¥å—<code>name</code>çš„å¼•ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'a&gt; { // City has lifetime 'a
    name: &amp;'a str, // and name also has lifetime 'a.
    date_founded: u32,
}

fn main() {
    let city_names = vec!["Ichinomiya".to_string(), "Kurume".to_string()];

    let my_city = City {
        name: &amp;city_names[0],
        date_founded: 1921,
    };

    println!("{} was founded in {}", my_city.name, my_city.date_founded);
}</code></pre></pre>
<p>å¦å¤–è®°ä½ï¼Œå¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥å†™ä»»ä½•ä¸œè¥¿æ¥ä»£æ›¿<code>'a</code>ã€‚è¿™ä¹Ÿå’Œæ³›å‹ç±»ä¼¼ï¼Œæˆ‘ä»¬å†™<code>T</code>å’Œ<code>U</code>ï¼Œä½†å®é™…ä¸Šå¯ä»¥å†™ä»»ä½•ä¸œè¥¿ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'city&gt; { // The lifetime is now called 'city
    name: &amp;'city str, // and name has the 'city lifetime
    date_founded: u32,
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥ä¸€èˆ¬éƒ½ä¼šå†™<code>'a, 'b, 'c</code>ç­‰ï¼Œå› ä¸ºè¿™æ ·å†™èµ·æ¥æ¯”è¾ƒå¿«ï¼Œä¹Ÿæ˜¯å¸¸ç”¨çš„å†™æ³•ã€‚ä½†å¦‚æœä½ æƒ³çš„è¯ï¼Œä½ å¯ä»¥éšæ—¶æ›´æ”¹ã€‚æœ‰ä¸€ä¸ªå¾ˆå¥½çš„å»ºè®®æ˜¯ï¼Œå¦‚æœä»£ç éå¸¸å¤æ‚ï¼ŒæŠŠç”Ÿå‘½æœŸæ”¹æˆä¸€ä¸ª "äººç±»å¯è¯»"çš„åå­—å¯ä»¥å¸®åŠ©ä½ é˜…è¯»ä»£ç ã€‚</p>
<p>æˆ‘ä»¬å†æ¥çœ‹çœ‹ä¸traitçš„æ¯”è¾ƒï¼Œå¯¹äºæ³›å‹ã€‚æ¯”å¦‚è¯´</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn prints&lt;T: Display&gt;(input: T) {
    println!("T is {}", input);
}

fn main() {}</code></pre></pre>
<p>å½“ä½ å†™<code>T: Display</code>çš„æ—¶å€™ï¼Œå®ƒçš„æ„æ€æ˜¯ "åªæœ‰å½“Tæœ‰Displayæ—¶ï¼Œæ‰å–T"ã€‚
è€Œä¸æ˜¯è¯´: "æˆ‘æŠŠDisplayç»™T".</p>
<p>å¯¹äºç”Ÿå‘½æœŸä¹Ÿæ˜¯å¦‚æ­¤ã€‚å½“ä½ åœ¨è¿™é‡Œå†™ 'a:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City&lt;'a&gt; {
    name: &amp;'a str,
    date_founded: u32,
}

fn main() {}</code></pre></pre>
<p>æ„æ€æ˜¯ "å¦‚æœ<code>name</code>çš„ç”Ÿå‘½æœŸè‡³å°‘ä¸<code>City</code>ä¸€æ ·é•¿ï¼Œæ‰æ¥å—<code>name</code>çš„è¾“å…¥"ã€‚
å®ƒçš„æ„æ€ä¸æ˜¯è¯´: "æˆ‘ä¼šè®©<code>name</code>çš„è¾“å…¥ä¸<code>City</code>ä¸€æ ·é•¿å¯¿"ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬å¯ä»¥äº†è§£ä¸€ä¸‹ä¹‹å‰çœ‹åˆ°çš„<code>&lt;'_&gt;</code>ã€‚è¿™è¢«ç§°ä¸º "åŒ¿åç”Ÿå‘½æœŸ"ï¼Œæ˜¯ä½¿ç”¨å¼•ç”¨çš„ä¸€ä¸ªæŒ‡æ ‡ã€‚ä¾‹å¦‚ï¼Œå½“ä½ åœ¨å®ç°ç»“æ„æ—¶ï¼ŒRustä¼šå‘ä½ å»ºè®®ä½¿ç”¨ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªå‡ ä¹å¯ä»¥å·¥ä½œçš„ç»“æ„ä½“ï¼Œä½†è¿˜ä¸èƒ½å·¥ä½œï¼š</p>
<pre><pre class="playground"><code class="language-rust">    // âš ï¸
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!("{} has {} hit points left!", self.name, self.hit_points);
    }
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥æˆ‘ä»¬å¯¹<code>struct</code>åšäº†æˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…:é¦–å…ˆæˆ‘ä»¬è¯´<code>name</code>æ¥è‡ªäºä¸€ä¸ª<code>&amp;str</code>ã€‚è¿™å°±æ„å‘³ç€æˆ‘ä»¬éœ€è¦lifetimeï¼Œæ‰€ä»¥æˆ‘ä»¬ç»™äº†å®ƒ<code>&lt;'a&gt;</code>ã€‚ç„¶åæˆ‘ä»¬å¿…é¡»å¯¹<code>struct</code>åšåŒæ ·çš„å¤„ç†ï¼Œä»¥è¯æ˜å®ƒä»¬è‡³å°‘å’Œè¿™ä¸ªç”Ÿå‘½æœŸä¸€æ ·é•¿ã€‚ä½†æ˜¯Rustå´å‘Šè¯‰æˆ‘ä»¬è¦è¿™æ ·åš:</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>å®ƒæƒ³è®©æˆ‘ä»¬åŠ ä¸Šé‚£ä¸ªåŒ¿åçš„ç”Ÿå‘½æœŸï¼Œä»¥è¡¨æ˜æœ‰ä¸€ä¸ªå¼•ç”¨è¢«ä½¿ç”¨ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬è¿™æ ·å†™ï¼Œå®ƒå°±ä¼šå¾ˆé«˜å…´ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!("{} has {} hit points left!", self.name, self.hit_points);
    }
}

fn main() {}</code></pre></pre>
<p>è¿™ä¸ªç”Ÿå‘½æœŸæ˜¯ä¸ºäº†è®©ä½ ä¸å¿…æ€»æ˜¯å†™è¯¸å¦‚<code>impl&lt;'a&gt; Adventurer&lt;'a&gt;</code>è¿™æ ·çš„ä¸œè¥¿ï¼Œå› ä¸ºç»“æ„å·²ç»æ˜¾ç¤ºäº†ç”Ÿå‘½æœŸã€‚</p>
<p>åœ¨Rustä¸­ï¼Œç”Ÿå‘½æœŸæ˜¯å¾ˆå›°éš¾çš„ï¼Œä½†è¿™é‡Œæœ‰ä¸€äº›æŠ€å·§å¯ä»¥é¿å…å¯¹å®ƒä»¬å¤ªè¿‡ç´§å¼ ã€‚</p>
<ul>
<li>ä½ å¯ä»¥ç»§ç»­ä½¿ç”¨è‡ªæœ‰ç±»å‹ï¼Œä½¿ç”¨å…‹éš†ç­‰ï¼Œå¦‚æœä½ æƒ³æš‚æ—¶é¿å…å®ƒä»¬ã€‚</li>
<li>å¾ˆå¤šæ—¶å€™ï¼Œå½“ç¼–è¯‘å™¨æƒ³è¦lifetimeçš„æ—¶å€™ï¼Œä½ åªè¦åœ¨è¿™é‡Œå’Œé‚£é‡Œå†™ä¸Š&lt;'a&gt;å°±å¯ä»¥äº†ã€‚è¿™åªæ˜¯ä¸€ç§ "åˆ«æ‹…å¿ƒï¼Œæˆ‘ä¸ä¼šç»™ä½ ä»»ä½•ä¸å¤Ÿé•¿å¯¿çš„ä¸œè¥¿"çš„è¯´æ³•ã€‚</li>
<li>ä½ å¯ä»¥æ¯æ¬¡åªæ¢ç´¢ä¸€ä¸‹ç”Ÿå‘½æœŸã€‚å†™ä¸€äº›æ‹¥æœ‰å€¼çš„ä»£ç ï¼Œç„¶åæŠŠä¸€ä¸ªä»£ç å˜æˆä¸€ä¸ªå¼•ç”¨ã€‚ç¼–è¯‘å™¨ä¼šå¼€å§‹æŠ±æ€¨ï¼Œä½†ä¹Ÿä¼šç»™å‡ºä¸€äº›å»ºè®®ã€‚å¦‚æœå®ƒå˜å¾—å¤ªå¤æ‚ï¼Œä½ å¯ä»¥æ’¤é”€å®ƒï¼Œä¸‹æ¬¡å†è¯•ã€‚</li>
</ul>
<p>è®©æˆ‘ä»¬ç”¨æˆ‘ä»¬çš„ä»£ç æ¥åšè¿™ä¸ªï¼Œçœ‹çœ‹ç¼–è¯‘å™¨æ€ä¹ˆè¯´ã€‚é¦–å…ˆæˆ‘ä»¬å›å»æŠŠç”Ÿå‘½æœŸæ‹¿å‡ºæ¥ï¼ŒåŒæ—¶å®ç°<code>Display</code>ã€‚<code>Display</code>å°±æ‰“å°<code>Adventurer</code>çš„åå­—ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
struct Adventurer {
    name: &amp;str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!("{} has {} hit points left!", self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, "{} has {} hit points.", self.name, self.hit_points)
        }
}

fn main() {}</code></pre></pre>
<p>ç¬¬ä¸€ä¸ªæŠ±æ€¨å°±æ˜¯è¿™ä¸ª:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src\main.rs:2:11
  |
2 |     name: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct Adventurer&lt;'a&gt; {
2 |     name: &amp;'a str,
  |
</code></pre>
<p>å®ƒå»ºè®®æ€ä¹ˆåš:åœ¨Adventureråé¢åŠ ä¸Š<code>&lt;'a&gt;</code>ï¼Œä»¥åŠ<code>&amp;'a str</code>ã€‚æ‰€ä»¥æˆ‘ä»¬å°±è¿™ä¹ˆåšã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!("{} has {} hit points left!", self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, "{} has {} hit points.", self.name, self.hit_points)
        }
}

fn main() {}</code></pre></pre>
<p>ç°åœ¨å®ƒå¯¹è¿™äº›éƒ¨åˆ†å¾ˆæ»¡æ„ï¼Œä½†å¯¹<code>impl</code>å—æ„Ÿåˆ°å¥‡æ€ªã€‚å®ƒå¸Œæœ›æˆ‘ä»¬æåˆ°å®ƒåœ¨ä½¿ç”¨å¼•ç”¨ã€‚</p>
<pre><code class="language-text">error[E0726]: implicit elided lifetime not allowed here
 --&gt; src\main.rs:6:6
  |
6 | impl Adventurer {
  |      ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`

error[E0726]: implicit elided lifetime not allowed here
  --&gt; src\main.rs:12:28
   |
12 | impl std::fmt::Display for Adventurer {
   |                            ^^^^^^^^^^- help: indicate the anonymous lifetime: `&lt;'_&gt;`
</code></pre>
<p>å¥½äº†ï¼Œæˆ‘ä»¬å°†è¿™äº›å†™è¿›å»......ç°åœ¨å®ƒå·¥ä½œäº†ï¼ç°åœ¨æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ª<code>Adventurer</code>ï¼Œç„¶åç”¨å®ƒåšä¸€äº›äº‹æƒ…:</p>
<pre><pre class="playground"><code class="language-rust">struct Adventurer&lt;'a&gt; {
    name: &amp;'a str,
    hit_points: u32,
}

impl Adventurer&lt;'_&gt; {
    fn take_damage(&amp;mut self) {
        self.hit_points -= 20;
        println!("{} has {} hit points left!", self.name, self.hit_points);
    }
}

impl std::fmt::Display for Adventurer&lt;'_&gt; {

        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, "{} has {} hit points.", self.name, self.hit_points)
        }
}

fn main() {
    let mut billy = Adventurer {
        name: "Billy",
        hit_points: 100_000,
    };
    println!("{}", billy);
    billy.take_damage();
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">Billy has 100000 hit points.
Billy has 99980 hit points left!
</code></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥çœ‹åˆ°ï¼Œlifetimeså¾€å¾€åªæ˜¯ç¼–è¯‘å™¨æƒ³è¦ç¡®å®šã€‚è€Œä¸”å®ƒé€šå¸¸å¾ˆèªæ˜ï¼Œå‡ ä¹å¯ä»¥çŒœåˆ°ä½ æƒ³è¦çš„ç”Ÿå‘½æœŸï¼Œåªéœ€è¦ä½ å‘Šè¯‰å®ƒï¼Œå®ƒå°±å¯ä»¥ç¡®å®šäº†ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å†…éƒ¨å¯å˜æ€§"><a class="header" href="#å†…éƒ¨å¯å˜æ€§">å†…éƒ¨å¯å˜æ€§</a></h2>
<h3 id="cell"><a class="header" href="#cell">Cell</a></h3>
<p><strong>å†…éƒ¨å¯å˜æ€§</strong>çš„æ„æ€æ˜¯åœ¨å†…éƒ¨æœ‰ä¸€ç‚¹å¯å˜æ€§ã€‚è¿˜è®°å¾—åœ¨Rustä¸­ï¼Œä½ éœ€è¦ç”¨<code>mut</code>æ¥æ”¹å˜ä¸€ä¸ªå˜é‡å—ï¼Ÿä¹Ÿæœ‰ä¸€äº›æ–¹æ³•å¯ä»¥ä¸ç”¨<code>mut</code>è¿™ä¸ªè¯æ¥æ”¹å˜å®ƒä»¬ã€‚è¿™æ˜¯å› ä¸ºRustæœ‰ä¸€äº›æ–¹æ³•å¯ä»¥è®©ä½ å®‰å…¨åœ°åœ¨ä¸€ä¸ªä¸å¯å˜çš„ç»“æ„é‡Œé¢æ”¹å˜å€¼ã€‚æ¯ä¸€ç§æ–¹æ³•éƒ½éµå¾ªä¸€äº›è§„åˆ™ï¼Œç¡®ä¿æ”¹å˜å€¼ä»ç„¶æ˜¯å®‰å…¨çš„ã€‚</p>
<p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘ä»¬ä¼šæƒ³è¦è¿™æ ·åš:æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªå«<code>PhoneModel</code>çš„ç»“æ„ä½“æœ‰å¾ˆå¤šå­—æ®µ:</p>
<pre><pre class="playground"><code class="language-rust">struct PhoneModel {
    company_name: String,
    model_name: String,
    screen_size: f32,
    memory: usize,
    date_issued: u32,
    on_sale: bool,
}

fn main() {
    let super_phone_3000 = PhoneModel {
        company_name: "YY Electronics".to_string(),
        model_name: "Super Phone 3000".to_string(),
        screen_size: 7.5,
        memory: 4_000_000,
        date_issued: 2020,
        on_sale: true,
    };

}</code></pre></pre>
<p><code>PhoneModel</code>ä¸­çš„å­—æ®µæœ€å¥½æ˜¯ä¸å¯å˜çš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›æ•°æ®æ”¹å˜ã€‚æ¯”å¦‚è¯´<code>date_issued</code>å’Œ<code>screen_size</code>æ°¸è¿œä¸ä¼šå˜ã€‚</p>
<p>ä½†æ˜¯é‡Œé¢æœ‰ä¸€ä¸ªå­—æ®µå«<code>on_sale</code>ã€‚ä¸€ä¸ªæ‰‹æœºå‹å·å…ˆæ˜¯ä¼šæœ‰é”€å”®(<code>true</code>)ï¼Œä½†æ˜¯åæ¥å…¬å¸ä¼šåœæ­¢é”€å”®ã€‚æˆ‘ä»¬èƒ½ä¸èƒ½åªè®©è¿™ä¸€ä¸ªå­—æ®µå¯å˜ï¼Ÿå› ä¸ºæˆ‘ä»¬ä¸æƒ³å†™<code>let mut super_phone_3000</code>ã€‚å¦‚æœæˆ‘ä»¬è¿™æ ·åšï¼Œé‚£ä¹ˆæ¯ä¸ªå­—æ®µéƒ½ä¼šå˜å¾—å¯å˜ã€‚</p>
<p>Rustæœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥è®©ä¸€äº›ä¸å¯å˜çš„ä¸œè¥¿é‡Œé¢æœ‰ä¸€äº›å®‰å…¨çš„å¯å˜æ€§ï¼Œæœ€ç®€å•çš„æ–¹æ³•å«åš<code>Cell</code>ã€‚é¦–å…ˆæˆ‘ä»¬ä½¿ç”¨<code>use std::cell::Cell</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ¯æ¬¡åªå†™<code>Cell</code>è€Œä¸æ˜¯<code>std::cell::Cell</code>ã€‚</p>
<p>ç„¶åæˆ‘ä»¬æŠŠ<code>on_sale: bool</code>æ”¹æˆ<code>on_sale: Cell&lt;bool&gt;</code>ã€‚ç°åœ¨å®ƒä¸æ˜¯ä¸€ä¸ªbool:å®ƒæ˜¯ä¸€ä¸ª<code>Cell</code>ï¼Œå®¹çº³äº†ä¸€ä¸ª<code>bool</code>ã€‚</p>
<p><code>Cell</code>æœ‰ä¸€ä¸ªå«åš<code>.set()</code>çš„æ–¹æ³•ï¼Œåœ¨è¿™é‡Œä½ å¯ä»¥æ”¹å˜å€¼ã€‚æˆ‘ä»¬ç”¨<code>.set()</code>æŠŠ<code>on_sale: true</code>æ”¹ä¸º<code>on_sale: Cell::new(true)</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::Cell;

struct PhoneModel {
    company_name: String,
    model_name: String,
    screen_size: f32,
    memory: usize,
    date_issued: u32,
    on_sale: Cell&lt;bool&gt;,
}

fn main() {
    let super_phone_3000 = PhoneModel {
        company_name: "YY Electronics".to_string(),
        model_name: "Super Phone 3000".to_string(),
        screen_size: 7.5,
        memory: 4_000_000,
        date_issued: 2020,
        on_sale: Cell::new(true),
    };

    // 10 years later, super_phone_3000 is not on sale anymore
    super_phone_3000.on_sale.set(false);
}</code></pre></pre>
<p><code>Cell</code> é€‚ç”¨äºæ‰€æœ‰ç±»å‹ï¼Œä½†å¯¹ç®€å•çš„ Copy ç±»å‹æ•ˆæœæœ€å¥½ï¼Œå› ä¸ºå®ƒç»™å‡ºçš„æ˜¯å€¼ï¼Œè€Œä¸æ˜¯å¼•ç”¨ã€‚<code>Cell</code>æœ‰ä¸€ä¸ªå«åš<code>get()</code>çš„æ–¹æ³•ï¼Œå®ƒåªå¯¹Copyç±»å‹æœ‰æ•ˆã€‚</p>
<p>å¦ä¸€ä¸ªå¯ä»¥ä½¿ç”¨çš„ç±»å‹æ˜¯ <code>RefCell</code>ã€‚</p>
<h3 id="refcell"><a class="header" href="#refcell">RefCell</a></h3>
<p><code>RefCell</code>æ˜¯å¦ä¸€ç§æ— éœ€å£°æ˜<code>mut</code>è€Œæ”¹å˜å€¼çš„æ–¹æ³•ã€‚å®ƒçš„æ„æ€æ˜¯ "å¼•ç”¨å•å…ƒæ ¼"ï¼Œå°±åƒ <code>Cell</code>ï¼Œä½†ä½¿ç”¨å¼•ç”¨è€Œä¸æ˜¯å‰¯æœ¬ã€‚</p>
<p>æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª <code>User</code> ç»“æ„ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä½ å¯ä»¥çœ‹åˆ°å®ƒä¸ <code>Cell</code> ç±»ä¼¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct User {
    id: u32,
    year_registered: u32,
    username: String,
    active: RefCell&lt;bool&gt;,
    // Many other fields
}

fn main() {
    let user_1 = User {
        id: 1,
        year_registered: 2020,
        username: "User 1".to_string(),
        active: RefCell::new(true),
    };

    println!("{:?}", user_1.active);
}</code></pre></pre>
<p>è¿™æ ·å°±å¯ä»¥æ‰“å°å‡º<code>RefCell { value: true }</code>ã€‚</p>
<p><code>RefCell</code>çš„æ–¹æ³•æœ‰å¾ˆå¤šã€‚å…¶ä¸­ä¸¤ç§æ˜¯<code>.borrow()</code>å’Œ<code>.borrow_mut()</code>ã€‚ä½¿ç”¨è¿™äº›æ–¹æ³•ï¼Œä½ å¯ä»¥åšä¸<code>&amp;</code>å’Œ<code>&amp;mut</code>ç›¸åŒçš„äº‹æƒ…ã€‚è§„åˆ™éƒ½æ˜¯ä¸€æ ·çš„:</p>
<ul>
<li>å¤šä¸ªä¸å¯å˜å€Ÿç”¨å¯ä»¥</li>
<li>ä¸€ä¸ªå¯å˜çš„å€Ÿç”¨å¯ä»¥</li>
<li>ä½†å¯å˜å’Œä¸å¯å˜å€Ÿç”¨åœ¨ä¸€èµ·æ˜¯ä¸è¡Œçš„</li>
</ul>
<p>æ‰€ä»¥æ”¹å˜<code>RefCell</code>ä¸­çš„å€¼æ˜¯éå¸¸å®¹æ˜“çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
user_1.active.replace(false);
println!("{:?}", user_1.active);
<span class="boring">}</span></code></pre></pre>
<p>è€Œä¸”è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æ–¹æ³•ï¼Œæ¯”å¦‚<code>replace_with</code>ä½¿ç”¨çš„æ˜¯é—­åŒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
let date = 2020;

user_1
    .active
    .replace_with(|_| if date &lt; 2000 { true } else { false });
println!("{:?}", user_1.active);
<span class="boring">}</span></code></pre></pre>
<p>ä½†æ˜¯ä½ è¦å°å¿ƒä½¿ç”¨<code>RefCell</code>ï¼Œå› ä¸ºå®ƒæ˜¯åœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨ã€‚è¿è¡Œæ—¶æ˜¯æŒ‡ç¨‹åºå®é™…è¿è¡Œçš„æ—¶å€™(ç¼–è¯‘å)ã€‚æ‰€ä»¥è¿™å°†ä¼šè¢«ç¼–è¯‘ï¼Œå³ä½¿å®ƒæ˜¯é”™è¯¯çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Debug)]
struct User {
    id: u32,
    year_registered: u32,
    username: String,
    active: RefCell&lt;bool&gt;,
    // Many other fields
}

fn main() {
    let user_1 = User {
        id: 1,
        year_registered: 2020,
        username: "User 1".to_string(),
        active: RefCell::new(true),
    };

    let borrow_one = user_1.active.borrow_mut(); // first mutable borrow - okay
    let borrow_two = user_1.active.borrow_mut(); // second mutable borrow - not okay
}</code></pre></pre>
<p>ä½†å¦‚æœä½ è¿è¡Œå®ƒï¼Œå®ƒå°±ä¼šç«‹å³å´©æºƒã€‚</p>
<pre><code class="language-text">thread 'main' panicked at 'already borrowed: BorrowMutError', C:\Users\mithr\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\src\libcore\cell.rs:877:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
error: process didn't exit successfully: `target\debug\rust_book.exe` (exit code: 101)
</code></pre>
<p><code>already borrowed: BorrowMutError</code>æ˜¯é‡è¦çš„éƒ¨åˆ†ã€‚æ‰€ä»¥å½“ä½ ä½¿ç”¨<code>RefCell</code>æ—¶ï¼Œå¥½ç¼–è¯‘<strong>å¹¶</strong>è¿è¡Œæ£€æŸ¥ã€‚</p>
<h3 id="mutex"><a class="header" href="#mutex">Mutex</a></h3>
<p><code>Mutex</code>æ˜¯å¦ä¸€ç§æ”¹å˜æ•°å€¼çš„æ–¹æ³•ï¼Œä¸éœ€è¦å£°æ˜<code>mut</code>ã€‚Mutexçš„æ„æ€æ˜¯<code>mutual exclusion</code>ï¼Œä¹Ÿå°±æ˜¯ "ä¸€æ¬¡åªèƒ½æ”¹ä¸€ä¸ª"ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ<code>Mutex</code>æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºå®ƒæ¯æ¬¡åªè®©ä¸€ä¸ªè¿›ç¨‹æ”¹å˜å®ƒã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œå®ƒä½¿ç”¨äº†<code>.lock()</code>ã€‚<code>Lock</code>å°±åƒä»é‡Œé¢é”ä¸Šä¸€æ‰‡é—¨ã€‚ä½ è¿›å…¥ä¸€ä¸ªæˆ¿é—´ï¼Œé”ä¸Šé—¨ï¼Œç°åœ¨ä½ å¯ä»¥åœ¨æˆ¿é—´é‡Œé¢æ”¹å˜ä¸œè¥¿ã€‚åˆ«äººä¸èƒ½è¿›æ¥é˜»æ­¢ä½ ï¼Œå› ä¸ºä½ æŠŠé—¨é”ä¸Šäº†ã€‚</p>
<p><code>Mutex</code>é€šè¿‡ä¾‹å­æ›´å®¹æ˜“ç†è§£:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5); // A new Mutex&lt;i32&gt;. We don't need to say mut
    let mut mutex_changer = my_mutex.lock().unwrap(); // mutex_changer is a MutexGuard
                                                     // It has to be mut because we will change it
                                                     // Now it has access to the Mutex
                                                     // Let's print my_mutex to see:

    println!("{:?}", my_mutex); // This prints "Mutex { data: &lt;locked&gt; }"
                                // So we can't access the data with my_mutex now,
                                // only with mutex_changer

    println!("{:?}", mutex_changer); // This prints 5. Let's change it to 6.

    *mutex_changer = 6; // mutex_changer is a MutexGuard&lt;i32&gt; so we use * to change the i32

    println!("{:?}", mutex_changer); // Now it says 6
}</code></pre></pre>
<p>ä½†æ˜¯<code>mutex_changer</code>åšå®Œåè¿˜æ˜¯æœ‰é”ã€‚æˆ‘ä»¬è¯¥å¦‚ä½•é˜»æ­¢å®ƒå‘¢ï¼Ÿ<code>Mutex</code>åœ¨<code>MutexGuard</code>è¶…å‡ºèŒƒå›´æ—¶å°±ä¼šè¢«è§£é”ã€‚"è¶…å‡ºèŒƒå›´"è¡¨ç¤ºè¯¥ä»£ç å—å·²ç»å®Œæˆã€‚æ¯”å¦‚è¯´:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    {
        let mut mutex_changer = my_mutex.lock().unwrap();
        *mutex_changer = 6;
    } // mutex_changer goes out of scope - now it is gone. It is not locked anymore

    println!("{:?}", my_mutex); // Now it says: Mutex { data: 6 }
}</code></pre></pre>
<p>å¦‚æœä½ ä¸æƒ³ä½¿ç”¨ä¸åŒçš„<code>{}</code>ä»£ç å—ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>std::mem::drop(mutex_changer)</code>ã€‚<code>std::mem::drop</code>çš„æ„æ€æ˜¯ "è®©è¿™ä¸ªè¶…å‡ºèŒƒå›´"ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap();
    *mutex_changer = 6;
    std::mem::drop(mutex_changer); // drop mutex_changer - it is gone now
                                   // and my_mutex is unlocked

    println!("{:?}", my_mutex); // Now it says: Mutex { data: 6 }
}</code></pre></pre>
<p>ä½ å¿…é¡»å°å¿ƒä½¿ç”¨ <code>Mutex</code>ï¼Œå› ä¸ºå¦‚æœå¦ä¸€ä¸ªå˜é‡è¯•å›¾ <code>lock</code>å®ƒï¼Œå®ƒä¼šç­‰å¾…ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap(); // mutex_changer has the lock
    let mut other_mutex_changer = my_mutex.lock().unwrap(); // other_mutex_changer wants the lock
                                                            // the program is waiting
                                                            // and waiting
                                                            // and will wait forever.

    println!("This will never print...");
}</code></pre></pre>
<p>è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯<code>try_lock()</code>ã€‚ç„¶åå®ƒä¼šè¯•ä¸€æ¬¡ï¼Œå¦‚æœæ²¡èƒ½é”ä¸Šå°±ä¼šæ”¾å¼ƒã€‚<code>try_lock().unwrap()</code>å°±ä¸è¦åšäº†ï¼Œå› ä¸ºå¦‚æœä¸æˆåŠŸå®ƒå°±ä¼šå´©æºƒã€‚<code>if let</code>æˆ–<code>match</code>æ¯”è¾ƒå¥½ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);
    let mut mutex_changer = my_mutex.lock().unwrap();
    let mut other_mutex_changer = my_mutex.try_lock(); // try to get the lock

    if let Ok(value) = other_mutex_changer {
        println!("The MutexGuard has: {}", value)
    } else {
        println!("Didn't get the lock")
    }
}</code></pre></pre>
<p>å¦å¤–ï¼Œä½ ä¸éœ€è¦åˆ›å»ºä¸€ä¸ªå˜é‡æ¥æ”¹å˜<code>Mutex</code>ã€‚ä½ å¯ä»¥ç›´æ¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);

    *my_mutex.lock().unwrap() = 6;

    println!("{:?}", my_mutex);
}</code></pre></pre>
<p><code>*my_mutex.lock().unwrap() = 6;</code>çš„æ„æ€æ˜¯ "è§£é”my_mutexå¹¶ä½¿å…¶æˆä¸º6"ã€‚æ²¡æœ‰ä»»ä½•å˜é‡æ¥ä¿å­˜å®ƒï¼Œæ‰€ä»¥ä½ ä¸éœ€è¦è°ƒç”¨ <code>std::mem::drop</code>ã€‚å¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥åš100æ¬¡--è¿™å¹¶ä¸é‡è¦ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let my_mutex = Mutex::new(5);

    for _ in 0..100 {
        *my_mutex.lock().unwrap() += 1; // locks and unlocks 100 times
    }

    println!("{:?}", my_mutex);
}</code></pre></pre>
<h3 id="rwlock"><a class="header" href="#rwlock">RwLock</a></h3>
<p><code>RwLock</code>çš„æ„æ€æ˜¯ "è¯»å†™é”"ã€‚å®ƒåƒ<code>Mutex</code>ï¼Œä½†ä¹Ÿåƒ<code>RefCell</code>ã€‚ä½ ç”¨<code>.write().unwrap()</code>ä»£æ›¿<code>.lock().unwrap()</code>æ¥æ”¹å˜å®ƒã€‚ä½†ä½ ä¹Ÿå¯ä»¥ç”¨<code>.read().unwrap()</code>æ¥è·å¾—è¯»æƒé™ã€‚å®ƒå’Œ<code>RefCell</code>ä¸€æ ·ï¼Œéµå¾ªè¿™äº›è§„åˆ™:</p>
<ul>
<li>å¾ˆå¤š<code>.read()</code>å˜é‡å¯ä»¥</li>
<li>ä¸€ä¸ª<code>.write()</code>å˜é‡å¯ä»¥</li>
<li>ä½†å¤šä¸ª<code>.write()</code>æˆ–<code>.read()</code>ä¸<code>.write()</code>ä¸€èµ·æ˜¯ä¸è¡Œçš„</li>
</ul>
<p>å¦‚æœåœ¨æ— æ³•è®¿é—®çš„æƒ…å†µä¸‹å°è¯•<code>.write()</code>ï¼Œç¨‹åºå°†æ°¸è¿œè¿è¡Œã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap(); // one .read() is fine
    let read2 = my_rwlock.read().unwrap(); // two .read()s is also fine

    println!("{:?}, {:?}", read1, read2);

    let write1 = my_rwlock.write().unwrap(); // uh oh, now the program will wait forever
}</code></pre></pre>
<p>æ‰€ä»¥æˆ‘ä»¬ç”¨<code>std::mem::drop</code>ï¼Œå°±åƒç”¨<code>Mutex</code>ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;
use std::mem::drop; // We will use drop() many times

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap();
    let read2 = my_rwlock.read().unwrap();

    println!("{:?}, {:?}", read1, read2);

    drop(read1);
    drop(read2); // we dropped both, so we can use .write() now

    let mut write1 = my_rwlock.write().unwrap();
    *write1 = 6;
    drop(write1);
    println!("{:?}", my_rwlock);
}</code></pre></pre>
<p>è€Œä¸”ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨<code>try_read()</code>å’Œ<code>try_write()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::RwLock;

fn main() {
    let my_rwlock = RwLock::new(5);

    let read1 = my_rwlock.read().unwrap();
    let read2 = my_rwlock.read().unwrap();

    if let Ok(mut number) = my_rwlock.try_write() {
        *number += 10;
        println!("Now the number is {}", number);
    } else {
        println!("Couldn't get write access, sorry!")
    };
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cow"><a class="header" href="#cow">Cow</a></h2>
<p>Cowæ˜¯ä¸€ä¸ªéå¸¸æ–¹ä¾¿çš„æšä¸¾ã€‚å®ƒçš„æ„æ€æ˜¯ "å†™æ—¶å…‹éš†"ï¼Œå¦‚æœä½ ä¸éœ€è¦<code>String</code>ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ª<code>&amp;str</code>ï¼Œå¦‚æœä½ éœ€è¦ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ª<code>String</code>ã€‚(å®ƒä¹Ÿå¯ä»¥å¯¹æ•°ç»„ä¸Vecç­‰åšåŒæ ·çš„å¤„ç†)ã€‚</p>
<p>ä¸ºäº†ç†è§£å®ƒï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹ç­¾åã€‚å®ƒè¯´</p>
<pre><pre class="playground"><code class="language-rust">pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
 {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}

fn main() {}</code></pre></pre>
<p>ä½ é©¬ä¸Šå°±çŸ¥é“ï¼Œ<code>'a</code>æ„å‘³ç€å®ƒå¯ä»¥å’Œå¼•ç”¨ä¸€èµ·å·¥ä½œã€‚<code>ToOwned</code>çš„ç‰¹æ€§æ„å‘³ç€å®ƒæ˜¯ä¸€ä¸ªå¯ä»¥å˜æˆæ‹¥æœ‰ç±»å‹çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œ<code>str</code>é€šå¸¸æ˜¯ä¸€ä¸ªå¼•ç”¨(<code>&amp;str</code>)ï¼Œä½ å¯ä»¥æŠŠå®ƒå˜æˆä¸€ä¸ªæ‹¥æœ‰çš„<code>String</code>ã€‚</p>
<p>æ¥ä¸‹æ¥æ˜¯<code>?Sized</code>ã€‚è¿™æ„å‘³ç€ "ä¹Ÿè®¸æ˜¯Sizedï¼Œä½†ä¹Ÿè®¸ä¸æ˜¯"ã€‚Rustä¸­å‡ ä¹æ¯ä¸ªç±»å‹éƒ½æ˜¯Sizedçš„ï¼Œä½†åƒ<code>str</code>è¿™æ ·çš„ç±»å‹å´ä¸æ˜¯ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ª <code>&amp;</code> æ¥ä»£æ›¿ <code>str</code>ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸çŸ¥é“å¤§å°ã€‚æ‰€ä»¥ï¼Œå¦‚æœä½ æƒ³è¦ä¸€ä¸ªå¯ä»¥ä½¿ç”¨ <code>str</code> è¿™æ ·çš„traitï¼Œä½ å¯ä»¥æ·»åŠ  <code>?Sized.</code></p>
<p>æ¥ä¸‹æ¥æ˜¯<code>enum</code>çš„å˜ç§ã€‚å®ƒä»¬æ˜¯ <code>Borrowed</code> å’Œ <code>Owned</code>ã€‚</p>
<p>æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æœ‰ä¸€ä¸ªè¿”å› <code>Cow&lt;'static, str&gt;</code> çš„å‡½æ•°ã€‚å¦‚æœä½ å‘Šè¯‰å‡½æ•°è¿”å›<code>"My message".into()</code>ï¼Œå®ƒå°±ä¼šæŸ¥çœ‹ç±»å‹:"My message"æ˜¯<code>str</code>. è¿™æ˜¯ä¸€ä¸ª<code>Borrowed</code>çš„ç±»å‹ï¼Œæ‰€ä»¥å®ƒé€‰æ‹©<code>Borrowed(&amp;'a B)</code>ã€‚æ‰€ä»¥å®ƒå°±å˜æˆäº†<code>Cow::Borrowed(&amp;'static str)</code>ã€‚</p>
<p>è€Œå¦‚æœä½ ç»™å®ƒä¸€ä¸ª<code>format!("{}", "My message").into()</code>ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šæŸ¥çœ‹ç±»å‹ã€‚è¿™æ¬¡æ˜¯ä¸€ä¸ª<code>String</code>ï¼Œå› ä¸º<code>format!</code>åˆ›å»ºäº†<code>String</code>ã€‚æ‰€ä»¥è¿™æ¬¡ä¼šé€‰æ‹© "Owned"ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªæµ‹è¯•<code>Cow</code>çš„ä¾‹å­ã€‚æˆ‘ä»¬å°†æŠŠä¸€ä¸ªæ•°å­—æ”¾å…¥ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œè¿”å›ä¸€ä¸ª<code>Cow&lt;'static, str&gt;</code>ã€‚æ ¹æ®è¿™ä¸ªæ•°å­—ï¼Œå®ƒä¼šåˆ›å»ºä¸€ä¸ª<code>&amp;str</code>æˆ–<code>String</code>ã€‚ç„¶åå®ƒä½¿ç”¨<code>.into()</code>å°†å…¶å˜æˆ<code>Cow</code>ã€‚è¿™æ ·åšçš„æ—¶å€™ï¼Œå®ƒå°±ä¼šé€‰æ‹©<code>Cow::Borrowed</code>æˆ–è€…<code>Cow::Owned</code>ã€‚é‚£æˆ‘ä»¬å°±åŒ¹é…ä¸€ä¸‹ï¼Œçœ‹çœ‹å®ƒé€‰çš„æ˜¯å“ªä¸€ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::borrow::Cow;

fn modulo_3(input: u8) -&gt; Cow&lt;'static, str&gt; {
    match input % 3 {
        0 =&gt; "Remainder is 0".into(),
        1 =&gt; "Remainder is 1".into(),
        remainder =&gt; format!("Remainder is {}", remainder).into(),
    }
}

fn main() {
    for number in 1..=6 {
        match modulo_3(number) {
            Cow::Borrowed(message) =&gt; println!("{} went in. The Cow is borrowed with this message: {}", number, message),
            Cow::Owned(message) =&gt; println!("{} went in. The Cow is owned with this message: {}", number, message),
        }
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">1 went in. The Cow is borrowed with this message: Remainder is 1
2 went in. The Cow is owned with this message: Remainder is 2
3 went in. The Cow is borrowed with this message: Remainder is 0
4 went in. The Cow is borrowed with this message: Remainder is 1
5 went in. The Cow is owned with this message: Remainder is 2
6 went in. The Cow is borrowed with this message: Remainder is 0
</code></pre>
<p><code>Cow</code>è¿˜æœ‰ä¸€äº›å…¶ä»–çš„æ–¹æ³•ï¼Œæ¯”å¦‚<code>into_owned</code> æˆ–è€… <code>into_borrowed</code>ï¼Œè¿™æ ·å¦‚æœä½ éœ€è¦çš„è¯ï¼Œä½ å¯ä»¥æ”¹å˜å®ƒã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç±»å‹åˆ«å"><a class="header" href="#ç±»å‹åˆ«å">ç±»å‹åˆ«å</a></h2>
<p>ç±»å‹åˆ«åçš„æ„æ€æ˜¯ "ç»™æŸä¸ªç±»å‹ä¸€ä¸ªæ–°çš„åå­—"ã€‚ç±»å‹åˆ«åéå¸¸ç®€å•ã€‚é€šå¸¸ï¼Œå½“æ‚¨æœ‰ä¸€ä¸ªå¾ˆé•¿çš„ç±»å‹ï¼Œè€Œåˆä¸æƒ³æ¯æ¬¡éƒ½å†™å®ƒæ—¶ï¼Œæ‚¨å°±ä¼šä½¿ç”¨å®ƒä»¬ã€‚å½“æ‚¨æƒ³ç»™ä¸€ä¸ªç±»å‹èµ·ä¸€ä¸ªæ›´å¥½çš„åå­—ï¼Œä¾¿äºè®°å¿†æ—¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å®ƒã€‚ä¸‹é¢æ˜¯ä¸¤ä¸ªç±»å‹åˆ«åçš„ä¾‹å­ã€‚</p>
<p>è¿™é‡Œæ˜¯ä¸€ä¸ªä¸éš¾çš„ç±»å‹ï¼Œä½†æ˜¯ä½ æƒ³è®©ä½ çš„ä»£ç æ›´å®¹æ˜“è¢«å…¶ä»–äºº(æˆ–è€…ä½ )ç†è§£ã€‚</p>
<pre><pre class="playground"><code class="language-rust">type CharacterVec = Vec&lt;char&gt;;

fn main() {}</code></pre></pre>
<p>è¿™æ˜¯ä¸€ç§éå¸¸éš¾è¯»çš„ç±»å‹:</p>
<pre><pre class="playground"><code class="language-rust">// this return type is extremely long
fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; std::iter::Take&lt;std::iter::Skip&lt;std::slice::Iter&lt;'a, char&gt;&gt;&gt; {
    input.iter().skip(4).take(5)
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥æ”¹æˆè¿™æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">type SkipFourTakeFive&lt;'a&gt; = std::iter::Take&lt;std::iter::Skip&lt;std::slice::Iter&lt;'a, char&gt;&gt;&gt;;

fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; SkipFourTakeFive {
    input.iter().skip(4).take(5)
}

fn main() {}</code></pre></pre>
<p>å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥å¯¼å…¥å…ƒç´ ï¼Œè®©ç±»å‹æ›´çŸ­:</p>
<pre><pre class="playground"><code class="language-rust">use std::iter::{Take, Skip};
use std::slice::Iter;

fn returns&lt;'a&gt;(input: &amp;'a Vec&lt;char&gt;) -&gt; Take&lt;Skip&lt;Iter&lt;'a, char&gt;&gt;&gt; {
    input.iter().skip(4).take(5)
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„å–œå¥½æ¥å†³å®šåœ¨ä½ çš„ä»£ç ä¸­ä»€ä¹ˆæ˜¯æœ€å¥½çœ‹çš„ã€‚</p>
<p>è¯·æ³¨æ„ï¼Œè¿™å¹¶æ²¡æœ‰åˆ›å»ºä¸€ä¸ªå®é™…çš„æ–°ç±»å‹ã€‚å®ƒåªæ˜¯ä¸€ä¸ªä»£æ›¿ç°æœ‰ç±»å‹çš„åç§°ã€‚æ‰€ä»¥å¦‚æœä½ å†™äº† <code>type File = String;</code>ï¼Œç¼–è¯‘å™¨åªä¼šçœ‹åˆ° <code>String</code>ã€‚æ‰€ä»¥è¿™å°†æ‰“å°å‡º <code>true</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">type File = String;

fn main() {
    let my_file = File::from("I am file contents");
    let my_string = String::from("I am file contents");
    println!("{}", my_file == my_string);
}</code></pre></pre>
<p>é‚£ä¹ˆå¦‚æœä½ æƒ³è¦ä¸€ä¸ªå®é™…çš„æ–°ç±»å‹å‘¢ï¼Ÿ</p>
<p>å¦‚æœä½ æƒ³è¦ä¸€ä¸ªæ–°çš„æ–‡ä»¶ç±»å‹ï¼Œè€Œç¼–è¯‘å™¨çœ‹åˆ°çš„æ˜¯<code>File</code>ï¼Œä½ å¯ä»¥æŠŠå®ƒæ”¾åœ¨ä¸€ä¸ªç»“æ„ä¸­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct File(String); // File is a wrapper around String

fn main() {
    let my_file = File(String::from("I am file contents"));
    let my_string = String::from("I am file contents");
}</code></pre></pre>
<p>ç°åœ¨è¿™æ ·å°±ä¸è¡Œäº†ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸¤ç§ä¸åŒçš„ç±»å‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct File(String); // File is a wrapper around String

fn main() {
    let my_file = File(String::from("I am file contents"));
    let my_string = String::from("I am file contents");
    println!("{}", my_file == my_string);  // âš ï¸ cannot compare File with String
}</code></pre></pre>
<p>å¦‚æœä½ æƒ³æ¯”è¾ƒé‡Œé¢çš„Stringï¼Œå¯ä»¥ç”¨my_file.0:</p>
<pre><pre class="playground"><code class="language-rust">struct File(String);

fn main() {
    let my_file = File(String::from("I am file contents"));
    let my_string = String::from("I am file contents");
    println!("{}", my_file.0 == my_string); // my_file.0 is a String, so this prints true
}</code></pre></pre>
<h3 id="åœ¨å‡½æ•°ä¸­å¯¼å…¥å’Œé‡å‘½å"><a class="header" href="#åœ¨å‡½æ•°ä¸­å¯¼å…¥å’Œé‡å‘½å">åœ¨å‡½æ•°ä¸­å¯¼å…¥å’Œé‡å‘½å</a></h3>
<p>é€šå¸¸ä½ ä¼šåœ¨ç¨‹åºçš„é¡¶éƒ¨å†™ä¸Š<code>use</code>ï¼Œåƒè¿™æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::{Cell, RefCell};

fn main() {}</code></pre></pre>
<p>ä½†æˆ‘ä»¬çœ‹åˆ°ï¼Œä½ å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹è¿™æ ·åšï¼Œç‰¹åˆ«æ˜¯åœ¨å‡½æ•°ä¸­ä½¿ç”¨åç§°è¾ƒé•¿çš„enumã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">enum MapDirection {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

fn main() {}

fn give_direction(direction: &amp;MapDirection) {
    match direction {
        MapDirection::North =&gt; println!("You are heading north."),
        MapDirection::NorthEast =&gt; println!("You are heading northeast."),
        // So much more left to type...
        // âš ï¸ because we didn't write every possible variant
    }
}</code></pre></pre>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬è¦åœ¨å‡½æ•°é‡Œé¢å¯¼å…¥MapDirectionã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å‡½æ•°é‡Œé¢ä½ å¯ä»¥ç›´æ¥å†™<code>North</code>ç­‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum MapDirection {
    North,
    NorthEast,
    East,
    SouthEast,
    South,
    SouthWest,
    West,
    NorthWest,
}

fn main() {}

fn give_direction(direction: &amp;MapDirection) {
    use MapDirection::*; // Import everything in MapDirection
    let m = "You are heading";

    match direction {
        North =&gt; println!("{} north.", m),
        NorthEast =&gt; println!("{} northeast.", m),
        // This is a bit better
        // âš ï¸
    }
}</code></pre></pre>
<p>æˆ‘ä»¬å·²ç»çœ‹åˆ°<code>::*</code>çš„æ„æ€æ˜¯ "å¯¼å…¥::ä¹‹åçš„æ‰€æœ‰å†…å®¹"ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™æ„å‘³ç€<code>North</code>ï¼Œ<code>NorthEast</code>......ä¸€ç›´åˆ°<code>NorthWest</code>ã€‚å½“ä½ å¯¼å…¥åˆ«äººçš„ä»£ç æ—¶ï¼Œä½ ä¹Ÿå¯ä»¥è¿™æ ·åšï¼Œä½†å¦‚æœä»£ç éå¸¸å¤§ï¼Œä½ å¯èƒ½ä¼šæœ‰é—®é¢˜ã€‚å¦‚æœå®ƒæœ‰ä¸€äº›å…ƒç´ å’Œä½ çš„ä»£ç æ˜¯ä¸€æ ·çš„å‘¢ï¼Ÿæ‰€ä»¥ä¸€èˆ¬æƒ…å†µä¸‹æœ€å¥½ä¸è¦ä¸€ç›´ä½¿ç”¨<code>::*</code>ï¼Œé™¤éä½ æœ‰æŠŠæ¡ã€‚å¾ˆå¤šæ—¶å€™ä½ åœ¨åˆ«äººçš„ä»£ç é‡Œçœ‹åˆ°ä¸€ä¸ªå«<code>prelude</code>çš„éƒ¨åˆ†ï¼Œé‡Œé¢æœ‰ä½ å¯èƒ½éœ€è¦çš„æ‰€æœ‰ä¸»è¦å…ƒç´ ã€‚é‚£ä¹ˆä½ é€šå¸¸ä¼šè¿™æ ·ä½¿ç”¨:<code>name::prelude::*</code>ã€‚ æˆ‘ä»¬å°†åœ¨ <code>modules</code> å’Œ <code>crates</code> çš„ç« èŠ‚ä¸­æ›´å¤šåœ°è®¨è®ºè¿™ä¸ªé—®é¢˜ã€‚</p>
<p>æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ <code>as</code> æ¥æ›´æ”¹åç§°ã€‚ä¾‹å¦‚ï¼Œä¹Ÿè®¸ä½ æ­£åœ¨ä½¿ç”¨åˆ«äººçš„ä»£ç ï¼Œè€Œä½ ä¸èƒ½æ”¹å˜æšä¸¾ä¸­çš„åç§°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">enum FileState {
    CannotAccessFile,
    FileOpenedAndReady,
    NoSuchFileExists,
    SimilarFileNameInNextDirectory,
}

fn main() {}</code></pre></pre>
<p>é‚£ä¹ˆä½ å°±å¯ä»¥</p>
<ol>
<li>å¯¼å…¥æ‰€æœ‰çš„ä¸œè¥¿</li>
<li>æ›´æ”¹åç§°</li>
</ol>
<pre><pre class="playground"><code class="language-rust">enum FileState {
    CannotAccessFile,
    FileOpenedAndReady,
    NoSuchFileExists,
    SimilarFileNameInNextDirectory,
}

fn give_filestate(input: &amp;FileState) {
    use FileState::{
        CannotAccessFile as NoAccess,
        FileOpenedAndReady as Good,
        NoSuchFileExists as NoFile,
        SimilarFileNameInNextDirectory as OtherDirectory
    };
    match input {
        NoAccess =&gt; println!("Can't access file."),
        Good =&gt; println!("Here is your file"),
        NoFile =&gt; println!("Sorry, there is no file by that name."),
        OtherDirectory =&gt; println!("Please check the other directory."),
    }
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥ç°åœ¨ä½ å¯ä»¥å†™<code>OtherDirectory</code>è€Œä¸æ˜¯<code>FileState::SimilarFileNameInNextDirectory</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="todoå®"><a class="header" href="#todoå®">todo!å®</a></h2>
<p>æœ‰æ—¶ä½ æƒ³ç²—ç•¥å†™ç‚¹å†™ä»£ç å¸®åŠ©ä½ æƒ³è±¡ä½ çš„é¡¹ç›®ã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸ªç®€å•çš„é¡¹ç›®ï¼Œç”¨ä¹¦ç±åšä¸€äº›äº‹æƒ…ã€‚ä¸‹é¢æ˜¯ä½ å†™çš„æ—¶å€™çš„æƒ³æ³•:</p>
<pre><pre class="playground"><code class="language-rust">struct Book {} // Okay, first I need a book struct.
               // Nothing in there yet - will add later

enum BookType { // A book can be hardcover or softcover, so add an enum
    HardCover,
    SoftCover,
}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {} // âš ï¸ get_book should take a &amp;Book and return an Option&lt;String&gt;

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {} // delete_book should take a Book and return a Result...
                                                    // TODO: impl block and make these functions methods...
fn check_book_type(book_type: &amp;BookType) { // Let's make sure the match statement works
    match book_type {
        BookType::HardCover =&gt; println!("It's hardcover"),
        BookType::SoftCover =&gt; println!("It's softcover"),
    }
}

fn main() {
    let book_type = BookType::HardCover;
    check_book_type(&amp;book_type); // Okay, let's check this function!
}</code></pre></pre>
<p>ä½†Rustå¯¹<code>get_book</code>å’Œ<code>delete_book</code>ä¸æ»¡æ„ã€‚å®ƒè¯´</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src\main.rs:32:29
   |
32 | fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {}
   |    --------                 ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::option::Option&lt;std::string::String&gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&gt; src\main.rs:34:31
   |
34 | fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {}
   |    -----------                ^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::result::Result&lt;(), std::string::String&gt;`
           found unit type `()`
</code></pre>
<p>ä½†æ˜¯ä½ ç°åœ¨ä¸å…³å¿ƒ<code>get_book</code>å’Œ<code>delete_book</code>ã€‚è¿™æ—¶ä½ å¯ä»¥ä½¿ç”¨<code>todo!()</code>ã€‚å¦‚æœä½ æŠŠè¿™ä¸ªåŠ åˆ°å‡½æ•°ä¸­ï¼ŒRustä¸ä¼šæŠ±æ€¨ï¼Œè€Œä¸”ä¼šç¼–è¯‘ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Book {}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {
    todo!() // todo means "I will do it later, please be quiet"
}

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {
    todo!()
}

fn main() {}</code></pre></pre>
<p>æ‰€ä»¥ç°åœ¨ä»£ç ç¼–è¯‘ï¼Œä½ å¯ä»¥çœ‹åˆ°<code>check_book_type</code>çš„ç»“æœ:<code>It's hardcover</code>ã€‚</p>
<p>ä½†æ˜¯è¦å°å¿ƒï¼Œå› ä¸ºå®ƒåªæ˜¯ç¼–è¯‘--ä½ ä¸èƒ½ä½¿ç”¨å‡½æ•°ã€‚å¦‚æœä½ è°ƒç”¨é‡Œé¢æœ‰<code>todo!()</code>çš„å‡½æ•°ï¼Œå®ƒå°±ä¼šå´©æºƒã€‚</p>
<p>å¦å¤–ï¼Œ<code>todo!()</code>å‡½æ•°ä»ç„¶éœ€è¦çœŸå®çš„è¾“å…¥å’Œè¾“å‡ºç±»å‹ã€‚å¦‚æœä½ åªå†™è¿™ä¸ªï¼Œå®ƒå°†æ— æ³•ç¼–è¯‘ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Book {}

fn get_book(book: &amp;Book) -&gt; WorldsBestType { // âš ï¸
    todo!()
}

fn main() {}</code></pre></pre>
<p>å®ƒä¼šè¯´</p>
<pre><code class="language-text">error[E0412]: cannot find type `WorldsBestType` in this scope
  --&gt; src\main.rs:32:29
   |
32 | fn get_book(book: &amp;Book) -&gt; WorldsBestType {
   |                             ^^^^^^^^^^^^^^ not found in this scope
</code></pre>
<p><code>todo!()</code>å…¶å®å’Œå¦ä¸€ä¸ªå®ä¸€æ ·ï¼š<code>unimplemented!()</code>ã€‚ç¨‹åºå‘˜ä»¬ç»å¸¸ä½¿ç”¨ <code>unimplemented!()</code>ï¼Œä½†æ‰“å­—æ—¶å¤ªé•¿äº†ï¼Œæ‰€ä»¥ä»–ä»¬åˆ›å»ºäº† <code>todo!()</code>ï¼Œå®ƒæ¯”è¾ƒçŸ­ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rc"><a class="header" href="#rc">Rc</a></h2>
<p>Rcçš„æ„æ€æ˜¯ "reference counter"(å¼•ç”¨è®¡æ•°å™¨)ã€‚ä½ çŸ¥é“åœ¨Rustä¸­ï¼Œæ¯ä¸ªå˜é‡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¿™ä¸ªä¸èƒ½å·¥ä½œçš„åŸå› :</p>
<pre><pre class="playground"><code class="language-rust">fn takes_a_string(input: String) {
    println!("It is: {}", input)
}

fn also_takes_a_string(input: String) {
    println!("It is: {}", input)
}

fn main() {
    let user_name = String::from("User MacUserson");

    takes_a_string(user_name);
    also_takes_a_string(user_name); // âš ï¸
}</code></pre></pre>
<p><code>takes_a_string</code>å–äº†<code>user_name</code>ä¹‹åï¼Œä½ å°±ä¸èƒ½å†ä½¿ç”¨äº†ã€‚è¿™é‡Œæ²¡æœ‰é—®é¢˜:ä½ å¯ä»¥ç›´æ¥ç»™å®ƒ<code>user_name.clone()</code>ã€‚ä½†æœ‰æ—¶ä¸€ä¸ªå˜é‡æ˜¯ä¸€ä¸ªç»“æ„çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿè®¸ä½ ä¸èƒ½å…‹éš†è¿™ä¸ªç»“æ„ï¼›æˆ–è€…<code>String</code>çœŸçš„å¾ˆé•¿ï¼Œä½ ä¸æƒ³å…‹éš†å®ƒã€‚è¿™äº›éƒ½æ˜¯<code>Rc</code>çš„ä¸€äº›åŸå› ï¼Œå®ƒè®©ä½ æ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…ã€‚<code>Rc</code>å°±åƒä¸€ä¸ªä¼˜ç§€çš„åŠå…¬äººå‘˜ã€‚<code>Rc</code>å†™ä¸‹è°æ‹¥æœ‰æ‰€æœ‰æƒï¼Œä»¥åŠæœ‰å¤šå°‘ä¸ªã€‚ç„¶åä¸€æ—¦æ‰€æœ‰è€…çš„æ•°é‡ä¸‹é™åˆ°0ï¼Œè¿™ä¸ªå˜é‡å°±å¯ä»¥æ¶ˆå¤±äº†ã€‚</p>
<p>ä¸‹é¢æ˜¯å¦‚ä½•ä½¿ç”¨<code>Rc</code>ã€‚é¦–å…ˆæƒ³è±¡ä¸¤ä¸ªç»“æ„:ä¸€ä¸ªå« <code>City</code>ï¼Œå¦ä¸€ä¸ªå« <code>CityData</code>ã€‚<code>City</code>æœ‰ä¸€ä¸ªåŸå¸‚çš„ä¿¡æ¯ï¼Œè€Œ<code>CityData</code>æŠŠæ‰€æœ‰çš„åŸå¸‚éƒ½æ”¾åœ¨<code>Vec</code>ä¸­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: String,
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;String&gt;,
}

fn main() {
    let calgary = City {
        name: "Calgary".to_string(),
        population: 1_200_000,
           // Pretend that this string is very very long
        city_history: "Calgary began as a fort called Fort Calgary that...".to_string(),
    };

    let canada_cities = CityData {
        names: vec![calgary.name], // This is using calgary.name, which is short
        histories: vec![calgary.city_history], // But this String is very long
    };

    println!("Calgary's history is: {}", calgary.city_history);  // âš ï¸
}</code></pre></pre>
<p>å½“ç„¶ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ï¼Œå› ä¸º<code>canada_cities</code>ç°åœ¨æ‹¥æœ‰æ•°æ®ï¼Œè€Œ<code>calgary</code>æ²¡æœ‰ã€‚å®ƒè¯´:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `calgary.city_history`
  --&gt; src\main.rs:27:42
   |
24 |         histories: vec![calgary.city_history], // But this String is very long
   |                         -------------------- value moved here
...
27 |     println!("Calgary's history is: {}", calgary.city_history);  // âš ï¸
   |                                          ^^^^^^^^^^^^^^^^^^^^ value borrowed here after move
   |
   = note: move occurs because `calgary.city_history` has type `std::string::String`, which does not implement the `Copy` trait
</code></pre>
<p>æˆ‘ä»¬å¯ä»¥å…‹éš†åç§°:<code>names: vec![calgary.name.clone()]</code>ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸æƒ³å…‹éš†<code>city_history</code>ï¼Œå› ä¸ºå®ƒå¾ˆé•¿ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª<code>Rc</code>ã€‚</p>
<p>å¢åŠ <code>use</code>çš„å£°æ˜ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {}</code></pre></pre>
<p>ç„¶åç”¨<code>Rc</code>æŠŠ<code>String</code>åŒ…å›´èµ·æ¥:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: Rc&lt;String&gt;,
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;Rc&lt;String&gt;&gt;,
}

fn main() {}</code></pre></pre>
<p>è¦æ·»åŠ ä¸€ä¸ªæ–°çš„å¼•ç”¨ï¼Œä½ å¿…é¡»<code>clone</code> <code>Rc</code>ã€‚ä½†æ˜¯ç­‰ä¸€ä¸‹ï¼Œæˆ‘ä»¬ä¸æ˜¯æƒ³é¿å…ä½¿ç”¨<code>.clone()</code>å—ï¼Ÿä¸å®Œå…¨æ˜¯:æˆ‘ä»¬ä¸æƒ³å…‹éš†æ•´ä¸ªStringã€‚ä½†æ˜¯ä¸€ä¸ª<code>Rc</code>çš„å…‹éš†åªæ˜¯å…‹éš†äº†æŒ‡é’ˆ--å®ƒåŸºæœ¬ä¸Šæ˜¯æ²¡æœ‰å¼€é”€çš„ã€‚è¿™å°±åƒåœ¨ä¸€ç›’ä¹¦ä¸Šè´´ä¸Šä¸€ä¸ªåå­—è´´çº¸ï¼Œä»¥è¡¨æ˜æœ‰ä¸¤ä¸ªäººæ‹¥æœ‰å®ƒï¼Œè€Œä¸æ˜¯åšä¸€ç›’å…¨æ–°çš„ä¹¦ã€‚</p>
<p>ä½ å¯ä»¥ç”¨<code>item.clone()</code>æˆ–è€…ç”¨<code>Rc::clone(&amp;item)</code>æ¥å…‹éš†ä¸€ä¸ªå«<code>item</code>çš„<code>Rc</code>ã€‚æ‰€ä»¥calgary.city_historyæœ‰ä¸¤ä¸ªæ‰€æœ‰è€…ã€‚
æˆ‘ä»¬å¯ä»¥ç”¨<code>Rc::strong_count(&amp;item)</code>æŸ¥è¯¢æ‹¥æœ‰è€…æ•°é‡ã€‚å¦å¤–æˆ‘ä»¬å†å¢åŠ ä¸€ä¸ªæ–°çš„æ‰€æœ‰è€…ã€‚ç°åœ¨æˆ‘ä»¬çš„ä»£ç æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
struct City {
    name: String,
    population: u32,
    city_history: Rc&lt;String&gt;, // String inside an Rc
}

#[derive(Debug)]
struct CityData {
    names: Vec&lt;String&gt;,
    histories: Vec&lt;Rc&lt;String&gt;&gt;, // A Vec of Strings inside Rcs
}

fn main() {
    let calgary = City {
        name: "Calgary".to_string(),
        population: 1_200_000,
           // Pretend that this string is very very long
        city_history: Rc::new("Calgary began as a fort called Fort Calgary that...".to_string()), // Rc::new() to make the Rc
    };

    let canada_cities = CityData {
        names: vec![calgary.name],
        histories: vec![calgary.city_history.clone()], // .clone() to increase the count
    };

    println!("Calgary's history is: {}", calgary.city_history);
    println!("{}", Rc::strong_count(&amp;calgary.city_history));
    let new_owner = calgary.city_history.clone();
}</code></pre></pre>
<p>è¿™å°±æ‰“å°å‡ºäº†<code>2</code>ã€‚è€Œ<code>new_owner</code>ç°åœ¨æ˜¯<code>Rc&lt;String&gt;</code>ã€‚ç°åœ¨å¦‚æœæˆ‘ä»¬ç”¨<code>println!("{}", Rc::strong_count(&amp;calgary.city_history));</code>ï¼Œæˆ‘ä»¬å¾—åˆ°<code>3</code>ã€‚</p>
<p>é‚£ä¹ˆï¼Œå¦‚æœæœ‰å¼ºæŒ‡é’ˆï¼Œæ˜¯å¦æœ‰å¼±æŒ‡é’ˆå‘¢ï¼Ÿæ˜¯çš„ï¼Œæœ‰ã€‚å¼±æŒ‡é’ˆæ˜¯æœ‰ç”¨çš„ï¼Œå› ä¸ºå¦‚æœä¸¤ä¸ª<code>Rc</code>äº’ç›¸æŒ‡å‘å¯¹æ–¹ï¼Œå®ƒä»¬å°±ä¸ä¼šæ­»ã€‚è¿™å°±æ˜¯æ‰€è°“çš„ "å¼•ç”¨å¾ªç¯"ã€‚å¦‚æœç¬¬1é¡¹å¯¹ç¬¬2é¡¹æœ‰ä¸€ä¸ªRcï¼Œè€Œç¬¬2é¡¹å¯¹ç¬¬1é¡¹æœ‰ä¸€ä¸ªRcï¼Œå®ƒä»¬ä¸èƒ½åˆ°0ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¦ä½¿ç”¨å¼±å¼•ç”¨ã€‚é‚£ä¹ˆ<code>Rc</code>å°±ä¼šå¯¹å¼•ç”¨è¿›è¡Œè®¡æ•°ï¼Œä½†å¦‚æœåªæœ‰å¼±å¼•ç”¨ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šæ­»æ‰ã€‚ä½ ä½¿ç”¨<code>Rc::downgrade(&amp;item)</code>è€Œä¸æ˜¯<code>Rc::clone(&amp;item)</code>æ¥åˆ›å»ºå¼±å¼•ç”¨ã€‚å¦å¤–ï¼Œéœ€è¦ç”¨<code>Rc::weak_count(&amp;item)</code>æ¥æŸ¥çœ‹å¼±å¼•ç”¨æ•°ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¤šçº¿ç¨‹"><a class="header" href="#å¤šçº¿ç¨‹">å¤šçº¿ç¨‹</a></h2>
<p>å¦‚æœä½ ä½¿ç”¨å¤šä¸ªçº¿ç¨‹ï¼Œä½ å¯ä»¥åŒæ—¶åšå¾ˆå¤šäº‹æƒ…ã€‚ç°ä»£è®¡ç®—æœºæœ‰ä¸€ä¸ªä»¥ä¸Šçš„æ ¸å¿ƒï¼Œæ‰€ä»¥å®ƒä»¬å¯ä»¥åŒæ—¶åšå¤šä»¶äº‹æƒ…ï¼ŒRustè®©ä½ ä½¿ç”¨å®ƒä»¬ã€‚Rustä½¿ç”¨çš„çº¿ç¨‹è¢«ç§°ä¸º "OSçº¿ç¨‹"ã€‚OSçº¿ç¨‹æ„å‘³ç€æ“ä½œç³»ç»Ÿåœ¨ä¸åŒçš„æ ¸ä¸Šåˆ›å»ºçº¿ç¨‹ã€‚(å…¶ä»–ä¸€äº›è¯­è¨€ä½¿ç”¨ "green threads"ï¼ŒåŠŸèƒ½è¾ƒå°‘)</p>
<p>ä½ ç”¨<code>std::thread::spawn</code>åˆ›å»ºçº¿ç¨‹ï¼Œç„¶åç”¨ä¸€ä¸ªé—­åŒ…æ¥å‘Šè¯‰å®ƒè¯¥æ€ä¹ˆåšã€‚çº¿ç¨‹å¾ˆæœ‰è¶£ï¼Œå› ä¸ºå®ƒä»¬åŒæ—¶è¿è¡Œï¼Œä½ å¯ä»¥æµ‹è¯•å®ƒï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    std::thread::spawn(|| {
        println!("I am printing something");
    });
}</code></pre></pre>
<p>å¦‚æœä½ è¿è¡Œè¿™ä¸ªï¼Œæ¯æ¬¡éƒ½ä¼šä¸ä¸€æ ·ã€‚æœ‰æ—¶ä¼šæ‰“å°ï¼Œæœ‰æ—¶ä¸ä¼šæ‰“å°(è¿™ä¹Ÿå–å†³äºä½ çš„ç”µè„‘é€Ÿåº¦)ã€‚è¿™æ˜¯å› ä¸ºæœ‰æ—¶<code>main()</code>åœ¨çº¿ç¨‹å®Œæˆä¹‹å‰å°±å®Œæˆäº†ã€‚è€Œå½“<code>main()</code>å®Œæˆåï¼Œç¨‹åºå°±ç»“æŸäº†ã€‚è¿™åœ¨<code>for</code>å¾ªç¯ä¸­æ›´å®¹æ˜“çœ‹åˆ°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 { // set up ten threads
        std::thread::spawn(|| {
            println!("I am printing something");
        });
    }   // Now the threads start.
}       // How many can finish before main() ends here?</code></pre></pre>
<p>é€šå¸¸åœ¨<code>main</code>ç»“æŸä¹‹å‰ï¼Œå¤§çº¦ä¼šæ‰“å°å‡ºå››æ¡çº¿ç¨‹ï¼Œä½†æ€»æ˜¯ä¸ä¸€æ ·ã€‚å¦‚æœä½ çš„ç”µè„‘é€Ÿåº¦æ¯”è¾ƒå¿«ï¼Œé‚£ä¹ˆå¯èƒ½å°±ä¸ä¼šæ‰“å°äº†ã€‚å¦å¤–ï¼Œæœ‰æ—¶çº¿ç¨‹ä¼šå´©æºƒã€‚</p>
<pre><code class="language-text">thread 'thread 'I am printing something
thread '&lt;unnamed&gt;&lt;unnamed&gt;thread '' panicked at '&lt;unnamed&gt;I am printing something
' panicked at 'thread '&lt;unnamed&gt;cannot access stdout during shutdown' panicked at '&lt;unnamed&gt;thread 'cannot access stdout during
shutdown
</code></pre>
<p>è¿™æ˜¯åœ¨ç¨‹åºå…³é—­æ—¶ï¼Œçº¿ç¨‹è¯•å›¾åšä¸€äº›æ­£ç¡®çš„äº‹æƒ…æ—¶å‡ºç°çš„é”™è¯¯ã€‚</p>
<p>ä½ å¯ä»¥ç»™ç”µè„‘åšä¸€äº›äº‹æƒ…ï¼Œè¿™æ ·å®ƒå°±ä¸ä¼šé©¬ä¸Šå…³é—­äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        std::thread::spawn(|| {
            println!("I am printing something");
        });
    }
    for _ in 0..1_000_000 { // make the program declare "let x = 9" one million times
                            // It has to finish this before it can exit the main function
        let _x = 9;
    }
}</code></pre></pre>
<p>ä½†è¿™æ˜¯ä¸€ä¸ªè®©çº¿ç¨‹æœ‰æ—¶é—´å®Œæˆçš„æ„šè ¢æ–¹æ³•ã€‚æ›´å¥½çš„æ–¹æ³•æ˜¯å°†çº¿ç¨‹ç»‘å®šåˆ°ä¸€ä¸ªå˜é‡ä¸Šã€‚å¦‚æœä½ åŠ ä¸Š <code>let</code>ï¼Œä½ å°±èƒ½åˆ›å»ºä¸€ä¸ª <code>JoinHandle</code>ã€‚ä½ å¯ä»¥åœ¨<code>spawn</code>çš„ç­¾åä¸­çœ‹åˆ°è¿™ä¸€ç‚¹:</p>
<pre><code class="language-text">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
</code></pre>
<p>(<code>f</code>æ˜¯é—­åŒ…--æˆ‘ä»¬å°†åœ¨åé¢å­¦ä¹ å¦‚ä½•å°†é—­åŒ…æ”¾å…¥æˆ‘ä»¬çš„å‡½æ•°ä¸­)</p>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æ¯æ¬¡éƒ½æœ‰<code>JoinHandle</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        let handle = std::thread::spawn(|| {
            println!("I am printing something");
        });

    }
}</code></pre></pre>
<p><code>handle</code>ç°åœ¨æ˜¯<code>JoinHandle</code>ã€‚æˆ‘ä»¬æ€ä¹ˆå¤„ç†å®ƒå‘¢ï¼Ÿæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå«åš <code>.join()</code> çš„æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•çš„æ„æ€æ˜¯ "ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ"(å®ƒç­‰å¾…çº¿ç¨‹åŠ å…¥å®ƒ)ã€‚æ‰€ä»¥ç°åœ¨åªè¦å†™<code>handle.join()</code>ï¼Œå®ƒå°±ä¼šç­‰å¾…æ¯ä¸ªçº¿ç¨‹å®Œæˆã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for _ in 0..10 {
        let handle = std::thread::spawn(|| {
            println!("I am printing something");
        });

        handle.join(); // Wait for the threads to finish
    }
}</code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬å°±æ¥äº†è§£ä¸€ä¸‹ä¸‰ç§ç±»å‹çš„é—­åŒ…ã€‚è¿™ä¸‰ç§ç±»å‹æ˜¯</p>
<ul>
<li><code>FnOnce</code>: å–æ•´ä¸ªå€¼</li>
<li><code>FnMut</code>: å–ä¸€ä¸ªå¯å˜å¼•ç”¨</li>
<li><code>Fn</code>: å–ä¸€ä¸ªæ™®é€šå¼•ç”¨</li>
</ul>
<p>å¦‚æœå¯ä»¥çš„è¯ï¼Œé—­åŒ…ä¼šå°½é‡ä½¿ç”¨<code>Fn</code>ã€‚ä½†å¦‚æœå®ƒéœ€è¦æ”¹å˜å€¼ï¼Œå®ƒå°†ä½¿ç”¨ <code>FnMut</code>ï¼Œè€Œå¦‚æœå®ƒéœ€è¦å–æ•´ä¸ªå€¼ï¼Œå®ƒå°†ä½¿ç”¨ <code>FnOnce</code>ã€‚<code>FnOnce</code>æ˜¯ä¸ªå¥½åå­—ï¼Œå› ä¸ºå®ƒè§£é‡Šäº†å®ƒçš„ä½œç”¨:å®ƒå–ä¸€æ¬¡å€¼ï¼Œç„¶åå°±ä¸èƒ½å†å–äº†ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_string = String::from("I will go into the closure");
    let my_closure = || println!("{}", my_string);
    my_closure();
    my_closure();
}</code></pre></pre>
<p><code>String</code>æ²¡æœ‰å®ç°<code>Copy</code>ï¼Œæ‰€ä»¥<code>my_closure()</code>æ˜¯<code>Fn</code>: å®ƒæ‹¿åˆ°ä¸€ä¸ªå¼•ç”¨</p>
<p>å¦‚æœæˆ‘ä»¬æ”¹å˜<code>my_string</code>ï¼Œå®ƒå˜æˆ<code>FnMut</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("I will go into the closure");
    let mut my_closure = || {
        my_string.push_str(" now");
        println!("{}", my_string);
    };
    my_closure();
    my_closure();
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">I will go into the closure now
I will go into the closure now now
</code></pre>
<p>è€Œå¦‚æœæŒ‰å€¼è·å–ï¼Œåˆ™æ˜¯<code>FnOnce</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec: Vec&lt;i32&gt; = vec![8, 9, 10];
    let my_closure = || {
        my_vec
            .into_iter() // into_iter takes ownership
            .map(|x| x as u8) // turn it into u8
            .map(|x| x * 2) // multiply by 2
            .collect::&lt;Vec&lt;u8&gt;&gt;() // collect into a Vec
    };
    let new_vec = my_closure();
    println!("{:?}", new_vec);
}</code></pre></pre>
<p>æˆ‘ä»¬æ˜¯æŒ‰å€¼å–çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½å¤šè·‘<code>my_closure()</code>æ¬¡ã€‚è¿™å°±æ˜¯åå­—çš„ç”±æ¥ã€‚</p>
<p>é‚£ä¹ˆç°åœ¨å›åˆ°çº¿ç¨‹ã€‚è®©æˆ‘ä»¬è¯•ç€ä»å¤–éƒ¨å¼•å…¥ä¸€ä¸ªå€¼:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("Can I go inside the thread?");

    let handle = std::thread::spawn(|| {
        println!("{}", my_string); // âš ï¸
    });

    handle.join();
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´è¿™ä¸ªä¸è¡Œã€‚</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `my_string`, which is owned by the current function
  --&gt; src\main.rs:28:37
   |
28 |     let handle = std::thread::spawn(|| {
   |                                     ^^ may outlive borrowed value `my_string`
29 |         println!("{}", my_string);
   |                        --------- `my_string` is borrowed here
   |
note: function requires argument type to outlive `'static`
  --&gt; src\main.rs:28:18
   |
28 |       let handle = std::thread::spawn(|| {
   |  __________________^
29 | |         println!("{}", my_string);
30 | |     });
   | |______^
help: to force the closure to take ownership of `my_string` (and any other referenced variables), use the `move` keyword
   |
28 |     let handle = std::thread::spawn(move || {
   |                                     ^^^^^^^
</code></pre>
<p>è¿™æ¡ä¿¡æ¯å¾ˆé•¿ï¼Œä½†å¾ˆæœ‰ç”¨:å®ƒè¯´åˆ°<code>use the `move` keyword</code>ã€‚é—®é¢˜æ˜¯æˆ‘ä»¬å¯ä»¥åœ¨çº¿ç¨‹ä½¿ç”¨<code>my_string</code>æ—¶å¯¹å®ƒåšä»»ä½•äº‹æƒ…ï¼Œä½†çº¿ç¨‹å¹¶ä¸æ‹¥æœ‰å®ƒã€‚è¿™å°†æ˜¯ä¸å®‰å…¨çš„ã€‚</p>
<p>è®©æˆ‘ä»¬è¯•è¯•å…¶ä»–è¡Œä¸é€šçš„ä¸œè¥¿ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("Can I go inside the thread?");

    let handle = std::thread::spawn(|| {
        println!("{}", my_string); // now my_string is being used as a reference
    });

    std::mem::drop(my_string);  // âš ï¸ We try to drop it here. But the thread still needs it.

    handle.join();
}</code></pre></pre>
<p>æ‰€ä»¥ä½ è¦ç”¨<code>move</code>æ¥å–å€¼ï¼Œç°åœ¨å®‰å…¨äº†:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("Can I go inside the thread?");

    let handle = std::thread::spawn(move|| {
        println!("{}", my_string);
    });

    std::mem::drop(my_string);  // âš ï¸ we can't drop, because handle has it. So this won't work

    handle.join();
}</code></pre></pre>
<p>æ‰€ä»¥æˆ‘ä»¬æŠŠ<code>std::mem::drop</code>åˆ æ‰ï¼Œç°åœ¨å°±å¯ä»¥äº†ã€‚<code>handle</code>å–<code>my_string</code>ï¼Œæˆ‘ä»¬çš„ä»£ç å°±å®‰å…¨äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("Can I go inside the thread?");

    let handle = std::thread::spawn(move|| {
        println!("{}", my_string);
    });

    handle.join();
}</code></pre></pre>
<p>æ‰€ä»¥åªè¦è®°ä½:å¦‚æœä½ åœ¨çº¿ç¨‹ä¸­éœ€è¦ä¸€ä¸ªæ¥è‡ªçº¿ç¨‹å¤–çš„å€¼ï¼Œä½ éœ€è¦ä½¿ç”¨<code>move</code>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‡½æ•°ä¸­çš„é—­åŒ…"><a class="header" href="#å‡½æ•°ä¸­çš„é—­åŒ…">å‡½æ•°ä¸­çš„é—­åŒ…</a></h2>
<p>é—­åŒ…æ˜¯ä¼Ÿå¤§çš„ã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æŠŠå®ƒä»¬æ”¾åˆ°è‡ªå·±çš„å‡½æ•°ä¸­å‘¢ï¼Ÿ</p>
<p>ä½ å¯ä»¥åˆ›å»ºè‡ªå·±çš„å‡½æ•°æ¥æ¥å—é—­åŒ…ï¼Œä½†æ˜¯åœ¨å‡½æ•°é‡Œé¢å°±ä¸é‚£ä¹ˆè‡ªç”±äº†ï¼Œä½ å¿…é¡»å†³å®šç±»å‹ã€‚åœ¨å‡½æ•°å¤–éƒ¨ï¼Œä¸€ä¸ªé—­åŒ…å¯ä»¥åœ¨<code>Fn</code>ã€<code>FnMut</code>å’Œ<code>FnOnce</code>ä¹‹é—´è‡ªè¡Œå†³å®šï¼Œä½†åœ¨å‡½æ•°å†…éƒ¨ä½ å¿…é¡»é€‰æ‹©ä¸€ä¸ªã€‚æœ€å¥½çš„ç†è§£æ–¹å¼æ˜¯çœ‹å‡ ä¸ªå‡½æ•°ç­¾åã€‚
è¿™é‡Œæ˜¯<code>.all()</code>çš„é‚£ä¸ªã€‚æˆ‘ä»¬è®°å¾—ï¼Œå®ƒæ£€æŸ¥ä¸€ä¸ªè¿­ä»£å™¨ï¼Œçœ‹çœ‹æ‰€æœ‰çš„ä¸œè¥¿æ˜¯å¦æ˜¯<code>true</code>(å–å†³äºä½ å†³å®šæ˜¯<code>true</code>è¿˜æ˜¯<code>false</code>)ã€‚å®ƒçš„éƒ¨åˆ†ç­¾åæ˜¯è¿™æ ·è¯´çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool    // ğŸš§
    where
        F: FnMut(Self::Item) -&gt; bool,
<span class="boring">}</span></code></pre></pre>
<p><code>fn all&lt;F&gt;</code>:è¿™å‘Šè¯‰ä½ æœ‰ä¸€ä¸ªé€šç”¨ç±»å‹<code>F</code>ã€‚ä¸€ä¸ªé—­åŒ…æ€»æ˜¯æ³›å‹ï¼Œå› ä¸ºæ¯æ¬¡éƒ½æ˜¯ä¸åŒçš„ç±»å‹ã€‚</p>
<p><code>(&amp;mut self, f: F)</code>:<code>&amp;mut self</code>å‘Šè¯‰ä½ è¿™æ˜¯ä¸€ä¸ªæ–¹æ³•ã€‚<code>f: F</code>é€šå¸¸ä½ çœ‹åˆ°çš„æ˜¯ä¸€ä¸ªé—­åŒ…:è¿™æ˜¯å˜é‡åå’Œç±»å‹ã€‚ å½“ç„¶ï¼Œ<code>f</code>å’Œ<code>F</code>å¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«ä¹‹å¤„ï¼Œå®ƒä»¬å¯ä»¥æ˜¯ä¸åŒçš„åå­—ã€‚å¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥å†™<code>my_closure: Closure</code>--è¿™å¹¶ä¸é‡è¦ã€‚ä½†åœ¨ç­¾åä¸­ï¼Œä½ å‡ ä¹æ€»æ˜¯çœ‹åˆ°<code>f: F</code>ã€‚</p>
<p>æ¥ä¸‹æ¥æ˜¯å…³äºé—­åŒ…çš„éƒ¨åˆ†:<code>F: FnMut(Self::Item) -&gt; bool</code>ã€‚åœ¨è¿™é‡Œï¼Œå®ƒå†³å®šäº†é—­åŒ…æ˜¯ <code>FnMut</code>ï¼Œæ‰€ä»¥å®ƒå¯ä»¥æ”¹å˜å€¼ã€‚å®ƒæ”¹å˜äº†<code>Self::Item</code>çš„å€¼ï¼Œè¿™æ˜¯å®ƒæ‰€å–çš„è¿­ä»£å™¨ã€‚è€Œä¸”å®ƒå¿…é¡»è¿”å› <code>true</code> æˆ– <code>false</code>ã€‚</p>
<p>è¿™é‡Œæ˜¯ä¸€ä¸ªæ›´ç®€å•çš„ç­¾åï¼Œæœ‰ä¸€ä¸ªé—­åŒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something&lt;F&gt;(f: F)    // ğŸš§
where
    F: FnOnce(),
{
    f();
}
<span class="boring">}</span></code></pre></pre>
<p>è¿™åªæ˜¯è¯´å®ƒæ¥å—ä¸€ä¸ªé—­åŒ…ï¼Œå–å€¼(<code>FnOnce</code>=å–å€¼)ï¼Œè€Œä¸è¿”å›ä»»ä½•ä¸œè¥¿ã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¯ä»¥è°ƒç”¨è¿™ä¸ªä»€ä¹ˆéƒ½ä¸å–çš„é—­åŒ…ï¼Œåšæˆ‘ä»¬å–œæ¬¢åšçš„äº‹æƒ…ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª <code>Vec</code>ï¼Œç„¶åå¯¹å®ƒè¿›è¡Œè¿­ä»£ï¼Œåªæ˜¯ä¸ºäº†å±•ç¤ºæˆ‘ä»¬ç°åœ¨å¯ä»¥åšä»€ä¹ˆã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn do_something&lt;F&gt;(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let some_vec = vec![9, 8, 10];
    do_something(|| {
        some_vec
            .into_iter()
            .for_each(|x| println!("The number is: {}", x));
    })
}</code></pre></pre>
<p>ä¸€ä¸ªæ›´çœŸå®çš„ä¾‹å­ï¼Œæˆ‘ä»¬å°†å†æ¬¡åˆ›å»ºä¸€ä¸ª <code>City</code> ç»“æ„ä½“ã€‚è¿™æ¬¡ <code>City</code> ç»“æ„ä½“æœ‰æ›´å¤šå…³äºå¹´ä»½å’Œäººå£çš„æ•°æ®ã€‚å®ƒæœ‰ä¸€ä¸ª <code>Vec&lt;u32&gt;</code> æ¥è¡¨ç¤ºæ‰€æœ‰çš„å¹´ä»½ï¼Œè¿˜æœ‰ä¸€ä¸ª <code>Vec&lt;u32&gt;</code> æ¥è¡¨ç¤ºæ‰€æœ‰çš„äººå£ã€‚</p>
<p><code>City</code>æœ‰ä¸¤ä¸ªæ–¹æ³•:<code>new()</code>ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„<code>City</code>, <code>.city_data()</code>æœ‰ä¸ªé—­åŒ…å‚æ•°ã€‚å½“æˆ‘ä»¬ä½¿ç”¨ <code>.city_data()</code> æ—¶ï¼Œå®ƒç»™æˆ‘ä»¬æä¾›äº†å¹´ä»½å’Œäººå£ä»¥åŠä¸€ä¸ªé—­åŒ…ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹æ•°æ®åšæˆ‘ä»¬æƒ³åšçš„äº‹æƒ…ã€‚é—­åŒ…ç±»å‹æ˜¯ <code>FnMut</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”¹å˜æ•°æ®ã€‚å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    years: Vec&lt;u32&gt;,
    populations: Vec&lt;u32&gt;,
}

impl City {
    fn new(name: &amp;str, years: Vec&lt;u32&gt;, populations: Vec&lt;u32&gt;) -&gt; Self {

        Self {
            name: name.to_string(),
            years,
            populations,
        }
    }

    fn city_data&lt;F&gt;(&amp;mut self, mut f: F) // We bring in self, but only f is generic F. f is the closure

    where
        F: FnMut(&amp;mut Vec&lt;u32&gt;, &amp;mut Vec&lt;u32&gt;), // The closure takes mutable vectors of u32
                                                // which are the year and population data
    {
        f(&amp;mut self.years, &amp;mut self.populations) // Finally this is the actual function. It says
                                                  // "use a closure on self.years and self.populations"
                                                  // We can do whatever we want with the closure
    }
}

fn main() {
    let years = vec![
        1372, 1834, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020,
    ];
    let populations = vec![
        3_250, 15_300, 24_000, 45_900, 58_800, 119_800, 283_071, 478_974, 400_378, 401_694,
        406_703, 437_619,
    ];
    // Now we can create our city
    let mut tallinn = City::new("Tallinn", years, populations);

    // Now we have a .city_data() method that has a closure. We can do anything we want.

    // First let's put the data for 5 years together and print it.
    tallinn.city_data(|city_years, city_populations| { // We can call the input anything we want
        let new_vec = city_years
            .into_iter()
            .zip(city_populations.into_iter()) // Zip the two together
            .take(5)                           // but only take the first 5
            .collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // Tell Rust to decide the type inside the tuple
        println!("{:?}", new_vec);
    });

    // Now let's add some data for the year 2030
    tallinn.city_data(|x, y| { // This time we just call the input x and y
        x.push(2030);
        y.push(500_000);
    });

    // We don't want the 1834 data anymore
    tallinn.city_data(|x, y| {
        let position_option = x.iter().position(|x| *x == 1834);
        if let Some(position) = position_option {
            println!(
                "Going to delete {} at position {:?} now.",
                x[position], position
            ); // Confirm that we delete the right item
            x.remove(position);
            y.remove(position);
        }
    });

    println!(
        "Years left are {:?}\nPopulations left are {:?}",
        tallinn.years, tallinn.populations
    );
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡ºæˆ‘ä»¬è°ƒç”¨<code>.city_data().</code>çš„æ‰€æœ‰æ—¶é—´çš„ç»“æœ:</p>
<pre><code class="language-text">[(1372, 3250), (1834, 15300), (1851, 24000), (1881, 45900), (1897, 58800)]
Going to delete 1834 at position 1 now.
Years left are [1372, 1851, 1881, 1897, 1925, 1959, 1989, 2000, 2005, 2010, 2020, 2030]
Populations left are [3250, 24000, 45900, 58800, 119800, 283071, 478974, 400378, 401694, 406703, 437619, 500000]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="impl-trait"><a class="header" href="#impl-trait">impl Trait</a></h2>
<p><code>impl Trait</code>ä¸æ³›å‹ç±»ä¼¼ã€‚ä½ è¿˜è®°å¾—ï¼Œæ³›å‹ä½¿ç”¨ä¸€ä¸ªç±»å‹ <code>T</code>(æˆ–ä»»ä½•å…¶ä»–åç§°)ï¼Œç„¶ååœ¨ç¨‹åºç¼–è¯‘æ—¶å†³å®šã€‚é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªå…·ä½“çš„ç±»å‹:</p>
<pre><pre class="playground"><code class="language-rust">fn gives_higher_i32(one: i32, two: i32) {
    let higher = if one &gt; two { one } else { two };
    println!("{} is higher.", higher);
}

fn main() {
    gives_higher_i32(8, 10);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:<code>10 is higher.</code>.</p>
<p>ä½†æ˜¯è¿™ä¸ªåªæ¥å—<code>i32</code>ï¼Œæ‰€ä»¥ç°åœ¨æˆ‘ä»¬è¦æŠŠå®ƒåšæˆé€šç”¨çš„ã€‚æˆ‘ä»¬éœ€è¦æ¯”è¾ƒï¼Œæˆ‘ä»¬éœ€è¦ç”¨<code>{}</code>æ‰“å°ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„ç±»å‹Téœ€è¦<code>PartialOrd</code>å’Œ<code>Display</code>ã€‚è®°ä½ï¼Œè¿™æ„å‘³ç€ "åªæ¥å—å·²ç»å®ç°<code>PartialOrd</code>å’Œ<code>Display</code>çš„ç±»å‹"ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn gives_higher_i32&lt;T: PartialOrd + Display&gt;(one: T, two: T) {
    let higher = if one &gt; two { one } else { two };
    println!("{} is higher.", higher);
}

fn main() {
    gives_higher_i32(8, 10);
}</code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹<code>impl Trait</code>ï¼Œå®ƒä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚æˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸€ä¸ªç±»å‹ <code>impl Trait</code>ï¼Œè€Œä¸æ˜¯ <code>T</code>ã€‚ç„¶åå®ƒå°†å¸¦å…¥ä¸€ä¸ªå®ç°è¯¥ç‰¹æ€§çš„ç±»å‹ã€‚è¿™å‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn prints_it(input: impl Into&lt;String&gt; + std::fmt::Display) { // Takes anything that can turn into a String and has Display
    println!("You can print many things, including {}", input);
}

fn main() {
    let name = "Tuon";
    let string_name = String::from("Tuon");
    prints_it(name);
    prints_it(string_name);
}</code></pre></pre>
<p>ç„¶è€Œï¼Œæ›´æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥è¿”å› <code>impl Trait</code>ï¼Œè¿™è®©æˆ‘ä»¬å¯ä»¥è¿”å›é—­åŒ…ï¼Œå› ä¸ºå®ƒä»¬çš„å‡½æ•°ç­¾åæ˜¯traitã€‚ä½ å¯ä»¥åœ¨æœ‰å®ƒä»¬çš„æ–¹æ³•çš„ç­¾åä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯ <code>.map()</code> çš„ç­¾åã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;     // ğŸš§
    where
        Self: Sized,
        F: FnMut(Self::Item) -&gt; B,
    {
        Map::new(self, f)
    }
<span class="boring">}</span></code></pre></pre>
<p><code>fn map&lt;B, F&gt;(self, f: F)</code>çš„æ„æ€æ˜¯ï¼Œå®ƒéœ€è¦ä¸¤ä¸ªé€šç”¨ç±»å‹ã€‚<code>F</code>æ˜¯æŒ‡ä»å®ç°<code>.map()</code>çš„å®¹å™¨ä¸­å–ä¸€ä¸ªå…ƒç´ çš„å‡½æ•°ï¼Œ<code>B</code>æ˜¯è¯¥å‡½æ•°çš„è¿”å›ç±»å‹ã€‚ç„¶ååœ¨<code>where</code>ä¹‹åï¼Œæˆ‘ä»¬çœ‹åˆ°çš„æ˜¯trait boundã€‚("trait bound"çš„æ„æ€æ˜¯ "å®ƒå¿…é¡»æœ‰è¿™ä¸ªtrait"ã€‚)ä¸€ä¸ªæ˜¯<code>Sized</code>ï¼Œæ¥ä¸‹æ¥æ˜¯é—­åŒ…ç­¾åã€‚å®ƒå¿…é¡»æ˜¯ä¸€ä¸ª <code>FnMut</code>ï¼Œå¹¶åœ¨ <code>Self::Item</code> ä¸Šåšé—­åŒ…ï¼Œä¹Ÿå°±æ˜¯ä½ ç»™å®ƒçš„è¿­ä»£å™¨ã€‚ç„¶åå®ƒè¿”å›<code>B</code>ã€‚</p>
<p>æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨åŒæ ·çš„æ–¹æ³•æ¥è¿”å›ä¸€ä¸ªé—­åŒ…ã€‚è¦è¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œä½¿ç”¨ <code>impl</code>ï¼Œç„¶åæ˜¯é—­åŒ…ç­¾åã€‚ä¸€æ—¦ä½ è¿”å›å®ƒï¼Œä½ å°±å¯ä»¥åƒä½¿ç”¨ä¸€ä¸ªå‡½æ•°ä¸€æ ·ä½¿ç”¨å®ƒã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå‡½æ•°çš„å°ä¾‹å­ï¼Œå®ƒæ ¹æ®ä½ è¾“å…¥çš„æ–‡æœ¬ç»™å‡ºä¸€ä¸ªé—­åŒ…ã€‚å¦‚æœä½ è¾“å…¥ "double "æˆ– "triple"ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šæŠŠå®ƒä¹˜ä»¥2æˆ–3ï¼Œå¦åˆ™å°±ä¼šè¿”ç»™ä½ ç›¸åŒçš„æ•°å­—ã€‚å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œæˆ‘ä»¬å¯ä»¥åšä»»ä½•æˆ‘ä»¬æƒ³åšçš„äº‹æƒ…ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿæ‰“å°ä¸€æ¡ä¿¡æ¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn returns_a_closure(input: &amp;str) -&gt; impl FnMut(i32) -&gt; i32 {
    match input {
        "double" =&gt; |mut number| {
            number *= 2;
            println!("Doubling number. Now it is {}", number);
            number
        },
        "triple" =&gt; |mut number| {
            number *= 40;
            println!("Tripling number. Now it is {}", number);
            number
        },
        _ =&gt; |number| {
            println!("Sorry, it's the same: {}.", number);
            number
        },
    }
}

fn main() {
    let my_number = 10;

    // Make three closures
    let mut doubles = returns_a_closure("double");
    let mut triples = returns_a_closure("triple");
    let mut quadruples = returns_a_closure("quadruple");

    doubles(my_number);
    triples(my_number);
    quadruples(my_number);
}</code></pre></pre>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªæ¯”è¾ƒé•¿çš„ä¾‹å­ã€‚è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œåœ¨ä¸€ä¸ªæ¸¸æˆä¸­ï¼Œä½ çš„è§’è‰²é¢å¯¹çš„æ˜¯æ™šä¸Šæ¯”è¾ƒå¼ºçš„æ€ªç‰©ã€‚æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå«<code>TimeOfDay</code>çš„æšä¸¾æ¥è®°å½•ä¸€å¤©çš„æƒ…å†µã€‚ä½ çš„è§’è‰²å«è¥¿è’™ï¼Œæœ‰ä¸€ä¸ªå«<code>character_fear</code>çš„æ•°å­—ï¼Œä¹Ÿå°±æ˜¯<code>f64</code>ã€‚å®ƒæ™šä¸Šä¸Šå‡ï¼Œç™½å¤©ä¸‹é™ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª<code>change_fear</code>å‡½æ•°ï¼Œæ”¹å˜ä»–çš„ææƒ§ï¼Œä½†ä¹Ÿåšå…¶ä»–äº‹æƒ…ï¼Œå¦‚å†™æ¶ˆæ¯ã€‚å®ƒå¤§æ¦‚æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">enum TimeOfDay { // just a simple enum
    Dawn,
    Day,
    Sunset,
    Night,
}

fn change_fear(input: TimeOfDay) -&gt; impl FnMut(f64) -&gt; f64 { // The function takes a TimeOfDay. It returns a closure.
                                                             // We use impl FnMut(64) -&gt; f64 to say that it needs to
                                                             // change the value, and also gives the same type back.
    use TimeOfDay::*; // So we only have to write Dawn, Day, Sunset, Night
                      // Instead of TimeOfDay::Dawn, TimeOfDay::Day, etc.
    match input {
        Dawn =&gt; |x| { // This is the variable character_fear that we give it later
            println!("The morning sun has vanquished the horrible night. You no longer feel afraid.");
            println!("Your fear is now {}", x * 0.5);
            x * 0.5
        },
        Day =&gt; |x| {
            println!("What a nice day. Maybe put your feet up and rest a bit.");
            println!("Your fear is now {}", x * 0.2);
            x * 0.2
        },
        Sunset =&gt; |x| {
            println!("The sun is almost down! This is no good.");
            println!("Your fear is now {}", x * 1.4);
            x * 1.4
        },
        Night =&gt; |x| {
            println!("What a horrible night to have a curse.");
            println!("Your fear is now {}", x * 5.0);
            x * 5.0
        },
    }
}

fn main() {
    use TimeOfDay::*;
    let mut character_fear = 10.0; // Start Simon with 10

    let mut daytime = change_fear(Day); // Make four closures here to call every time we want to change Simon's fear.
    let mut sunset = change_fear(Sunset);
    let mut night = change_fear(Night);
    let mut morning = change_fear(Dawn);

    character_fear = daytime(character_fear); // Call the closures on Simon's fear. They give a message and change the fear number.
                                              // In real life we would have a Character struct and use it as a method instead,
                                              // like this: character_fear.daytime()
    character_fear = sunset(character_fear);
    character_fear = night(character_fear);
    character_fear = morning(character_fear);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">What a nice day. Maybe put your feet up and rest a bit.
Your fear is now 2
The sun is almost down! This is no good.
Your fear is now 2.8
What a horrible night to have a curse.
Your fear is now 14
The morning sun has vanquished the horrible night. You no longer feel afraid.
Your fear is now 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arc"><a class="header" href="#arc">Arc</a></h2>
<p>ä½ è¿˜è®°å¾—æˆ‘ä»¬ç”¨<code>Rc</code>æ¥ç»™ä¸€ä¸ªå˜é‡ä¸€ä¸ªä»¥ä¸Šçš„æ‰€æœ‰è€…ã€‚å¦‚æœæˆ‘ä»¬åœ¨çº¿ç¨‹ä¸­åšåŒæ ·çš„äº‹æƒ…ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ª <code>Arc</code>ã€‚<code>Arc</code>çš„æ„æ€æ˜¯ "atomic reference counter"(åŸå­å¼•ç”¨è®¡æ•°å™¨)ã€‚åŸå­çš„æ„æ€æ˜¯å®ƒä½¿ç”¨è®¡ç®—æœºçš„å¤„ç†å™¨ï¼Œæ‰€ä»¥æ¯æ¬¡åªå†™ä¸€æ¬¡æ•°æ®ã€‚è¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå› ä¸ºå¦‚æœä¸¤ä¸ªçº¿ç¨‹åŒæ—¶å†™å…¥æ•°æ®ï¼Œä½ ä¼šå¾—åˆ°é”™è¯¯çš„ç»“æœã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä½ èƒ½åœ¨Rustä¸­åšåˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
let mut x = 10;

for i in 0..10 { // Thread 1
    x += 1
}
for i in 0..10 { // Thread 2
    x += 1
}
<span class="boring">}</span></code></pre></pre>
<p>å¦‚æœçº¿ç¨‹1å’Œçº¿ç¨‹2ä¸€èµ·å¯åŠ¨ï¼Œä¹Ÿè®¸å°±ä¼šå‡ºç°è¿™ç§æƒ…å†µã€‚</p>
<ul>
<li>çº¿ç¨‹1çœ‹åˆ°10ï¼Œå†™ä¸‹11ï¼Œç„¶åçº¿ç¨‹2çœ‹åˆ°11ï¼Œå†™ä¸‹12 ç„¶åçº¿ç¨‹2çœ‹åˆ°11ï¼Œå†™å…¥12ã€‚åˆ°ç›®å‰ä¸ºæ­¢æ²¡æœ‰é—®é¢˜ã€‚</li>
<li>çº¿ç¨‹1çœ‹åˆ°12ã€‚åŒæ—¶ï¼Œçº¿ç¨‹2çœ‹åˆ°12ã€‚çº¿ç¨‹ä¸€çœ‹åˆ°13ï¼Œå†™ä¸‹13 çº¿ç¨‹2ä¹Ÿå†™äº†13 ç°åœ¨æˆ‘ä»¬æœ‰13ä¸ªï¼Œä½†åº”è¯¥æ˜¯14ä¸ª Now we have 13, but it should be 14. è¿™æ˜¯ä¸ªå¤§é—®é¢˜ã€‚</li>
</ul>
<p><code>Arc</code>ä½¿ç”¨å¤„ç†å™¨æ¥ç¡®ä¿è¿™ç§æƒ…å†µä¸ä¼šå‘ç”Ÿï¼Œæ‰€ä»¥å½“ä½ æœ‰çº¿ç¨‹æ—¶å¿…é¡»ä½¿ç”¨è¿™ç§æ–¹æ³•ã€‚ä¸è¿‡ä¸å»ºè®®å•çº¿ç¨‹ä¸Šç”¨<code>Arc</code>ï¼Œå› ä¸º<code>Rc</code>æ›´å¿«ä¸€äº›ã€‚</p>
<p>ä¸è¿‡ä½ ä¸èƒ½åªç”¨ä¸€ä¸ª<code>Arc</code>æ¥æ”¹å˜æ•°æ®ã€‚æ‰€ä»¥ä½ ç”¨ä¸€ä¸ª<code>Mutex</code>æŠŠæ•°æ®åŒ…èµ·æ¥ï¼Œç„¶åç”¨ä¸€ä¸ª<code>Arc</code>æŠŠ<code>Mutex</code>åŒ…èµ·æ¥ã€‚</p>
<p>æ‰€ä»¥æˆ‘ä»¬ç”¨ä¸€ä¸ª<code>Mutex</code>åœ¨ä¸€ä¸ª<code>Arc</code>é‡Œé¢æ¥æ”¹å˜ä¸€ä¸ªæ•°å­—çš„å€¼ã€‚é¦–å…ˆæˆ‘ä»¬è®¾ç½®ä¸€ä¸ªçº¿ç¨‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        println!("The thread is working!") // Just testing the thread
    });

    handle.join().unwrap(); // Make the thread wait here until it is done
    println!("Exiting the program");
}</code></pre></pre>
<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¿™ä¸ªåªæ‰“å°:</p>
<pre><code class="language-text">The thread is working!
Exiting the program
</code></pre>
<p>å¾ˆå¥½ï¼Œç°åœ¨è®©æˆ‘ä»¬æŠŠå®ƒæ”¾åœ¨<code>for</code>çš„å¾ªç¯ä¸­ï¼Œè¿›è¡Œ<code>0..5</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        for _ in 0..5 {
            println!("The thread is working!")
        }
    });

    handle.join().unwrap();
    println!("Exiting the program");
}</code></pre></pre>
<p>è¿™ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚æˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ç»“æœ:</p>
<pre><code class="language-text">The thread is working!
The thread is working!
The thread is working!
The thread is working!
The thread is working!
Exiting the program
</code></pre>
<p>ç°åœ¨æˆ‘ä»¬å†åŠ ä¸€ä¸ªçº¿ç¨‹ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½ä¼šåšåŒæ ·çš„äº‹æƒ…ã€‚ä½ å¯ä»¥çœ‹åˆ°ï¼Œè¿™äº›çº¿ç¨‹æ˜¯åœ¨åŒä¸€æ—¶é—´å·¥ä½œçš„ã€‚æœ‰æ—¶ä¼šå…ˆæ‰“å°<code>Thread 1 is working!</code>ï¼Œä½†å…¶ä»–æ—¶å€™<code>Thread 2 is working!</code>å…ˆæ‰“å°ã€‚è¿™å°±æ˜¯æ‰€è°“çš„<strong>å¹¶å‘</strong>ï¼Œä¹Ÿå°±æ˜¯ "ä¸€èµ·è¿è¡Œ"çš„æ„æ€ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let thread1 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!("Thread 1 is working!")
        }
    });

    let thread2 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!("Thread 2 is working!")
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!("Exiting the program");
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Exiting the program
</code></pre>
<p>ç°åœ¨æˆ‘ä»¬è¦æ”¹å˜<code>my_number</code>çš„æ•°å€¼ã€‚ç°åœ¨å®ƒæ˜¯ä¸€ä¸ª<code>i32</code>ã€‚æˆ‘ä»¬å°†æŠŠå®ƒæ”¹ä¸º <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>:ä¸€ä¸ªå¯ä»¥æ”¹å˜çš„ <code>i32</code>ï¼Œç”± <code>Arc</code> ä¿æŠ¤ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
let my_number = Arc::new(Mutex::new(0));
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å…‹éš†å®ƒã€‚æ¯ä¸ªå…‹éš†å¯ä»¥è¿›å…¥ä¸åŒçš„çº¿ç¨‹ã€‚æˆ‘ä»¬æœ‰ä¸¤ä¸ªçº¿ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†åšä¸¤ä¸ªå…‹éš†ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
let my_number = Arc::new(Mutex::new(0));

let my_number1 = Arc::clone(&amp;my_number); // This clone goes into Thread 1
let my_number2 = Arc::clone(&amp;my_number); // This clone goes into Thread 2
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å°†å®‰å…¨å…‹éš†è¿æ¥åˆ°<code>my_number</code>ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬<code>move</code>åˆ°å…¶ä»–çº¿ç¨‹ä¸­ï¼Œæ²¡æœ‰é—®é¢˜ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));

    let my_number1 = Arc::clone(&amp;my_number);
    let my_number2 = Arc::clone(&amp;my_number);

    let thread1 = std::thread::spawn(move || { // Only the clone goes into Thread 1
        for _ in 0..10 {
            *my_number1.lock().unwrap() +=1; // Lock the Mutex, change the value
        }
    });

    let thread2 = std::thread::spawn(move || { // Only the clone goes into Thread 2
        for _ in 0..10 {
            *my_number2.lock().unwrap() += 1;
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!("Value is: {:?}", my_number);
    println!("Exiting the program");
}</code></pre></pre>
<p>ç¨‹åºæ‰“å°:</p>
<pre><code class="language-text">Value is: Mutex { data: 20 }
Exiting the program
</code></pre>
<p>æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªæˆåŠŸçš„æ¡ˆä¾‹ã€‚</p>
<p>ç„¶åæˆ‘ä»¬å¯ä»¥å°†ä¸¤ä¸ªçº¿ç¨‹è¿æ¥åœ¨ä¸€èµ·ï¼Œå½¢æˆä¸€ä¸ª<code>for</code>å¾ªç¯ï¼Œå¹¶ä½¿ä»£ç æ›´çŸ­ã€‚</p>
<p>æˆ‘ä»¬éœ€è¦ä¿å­˜å¥æŸ„ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨å¾ªç¯å¤–å¯¹æ¯ä¸ªçº¿ç¨‹è°ƒç”¨<code>.join()</code>ã€‚å¦‚æœæˆ‘ä»¬åœ¨å¾ªç¯å†…è¿™æ ·åšï¼Œå®ƒå°†ç­‰å¾…ç¬¬ä¸€ä¸ªçº¿ç¨‹å®Œæˆåå†å¯åŠ¨æ–°çš„çº¿ç¨‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));
    let mut handle_vec = vec![]; // JoinHandles will go in here

    for _ in 0..2 { // do this twice
        let my_number_clone = Arc::clone(&amp;my_number); // Make the clone before starting the thread
        let handle = std::thread::spawn(move || { // Put the clone in
            for _ in 0..10 {
                *my_number_clone.lock().unwrap() += 1;
            }
        });
        handle_vec.push(handle); // save the handle so we can call join on it outside of the loop
                                 // If we don't push it in the vec, it will just die here
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // call join on all handles
    println!("{:?}", my_number);
}</code></pre></pre>
<p>æœ€åè¿™ä¸ªæ‰“å°<code>Mutex { data: 20 }</code>ã€‚</p>
<p>è¿™çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œä½†<code>Arc&lt;Mutex&lt;SomeType&gt;&gt;&gt;</code>åœ¨Rustä¸­ä½¿ç”¨çš„é¢‘ç‡å¾ˆé«˜ï¼Œæ‰€ä»¥å®ƒå˜å¾—å¾ˆè‡ªç„¶ã€‚å¦å¤–ï¼Œä½ ä¹Ÿå¯ä»¥éšæ—¶å†™ä½ çš„ä»£ç ï¼Œè®©å®ƒæ›´å¹²å‡€ã€‚è¿™é‡Œæ˜¯åŒæ ·çš„ä»£ç ï¼Œå¤šäº†ä¸€æ¡<code>use</code>è¯­å¥å’Œä¸¤ä¸ªå‡½æ•°ã€‚è¿™äº›å‡½æ•°å¹¶æ²¡æœ‰åšä»»ä½•æ–°çš„äº‹æƒ…ï¼Œä½†æ˜¯å®ƒä»¬æŠŠä¸€äº›ä»£ç ä»<code>main()</code>ä¸­ç§»å‡ºã€‚å¦‚æœä½ å¾ˆéš¾è¯»æ‡‚çš„è¯ï¼Œå¯ä»¥å°è¯•é‡å†™è¿™æ ·çš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread::spawn; // Now we just write spawn

fn make_arc(number: i32) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // Just a function to make a Mutex in an Arc
    Arc::new(Mutex::new(number))
}

fn new_clone(input: &amp;Arc&lt;Mutex&lt;i32&gt;&gt;) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // Just a function so we can write new_clone
    Arc::clone(&amp;input)
}

// Now main() is easier to read
fn main() {
    let mut handle_vec = vec![]; // each handle will go in here
    let my_number = make_arc(0);

    for _ in 0..2 {
        let my_number_clone = new_clone(&amp;my_number);
        let handle = spawn(move || {
            for _ in 0..10 {
                let mut value_inside = my_number_clone.lock().unwrap();
                *value_inside += 1;
            }
        });
        handle_vec.push(handle);    // the handle is done, so put it in the vector
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // Make each one wait

    println!("{:?}", my_number);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>A channel is an easy way to use many threads that send to one place.å®ƒä»¬ç›¸å½“æµè¡Œï¼Œå› ä¸ºå®ƒä»¬å¾ˆå®¹æ˜“ç»„åˆåœ¨ä¸€èµ·ã€‚ä½ å¯ä»¥åœ¨Rustä¸­ç”¨<code>std::sync::mpsc</code>åˆ›å»ºä¸€ä¸ªchannelã€‚<code>mpsc</code>çš„æ„æ€æ˜¯ "å¤šä¸ªç”Ÿäº§è€…ï¼Œå•ä¸ªæ¶ˆè´¹è€…"ï¼Œæ‰€ä»¥ "many threads sending to one place"ã€‚è¦å¯åŠ¨ä¸€ä¸ªé€šé“ï¼Œä½ å¯ä»¥ä½¿ç”¨ <code>channel()</code>ã€‚è¿™å°†åˆ›å»ºä¸€ä¸ª <code>Sender</code> å’Œä¸€ä¸ª <code>Receiver</code>ï¼Œå®ƒä»¬è¢«ç»‘åœ¨ä¸€èµ·ã€‚ä½ å¯ä»¥åœ¨å‡½æ•°ç­¾åä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
pub fn channel&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;)
<span class="boring">}</span></code></pre></pre>
<p>æ‰€ä»¥ä½ è¦é€‰æ‹©ä¸€ä¸ªå‘é€è€…çš„åå­—å’Œä¸€ä¸ªæ¥æ”¶è€…çš„åå­—ã€‚é€šå¸¸ä½ ä¼šçœ‹åˆ°åƒ<code>let (sender, receiver) = channel();</code>è¿™æ ·çš„å¼€å¤´ã€‚å› ä¸ºå®ƒæ˜¯æ³›å‹å‡½æ•°ï¼Œå¦‚æœä½ åªå†™è¿™ä¸ªï¼ŒRustä¸ä¼šçŸ¥é“ç±»å‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel(); // âš ï¸
}</code></pre></pre>
<p>ç¼–è¯‘å™¨è¯´:</p>
<pre><code class="language-text">error[E0282]: type annotations needed for `(std::sync::mpsc::Sender&lt;T&gt;, std::sync::mpsc::Receiver&lt;T&gt;)`
  --&gt; src\main.rs:30:30
   |
30 |     let (sender, receiver) = channel();
   |         ------------------   ^^^^^^^ cannot infer type for type parameter `T` declared on the function `channel`
   |         |
   |         consider giving this pattern the explicit type `(std::sync::mpsc::Sender&lt;T&gt;, std::sync::mpsc::Receiver&lt;T&gt;)`, where
the type parameter `T` is specified
</code></pre>
<p>å®ƒå»ºè®®ä¸º<code>Sender</code>å’Œ<code>Receiver</code>æ·»åŠ ä¸€ä¸ªç±»å‹ã€‚å¦‚æœä½ æ„¿æ„çš„è¯ï¼Œå¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{channel, Sender, Receiver}; // Added Sender and Receiver here

fn main() {
    let (sender, receiver): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = channel();
}</code></pre></pre>
<p>ä½†ä½ ä¸å¿…è¿™æ ·åš: ä¸€æ—¦ä½ å¼€å§‹ä½¿ç”¨<code>Sender</code>å’Œ<code>Receiver</code>ï¼ŒRustå°±èƒ½çŒœåˆ°ç±»å‹ã€‚</p>
<p>æ‰€ä»¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æœ€ç®€å•çš„ä½¿ç”¨é€šé“çš„æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();

    sender.send(5);
    receiver.recv(); // recv = receive, not "rec v"
}</code></pre></pre>
<p>ç°åœ¨ç¼–è¯‘å™¨çŸ¥é“ç±»å‹äº†ã€‚<code>sender</code>æ˜¯<code>Result&lt;(), SendError&lt;i32&gt;&gt;</code>ï¼Œ<code>receiver</code>æ˜¯<code>Result&lt;i32, RecvError&gt;</code>ã€‚æ‰€ä»¥ä½ å¯ä»¥ç”¨<code>.unwrap()</code>æ¥çœ‹çœ‹å‘é€æ˜¯å¦æœ‰æ•ˆï¼Œæˆ–è€…ä½¿ç”¨æ›´å¥½çš„é”™è¯¯å¤„ç†ã€‚æˆ‘ä»¬åŠ ä¸Š<code>.unwrap()</code>ï¼Œä¹ŸåŠ ä¸Š<code>println!</code>ï¼Œçœ‹çœ‹å¾—åˆ°ä»€ä¹ˆã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();

    sender.send(5).unwrap();
    println!("{}", receiver.recv().unwrap());
}</code></pre></pre>
<p>è¿™æ ·å°±å¯ä»¥æ‰“å°å‡º<code>5</code>ã€‚</p>
<p><code>channel</code>å°±åƒ<code>Arc</code>ä¸€æ ·ï¼Œå› ä¸ºä½ å¯ä»¥å…‹éš†å®ƒï¼Œå¹¶å°†å…‹éš†çš„å†…å®¹å‘é€åˆ°å…¶ä»–çº¿ç¨‹ä¸­ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸¤ä¸ªçº¿ç¨‹ï¼Œå¹¶å°†å€¼å‘é€åˆ°<code>receiver</code>ã€‚è¿™æ®µä»£ç å¯ä»¥å·¥ä½œï¼Œä½†å®ƒå¹¶ä¸å®Œå…¨æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();

    std::thread::spawn(move|| { // move sender in
        sender.send("Send a &amp;str this time").unwrap();
    });

    std::thread::spawn(move|| { // move sender_clone in
        sender_clone.send("And here is another &amp;str").unwrap();
    });

    println!("{}", receiver.recv().unwrap());
}</code></pre></pre>
<p>ä¸¤ä¸ªçº¿ç¨‹å¼€å§‹å‘é€ï¼Œç„¶åæˆ‘ä»¬<code>println!</code>ã€‚å®ƒå¯èƒ½ä¼šæ‰“å° <code>Send a &amp;str this time</code> æˆ– <code>And here is another &amp;str</code>ï¼Œè¿™å–å†³äºå“ªä¸ªçº¿ç¨‹å…ˆå®Œæˆã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªjoinå¥æŸ„æ¥ç­‰å¾…å®ƒä»¬å®Œæˆã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![]; // Put our handles in here

    handle_vec.push(std::thread::spawn(move|| {  // push this into the vec
        sender.send("Send a &amp;str this time").unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {  // and push this into the vec
        sender_clone.send("And here is another &amp;str").unwrap();
    }));

    for _ in handle_vec { // now handle_vec has 2 items. Let's print them
        println!("{:?}", receiver.recv().unwrap());
    }
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">"Send a &amp;str this time"
"And here is another &amp;str"
</code></pre>
<p>ç°åœ¨æˆ‘ä»¬ä¸æ‰“å°ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª<code>results_vec</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;

fn main() {
    let (sender, receiver) = channel();
    let sender_clone = sender.clone();
    let mut handle_vec = vec![];
    let mut results_vec = vec![];

    handle_vec.push(std::thread::spawn(move|| {
        sender.send("Send a &amp;str this time").unwrap();
    }));

    handle_vec.push(std::thread::spawn(move|| {
        sender_clone.send("And here is another &amp;str").unwrap();
    }));

    for _ in handle_vec {
        results_vec.push(receiver.recv().unwrap());
    }

    println!("{:?}", results_vec);
}</code></pre></pre>
<p>ç°åœ¨ç»“æœåœ¨æˆ‘ä»¬çš„vecä¸­:<code>["Send a &amp;str this time", "And here is another &amp;str"]</code>ã€‚</p>
<p>ç°åœ¨è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰å¾ˆå¤šå·¥ä½œè¦åšï¼Œå¹¶ä¸”æƒ³è¦ä½¿ç”¨çº¿ç¨‹ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªå¤§çš„VECï¼Œé‡Œé¢æœ‰1ç™¾ä¸‡ä¸ªå…ƒç´ ï¼Œéƒ½æ˜¯0ï¼Œæˆ‘ä»¬æƒ³æŠŠæ¯ä¸ª0éƒ½å˜æˆ1ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨10ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹å°†åšååˆ†ä¹‹ä¸€çš„å·¥ä½œã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªæ–°çš„VECï¼Œå¹¶ä½¿ç”¨<code>.extend()</code>æ¥æ”¶é›†ç»“æœã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;
use std::thread::spawn;

fn main() {
    let (sender, receiver) = channel();
    let hugevec = vec![0; 1_000_000];
    let mut newvec = vec![];
    let mut handle_vec = vec![];

    for i in 0..10 {
        let sender_clone = sender.clone();
        let mut work: Vec&lt;u8&gt; = Vec::with_capacity(hugevec.len() / 10); // new vec to put the work in. 1/10th the size
        work.extend(&amp;hugevec[i*100_000..(i+1)*100_000]); // first part gets 0..100_000, next gets 100_000..200_000, etc.
        let handle =spawn(move || { // make a handle

            for number in work.iter_mut() { // do the actual work
                *number += 1;
            };
            sender_clone.send(work).unwrap(); // use the sender_clone to send the work to the receiver
        });
        handle_vec.push(handle);
    }

    for handle in handle_vec { // stop until the threads are done
        handle.join().unwrap();
    }

    while let Ok(results) = receiver.try_recv() {
        newvec.push(results); // push the results from receiver.recv() into the vec
    }

    // Now we have a Vec&lt;Vec&lt;u8&gt;&gt;. To put it together we can use .flatten()
    let newvec = newvec.into_iter().flatten().collect::&lt;Vec&lt;u8&gt;&gt;(); // Now it's one vec of 1_000_000 u8 numbers

    println!("{:?}, {:?}, total length: {}", // Let's print out some numbers to make sure they are all 1
        &amp;newvec[0..10], &amp;newvec[newvec.len()-10..newvec.len()], newvec.len() // And show that the length is 1_000_000 items
    );

    for number in newvec { // And let's tell Rust that it can panic if even one number is not 1
        if number != 1 {
            panic!();
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é˜…è¯»rustæ–‡æ¡£"><a class="header" href="#é˜…è¯»rustæ–‡æ¡£">é˜…è¯»Rustæ–‡æ¡£</a></h2>
<p>çŸ¥é“å¦‚ä½•é˜…è¯»Rustä¸­çš„æ–‡æ¡£æ˜¯å¾ˆé‡è¦çš„ï¼Œè¿™æ ·ä½ å°±å¯ä»¥ç†è§£å…¶ä»–äººå†™çš„ä¸œè¥¿ã€‚è¿™é‡Œæœ‰ä¸€äº›Rustæ–‡æ¡£ä¸­éœ€è¦çŸ¥é“çš„äº‹æƒ…ã€‚</p>
<h3 id="assert_eq"><a class="header" href="#assert_eq">assert_eq!</a></h3>
<p>ä½ åœ¨åšæµ‹è¯•çš„æ—¶å€™çœ‹åˆ°<code>assert_eq!</code>æ˜¯ç”¨çš„ã€‚ä½ æŠŠä¸¤ä¸ªå…ƒç´ æ”¾åœ¨å‡½æ•°é‡Œé¢ï¼Œå¦‚æœå®ƒä»¬ä¸ç›¸ç­‰ï¼Œç¨‹åºå°±ä¼šå´©æºƒã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¶æ•°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    prints_number(56);
}

fn prints_number(input: i32) {
    assert_eq!(input % 2, 0); // number must be equal.
                              // If number % 2 is not 0, it panics
    println!("The number is not odd. It is {}", input);
}</code></pre></pre>
<p>ä¹Ÿè®¸ä½ æ²¡æœ‰ä»»ä½•è®¡åˆ’åœ¨ä½ çš„ä»£ç ä¸­ä½¿ç”¨<code>assert_eq!</code>ï¼Œä½†å®ƒåœ¨Rustæ–‡æ¡£ä¸­éšå¤„å¯è§ã€‚è¿™æ˜¯å› ä¸ºåœ¨ä¸€ä¸ªæ–‡æ¡£ä¸­ï¼Œä½ éœ€è¦å¾ˆå¤§çš„ç©ºé—´æ¥<code>println!</code>ä¸€åˆ‡ã€‚å¦å¤–ï¼Œä½ ä¼šéœ€è¦<code>Display</code>æˆ–<code>Debug</code>æ¥æ‰“å°ä½ æƒ³æ‰“å°çš„ä¸œè¥¿ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ–‡æ¡£ä¸­åˆ°å¤„éƒ½æœ‰<code>assert_eq!</code>çš„åŸå› ã€‚ä¸‹é¢æ˜¯è¿™é‡Œçš„ä¸€ä¸ªä¾‹å­<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a>ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨Vecã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2);
    assert_eq!(vec[0], 1);

    assert_eq!(vec.pop(), Some(2));
    assert_eq!(vec.len(), 1);

    vec[0] = 7;
    assert_eq!(vec[0], 7);

    vec.extend([1, 2, 3].iter().copied());

    for x in &amp;vec {
        println!("{}", x);
    }
    assert_eq!(vec, [7, 1, 2, 3]);
}</code></pre></pre>
<p>åœ¨è¿™äº›ä¾‹å­ä¸­ï¼Œä½ å¯ä»¥åªæŠŠ<code>assert_eq!(a, b)</code>çœ‹æˆæ˜¯åœ¨è¯´ "aæ˜¯b"ã€‚ç°åœ¨çœ‹çœ‹å³è¾¹å¸¦æœ‰æ³¨é‡Šçš„åŒä¸€ä¸ªä¾‹å­ã€‚æ³¨é‡Šæ˜¾ç¤ºäº†å®ƒçš„å®é™…å«ä¹‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2); // "The vec length is 2"
    assert_eq!(vec[0], 1); // "vec[0] is 1"

    assert_eq!(vec.pop(), Some(2)); // "When you use .pop(), you get Some()"
    assert_eq!(vec.len(), 1); // "The vec length is now 1"

    vec[0] = 7;
    assert_eq!(vec[0], 7); // "Vec[0] is 7"

    vec.extend([1, 2, 3].iter().copied());

    for x in &amp;vec {
        println!("{}", x);
    }
    assert_eq!(vec, [7, 1, 2, 3]); // "The vec now has [7, 1, 2, 3]"
}</code></pre></pre>
<h3 id="æœç´¢"><a class="header" href="#æœç´¢">æœç´¢</a></h3>
<p>Rust æ–‡æ¡£çš„é¡¶éƒ¨æ æ˜¯æœç´¢æ ã€‚å®ƒåœ¨ä½ è¾“å…¥æ—¶æ˜¾ç¤ºç»“æœã€‚å½“ä½ å¾€ä¸‹ç¿»æ—¶ï¼Œä½ ä¸èƒ½å†çœ‹åˆ°æœç´¢æ ï¼Œä½†å¦‚æœä½ æŒ‰é”®ç›˜ä¸Šçš„<strong>s</strong>é”®ï¼Œä½ å¯ä»¥å†æ¬¡æœç´¢ã€‚æ‰€ä»¥åœ¨ä»»ä½•åœ°æ–¹æŒ‰<strong>s</strong>é”®å¯ä»¥è®©ä½ é©¬ä¸Šæœç´¢ã€‚</p>
<h3 id="src-æŒ‰é’®"><a class="header" href="#src-æŒ‰é’®">[src] æŒ‰é’®</a></h3>
<p>é€šå¸¸ä¸€ä¸ªæ–¹æ³•ã€ç»“æ„ä½“ç­‰çš„ä»£ç ä¸ä¼šæ˜¯å®Œæ•´çš„ã€‚è¿™æ˜¯å› ä¸ºä½ é€šå¸¸ä¸éœ€è¦çœ‹åˆ°å®Œæ•´çš„æºç å°±èƒ½çŸ¥é“å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œè€Œå®Œæ•´çš„ä»£ç å¯èƒ½ä¼šè®©äººå›°æƒ‘ã€‚ä½†å¦‚æœä½ æƒ³çŸ¥é“æ›´å¤šï¼Œä½ å¯ä»¥ç‚¹å‡»[src]å°±å¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œåœ¨<code>String</code>çš„é¡µé¢ä¸Šï¼Œä½ å¯ä»¥çœ‹åˆ°<code>.with_capacity()</code>çš„è¿™ä¸ªç­¾åã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
pub fn with_capacity(capacity: usize) -&gt; String
<span class="boring">}</span></code></pre></pre>
<p>å¥½äº†ï¼Œä½ è¾“å…¥ä¸€ä¸ªæ•°å­—ï¼Œå®ƒç»™ä½ ä¸€ä¸ª<code>String</code>ã€‚è¿™å¾ˆç®€å•ï¼Œä½†ä¹Ÿè®¸æˆ‘ä»¬å¾ˆå¥½å¥‡ï¼Œæƒ³çœ‹æ›´å¤šã€‚å¦‚æœä½ ç‚¹å‡»[src]ä½ å¯ä»¥çœ‹åˆ°è¿™ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
pub fn with_capacity(capacity: usize) -&gt; String {
    String { vec: Vec::with_capacity(capacity) }
}
<span class="boring">}</span></code></pre></pre>
<p>æœ‰è¶£çš„æ˜¯ï¼Œç°åœ¨ä½ å¯ä»¥çœ‹åˆ°ï¼Œå­—ç¬¦ä¸²æ˜¯<code>Vec</code>çš„ä¸€ç§ã€‚è€Œå®é™…ä¸Šä¸€ä¸ª<code>String</code>æ˜¯ä¸€ä¸ª<code>u8</code>å­—èŠ‚çš„å‘é‡ï¼Œè¿™å¾ˆæœ‰æ„æ€ã€‚ä½ ä¸éœ€è¦çŸ¥é“ï¼Œå°±å¯ä»¥ä½¿ç”¨<code>with_capacity</code>çš„æ–¹æ³•ï¼Œä½ åªæœ‰ç‚¹å‡»[src]æ‰èƒ½çœ‹åˆ°ã€‚æ‰€ä»¥å¦‚æœæ–‡æ¡£æ²¡æœ‰å¤ªå¤šç»†èŠ‚ï¼Œè€Œä½ åˆæƒ³çŸ¥é“æ›´å¤šçš„è¯ï¼Œç‚¹å‡»[src]æ˜¯ä¸ªå¥½ä¸»æ„ã€‚</p>
<h3 id="traitä¿¡æ¯"><a class="header" href="#traitä¿¡æ¯">traitä¿¡æ¯</a></h3>
<p>traitæ–‡æ¡£çš„é‡è¦éƒ¨åˆ†æ˜¯å·¦è¾¹çš„ "Required Methods"ã€‚å¦‚æœä½ çœ‹åˆ° "Required Methods"ï¼Œå¯èƒ½æ„å‘³ç€ä½ å¿…é¡»è‡ªå·±ç¼–å†™æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œå¯¹äº <code>Iterator</code>ï¼Œä½ éœ€è¦å†™ <code>.next()</code> æ–¹æ³•ã€‚è€Œå¯¹äº<code>From</code>ï¼Œä½ éœ€è¦å†™<code>.from()</code>æ–¹æ³•ã€‚ä½†æ˜¯æœ‰äº›traitåªéœ€è¦ä¸€ä¸ª<strong>å±æ€§</strong>å°±å¯ä»¥å®ç°ï¼Œæ¯”å¦‚æˆ‘ä»¬åœ¨<code>#[derive(Debug)]</code>ä¸­çœ‹åˆ°çš„ã€‚<code>Debug</code>éœ€è¦<code>.fmt()</code>æ–¹æ³•ï¼Œä½†é€šå¸¸ä½ åªéœ€è¦ä½¿ç”¨<code>#[derive(Debug)]</code>ï¼Œé™¤éä½ æƒ³è‡ªå·±åšã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨<code>std::fmt::Debug</code>çš„é¡µé¢ä¸Šè¯´ "ä¸€èˆ¬æ¥è¯´ï¼Œä½ åº”è¯¥ç›´æ¥æ´¾ç”Ÿå‡ºä¸€ä¸ªDebugå®ç°"ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å±æ€§"><a class="header" href="#å±æ€§">å±æ€§</a></h2>
<p>ä½ ä»¥å‰è§è¿‡<code>#[derive(Debug)]</code>è¿™æ ·çš„ä»£ç :è¿™ç§ç±»å‹çš„ä»£ç å«åš<em>å±æ€§</em>ã€‚è¿™äº›å±æ€§æ˜¯ç»™ç¼–è¯‘å™¨æä¾›ä¿¡æ¯çš„å°æ®µä»£ç ã€‚å®ƒä»¬ä¸å®¹æ˜“åˆ›å»ºï¼Œä½†ä½¿ç”¨èµ·æ¥éå¸¸æ–¹ä¾¿ã€‚å¦‚æœä½ åªç”¨<code>#</code>å†™ä¸€ä¸ªå±æ€§ï¼Œé‚£ä¹ˆå®ƒå°†å½±å“ä¸‹ä¸€è¡Œçš„ä»£ç ã€‚ä½†å¦‚æœä½ ç”¨<code>#!</code>æ¥å†™ï¼Œé‚£ä¹ˆå®ƒå°†å½±å“è‡ªå·±ç©ºé—´é‡Œçš„ä¸€åˆ‡ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€äº›ä½ ä¼šç»å¸¸çœ‹åˆ°çš„å±æ€§ã€‚</p>
<p><code>#[allow(dead_code)]</code> å’Œ <code>#[allow(unused_variables)]</code>ã€‚ å¦‚æœä½ å†™äº†ä¸ç”¨çš„ä»£ç ï¼ŒRustä»ç„¶ä¼šç¼–è¯‘ï¼Œä½†ä¼šè®©ä½ çŸ¥é“ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªç»“æ„ä½“ï¼Œé‡Œé¢ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œåªæœ‰ä¸€ä¸ªå˜é‡ã€‚æˆ‘ä»¬ä¸ä½¿ç”¨å®ƒä»¬ä¸­çš„ä»»ä½•ä¸€ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct JustAStruct {}

fn main() {
    let some_char = 'ã‚“';
}</code></pre></pre>
<p>å¦‚æœä½ è¿™æ ·å†™ï¼ŒRustä¼šæé†’ä½ ï¼Œä½ æ²¡æœ‰ä½¿ç”¨å®ƒä»¬ã€‚</p>
<pre><code class="language-text">warning: unused variable: `some_char`
 --&gt; src\main.rs:4:9
  |
4 |     let some_char = 'ã‚“';
  |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_some_char`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: struct is never constructed: `JustAStruct`
 --&gt; src\main.rs:1:8
  |
1 | struct JustAStruct {}
  |        ^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default
</code></pre>
<p>æˆ‘ä»¬çŸ¥é“ï¼Œå¯ä»¥åœ¨åå­—å‰å†™ä¸€ä¸ª<code>_</code>ï¼Œè®©ç¼–è¯‘å™¨å®‰é™ä¸‹æ¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct _JustAStruct {}

fn main() {
    let _some_char = 'ã‚“';
}</code></pre></pre>
<p>ä½†ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å±æ€§ã€‚ä½ ä¼šæ³¨æ„åˆ°åœ¨æ¶ˆæ¯ä¸­ï¼Œå®ƒä½¿ç”¨äº†<code>#[warn(unused_variables)]</code>å’Œ<code>#[warn(dead_code)]</code>ã€‚åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­ï¼Œ<code>JustAStruct</code>æ˜¯æ­»ä»£ç ï¼Œè€Œ<code>some_char</code>æ˜¯ä¸€ä¸ªæœªä½¿ç”¨çš„å˜é‡ã€‚<code>warn</code>çš„åä¹‰è¯æ˜¯<code>allow</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼Œå®ƒä¸ä¼šè¯´ä»€ä¹ˆã€‚</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)]
#![allow(unused_variables)]

struct Struct1 {} // Create five structs
struct Struct2 {}
struct Struct3 {}
struct Struct4 {}
struct Struct5 {}

fn main() {
    let char1 = 'ã‚“'; // and four variables. We don't use any of them but the compiler is quiet
    let char2 = ';';
    let some_str = "I'm just a regular &amp;str";
    let some_vec = vec!["I", "am", "just", "a", "vec"];
}</code></pre></pre>
<p>å½“ç„¶ï¼Œå¤„ç†æ­»ä»£ç å’Œæœªä½¿ç”¨çš„å˜é‡æ˜¯å¾ˆé‡è¦çš„ã€‚ä½†æœ‰æ—¶ä½ å¸Œæœ›ç¼–è¯‘å™¨å®‰é™ä¸€æ®µæ—¶é—´ã€‚æˆ–è€…æ‚¨å¯èƒ½éœ€è¦å±•ç¤ºä¸€äº›ä»£ç æˆ–æ•™äººä»¬Rustï¼Œä½†åˆä¸æƒ³ç”¨ç¼–è¯‘å™¨çš„ä¿¡æ¯æ¥è¿·æƒ‘ä»–ä»¬ã€‚</p>
<p><code>#[derive(TraitName)]</code>è®©ä½ å¯ä»¥ä¸ºä½ åˆ›å»ºçš„ç»“æ„å’Œæšä¸¾æ´¾ç”Ÿä¸€äº›traitã€‚è¿™é€‚ç”¨äºè®¸å¤šå¯ä»¥è‡ªåŠ¨æ´¾ç”Ÿçš„å¸¸è§traitã€‚æœ‰äº›åƒ <code>Display</code> è¿™æ ·çš„ç‰¹æ€§ä¸èƒ½è‡ªåŠ¨è¡ç”Ÿï¼Œå› ä¸ºå¯¹äº <code>Display</code>ï¼Œä½ å¿…é¡»é€‰æ‹©å¦‚ä½•æ˜¾ç¤ºã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
#[derive(Display)]
struct HoldsAString {
    the_string: String,
}

fn main() {
    let my_string = HoldsAString {
        the_string: "Here I am!".to_string(),
    };
}</code></pre></pre>
<p>é”™è¯¯ä¿¡æ¯ä¼šå‘Šè¯‰ä½ :</p>
<pre><code class="language-text">error: cannot find derive macro `Display` in this scope
 --&gt; src\main.rs:2:10
  |
2 | #[derive(Display)]
  |
</code></pre>
<p>ä½†æ˜¯å¯¹äºå¯ä»¥è‡ªåŠ¨æ¨å¯¼å‡ºçš„traitï¼Œä½ å¯ä»¥éšå¿ƒæ‰€æ¬²çš„æ”¾è¿›å»ã€‚è®©æˆ‘ä»¬ç»™<code>HoldsAString</code>åœ¨ä¸€è¡Œä¸­åŠ å…¥ä¸ƒä¸ªtraitï¼Œåªæ˜¯ä¸ºäº†å¥½ç©ï¼Œå°½ç®¡å®ƒåªéœ€è¦ä¸€ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, PartialEq, Eq, Ord, PartialOrd, Hash, Clone)]
struct HoldsAString {
    the_string: String,
}

fn main() {
    let my_string = HoldsAString {
        the_string: "Here I am!".to_string(),
    };
    println!("{:?}", my_string);
}</code></pre></pre>
<p>å¦å¤–ï¼Œå¦‚æœ(ä¹Ÿåªæœ‰åœ¨)å®ƒçš„å­—æ®µéƒ½å®ç°äº†<code>Copy</code>çš„æƒ…å†µä¸‹ï¼Œä½ æ‰å¯ä»¥åˆ›å»ºä¸€ä¸ª<code>Copy</code>ç»“æ„ã€‚<code>HoldsAString</code>åŒ…å«<code>String</code>ï¼Œå®ƒæ²¡æœ‰å®ç°<code>Copy</code>ï¼Œæ‰€ä»¥ä½ ä¸èƒ½å¯¹å®ƒä½¿ç”¨<code>#[derive(Copy)]</code>ã€‚ä½†æ˜¯å¯¹ä¸‹é¢è¿™ä¸ªç»“æ„ä½ å¯ä»¥:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // You also need Clone to use Copy
struct NumberAndBool {
    number: i32, // i32 is Copy
    true_or_false: bool // bool is also Copy. So no problem
}

fn does_nothing(input: NumberAndBool) {

}

fn main() {
    let number_and_bool = NumberAndBool {
        number: 8,
        true_or_false: true
    };

    does_nothing(number_and_bool);
    does_nothing(number_and_bool); // If it didn't have copy, this would make an error
}</code></pre></pre>
<p><code>#[cfg()]</code>çš„æ„æ€æ˜¯é…ç½®ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨æ˜¯å¦è¿è¡Œä»£ç ã€‚å®ƒé€šå¸¸æ˜¯è¿™æ ·çš„:<code>#[cfg(test)]</code>ã€‚ä½ åœ¨å†™æµ‹è¯•å‡½æ•°çš„æ—¶å€™ç”¨è¿™ä¸ªï¼Œè¿™æ ·å®ƒå°±çŸ¥é“é™¤éä½ åœ¨æµ‹è¯•ï¼Œå¦åˆ™ä¸è¦è¿è¡Œå®ƒä»¬ã€‚é‚£ä¹ˆä½ å¯ä»¥åœ¨ä½ çš„ä»£ç é™„è¿‘å†™æµ‹è¯•ï¼Œä½†ç¼–è¯‘å™¨ä¸ä¼šè¿è¡Œå®ƒä»¬ï¼Œé™¤éä½ å‘Šè¯‰ç¼–è¯‘å™¨ã€‚</p>
<p>è¿˜æœ‰ä¸€ä¸ªä½¿ç”¨<code>cfg</code>çš„ä¾‹å­æ˜¯<code>#[cfg(target_os = "windows")]</code>ã€‚æœ‰äº†å®ƒï¼Œä½ å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨åªåœ¨Windowsï¼ŒLinuxæˆ–å…¶ä»–å¹³å°åˆ™ä¸èƒ½è¿è¡Œä»£ç ã€‚</p>
<p><code>#![no_std]</code>æ˜¯ä¸€ä¸ªæœ‰è¶£çš„å±æ€§ï¼Œå®ƒå‘Šè¯‰Rustä¸è¦å¼•å…¥æ ‡å‡†åº“ã€‚è¿™æ„å‘³ç€ä½ æ²¡æœ‰<code>Vec</code>ï¼Œ<code>String</code>ï¼Œä»¥åŠæ ‡å‡†åº“ä¸­çš„å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚ä½ ä¼šåœ¨é‚£äº›æ²¡æœ‰å¤šå°‘å†…å­˜æˆ–ç©ºé—´çš„å°å‹è®¾å¤‡çš„ä»£ç ä¸­çœ‹åˆ°è¿™ä¸ªã€‚</p>
<p>ä½ å¯ä»¥åœ¨<a href="https://doc.rust-lang.org/reference/attributes.html">è¿™é‡Œ</a>çœ‹åˆ°æ›´å¤šçš„å±æ€§ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="box"><a class="header" href="#box">Box</a></h2>
<p><code>Box</code> æ˜¯ Rust ä¸­ä¸€ä¸ªéå¸¸æ–¹ä¾¿çš„ç±»å‹ã€‚å½“ä½ ä½¿ç”¨<code>Box</code>æ—¶ï¼Œä½ å¯ä»¥æŠŠä¸€ä¸ªç±»å‹æ”¾åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šã€‚è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ <code>Box</code>ï¼Œåªéœ€ä½¿ç”¨ <code>Box::new()</code> å¹¶å°†å…ƒç´ æ”¾åœ¨é‡Œé¢å³å¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn just_takes_a_variable&lt;T&gt;(item: T) {} // Takes anything and drops it.

fn main() {
    let my_number = 1; // This is an i32
    just_takes_a_variable(my_number);
    just_takes_a_variable(my_number); // Using this function twice is no problem, because it's Copy

    let my_box = Box::new(1); // This is a Box&lt;i32&gt;
    just_takes_a_variable(my_box.clone()); // Without .clone() the second function would make an error
    just_takes_a_variable(my_box); // because Box is not Copy
}</code></pre></pre>
<p>ä¸€å¼€å§‹å¾ˆéš¾æƒ³è±¡åœ¨å“ªé‡Œä½¿ç”¨å®ƒï¼Œä½†ä½ åœ¨Rustä¸­ç»å¸¸ä½¿ç”¨å®ƒã€‚ä½ è®°å¾—<code>&amp;</code>æ˜¯ç”¨äº<code>str</code>çš„ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸çŸ¥é“<code>str</code>çš„å¤§å°:å®ƒå¯ä»¥æ˜¯ä»»ä½•é•¿åº¦ã€‚ä½†æ˜¯<code>&amp;</code>çš„å¼•ç”¨æ€»æ˜¯ç›¸åŒçš„é•¿åº¦ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å¯ä»¥ä½¿ç”¨å®ƒã€‚<code>Box</code>ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚å¦å¤–ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨<code>Box</code>ä¸Šä½¿ç”¨<code>*</code>æ¥è·å–å€¼ï¼Œå°±åƒä½¿ç”¨<code>&amp;</code>ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_box = Box::new(1); // This is a Box&lt;i32&gt;
    let an_integer = *my_box; // This is an i32
    println!("{:?}", my_box);
    println!("{:?}", an_integer);
}</code></pre></pre>
<p>è¿™å°±æ˜¯ä¸ºä»€ä¹ˆBoxè¢«ç§°ä¸º "æ™ºèƒ½æŒ‡é’ˆ"çš„åŸå› ï¼Œå› ä¸ºå®ƒå°±åƒ<code>&amp;</code>çš„å¼•ç”¨(æŒ‡é’ˆçš„ä¸€ç§)ï¼Œä½†å¯ä»¥åšæ›´å¤šçš„äº‹æƒ…ã€‚</p>
<p>ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨Boxæ¥åˆ›å»ºé‡Œé¢æœ‰ç›¸åŒç»“æ„çš„ç»“æ„ä½“ã€‚è¿™äº›ç»“æ„è¢«ç§°ä¸º<em>é€’å½’</em>ï¼Œè¿™æ„å‘³ç€åœ¨Struct Aé‡Œé¢ä¹Ÿè®¸æ˜¯å¦ä¸€ä¸ªStruct Aï¼Œæœ‰æ—¶ä½ å¯ä»¥ä½¿ç”¨Boxæ¥åˆ›å»ºé“¾è¡¨ï¼Œå°½ç®¡è¿™åœ¨Rustä¸­å¹¶ä¸ååˆ†æµè¡Œã€‚ä½†å¦‚æœä½ æƒ³åˆ›å»ºä¸€ä¸ªé€’å½’ç»“æ„ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>Box</code>ã€‚å¦‚æœä½ è¯•ç€ä¸ç”¨ <code>Box</code> ä¼šå‘ç”Ÿä»€ä¹ˆ:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct List {
    item: Option&lt;List&gt;, // âš ï¸
}
<span class="boring">}</span></code></pre></pre>
<p>è¿™ä¸ªç®€å•çš„<code>List</code>æœ‰ä¸€é¡¹ï¼Œå¯èƒ½æ˜¯<code>Some&lt;List&gt;</code>(å¦ä¸€ä¸ªåˆ—è¡¨)ï¼Œä¹Ÿå¯èƒ½æ˜¯<code>None</code>ã€‚å› ä¸ºä½ å¯ä»¥é€‰æ‹©<code>None</code>ï¼Œæ‰€ä»¥å®ƒä¸ä¼šæ°¸è¿œé€’å½’ã€‚ä½†æ˜¯ç¼–è¯‘å™¨è¿˜æ˜¯ä¸çŸ¥é“å¤§å°ã€‚</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
  --&gt; src\main.rs:16:1
   |
16 | struct List {
   | ^^^^^^^^^^^ recursive type has infinite size
17 |     item: Option&lt;List&gt;,
   |     ------------------ recursive without indirection
   |
   = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œå®ƒç”šè‡³å»ºè®®å°è¯•<code>Box</code>ã€‚æ‰€ä»¥æˆ‘ä»¬ç”¨<code>Box</code>æŠŠListåŒ…è£¹èµ·æ¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct List {
    item: Option&lt;Box&lt;List&gt;&gt;,
}
fn main() {}</code></pre></pre>
<p>ç°åœ¨ç¼–è¯‘å™¨ç”¨<code>List</code>å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ‰€æœ‰çš„ä¸œè¥¿éƒ½åœ¨<code>Box</code>åé¢ï¼Œè€Œä¸”å®ƒçŸ¥é“<code>Box</code>çš„å¤§å°ã€‚é‚£ä¹ˆä¸€ä¸ªéå¸¸ç®€å•çš„åˆ—è¡¨å¯èƒ½æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">struct List {
    item: Option&lt;Box&lt;List&gt;&gt;,
}

impl List {
    fn new() -&gt; List {
        List {
            item: Some(Box::new(List { item: None })),
        }
    }
}

fn main() {
    let mut my_list = List::new();
}</code></pre></pre>
<p>å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿæœ‰ç‚¹å¤æ‚ï¼ŒRustå¹¶ä¸æ€ä¹ˆä½¿ç”¨è¿™ç§ç±»å‹çš„æ¨¡å¼ã€‚è¿™æ˜¯å› ä¸ºRustå¯¹å€Ÿç”¨å’Œæ‰€æœ‰æƒæœ‰ä¸¥æ ¼çš„è§„å®šï¼Œä½ çŸ¥é“çš„ã€‚ä½†å¦‚æœä½ æƒ³å¯åŠ¨ä¸€ä¸ªè¿™æ ·çš„åˆ—è¡¨(é“¾è¡¨)ï¼Œ<code>Box</code>å¯ä»¥å¸®åŠ©ä½ ã€‚</p>
<p><code>Box</code>è¿˜å¯ä»¥è®©ä½ åœ¨ä¸Šé¢ä½¿ç”¨<code>std::mem::drop</code>ï¼Œå› ä¸ºå®ƒåœ¨å †ä¸Šã€‚è¿™æœ‰æ—¶ä¼šå¾ˆæ–¹ä¾¿ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç”¨boxåŒ…è£¹trait"><a class="header" href="#ç”¨boxåŒ…è£¹trait">ç”¨BoxåŒ…è£¹trait</a></h2>
<p><code>Box</code>å¯¹äºè¿”å›traitéå¸¸æœ‰ç”¨ã€‚ä½ å¯ä»¥åƒè¿™ä¸ªä¾‹å­ä¸€æ ·ç”¨æ³›å‹å‡½æ•°å†™trait:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

struct DoesntImplementDisplay {}

fn displays_it&lt;T: Display&gt;(input: T) {
    println!("{}", input);
}

fn main() {}</code></pre></pre>
<p>è¿™ä¸ªåªèƒ½æ¥å—<code>Display</code>çš„ä¸œè¥¿ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ¥å—æˆ‘ä»¬çš„<code>DoesntImplementDisplay</code>ç»“æ„ã€‚ä½†æ˜¯å®ƒå¯ä»¥æ¥å—å¾ˆå¤šå…¶ä»–çš„ä¸œè¥¿ï¼Œæ¯”å¦‚<code>String</code>ã€‚</p>
<p>ä½ ä¹Ÿçœ‹åˆ°äº†ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>impl Trait</code> æ¥è¿”å›å…¶ä»–çš„traitï¼Œæˆ–è€…é—­åŒ…ã€‚<code>Box</code>ä¹Ÿå¯ä»¥ç”¨ç±»ä¼¼çš„æ–¹å¼ä½¿ç”¨ã€‚ä½ å¯ä»¥ä½¿ç”¨ <code>Box</code>ï¼Œå¦åˆ™ç¼–è¯‘å™¨å°†ä¸çŸ¥é“å€¼çš„å¤§å°ã€‚è¿™ä¸ªä¾‹å­è¡¨æ˜ï¼Œtraitå¯ä»¥ç”¨åœ¨ä»»ä½•å¤§å°çš„ä¸œè¥¿ä¸Š:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)] // Tell the compiler to be quiet
use std::mem::size_of; // This gives the size of a type

trait JustATrait {} // We will implement this on everything

enum EnumOfNumbers {
    I8(i8),
    AnotherI8(i8),
    OneMoreI8(i8),
}
impl JustATrait for EnumOfNumbers {}

struct StructOfNumbers {
    an_i8: i8,
    another_i8: i8,
    one_more_i8: i8,
}
impl JustATrait for StructOfNumbers {}

enum EnumOfOtherTypes {
    I8(i8),
    AnotherI8(i8),
    Collection(Vec&lt;String&gt;),
}
impl JustATrait for EnumOfOtherTypes {}

struct StructOfOtherTypes {
    an_i8: i8,
    another_i8: i8,
    a_collection: Vec&lt;String&gt;,
}
impl JustATrait for StructOfOtherTypes {}

struct ArrayAndI8 {
    array: [i8; 1000], // This one will be very large
    an_i8: i8,
    in_u8: u8,
}
impl JustATrait for ArrayAndI8 {}

fn main() {
    println!(
        "{}, {}, {}, {}, {}",
        size_of::&lt;EnumOfNumbers&gt;(),
        size_of::&lt;StructOfNumbers&gt;(),
        size_of::&lt;EnumOfOtherTypes&gt;(),
        size_of::&lt;StructOfOtherTypes&gt;(),
        size_of::&lt;ArrayAndI8&gt;(),
    );
}</code></pre></pre>
<p>å½“æˆ‘ä»¬æ‰“å°è¿™äº›ä¸œè¥¿çš„sizeçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¾—åˆ°<code>2, 3, 32, 32, 1002</code>ã€‚æ‰€ä»¥å¦‚æœä½ åƒä¸‹é¢è¿™æ ·åšçš„è¯ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âš ï¸
fn returns_just_a_trait() -&gt; JustATrait {
    let some_enum = EnumOfNumbers::I8(8);
    some_enum
}
<span class="boring">}</span></code></pre></pre>
<p>å®ƒè¯´ï¼š</p>
<pre><code class="language-text">error[E0746]: return type cannot have an unboxed trait object
  --&gt; src\main.rs:53:30
   |
53 | fn returns_just_a_trait() -&gt; JustATrait {
   |                              ^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>è€Œè¿™æ˜¯çœŸçš„ï¼Œå› ä¸ºsizeå¯ä»¥æ˜¯2ï¼Œ3ï¼Œ32ï¼Œ1002ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚æ‰€ä»¥æˆ‘ä»¬æŠŠå®ƒæ”¾åœ¨ä¸€ä¸ª<code>Box</code>ä¸­ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬è¿˜è¦åŠ ä¸Š<code>dyn</code>è¿™ä¸ªå…³é”®è¯ã€‚<code>dyn</code>è¿™ä¸ªè¯å‘Šè¯‰ä½ ï¼Œä½ è¯´çš„æ˜¯ä¸€ä¸ªtraitï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç»“æ„ä½“æˆ–å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚</p>
<p>æ‰€ä»¥ä½ å¯ä»¥æŠŠå‡½æ•°æ”¹æˆè¿™æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
fn returns_just_a_trait() -&gt; Box&lt;dyn JustATrait&gt; {
    let some_enum = EnumOfNumbers::I8(8);
    Box::new(some_enum)
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨å®ƒå·¥ä½œäº†ï¼Œå› ä¸ºåœ¨æ ˆä¸Šåªæ˜¯ä¸€ä¸ª<code>Box</code>ï¼Œæˆ‘ä»¬çŸ¥é“<code>Box</code>çš„å¤§å°ã€‚</p>
<p>ä½ ä¼šç»å¸¸çœ‹åˆ°<code>Box&lt;dyn Error&gt;</code>è¿™ç§å½¢å¼ï¼Œå› ä¸ºæœ‰æ—¶ä½ å¯èƒ½ä¼šæœ‰å¤šä¸ªå¯èƒ½çš„é”™è¯¯ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥å¿«é€Ÿåˆ›å»ºä¸¤ä¸ªé”™è¯¯ç±»å‹æ¥æ˜¾ç¤ºè¿™ä¸€ç‚¹ã€‚è¦åˆ›å»ºä¸€ä¸ªæ­£å¼çš„é”™è¯¯ç±»å‹ï¼Œä½ å¿…é¡»ä¸ºå®ƒå®ç°<code>std::error::Error</code>ã€‚è¿™éƒ¨åˆ†å¾ˆå®¹æ˜“:åªè¦å†™å‡º <code>impl std::error::Error {}</code>ã€‚ä½†é”™è¯¯è¿˜éœ€è¦<code>Debug</code>å’Œ<code>Display</code>ï¼Œè¿™æ ·æ‰èƒ½ç»™å‡ºé—®é¢˜çš„ä¿¡æ¯ã€‚<code>Debug</code>åªè¦åŠ ä¸Š<code>#[derive(Debug)]</code>å°±è¡Œï¼Œå¾ˆå®¹æ˜“ï¼Œä½†<code>Display</code>éœ€è¦<code>.fmt()</code>æ–¹æ³•ã€‚æˆ‘ä»¬ä¹‹å‰åšè¿‡ä¸€æ¬¡ã€‚</p>
<p>ä»£ç æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct ErrorOne;

impl Error for ErrorOne {} // Now it is an error type with Debug. Time for Display:

impl fmt::Display for ErrorOne {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "You got the first error!") // All it does is write this message
    }
}


#[derive(Debug)] // Do the same thing with ErrorTwo
struct ErrorTwo;

impl Error for ErrorTwo {}

impl fmt::Display for ErrorTwo {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "You got the second error!")
    }
}

// Make a function that just returns a String or an error
fn returns_errors(input: u8) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; { // With Box&lt;dyn Error&gt; you can return anything that has the Error trait

    match input {
        0 =&gt; Err(Box::new(ErrorOne)), // Don't forget to put it in a box
        1 =&gt; Err(Box::new(ErrorTwo)),
        _ =&gt; Ok("Looks fine to me".to_string()), // This is the success type
    }

}

fn main() {

    let vec_of_u8s = vec![0_u8, 1, 80]; // Three numbers to try out

    for number in vec_of_u8s {
        match returns_errors(number) {
            Ok(input) =&gt; println!("{}", input),
            Err(message) =&gt; println!("{}", message),
        }
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">You got the first error!
You got the second error!
Looks fine to me
</code></pre>
<p>å¦‚æœæˆ‘ä»¬æ²¡æœ‰<code>Box&lt;dyn Error&gt;</code>ï¼Œå†™äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å°±æœ‰é—®é¢˜äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âš ï¸
fn returns_errors(input: u8) -&gt; Result&lt;String, Error&gt; {
    match input {
        0 =&gt; Err(ErrorOne),
        1 =&gt; Err(ErrorTwo),
        _ =&gt; Ok("Looks fine to me".to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>å®ƒä¼šå‘Šè¯‰ä½ ã€‚</p>
<pre><code class="language-text">21  | fn returns_errors(input: u8) -&gt; Result&lt;String, Error&gt; {
    |                                 ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
</code></pre>
<p>è¿™å¹¶ä¸å¥‡æ€ªï¼Œå› ä¸ºæˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªtraitå¯ä»¥ä½œç”¨äºå¾ˆå¤šä¸œè¥¿ï¼Œè€Œä¸”å®ƒä»¬å„è‡ªæœ‰ä¸åŒçš„å¤§å°ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é»˜è®¤å€¼å’Œå»ºé€ è€…æ¨¡å¼"><a class="header" href="#é»˜è®¤å€¼å’Œå»ºé€ è€…æ¨¡å¼">é»˜è®¤å€¼å’Œå»ºé€ è€…æ¨¡å¼</a></h2>
<p>ä½ å¯ä»¥å®ç° <code>Default</code> traitï¼Œç»™ä½ è®¤ä¸ºæœ€å¸¸è§çš„ <code>struct</code> æˆ– <code>enum</code> èµ‹å€¼ã€‚å»ºé€ è€…æ¨¡å¼å¯ä»¥å¾ˆå¥½åœ°ä¸ä¹‹é…åˆï¼Œè®©ç”¨æˆ·åœ¨éœ€è¦æ—¶è½»æ¾åœ°è¿›è¡Œä¿®æ”¹ã€‚é¦–å…ˆæˆ‘ä»¬æ¥çœ‹çœ‹<code>Default</code>ã€‚å®é™…ä¸Šï¼ŒRustä¸­çš„å¤§å¤šæ•°é€šç”¨ç±»å‹å·²ç»æœ‰<code>Default</code>ã€‚å®ƒä»¬å¹¶ä¸å¥‡æ€ªã€‚0, ""(ç©ºå­—ç¬¦ä¸²), <code>false</code>, ç­‰ç­‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let default_i8: i8 = Default::default();
    let default_str: String = Default::default();
    let default_bool: bool = Default::default();

    println!("'{}', '{}', '{}'", default_i8, default_str, default_bool);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°<code>'0', '', 'false'</code>ã€‚</p>
<p>æ‰€ä»¥<code>Default</code>å°±åƒ<code>new</code>å‡½æ•°ä¸€æ ·ï¼Œé™¤äº†ä½ ä¸éœ€è¦è¾“å…¥ä»»ä½•ä¸œè¥¿ã€‚é¦–å…ˆæˆ‘ä»¬è¦åˆ›å»ºä¸€ä¸ª<code>struct</code>ï¼Œå®ƒè¿˜æ²¡æœ‰å®ç°<code>Default</code>ã€‚å®ƒæœ‰ä¸€ä¸ª<code>new</code>å‡½æ•°ï¼Œæˆ‘ä»¬ç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ªåä¸ºBillyçš„è§’è‰²ï¼Œå¹¶æä¾›ä¸€äº›ç»Ÿè®¡ä¿¡æ¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive { LifeState::Alive } else { LifeState::Dead },
        }
    }
}

fn main() {
    let character_1 = Character::new("Billy".to_string(), 15, 170, 70, true);
}</code></pre></pre>
<p>ä½†ä¹Ÿè®¸åœ¨æˆ‘ä»¬çš„ä¸–ç•Œé‡Œï¼Œæˆ‘ä»¬å¸Œæœ›å¤§éƒ¨åˆ†è§’è‰²éƒ½å«æ¯”åˆ©ï¼Œå¹´é¾„15å²ï¼Œèº«é«˜170ï¼Œä½“é‡70ï¼Œè¿˜æ´»ç€ã€‚æˆ‘ä»¬å¯ä»¥å®ç°<code>Default</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥å†™<code>Character::default()</code>ã€‚å®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive {
                LifeState::Alive
            } else {
                LifeState::Dead
            },
        }
    }
}

impl Default for Character {
    fn default() -&gt; Self {
        Self {
            name: "Billy".to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
}

fn main() {
    let character_1 = Character::default();

    println!(
        "The character {:?} is {:?} years old.",
        character_1.name, character_1.age
    );
}</code></pre></pre>
<p>æ‰“å°å‡º<code>The character "Billy" is 15 years old.</code>ï¼Œç®€å•å¤šäº†!</p>
<p>ç°åœ¨æˆ‘ä»¬æ¥çœ‹å»ºé€ è€…æ¨¡å¼ã€‚æˆ‘ä»¬ä¼šæœ‰å¾ˆå¤šBillyï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šä¿ç•™é»˜è®¤çš„ã€‚ä½†æ˜¯å¾ˆå¤šå…¶ä»–è§’è‰²åªä¼šæœ‰ä¸€ç‚¹ä¸åŒã€‚å»ºé€ è€…æ¨¡å¼è®©æˆ‘ä»¬å¯ä»¥æŠŠå°æ–¹æ³•é“¾æ¥èµ·æ¥ï¼Œæ¯æ¬¡æ”¹å˜ä¸€ä¸ªå€¼ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ª<code>Character</code>çš„æ–¹æ³•:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn height(mut self, height: u32) -&gt; Self {    // ğŸš§
    self.height = height;
    self
}
<span class="boring">}</span></code></pre></pre>
<p>ä¸€å®šè¦æ³¨æ„ï¼Œå®ƒå–çš„æ˜¯<code>mut self</code>ã€‚æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°è¿‡ä¸€æ¬¡ï¼Œå®ƒä¸æ˜¯ä¸€ä¸ªå¯å˜å¼•ç”¨(<code>&amp;mut self</code>)ã€‚å®ƒå ç”¨äº†<code>Self</code>çš„æ‰€æœ‰æƒï¼Œæœ‰äº†<code>mut</code>ï¼Œå®ƒå°†æ˜¯å¯å˜çš„ï¼Œå³ä½¿å®ƒä¹‹å‰ä¸æ˜¯å¯å˜çš„ã€‚è¿™æ˜¯å› ä¸º<code>.height()</code>æ‹¥æœ‰å®Œå…¨çš„æ‰€æœ‰æƒï¼Œåˆ«äººä¸èƒ½ç¢°å®ƒï¼Œæ‰€ä»¥å®ƒæ˜¯å®‰å…¨çš„ï¼Œå¯å˜ã€‚å®ƒåªæ˜¯æ”¹å˜<code>self.height</code>ï¼Œç„¶åè¿”å›<code>Self</code>(å°±æ˜¯<code>Character</code>)ã€‚</p>
<p>æ‰€ä»¥æˆ‘ä»¬æœ‰ä¸‰ä¸ªè¿™æ ·çš„æ„å»ºæ–¹æ³•ã€‚å®ƒä»¬å‡ ä¹æ˜¯ä¸€æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn height(mut self, height: u32) -&gt; Self {     // ğŸš§
    self.height = height;
    self
}

fn weight(mut self, weight: u32) -&gt; Self {
    self.weight = weight;
    self
}

fn name(mut self, name: &amp;str) -&gt; Self {
    self.name = name.to_string();
    self
}
<span class="boring">}</span></code></pre></pre>
<p>æ¯ä¸€ä¸ªéƒ½ä¼šæ”¹å˜ä¸€ä¸ªå˜é‡ï¼Œå¹¶å›é¦ˆç»™<code>Self</code>:è¿™å°±æ˜¯ä½ åœ¨å»ºé€ è€…æ¨¡å¼ä¸­çœ‹åˆ°çš„ã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬ç±»ä¼¼è¿™æ ·å†™æ¥åˆ›å»ºä¸€ä¸ªè§’è‰²:<code>let character_1 = Character::default().height(180).weight(60).name("Bobby");</code>ã€‚å¦‚æœä½ æ­£åœ¨æ„å»ºä¸€ä¸ªåº“ç»™åˆ«äººä½¿ç”¨ï¼Œè¿™å¯ä»¥è®©ä»–ä»¬å¾ˆå®¹æ˜“ç”¨èµ·æ¥ã€‚å¯¹æœ€ç»ˆç”¨æˆ·æ¥è¯´å¾ˆå®¹æ˜“ï¼Œå› ä¸ºå®ƒå‡ ä¹çœ‹èµ·æ¥åƒè‡ªç„¶çš„è‹±è¯­ã€‚"ç»™æˆ‘ä¸€ä¸ªé»˜è®¤è§’è‰²ï¼Œèº«é«˜ä¸º180ï¼Œä½“é‡ä¸º60ï¼Œåå­—ä¸ºBobby." åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„ä»£ç çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive {
                LifeState::Alive
            } else {
                LifeState::Dead
            },
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self
    }
}

impl Default for Character {
    fn default() -&gt; Self {
        Self {
            name: "Billy".to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
}

fn main() {
    let character_1 = Character::default().height(180).weight(60).name("Bobby");

    println!("{:?}", character_1);
}</code></pre></pre>
<p>æœ€åä¸€ä¸ªè¦æ·»åŠ çš„æ–¹æ³•é€šå¸¸å«<code>.build()</code>ã€‚è¿™ä¸ªæ–¹æ³•æ˜¯ä¸€ç§æœ€ç»ˆæ£€æŸ¥ã€‚å½“ä½ ç»™ç”¨æˆ·æä¾›ä¸€ä¸ªåƒ<code>.height()</code>è¿™æ ·çš„æ–¹æ³•æ—¶ï¼Œä½ å¯ä»¥ç¡®ä¿ä»–ä»¬åªè¾“å…¥ä¸€ä¸ª<code>u32()</code>ï¼Œä½†æ˜¯å¦‚æœä»–ä»¬è¾“å…¥5000çš„èº«é«˜æ€ä¹ˆåŠï¼Ÿè¿™åœ¨ä½ æ­£åœ¨åšçš„æ¸¸æˆä¸­å¯èƒ½å°±ä¸å¯¹äº†ã€‚æˆ‘ä»¬æœ€åå°†ä½¿ç”¨ä¸€ä¸ªåä¸º<code>.build()</code>çš„æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ª<code>Result</code>ã€‚åœ¨å®ƒé‡Œé¢æˆ‘ä»¬å°†æ£€æŸ¥ç”¨æˆ·è¾“å…¥æ˜¯å¦æ­£å¸¸ï¼Œå¦‚æœæ­£å¸¸ï¼Œæˆ‘ä»¬å°†è¿”å›ä¸€ä¸ª <code>Ok(Self)</code>ã€‚</p>
<p>ä¸è¿‡é¦–å…ˆæˆ‘ä»¬è¦æ”¹å˜<code>.new()</code>æ–¹æ³•ã€‚æˆ‘ä»¬ä¸å¸Œæœ›ç”¨æˆ·å†è‡ªç”±åˆ›å»ºä»»ä½•ä¸€ç§è§’è‰²ã€‚æ‰€ä»¥æˆ‘ä»¬å°†æŠŠ<code>impl Default</code>çš„å€¼ç§»åˆ°<code>.new()</code>ã€‚è€Œç°åœ¨<code>.new()</code>ä¸æ¥å—ä»»ä½•è¾“å…¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new() -&gt; Self {    // ğŸš§
        Self {
            name: "Billy".to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>è¿™æ„å‘³ç€æˆ‘ä»¬ä¸å†éœ€è¦<code>impl Default</code>äº†ï¼Œå› ä¸º<code>.new()</code>æœ‰æ‰€æœ‰çš„é»˜è®¤å€¼ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ é™¤<code>impl Default</code>ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬çš„ä»£ç æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new() -&gt; Self {
        Self {
            name: "Billy".to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self
    }
}

fn main() {
    let character_1 = Character::new().height(180).weight(60).name("Bobby");

    println!("{:?}", character_1);
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºæ¥çš„ç»“æœæ˜¯ä¸€æ ·çš„:<code>Character { name: "Bobby", age: 15, height: 180, weight: 60, lifestate: Alive }</code>ã€‚</p>
<p>æˆ‘ä»¬å‡ ä¹å·²ç»å‡†å¤‡å¥½å†™<code>.build()</code>æ–¹æ³•äº†ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªé—®é¢˜:å¦‚ä½•è®©ç”¨æˆ·ä½¿ç”¨å®ƒï¼Ÿç°åœ¨ç”¨æˆ·å¯ä»¥å†™<code>let x = Character::new().height(76767);</code>ï¼Œç„¶åå¾—åˆ°ä¸€ä¸ª<code>Character</code>ã€‚æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œä¹Ÿè®¸ä½ èƒ½æƒ³å‡ºè‡ªå·±çš„æ–¹æ³•ã€‚ä½†æ˜¯æˆ‘ä»¬ä¼šåœ¨<code>Character</code>ä¸­å¢åŠ ä¸€ä¸ª<code>can_use: bool</code>çš„å€¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]       // ğŸš§
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
    can_use: bool, // Set whether the user can use the character
}

\\ Cut other code

    fn new() -&gt; Self {
        Self {
            name: "Billy".to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
            can_use: true, // .new() always gives a good character, so it's true
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>è€Œå¯¹äºå…¶ä»–çš„æ–¹æ³•ï¼Œæ¯”å¦‚<code>.height()</code>ï¼Œæˆ‘ä»¬ä¼šå°†<code>can_use</code>è®¾ç½®ä¸º<code>false</code>ã€‚åªæœ‰<code>.build()</code>ä¼šå†æ¬¡è®¾ç½®ä¸º<code>true</code>ï¼Œæ‰€ä»¥ç°åœ¨ç”¨æˆ·è¦ç”¨<code>.build()</code>åšæœ€åçš„æ£€æŸ¥ã€‚æˆ‘ä»¬è¦ç¡®ä¿<code>height</code>ä¸é«˜äº200ï¼Œ<code>weight</code>ä¸é«˜äº300ã€‚å¦å¤–ï¼Œåœ¨æˆ‘ä»¬çš„æ¸¸æˆä¸­ï¼Œæœ‰ä¸€ä¸ªä¸å¥½çš„å­—å«<code>smurf</code>ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›ä»»ä½•è§’è‰²ä½¿ç”¨å®ƒã€‚</p>
<p>æˆ‘ä»¬çš„<code>.build()</code>æ–¹æ³•æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build(mut self) -&gt; Result&lt;Character, String&gt; {      // ğŸš§
    if self.height &lt; 200 &amp;&amp; self.weight &lt; 300 &amp;&amp; !self.name.to_lowercase().contains("smurf") {
        self.can_use = true;
        Ok(self)
    } else {
        Err("Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)"
            .to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>!self.name.to_lowercase().contains("smurf")</code> ç¡®ä¿ç”¨æˆ·ä¸ä¼šå†™å‡ºç±»ä¼¼ "SMURF"æˆ– "IamSmurf"çš„å­—æ ·ã€‚å®ƒè®©æ•´ä¸ª <code>String</code> éƒ½å˜æˆå°å†™(å°å­—æ¯)ï¼Œå¹¶æ£€æŸ¥ <code>.contains()</code> è€Œä¸æ˜¯ <code>==</code>ã€‚è€Œå‰é¢çš„<code>!</code>è¡¨ç¤º "ä¸æ˜¯"ã€‚</p>
<p>å¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œæˆ‘ä»¬å°±æŠŠ<code>can_use</code>è®¾ç½®ä¸º<code>true</code>ï¼Œç„¶åæŠŠ<code>Ok</code>é‡Œé¢çš„å­—ç¬¦ç»™ç”¨æˆ·ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬çš„ä»£ç å·²ç»å®Œæˆäº†ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸‰ä¸ªä¸å·¥ä½œçš„è§’è‰²ï¼Œå’Œä¸€ä¸ªå·¥ä½œçš„è§’è‰²ã€‚æœ€åçš„ä»£ç æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
    can_use: bool, // Here is the new value
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new() -&gt; Self {
        Self {
            name: "Billy".to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
            can_use: true,  // .new() makes a fine character, so it is true
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self.can_use = false; // Now the user can't use the character
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self.can_use = false;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self.can_use = false;
        self
    }

    fn build(mut self) -&gt; Result&lt;Character, String&gt; {
        if self.height &lt; 200 &amp;&amp; self.weight &lt; 300 &amp;&amp; !self.name.to_lowercase().contains("smurf") {
            self.can_use = true;   // Everything is okay, so set to true
            Ok(self)               // and return the character
        } else {
            Err("Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)"
                .to_string())
        }
    }
}

fn main() {
    let character_with_smurf = Character::new().name("Lol I am Smurf!!").build(); // This one contains "smurf" - not okay
    let character_too_tall = Character::new().height(400).build(); // Too tall - not okay
    let character_too_heavy = Character::new().weight(500).build(); // Too heavy - not okay
    let okay_character = Character::new()
        .name("Billybrobby")
        .height(180)
        .weight(100)
        .build();   // This character is okay. Name is fine, height and weight are fine

    // Now they are not Character, they are Result&lt;Character, String&gt;. So let's put them in a Vec so we can see them:
    let character_vec = vec![character_with_smurf, character_too_tall, character_too_heavy, okay_character];

    for character in character_vec { // Now we will print the character if it's Ok, and print the error if it's Err
        match character {
            Ok(character_info) =&gt; println!("{:?}", character_info),
            Err(err_info) =&gt; println!("{}", err_info),
        }
        println!(); // Then add one more line
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Character { name: "Billybrobby", age: 15, height: 180, weight: 100, lifestate: Alive, can_use: true }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="derefå’Œderefmut"><a class="header" href="#derefå’Œderefmut">Derefå’ŒDerefMut</a></h2>
<p><code>Deref</code>æ˜¯è®©ä½ ç”¨<code>*</code>æ¥è§£å¼•ç”¨æŸäº›ä¸œè¥¿çš„traitã€‚æˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªå¼•ç”¨å’Œä¸€ä¸ªå€¼æ˜¯ä¸ä¸€æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
fn main() {
    let value = 7; // This is an i32
    let reference = &amp;7; // This is a &amp;i32
    println!("{}", value == reference);
}</code></pre></pre>
<p>è€ŒRustè¿<code>false</code>éƒ½ä¸ç»™ï¼Œå› ä¸ºå®ƒç”šè‡³ä¸ä¼šæ¯”è¾ƒä¸¤è€…ã€‚</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src\main.rs:4:26
  |
4 |     println!("{}", value == reference);
  |                          ^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>å½“ç„¶ï¼Œè¿™é‡Œçš„è§£æ³•æ˜¯ä½¿ç”¨<code>*</code>ã€‚æ‰€ä»¥è¿™å°†æ‰“å°å‡º<code>true</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let value = 7;
    let reference = &amp;7;
    println!("{}", value == *reference);
}</code></pre></pre>
<p>ç°åœ¨è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ä¸€ä¸ªç®€å•çš„ç±»å‹ï¼Œå®ƒåªæ˜¯å®¹çº³ä¸€ä¸ªæ•°å­—ã€‚å®ƒå°±åƒä¸€ä¸ª<code>Box</code>ï¼Œæˆ‘ä»¬æœ‰ä¸€äº›æƒ³æ³•ä¸ºå®ƒæä¾›ä¸€äº›é¢å¤–çš„åŠŸèƒ½ã€‚ä½†å¦‚æœæˆ‘ä»¬åªæ˜¯ç»™å®ƒä¸€ä¸ªæ•°å­—ï¼Œ
å®ƒå°±ä¸èƒ½åšé‚£ä¹ˆå¤šäº†ã€‚</p>
<p>æˆ‘ä»¬ä¸èƒ½åƒä½¿ç”¨<code>Box</code>é‚£æ ·ä½¿ç”¨<code>*</code>:</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
struct HoldsANumber(u8);

fn main() {
    let my_number = HoldsANumber(20);
    println!("{}", *my_number + 20);
}</code></pre></pre>
<p>é”™è¯¯ä¿¡æ¯æ˜¯:</p>
<pre><code class="language-text">error[E0614]: type `HoldsANumber` cannot be dereferenced
  --&gt; src\main.rs:24:22
   |
24 |     println!("{:?}", *my_number + 20);
</code></pre>
<p>æˆ‘ä»¬å½“ç„¶å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚<code>println!("{:?}", my_number.0 + 20);</code>. ä½†æ˜¯è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬å°±æ˜¯åœ¨20çš„åŸºç¡€ä¸Šå†å•ç‹¬åŠ ä¸€ä¸ª<code>u8</code>ã€‚å¦‚æœæˆ‘ä»¬èƒ½æŠŠå®ƒä»¬åŠ åœ¨ä¸€èµ·å°±æ›´å¥½äº†ã€‚<code>cannot be dereferenced</code>è¿™ä¸ªæ¶ˆæ¯ç»™äº†æˆ‘ä»¬ä¸€ä¸ªçº¿ç´¢:æˆ‘ä»¬éœ€è¦å®ç°<code>Deref</code>ã€‚å®ç°<code>Deref</code>çš„ç®€å•ä¸œè¥¿æœ‰æ—¶è¢«ç§°ä¸º "æ™ºèƒ½æŒ‡é’ˆ"ã€‚ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆå¯ä»¥æŒ‡å‘å®ƒçš„å…ƒç´ ï¼Œæœ‰å®ƒçš„ä¿¡æ¯ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨å®ƒçš„æ–¹æ³•ã€‚å› ä¸ºç°åœ¨æˆ‘ä»¬å¯ä»¥æ·»åŠ <code>my_number.0</code>ï¼Œè¿™æ˜¯ä¸€ä¸ª<code>u8</code>ï¼Œä½†æˆ‘ä»¬ä¸èƒ½ç”¨<code>HoldsANumber</code>åšå…¶ä»–çš„äº‹æƒ…:åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå®ƒåªæœ‰<code>Debug</code>ã€‚</p>
<p>æœ‰è¶£çš„æ˜¯:<code>String</code>å…¶å®æ˜¯<code>&amp;str</code>çš„æ™ºèƒ½æŒ‡é’ˆï¼Œ<code>Vec</code>æ˜¯æ•°ç»„(æˆ–å…¶ä»–ç±»å‹)çš„æ™ºèƒ½æŒ‡é’ˆã€‚æ‰€ä»¥æˆ‘ä»¬å…¶å®ä»ä¸€å¼€å§‹å°±åœ¨ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆã€‚</p>
<p>å®ç°<code>Deref</code>å¹¶ä¸éš¾ï¼Œæ ‡å‡†åº“ä¸­çš„ä¾‹å­ä¹Ÿå¾ˆç®€å•ã€‚<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">ä¸‹é¢æ˜¯æ ‡å‡†åº“ä¸­çš„ç¤ºä¾‹ä»£ç </a>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct DerefExample&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

fn main() {
    let x = DerefExample { value: 'a' };
    assert_eq!('a', *x);
}</code></pre></pre>
<p>æ‰€ä»¥æˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªæ¥ï¼Œç°åœ¨æˆ‘ä»¬çš„<code>Deref</code>æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
impl Deref for HoldsANumber {
    type Target = u8; // Remember, this is the "associated type": the type that goes together.
                      // You have to use the right type Target = (the type you want to return)

    fn deref(&amp;self) -&gt; &amp;Self::Target { // Rust calls .deref() when you use *. We just defined Target as a u8 so this is easy to understand
        &amp;self.0   // We chose &amp;self.0 because it's a tuple struct. In a named struct it would be something like "&amp;self.number"
    }
}
<span class="boring">}</span></code></pre></pre>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨<code>*</code>æ¥åš:</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;
#[derive(Debug)]
struct HoldsANumber(u8);

impl Deref for HoldsANumber {
    type Target = u8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

fn main() {
    let my_number = HoldsANumber(20);
    println!("{:?}", *my_number + 20);
}</code></pre></pre>
<p>æ‰€ä»¥ï¼Œè¿™æ ·å°±å¯ä»¥æ‰“å°å‡º<code>40</code>ï¼Œæˆ‘ä»¬ä¸éœ€è¦å†™<code>my_number.0</code>ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¾—åˆ°äº† <code>u8</code> çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä¸º <code>HoldsANumber</code> å†™å‡ºæˆ‘ä»¬è‡ªå·±çš„æ–¹æ³•ã€‚æˆ‘ä»¬å°†æ·»åŠ è‡ªå·±çš„ç®€å•æ–¹æ³•ï¼Œå¹¶ä½¿ç”¨æˆ‘ä»¬ä»<code>u8</code>ä¸­å¾—åˆ°çš„å¦ä¸€ä¸ªæ–¹æ³•ï¼Œç§°ä¸º<code>.checked_sub()</code>ã€‚<code>.checked_sub()</code>æ–¹æ³•æ˜¯ä¸€ä¸ªå®‰å…¨çš„å‡æ³•ï¼Œå®ƒèƒ½è¿”å›ä¸€ä¸ª<code>Option</code>ã€‚å¦‚æœå®ƒèƒ½åšå‡æ³•ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šåœ¨<code>Some</code>é‡Œé¢ç»™ä½ ï¼Œå¦‚æœå®ƒä¸èƒ½åšå‡æ³•ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šç»™å‡ºä¸€ä¸ª<code>None</code>ã€‚è®°ä½ï¼Œ<code>u8</code>ä¸èƒ½æ˜¯è´Ÿæ•°ï¼Œæ‰€ä»¥è¿˜æ˜¯<code>.checked_sub()</code>æ¯”è¾ƒå®‰å…¨ï¼Œè¿™æ ·å°±ä¸ä¼šå´©æºƒäº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct HoldsANumber(u8);

impl HoldsANumber {
    fn prints_the_number_times_two(&amp;self) {
        println!("{}", self.0 * 2);
    }
}

impl Deref for HoldsANumber {
    type Target = u8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

fn main() {
    let my_number = HoldsANumber(20);
    println!("{:?}", my_number.checked_sub(100)); // This method comes from u8
    my_number.prints_the_number_times_two(); // This is our own method
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">None
40
</code></pre>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°<code>DerefMut</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡<code>*</code>æ¥æ”¹å˜æ•°å€¼ã€‚å®ƒçœ‹èµ·æ¥å‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚åœ¨å®ç°<code>DerefMut</code>ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆå®ç°<code>Deref</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::{Deref, DerefMut};

struct HoldsANumber(u8);

impl HoldsANumber {
    fn prints_the_number_times_two(&amp;self) {
        println!("{}", self.0 * 2);
    }
}

impl Deref for HoldsANumber {
    type Target = u8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for HoldsANumber { // You don't need type Target = u8; here because it already knows thanks to Deref
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target { // Everything else is the same except it says mut everywhere
        &amp;mut self.0
    }
}

fn main() {
    let mut my_number = HoldsANumber(20);
    *my_number = 30; // DerefMut lets us do this
    println!("{:?}", my_number.checked_sub(100));
    my_number.prints_the_number_times_two();
}</code></pre></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥çœ‹åˆ°ï¼Œ<code>Deref</code>ç»™ä½ çš„ç±»å‹æä¾›äº†å¼ºå¤§çš„åŠ›é‡ã€‚</p>
<p>è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ ‡å‡†åº“è¯´:<code>Deref should only be implemented for smart pointers to avoid confusion</code>ã€‚è¿™æ˜¯å› ä¸ºå¯¹äºä¸€ä¸ªå¤æ‚çš„ç±»å‹ï¼Œä½ å¯ä»¥ç”¨ <code>Deref</code> åšä¸€äº›å¥‡æ€ªçš„äº‹æƒ…ã€‚è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸ªéå¸¸æ··ä¹±çš„ä¾‹å­æ¥ç†è§£å®ƒä»¬çš„å«ä¹‰ã€‚æˆ‘ä»¬å°†ä»ä¸€ä¸ªæ¸¸æˆçš„ <code>Character</code> ç»“æ„å¼€å§‹ã€‚ä¸€ä¸ªæ–°çš„<code>Character</code>éœ€è¦ä¸€äº›æ•°æ®ï¼Œæ¯”å¦‚æ™ºåŠ›å’ŒåŠ›é‡ã€‚æ‰€ä»¥è¿™é‡Œæ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªè§’è‰²ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct Character {
    name: String,
    strength: u8,
    dexterity: u8,
    health: u8,
    intelligence: u8,
    wisdom: u8,
    charm: u8,
    hit_points: i8,
    alignment: Alignment,
}

impl Character {
    fn new(
        name: String,
        strength: u8,
        dexterity: u8,
        health: u8,
        intelligence: u8,
        wisdom: u8,
        charm: u8,
        hit_points: i8,
        alignment: Alignment,
    ) -&gt; Self {
        Self {
            name,
            strength,
            dexterity,
            health,
            intelligence,
            wisdom,
            charm,
            hit_points,
            alignment,
        }
    }
}

enum Alignment {
    Good,
    Neutral,
    Evil,
}

fn main() {
    let billy = Character::new("Billy".to_string(), 9, 8, 7, 10, 19, 19, 5, Alignment::Good);
}</code></pre></pre>
<p>ç°åœ¨è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬è¦æŠŠäººç‰©çš„hit pointsæ”¾åœ¨ä¸€ä¸ªå¤§çš„vecé‡Œã€‚ä¹Ÿè®¸æˆ‘ä»¬ä¼šæŠŠæ€ªç‰©æ•°æ®ä¹Ÿæ”¾è¿›å»ï¼ŒæŠŠå®ƒæ”¾åœ¨ä¸€èµ·ã€‚ç”±äº <code>hit_points</code> æ˜¯ä¸€ä¸ª <code>i8</code>ï¼Œæˆ‘ä»¬å®ç°äº† <code>Deref</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹å®ƒè¿›è¡Œå„ç§è®¡ç®—ã€‚ä½†æ˜¯çœ‹çœ‹ç°åœ¨æˆ‘ä»¬çš„<code>main()</code>å‡½æ•°ä¸­ï¼Œå®ƒçœ‹èµ·æ¥å¤šä¹ˆå¥‡æ€ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

// All the other code is the same until after the enum Alignment
struct Character {
    name: String,
    strength: u8,
    dexterity: u8,
    health: u8,
    intelligence: u8,
    wisdom: u8,
    charm: u8,
    hit_points: i8,
    alignment: Alignment,
}

impl Character {
    fn new(
        name: String,
        strength: u8,
        dexterity: u8,
        health: u8,
        intelligence: u8,
        wisdom: u8,
        charm: u8,
        hit_points: i8,
        alignment: Alignment,
    ) -&gt; Self {
        Self {
            name,
            strength,
            dexterity,
            health,
            intelligence,
            wisdom,
            charm,
            hit_points,
            alignment,
        }
    }
}

enum Alignment {
    Good,
    Neutral,
    Evil,
}

impl Deref for Character { // impl Deref for Character. Now we can do any integer math we want!
    type Target = i8;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.hit_points
    }
}



fn main() {
    let billy = Character::new("Billy".to_string(), 9, 8, 7, 10, 19, 19, 5, Alignment::Good); // Create two characters, billy and brandy
    let brandy = Character::new("Brandy".to_string(), 9, 8, 7, 10, 19, 19, 5, Alignment::Good);

    let mut hit_points_vec = vec![]; // Put our hit points data in here
    hit_points_vec.push(*billy);     // Push *billy?
    hit_points_vec.push(*brandy);    // Push *brandy?

    println!("{:?}", hit_points_vec);
}</code></pre></pre>
<p>è¿™åªæ‰“å°äº†<code>[5, 5]</code>ã€‚æˆ‘ä»¬çš„ä»£ç ç°åœ¨è®©äººè¯»èµ·æ¥æ„Ÿè§‰éå¸¸å¥‡æ€ªã€‚æˆ‘ä»¬å¯ä»¥åœ¨<code>main()</code>ä¸Šé¢çœ‹åˆ°<code>Deref</code>ï¼Œç„¶åå¼„æ¸…æ¥š<code>*billy</code>çš„æ„æ€æ˜¯<code>i8</code>ï¼Œä½†æ˜¯å¦‚æœæœ‰å¾ˆå¤šä»£ç å‘¢ï¼Ÿå¯èƒ½æˆ‘ä»¬çš„ä»£ç æœ‰2000è¡Œï¼Œçªç„¶è¦å¼„æ¸…æ¥šä¸ºä»€ä¹ˆè¦<code>.push()</code> <code>*billy</code>ã€‚<code>Character</code>å½“ç„¶ä¸ä»…ä»…æ˜¯<code>i8</code>çš„æ™ºèƒ½æŒ‡é’ˆã€‚</p>
<p>å½“ç„¶ï¼Œå†™<code>hit_points_vec.push(*billy)</code>å¹¶ä¸è¿æ³•ï¼Œä½†è¿™è®©ä»£ç çœ‹èµ·æ¥éå¸¸å¥‡æ€ªã€‚ä¹Ÿè®¸ä¸€ä¸ªç®€å•çš„<code>.get_hp()</code>æ–¹æ³•ä¼šå¥½å¾—å¤šï¼Œæˆ–è€…å¦ä¸€ä¸ªå­˜æ”¾è§’è‰²çš„ç»“æ„ä½“ã€‚ç„¶åä½ å¯ä»¥è¿­ä»£å¹¶æ¨é€æ¯ä¸ªè§’è‰²çš„ <code>hit_points</code>ã€‚<code>Deref</code>æä¾›äº†å¾ˆå¤šåŠŸèƒ½ï¼Œä½†æœ€å¥½ç¡®ä¿ä»£ç çš„é€»è¾‘æ€§ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="crateå’Œæ¨¡å—"><a class="header" href="#crateå’Œæ¨¡å—">Crateå’Œæ¨¡å—</a></h2>
<p>æ¯æ¬¡ä½ åœ¨ Rust ä¸­å†™ä»£ç æ—¶ï¼Œä½ éƒ½æ˜¯åœ¨ <code>crate</code> ä¸­å†™çš„ã€‚<code>crate</code>æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶ï¼Œä¸€èµ·ä¸ºä½ çš„ä»£ç æœåŠ¡ã€‚åœ¨ä½ å†™çš„æ–‡ä»¶é‡Œé¢ï¼Œä½ ä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ª<code>mod</code>ã€‚<code>mod</code>æ˜¯å­˜æ”¾å‡½æ•°ã€ç»“æ„ä½“ç­‰çš„ç©ºé—´ï¼Œå› ä¸ºè¿™äº›åŸå› è¢«ä½¿ç”¨:</p>
<ul>
<li>æ„å»ºä½ çš„ä»£ç :å®ƒå¯ä»¥å¸®åŠ©ä½ æ€è€ƒä»£ç çš„æ€»ä½“ç»“æ„ã€‚å½“ä½ çš„ä»£ç è¶Šæ¥è¶Šå¤§æ—¶ï¼Œè¿™ä¸€ç‚¹å¯èƒ½å¾ˆé‡è¦ã€‚</li>
<li>é˜…è¯»ä½ çš„ä»£ç :äººä»¬å¯ä»¥æ›´å®¹æ˜“ç†è§£ä½ çš„ä»£ç ã€‚ä¾‹å¦‚ï¼Œ<code>std::collections::HashMap</code>è¿™ä¸ªåå­—å‘Šè¯‰ä½ ï¼Œå®ƒåœ¨<code>std</code>çš„æ¨¡å—<code>collections</code>é‡Œé¢ã€‚è¿™ç»™äº†ä½ ä¸€ä¸ªæç¤ºï¼Œä¹Ÿè®¸<code>collections</code>é‡Œé¢è¿˜æœ‰æ›´å¤šçš„é›†åˆç±»å‹ï¼Œä½ å¯ä»¥å°è¯•ä¸€ä¸‹ã€‚</li>
<li>ç§å¯†æ€§:æ‰€æœ‰çš„ä¸œè¥¿ä¸€å¼€å§‹éƒ½æ˜¯ç§æœ‰çš„ã€‚è¿™æ ·å¯ä»¥è®©ä½ ä¸è®©ç”¨æˆ·ç›´æ¥ä½¿ç”¨å‡½æ•°ã€‚</li>
</ul>
<p>è¦åˆ›å»ºä¸€ä¸ª<code>mod</code>ï¼Œåªéœ€è¦å†™<code>mod</code>ï¼Œç„¶åç”¨<code>{}</code>å¼€å§‹ä¸€ä¸ªä»£ç å—ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªåä¸º<code>print_things</code>çš„modï¼Œå®ƒæœ‰ä¸€äº›æ‰“å°ç›¸å…³çš„åŠŸèƒ½ã€‚</p>
<pre><pre class="playground"><code class="language-rust">mod print_things {
    use std::fmt::Display;

    fn prints_one_thing&lt;T: Display&gt;(input: T) { // Print anything that implements Display
        println!("{}", input)
    }
}

fn main() {}</code></pre></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬æŠŠ<code>use std::fmt::Display;</code>å†™åœ¨<code>print_things</code>é‡Œé¢ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ç©ºé—´ã€‚å¦‚æœä½ æŠŠ<code>use std::fmt::Display;</code>å†™åœ¨<code>main()</code>é‡Œé¢ï¼Œé‚£æ²¡ç”¨ã€‚è€Œä¸”ï¼Œæˆ‘ä»¬ç°åœ¨ä¹Ÿä¸èƒ½ä»<code>main()</code>é‡Œé¢è°ƒç”¨ã€‚å¦‚æœåœ¨<code>fn</code>å‰é¢æ²¡æœ‰<code>pub</code>è¿™ä¸ªå…³é”®å­—ï¼Œå®ƒå°±ä¼šä¿æŒç§å¯†æ€§ã€‚è®©æˆ‘ä»¬è¯•ç€åœ¨æ²¡æœ‰<code>pub</code>çš„æƒ…å†µä¸‹è°ƒç”¨å®ƒã€‚è¿™é‡Œæœ‰ä¸€ç§å†™æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// ğŸš§
fn main() {
    crate::print_things::prints_one_thing(6);
}</code></pre></pre>
<p><code>crate</code>çš„æ„æ€æ˜¯ "åœ¨è¿™ä¸ªé¡¹ç›®é‡Œ"ï¼Œä½†å¯¹äºæˆ‘ä»¬ç®€å•çš„ä¾‹å­æ¥è¯´ï¼Œå®ƒå’Œ "åœ¨è¿™ä¸ªæ–‡ä»¶é‡Œé¢"æ˜¯ä¸€æ ·çš„ã€‚æ¥ç€æ˜¯<code>print_things</code>è¿™ä¸ªmodï¼Œæœ€åæ˜¯<code>prints_one_thing()</code>å‡½æ•°ã€‚ä½ å¯ä»¥æ¯æ¬¡éƒ½å†™è¿™ä¸ªï¼Œä¹Ÿå¯ä»¥å†™<code>use</code>æ¥å¯¼å…¥ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯´å®ƒæ˜¯ç§æœ‰çš„é”™è¯¯:</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
mod print_things {
    use std::fmt::Display;

    fn prints_one_thing&lt;T: Display&gt;(input: T) {
        println!("{}", input)
    }
}

fn main() {
    use crate::print_things::prints_one_thing;

    prints_one_thing(6);
    prints_one_thing("Trying to print a string...".to_string());
}</code></pre></pre>
<p>è¿™æ˜¯é”™è¯¯çš„ã€‚</p>
<pre><code class="language-text">error[E0603]: function `prints_one_thing` is private
  --&gt; src\main.rs:10:30
   |
10 |     use crate::print_things::prints_one_thing;
   |                              ^^^^^^^^^^^^^^^^ private function
   |
note: the function `prints_one_thing` is defined here
  --&gt; src\main.rs:4:5
   |
4  |     fn prints_one_thing&lt;T: Display&gt;(input: T) {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>å¾ˆå®¹æ˜“ç†è§£ï¼Œå‡½æ•°<code>print_one_thing</code>æ˜¯ç§æœ‰çš„ã€‚å®ƒè¿˜ç”¨<code>src\main.rs:4:5</code>å‘Šè¯‰æˆ‘ä»¬åœ¨å“ªé‡Œå¯ä»¥æ‰¾åˆ°è¿™ä¸ªå‡½æ•°ã€‚è¿™å¾ˆæœ‰å¸®åŠ©ï¼Œå› ä¸ºä½ ä¸ä»…å¯ä»¥åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å†™<code>mod</code>ï¼Œè¿˜å¯ä»¥åœ¨å¾ˆå¤šæ–‡ä»¶ä¸­å†™<code>mod</code>ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬åªéœ€è¦å†™<code>pub fn</code>è€Œä¸æ˜¯<code>fn</code>ï¼Œä¸€åˆ‡å°±éƒ½å¯ä»¥äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">mod print_things {
    use std::fmt::Display;

    pub fn prints_one_thing&lt;T: Display&gt;(input: T) {
        println!("{}", input)
    }
}

fn main() {
    use crate::print_things::prints_one_thing;

    prints_one_thing(6);
    prints_one_thing("Trying to print a string...".to_string());
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">6
Trying to print a string...
</code></pre>
<p><code>pub</code>å¯¹ç»“æ„ä½“ã€æšä¸¾ã€traitæˆ–æ¨¡å—æœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ<code>pub</code>å¯¹å®ƒä»¬æ¥è¯´æ˜¯è¿™æ ·çš„:</p>
<ul>
<li><code>pub</code>å¯¹äºä¸€ä¸ªç»“æ„ï¼šå®ƒä½¿ç»“æ„å…¬å¼€ï¼Œä½†æˆå‘˜ä¸æ˜¯å…¬å¼€çš„ã€‚è¦æƒ³è®©ä¸€ä¸ªæˆå‘˜å…¬å¼€ï¼Œä½ ä¹Ÿè¦ä¸ºæ¯ä¸ªæˆå‘˜å†™<code>pub</code>ã€‚</li>
<li><code>pub</code> å¯¹äºä¸€ä¸ªæšä¸¾æˆ–traitï¼šæ‰€æœ‰çš„ä¸œè¥¿éƒ½å˜æˆäº†å…¬å…±çš„ã€‚è¿™æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºtraitsæ˜¯ç»™äº‹ç‰©èµ‹äºˆç›¸åŒçš„è¡Œä¸ºã€‚è€Œæšä¸¾æ˜¯å€¼ä¹‹é—´çš„é€‰æ‹©ï¼Œä½ éœ€è¦çœ‹åˆ°æ‰€æœ‰çš„æšä¸¾å€¼æ‰èƒ½åšé€‰æ‹©ã€‚</li>
<li><code>pub</code>å¯¹äºä¸€ä¸ªæ¨¡å—æ¥è¯´ï¼šä¸€ä¸ªé¡¶å±‚çš„æ¨¡å—ä¼šæ˜¯<code>pub</code>ï¼Œå› ä¸ºå¦‚æœå®ƒä¸æ˜¯pubï¼Œé‚£ä¹ˆæ ¹æœ¬æ²¡æœ‰äººå¯ä»¥ä½¿ç”¨é‡Œé¢çš„ä»»ä½•ä¸œè¥¿ã€‚ä½†æ˜¯æ¨¡å—é‡Œé¢çš„æ¨¡å—éœ€è¦ä½¿ç”¨<code>pub</code>æ‰èƒ½æˆä¸ºå…¬å…±çš„ã€‚</li>
</ul>
<p>æˆ‘ä»¬åœ¨<code>print_things</code>é‡Œé¢æ”¾ä¸€ä¸ªåä¸º<code>Billy</code>çš„ç»“æ„ä½“ã€‚è¿™ä¸ªç»“æ„ä½“å‡ ä¹éƒ½ä¼šæ˜¯publicçš„ï¼Œä½†ä¹Ÿä¸å°½ç„¶ã€‚è¿™ä¸ªç»“æ„æ˜¯å…¬å…±çš„ï¼Œæ‰€ä»¥å®ƒè¿™æ ·å†™ï¼š<code>pub struct Billy</code>ã€‚é‡Œé¢ä¼šæœ‰ä¸€ä¸ª <code>name</code> å’Œ <code>times_to_print</code>ã€‚<code>name</code>ä¸ä¼šæ˜¯å…¬å…±çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªæƒ³è®©ç”¨æˆ·åˆ›å»ºåä¸º<code>"Billy".to_string()</code>çš„ç»“æ„ã€‚ä½†æ˜¯ç”¨æˆ·å¯ä»¥é€‰æ‹©æ‰“å°çš„æ¬¡æ•°ï¼Œæ‰€ä»¥è¿™å°†æ˜¯å…¬å¼€çš„ã€‚å®ƒçš„æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">mod print_things {
    use std::fmt::{Display, Debug};

    #[derive(Debug)]
    pub struct Billy { // Billy is public
        name: String, // but name is private.
        pub times_to_print: u32,
    }

    impl Billy {
        pub fn new(times_to_print: u32) -&gt; Self { // That means the user needs to use new to create a Billy. The user can only change the number of times_to_print
            Self {
                name: "Billy".to_string(), // We choose the name - the user can't
                times_to_print,
            }
        }

        pub fn print_billy(&amp;self) { // This function prints a Billy
            for _ in 0..self.times_to_print {
                println!("{:?}", self.name);
            }
        }
    }

    pub fn prints_one_thing&lt;T: Display&gt;(input: T) {
        println!("{}", input)
    }
}

fn main() {
    use crate::print_things::*; // Now we use *. This imports everything from print_things

    let my_billy = Billy::new(3);
    my_billy.print_billy();
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">"Billy"
"Billy"
"Billy"
</code></pre>
<p>å¯¹äº†ï¼Œå¯¼å…¥ä¸€åˆ‡çš„<code>*</code>å«åš "globè¿ç®—ç¬¦"ã€‚Globçš„æ„æ€æ˜¯ "å…¨å±€"ï¼Œæ‰€ä»¥å®ƒæ„å‘³ç€ä¸€åˆ‡ã€‚</p>
<p>åœ¨<code>mod</code>é‡Œé¢ä½ å¯ä»¥åˆ›å»ºå…¶ä»–modã€‚ä¸€ä¸ªå­ mod(modé‡Œçš„mod)æ€»æ˜¯å¯ä»¥ä½¿ç”¨çˆ¶ mod å†…éƒ¨çš„ä»»ä½•ä¸œè¥¿ã€‚ä½ å¯ä»¥åœ¨ä¸‹ä¸€ä¸ªä¾‹å­ä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬åœ¨ <code>mod province</code> é‡Œé¢æœ‰ä¸€ä¸ª <code>mod city</code>ï¼Œè€Œ<code>mod province</code>åœ¨ <code>mod country</code> é‡Œé¢ã€‚</p>
<p>ä½ å¯ä»¥è¿™æ ·æƒ³:å³ä½¿ä½ åœ¨ä¸€ä¸ªå›½å®¶ï¼Œä½ å¯èƒ½ä¸åœ¨ä¸€ä¸ªçœã€‚è€Œå³ä½¿ä½ åœ¨ä¸€ä¸ªçœï¼Œä½ ä¹Ÿå¯èƒ½ä¸åœ¨ä¸€ä¸ªå¸‚ã€‚ä½†å¦‚æœä½ åœ¨ä¸€ä¸ªåŸå¸‚ï¼Œä½ å°±åœ¨è¿™ä¸ªåŸå¸‚çš„çœä»½å’Œå®ƒçš„å›½å®¶ã€‚</p>
<pre><pre class="playground"><code class="language-rust">mod country { // The main mod doesn't need pub
    fn print_country(country: &amp;str) { // Note: this function isn't public
        println!("We are in the country of {}", country);
    }
    pub mod province { // Make this mod public

        fn print_province(province: &amp;str) { // Note: this function isn't public
            println!("in the province of {}", province);
        }

        pub mod city { // Make this mod public
            pub fn print_city(country: &amp;str, province: &amp;str, city: &amp;str) {  // This function is public though
                crate::country::print_country(country);
                crate::country::province::print_province(province);
                println!("in the city of {}", city);
            }
        }
    }
}

fn main() {
    crate::country::province::city::print_city("Canada", "New Brunswick", "Moncton");
}</code></pre></pre>
<p>æœ‰è¶£çš„æ˜¯ï¼Œ<code>print_city</code>å¯ä»¥è®¿é—®<code>print_province</code>å’Œ<code>print_country</code>ã€‚è¿™æ˜¯å› ä¸º<code>mod city</code>åœ¨å…¶ä»–modé‡Œé¢ã€‚å®ƒä¸éœ€è¦åœ¨<code>print_province</code>å‰é¢æ·»åŠ <code>pub</code>ä¹‹åæ‰èƒ½ä½¿ç”¨ã€‚è¿™ä¹Ÿæ˜¯æœ‰é“ç†çš„:ä¸€ä¸ªåŸå¸‚ä¸éœ€è¦åšä»€ä¹ˆï¼Œå®ƒæœ¬æ¥å°±åœ¨ä¸€ä¸ªçœé‡Œï¼Œåœ¨ä¸€ä¸ªå›½å®¶é‡Œã€‚</p>
<p>ä½ å¯èƒ½æ³¨æ„åˆ°ï¼Œ<code>crate::country::province::print_province(province);</code>éå¸¸é•¿ã€‚å½“æˆ‘ä»¬åœ¨ä¸€ä¸ªæ¨¡å—é‡Œé¢çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨<code>super</code>ä»ä¸Šé¢å¼•å…¥å…ƒç´ ã€‚å…¶å®superè¿™ä¸ªè¯æœ¬èº«å°±æ˜¯"ä¸Šé¢"çš„æ„æ€ï¼Œæ¯”å¦‚ "ä¸Šçº§"ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªç”¨äº†ä¸€æ¬¡å‡½æ•°ï¼Œä½†æ˜¯å¦‚æœä½ ç”¨çš„æ¯”è¾ƒå¤šçš„è¯ï¼Œé‚£ä¹ˆæœ€å¥½æ˜¯å¯¼å…¥ã€‚å¦‚æœå®ƒèƒ½è®©ä½ çš„ä»£ç æ›´å®¹æ˜“é˜…è¯»ï¼Œé‚£ä¹Ÿæ˜¯ä¸ªå¥½ä¸»æ„ï¼Œå³ä½¿ä½ åªç”¨äº†ä¸€æ¬¡å‡½æ•°ã€‚ç°åœ¨çš„ä»£ç å‡ ä¹æ˜¯ä¸€æ ·çš„ï¼Œä½†æ›´å®¹æ˜“é˜…è¯»ä¸€äº›ã€‚</p>
<pre><pre class="playground"><code class="language-rust">mod country {
    fn print_country(country: &amp;str) {
        println!("We are in the country of {}", country);
    }
    pub mod province {
        fn print_province(province: &amp;str) {
            println!("in the province of {}", province);
        }

        pub mod city {
            use super::super::*; // use everything in "above above": that means mod country
            use super::*;        // use everything in "above": that means mod province

            pub fn print_city(country: &amp;str, province: &amp;str, city: &amp;str) {
                print_country(country);
                print_province(province);
                println!("in the city of {}", city);
            }
        }
    }
}

fn main() {
    use crate::country::province::city::print_city; // bring in the function

    print_city("Canada", "New Brunswick", "Moncton");
    print_city("Korea", "Gyeonggi-do", "Gwangju"); // Now it's less work to use it again
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æµ‹è¯•"><a class="header" href="#æµ‹è¯•">æµ‹è¯•</a></h2>
<p>ç°åœ¨æˆ‘ä»¬å·²ç»äº†è§£äº†æ¨¡å—,å°±å¯ä»¥è°ˆè°ˆæµ‹è¯•äº†ã€‚åœ¨Rustä¸­æµ‹è¯•ä½ çš„ä»£ç æ˜¯éå¸¸å®¹æ˜“çš„ï¼Œå› ä¸ºä½ å¯ä»¥åœ¨ä½ çš„ä»£ç æ—è¾¹å†™æµ‹è¯•ã€‚</p>
<p>å¼€å§‹æµ‹è¯•çš„æœ€ç®€å•çš„æ–¹æ³•æ˜¯åœ¨ä¸€ä¸ªå‡½æ•°ä¸Šé¢æ·»åŠ <code>#[test]</code>ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn two_is_two() {
    assert_eq!(2, 2);
}
<span class="boring">}</span></code></pre></pre>
<p>ä½†å¦‚æœä½ è¯•å›¾åœ¨playgroundä¸­è¿è¡Œå®ƒï¼Œå®ƒç»™å‡ºäº†ä¸€ä¸ªé”™è¯¯ã€‚<code>error[E0601]: `main` function not found in crate `playground</code>. è¿™æ˜¯å› ä¸ºä½ ä¸ä½¿ç”¨ <em>Run</em> æ¥è¿›è¡Œæµ‹è¯•ï¼Œä½ ä½¿ç”¨ <em>Test</em> ã€‚å¦å¤–ï¼Œä½ ä¸ä½¿ç”¨ <code>main()</code> å‡½æ•°è¿›è¡Œæµ‹è¯• - å®ƒä»¬åœ¨å¤–é¢è¿è¡Œã€‚è¦åœ¨Playgroundä¸­è¿è¡Œè¿™ä¸ªï¼Œç‚¹å‡» <em>RUN</em> æ—è¾¹çš„<code>Â·Â·Â·</code>ï¼Œç„¶åæŠŠå®ƒæ”¹ä¸º <em>Test</em> ã€‚ç°åœ¨å¦‚æœä½ ç‚¹å‡»å®ƒï¼Œå®ƒå°†è¿è¡Œæµ‹è¯•ã€‚(å¦‚æœä½ å·²ç»å®‰è£…äº† Rustï¼Œä½ å°†è¾“å…¥ <code>cargo test</code> æ¥åšè¿™ä¸ªæµ‹è¯•)</p>
<p>è¿™é‡Œæ˜¯è¾“å‡º:</p>
<pre><code class="language-text">running 1 test
test two_is_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>è®©æˆ‘ä»¬æŠŠ<code>assert_eq!(2, 2)</code>æ”¹æˆ<code>assert_eq!(2, 3)</code>ï¼Œçœ‹çœ‹ä¼šæœ‰ä»€ä¹ˆç»“æœã€‚å½“æµ‹è¯•å¤±è´¥æ—¶ï¼Œä½ ä¼šå¾—åˆ°æ›´å¤šçš„ä¿¡æ¯ã€‚</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>assert_eq!(left, right)</code>æ˜¯Rustä¸­æµ‹è¯•ä¸€ä¸ªå‡½æ•°çš„ä¸»è¦æ–¹æ³•ã€‚å¦‚æœå®ƒä¸å·¥ä½œï¼Œå®ƒå°†æ˜¾ç¤ºä¸åŒçš„å€¼:å·¦è¾¹æœ‰2ï¼Œä½†å³è¾¹æœ‰3ã€‚</p>
<p><code>RUST_BACKTRACE=1</code>æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿™æ˜¯è®¡ç®—æœºä¸Šçš„ä¸€ä¸ªè®¾ç½®ï¼Œå¯ä»¥æä¾›æ›´å¤šå…³äºé”™è¯¯çš„ä¿¡æ¯ã€‚å¹¸å¥½playgroundä¹Ÿæœ‰:ç‚¹å‡»<code>STABLE</code>æ—è¾¹çš„<code>Â·Â·Â·</code>ï¼Œç„¶åè®¾ç½®å›æº¯ä¸º<code>ENABLED</code>ã€‚å¦‚æœä½ è¿™æ ·åšï¼Œå®ƒä¼šç»™ä½ <em>å¾ˆå¤š</em>çš„ä¿¡æ¯ã€‚</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: 2 == 3', src/lib.rs:3:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:78
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:59
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1076
   5: std::io::Write::write_fmt
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/io/mod.rs:1537
   6: std::io::impls::&lt;impl std::io::Write for alloc::boxed::Box&lt;W&gt;&gt;::write_fmt
             at src/libstd/io/impls.rs:176
   7: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:62
   8: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   9: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:198
  10: std::panicking::default_hook
             at src/libstd/panicking.rs:215
  11: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:486
  12: std::panicking::begin_panic
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:410
  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
  15: core::ops::function::FnOnce::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libcore/ops/function.rs:232
  16: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::FnOnce&lt;A&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/liballoc/boxed.rs:1076
  17: &lt;std::panic::AssertUnwindSafe&lt;F&gt; as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:318
  18: std::panicking::try::do_call
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:297
  19: std::panicking::try
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:274
  20: std::panic::catch_unwind
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:394
  21: test::run_test_in_process
             at src/libtest/lib.rs:541
  22: test::run_test::run_test_inner::{{closure}}
             at src/libtest/lib.rs:450
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>é™¤éä½ çœŸçš„æ‰¾ä¸åˆ°é—®é¢˜æ‰€åœ¨ï¼Œå¦åˆ™ä½ ä¸éœ€è¦ä½¿ç”¨å›æº¯ã€‚ä½†å¹¸è¿çš„æ˜¯ä½ ä¹Ÿä¸éœ€è¦å…¨éƒ¨ç†è§£ã€‚ å¦‚æœä½ ç»§ç»­é˜…è¯»ï¼Œä½ æœ€ç»ˆä¼šçœ‹åˆ°ç¬¬13è¡Œï¼Œé‚£é‡Œå†™ç€<code>playground</code>--é‚£æ˜¯å®ƒæåˆ°çš„ä½ çš„ä»£ç çš„ä½ç½®ã€‚å…¶ä»–çš„éƒ½æ˜¯å…³äºRustä¸ºäº†è¿è¡Œä½ çš„ç¨‹åº,åœ¨å…¶ä»–åº“ä¸­æ‰€åšçš„äº‹æƒ…ã€‚ä½†æ˜¯è¿™ä¸¤è¡Œå‘Šè¯‰ä½ ï¼Œå®ƒçœ‹çš„æ˜¯playgroundçš„ç¬¬2è¡Œå’Œç¬¬3è¡Œï¼Œè¿™æ˜¯ä¸€ä¸ªæç¤ºï¼Œè¦æ£€æŸ¥é‚£é‡Œã€‚è¿™é‡Œæ˜¯é‚£ä¸ªéƒ¨åˆ†:</p>
<pre><code class="language-text">  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
</code></pre>
<p>ç¼–è¾‘ï¼šRuståœ¨2021å¹´åˆæ”¹è¿›äº†å…¶å›æº¯ä¿¡æ¯ï¼Œåªæ˜¾ç¤ºæœ€æœ‰æ„ä¹‰çš„ä¿¡æ¯ã€‚ç°åœ¨å®ƒæ›´å®¹æ˜“é˜…è¯»ã€‚</p>
<pre><code class="language-text">failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: playground::two_is_two
             at ./src/lib.rs:3:5
   3: playground::two_is_two::{{closure}}
             at ./src/lib.rs:2:1
   4: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
</code></pre>
<p>ç°åœ¨æˆ‘ä»¬å†æŠŠå›æº¯å…³é—­ï¼Œå›åˆ°å¸¸è§„æµ‹è¯•ã€‚ç°åœ¨æˆ‘ä»¬è¦å†™ä¸€äº›å…¶ä»–å‡½æ•°ï¼Œå¹¶ä½¿ç”¨æµ‹è¯•å‡½æ•°æ¥æµ‹è¯•å®ƒä»¬ã€‚è¿™é‡Œæœ‰å‡ ä¸ª:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
<span class="boring">[test]
</span>fn it_returns_two() {
    assert_eq!(return_two(), 2);
}

fn return_six() -&gt; i8 {
    4 + return_two()
}
<span class="boring">[test]
</span>fn it_returns_six() {
    assert_eq!(return_six(), 6)
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨ï¼Œéƒ½èƒ½è¿è¡Œ:</p>
<pre><code class="language-text">running 2 tests
test it_returns_two ... ok
test it_returns_six ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>è¿™ä¸æ˜¯å¤ªéš¾ã€‚</p>
<p>é€šå¸¸ä½ ä¼šæƒ³æŠŠä½ çš„æµ‹è¯•æ”¾åœ¨è‡ªå·±çš„æ¨¡å—ä¸­ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œè¯·ä½¿ç”¨ç›¸åŒçš„ <code>mod</code> å…³é”®å­—ï¼Œå¹¶åœ¨å…¶ä¸Šæ–¹æ·»åŠ  <code>#[cfg(test)]</code>(è®°ä½:<code>cfg</code> çš„æ„æ€æ˜¯ "é…ç½®")ã€‚ä½ è¿˜è¦åœ¨æ¯ä¸ªæµ‹è¯•ä¸Šé¢ç»§ç»­å†™<code>#[test]</code>ã€‚è¿™æ˜¯å› ä¸ºä»¥åå½“ä½ å®‰è£…Rustæ—¶ï¼Œä½ å¯ä»¥åšæ›´å¤æ‚çš„æµ‹è¯•ã€‚ä½ å°†å¯ä»¥è¿è¡Œä¸€ä¸ªæµ‹è¯•ï¼Œæˆ–è€…æ‰€æœ‰çš„æµ‹è¯•ï¼Œæˆ–è€…è¿è¡Œå‡ ä¸ªæµ‹è¯•ã€‚å¦å¤–åˆ«å¿˜äº†å†™<code>use super::*;</code>ï¼Œå› ä¸ºæµ‹è¯•æ¨¡å—éœ€è¦ä½¿ç”¨ä¸Šé¢çš„å‡½æ•°ã€‚ç°åœ¨å®ƒçœ‹èµ·æ¥ä¼šæ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
fn return_six() -&gt; i8 {
    4 + return_two()
}

<span class="boring">[cfg(test)]
</span>mod tests {
    use super::*;

    #[test]
    fn it_returns_six() {
        assert_eq!(return_six(), 6)
    }
    #[test]
    fn it_returns_two() {
        assert_eq!(return_two(), 2);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="æµ‹è¯•é©±åŠ¨çš„å¼€å‘"><a class="header" href="#æµ‹è¯•é©±åŠ¨çš„å¼€å‘">æµ‹è¯•é©±åŠ¨çš„å¼€å‘</a></h3>
<p>åœ¨é˜…è¯»Rustæˆ–å…¶ä»–è¯­è¨€æ—¶ï¼Œä½ å¯èƒ½ä¼šçœ‹åˆ° "æµ‹è¯•é©±åŠ¨å¼€å‘"è¿™ä¸ªè¯ã€‚è¿™æ˜¯ç¼–å†™ç¨‹åºçš„ä¸€ç§æ–¹å¼ï¼Œæœ‰äº›äººå–œæ¬¢å®ƒï¼Œè€Œæœ‰äº›äººåˆ™å–œæ¬¢å…¶ä»–çš„æ–¹å¼ã€‚"æµ‹è¯•é©±åŠ¨å¼€å‘"çš„æ„æ€æ˜¯ "å…ˆå†™æµ‹è¯•ï¼Œå†å†™ä»£ç "ã€‚å½“ä½ è¿™æ ·åšçš„æ—¶å€™ï¼Œä½ ä¼šæœ‰å¾ˆå¤šå…³äºä½ æƒ³è¦ä½ çš„ä»£ç åšçš„æ‰€æœ‰äº‹æƒ…çš„æµ‹è¯•ä»£ç ã€‚ç„¶åä½ å¼€å§‹å†™ä»£ç ï¼Œå¹¶è¿è¡Œæµ‹è¯•ï¼Œçœ‹çœ‹ä½ æ˜¯å¦åšå¯¹äº†ã€‚ç„¶åï¼Œå½“ä½ æ·»åŠ å’Œé‡å†™ä»£ç æ—¶ï¼Œå¦‚æœæœ‰ä»€ä¹ˆåœ°æ–¹å‡ºäº†é—®é¢˜ï¼Œæµ‹è¯•ä»£ç ä¼šä¸€ç›´åœ¨é‚£é‡Œå‘ä½ å±•ç¤ºã€‚è¿™åœ¨Rustä¸­æ˜¯éå¸¸å®¹æ˜“çš„ï¼Œå› ä¸ºç¼–è¯‘å™¨ç»™å‡ºäº†å¾ˆå¤šå¾…ä¿®å¤å†…å®¹çš„ä¿¡æ¯ã€‚è®©æˆ‘ä»¬å†™ä¸€ä¸ªæµ‹è¯•é©±åŠ¨å¼€å‘çš„å°ä¾‹å­ï¼Œçœ‹çœ‹å®ƒæ˜¯ä»€ä¹ˆæ ·å­çš„ã€‚</p>
<p>è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸ªæ¥å—ç”¨æˆ·è¾“å…¥çš„è®¡ç®—å™¨ã€‚å®ƒå¯ä»¥åŠ (+)ï¼Œä¹Ÿå¯ä»¥å‡(-)ã€‚å¦‚æœç”¨æˆ·å†™ "5+6"ï¼Œå®ƒåº”è¯¥è¿”å›11ï¼Œå¦‚æœç”¨æˆ·å†™ "5+6-7"ï¼Œå®ƒåº”è¯¥è¿”å›4ï¼Œä»¥æ­¤ç±»æ¨ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆä»æµ‹è¯•å‡½æ•°å¼€å§‹ã€‚ä½ ä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œæµ‹è¯•ä¸­çš„å‡½æ•°åé€šå¸¸éƒ½ç›¸å½“é•¿ã€‚è¿™æ˜¯å› ä¸ºä½ å¯èƒ½ä¼šè¿è¡Œå¾ˆå¤šæµ‹è¯•ï¼Œä½ æƒ³äº†è§£å“ªäº›æµ‹è¯•å¤±è´¥äº†ã€‚</p>
<p>æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªåä¸º<code>math()</code>çš„å‡½æ•°å°±å¯ä»¥å®Œæˆæ‰€æœ‰çš„å·¥ä½œã€‚å®ƒå°†è¿”å›ä¸€ä¸ª <code>i32</code>(æˆ‘ä»¬ä¸ä¼šä½¿ç”¨æµ®ç‚¹æ•°)ã€‚å› ä¸ºå®ƒéœ€è¦è¿”å›ä¸€äº›ä¸œè¥¿ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡éƒ½åªè¿”å› <code>6</code>ã€‚ç„¶åæˆ‘ä»¬å°†å†™ä¸‰ä¸ªæµ‹è¯•å‡½æ•°ã€‚å½“ç„¶ï¼Œå®ƒä»¬éƒ½ä¼šå¤±è´¥ã€‚ç°åœ¨çš„ä»£ç æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn math(input: &amp;str) -&gt; i32 {
    6
}

<span class="boring">[cfg(test)]
</span>mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>å®ƒç»™äº†æˆ‘ä»¬è¿™ä¸ªä¿¡æ¯ã€‚</p>
<pre><code class="language-text">running 3 tests
test tests::one_minus_minus_one_is_two ... FAILED
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>ä»¥åŠ<code>thread 'tests::one_plus_one_is_two' panicked at 'assertion failed: `(left == right)` </code>çš„æ‰€æœ‰ä¿¡æ¯ã€‚æˆ‘ä»¬ä¸éœ€è¦åœ¨è¿™é‡Œå…¨éƒ¨æ‰“å°å‡ºæ¥ã€‚</p>
<p>ç°åœ¨è¦è€ƒè™‘å¦‚ä½•åˆ›å»ºè®¡ç®—å™¨ã€‚æˆ‘ä»¬å°†æ¥å—ä»»ä½•æ•°å­—ï¼Œä»¥åŠç¬¦å·<code>+-</code>ã€‚æˆ‘ä»¬å°†å…è®¸ç©ºæ ¼ï¼Œä½†ä¸å…è®¸å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬ä»åŒ…å«æ‰€æœ‰æ•°å€¼çš„<code>const</code>å¼€å§‹ã€‚ç„¶åæˆ‘ä»¬å°†ä½¿ç”¨ <code>.chars()</code> æŒ‰å­—ç¬¦è¿›è¡Œè¿­ä»£ï¼Œå¹¶ä½¿ç”¨ <code>.all()</code> ç¡®ä¿å®ƒä»¬éƒ½åœ¨é‡Œé¢ã€‚</p>
<p>ç„¶åï¼Œæˆ‘ä»¬å°†æ·»åŠ ä¸€ä¸ªä¼šå´©æºƒçš„æµ‹è¯•ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæ·»åŠ  <code>#[should_panic]</code> å±æ€§:ç°åœ¨å¦‚æœå®ƒå´©æºƒï¼Œæµ‹è¯•å°†æˆåŠŸã€‚</p>
<p>ç°åœ¨ä»£ç çœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = "1234567890+- "; // Don't forget the space at the end

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) {
        panic!("Please only input numbers, +-, or spaces");
    }
    6 // we still return a 6 for now
}

<span class="boring">[cfg(test)]
</span>mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }

    #[test]
    #[should_panic]  // Here is our new test - it should panic
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨ï¼Œå½“æˆ‘ä»¬è¿è¡Œæµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬å¾—åˆ°è¿™æ ·çš„ç»“æœã€‚</p>
<pre><code class="language-text">running 4 tests
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_minus_minus_one_is_two ... FAILED
test tests::panics_when_characters_not_right ... ok
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>ä¸€ä¸ªæˆåŠŸäº†! æˆ‘ä»¬çš„<code>math()</code>å‡½æ•°ç°åœ¨åªèƒ½æ¥å—å¥½çš„è¾“å…¥äº†ã€‚</p>
<p>ä¸‹ä¸€æ­¥æ˜¯ç¼–å†™å®é™…çš„è®¡ç®—å™¨ã€‚è¿™å°±æ˜¯å…ˆæœ‰æµ‹è¯•çš„æœ‰è¶£ä¹‹å¤„:å®é™…çš„ä»£ç è¦æ™šå¾ˆå¤šã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†æŠŠè®¡ç®—å™¨çš„é€»è¾‘æ”¾åœ¨ä¸€èµ·ã€‚æˆ‘ä»¬è¦åšåˆ°ä»¥ä¸‹å‡ ç‚¹ã€‚</p>
<ul>
<li>æ‰€æœ‰çš„ç©ºä½éƒ½åº”è¯¥è¢«åˆ é™¤ã€‚è¿™åœ¨<code>.filter()</code>ä¸­å¾ˆå®¹æ˜“å®ç°ã€‚</li>
<li>æ‰€æœ‰è¾“å…¥åº”è¯¥å˜æˆä¸€ä¸ª<code>Vec</code>ã€‚<code>+</code>ä¸éœ€è¦æˆä¸ºè¾“å…¥ï¼Œä½†æ˜¯å½“ç¨‹åºçœ‹åˆ°<code>+</code>æ—¶ï¼Œåº”è¯¥çŸ¥é“è¿™ä¸ªæ•°å­—å·²ç»å®Œæˆäº†ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥<code>+</code>åº”è¯¥è¿™æ ·åš:
<ol>
<li>çœ‹åˆ°<code>1</code>ï¼ŒæŠŠå®ƒæ¨åˆ°ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ä¸­ã€‚</li>
<li>çœ‹åˆ°å¦ä¸€ä¸ª1ï¼ŒæŠŠå®ƒæ¨å…¥å­—ç¬¦ä¸²ä¸­(ç°åœ¨æ˜¯ "11")ã€‚</li>
<li>çœ‹åˆ°ä¸€ä¸ª<code>+</code>ï¼ŒçŸ¥é“è¿™ä¸ªæ•°å­—å·²ç»ç»“æŸã€‚å®ƒä¼šæŠŠå­—ç¬¦ä¸²æ¨å…¥vecä¸­ï¼Œç„¶åæ¸…ç©ºå­—ç¬¦ä¸²ã€‚</li>
</ol>
</li>
<li>ç¨‹åºå¿…é¡»è®¡ç®—å‡º<code>-</code>çš„æ•°é‡ã€‚å¥‡æ•°(1ï¼Œ3ï¼Œ5...)è¡¨ç¤ºå‡æ³•ï¼Œå¶æ•°(2ï¼Œ4ï¼Œ6...)è¡¨ç¤ºåŠ æ³•ã€‚æ‰€ä»¥ "1--9"åº”è¯¥æ˜¯10ï¼Œè€Œä¸æ˜¯-8ã€‚</li>
<li>ç¨‹åºåº”è¯¥åˆ é™¤æœ€åä¸€ä¸ªæ•°å­—åé¢çš„ä»»ä½•ä¸œè¥¿ã€‚<code>5+5+++++----</code>æ˜¯ç”±<code>OKAY_CHARACTERS</code>ä¸­çš„æ‰€æœ‰å­—ç¬¦ç»„æˆçš„ï¼Œä½†å®ƒåº”è¯¥å˜æˆ<code>5+5</code>ã€‚<code>.trim_end_matches()</code>å°±å¾ˆç®€å•äº†ï¼Œä½ æŠŠ<code>&amp;str</code>æœ«å°¾ç¬¦åˆçš„ä¸œè¥¿éƒ½å»æ‰ã€‚</li>
</ul>
<p>é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œ<code>.trim_end_matches()</code>å’Œ<code>.trim_start_matches()</code>æ›¾ç»æ˜¯<code>trim_right_matches()</code>å’Œ<code>trim_left_matches()</code>ã€‚ä½†åæ¥äººä»¬æ³¨æ„åˆ°æœ‰äº›è¯­è¨€æ˜¯ä»å³åˆ°å·¦(æ³¢æ–¯è¯­ã€å¸Œä¼¯æ¥è¯­ç­‰)ï¼Œæ‰€ä»¥å·¦å³éƒ½æ˜¯é”™çš„ã€‚ä½ å¯èƒ½è¿˜èƒ½åœ¨ä¸€äº›ä»£ç ä¸­çœ‹åˆ°æ—§çš„åå­—ï¼Œä½†å®ƒä»¬æ˜¯ä¸€æ ·çš„)ã€‚)</p>
<p>é¦–å…ˆæˆ‘ä»¬åªæƒ³é€šè¿‡æ‰€æœ‰çš„æµ‹è¯•ã€‚é€šè¿‡æµ‹è¯•åï¼Œæˆ‘ä»¬å°±å¯ä»¥ "é‡æ„"äº†ã€‚é‡æ„çš„æ„æ€æ˜¯è®©ä»£ç å˜å¾—æ›´å¥½ï¼Œé€šå¸¸æ˜¯é€šè¿‡ç»“æ„ã€æšä¸¾å’Œæ–¹æ³•ç­‰æ–¹å¼ã€‚ä¸‹é¢æ˜¯æˆ‘ä»¬ä½¿æµ‹è¯•é€šè¿‡çš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = "1234567890+- ";

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric())
    {
        panic!("Please only input numbers, +-, or spaces.");
    }

    let input = input.trim_end_matches(|x| "+- ".contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;(); // Remove + and - at the end, and all spaces
    let mut result_vec = vec![]; // Results go in here
    let mut push_string = String::new(); // This is the string we push in every time. We will keep reusing it in the loop.
    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !push_string.is_empty() { // If the string is empty, we don't want to push "" into result_vec
                    result_vec.push(push_string.clone()); // But if it's not empty, it will be a number. Push it into the vec
                    push_string.clear(); // Then clear the string
                }
            },
            '-' =&gt; { // If we get a -,
                if push_string.contains('-') || push_string.is_empty() { // check to see if it's empty or has a -
                    push_string.push(character) // if so, then push it in
                } else { // otherwise, it will contain a number
                result_vec.push(push_string.clone()); // so push the number into result_vec, clear it and then push -
                push_string.clear();
                push_string.push(character);
                }
            },
            number =&gt; { // number here means "anything else that matches". We selected the name here
                if push_string.contains('-') { // We might have some - characters to push in first
                    result_vec.push(push_string.clone());
                    push_string.clear();
                    push_string.push(number);
                } else { // But if we don't, that means we can push the number in
                    push_string.push(number);
                }
            },
        }
    }
    result_vec.push(push_string); // Push one last time after the loop is over. Don't need to .clone() because we don't use it anymore

    let mut total = 0; // Now it's time to do math. Start with a total
    let mut adds = true; // true = add, false = subtract
    let mut math_iter = result_vec.into_iter();
    while let Some(entry) = math_iter.next() { // Iter through the items
        if entry.contains('-') { // If it has a - character, check if it's even or odd
            if entry.chars().count() % 2 == 1 {
                adds = match adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue; // Go to the next item
            } else {
                continue;
            }
        }
        if adds == true {
            total += entry.parse::&lt;i32&gt;().unwrap(); // If there is no '-', it must be a number. So we are safe to unwrap
        } else {
            total -= entry.parse::&lt;i32&gt;().unwrap();
            adds = true;  // After subtracting, reset adds to true.
        }
    }
    total // Finally, return the total
}
   /// We'll add a few more tests just to make sure

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math("9+9-9-9"), 0); // This is a new test
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math("8  - 9     +9-----+++++"), 8); // This is a new test
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨æµ‹è¯•é€šè¿‡äº†!</p>
<pre><code class="language-text">running 6 tests
test tests::one_minus_minus_one_is_two ... ok
test tests::nine_plus_nine_minus_nine_minus_nine_is_zero ... ok
test tests::one_minus_two_is_minus_one ... ok
test tests::eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end ... ok
test tests::one_plus_one_is_two ... ok
test tests::panics_when_characters_not_right ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æµ‹è¯•é©±åŠ¨çš„å¼€å‘ä¸­ï¼Œæœ‰ä¸€ä¸ªæ¥å›çš„è¿‡ç¨‹ã€‚å®ƒæ˜¯è¿™æ ·çš„ã€‚</p>
<ul>
<li>é¦–å…ˆä½ è¦å†™å‡ºæ‰€æœ‰ä½ èƒ½æƒ³åˆ°çš„æµ‹è¯•</li>
<li>ç„¶åä½ å¼€å§‹å†™ä»£ç ã€‚</li>
<li>å½“ä½ å†™ä»£ç çš„æ—¶å€™ï¼Œä½ ä¼šæœ‰å…¶ä»–æµ‹è¯•çš„æƒ³æ³•ã€‚</li>
<li>ä½ æ·»åŠ æµ‹è¯•ï¼Œä½ çš„æµ‹è¯•éšç€ä½ çš„å‘å±•è€Œå¢é•¿ã€‚ä½ çš„æµ‹è¯•è¶Šå¤šï¼Œä½ çš„ä»£ç è¢«æ£€æŸ¥çš„æ¬¡æ•°å°±è¶Šå¤šã€‚</li>
</ul>
<p>å½“ç„¶ï¼Œæµ‹è¯•å¹¶ä¸èƒ½æ£€æŸ¥æ‰€æœ‰çš„ä¸œè¥¿ï¼Œè®¤ä¸º "é€šè¿‡æ‰€æœ‰æµ‹è¯•=ä»£ç æ˜¯å®Œç¾çš„"æ˜¯é”™è¯¯çš„ã€‚ä½†æ˜¯ï¼Œæµ‹è¯•å¯¹äºä½ ä¿®æ”¹ä»£ç çš„æ—¶å€™æ˜¯éå¸¸å¥½çš„ã€‚å¦‚æœä½ ä»¥åä¿®æ”¹äº†ä»£ç ï¼Œç„¶åè¿è¡Œæµ‹è¯•ï¼Œå¦‚æœå…¶ä¸­ä¸€ä¸ªæµ‹è¯•ä¸æˆåŠŸï¼Œä½ å°±ä¼šçŸ¥é“è¯¥æ€ä¹ˆä¿®å¤ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬å¯ä»¥é‡å†™(é‡æ„)ä¸€ä¸‹ä»£ç ã€‚ä¸€ä¸ªå¥½çš„æ–¹æ³•æ˜¯ç”¨clippyå¼€å§‹ã€‚å¦‚æœä½ å®‰è£…äº†Rustï¼Œé‚£ä¹ˆä½ å¯ä»¥è¾“å…¥<code>cargo clippy</code>ï¼Œå¦‚æœä½ ä½¿ç”¨çš„æ˜¯Playgroundï¼Œé‚£ä¹ˆç‚¹å‡»<code>TOOLS</code>ï¼Œé€‰æ‹©Clippyã€‚Clippyä¼šæŸ¥çœ‹ä½ çš„ä»£ç ï¼Œå¹¶ç»™ä½ æç¤ºï¼Œè®©ä½ çš„ä»£ç æ›´ç®€å•ã€‚æˆ‘ä»¬çš„ä»£ç æ²¡æœ‰ä»»ä½•é”™è¯¯ï¼Œä½†å®ƒå¯ä»¥æ›´å¥½ã€‚</p>
<p>Clippyä¼šå‘Šè¯‰æˆ‘ä»¬ä¸¤ä»¶äº‹ã€‚</p>
<pre><code class="language-text">warning: this loop could be written as a `for` loop
  --&gt; src/lib.rs:44:5
   |
44 |     while let Some(entry) = math_iter.next() { // Iter through the items
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for entry in math_iter`
   |
   = note: `#[warn(clippy::while_let_on_iterator)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator

warning: equality checks against true are unnecessary
  --&gt; src/lib.rs:53:12
   |
53 |         if adds == true {
   |            ^^^^^^^^^^^^ help: try simplifying it as shown: `adds`
   |
   = note: `#[warn(clippy::bool_comparison)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison
</code></pre>
<p>è¿™æ˜¯çœŸçš„:<code>for entry in math_iter</code>æ¯”<code>while let Some(entry) = math_iter.next()</code>ç®€å•å¾—å¤šã€‚è€Œ<code>for</code>å¾ªç¯å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæ‰€ä»¥æˆ‘ä»¬æ²¡æœ‰ä»»ä½•ç†ç”±å†™<code>.iter()</code>ã€‚è°¢è°¢ä½ ï¼Œclippy! è€Œä¸”æˆ‘ä»¬ä¹Ÿä¸éœ€è¦åš<code>math_iter</code>:æˆ‘ä»¬å¯ä»¥ç›´æ¥å†™<code>for entry in result_vec</code>ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬å°†å¼€å§‹ä¸€äº›çœŸæ­£çš„é‡æ„ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª <code>Calculator</code> ç»“æ„ä½“ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„å˜é‡ã€‚è¿™å°†æ‹¥æœ‰æˆ‘ä»¬ä½¿ç”¨çš„æ‰€æœ‰å˜é‡ã€‚æˆ‘ä»¬å°†æ”¹å˜ä¸¤ä¸ªåå­—ä»¥ä½¿å…¶æ›´åŠ æ¸…æ™°ã€‚<code>result_vec</code>å°†å˜æˆ<code>results</code>ï¼Œ<code>push_string</code>å°†å˜æˆ<code>current_input</code>(currentçš„æ„æ€æ˜¯ "ç°åœ¨")ã€‚è€Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œå®ƒåªæœ‰ä¸€ç§æ–¹æ³•:newã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨æˆ‘ä»¬çš„ä»£ç å…¶å®æ¯”è¾ƒé•¿ï¼Œä½†æ›´å®¹æ˜“è¯»æ‡‚ã€‚æ¯”å¦‚ï¼Œ<code>if adds</code>ç°åœ¨æ˜¯<code>if calculator.adds</code>ï¼Œè¿™å°±è·Ÿè¯»è‹±æ–‡å®Œå…¨ä¸€æ ·ã€‚å®ƒçš„æ ·å­æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}

const OKAY_CHARACTERS: &amp;str = "1234567890+- ";

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!("Please only input numbers, +-, or spaces");
    }

    let input = input.trim_end_matches(|x| "+- ".contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.current_input.push(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.current_input.clear();
                calculator.current_input.push(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                    calculator.current_input.push(number);
                } else {
                    calculator.current_input.push(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math("9+9-9-9"), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math("8  - 9     +9-----+++++"), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>æœ€åæˆ‘ä»¬å¢åŠ ä¸¤ä¸ªæ–°æ–¹æ³•ã€‚ä¸€ä¸ªå«åš <code>.clear()</code>ï¼Œæ¸…é™¤ <code>current_input()</code>ã€‚å¦ä¸€ä¸ªå«åš <code>push_char()</code>ï¼ŒæŠŠè¾“å…¥æ¨åˆ° <code>current_input()</code> ä¸Šã€‚è¿™æ˜¯æˆ‘ä»¬é‡æ„åçš„ä»£ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }

    fn clear(&amp;mut self) {
        self.current_input.clear();
    }

    fn push_char(&amp;mut self, character: char) {
        self.current_input.push(character);
    }
}

const OKAY_CHARACTERS: &amp;str = "1234567890+- ";

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!("Please only input numbers, +-, or spaces");
    }

    let input = input.trim_end_matches(|x| "+- ".contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.push_char(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.clear();
                calculator.push_char(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                    calculator.push_char(number);
                } else {
                    calculator.push_char(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math("1 + 1"), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math("1 - 2"), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math("1 - -1"), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math("9+9-9-9"), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math("8  - 9     +9-----+++++"), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math("7 + seven");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨å¤§æ¦‚å·²ç»å¤Ÿå¥½äº†ã€‚æˆ‘ä»¬å¯ä»¥å†™æ›´å¤šçš„æ–¹æ³•ï¼Œä½†æ˜¯åƒ<code>calculator.results.push(calculator.current_input.clone());</code>è¿™æ ·çš„è¡Œå·²ç»å¾ˆæ¸…æ¥šäº†ã€‚é‡æ„æœ€å¥½æ˜¯åœ¨ä½ å®Œæˆåè¿˜èƒ½è½»æ¾é˜…è¯»ä»£ç çš„æ—¶å€™ã€‚ä½ ä¸å¸Œæœ›åªæ˜¯ä¸ºäº†è®©ä»£ç å˜çŸ­è€Œé‡æ„:ä¾‹å¦‚ï¼Œ<code>clc.clr()</code>å°±æ¯”<code>calculator.clear()</code>å·®å¾ˆå¤šã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¤–éƒ¨crate"><a class="header" href="#å¤–éƒ¨crate">å¤–éƒ¨crate</a></h2>
<p>å¤–éƒ¨crateçš„æ„æ€æ˜¯ "åˆ«äººçš„crate"ã€‚</p>
<p>åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ <em>å·®ä¸å¤š</em>éœ€è¦å®‰è£…Rustï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥åªä½¿ç”¨Playgroundã€‚ç°åœ¨æˆ‘ä»¬è¦å­¦ä¹ å¦‚ä½•å¯¼å…¥åˆ«äººå†™çš„crateã€‚è¿™åœ¨Rustä¸­å¾ˆé‡è¦ï¼ŒåŸå› æœ‰äºŒã€‚</p>
<ul>
<li>å¯¼å…¥å…¶ä»–çš„crateå¾ˆå®¹æ˜“ï¼Œå¹¶ä¸”...</li>
<li>Rustæ ‡å‡†åº“æ˜¯ç›¸å½“å°çš„ã€‚</li>
</ul>
<p>è¿™æ„å‘³ç€ï¼Œåœ¨Rustä¸­ï¼Œå¾ˆå¤šåŸºæœ¬åŠŸèƒ½éƒ½éœ€è¦ç”¨åˆ°å¤–éƒ¨Crateï¼Œè¿™å¾ˆæ­£å¸¸ã€‚æˆ‘ä»¬çš„æƒ³æ³•æ˜¯ï¼Œå¦‚æœä½¿ç”¨å¤–éƒ¨Crateå¾ˆæ–¹ä¾¿ï¼Œé‚£ä¹ˆä½ å¯ä»¥é€‰æ‹©æœ€å¥½çš„ä¸€ä¸ªã€‚ä¹Ÿè®¸ä¸€ä¸ªäººä¼šä¸ºä¸€ä¸ªåŠŸèƒ½åˆ›å»ºä¸€ä¸ªcrateï¼Œç„¶åå…¶ä»–äººä¼šåˆ›å»ºä¸€ä¸ªæ›´å¥½çš„crateã€‚</p>
<p>åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬åªçœ‹æœ€æµè¡Œçš„crateï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªä½¿ç”¨Rustçš„äººéƒ½çŸ¥é“çš„crateã€‚</p>
<p>è¦å¼€å§‹å­¦ä¹ å¤–éƒ¨Crateï¼Œæˆ‘ä»¬å°†ä»æœ€å¸¸è§çš„Crateå¼€å§‹ã€‚<code>rand</code>.</p>
<h3 id="rand"><a class="header" href="#rand">rand</a></h3>
<p>ä½ æœ‰æ²¡æœ‰æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰ä½¿ç”¨ä»»ä½•éšæœºæ•°ï¼Ÿé‚£æ˜¯å› ä¸ºéšæœºæ•°ä¸åœ¨æ ‡å‡†åº“ä¸­ã€‚ä½†æ˜¯æœ‰å¾ˆå¤šcrate "å‡ ä¹æ˜¯æ ‡å‡†åº“"ï¼Œå› ä¸ºå¤§å®¶éƒ½åœ¨ä½¿ç”¨å®ƒä»¬ã€‚åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå¸¦å…¥ä¸€ä¸ª crate æ˜¯éå¸¸å®¹æ˜“çš„ã€‚å¦‚æœä½ çš„ç”µè„‘ä¸Šæœ‰Rustï¼Œæœ‰ä¸€ä¸ªå«<code>Cargo.toml</code>çš„æ–‡ä»¶ï¼Œé‡Œé¢æœ‰è¿™äº›ä¿¡æ¯ã€‚<code>Cargo.toml</code>æ–‡ä»¶åœ¨ä½ å¯åŠ¨æ—¶æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><code class="language-text">[package]
name = "rust_book"
version = "0.1.0"
authors = ["David MacLeod"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>ç°åœ¨ï¼Œå¦‚æœä½ æƒ³æ·»åŠ <code>rand</code> crateï¼Œåœ¨<code>crates.io</code>ä¸Šæœç´¢å®ƒï¼Œè¿™æ˜¯æ‰€æœ‰crateçš„å»å¤„ã€‚è¿™å°†å¸¦ä½ åˆ°<code>https://crates.io/crates/rand</code>ã€‚å½“ä½ ç‚¹å‡»é‚£ä¸ªï¼Œä½ å¯ä»¥çœ‹åˆ°ä¸€ä¸ªå±å¹•ï¼Œä¸Šé¢å†™ç€<code>Cargo.toml   rand = "0.7.3"</code>ã€‚ä½ æ‰€è¦åšçš„å°±æ˜¯åœ¨[dependencies]ä¸‹æ·»åŠ è¿™æ ·çš„å†…å®¹:</p>
<pre><code class="language-text">[package]
name = "rust_book"
version = "0.1.0"
authors = ["David MacLeod"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = "0.7.3"
</code></pre>
<p>ç„¶åCargoä¼šå¸®ä½ å®Œæˆå‰©ä¸‹çš„å·¥ä½œã€‚ç„¶åä½ å°±å¯ä»¥åœ¨<code>rand</code>æ–‡æ¡£ç½‘ç«™ä¸Šå¼€å§‹ç¼–å†™åƒ<a href="https://docs.rs/rand/0.7.3/rand/">æœ¬ä¾‹ä»£ç </a>è¿™æ ·çš„ä»£ç ã€‚è¦æƒ³è¿›å…¥æ–‡æ¡£ï¼Œä½ å¯ä»¥ç‚¹å‡»<a href="https://crates.io/crates/rand">crates.ioä¸Šçš„é¡µé¢</a>ä¸­çš„<code>docs</code>æŒ‰é’®ã€‚</p>
<p>å…³äºCargoçš„ä»‹ç»å°±åˆ°è¿™é‡Œäº†:æˆ‘ä»¬ç°åœ¨ä½¿ç”¨çš„è¿˜åªæ˜¯playgroundã€‚å¹¸è¿çš„æ˜¯ï¼Œplaygroundå·²ç»å®‰è£…äº†å‰100ä¸ªcrateã€‚æ‰€ä»¥ä½ è¿˜ä¸éœ€è¦å†™è¿›<code>Cargo.toml</code>ã€‚åœ¨playgroundä¸Šï¼Œä½ å¯ä»¥æƒ³è±¡ï¼Œå®ƒæœ‰ä¸€ä¸ªè¿™æ ·çš„é•¿é•¿çš„åˆ—è¡¨ï¼Œæœ‰100ä¸ªcrateã€‚</p>
<pre><code class="language-text">[dependencies]
rand = "0.7.3"
some_other_crate = "0.1.0"
another_nice_crate = "1.7"
</code></pre>
<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœè¦ä½¿ç”¨<code>rand</code>ï¼Œä½ å¯ä»¥ç›´æ¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">use rand; // This means the whole crate rand
          // On your computer you can't just write this;
          // you need to write in the Cargo.toml file first

fn main() {
    for _ in 0..5 {
        let random_u16 = rand::random::&lt;u16&gt;();
        print!("{} ", random_u16);
    }
}</code></pre></pre>
<p>æ¯æ¬¡éƒ½ä¼šæ‰“å°ä¸åŒçš„<code>u16</code>å·ç ï¼Œæ¯”å¦‚<code>42266 52873 56528 46927 6867</code>ã€‚</p>
<p><code>rand</code>ä¸­çš„ä¸»è¦åŠŸèƒ½æ˜¯<code>random</code>å’Œ<code>thread_rng</code>(rngçš„æ„æ€æ˜¯ "éšæœºæ•°å‘ç”Ÿå™¨")ã€‚è€Œå®é™…ä¸Šå¦‚æœä½ çœ‹<code>random</code>ï¼Œå®ƒè¯´:"è¿™åªæ˜¯<code>thread_rng().gen()</code>çš„ä¸€ä¸ªå¿«æ·æ–¹å¼"ã€‚æ‰€ä»¥å…¶å®æ˜¯<code>thread_rng</code>åŸºæœ¬åšå®Œäº†ä¸€åˆ‡ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œä»1åˆ°10çš„æ•°å­—ã€‚ä¸ºäº†å¾—åˆ°è¿™äº›æ•°å­—ï¼Œæˆ‘ä»¬åœ¨1åˆ°11ä¹‹é—´ä½¿ç”¨<code>.gen_range()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use rand::{thread_rng, Rng}; // Or just use rand::*; if we are lazy

fn main() {
    let mut number_maker = thread_rng();
    for _ in 0..5 {
        print!("{} ", number_maker.gen_range(1, 11));
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º<code>7 2 4 8 6</code>è¿™æ ·çš„ä¸œè¥¿ã€‚</p>
<p>ç”¨éšæœºæ•°æˆ‘ä»¬å¯ä»¥åšä¸€äº›æœ‰è¶£çš„äº‹æƒ…ï¼Œæ¯”å¦‚ä¸ºæ¸¸æˆåˆ›å»ºè§’è‰²ã€‚æˆ‘ä»¬å°†ä½¿ç”¨<code>rand</code>å’Œå…¶ä»–ä¸€äº›æˆ‘ä»¬çŸ¥é“çš„ä¸œè¥¿æ¥åˆ›å»ºå®ƒä»¬ã€‚åœ¨è¿™ä¸ªæ¸¸æˆä¸­ï¼Œæˆ‘ä»¬çš„è§’è‰²æœ‰å…­ç§çŠ¶æ€ï¼Œç”¨ä¸€ä¸ªd6æ¥è¡¨ç¤ºä»–ä»¬ã€‚d6æ˜¯ä¸€ä¸ªç«‹æ–¹ä½“ï¼Œå½“ä½ æŠ•æ·å®ƒæ—¶ï¼Œå®ƒèƒ½ç»™å‡º1ã€2ã€3ã€4ã€5æˆ–6ã€‚æ¯ä¸ªè§’è‰²éƒ½ä¼šæ·ä¸‰æ¬¡d6ï¼Œæ‰€ä»¥æ¯ä¸ªç»Ÿè®¡éƒ½åœ¨3åˆ°18ä¹‹é—´ã€‚</p>
<p>ä½†æ˜¯æœ‰æ—¶å€™å¦‚æœä½ çš„è§’è‰²æœ‰ä¸€äº›ä½çš„ä¸œè¥¿ï¼Œæ¯”å¦‚3æˆ–4ï¼Œé‚£å°±ä¸å…¬å¹³äº†ã€‚æ¯”å¦‚è¯´ä½ çš„åŠ›é‡æ˜¯3ï¼Œä½ å°±ä¸èƒ½æ‹¿ä¸œè¥¿ã€‚æ‰€ä»¥è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯ç”¨d6å››æ¬¡ã€‚ä½ æ·å››æ¬¡ï¼Œç„¶åæ‰”æ‰æœ€ä½çš„æ•°å­—ã€‚æ‰€ä»¥å¦‚æœä½ æ·3ï¼Œ3ï¼Œ1ï¼Œ6ï¼Œé‚£ä¹ˆä½ ä¿ç•™3ï¼Œ3ï¼Œ6=12ã€‚æˆ‘ä»¬ä¹Ÿä¼šæŠŠè¿™ä¸ªæ–¹æ³•åšå‡ºæ¥ï¼Œæ‰€ä»¥æ¸¸æˆçš„ä¸»äººå¯ä»¥å†³å®šã€‚</p>
<p>è¿™æ˜¯æˆ‘ä»¬ç®€å•çš„è§’è‰²åˆ›å»ºå™¨ã€‚æˆ‘ä»¬ä¸ºæ•°æ®ç»Ÿè®¡åˆ›å»ºäº†ä¸€ä¸ª<code>Character</code>ç»“æ„ï¼Œç”šè‡³è¿˜å®ç°äº†<code>Display</code>æ¥æŒ‰ç…§æˆ‘ä»¬æƒ³è¦çš„æ–¹å¼æ‰“å°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use rand::{thread_rng, Rng}; // Or just use rand::*; if we are lazy
use std::fmt; // Going to impl Display for our character


struct Character {
    strength: u8,
    dexterity: u8,    // This means "body quickness"
    constitution: u8, // This means "health"
    intelligence: u8,
    wisdom: u8,
    charisma: u8, // This means "popularity with people"
}

fn three_die_six() -&gt; u8 { // A "die" is the thing you throw to get the number
    let mut generator = thread_rng(); // Create our random number generator
    let mut stat = 0; // This is the total
    for _ in 0..3 {
        stat += generator.gen_range(1..=6); // Add each time
    }
    stat // Return the total
}

fn four_die_six() -&gt; u8 {
    let mut generator = thread_rng();
    let mut results = vec![]; // First put the numbers in a vec
    for _ in 0..4 {
        results.push(generator.gen_range(1..=6));
    }
    results.sort(); // Now a result like [4, 3, 2, 6] becomes [2, 3, 4, 6]
    results.remove(0); // Now it would be [3, 4, 6]
    results.iter().sum() // Return this result
}

enum Dice {
    Three,
    Four
}

impl Character {
    fn new(dice: Dice) -&gt; Self { // true for three dice, false for four
        match dice {
            Dice::Three =&gt; Self {
                strength: three_die_six(),
                dexterity: three_die_six(),
                constitution: three_die_six(),
                intelligence: three_die_six(),
                wisdom: three_die_six(),
                charisma: three_die_six(),
            },
            Dice::Four =&gt; Self {
                strength: four_die_six(),
                dexterity: four_die_six(),
                constitution: four_die_six(),
                intelligence: four_die_six(),
                wisdom: four_die_six(),
                charisma: four_die_six(),
            },
        }
    }
    fn display(&amp;self) { // We can do this because we implemented Display below
        println!("{}", self);
        println!();
    }
}

impl fmt::Display for Character { // Just follow the code for in https://doc.rust-lang.org/std/fmt/trait.Display.html and change it a bit
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "Your character has these stats:
strength: {}
dexterity: {}
constitution: {}
intelligence: {}
wisdom: {}
charisma: {}",
            self.strength,
            self.dexterity,
            self.constitution,
            self.intelligence,
            self.wisdom,
            self.charisma
        )
    }
}



fn main() {
    let weak_billy = Character::new(Dice::Three);
    let strong_billy = Character::new(Dice::Four);
    weak_billy.display();
    strong_billy.display();
}</code></pre></pre>
<p>å®ƒä¼šæ‰“å°å‡ºè¿™æ ·çš„ä¸œè¥¿ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Your character has these stats:
strength: 9
dexterity: 15
constitution: 15
intelligence: 8
wisdom: 11
charisma: 9

Your character has these stats:
strength: 9
dexterity: 13
constitution: 14
intelligence: 16
wisdom: 16
charisma: 10
<span class="boring">}</span></code></pre></pre>
<p>æœ‰å››ä¸ªéª°å­çš„è§’è‰²é€šå¸¸åœ¨å¤§å¤šæ•°äº‹æƒ…ä¸Šéƒ½ä¼šå¥½ä¸€ç‚¹ã€‚</p>
<h3 id="rayon"><a class="header" href="#rayon">rayon</a></h3>
<p><code>rayon</code> æ˜¯ä¸€ä¸ªæµè¡Œçš„crateï¼Œå®ƒå¯ä»¥è®©ä½ åŠ å¿« Rust ä»£ç çš„é€Ÿåº¦ã€‚å®ƒä¹‹æ‰€ä»¥å—æ¬¢è¿ï¼Œæ˜¯å› ä¸ºå®ƒæ— éœ€åƒ <code>thread::spawn</code> è¿™æ ·çš„ä¸œè¥¿å°±èƒ½åˆ›å»ºçº¿ç¨‹ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒä¹‹æ‰€ä»¥å—æ¬¢è¿æ˜¯å› ä¸ºå®ƒæ—¢æœ‰æ•ˆåˆå®¹æ˜“ç¼–å†™ã€‚æ¯”å¦‚è¯´</p>
<ul>
<li><code>.iter()</code>, <code>.iter_mut()</code>, <code>into_iter()</code>åœ¨rayonä¸­æ˜¯è¿™æ ·å†™çš„:</li>
<li><code>.par_iter()</code>, <code>.par_iter_mut()</code>, <code>par_into_iter()</code>. æ‰€ä»¥ä½ åªè¦åŠ ä¸Š<code>par_</code>ï¼Œä½ çš„ä»£ç å°±ä¼šå˜å¾—å¿«å¾ˆå¤šã€‚(parçš„æ„æ€æ˜¯ "å¹¶è¡Œ")</li>
</ul>
<p>å…¶ä»–æ–¹æ³•ä¹Ÿä¸€æ ·:<code>.chars()</code>å°±æ˜¯<code>.par_chars()</code>ï¼Œä»¥æ­¤ç±»æ¨ã€‚</p>
<p>è¿™é‡Œä¸¾ä¸ªä¾‹å­ï¼Œä¸€æ®µç®€å•çš„ä»£ç ï¼Œå´è®©è®¡ç®—æœºåšäº†å¾ˆå¤šå·¥ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![0; 200_000];
    my_vec.iter_mut().enumerate().for_each(|(index, number)| *number+=index+1);
    println!("{:?}", &amp;my_vec[5000..5005]);
}</code></pre></pre>
<p>å®ƒåˆ›å»ºäº†ä¸€ä¸ªæœ‰20ä¸‡é¡¹çš„å‘é‡:æ¯ä¸€é¡¹éƒ½æ˜¯0ï¼Œç„¶åè°ƒç”¨<code>.enumerate()</code>æ¥è·å–æ¯ä¸ªæ•°å­—çš„ç´¢å¼•ï¼Œå¹¶å°†0æ”¹ä¸ºç´¢å¼•å·ã€‚å®ƒçš„æ‰“å°æ—¶é—´å¤ªé•¿ï¼Œæ‰€ä»¥æˆ‘ä»¬åªæ‰“å°5000åˆ°5004é¡¹ã€‚è¿™åœ¨Rustä¸­è¿˜æ˜¯éå¸¸å¿«çš„ï¼Œä½†å¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥ç”¨Rayonè®©å®ƒæ›´å¿«ã€‚ä»£ç å‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use rayon::prelude::*; // Import rayon

fn main() {
    let mut my_vec = vec![0; 200_000];
    my_vec.par_iter_mut().enumerate().for_each(|(index, number)| *number+=index+1); // add par_ to iter_mut
    println!("{:?}", &amp;my_vec[5000..5005]);
}</code></pre></pre>
<p>å°±è¿™æ ·äº†ã€‚<code>rayon</code>è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æ–¹æ³•æ¥å®šåˆ¶ä½ æƒ³åšçš„äº‹æƒ…ï¼Œä½†æœ€ç®€å•çš„å°±æ˜¯ "æ·»åŠ <code>_par</code>ï¼Œè®©ä½ çš„ç¨‹åºæ›´å¿«"ã€‚</p>
<h3 id="serde"><a class="header" href="#serde">serde</a></h3>
<p><code>serde</code>æ˜¯ä¸€ä¸ªæµè¡Œçš„crateï¼Œå®ƒå¯ä»¥åœ¨JSONã€YAMLç­‰æ ¼å¼é—´ç›¸äº’è½¬æ¢ã€‚æœ€å¸¸è§çš„ä½¿ç”¨æ–¹æ³•æ˜¯é€šè¿‡åˆ›å»ºä¸€ä¸ª<code>struct</code>ï¼Œä¸Šé¢æœ‰ä¸¤ä¸ªå±æ€§ã€‚<a href="https://serde.rs/">å®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„</a>ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Serialize</code>å’Œ<code>Deserialize</code>traitæ˜¯ä½¿è½¬æ¢å˜å¾—ç®€å•çš„åŸå› ã€‚(è¿™ä¹Ÿæ˜¯<code>serde</code>è¿™ä¸ªåå­—çš„ç”±æ¥)å¦‚æœä½ çš„ç»“æ„ä½“ä¸Šæœ‰è¿™ä¸¤ä¸ªtraitï¼Œé‚£ä¹ˆä½ åªéœ€è¦è°ƒç”¨ä¸€ä¸ªæ–¹æ³•å°±å¯ä»¥æŠŠå®ƒè½¬åŒ–ä¸ºJSONæˆ–å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚</p>
<h3 id="regex"><a class="header" href="#regex">regex</a></h3>
<p><a href="https://crates.io/crates/regex">regex</a> crate å¯ä»¥è®©ä½ ä½¿ç”¨ <a href="https://en.wikipedia.org/wiki/Regular_expression">æ­£åˆ™è¡¨è¾¾å¼</a> æœç´¢æ–‡æœ¬ã€‚æœ‰äº†å®ƒï¼Œä½ å¯ä»¥é€šè¿‡ä¸€æ¬¡æœç´¢å¾—åˆ°è¯¸å¦‚ <code>colour</code>, <code>color</code>, <code>colours</code> å’Œ <code>colors</code> çš„åŒ¹é…ä¿¡æ¯ã€‚æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦ä¸€é—¨è¯­è¨€ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨å®ƒä»¬ï¼Œä¹Ÿå¿…é¡»å­¦ä¼šã€‚</p>
<h3 id="chrono"><a class="header" href="#chrono">chrono</a></h3>
<p><a href="https://crates.io/crates/chrono">chrono</a>æ˜¯ä¸ºé‚£äº›éœ€è¦æ›´å¤šæ—¶é—´åŠŸèƒ½çš„äººå‡†å¤‡çš„ä¸»è¦crateã€‚æˆ‘ä»¬ç°åœ¨æ¥çœ‹ä¸€ä¸‹æ ‡å‡†åº“ï¼Œå®ƒæœ‰æ—¶é—´çš„åŠŸèƒ½ï¼Œä½†æ˜¯å¦‚æœä½ éœ€è¦æ›´å¤šçš„åŠŸèƒ½ï¼Œé‚£ä¹ˆè¿™ä¸ªcrateæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ ‡å‡†åº“ä¹‹æ—…"><a class="header" href="#æ ‡å‡†åº“ä¹‹æ—…">æ ‡å‡†åº“ä¹‹æ—…</a></h2>
<p>ç°åœ¨ä½ å·²ç»çŸ¥é“äº†å¾ˆå¤šRustçš„çŸ¥è¯†ï¼Œä½ å°†èƒ½å¤Ÿç†è§£æ ‡å‡†åº“é‡Œé¢çš„å¤§éƒ¨åˆ†ä¸œè¥¿ã€‚å®ƒé‡Œé¢çš„ä»£ç å·²ç»ä¸æ˜¯é‚£ä¹ˆå¯æ€•äº†ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹å®ƒé‡Œé¢ä¸€äº›æˆ‘ä»¬è¿˜æ²¡æœ‰å­¦è¿‡çš„éƒ¨åˆ†ã€‚æœ¬ç¯‡æ¸¸è®°å°†ä»‹ç»æ ‡å‡†åº“çš„å¤§éƒ¨åˆ†éƒ¨åˆ†ï¼Œä½ ä¸éœ€è¦å®‰è£…Rustã€‚æˆ‘ä»¬å°†é‡æ¸©å¾ˆå¤šæˆ‘ä»¬å·²ç»çŸ¥é“çš„å†…å®¹ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ›´æ·±å…¥åœ°å­¦ä¹ å®ƒä»¬ã€‚</p>
<h3 id="æ•°ç»„-1"><a class="header" href="#æ•°ç»„-1">æ•°ç»„</a></h3>
<p>å…³äºæ•°ç»„éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œå®ƒä»¬æ²¡æœ‰å®ç°<code>Iterator.</code>ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªæ•°ç»„ï¼Œä½ ä¸èƒ½ä½¿ç”¨<code>for</code>ã€‚ä½†æ˜¯ä½ å¯ä»¥å¯¹å®ƒä»¬ä½¿ç”¨ <code>.iter()</code> è¿™æ ·çš„æ–¹æ³•ã€‚æˆ–è€…ä½ å¯ä»¥ä½¿ç”¨<code>&amp;</code>æ¥å¾—åˆ°ä¸€ä¸ªåˆ‡ç‰‡ã€‚å®é™…ä¸Šï¼Œå¦‚æœä½ å°è¯•ä½¿ç”¨<code>for</code>ï¼Œç¼–è¯‘å™¨ä¼šå‡†ç¡®åœ°å‘Šè¯‰ä½ ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // âš ï¸
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];

    for city in my_cities {
        println!("{}", city);
    }
}</code></pre></pre>
<p>æ¶ˆæ¯æ˜¯:</p>
<pre><code class="language-text">error[E0277]: `[&amp;str; 3]` is not an iterator
 --&gt; src\main.rs:5:17
  |
  |                 ^^^^^^^^^ borrow the array with `&amp;` or call `.iter()` on it to iterate over it
</code></pre>
<p>æ‰€ä»¥è®©æˆ‘ä»¬è¯•è¯•è¿™ä¸¤ç§æ–¹æ³•ã€‚å®ƒä»¬çš„ç»“æœæ˜¯ä¸€æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];

    for city in &amp;my_cities {
        println!("{}", city);
    }
    for city in my_cities.iter() {
        println!("{}", city);
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
</code></pre>
<p>å¦‚æœä½ æƒ³ä»ä¸€ä¸ªæ•°ç»„ä¸­è·å–å˜é‡ï¼Œä½ å¯ä»¥æŠŠå®ƒä»¬çš„åå­—æ”¾åœ¨ <code>[]</code> ä¸­æ¥è§£æ„å®ƒã€‚è¿™ä¸åœ¨ <code>match</code> è¯­å¥ä¸­ä½¿ç”¨å…ƒç»„æˆ–ä»ç»“æ„ä½“ä¸­è·å–å˜é‡æ˜¯ä¸€æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];
    let [city1, city2, city3] = my_cities;
    println!("{}", city1);
}</code></pre></pre>
<p>æ‰“å°å‡º<code>Beirut</code>.</p>
<h3 id="char"><a class="header" href="#char">char</a></h3>
<p>æ‚¨å¯ä»¥ä½¿ç”¨<code>.escape_unicode()</code>çš„æ–¹æ³•æ¥è·å–<code>char</code>çš„Unicodeå·ç ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let korean_word = "ì²­ì¶˜ì˜ˆì°¬";
    for character in korean_word.chars() {
        print!("{} ", character.escape_unicode());
    }
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>u{ccad} u{cd98} u{c608} u{cc2c}</code>ã€‚</p>
<p>ä½ å¯ä»¥ä½¿ç”¨ <code>From</code> traitä» <code>u8</code> ä¸­å¾—åˆ°ä¸€ä¸ªå­—ç¬¦ï¼Œä½†å¯¹äº <code>u32</code>ï¼Œä½ ä½¿ç”¨ <code>TryFrom</code>ï¼Œå› ä¸ºå®ƒå¯èƒ½æ— æ³•å·¥ä½œã€‚<code>u32</code>ä¸­çš„æ•°å­—æ¯”Unicodeä¸­çš„å­—ç¬¦å¤šå¾ˆå¤šã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªç®€å•çš„æ¼”ç¤ºæ¥äº†è§£ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom; // You need to bring TryFrom in to use it
use rand::prelude::*;      // We will use random numbers too

fn main() {
    let some_character = char::from(99); // This one is easy - no need for TryFrom
    println!("{}", some_character);

    let mut random_generator = rand::thread_rng();
    // This will try 40,000 times to make a char from a u32.
    // The range is 0 (std::u32::MIN) to u32's highest number (std::u32::MAX). If it doesn't work, we will give it '-'.
    for _ in 0..40_000 {
        let bigger_character = char::try_from(random_generator.gen_range(std::u32::MIN..std::u32::MAX)).unwrap_or('-');
        print!("{}", bigger_character)
    }
}</code></pre></pre>
<p>å‡ ä¹æ¯æ¬¡éƒ½ä¼šç”Ÿæˆä¸€ä¸ª<code>-</code>ã€‚è¿™æ˜¯ä½ ä¼šçœ‹åˆ°çš„é‚£ç§è¾“å‡ºçš„ä¸€éƒ¨åˆ†ã€‚</p>
<pre><code class="language-text">------------------------------------------------------------------------ğ¤’°---------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------ì¶—--------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
------------ò‡œ----------------------------------------------------
</code></pre>
<p>æ‰€ä»¥ï¼Œä½ è¦ç”¨<code>TryFrom</code>æ˜¯ä»¶å¥½äº‹ã€‚</p>
<p>å¦å¤–ï¼Œä»2020å¹´8æœˆåº•å¼€å§‹ï¼Œä½ ç°åœ¨å¯ä»¥ä»<code>char</code>ä¸­å¾—åˆ°ä¸€ä¸ª<code>String</code>ã€‚(<code>String</code>å®ç°äº†<code>From&lt;char&gt;</code>)åªè¦å†™<code>String::from()</code>ï¼Œç„¶ååœ¨é‡Œé¢æ”¾ä¸€ä¸ª<code>char</code>ã€‚</p>
<h3 id="æ•´æ•°"><a class="header" href="#æ•´æ•°">æ•´æ•°</a></h3>
<p>è¿™äº›ç±»å‹çš„æ•°å­¦æ–¹æ³•æœ‰å¾ˆå¤šï¼Œå¦å¤–è¿˜æœ‰ä¸€äº›å…¶ä»–çš„æ–¹æ³•ã€‚ä¸‹é¢æ˜¯ä¸€äº›æœ€æœ‰ç”¨çš„ã€‚</p>
<p><code>.checked_add()</code>, <code>.checked_sub()</code>, <code>.checked_mul()</code>, <code>.checked_div()</code>. å¦‚æœä½ è®¤ä¸ºä½ å¯èƒ½ä¼šå¾—åˆ°ä¸€ä¸ªä¸é€‚åˆç±»å‹çš„æ•°å­—ï¼Œè¿™äº›éƒ½æ˜¯ä¸é”™çš„æ–¹æ³•ã€‚å®ƒä»¬ä¼šè¿”å›ä¸€ä¸ª <code>Option</code>ï¼Œè¿™æ ·ä½ å°±å¯ä»¥å®‰å…¨åœ°æ£€æŸ¥ä½ çš„æ•°å­¦è®¡ç®—æ˜¯å¦æ­£å¸¸ï¼Œè€Œä¸ä¼šè®©ç¨‹åºå´©æºƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 200_u8;
    let other_number = 200_u8;

    println!("{:?}", some_number.checked_add(other_number));
    println!("{:?}", some_number.checked_add(1));
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">None
Some(201)
</code></pre>
<p>ä½ ä¼šæ³¨æ„åˆ°ï¼Œåœ¨æ•´æ•°çš„é¡µé¢ä¸Šï¼Œç»å¸¸è¯´<code>rhs</code>ã€‚è¿™æ„å‘³ç€ "å³è¾¹"ï¼Œä¹Ÿå°±æ˜¯ä½ åšä¸€äº›æ•°å­¦è¿ç®—æ—¶çš„å³æ“ä½œæ•°ã€‚æ¯”å¦‚åœ¨<code>5 + 6</code>ä¸­ï¼Œ<code>5</code>åœ¨å·¦è¾¹ï¼Œ<code>6</code>åœ¨å³è¾¹ï¼Œæ‰€ä»¥<code>6</code>å°±æ˜¯<code>rhs</code>ã€‚è¿™ä¸ªä¸æ˜¯å…³é”®è¯ï¼Œä½†æ˜¯ä½ ä¼šç»å¸¸çœ‹åˆ°ï¼Œæ‰€ä»¥çŸ¥é“å°±å¥½ã€‚</p>
<p>è¯´åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬æ¥å­¦ä¹ ä¸€ä¸‹å¦‚ä½•å®ç°<code>Add</code>ã€‚åœ¨ä½ å®ç°äº†<code>Add</code>ä¹‹åï¼Œä½ å¯ä»¥åœ¨ä½ åˆ›å»ºçš„ç±»å‹ä¸Šä½¿ç”¨<code>+</code>ã€‚ä½ éœ€è¦è‡ªå·±å®ç°<code>Add</code>ï¼Œå› ä¸ºaddå¯ä»¥è¡¨è¾¾å¾ˆå¤šæ„æ€ã€‚è¿™æ˜¯æ ‡å‡†åº“é¡µé¢ä¸­çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add; // first bring in Add

#[derive(Debug, Copy, Clone, PartialEq)] // PartialEq is probably the most important part here. You want to be able to compare numbers
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self; // Remember, this is called an "associated type": a "type that goes together".
                        // In this case it's just another Point

    fn add(self, other: Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>ç°åœ¨è®©æˆ‘ä»¬ä¸ºè‡ªå·±çš„ç±»å‹å®ç°<code>Add</code>ã€‚è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æƒ³æŠŠä¸¤ä¸ªå›½å®¶åŠ åœ¨ä¸€èµ·ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ¯”è¾ƒå®ƒä»¬çš„ç»æµã€‚å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
use std::ops::Add;

#[derive(Clone)]
struct Country {
    name: String,
    population: u32,
    gdp: u32, // This is the size of the economy
}

impl Country {
    fn new(name: &amp;str, population: u32, gdp: u32) -&gt; Self {
        Self {
            name: name.to_string(),
            population,
            gdp,
        }
    }
}

impl Add for Country {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            name: format!("{} and {}", self.name, other.name), // We will add the names together,
            population: self.population + other.population, // and the population,
            gdp: self.gdp + other.gdp,   // and the GDP
        }
    }
}

impl fmt::Display for Country {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "In {} are {} people and a GDP of ${}", // Then we can print them all with just {}
            self.name, self.population, self.gdp
        )
    }
}

fn main() {
    let nauru = Country::new("Nauru", 10_670, 160_000_000);
    let vanuatu = Country::new("Vanuatu", 307_815, 820_000_000);
    let micronesia = Country::new("Micronesia", 104_468, 367_000_000);

    // We could have given Country a &amp;str instead of a String for the name. But we would have to write lifetimes everywhere
    // and that would be too much for a small example. Better to just clone them when we call println!.
    println!("{}", nauru.clone());
    println!("{}", nauru.clone() + vanuatu.clone());
    println!("{}", nauru + vanuatu + micronesia);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">In Nauru are 10670 people and a GDP of $160000000
In Nauru and Vanuatu are 318485 people and a GDP of $980000000
In Nauru and Vanuatu and Micronesia are 422953 people and a GDP of $1347000000
</code></pre>
<p>ä»¥ååœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ<code>.fmt()</code>æ”¹æˆæ›´å®¹æ˜“é˜…è¯»çš„æ•°å­—æ˜¾ç¤ºã€‚</p>
<p>å¦å¤–ä¸‰ä¸ªå«<code>Sub</code>ã€<code>Mul</code>å’Œ<code>Div</code>ï¼Œå®ç°èµ·æ¥åŸºæœ¬ä¸€æ ·ã€‚<code>+=</code>ã€<code>-=</code>ã€<code>*=</code>å’Œ<code>/=</code>ï¼Œåªè¦åŠ ä¸Š<code>Assign</code>:<code>AddAssign</code>ã€<code>SubAssign</code>ã€<code>MulAssign</code>å’Œ<code>DivAssign</code>å³å¯ã€‚ä½ å¯ä»¥çœ‹åˆ°å®Œæ•´çš„åˆ—è¡¨<a href="https://doc.rust-lang.org/std/ops/index.html#structs">è¿™é‡Œ</a>ï¼Œå› ä¸ºè¿˜æœ‰å¾ˆå¤šã€‚ä¾‹å¦‚ <code>%</code> è¢«ç§°ä¸º <code>Rem</code>, <code>-</code> è¢«ç§°ä¸º <code>Neg</code>, ç­‰ç­‰ã€‚</p>
<h3 id="æµ®ç‚¹æ•°-1"><a class="header" href="#æµ®ç‚¹æ•°-1">æµ®ç‚¹æ•°</a></h3>
<p><code>f32</code>å’Œ<code>f64</code>æœ‰éå¸¸å¤šçš„æ–¹æ³•ï¼Œä½ åœ¨åšæ•°å­¦è®¡ç®—çš„æ—¶å€™ä¼šç”¨åˆ°ã€‚æˆ‘ä»¬ä¸çœ‹è¿™äº›ï¼Œä½†è¿™é‡Œæœ‰ä¸€äº›ä½ å¯èƒ½ä¼šç”¨åˆ°çš„æ–¹æ³•ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯ <code>.floor()</code>, <code>.ceil()</code>, <code>.round()</code>, å’Œ <code>.trunc()</code>. æ‰€æœ‰è¿™äº›æ–¹æ³•éƒ½è¿”å›ä¸€ä¸ª <code>f32</code> æˆ– <code>f64</code>ï¼Œå®ƒåƒä¸€ä¸ªæ•´æ•°ï¼Œå°æ•°ç‚¹åé¢æ˜¯ <code>0</code>ã€‚å®ƒä»¬æ˜¯è¿™æ ·åšçš„ã€‚</p>
<ul>
<li><code>.floor()</code>: ç»™ä½ ä¸‹ä¸€ä¸ªæœ€ä½çš„æ•´æ•°.</li>
<li><code>.ceil()</code>: ç»™ä½ ä¸‹ä¸€ä¸ªæœ€é«˜çš„æ•´æ•°ã€‚</li>
<li><code>.round()</code>: å¦‚æœå°æ•°éƒ¨åˆ†å¤§äºç­‰äº0.5ï¼Œè¿”å›æ•°å€¼åŠ 1;å¦‚æœå°æ•°éƒ¨åˆ†å°äº0.5ï¼Œè¿”å›ç›¸åŒæ•°å€¼ã€‚è¿™å°±æ˜¯æ‰€è°“çš„å››èˆäº”å…¥ï¼Œå› ä¸ºå®ƒç»™ä½ ä¸€ä¸ª "èˆå…¥"çš„æ•°å­—(ä¸€ä¸ªæ•°å­—çš„ç®€çŸ­å½¢å¼)ã€‚</li>
<li><code>.trunc()</code>:åªæ˜¯æŠŠå°æ•°ç‚¹å·åçš„éƒ¨åˆ†æˆªæ‰ã€‚Truncateæ˜¯ "æˆªæ–­"çš„æ„æ€ã€‚</li>
</ul>
<p>è¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„å‡½æ•°æ¥æ‰“å°å®ƒä»¬ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn four_operations(input: f64) {
    println!(
"For the number {}:
floor: {}
ceiling: {}
rounded: {}
truncated: {}\n",
        input,
        input.floor(),
        input.ceil(),
        input.round(),
        input.trunc()
    );
}

fn main() {
    four_operations(9.1);
    four_operations(100.7);
    four_operations(-1.1);
    four_operations(-19.9);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">For the number 9.1:
floor: 9
ceiling: 10
rounded: 9 // because less than 9.5
truncated: 9

For the number 100.7:
floor: 100
ceiling: 101
rounded: 101 // because more than 100.5
truncated: 100

For the number -1.1:
floor: -2
ceiling: -1
rounded: -1
truncated: -1

For the number -19.9:
floor: -20
ceiling: -19
rounded: -20
truncated: -19
</code></pre>
<p><code>f32</code> å’Œ <code>f64</code> æœ‰ä¸€ä¸ªå«åš <code>.max()</code> å’Œ <code>.min()</code> çš„æ–¹æ³•ï¼Œå¯ä»¥å¾—åˆ°ä¸¤ä¸ªæ•°å­—ä¸­è¾ƒå¤§æˆ–è¾ƒå°çš„æ•°å­—ã€‚(å¯¹äºå…¶ä»–ç±»å‹ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨<code>std::cmp::max</code>å’Œ<code>std::cmp::min</code>ã€‚)ä¸‹é¢æ˜¯ç”¨<code>.fold()</code>æ¥å¾—åˆ°æœ€é«˜æˆ–æœ€ä½æ•°çš„æ–¹æ³•ã€‚ä½ åˆå¯ä»¥çœ‹åˆ°ï¼Œ<code>.fold()</code>ä¸ä»…ä»…æ˜¯ç”¨æ¥åŠ æ•°å­—çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8.0_f64, 7.6, 9.4, 10.0, 22.0, 77.345, 10.22, 3.2, -7.77, -10.0];
    let maximum = my_vec.iter().fold(f64::MIN, |current_number, next_number| current_number.max(*next_number)); // Note: start with the lowest possible number for an f64.
    let minimum = my_vec.iter().fold(f64::MAX, |current_number, next_number| current_number.min(*next_number)); // And here start with the highest possible number
    println!("{}, {}", maximum, minimum);
}</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">bool</a></h3>
<p>åœ¨ Rust ä¸­ï¼Œå¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥æŠŠ <code>bool</code> å˜æˆä¸€ä¸ªæ•´æ•°ï¼Œå› ä¸ºè¿™æ ·åšæ˜¯å®‰å…¨çš„ã€‚ä½†ä½ ä¸èƒ½åè¿‡æ¥åšã€‚å¦‚ä½ æ‰€è§ï¼Œ<code>true</code>å˜æˆäº†1ï¼Œ<code>false</code>å˜æˆäº†0ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false = (true, false);
    println!("{} {}", true_false.0 as u8, true_false.1 as i32);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º<code>1 0</code>ã€‚å¦‚æœä½ å‘Šè¯‰ç¼–è¯‘å™¨ç±»å‹ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ <code>.into()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false: (i128, u16) = (true.into(), false.into());
    println!("{} {}", true_false.0, true_false.1);
}</code></pre></pre>
<p>è¿™æ‰“å°çš„æ˜¯ä¸€æ ·çš„ä¸œè¥¿ã€‚</p>
<p>ä»Rust 1.50(2021å¹´2æœˆå‘å¸ƒ)å¼€å§‹ï¼Œæœ‰ä¸€ä¸ªå«åš <code>then()</code>çš„æ–¹æ³•ï¼Œå®ƒå°†ä¸€ä¸ª <code>bool</code>å˜æˆä¸€ä¸ª <code>Option</code>ã€‚ä½¿ç”¨<code>then()</code>æ—¶éœ€è¦ä¸€ä¸ªé—­åŒ…ï¼Œå¦‚æœitemæ˜¯<code>true</code>ï¼Œé—­åŒ…å°±ä¼šè¢«è°ƒç”¨ã€‚åŒæ—¶ï¼Œæ— è®ºä»é—­åŒ…ä¸­è¿”å›ä»€ä¹ˆï¼Œéƒ½ä¼šè¿›å…¥<code>Option</code>ä¸­ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå°ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let (tru, fals) = (true.then(|| 8), false.then(|| 8));
    println!("{:?}, {:?}", tru, fals);
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å° <code>Some(8), None</code>ã€‚</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªè¾ƒé•¿çš„ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let bool_vec = vec![true, false, true, false, false];

    let option_vec = bool_vec
        .iter()
        .map(|item| {
            item.then(|| { // Put this inside of map so we can pass it on
                println!("Got a {}!", item);
                "It's true, you know" // This goes inside Some if it's true
                                      // Otherwise it just passes on None
            })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Now we have: {:?}", option_vec);

    // That printed out the Nones too. Let's filter map them out in a new Vec.
    let filtered_vec = option_vec.into_iter().filter_map(|c| c).collect::&lt;Vec&lt;_&gt;&gt;();

    println!("And without the Nones: {:?}", filtered_vec);
}</code></pre></pre>
<p>å°†æ‰“å°:</p>
<pre><code class="language-text">Got a true!
Got a true!
Now we have: [Some("It\'s true, you know"), None, Some("It\'s true, you know"), None, None]
And without the Nones: ["It\'s true, you know", "It\'s true, you know"]
</code></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<p>Vecæœ‰å¾ˆå¤šæ–¹æ³•æˆ‘ä»¬è¿˜æ²¡æœ‰çœ‹ã€‚å…ˆè¯´è¯´<code>.sort()</code>ã€‚<code>.sort()</code>ä¸€ç‚¹éƒ½ä¸å¥‡æ€ªã€‚å®ƒä½¿ç”¨<code>&amp;mut self</code>æ¥å¯¹ä¸€ä¸ªå‘é‡è¿›è¡Œæ’åºã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![100, 90, 80, 0, 0, 0, 0, 0];
    my_vec.sort();
    println!("{:?}", my_vec);
}</code></pre></pre>
<p>è¿™æ ·æ‰“å°å‡ºæ¥çš„æ˜¯<code>[0, 0, 0, 0, 0, 80, 90, 100]</code>ã€‚ä½†è¿˜æœ‰ä¸€ç§æ›´æœ‰è¶£çš„æ’åºæ–¹å¼å«<code>.sort_unstable()</code>ï¼Œå®ƒé€šå¸¸æ›´å¿«ã€‚å®ƒä¹‹æ‰€ä»¥æ›´å¿«ï¼Œæ˜¯å› ä¸ºå®ƒä¸åœ¨ä¹æ’åºå‰åç›¸åŒæ•°å­—çš„å…ˆåé¡ºåºã€‚åœ¨å¸¸è§„çš„<code>.sort()</code>ä¸­ï¼Œä½ çŸ¥é“æœ€åçš„<code>0, 0, 0, 0, 0</code>ä¼šåœ¨<code>.sort()</code>ä¹‹åçš„é¡ºåºç›¸åŒã€‚ä½†æ˜¯<code>.sort_unstable()</code>å¯èƒ½ä¼šæŠŠæœ€åä¸€ä¸ª0ç§»åˆ°ç´¢å¼•0ï¼Œç„¶åæŠŠç¬¬ä¸‰ä¸ªæœ€åçš„0ç§»åˆ°ç´¢å¼•2ï¼Œç­‰ç­‰ã€‚</p>
<p><code>.dedup()</code>çš„æ„æ€æ˜¯ "å»é‡å¤"ã€‚å®ƒå°†åˆ é™¤ä¸€ä¸ªå‘é‡ä¸­ç›¸åŒçš„å…ƒç´ ï¼Œä½†åªæœ‰å½“å®ƒä»¬å½¼æ­¤ç›¸é‚»æ—¶æ‰ä¼šåˆ é™¤ã€‚æ¥ä¸‹æ¥è¿™æ®µä»£ç ä¸ä¼šåªæ‰“å°<code>"sun", "moon"</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec!["sun", "sun", "moon", "moon", "sun", "moon", "moon"];
    my_vec.dedup();
    println!("{:?}", my_vec);
}</code></pre></pre>
<p>å®ƒåªæ˜¯æŠŠå¦ä¸€ä¸ª "sun"æ—è¾¹çš„ "sun"å»æ‰ï¼Œç„¶åæŠŠä¸€ä¸ª "moon"æ—è¾¹çš„ "moon"å»æ‰ï¼Œå†æŠŠå¦ä¸€ä¸ª "moon"æ—è¾¹çš„ "moon"å»æ‰ã€‚ç»“æœæ˜¯ <code>["sun", "moon", "sun", "moon"]</code>.</p>
<p>å¦‚æœä½ æƒ³æŠŠæ¯ä¸ªé‡å¤çš„ä¸œè¥¿éƒ½å»æ‰ï¼Œå°±å…ˆ<code>.sort()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec!["sun", "sun", "moon", "moon", "sun", "moon", "moon"];
    my_vec.sort();
    my_vec.dedup();
    println!("{:?}", my_vec);
}</code></pre></pre>
<p>ç»“æœ:<code>["moon", "sun"]</code>.</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>ä½ ä¼šè®°å¾—ï¼Œ<code>String</code>æœ‰ç‚¹åƒ<code>Vec</code>ã€‚å®ƒå¾ˆåƒ<code>Vec</code>ï¼Œä½ å¯ä»¥è°ƒç”¨å¾ˆå¤šç›¸åŒçš„æ–¹æ³•ã€‚æ¯”å¦‚è¯´ï¼Œä½ å¯ä»¥ç”¨<code>String::with_capacity()</code>åˆ›å»ºä¸€ä¸ªï¼Œå¦‚æœä½ éœ€è¦å¤šæ¬¡ç”¨<code>.push()</code>æ¨ä¸€ä¸ª<code>char</code>ï¼Œæˆ–è€…ç”¨<code>.push_str()</code>æ¨ä¸€ä¸ª<code>&amp;str</code>ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæœ‰å¤šæ¬¡å†…å­˜åˆ†é…çš„<code>String</code>çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::new();
    let mut capacity_counter = 0; // capacity starts at 0
    for _ in 0..100_000 { // Do this 100,000 times
        if push_string.capacity() != capacity_counter { // First check if capacity is different now
            println!("{}", push_string.capacity()); // If it is, print it
            capacity_counter = push_string.capacity(); // then update the counter
        }
        push_string.push_str("I'm getting pushed into the string!"); // and push this in every time
    }
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">35
70
140
280
560
1120
2240
4480
8960
17920
35840
71680
143360
286720
573440
1146880
2293760
4587520
</code></pre>
<p>æˆ‘ä»¬ä¸å¾—ä¸é‡æ–°åˆ†é…(æŠŠæ‰€æœ‰ä¸œè¥¿å¤åˆ¶è¿‡æ¥)18æ¬¡ã€‚ä½†æ—¢ç„¶æˆ‘ä»¬çŸ¥é“äº†æœ€ç»ˆçš„å®¹é‡ï¼Œæˆ‘ä»¬å¯ä»¥é©¬ä¸Šè®¾ç½®å®¹é‡ï¼Œä¸éœ€è¦é‡æ–°åˆ†é…:åªè®¾ç½®ä¸€æ¬¡<code>String</code>å®¹é‡å°±å¤Ÿäº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520); // We know the exact number. Some different big number could work too
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!("{}", push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str("I'm getting pushed into the string!");
    }
}</code></pre></pre>
<p>è€Œè¿™ä¸ªæ‰“å°<code>4587520</code>ã€‚å®Œç¾çš„! æˆ‘ä»¬å†ä¹Ÿä¸ç”¨åˆ†é…äº†ã€‚</p>
<p>å½“ç„¶ï¼Œå®é™…é•¿åº¦è‚¯å®šæ¯”è¿™ä¸ªå°ã€‚å¦‚æœä½ è¯•äº†100001æ¬¡ï¼Œ101000æ¬¡ç­‰ç­‰ï¼Œè¿˜æ˜¯ä¼šè¯´<code>4587520</code>ã€‚è¿™æ˜¯å› ä¸ºæ¯æ¬¡çš„å®¹é‡éƒ½æ˜¯ä¹‹å‰çš„2å€ã€‚ä¸è¿‡æˆ‘ä»¬å¯ä»¥ç”¨<code>.shrink_to_fit()</code>æ¥ç¼©å°å®ƒ(å’Œ<code>Vec</code>ä¸€æ ·)ã€‚æˆ‘ä»¬çš„<code>String</code>å·²ç»éå¸¸å¤§äº†ï¼Œæˆ‘ä»¬ä¸æƒ³å†ç»™å®ƒå¢åŠ ä»»ä½•ä¸œè¥¿ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠå®ƒç¼©å°ä¸€ç‚¹ã€‚ä½†æ˜¯åªæœ‰åœ¨ä½ æœ‰æŠŠæ¡çš„æƒ…å†µä¸‹æ‰å¯ä»¥è¿™æ ·åš:ä¸‹é¢æ˜¯åŸå› ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520);
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!("{}", push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str("I'm getting pushed into the string!");
    }
    push_string.shrink_to_fit();
    println!("{}", push_string.capacity());
    push_string.push('a');
    println!("{}", push_string.capacity());
    push_string.shrink_to_fit();
    println!("{}", push_string.capacity());
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">4587520
3500000
7000000
3500001
</code></pre>
<p>æ‰€ä»¥é¦–å…ˆæˆ‘ä»¬çš„å¤§å°æ˜¯<code>4587520</code>ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰å…¨éƒ¨ä½¿ç”¨ã€‚æˆ‘ä»¬ç”¨äº†<code>.shrink_to_fit()</code>ï¼Œç„¶åæŠŠå¤§å°é™åˆ°äº†<code>3500000</code>ã€‚ä½†æ˜¯æˆ‘ä»¬å¿˜è®°äº†æˆ‘ä»¬éœ€è¦æ¨ä¸Šä¸€ä¸ª <code>a</code>ã€‚å½“æˆ‘ä»¬è¿™æ ·åšçš„æ—¶å€™ï¼ŒRust çœ‹åˆ°æˆ‘ä»¬éœ€è¦æ›´å¤šçš„ç©ºé—´ï¼Œç»™äº†æˆ‘ä»¬åŒå€çš„ç©ºé—´:ç°åœ¨æ˜¯ <code>7000000</code>ã€‚Whoops! æ‰€ä»¥æˆ‘ä»¬åˆè°ƒç”¨äº†<code>.shrink_to_fit()</code>ï¼Œç°åœ¨åˆå›åˆ°äº†<code>3500001</code>ã€‚</p>
<p><code>.pop()</code>å¯¹<code>String</code>æœ‰ç”¨ï¼Œå°±åƒå¯¹<code>Vec</code>ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(".daer ot drah tib elttil a si gnirts sihT");
    loop {
        let pop_result = my_string.pop();
        match pop_result {
            Some(character) =&gt; print!("{}", character),
            None =&gt; break,
        }
    }
}</code></pre></pre>
<p>è¿™æ‰“å°çš„æ˜¯<code>This string is a little bit hard to read.</code>ï¼Œå› ä¸ºå®ƒæ˜¯ä»æœ€åä¸€ä¸ªå­—ç¬¦å¼€å§‹çš„ã€‚</p>
<p><code>.retain()</code>æ˜¯ä¸€ä¸ªä½¿ç”¨é—­åŒ…çš„æ–¹æ³•ï¼Œè¿™å¯¹<code>String</code>æ¥è¯´æ˜¯ç½•è§çš„ã€‚å°±åƒåœ¨è¿­ä»£å™¨ä¸Šçš„<code>.filter()</code>ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("Age: 20 Height: 194 Weight: 80");
    my_string.retain(|character| character.is_alphabetic() || character == ' '); // Keep if a letter or a space
    dbg!(my_string); // Let's use dbg!() for fun this time instead of println!
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">[src\main.rs:4] my_string = "Age  Height  Weight "
</code></pre>
<h3 id="osstringå’Œcstring"><a class="header" href="#osstringå’Œcstring">OsStringå’ŒCString</a></h3>
<p><code>std::ffi</code>æ˜¯<code>std</code>çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒå¸®åŠ©ä½ å°†Rustä¸å…¶ä»–è¯­è¨€æˆ–æ“ä½œç³»ç»Ÿä¸€èµ·ä½¿ç”¨ã€‚å®ƒæœ‰<code>OsString</code>å’Œ<code>CString</code>è¿™æ ·çš„ç±»å‹ï¼Œå®ƒä»¬å°±åƒæ“ä½œç³»ç»Ÿçš„<code>String</code>æˆ–è¯­è¨€Cçš„<code>String</code>ä¸€æ ·ï¼Œå®ƒä»¬å„è‡ªä¹Ÿæœ‰è‡ªå·±çš„<code>&amp;str</code>ç±»å‹:<code>OsStr</code>å’Œ<code>CStr</code>ã€‚<code>ffi</code>çš„æ„æ€æ˜¯ "foreign function interface"(å¤–éƒ¨å‡½æ•°æ¥å£)ã€‚</p>
<p>å½“ä½ å¿…é¡»ä¸ä¸€ä¸ªæ²¡æœ‰Unicodeçš„æ“ä½œç³»ç»Ÿä¸€èµ·å·¥ä½œæ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>OsString</code>ã€‚æ‰€æœ‰çš„Rustå­—ç¬¦ä¸²éƒ½æ˜¯unicodeï¼Œä½†ä¸æ˜¯æ¯ä¸ªæ“ä½œç³»ç»Ÿæ”¯æŒã€‚ä¸‹é¢æ˜¯æ ‡å‡†åº“ä¸­å…³äºä¸ºä»€ä¹ˆæˆ‘ä»¬æœ‰<code>OsString</code>çš„ç®€å•è‹±æ–‡è§£é‡Šã€‚</p>
<ul>
<li>Unixç³»ç»Ÿ(Linuxç­‰)ä¸Šçš„å­—ç¬¦ä¸²å¯èƒ½æ˜¯å¾ˆå¤šæ²¡æœ‰0çš„å­—èŠ‚ç»„åˆåœ¨ä¸€èµ·ã€‚è€Œä¸”æœ‰æ—¶ä½ ä¼šæŠŠå®ƒä»¬è¯»æˆUnicode UTF-8ã€‚</li>
<li>Windowsä¸Šçš„å­—ç¬¦ä¸²å¯èƒ½æ˜¯ç”±éšæœºçš„16ä½å€¼ç»„æˆçš„ï¼Œæ²¡æœ‰0ã€‚æœ‰æ—¶ä½ ä¼šæŠŠå®ƒä»¬è¯»æˆUnicode UTF-16ã€‚</li>
<li>åœ¨Rustä¸­ï¼Œå­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„UTF-8ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«0ã€‚</li>
</ul>
<p>æ‰€ä»¥ï¼Œ<code>OsString</code>è¢«è®¾è®¡ä¸ºæ”¯æŒå®ƒä»¬è¯»å–ã€‚</p>
<p>ä½ å¯ä»¥ç”¨ä¸€ä¸ª<code>OsString</code>åšæ‰€æœ‰å¸¸è§„çš„äº‹æƒ…ï¼Œæ¯”å¦‚<code>OsString::from("Write something here")</code>ã€‚å®ƒè¿˜æœ‰ä¸€ä¸ªæœ‰è¶£çš„æ–¹æ³•ï¼Œå«åš <code>.into_string()</code>ï¼Œè¯•å›¾æŠŠè‡ªå·±å˜æˆä¸€ä¸ªå¸¸è§„çš„ <code>String</code>ã€‚å®ƒè¿”å›ä¸€ä¸ª <code>Result</code>ï¼Œä½† <code>Err</code> éƒ¨åˆ†åªæ˜¯åŸæ¥çš„ <code>OsString</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
pub fn into_string(self) -&gt; Result&lt;String, OsString&gt;
<span class="boring">}</span></code></pre></pre>
<p>æ‰€ä»¥å¦‚æœä¸è¡Œçš„è¯ï¼Œé‚£ä½ å°±æŠŠå®ƒæ‰¾å›æ¥ã€‚ä½ ä¸èƒ½è°ƒç”¨<code>.unwrap()</code>ï¼Œå› ä¸ºå®ƒä¼šå´©æºƒï¼Œä½†æ˜¯ä½ å¯ä»¥ä½¿ç”¨<code>match</code>æ¥æ‰¾å›<code>OsString</code>ã€‚æˆ‘ä»¬é€šè¿‡è°ƒç”¨ä¸å­˜åœ¨çš„æ–¹æ³•æ¥æµ‹è¯•ä¸€ä¸‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::OsString;

fn main() {
    // âš ï¸
    let os_string = OsString::from("This string works for your OS too.");
    match os_string.into_string() {
        Ok(valid) =&gt; valid.thth(),           // Compiler: "What's .thth()??"
        Err(not_valid) =&gt; not_valid.occg(),  // Compiler: "What's .occg()??"
    }
}</code></pre></pre>
<p>ç„¶åç¼–è¯‘å™¨å‡†ç¡®åœ°å‘Šè¯‰æˆ‘ä»¬æˆ‘ä»¬æƒ³çŸ¥é“çš„ä¸œè¥¿ã€‚</p>
<pre><code class="language-text">error[E0599]: no method named `thth` found for struct `std::string::String` in the current scope
 --&gt; src/main.rs:6:28
  |
6 |         Ok(valid) =&gt; valid.thth(),
  |                            ^^^^ method not found in `std::string::String`

error[E0599]: no method named `occg` found for struct `std::ffi::OsString` in the current scope
 --&gt; src/main.rs:7:37
  |
7 |         Err(not_valid) =&gt; not_valid.occg(),
  |                                     ^^^^ method not found in `std::ffi::OsString`
</code></pre>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œ<code>valid</code>çš„ç±»å‹æ˜¯<code>String</code>ï¼Œ<code>not_valid</code>çš„ç±»å‹æ˜¯<code>OsString</code>ã€‚</p>
<h3 id="mem"><a class="header" href="#mem">Mem</a></h3>
<p><code>std::mem</code>æœ‰ä¸€äº›éå¸¸æœ‰è¶£çš„æ–¹æ³•ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†ä¸€äº›ï¼Œæ¯”å¦‚<code>.size_of()</code>ã€<code>.size_of_val()</code>å’Œ<code>.drop()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    println!("{}", mem::size_of::&lt;i32&gt;());
    let my_array = [8; 50];
    println!("{}", mem::size_of_val(&amp;my_array));
    let mut some_string = String::from("You can drop a String because it's on the heap");
    mem::drop(some_string);
    // some_string.clear();   If we did this it would panic
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">4
200
</code></pre>
<p>ä¸‹é¢æ˜¯<code>mem</code>ä¸­çš„ä¸€äº›å…¶ä»–æ–¹æ³•ã€‚</p>
<p><code>swap()</code>: ç”¨è¿™ä¸ªæ–¹æ³•ä½ å¯ä»¥äº¤æ¢ä¸¤ä¸ªå˜é‡ä¹‹é—´çš„å€¼ã€‚ä½ å¯ä»¥é€šè¿‡ä¸ºæ¯ä¸ªå˜é‡åˆ›å»ºä¸€ä¸ªå¯å˜å¼•ç”¨æ¥åšã€‚å½“ä½ æœ‰ä¸¤ä¸ªä¸œè¥¿æƒ³äº¤æ¢ï¼Œè€ŒRustå› ä¸ºå€Ÿç”¨è§„åˆ™ä¸è®©ä½ äº¤æ¢æ—¶ï¼Œè¿™å¾ˆæœ‰å¸®åŠ©ã€‚æˆ–è€…åªæ˜¯å½“ä½ æƒ³å¿«é€Ÿåˆ‡æ¢ä¸¤ä¸ªä¸œè¥¿çš„æ—¶å€™ã€‚</p>
<p>è¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::{mem, fmt};

struct Ring { // Create a ring from Lord of the Rings
    owner: String,
    former_owner: String,
    seeker: String, // seeker means "person looking for it"
}

impl Ring {
    fn new(owner: &amp;str, former_owner: &amp;str, seeker: &amp;str) -&gt; Self {
        Self {
            owner: owner.to_string(),
            former_owner: former_owner.to_string(),
            seeker: seeker.to_string(),
        }
    }
}

impl fmt::Display for Ring { // Display to show who has it and who wants it
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "{} has the ring, {} used to have it, and {} wants it", self.owner, self.former_owner, self.seeker)
        }
}

fn main() {
    let mut one_ring = Ring::new("Frodo", "Gollum", "Sauron");
    println!("{}", one_ring);
    mem::swap(&amp;mut one_ring.owner, &amp;mut one_ring.former_owner); // Gollum got the ring back for a second
    println!("{}", one_ring);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">Frodo has the ring, Gollum used to have it, and Sauron wants it
Gollum has the ring, Frodo used to have it, and Sauron wants it
</code></pre>
<p><code>replace()</code>:è¿™ä¸ªå°±åƒswapä¸€æ ·ï¼Œå…¶å®é‡Œé¢ä¹Ÿç”¨äº†swapï¼Œä½ å¯ä»¥çœ‹åˆ°ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn replace&lt;T&gt;(dest: &amp;mut T, mut src: T) -&gt; T {
    swap(dest, &amp;mut src);
    src
}
<span class="boring">}</span></code></pre></pre>
<p>æ‰€ä»¥å®ƒåªæ˜¯åšäº†ä¸€ä¸ªäº¤æ¢ï¼Œç„¶åè¿”å›å¦ä¸€ä¸ªå…ƒç´ ã€‚æœ‰äº†è¿™ä¸ªï¼Œä½ å°±ç”¨ä½ æ”¾è¿›å»çš„å…¶ä»–ä¸œè¥¿æ¥æ›¿æ¢è¿™ä¸ªå€¼ã€‚å› ä¸ºå®ƒè¿”å›çš„æ˜¯æ—§çš„å€¼ï¼Œæ‰€ä»¥ä½ åº”è¯¥ç”¨<code>let</code>æ¥ä½¿ç”¨å®ƒã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct City {
    name: String,
}

impl City {
    fn change_name(&amp;mut self, name: &amp;str) {
        let old_name = mem::replace(&amp;mut self.name, name.to_string());
        println!(
            "The city once called {} is now called {}.",
            old_name, self.name
        );
    }
}

fn main() {
    let mut capital_city = City {
        name: "Constantinople".to_string(),
    };
    capital_city.change_name("Istanbul");
}</code></pre></pre>
<p>è¿™æ ·å°±ä¼šæ‰“å°å‡º<code>The city once called Constantinople is now called Istanbul.</code>ã€‚</p>
<p>æœ‰ä¸€ä¸ªå‡½æ•°å«<code>.take()</code>ï¼Œå’Œ<code>.replace()</code>ä¸€æ ·ï¼Œä½†å®ƒåœ¨å…ƒç´ ä¸­ç•™ä¸‹äº†é»˜è®¤å€¼ã€‚
ä½ ä¼šè®°å¾—ï¼Œé»˜è®¤å€¼é€šå¸¸æ˜¯0ã€""ä¹‹ç±»çš„ä¸œè¥¿ã€‚è¿™é‡Œæ˜¯ç­¾åã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ğŸš§
pub fn take&lt;T&gt;(dest: &amp;mut T) -&gt; T
where
    T: Default,
<span class="boring">}</span></code></pre></pre>
<p>æ‰€ä»¥ä½ å¯ä»¥åšè¿™æ ·çš„äº‹æƒ…ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    let mut number_vec = vec![8, 7, 0, 2, 49, 9999];
    let mut new_vec = vec![];

    number_vec.iter_mut().for_each(|number| {
        let taker = mem::take(number);
        new_vec.push(taker);
    });

    println!("{:?}\n{:?}", number_vec, new_vec);
}</code></pre></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œå®ƒå°†æ‰€æœ‰æ•°å­—éƒ½æ›¿æ¢ä¸º0:æ²¡æœ‰åˆ é™¤ä»»ä½•ç´¢å¼•ã€‚</p>
<pre><code class="language-text">[0, 0, 0, 0, 0, 0]
[8, 7, 0, 2, 49, 9999]
</code></pre>
<p>å½“ç„¶ï¼Œå¯¹äºä½ è‡ªå·±çš„ç±»å‹ï¼Œä½ å¯ä»¥æŠŠ<code>Default</code>å®ç°æˆä»»ä½•ä½ æƒ³è¦çš„ç±»å‹ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª<code>Bank</code>å’Œä¸€ä¸ª<code>Robber</code>ã€‚æ¯æ¬¡ä»–æŠ¢äº†<code>Bank</code>ï¼Œä»–å°±ä¼šåœ¨æ¡Œå­ä¸Šæ‹¿åˆ°é’±ã€‚ä½†æ˜¯åŠå…¬æ¡Œå¯ä»¥éšæ—¶ä»åé¢æ‹¿é’±ï¼Œæ‰€ä»¥å®ƒæ°¸è¿œæœ‰50ã€‚æˆ‘ä»¬å°†ä¸ºæ­¤è‡ªåˆ¶ä¸€ä¸ªç±»å‹ï¼Œæ‰€ä»¥å®ƒå°†æ°¸è¿œæœ‰50ã€‚ä¸‹é¢æ˜¯å®ƒçš„å·¥ä½œåŸç†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
use std::ops::{Deref, DerefMut}; // We will use this to get the power of u32

struct Bank {
    money_inside: u32,
    money_at_desk: DeskMoney, // This is our "smart pointer" type. It has its own default, but it will use u32
}

struct DeskMoney(u32);

impl Default for DeskMoney {
    fn default() -&gt; Self {
        Self(50) // default is always 50, not 0
    }
}

impl Deref for DeskMoney { // With this we can access the u32 using *
    type Target = u32;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for DeskMoney { // And with this we can add, subtract, etc.
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

impl Bank {
    fn check_money(&amp;self) {
        println!(
            "There is ${} in the back and ${} at the desk.\n",
            self.money_inside, *self.money_at_desk // Use * so we can just print the u32
        );
    }
}

struct Robber {
    money_in_pocket: u32,
}

impl Robber {
    fn check_money(&amp;self) {
        println!("The robber has ${} right now.\n", self.money_in_pocket);
    }

    fn rob_bank(&amp;mut self, bank: &amp;mut Bank) {
        let new_money = mem::take(&amp;mut bank.money_at_desk); // Here it takes the money, and leaves 50 because that is the default
        self.money_in_pocket += *new_money; // Use * because we can only add u32. DeskMoney can't add
        bank.money_inside -= *new_money;    // Same here
        println!("She robbed the bank. She now has ${}!\n", self.money_in_pocket);
    }
}

fn main() {
    let mut bank_of_klezkavania = Bank { // Set up our bank
        money_inside: 5000,
        money_at_desk: DeskMoney(50),
    };
    bank_of_klezkavania.check_money();

    let mut robber = Robber { // Set up our robber
        money_in_pocket: 50,
    };
    robber.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Rob, then check money
    robber.check_money();
    bank_of_klezkavania.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Do it again
    robber.check_money();
    bank_of_klezkavania.check_money();

}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">There is $5000 in the back and $50 at the desk.

The robber has $50 right now.

She robbed the bank. She now has $100!

The robber has $100 right now.

There is $4950 in the back and $50 at the desk.

She robbed the bank. She now has $150!

The robber has $150 right now.

There is $4900 in the back and $50 at the desk.
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°æ¡Œå­ä¸Šæ€»æ˜¯æœ‰50ç¾å…ƒã€‚</p>
<h3 id="prelude"><a class="header" href="#prelude">Prelude</a></h3>
<p>æ ‡å‡†åº“ä¹Ÿæœ‰ä¸€ä¸ªpreludeï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ä¸ç”¨å†™<code>use std::vec::Vec</code>è¿™æ ·çš„ä¸œè¥¿æ¥åˆ›å»ºä¸€ä¸ª<code>Vec</code>ã€‚ä½ å¯ä»¥<a href="https://doc.rust-lang.org/std/prelude/index.html#prelude-contents">åœ¨è¿™é‡Œ</a>çœ‹åˆ°æ‰€æœ‰è¿™äº›å…ƒç´ ï¼Œå¹¶ä¸”å¤§è‡´äº†è§£:</p>
<ul>
<li><code>std::marker::{Copy, Send, Sized, Sync, Unpin}</code>. ä½ ä»¥å‰æ²¡æœ‰è§è¿‡<code>Unpin</code>ï¼Œå› ä¸ºå‡ ä¹æ¯ä¸€ç§ç±»å‹éƒ½ä¼šç”¨åˆ°å®ƒ(æ¯”å¦‚<code>Sized</code>ï¼Œä¹Ÿå¾ˆå¸¸è§)ã€‚"Pin"çš„æ„æ€æ˜¯ä¸è®©ä¸œè¥¿åŠ¨ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ<code>Pin</code>æ„å‘³ç€å®ƒåœ¨å†…å­˜ä¸­ä¸èƒ½ç§»åŠ¨ï¼Œä½†å¤§å¤šæ•°å…ƒç´ éƒ½æœ‰<code>Unpin</code>ï¼Œæ‰€ä»¥ä½ å¯ä»¥ç§»åŠ¨ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåƒ<code>std::mem::replace</code>è¿™æ ·çš„å‡½æ•°èƒ½ç”¨ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰è¢«é’‰ä½ã€‚</li>
<li><code>std::ops::{Drop, Fn, FnMut, FnOnce}</code>.</li>
<li><code>std::mem::drop</code></li>
<li><code>std::boxed::Box</code>.</li>
<li><code>std::borrow::ToOwned</code>. ä½ ä¹‹å‰ç”¨<code>Cow</code>çœ‹åˆ°è¿‡ä¸€ç‚¹ï¼Œå®ƒå¯ä»¥æŠŠå€Ÿæ¥çš„å†…å®¹å˜æˆè‡ªå·±çš„ã€‚å®ƒä½¿ç”¨<code>.to_owned()</code>æ¥å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ä½ ä¹Ÿå¯ä»¥åœ¨<code>&amp;str</code>ä¸Šä½¿ç”¨<code>.to_owned()</code>ï¼Œå¾—åˆ°ä¸€ä¸ª<code>String</code>ï¼Œå¯¹äºå…¶ä»–å€Ÿæ¥çš„å€¼ä¹Ÿæ˜¯ä¸€æ ·ã€‚</li>
<li><code>std::clone::Clone</code></li>
<li><code>std::cmp::{PartialEq, PartialOrd, Eq, Ord}</code>.</li>
<li><code>std::convert::{AsRef, AsMut, Into, From}</code>.</li>
<li><code>std::default::Default</code>.</li>
<li><code>std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}</code>. æˆ‘ä»¬ä¹‹å‰ç”¨<code>.rev()</code>æ¥åšè¿­ä»£å™¨:è¿™å®é™…ä¸Šæ˜¯åšäº†ä¸€ä¸ª<code>DoubleEndedIterator</code>ã€‚<code>ExactSizeIterator</code>åªæ˜¯ç±»ä¼¼äº<code>0..10</code>çš„ä¸œè¥¿:å®ƒå·²ç»çŸ¥é“è‡ªå·±çš„<code>.len()</code>æ˜¯10ã€‚å…¶ä»–è¿­ä»£å™¨ä¸çŸ¥é“å®ƒä»¬çš„é•¿åº¦æ˜¯è‚¯å®šçš„ã€‚</li>
<li><code>std::option::Option::{self, Some, None}</code>.</li>
<li><code>std::result::Result::{self, Ok, Err}</code>.</li>
<li><code>std::string::{String, ToString}</code>.</li>
<li><code>std::vec::Vec</code>.</li>
</ul>
<p>å¦‚æœä½ å› ä¸ºæŸäº›åŸå› ä¸æƒ³è¦è¿™ä¸ªpreludeæ€ä¹ˆåŠï¼Ÿå°±åŠ å±æ€§<code>#![no_implicit_prelude]</code>ã€‚æˆ‘ä»¬æ¥è¯•ä¸€è¯•ï¼Œçœ‹ç¼–è¯‘å™¨çš„æŠ±æ€¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
#![no_implicit_prelude]
fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from("This won't work");
    println!("{:?}, {}", my_vec, my_string);
}</code></pre></pre>
<p>ç°åœ¨Rustæ ¹æœ¬ä¸çŸ¥é“ä½ æƒ³åšä»€ä¹ˆã€‚</p>
<pre><code class="language-text">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:5:5
  |
5 |     println!("{:?}, {}", my_vec, my_string);
  |     ^^^^^^^

error: cannot find macro `vec` in this scope
 --&gt; src/main.rs:3:18
  |
3 |     let my_vec = vec![8, 9, 10];
  |                  ^^^

error[E0433]: failed to resolve: use of undeclared type or module `String`
 --&gt; src/main.rs:4:21
  |
4 |     let my_string = String::from("This won't work");
  |                     ^^^^^^ use of undeclared type or module `String`

error: aborting due to 3 previous errors
</code></pre>
<p>å› æ­¤ï¼Œå¯¹äºè¿™ä¸ªç®€å•çš„ä»£ç ï¼Œä½ éœ€è¦å‘Šè¯‰Rustä½¿ç”¨<code>extern</code>(å¤–éƒ¨)crateï¼Œå«åš<code>std</code>ï¼Œç„¶åæ˜¯ä½ æƒ³è¦çš„å…ƒç´ ã€‚è¿™é‡Œæ˜¯æˆ‘ä»¬è¦åšçš„ä¸€åˆ‡ï¼Œåªæ˜¯ä¸ºäº†åˆ›å»ºä¸€ä¸ªVecå’Œä¸€ä¸ªStringï¼Œå¹¶æ‰“å°å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust">#![no_implicit_prelude]

extern crate std; // Now you have to tell Rust that you want to use a crate called std
use std::vec; // We need the vec macro
use std::string::String; // and string
use std::convert::From; // and this to convert from a &amp;str to the String
use std::println; // and this to print

fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from("This won't work");
    println!("{:?}, {}", my_vec, my_string);
}</code></pre></pre>
<p>ç°åœ¨ç»ˆäºæˆåŠŸäº†ï¼Œæ‰“å°å‡º<code>[8, 9, 10], This won't work</code>ã€‚æ‰€ä»¥ä½ å¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆRustè¦ç”¨preludeäº†ã€‚ä½†å¦‚æœä½ æ„¿æ„ï¼Œä½ ä¸éœ€è¦ä½¿ç”¨å®ƒã€‚è€Œä¸”ä½ ç”šè‡³å¯ä»¥ä½¿ç”¨<code>#![no_std]</code>(æˆ‘ä»¬æ›¾ç»çœ‹åˆ°è¿‡)ï¼Œç”¨äºä½ è¿å †æ ˆå†…å­˜è¿™ç§ä¸œè¥¿éƒ½ç”¨ä¸ä¸Šçš„æ—¶å€™ã€‚ä½†å¤§å¤šæ•°æ—¶å€™ï¼Œä½ æ ¹æœ¬ä¸ç”¨è€ƒè™‘ä¸ç”¨preludeæˆ–<code>std</code>ã€‚</p>
<p>é‚£ä¹ˆä¸ºä»€ä¹ˆä¹‹å‰æˆ‘ä»¬æ²¡æœ‰çœ‹åˆ°<code>extern</code>è¿™ä¸ªå…³é”®å­—å‘¢ï¼Ÿæ˜¯å› ä¸ºä½ å·²ç»ä¸éœ€è¦å®ƒäº†ã€‚ä»¥å‰ï¼Œå½“å¸¦å…¥å¤–éƒ¨crateæ—¶ï¼Œä½ å¿…é¡»ä½¿ç”¨å®ƒã€‚æ‰€ä»¥ä»¥å‰è¦ä½¿ç”¨<code>rand</code>ï¼Œä½ å¿…é¡»è¦å†™æˆ:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate rand;
<span class="boring">}</span></code></pre></pre>
<p>ç„¶åç”¨ <code>use</code> è¯­å¥æ¥è¡¨ç¤ºä½ æƒ³ä½¿ç”¨çš„ä¿®æ”¹ã€traitç­‰ã€‚ä½†ç°åœ¨Rustç¼–è¯‘å™¨å·²ç»ä¸éœ€è¦è¿™äº›å¸®åŠ©äº†--ä½ åªéœ€è¦ä½¿ç”¨<code>use</code>ï¼Œrustå°±çŸ¥é“åœ¨å“ªé‡Œå¯ä»¥æ‰¾åˆ°å®ƒã€‚æ‰€ä»¥ä½ å‡ ä¹å†ä¹Ÿä¸éœ€è¦<code>extern crate</code>äº†ï¼Œä½†åœ¨å…¶ä»–äººçš„Rustä»£ç ä¸­ï¼Œä½ å¯èƒ½ä»ç„¶ä¼šåœ¨é¡¶éƒ¨çœ‹åˆ°å®ƒã€‚</p>
<h3 id="time"><a class="header" href="#time">Time</a></h3>
<p><code>std::time</code>æ˜¯ä½ å¯ä»¥æ‰¾åˆ°æ—¶é—´å‡½æ•°çš„åœ°æ–¹ã€‚(å¦‚æœä½ æƒ³è¦æ›´å¤šçš„åŠŸèƒ½ï¼Œ<code>chrono</code>è¿™æ ·çš„crateä¹Ÿå¯ä»¥ã€‚)æœ€ç®€å•çš„åŠŸèƒ½å°±æ˜¯ç”¨<code>Instant::now()</code>è·å–ç³»ç»Ÿæ—¶é—´å³å¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time = Instant::now();
    println!("{:?}", time);
}</code></pre></pre>
<p>å¦‚æœä½ æ‰“å°å‡ºæ¥ï¼Œä½ ä¼šå¾—åˆ°è¿™æ ·çš„ä¸œè¥¿ã€‚<code>Instant { tv_sec: 2738771, tv_nsec: 685628140 }</code>. è¿™è¯´çš„æ˜¯ç§’å’Œçº³ç§’ï¼Œä½†ç”¨å¤„ä¸å¤§ã€‚æ¯”å¦‚ä½ çœ‹2738771ç§’(å†™äº8æœˆ)ï¼Œå°±æ˜¯31.70å¤©ã€‚è¿™å’Œæœˆä»½ã€æ—¥å­æ²¡æœ‰ä»»ä½•å…³ç³»ã€‚ä½†æ˜¯<code>Instant</code>çš„é¡µé¢å‘Šè¯‰æˆ‘ä»¬ï¼Œå®ƒæœ¬èº«ä¸åº”è¯¥æœ‰ç”¨ã€‚å®ƒè¯´å®ƒæ˜¯ "ä¸é€æ˜çš„ï¼Œåªæœ‰å’ŒDurationä¸€èµ·æ‰æœ‰ç”¨"ã€‚Opaqueçš„æ„æ€æ˜¯ "ä½ æä¸æ¸…æ¥š"ï¼Œè€ŒDurationçš„æ„æ€æ˜¯ "è¿‡äº†å¤šå°‘æ—¶é—´"ã€‚æ‰€ä»¥å®ƒåªæœ‰åœ¨åšæ¯”è¾ƒæ—¶é—´è¿™æ ·çš„äº‹æƒ…æ—¶æ‰æœ‰ç”¨ã€‚</p>
<p>å¦‚æœä½ çœ‹å·¦è¾¹çš„traitï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯<code>Sub&lt;Instant&gt;</code>ã€‚ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥ç”¨<code>-</code>æ¥å‡å»ä¸€ä¸ªã€‚è€Œå½“æˆ‘ä»¬ç‚¹å‡»[src]çœ‹å®ƒçš„ä½œç”¨æ—¶ï¼Œé¡µé¢æ˜¾ç¤ºï¼š</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sub&lt;Instant&gt; for Instant {
    type Output = Duration;

    fn sub(self, other: Instant) -&gt; Duration {
        self.duration_since(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>å› æ­¤ï¼Œå®ƒéœ€è¦ä¸€ä¸ª<code>Instant</code>ï¼Œå¹¶ä½¿ç”¨<code>.duration_since()</code>ç»™å‡ºä¸€ä¸ª<code>Duration</code>ã€‚è®©æˆ‘ä»¬è¯•ç€æ‰“å°ä¸€ä¸‹ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸¤ä¸ªç›¸é‚»çš„ <code>Instant::now()</code>ï¼Œç„¶åè®©ç¨‹åºå¿™æ´»ä¸€ä¼šå„¿ï¼Œå†åˆ›å»ºä¸€ä¸ª <code>Instant::now()</code>ã€‚ç„¶åæˆ‘ä»¬å†åˆ›å»ºä¸€ä¸ª<code>Instant::now()</code>. æœ€åï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ç”¨äº†å¤šé•¿æ—¶é—´ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = Instant::now();
    let time2 = Instant::now(); // These two are right next to each other

    let mut new_string = String::new();
    loop {
        new_string.push('áƒ¬'); // Make Rust push this Georgian letter onto the String
        if new_string.len() &gt; 100_000 { //  until it is 100,000 bytes long
            break;
        }
    }
    let time3 = Instant::now();
    println!("{:?}", time2 - time1);
    println!("{:?}", time3 - time1);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡ºè¿™æ ·çš„ä¸œè¥¿ã€‚</p>
<pre><code class="language-text">1.025Âµs
683.378Âµs
</code></pre>
<p>æ‰€ä»¥ï¼Œè¿™åªæ˜¯1å¾®ç§’å¤šä¸683æ¯«ç§’ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼ŒRustç¡®å®èŠ±äº†ä¸€äº›æ—¶é—´æ¥åšã€‚</p>
<p>ä¸è¿‡æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª<code>Instant</code>åšä¸€ä»¶æœ‰è¶£çš„äº‹æƒ…ã€‚
æˆ‘ä»¬å¯ä»¥æŠŠå®ƒå˜æˆ<code>String</code>ä¸<code>format!("{:?}", Instant::now());</code>ã€‚å®ƒçš„æ ·å­æ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = format!("{:?}", Instant::now());
    println!("{}", time1);
}</code></pre></pre>
<p>è¿™æ ·å°±ä¼šæ‰“å°å‡ºç±»ä¼¼<code>Instant { tv_sec: 2740773, tv_nsec: 632821036 }</code>çš„ä¸œè¥¿ã€‚è¿™æ˜¯æ²¡æœ‰ç”¨çš„ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬ä½¿ç”¨ <code>.iter()</code> å’Œ <code>.rev()</code> ä»¥åŠ <code>.skip(2)</code>ï¼Œæˆ‘ä»¬å¯ä»¥è·³è¿‡æœ€åçš„ <code>}</code> å’Œ <code> </code>ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ªéšæœºæ•°å‘ç”Ÿå™¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn bad_random_number(digits: usize) {
    if digits &gt; 9 {
        panic!("Random number can only be up to 9 digits");
    }
    let now = Instant::now();
    let output = format!("{:?}", now);

    output
        .chars()
        .rev()
        .skip(2)
        .take(digits)
        .for_each(|character| print!("{}", character));
    println!();
}

fn main() {
    bad_random_number(1);
    bad_random_number(1);
    bad_random_number(3);
    bad_random_number(3);
}</code></pre></pre>
<p>è¿™æ ·å°±ä¼šæ‰“å°å‡ºç±»ä¼¼è¿™æ ·çš„å†…å®¹:</p>
<pre><code class="language-text">6
4
967
180
</code></pre>
<p>è¿™ä¸ªå‡½æ•°è¢«ç§°ä¸º<code>bad_random_number</code>ï¼Œå› ä¸ºå®ƒä¸æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„éšæœºæ•°ç”Ÿæˆå™¨ã€‚Rustæœ‰æ›´å¥½çš„crateï¼Œå¯ä»¥ç”¨æ¯”<code>rand</code>æ›´å°‘çš„ä»£ç åˆ›å»ºéšæœºæ•°ï¼Œæ¯”å¦‚<code>fastrand</code>ã€‚ä½†è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼Œä½ å¯ä»¥åˆ©ç”¨ä½ çš„æƒ³è±¡åŠ›ç”¨<code>Instant</code>æ¥åšä¸€äº›äº‹æƒ…ã€‚</p>
<p>å½“ä½ æœ‰ä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨<code>std::thread::sleep</code>ä½¿å®ƒåœæ­¢ä¸€æ®µæ—¶é—´ã€‚å½“ä½ è¿™æ ·åšæ—¶ï¼Œä½ å¿…é¡»ç»™å®ƒä¸€ä¸ªdurationã€‚ä½ ä¸å¿…åˆ›å»ºå¤šä¸ªçº¿ç¨‹æ¥åšè¿™ä»¶äº‹ï¼Œå› ä¸ºæ¯ä¸ªç¨‹åºè‡³å°‘åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸Šã€‚<code>sleep</code>è™½ç„¶éœ€è¦ä¸€ä¸ª<code>Duration</code>ï¼Œæ‰€ä»¥å®ƒå¯ä»¥çŸ¥é“è¦ç¡å¤šä¹…ã€‚ä½ å¯ä»¥è¿™æ ·é€‰å•ä½:<code>Duration::from_millis()</code>, <code>Duration::from_secs</code>, ç­‰ç­‰ã€‚è¿™é‡Œä¸¾ä¸€ä¸ªä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use std::thread::sleep;

fn main() {
    let three_seconds = Duration::from_secs(3);
    println!("I must sleep now.");
    sleep(three_seconds);
    println!("Did I miss anything?");
}</code></pre></pre>
<p>è¿™å°†åªæ‰“å°</p>
<pre><code class="language-text">I must sleep now.
Did I miss anything?
</code></pre>
<p>ä½†çº¿ç¨‹åœ¨ä¸‰ç§’é’Ÿå†…ä»€ä¹ˆä¹Ÿä¸åšã€‚å½“ä½ æœ‰å¾ˆå¤šçº¿ç¨‹éœ€è¦ç»å¸¸å°è¯•ä¸€äº›äº‹æƒ…æ—¶ï¼Œæ¯”å¦‚è¿æ¥ï¼Œä½ é€šå¸¸ä¼šä½¿ç”¨<code>.sleep()</code>ã€‚ä½ ä¸å¸Œæœ›çº¿ç¨‹åœ¨ä¸€ç§’é’Ÿå†…ä½¿ç”¨ä½ çš„å¤„ç†å™¨å°è¯•10ä¸‡æ¬¡ï¼Œè€Œä½ åªæ˜¯æƒ³è®©å®ƒæœ‰æ—¶æ£€æŸ¥ä¸€ä¸‹ã€‚æ‰€ä»¥ï¼Œä½ å°±å¯ä»¥è®¾ç½®ä¸€ä¸ª<code>Duration</code>ï¼Œå®ƒå°±ä¼šåœ¨æ¯æ¬¡é†’æ¥çš„æ—¶å€™å°è¯•åšå®ƒçš„ä»»åŠ¡ã€‚</p>
<h3 id="å…¶ä»–å®"><a class="header" href="#å…¶ä»–å®">å…¶ä»–å®</a></h3>
<p>æˆ‘ä»¬å†æ¥çœ‹çœ‹å…¶ä»–ä¸€äº›å®ã€‚</p>
<p><code>unreachable!()</code></p>
<p>è¿™ä¸ªå®æœ‰ç‚¹åƒ<code>todo!()</code>ï¼Œé™¤äº†å®ƒæ˜¯é’ˆå¯¹ä½ æ°¸è¿œä¸ä¼šç”¨çš„ä»£ç ã€‚ä¹Ÿè®¸ä½ åœ¨ä¸€ä¸ªæšä¸¾ä¸­æœ‰ä¸€ä¸ª<code>match</code>ï¼Œä½ çŸ¥é“å®ƒæ°¸è¿œä¸ä¼šé€‰æ‹©å…¶ä¸­çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œæ‰€ä»¥ä»£ç æ°¸è¿œæ— æ³•è¾¾åˆ°é‚£ä¸ªåˆ†æ”¯ã€‚å¦‚æœæ˜¯è¿™æ ·ï¼Œä½ å¯ä»¥å†™<code>unreachable!()</code>ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±çŸ¥é“å¯ä»¥å¿½ç•¥è¿™éƒ¨åˆ†ã€‚</p>
<p>ä¾‹å¦‚ï¼Œå‡è®¾ä½ æœ‰ä¸€ä¸ªç¨‹åºï¼Œå½“ä½ é€‰æ‹©ä¸€ä¸ªåœ°æ–¹å±…ä½æ—¶ï¼Œå®ƒä¼šå†™ä¸€äº›ä¸œè¥¿ã€‚åœ¨ä¹Œå…‹å…°ï¼Œé™¤äº†åˆ‡å°”è¯ºè´åˆ©ï¼Œå…¶ä»–åœ°æ–¹éƒ½ä¸é”™ã€‚ä½ çš„ç¨‹åºä¸è®©ä»»ä½•äººé€‰æ‹©åˆ‡å°”è¯ºè´åˆ©ï¼Œå› ä¸ºå®ƒç°åœ¨ä¸æ˜¯ä¸€ä¸ªå¥½åœ°æ–¹ã€‚ä½†æ˜¯è¿™ä¸ªæšä¸¾æ˜¯å¾ˆæ—©ä»¥å‰åœ¨åˆ«äººçš„ä»£ç é‡Œåšçš„ï¼Œä½ æ— æ³•æ›´æ”¹ã€‚æ‰€ä»¥åœ¨<code>match</code>çš„åˆ†æ”¯ä¸­ï¼Œä½ å¯ä»¥ç”¨è¿™ä¸ªå®ã€‚å®ƒæ˜¯è¿™æ ·çš„:</p>
<pre><pre class="playground"><code class="language-rust">enum UkrainePlaces {
    Kiev,
    Kharkiv,
    Chernobyl, // Pretend we can't change the enum - Chernobyl will always be here
    Odesa,
    Dnipro,
}

fn choose_city(place: &amp;UkrainePlaces) {
    use UkrainePlaces::*;
    match place {
        Kiev =&gt; println!("You will live in Kiev"),
        Kharkiv =&gt; println!("You will live in Kharkiv"),
        Chernobyl =&gt; unreachable!(),
        Odesa =&gt; println!("You will live in Odesa"),
        Dnipro =&gt; println!("You will live in Dnipro"),
    }
}

fn main() {
    let user_input = UkrainePlaces::Kiev; // Pretend the user input is made from some other function. The user can't choose Chernobyl, no matter what
    choose_city(&amp;user_input);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°å‡º <code>You will live in Kiev</code>ã€‚</p>
<p><code>unreachable!()</code>å¯¹ä½ æ¥è¯´ä¹Ÿå¾ˆå¥½è¯»ï¼Œå› ä¸ºå®ƒæé†’ä½ ä»£ç çš„æŸäº›éƒ¨åˆ†æ˜¯ä¸å¯è®¿é—®çš„ã€‚ä¸è¿‡ä½ å¿…é¡»ç¡®å®šä»£ç ç¡®å®æ˜¯ä¸å¯è®¿é—®çš„ã€‚å¦‚æœç¼–è¯‘å™¨è°ƒç”¨<code>unreachable!()</code>ï¼Œç¨‹åºå°±ä¼šå´©æºƒã€‚</p>
<p>æ­¤å¤–ï¼Œå¦‚æœä½ æ›¾ç»æœ‰ä¸å¯è¾¾çš„ä»£ç ï¼Œè€Œç¼–è¯‘å™¨çŸ¥é“ï¼Œå®ƒä¼šå‘Šè¯‰ä½ ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_or_false = true;

    match true_or_false {
        true =&gt; println!("It's true"),
        false =&gt; println!("It's false"),
        true =&gt; println!("It's true"), // Whoops, we wrote true again
    }
}</code></pre></pre>
<p>å®ƒä¼šè¯´</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; src/main.rs:7:9
  |
7 |         true =&gt; println!("It's true"),
  |         ^^^^
  |
</code></pre>
<p>ä½†æ˜¯<code>unreachable!()</code>æ˜¯ç”¨äºç¼–è¯‘å™¨æ— æ³•çŸ¥é“çš„æ—¶å€™ï¼Œå°±åƒæˆ‘ä»¬å¦ä¸€ä¸ªä¾‹å­ã€‚</p>
<p><code>column!</code>, <code>line!</code>, <code>file!</code>, <code>module_path!</code></p>
<p>è¿™å››ä¸ªå®æœ‰ç‚¹åƒ<code>dbg!()</code>ï¼Œå› ä¸ºä½ åªæ˜¯æŠŠå®ƒä»¬æ”¾è¿›ä»£ç å»ç»™ä½ è°ƒè¯•ä¿¡æ¯ã€‚ä½†æ˜¯å®ƒä»¬ä¸éœ€è¦ä»»ä½•å˜é‡--ä½ åªéœ€è¦ç”¨å®ƒä»¬å’Œæ‹¬å·ä¸€èµ·ä½¿ç”¨ï¼Œè€Œæ²¡æœ‰å…¶ä»–çš„ä¸œè¥¿ã€‚å®ƒä»¬æ”¾åˆ°ä¸€èµ·å¾ˆå®¹æ˜“å­¦:</p>
<ul>
<li><code>column!()</code>ç»™ä½ å†™çš„é‚£ä¸€åˆ—</li>
<li><code>file!()</code>ç»™ä½ å†™çš„æ–‡ä»¶çš„åç§°</li>
<li><code>line!()</code>ç»™ä½ å†™çš„é‚£è¡Œå­—ï¼Œç„¶åæ˜¯</li>
<li><code>module_path!()</code>ç»™ä½ æ¨¡å—çš„ä½ç½®ã€‚</li>
</ul>
<p>æ¥ä¸‹æ¥çš„ä»£ç åœ¨ä¸€ä¸ªç®€å•çš„ä¾‹å­ä¸­å±•ç¤ºäº†è¿™ä¸‰è€…ã€‚æˆ‘ä»¬å°†å‡è£…æœ‰æ›´å¤šçš„ä»£ç (modé‡Œé¢çš„mod)ï¼Œå› ä¸ºè¿™å°±æ˜¯æˆ‘ä»¬è¦ä½¿ç”¨è¿™äº›å®çš„åŸå› ã€‚ä½ å¯ä»¥æƒ³è±¡ä¸€ä¸ªå¤§çš„Rustç¨‹åº,å®ƒæœ‰è®¸å¤šmodå’Œæ–‡ä»¶ã€‚</p>
<pre><pre class="playground"><code class="language-rust">pub mod something {
    pub mod third_mod {
        pub fn print_a_country(input: &amp;mut Vec&lt;&amp;str&gt;) {
            println!(
                "The last country is {} inside the module {}",
                input.pop().unwrap(),
                module_path!()
            );
        }
    }
}

fn main() {
    use something::third_mod::*;
    let mut country_vec = vec!["Portugal", "Czechia", "Finland"];

    // do some stuff
    println!("Hello from file {}", file!());

    // do some stuff
    println!(
        "On line {} we got the country {}",
        line!(),
        country_vec.pop().unwrap()
    );

    // do some more stuff

    println!(
        "The next country is {} on line {} and column {}.",
        country_vec.pop().unwrap(),
        line!(),
        column!(),
    );

    // lots more code

    print_a_country(&amp;mut country_vec);
}</code></pre></pre>
<p>å®ƒæ‰“å°çš„æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><code class="language-text">Hello from file src/main.rs
On line 23 we got the country Finland
The next country is Czechia on line 32 and column 9.
The last country is Portugal inside the module rust_book::something::third_mod
</code></pre>
<p><code>cfg!</code></p>
<p>æˆ‘ä»¬çŸ¥é“ï¼Œä½ å¯ä»¥ä½¿ç”¨ <code>#[cfg(test)]</code> å’Œ <code>#[cfg(windows)]</code> è¿™æ ·çš„å±æ€§æ¥å‘Šè¯‰ç¼–è¯‘å™¨åœ¨æŸäº›æƒ…å†µä¸‹è¯¥æ€ä¹ˆåšã€‚å½“ä½ æœ‰<code>test</code>æ—¶ï¼Œå½“ä½ åœ¨æµ‹è¯•æ¨¡å¼ä¸‹è¿è¡ŒRustæ—¶ï¼Œå®ƒä¼šè¿è¡Œä»£ç (å¦‚æœæ˜¯åœ¨ç”µè„‘ä¸Šï¼Œä½ è¾“å…¥<code>cargo test</code>)ã€‚è€Œå½“ä½ ä½¿ç”¨<code>windows</code>æ—¶ï¼Œå¦‚æœç”¨æˆ·ä½¿ç”¨çš„æ˜¯Windowsï¼Œå®ƒå°±ä¼šè¿è¡Œä»£ç ã€‚ä½†ä¹Ÿè®¸ä½ åªæ˜¯æƒ³æ ¹æ®ä¸åŒæ“ä½œç³»ç»Ÿå¯¹ä¾èµ–ç³»ç»Ÿçš„ä»£ç åšå¾ˆå°çš„ä¿®æ”¹ã€‚è¿™æ—¶å€™è¿™ä¸ªå®å°±å¾ˆæœ‰ç”¨äº†ã€‚å®ƒè¿”å›ä¸€ä¸ª<code>bool</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let helpful_message = if cfg!(target_os = "windows") { "backslash" } else { "slash" };

    println!(
        "...then in your hard drive, type the directory name followed by a {}. Then you...",
        helpful_message
    );
}</code></pre></pre>
<p>è¿™å°†ä»¥ä¸åŒçš„æ–¹å¼æ‰“å°ï¼Œå–å†³äºä½ çš„ç³»ç»Ÿã€‚Rust Playgroundåœ¨Linuxä¸Šè¿è¡Œï¼Œæ‰€ä»¥ä¼šæ‰“å°:</p>
<pre><code class="language-text">...then in your hard drive, type the directory name followed by a slash. Then you...
</code></pre>
<p><code>cfg!()</code>é€‚ç”¨äºä»»ä½•ä¸€ç§é…ç½®ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œå½“ä½ åœ¨æµ‹è¯•ä¸­ä½¿ç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œå®ƒçš„è¿è¡Œæ–¹å¼ä¼šæœ‰æ‰€ä¸åŒã€‚</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)] // cfg! will know to look for the word test
mod testing {
    use super::*;
    #[test]
    fn check_if_five() {
        assert_eq!(bring_number(true), 5); // This bring_number() function should return 5
    }
}

fn bring_number(should_run: bool) -&gt; u32 { // This function takes a bool as to whether it should run
    if cfg!(test) &amp;&amp; should_run { // if it should run and has the configuration test, return 5
        5
    } else if should_run { // if it's not a test but it should run, print something. When you run a test it ignores println! statements
        println!("Returning 5. This is not a test");
        5
    } else {
        println!("This shouldn't run, returning 0."); // otherwise return 0
        0
    }
}

fn main() {
    bring_number(true);
    bring_number(false);
}</code></pre></pre>
<p>ç°åœ¨æ ¹æ®é…ç½®çš„ä¸åŒï¼Œå®ƒçš„è¿è¡Œæ–¹å¼ä¹Ÿä¼šä¸åŒã€‚å¦‚æœä½ åªæ˜¯è¿è¡Œç¨‹åºï¼Œå®ƒä¼šç»™ä½ è¿™æ ·çš„ç»“æœ:</p>
<pre><code class="language-text">Returning 5. This is not a test
This shouldn't run, returning 0.
</code></pre>
<p>ä½†å¦‚æœä½ åœ¨æµ‹è¯•æ¨¡å¼ä¸‹è¿è¡Œå®ƒ(<code>cargo test</code>ï¼Œç”¨äºç”µè„‘ä¸Šçš„Rust)ï¼Œå®ƒå®é™…ä¸Šä¼šè¿è¡Œæµ‹è¯•ã€‚å› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæµ‹è¯•æ€»æ˜¯è¿”å›5ï¼Œæ‰€ä»¥å®ƒä¼šé€šè¿‡ã€‚</p>
<pre><code class="language-text">running 1 test
test testing::check_if_five ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç¼–å†™å®"><a class="header" href="#ç¼–å†™å®">ç¼–å†™å®</a></h2>
<p>ç¼–å†™å®æ˜¯éå¸¸å¤æ‚çš„ã€‚ä½ å¯èƒ½æ°¸è¿œéƒ½ä¸éœ€è¦å†™å®ï¼Œä½†æœ‰æ—¶ä½ å¯èƒ½ä¼šæƒ³å†™ï¼Œå› ä¸ºå®ƒä»¬éå¸¸æ–¹ä¾¿ã€‚å†™å®å¾ˆæœ‰è¶£ï¼Œå› ä¸ºå®ƒä»¬å‡ ä¹æ˜¯ä¸åŒçš„è¯­è¨€ã€‚è¦å†™ä¸€ä¸ªå®ï¼Œä½ å®é™…ä¸Šæ˜¯ç”¨å¦ä¸€ä¸ªå«<code>macro_rules!</code>çš„å®ã€‚ç„¶åä½ æ·»åŠ ä½ çš„å®åç§°ï¼Œå¹¶æ‰“å¼€ä¸€ä¸ª<code>{}</code>å—ã€‚é‡Œé¢æœ‰ç‚¹åƒ<code>match</code>è¯­å¥ã€‚</p>
<p>è¿™é‡Œæœ‰ä¸€ä¸ªåªå–<code>()</code>ï¼Œç„¶åè¿”å›6:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! give_six {
    () =&gt; {
        6
    };
}

fn main() {
    let six = give_six!();
    println!("{}", six);
}</code></pre></pre>
<p>ä½†è¿™å’Œ<code>match</code>è¯­å¥æ˜¯ä¸ä¸€æ ·çš„ï¼Œå› ä¸ºå®å®é™…ä¸Šä¸ä¼šç¼–è¯‘ä»»ä½•ä¸œè¥¿ã€‚å®ƒåªæ˜¯æ¥å—ä¸€ä¸ªè¾“å…¥å¹¶ç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚ç„¶åç¼–è¯‘å™¨ä¼šæ£€æŸ¥å®ƒæ˜¯å¦æœ‰æ„ä¹‰ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®å°±åƒ "å†™ä»£ç çš„ä»£ç "ã€‚ä½ ä¼šè®°å¾—ï¼Œä¸€ä¸ªçœŸæ­£çš„<code>match</code>è¯­å¥éœ€è¦ç»™å‡ºç›¸åŒçš„ç±»å‹ï¼Œæ‰€ä»¥è¿™ä¸ä¼šå·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
// âš ï¸
    let my_number = 10;
    match my_number {
        10 =&gt; println!("You got a ten"),
        _ =&gt; 10,
    }
}</code></pre></pre>
<p>å®ƒä¼šæŠ±æ€¨ä½ åœ¨ä¸€ç§æƒ…å†µä¸‹è¦è¿”å›<code>()</code>ï¼Œåœ¨å¦ä¸€ç§æƒ…å†µä¸‹è¦è¿”å›<code>i32</code>ã€‚</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
 --&gt; src\main.rs:5:14
  |
3 | /     match my_number {
4 | |         10 =&gt; println!("You got a ten"),
  | |               ------------------------- this is found to be of type `()`
5 | |         _ =&gt; 10,
  | |              ^^ expected `()`, found integer
6 | |     }
  | |_____- `match` arms have incompatible types
</code></pre>
<p>ä½†å®å¹¶ä¸å…³å¿ƒï¼Œå› ä¸ºå®ƒåªæ˜¯ç»™å‡ºä¸€ä¸ªè¾“å‡ºã€‚å®ƒä¸æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨--å®ƒæ˜¯ä»£ç å‰çš„ä»£ç ã€‚æ‰€ä»¥ä½ å¯ä»¥è¿™æ ·åš:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! six_or_print {
    (6) =&gt; {
        6
    };
    () =&gt; {
        println!("You didn't give me 6.");
    };
}

fn main() {
    let my_number = six_or_print!(6);
    six_or_print!();
}</code></pre></pre>
<p>è¿™ä¸ªå°±å¥½åŠäº†ï¼Œæ‰“å°çš„æ˜¯<code>You didn't give me 6.</code>ã€‚ä½ ä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸æ˜¯åŒ¹é…åˆ†æ”¯ï¼Œå› ä¸ºæ²¡æœ‰<code>_</code>è¡Œã€‚æˆ‘ä»¬åªèƒ½ç»™å®ƒ<code>(6)</code>ï¼Œæˆ–è€…<code>()</code>ï¼Œå…¶ä»–çš„éƒ½ä¼šå‡ºé”™ã€‚è€Œæˆ‘ä»¬ç»™å®ƒçš„<code>6</code>ç”šè‡³ä¸æ˜¯<code>i32</code>ï¼Œåªæ˜¯ä¸€ä¸ªè¾“å…¥6ã€‚å…¶å®ä½ å¯ä»¥è®¾ç½®ä»»ä½•ä¸œè¥¿ä½œä¸ºå®çš„è¾“å…¥ï¼Œå› ä¸ºå®ƒåªæ˜¯çœ‹è¾“å…¥ï¼Œçœ‹å¾—åˆ°ä»€ä¹ˆã€‚æ¯”å¦‚è¯´:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    (THis is strange input í•˜í•˜ã¯ã¯å“ˆå“ˆ but it still works) =&gt; {
        println!("You guessed the secret message!")
    };
    () =&gt; {
        println!("You didn't guess it");
    };
}

fn main() {
    might_print!(THis is strange input í•˜í•˜ã¯ã¯å“ˆå“ˆ but it still works);
    might_print!();
}</code></pre></pre>
<p>æ‰€ä»¥è¿™ä¸ªå¥‡æ€ªçš„å®åªå“åº”ä¸¤ä»¶äº‹ã€‚<code>()</code>å’Œ<code>(THis is strange input í•˜í•˜ã¯ã¯å“ˆå“ˆ but it still works)</code>. æ²¡æœ‰å…¶ä»–çš„ä¸œè¥¿ã€‚å®ƒæ‰“å°çš„æ˜¯:</p>
<pre><code class="language-text">You guessed the secret message!
You didn't guess it
</code></pre>
<p>æ‰€ä»¥å®ä¸å®Œå…¨æ˜¯Rustè¯­æ³•ã€‚ä½†æ˜¯å®ä¹Ÿå¯ä»¥ç†è§£ä½ ç»™å®ƒçš„ä¸åŒç±»å‹çš„è¾“å…¥ã€‚æ‹¿è¿™ä¸ªä¾‹å­æ¥è¯´ã€‚</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    ($input:expr) =&gt; {
        println!("You gave me: {}", $input);
    }
}

fn main() {
    might_print!(6);
}</code></pre></pre>
<p>è¿™å°†æ‰“å°<code>You gave me: 6</code>ã€‚<code>$input:expr</code>éƒ¨åˆ†å¾ˆé‡è¦ã€‚å®ƒçš„æ„æ€æ˜¯ "å¯¹äºä¸€ä¸ªè¡¨è¾¾å¼ï¼Œç»™å®ƒèµ·ä¸€ä¸ªå˜é‡å$input"ã€‚åœ¨å®ä¸­ï¼Œå˜é‡ä»¥<code>$</code>å¼€å¤´ã€‚åœ¨è¿™ä¸ªå®ä¸­ï¼Œå¦‚æœä½ ç»™å®ƒä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒå°±ä¼šæ‰“å°å‡ºæ¥ã€‚æˆ‘ä»¬å†æ¥è¯•ä¸€è¯•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    ($input:expr) =&gt; {
        println!("You gave me: {:?}", $input); // Now we'll use {:?} because we will give it different kinds of expressions
    }
}

fn main() {
    might_print!(()); // give it a ()
    might_print!(6); // give it a 6
    might_print!(vec![8, 9, 7, 10]); // give it a vec
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">You gave me: ()
You gave me: 6
You gave me: [8, 9, 7, 10]
</code></pre>
<p>å¦å¤–æ³¨æ„ï¼Œæˆ‘ä»¬å†™äº†<code>{:?}</code>ï¼Œä½†å®ƒä¸ä¼šæ£€æŸ¥<code>&amp;input</code>æ˜¯å¦å®ç°äº†<code>Debug</code>ã€‚å®ƒåªä¼šå†™ä»£ç ï¼Œå¹¶å°è¯•è®©å®ƒç¼–è¯‘ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šç»™å‡ºä¸€ä¸ªé”™è¯¯ã€‚</p>
<p>é‚£ä¹ˆé™¤äº†<code>expr</code>ï¼Œå®è¿˜èƒ½çœ‹åˆ°ä»€ä¹ˆå‘¢ï¼Ÿå®ƒä»¬æ˜¯ <code>block | expr | ident | item | lifetime | literal  | meta | pat | path | stmt | tt | ty | vis</code>. è¿™å°±æ˜¯å¤æ‚çš„éƒ¨åˆ†ã€‚ä½ å¯ä»¥åœ¨<a href="https://doc.rust-lang.org/beta/reference/macros-by-example.html">è¿™é‡Œ</a>çœ‹åˆ°å®ƒä»¬å„è‡ªçš„æ„æ€ï¼Œè¿™é‡Œè¯´:</p>
<pre><code class="language-text">item: an Item
block: a BlockExpression
stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)
pat: a Pattern
expr: an Expression
ty: a Type
ident: an IDENTIFIER_OR_KEYWORD
path: a TypePath style path
tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})
meta: an Attr, the contents of an attribute
lifetime: a LIFETIME_TOKEN
vis: a possibly empty Visibility qualifier
literal: matches -?LiteralExpression
</code></pre>
<p>å¦å¤–æœ‰ä¸€ä¸ªå¾ˆå¥½çš„ç½‘ç«™å«cheats.rsï¼Œåœ¨<a href="https://cheats.rs/#macros-attributes">è¿™é‡Œ</a>è§£é‡Šäº†å®ƒä»¬ï¼Œå¹¶ä¸”æ¯ä¸ªéƒ½ç»™å‡ºäº†ä¾‹å­ã€‚</p>
<p>ç„¶è€Œï¼Œå¯¹äºå¤§å¤šæ•°å®ï¼Œä½ åªä¼šç”¨åˆ° <code>expr</code>ã€<code>ident</code> å’Œ <code>tt</code>ã€‚<code>ident</code> è¡¨ç¤ºæ ‡è¯†ç¬¦ï¼Œç”¨äºå˜é‡æˆ–å‡½æ•°åç§°ã€‚<code>tt</code>è¡¨ç¤ºtokenæ ‘ï¼Œå’Œä»»ä½•ç±»å‹çš„è¾“å…¥ã€‚è®©æˆ‘ä»¬å°è¯•ç”¨è¿™ä¸¤ä¸ªè¯åˆ›å»ºä¸€ä¸ªç®€å•çš„å®ã€‚</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! check {
    ($input1:ident, $input2:expr) =&gt; {
        println!(
            "Is {:?} equal to {:?}? {:?}",
            $input1,
            $input2,
            $input1 == $input2
        );
    };
}

fn main() {
    let x = 6;
    let my_vec = vec![7, 8, 9];
    check!(x, 6);
    check!(my_vec, vec![7, 8, 9]);
    check!(x, 10);
}</code></pre></pre>
<p>æ‰€ä»¥è¿™å°†å–ä¸€ä¸ª<code>ident</code>(åƒä¸€ä¸ªå˜é‡å)å’Œä¸€ä¸ªè¡¨è¾¾å¼ï¼Œçœ‹çœ‹å®ƒä»¬æ˜¯å¦ç›¸åŒã€‚å®ƒçš„æ‰“å°ç»“æœæ˜¯</p>
<pre><code class="language-text">Is 6 equal to 6? true
Is [7, 8, 9] equal to [7, 8, 9]? true
Is 6 equal to 10? false
</code></pre>
<p>è€Œè¿™é‡Œæœ‰ä¸€ä¸ªå®ï¼Œè¾“å…¥<code>tt</code>ï¼Œç„¶åæŠŠå®ƒæ‰“å°å‡ºæ¥ã€‚å®ƒå…ˆç”¨ä¸€ä¸ªå«<code>stringify!</code>çš„å®åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! print_anything {
    ($input:tt) =&gt; {
        let output = stringify!($input);
        println!("{}", output);
    };
}

fn main() {
    print_anything!(ththdoetd);
    print_anything!(87575oehq75onth);
}</code></pre></pre>
<p>è¿™ä¸ªå°†æ‰“å°:</p>
<pre><code class="language-text">ththdoetd
87575oehq75onth
</code></pre>
<p>ä½†æ˜¯å¦‚æœæˆ‘ä»¬ç»™å®ƒä¸€äº›å¸¦æœ‰ç©ºæ ¼ã€é€—å·ç­‰çš„ä¸œè¥¿ï¼Œå®ƒå°±ä¸ä¼šæ‰“å°ã€‚å®ƒä¼šè®¤ä¸ºæˆ‘ä»¬ç»™äº†å®ƒä¸æ­¢ä¸€ä¸ªå…ƒç´ æˆ–é¢å¤–çš„ä¿¡æ¯ï¼Œæ‰€ä»¥å®ƒä¼šæ„Ÿåˆ°å›°æƒ‘ã€‚</p>
<p>è¿™å°±æ˜¯å®å¼€å§‹å˜å¾—å›°éš¾çš„åœ°æ–¹ã€‚</p>
<p>è¦ä¸€æ¬¡ç»™å®æä¾›å¤šä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ä¸åŒçš„è¯­æ³•ã€‚ä¸è¦ç”¨<code>$input</code>ï¼Œè€Œæ˜¯<code>$($input1),*</code>ã€‚è¿™æ„å‘³ç€é›¶æˆ–æ›´å¤š(è¿™æ˜¯ * çš„æ„æ€)ï¼Œç”¨é€—å·åˆ†éš”ã€‚å¦‚æœä½ æƒ³è¦ä¸€ä¸ªæˆ–å¤šä¸ªï¼Œè¯·ä½¿ç”¨ <code>+</code> è€Œä¸æ˜¯ <code>*</code>ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬çš„å®çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! print_anything {
    ($($input1:tt),*) =&gt; {
        let output = stringify!($($input1),*);
        println!("{}", output);
    };
}


fn main() {
    print_anything!(ththdoetd, rcofe);
    print_anything!();
    print_anything!(87575oehq75onth, ntohe, 987987o, 097);
}</code></pre></pre>
<p>æ‰€ä»¥å®ƒæ¥å—ä»»ä½•ç”¨é€—å·éš”å¼€çš„tokenæ ‘ï¼Œå¹¶ä½¿ç”¨ <code>stringify!</code> æŠŠå®ƒå˜æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ç„¶åæ‰“å°å‡ºæ¥ã€‚å®ƒçš„æ‰“å°ç»“æœæ˜¯:</p>
<pre><code class="language-text">ththdoetd, rcofe

87575oehq75onth, ntohe, 987987o, 097
</code></pre>
<p>å¦‚æœæˆ‘ä»¬ä½¿ç”¨<code>+</code>è€Œä¸æ˜¯<code>*</code>ï¼Œå®ƒä¼šç»™å‡ºä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸ºæœ‰ä¸€æ¬¡æˆ‘ä»¬æ²¡æœ‰ç»™å®ƒè¾“å…¥ã€‚æ‰€ä»¥<code>*</code>æ˜¯ä¸€ä¸ªæ¯”è¾ƒå®‰å…¨çš„é€‰æ‹©ã€‚</p>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹çœ‹åˆ°å®çš„å¨åŠ›äº†ã€‚åœ¨æ¥ä¸‹æ¥çš„è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„å‡½æ•°:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_a_function {
    ($name:ident, $($input:tt),*) =&gt; { // First you give it one name for the function, then it checks everything else
        fn $name() {
            let output = stringify!($($input),*); // It makes everything else into a string
            println!("{}", output);
        }
    };
}


fn main() {
    make_a_function!(print_it, 5, 5, 6, I); // We want a function called print_it() that prints everything else we give it
    print_it();
    make_a_function!(say_its_nice, this, is, really, nice); // Same here but we change the function name
    say_its_nice();
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">5, 5, 6, I
this, is, really, nice
</code></pre>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹äº†è§£å…¶ä»–çš„å®äº†ã€‚ä½ å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨çš„ä¸€äº›å®éå¸¸ç®€å•ã€‚è¿™é‡Œæ˜¯æˆ‘ä»¬ç”¨æ¥å†™å…¥æ–‡ä»¶çš„<code>write!</code>çš„é‚£ä¸ª:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! write {
    ($dst:expr, $($arg:tt)*) =&gt; ($dst.write_fmt($crate::format_args!($($arg)*)))
}
<span class="boring">}</span></code></pre></pre>
<p>è¦ä½¿ç”¨å®ƒï¼Œä½ å°±è¾“å…¥è¿™ä¸ª:</p>
<ul>
<li>ä¸€ä¸ªè¡¨è¾¾å¼(<code>expr</code>) å¾—åˆ°å˜é‡å<code>$dst</code>.</li>
<li>ä¹‹åçš„ä¸€åˆ‡ã€‚å¦‚æœå®ƒå†™çš„æ˜¯<code>$arg:tt</code>ï¼Œé‚£ä¹ˆå®ƒåªä¼šå–1ä¸ªï¼Œä½†æ˜¯å› ä¸ºå®ƒå†™çš„æ˜¯<code>$($arg:tt)*</code>ï¼Œæ‰€ä»¥å®ƒå–0ï¼Œ1ï¼Œæˆ–è€…ä»»æ„å¤šä¸ªã€‚</li>
</ul>
<p>ç„¶åå®ƒå–<code>$dst</code>ï¼Œå¹¶å¯¹å®ƒä½¿ç”¨äº†ä¸€ä¸ªå«åš<code>write_fmt</code>çš„æ–¹æ³•ã€‚åœ¨è¿™é‡Œé¢ï¼Œå®ƒä½¿ç”¨äº†å¦ä¸€ä¸ªå«åš<code>format_args!</code>çš„å®ï¼Œå®ƒæ¥å—æ‰€æœ‰çš„<code>$($arg)*</code>ï¼Œæˆ–è€…æˆ‘ä»¬è¾“å…¥çš„æ‰€æœ‰å‚æ•°ã€‚</p>
<p>ç°åœ¨æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹<code>todo!</code>è¿™ä¸ªå®ã€‚å½“ä½ æƒ³è®©ç¨‹åºç¼–è¯‘ä½†è¿˜æ²¡æœ‰å†™å‡ºä½ çš„ä»£ç æ—¶ï¼Œå°±ä¼šç”¨åˆ°è¿™ä¸ªå®ã€‚å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! todo {
    () =&gt; (panic!("not yet implemented"));
    ($($arg:tt)+) =&gt; (panic!("not yet implemented: {}", $crate::format_args!($($arg)+)));
}
<span class="boring">}</span></code></pre></pre>
<p>è¿™ä¸ªæœ‰ä¸¤ä¸ªé€‰é¡¹:ä½ å¯ä»¥è¾“å…¥<code>()</code>ï¼Œä¹Ÿå¯ä»¥è¾“å…¥ä¸€äº›tokenæ ‘(<code>tt</code>)ã€‚</p>
<ul>
<li>å¦‚æœä½ è¾“å…¥<code>()</code>ï¼Œå®ƒåªæ˜¯<code>panic!</code>ï¼Œå¹¶åŠ ä¸Šä¸€ä¸ªä¿¡æ¯ã€‚æ‰€ä»¥å…¶å®ä½ å¯ä»¥ç›´æ¥å†™<code>panic!("not yet implemented")</code>ï¼Œè€Œä¸æ˜¯<code>todo!</code>ï¼Œè¿™ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚</li>
<li>å¦‚æœä½ è¾“å…¥ä¸€äº›å‚æ•°ï¼Œå®ƒä¼šå°è¯•æ‰“å°å®ƒä»¬ã€‚ä½ å¯ä»¥çœ‹åˆ°é‡Œé¢æœ‰åŒæ ·çš„<code>format_args!</code>å®ï¼Œå®ƒçš„å·¥ä½œåŸç†å’Œ<code>println!</code>ä¸€æ ·ã€‚</li>
</ul>
<p>æ‰€ä»¥ï¼Œå¦‚æœä½ å†™äº†è¿™ä¸ªï¼Œå®ƒä¹Ÿä¼šå·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">fn not_done() {
    let time = 8;
    let reason = "lack of time";
    todo!("Not done yet because of {}. Check back in {} hours", reason, time);
}

fn main() {
    not_done();
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">thread 'main' panicked at 'not yet implemented: Not done yet because of lack of time. Check back in 8 hours', src/main.rs:4:5
</code></pre>
<p>åœ¨ä¸€ä¸ªå®é‡Œé¢ï¼Œä½ ç”šè‡³å¯ä»¥è°ƒç”¨åŒä¸€ä¸ªå®ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªã€‚</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! my_macro {
    () =&gt; {
        println!("Let's print this.");
    };
    ($input:expr) =&gt; {
        my_macro!();
    };
    ($($input:expr),*) =&gt; {
        my_macro!();
    }
}

fn main() {
    my_macro!(vec![8, 9, 0]);
    my_macro!(toheteh);
    my_macro!(8, 7, 0, 10);
    my_macro!();
}</code></pre></pre>
<p>è¿™ä¸ªå¯ä»¥å–<code>()</code>ï¼Œä¹Ÿå¯ä»¥å–ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¹Ÿå¯ä»¥å–å¾ˆå¤šè¡¨è¾¾å¼ã€‚ä½†æ˜¯ä¸ç®¡ä½ æ”¾ä»€ä¹ˆè¡¨è¾¾å¼ï¼Œå®ƒéƒ½ä¼šå¿½ç•¥æ‰€æœ‰çš„è¡¨è¾¾å¼ï¼Œåªæ˜¯åœ¨<code>()</code>ä¸Šè°ƒç”¨<code>my_macro!</code>ã€‚æ‰€ä»¥è¾“å‡ºçš„åªæ˜¯<code>Let's print this</code>ï¼Œå››æ¬¡ã€‚</p>
<p>åœ¨<code>dbg!</code>å®ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°åŒæ ·çš„æƒ…å†µï¼Œä¹Ÿæ˜¯è°ƒç”¨è‡ªå·±ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! dbg {
    () =&gt; {
        $crate::eprintln!("[{}:{}]", $crate::file!(), $crate::line!()); //$crate means the crate that it's in.
    };
    ($val:expr) =&gt; {
        // Use of `match` here is intentional because it affects the lifetimes
        // of temporaries - https://stackoverflow.com/a/48732525/1063961
        match $val {
            tmp =&gt; {
                $crate::eprintln!("[{}:{}] {} = {:#?}",
                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &amp;tmp);
                tmp
            }
        }
    };
    // Trailing comma with single argument is ignored
    ($val:expr,) =&gt; { $crate::dbg!($val) };
    ($($val:expr),+ $(,)?) =&gt; {
        ($($crate::dbg!($val)),+,)
    };
}
<span class="boring">}</span></code></pre></pre>
<p>(<code>eprintln!</code>ä¸<code>println!</code>ç›¸åŒï¼Œåªæ‰“å°åˆ°<code>io::stderr</code>è€Œä¸æ˜¯<code>io::stdout</code>ã€‚è¿˜æœ‰<code>eprint!</code>ä¸å¢åŠ ä¸€è¡Œ)ã€‚)</p>
<p>æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è‡ªå·±å»è¯•ä¸€è¯•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dbg!();
}</code></pre></pre>
<p>è¿™ä¸ç¬¬ä¸€åˆ†æ”¯ç›¸åŒ¹é…ï¼Œæ‰€ä»¥å®ƒä¼šç”¨<code>file!</code>å’Œ<code>line!</code>å®æ‰“å°æ–‡ä»¶åå’Œè¡Œåã€‚å®ƒæ‰“å°çš„æ˜¯<code>[src/main.rs:2]</code>ã€‚</p>
<p>æˆ‘ä»¬ç”¨è¿™ä¸ªæ¥è¯•è¯•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dbg!(vec![8, 9, 10]);
}</code></pre></pre>
<p>è¿™å°†åŒ¹é…ä¸‹ä¸€ä¸ªåˆ†æ”¯ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚ç„¶åå®ƒå°†è°ƒç”¨è¾“å…¥<code>tmp</code>å¹¶ä½¿ç”¨è¿™ä¸ªä»£ç ã€‚<code> $crate::eprintln!("[{}:{}] {} = {:#?}", $crate::file!(), $crate::line!(), $crate::stringify!($val), &amp;tmp);</code>. æ‰€ä»¥å®ƒä¼šç”¨<code>file!</code>å’Œ<code>line!</code>æ¥æ‰“å°ï¼Œç„¶åæŠŠ<code>$val</code>åšæˆ<code>String</code>ï¼Œç”¨<code>{:#?}</code>æ¥æ¼‚äº®çš„æ‰“å°<code>tmp</code>ã€‚æ‰€ä»¥å¯¹äºæˆ‘ä»¬çš„è¾“å…¥ï¼Œå®ƒä¼šè¿™æ ·å†™ã€‚</p>
<pre><code class="language-text">[src/main.rs:2] vec![8, 9, 10] = [
    8,
    9,
    10,
]
</code></pre>
<p>å‰©ä¸‹çš„éƒ¨åˆ†ï¼Œå³ä½¿ä½ å¤šåŠ äº†ä¸€ä¸ªé€—å·ï¼Œå®ƒä¹Ÿåªæ˜¯è‡ªå·±è°ƒç”¨<code>dbg!</code>ã€‚</p>
<p>æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œå®æ˜¯éå¸¸å¤æ‚çš„ï¼é€šå¸¸ä½ åªæƒ³è®©ä¸€ä¸ªå®è‡ªåŠ¨å®Œæˆä¸€äº›ç®€å•å‡½æ•°ä¸èƒ½å¾ˆå¥½å®Œæˆçš„äº‹æƒ…ã€‚å­¦ä¹ å®çš„æœ€å¥½æ–¹æ³•æ˜¯çœ‹å…¶ä»–å®çš„ä¾‹å­ã€‚æ²¡æœ‰å¤šå°‘äººèƒ½å¤Ÿå¿«é€Ÿå†™å‡ºå®è€Œä¸å‡ºé—®é¢˜ã€‚æ‰€ä»¥ä¸è¦è®¤ä¸ºä½ éœ€è¦çŸ¥é“å®çš„ä¸€åˆ‡ï¼Œæ‰èƒ½çŸ¥é“å¦‚ä½•åœ¨Rustä¸­å†™ã€‚ä½†å¦‚æœä½ è¯»äº†å…¶ä»–å®ï¼Œå¹¶ç¨åŠ ä¿®æ”¹ï¼Œä½ å°±å¯ä»¥å¾ˆå®¹æ˜“åœ°å€Ÿç”¨å®ƒä»¬çš„åŠ›é‡ã€‚ç„¶åä½ å¯èƒ½ä¼šå¼€å§‹é€‚åº”å†™è‡ªå·±çš„å®ã€‚</p>
<h1 id="ç¬¬2éƒ¨åˆ†---ç”µè„‘ä¸Šçš„rust"><a class="header" href="#ç¬¬2éƒ¨åˆ†---ç”µè„‘ä¸Šçš„rust">ç¬¬2éƒ¨åˆ† - ç”µè„‘ä¸Šçš„Rust</a></h1>
<p>ä½ çœ‹åˆ°äº†ï¼Œæˆ‘ä»¬å‡ ä¹å¯ä»¥ä½¿ç”¨Playgroundå­¦ä¹ Rustä¸­çš„ä»»ä½•ä¸œè¥¿ã€‚ä½†å¦‚æœä½ åˆ°ç›®å‰ä¸ºæ­¢å·²ç»å­¦äº†è¿™ä¹ˆå¤šï¼Œç°åœ¨ä½ å¯èƒ½ä¼šæƒ³è¦åœ¨ä½ çš„ç”µè„‘ä¸Šä½¿ç”¨Rustã€‚æ€»æœ‰ä¸€äº›äº‹æƒ…æ˜¯ä½ ä¸èƒ½ç”¨Playgroundåšçš„ï¼Œæ¯”å¦‚ä½¿ç”¨æ–‡ä»¶æˆ–ä»£ç åœ¨å¤šä¸ªæ–‡ä»¶ä¸­ã€‚å…¶ä»–å¦‚è¾“å…¥å’Œflagsä¹Ÿéœ€è¦åœ¨ç”µè„‘ä¸Šå®‰è£…Rustã€‚ä½†æœ€é‡è¦çš„æ˜¯ï¼Œåœ¨ä½ çš„ç”µè„‘ä¸Šæœ‰äº†Rustï¼Œä½ å¯ä»¥ä½¿ç”¨Crateã€‚æˆ‘ä»¬å·²ç»äº†è§£äº†crateï¼Œä½†åœ¨playgroundä¸­ä½ åªèƒ½ä½¿ç”¨æœ€æµè¡Œçš„crateã€‚ä½†åœ¨ä½ çš„ç”µè„‘ä¸Šï¼Œä½ å¯ä»¥åœ¨ç¨‹åºä¸­ä½¿ç”¨ä»»ä½•crateã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo"><a class="header" href="#cargo">cargo</a></h2>
<p><code>rustc</code>çš„æ„æ€æ˜¯Rustç¼–è¯‘å™¨ï¼Œå®é™…çš„ç¼–è¯‘å·¥ä½œç”±å®ƒå®Œæˆã€‚ä¸€ä¸ªrustæ–‡ä»¶çš„ç»“å°¾æ˜¯<code>.rs</code>ã€‚ä½†å¤§å¤šæ•°äººä¸ä¼šå†™å‡ºç±»ä¼¼ <code>rustc main.rs</code> çš„ä¸œè¥¿æ¥ç¼–è¯‘ã€‚ä»–ä»¬ä½¿ç”¨çš„æ˜¯åä¸º <code>cargo</code> çš„ä¸œè¥¿ï¼Œå®ƒæ˜¯ Rust çš„ä¸»åŒ…ç®¡ç†å™¨ã€‚</p>
<p>å…³äºè¿™ä¸ªåå­—çš„ä¸€ä¸ªè¯´æ˜: ä¹‹æ‰€ä»¥å«<code>cargo</code>ï¼Œæ˜¯å› ä¸ºå½“ä½ æŠŠcrateæ”¾åœ¨ä¸€èµ·æ—¶ï¼Œä½ ä¼šå¾—åˆ°cargoã€‚Crateå°±æ˜¯ä½ åœ¨èˆ¹ä¸Šæˆ–å¡è½¦ä¸Šçœ‹åˆ°çš„æœ¨ç®±ï¼Œä½†ä½ è®°ä½ï¼Œæ¯ä¸ªRusté¡¹ç›®ä¹Ÿå«Crateã€‚é‚£ä¹ˆå½“ä½ æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·æ—¶ï¼Œä½ å°±ä¼šå¾—åˆ°æ•´ä¸ªcargoã€‚</p>
<p>å½“ä½ ä½¿ç”¨cargoæ¥è¿è¡Œä¸€ä¸ªé¡¹ç›®æ—¶ï¼Œä½ å¯ä»¥çœ‹åˆ°è¿™ä¸€ç‚¹ã€‚è®©æˆ‘ä»¬ç”¨ <code>rand</code> è¯•è¯•ç®€å•çš„ä¸œè¥¿:æˆ‘ä»¬åªæ˜¯åœ¨å…«ä¸ªå­—æ¯ä¹‹é—´éšæœºé€‰æ‹©ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use rand::seq::SliceRandom; // Use this for .choose over slices

fn main() {

    let my_letters = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

    let mut rng = rand::thread_rng();
    for _ in 0..6 {
        print!("{} ", my_letters.choose(&amp;mut rng).unwrap());
    }
}</code></pre></pre>
<p>è¿™æ ·å°±ä¼šæ‰“å°å‡º<code>b c g h e a</code>è¿™æ ·çš„ä¸œè¥¿ã€‚ä½†æˆ‘ä»¬æƒ³å…ˆçœ‹çœ‹<code>cargo</code>çš„ä½œç”¨ã€‚è¦ä½¿ç”¨ <code>cargo</code> å¹¶è¿è¡Œæˆ‘ä»¬çš„ç¨‹åºï¼Œé€šå¸¸æˆ‘ä»¬è¾“å…¥ <code>cargo run</code>ã€‚è¿™æ ·å°±å¯ä»¥æ„å»ºæˆ‘ä»¬çš„ç¨‹åºï¼Œå¹¶ä¸ºæˆ‘ä»¬è¿è¡Œå®ƒã€‚å½“å®ƒå¼€å§‹ç¼–è¯‘çš„æ—¶å€™ï¼Œä¼šåšè¿™æ ·çš„äº‹æƒ…:</p>
<pre><code class="language-text">   Compiling getrandom v0.1.14
   Compiling cfg-if v0.1.10
   Compiling ppv-lite86 v0.2.8
   Compiling rand_core v0.5.1
   Compiling rand_chacha v0.2.2
   Compiling rand v0.7.3
   Compiling rust_book v0.1.0 (C:\Users\mithr\OneDrive\Documents\Rust\rust_book)
    Finished dev [unoptimized + debuginfo] target(s) in 13.13s
     Running `C:\Users\mithr\OneDrive\Documents\Rust\rust_book\target\debug\rust_book.exe`
g f c f h b
</code></pre>
<p>æ‰€ä»¥çœ‹èµ·æ¥ä¸åªæ˜¯å¼•å…¥äº†<code>rand</code>ï¼Œè¿˜å¼•å…¥äº†ä¸€äº›å…¶ä»–çš„crateã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„crateéœ€è¦<code>rand</code>ï¼Œä½†<code>rand</code>ä¹Ÿæœ‰ä¸€äº›ä»£ç ä¹Ÿéœ€è¦å…¶ä»–crateã€‚æ‰€ä»¥<code>cargo</code>ä¼šæ‰¾åˆ°æˆ‘ä»¬éœ€è¦çš„æ‰€æœ‰crateï¼Œå¹¶æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·ã€‚åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œåªæœ‰7ä¸ªï¼Œä½†åœ¨éå¸¸å¤§çš„é¡¹ç›®ä¸­ï¼Œä½ å¯èƒ½ä¼šæœ‰200ä¸ªæˆ–æ›´å¤šçš„crateè¦å¼•å…¥ã€‚</p>
<p>è¿™å°±æ˜¯ä½ å¯ä»¥çœ‹åˆ°Rustçš„æƒè¡¡çš„åœ°æ–¹ã€‚Rustçš„é€Ÿåº¦éå¸¸å¿«ï¼Œå› ä¸ºå®ƒæå‰ç¼–è¯‘ã€‚å®ƒé€šè¿‡æŸ¥çœ‹ä»£ç ï¼Œçœ‹ä½ å†™çš„ä»£ç åˆ°åº•åšäº†ä»€ä¹ˆã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½ä¼šå†™è¿™æ ·çš„æ³›å‹ä»£ç :</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_and_return_thing&lt;T: Display&gt;(input: T) -&gt; T {
    println!("You gave me {} and now I will give it back.", input);
    input
}

fn main() {
    let my_name = print_and_return_thing("Windy");
    let small_number = print_and_return_thing(9.0);
}</code></pre></pre>
<p>è¿™ä¸ªå‡½æ•°å¯ä»¥ç”¨ä»»ä½•å®ç°äº†<code>Display</code>çš„ä½œä¸ºå‚æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ç»™å®ƒä¸€ä¸ª<code>&amp;str</code>ï¼Œæ¥ä¸‹æ¥ç»™å®ƒä¸€ä¸ª<code>f64</code>ï¼Œè¿™å¯¹æˆ‘ä»¬æ¥è¯´æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ä½†æ˜¯ç¼–è¯‘å™¨ä¸çœ‹æ³›å‹ï¼Œå› ä¸ºå®ƒä¸æƒ³åœ¨è¿è¡Œæ—¶åšä»»ä½•äº‹æƒ…ã€‚å®ƒæƒ³æŠŠä¸€ä¸ªèƒ½è¿è¡Œçš„ç¨‹åºå°½å¯èƒ½å¿«åœ°ç»„è£…èµ·æ¥ã€‚æ‰€ä»¥å½“å®ƒçœ‹ç¬¬ä¸€éƒ¨åˆ†çš„<code>"Windy"</code>æ—¶ï¼Œå®ƒæ²¡æœ‰çœ‹åˆ°<code>fn print_and_return_thing&lt;T: Display&gt;(input: T) -&gt; T</code>ï¼Œå®ƒçœ‹åˆ°çš„æ˜¯<code>fn print_and_return_thing(input: &amp;str) -&gt; &amp;str</code>è¿™æ ·çš„ä¸œè¥¿ã€‚è€Œæ¥ä¸‹æ¥å®ƒçœ‹åˆ°çš„æ˜¯<code>fn print_and_return_thing(input: f64) -&gt; f64</code>ã€‚æ‰€æœ‰å…³äºtraitçš„æ£€æŸ¥ç­‰ç­‰éƒ½æ˜¯åœ¨ç¼–è¯‘æ—¶å®Œæˆçš„ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ³›å‹éœ€è¦æ›´é•¿çš„æ—¶é—´æ¥ç¼–è¯‘ï¼Œå› ä¸ºå®ƒéœ€è¦å¼„æ¸…æ¥šå®ƒä»¬ï¼Œå¹¶ä½¿ä¹‹å…·ä½“åŒ–ã€‚</p>
<p>è¿˜æœ‰ä¸€ç‚¹:Rust 2020æ­£åœ¨åŠªåŠ›å¤„ç†ç¼–è¯‘æ—¶é—´é—®é¢˜ï¼Œå› ä¸ºè¿™éƒ¨åˆ†éœ€è¦çš„æ—¶é—´æœ€é•¿ã€‚æ¯ä¸€ä¸ªç‰ˆæœ¬çš„Ruståœ¨ç¼–è¯‘æ—¶éƒ½ä¼šå¿«ä¸€ç‚¹ï¼Œè€Œä¸”è¿˜æœ‰ä¸€äº›å…¶ä»–çš„è®¡åˆ’æ¥åŠ å¿«å®ƒçš„é€Ÿåº¦ã€‚ä½†ä¸æ­¤åŒæ—¶ï¼Œä»¥ä¸‹æ˜¯ä½ åº”è¯¥çŸ¥é“çš„:</p>
<ul>
<li><code>cargo build</code>ä¼šæ„å»ºä½ çš„ç¨‹åºï¼Œè¿™æ ·ä½ å°±å¯ä»¥è¿è¡Œå®ƒäº†ã€‚</li>
<li><code>cargo run</code>å°†å»ºç«‹ä½ çš„ç¨‹åºå¹¶è¿è¡Œå®ƒã€‚</li>
<li><code>cargo build --release</code>å’Œ<code>cargo run --release</code>å‘å¸ƒæ¨¡å¼ä¸‹æœ‰åŒæ ·çš„æ•ˆæœã€‚ä»€ä¹ˆæ˜¯å‘å¸ƒæ¨¡å¼ï¼Ÿå½“ä½ çš„ä»£ç æœ€ç»ˆå®Œæˆåå°±å¯ä»¥ç”¨å‘å¸ƒæ¨¡å¼äº†ã€‚Rustä¼šèŠ±æ›´å¤šçš„æ—¶é—´æ¥ç¼–è¯‘ï¼Œä½†å®ƒè¿™æ ·åšæ˜¯å› ä¸ºå®ƒä½¿ç”¨äº†å®ƒæ‰€çŸ¥é“çš„ä¸€åˆ‡ï¼Œæ¥ä½¿ç¼–è¯‘å‡ºçš„ç¨‹åºè¿è¡Œæ›´å¿«ã€‚Releaseæ¨¡å¼å®é™…ä¸Šæ¯”å¸¸è§„æ¨¡å¼<em>å¿«çš„å¤š</em>ï¼Œå¸¸è§„æ¨¡å¼è¢«ç§°ä¸ºdebugæ¨¡å¼ã€‚é‚£æ˜¯å› ä¸ºå®ƒçš„ç¼–è¯‘é€Ÿåº¦æ›´å¿«ï¼Œè€Œä¸”æœ‰æ›´å¤šçš„è°ƒè¯•ä¿¡æ¯ã€‚å¸¸è§„çš„<code>cargo build</code>å«åš "debug build"ï¼Œ<code>cargo build --release</code>å«åš "release build"ã€‚</li>
<li><code>cargo check</code>æ˜¯ä¸€ç§æ£€æŸ¥ä»£ç çš„æ–¹å¼ã€‚å®ƒå°±åƒç¼–è¯‘ä¸€æ ·ï¼Œåªä¸è¿‡å®ƒä¸ä¼šçœŸæ­£åœ°åˆ›å»ºä½ çš„ç¨‹åºã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ£€æŸ¥ä½ çš„ä»£ç çš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒä¸åƒ<code>build</code>æˆ–<code>run</code>é‚£æ ·éœ€è¦å¾ˆé•¿æ—¶é—´ã€‚</li>
</ul>
<p>å¯¹äº†ï¼Œå‘½ä»¤ä¸­çš„<code>--release</code>éƒ¨åˆ†å«åš<code>flag</code>ã€‚è¿™æ„å‘³ç€å‘½ä»¤ä¸­çš„é¢å¤–ä¿¡æ¯ã€‚</p>
<p>å…¶ä»–ä¸€äº›ä½ éœ€è¦çŸ¥é“çš„äº‹æƒ…æ˜¯:</p>
<ul>
<li><code>cargo new</code>. è¿™æ ·åšæ˜¯ä¸ºäº†åˆ›å»ºä¸€ä¸ªæ–°çš„Rusté¡¹ç›®ã€‚<code>new</code>ä¹‹åï¼Œå†™ä¸Šé¡¹ç›®çš„åç§°ï¼Œ<code>cargo</code>å°†ä¼šåˆ›å»ºæ‰€æœ‰ä½ éœ€è¦çš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ã€‚</li>
<li><code>cargo clean</code>. å½“ä½ æŠŠcrateæ·»åŠ åˆ°<code>Cargo.toml</code>æ—¶ï¼Œç”µè„‘ä¼šä¸‹è½½æ‰€æœ‰éœ€è¦çš„æ–‡ä»¶ï¼Œå®ƒä»¬ä¼šå ç”¨å¾ˆå¤šç©ºé—´ã€‚å¦‚æœä½ ä¸æƒ³å†è®©å®ƒä»¬åœ¨ä½ çš„ç”µè„‘ä¸Šï¼Œè¾“å…¥<code>cargo clean</code>ã€‚</li>
</ul>
<p>å…³äºç¼–è¯‘å™¨è¿˜æœ‰ä¸€ç‚¹:åªæœ‰å½“ä½ ç¬¬ä¸€æ¬¡ä½¿ç”¨<code>cargo build</code>æˆ–<code>cargo run</code>æ—¶ï¼Œå®ƒæ‰ä¼šèŠ±è´¹æœ€å¤šçš„æ—¶é—´ã€‚ä¹‹åå®ƒå°±ä¼šè®°ä½ï¼Œå®ƒåˆä¼šå¿«é€Ÿç¼–è¯‘ã€‚ä½†å¦‚æœä½ ä½¿ç”¨ <code>cargo clean</code>ï¼Œç„¶åè¿è¡Œ <code>cargo build</code>ï¼Œå®ƒå°†ä¸å¾—ä¸å†æ…¢æ…¢åœ°ç¼–è¯‘ä¸€æ¬¡ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ¥å—ç”¨æˆ·è¾“å…¥"><a class="header" href="#æ¥å—ç”¨æˆ·è¾“å…¥">æ¥å—ç”¨æˆ·è¾“å…¥</a></h2>
<p>ä¸€ä¸ªç®€å•çš„æ–¹æ³•æ˜¯ç”¨<code>std::io::stdin</code>æ¥æ¥å—ç”¨æˆ·çš„è¾“å…¥ã€‚è¿™æ„å‘³ç€ "æ ‡å‡†è¾“å…¥"ï¼Œä¹Ÿå°±æ˜¯æ¥è‡ªé”®ç›˜çš„è¾“å…¥ã€‚ç”¨<code>stdin()</code>å¯ä»¥è·å¾—ç”¨æˆ·çš„è¾“å…¥ï¼Œä½†æ˜¯æ¥ä¸‹æ¥ä½ å°±ä¼šæƒ³ç”¨<code>.read_line()</code>æŠŠå®ƒæ”¾åˆ°<code>&amp;mut String</code>ä¸­ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œä½†å®ƒæ—¢èƒ½å·¥ä½œï¼Œä¹Ÿä¸èƒ½å·¥ä½œ:</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    println!("Please type something, or x to escape:");
    let mut input_string = String::new();

    while input_string != "x" { // This is the part that doesn't work right
        input_string.clear(); // First clear the String. Otherwise it will keep adding to it
        io::stdin().read_line(&amp;mut input_string).unwrap(); // Get the stdin from the user, and put it in read_string
        println!("You wrote {}", input_string);
    }
    println!("See you later!");
}</code></pre></pre>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªè¾“å‡ºè¾“å‡ºçš„æ ·å­ã€‚</p>
<pre><code class="language-text">Please type something, or x to escape:
something
You wrote something

Something else
You wrote Something else

x
You wrote x

x
You wrote x

x
You wrote x
</code></pre>
<p>å®ƒæ¥å—æˆ‘ä»¬çš„è¾“å…¥ï¼Œç„¶åæŠŠå®ƒè¿˜ç»™æˆ‘ä»¬ï¼Œå®ƒç”šè‡³çŸ¥é“æˆ‘ä»¬è¾“å…¥äº†<code>x</code>ã€‚ä½†å®ƒå¹¶æ²¡æœ‰é€€å‡ºç¨‹åºã€‚å”¯ä¸€çš„åŠæ³•æ˜¯å…³é—­çª—å£ï¼Œæˆ–è€…è¾“å…¥ctrlå’Œcã€‚è®©æˆ‘ä»¬æŠŠ<code>println!</code>ä¸­çš„<code>{}</code>æ”¹ä¸º<code>{:?}</code>ï¼Œä»¥è·å¾—æ›´å¤šçš„ä¿¡æ¯(å¦‚æœä½ å–œæ¬¢é‚£ä¸ªå®ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨<code>dbg!(&amp;input_string)</code>)ã€‚ç°åœ¨å®ƒè¯´</p>
<pre><code class="language-text">Please type something, or x to escape:
something
You wrote "something\r\n"
Something else
You wrote "Something else\r\n"
x
You wrote "x\r\n"
x
You wrote "x\r\n"
</code></pre>
<p>è¿™æ˜¯å› ä¸ºé”®ç›˜è¾“å…¥å…¶å®ä¸åªæ˜¯<code>something</code>ï¼Œè€Œæ˜¯<code>something</code>å’Œ<code>Enter</code>é”®ã€‚æœ‰ä¸€ä¸ªç®€å•çš„æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå«åš<code>.trim()</code>ï¼Œå®ƒå¯ä»¥æŠŠæ‰€æœ‰çš„ç©ºç™½éƒ½å»æ‰ã€‚é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œ<a href="https://doc.rust-lang.org/reference/whitespace.html">è¿™äº›å­—ç¬¦</a>éƒ½æ˜¯ç©ºç™½å­—ç¬¦ã€‚</p>
<pre><code class="language-text">U+0009 (horizontal tab, '\t')
U+000A (line feed, '\n')
U+000B (vertical tab)
U+000C (form feed)
U+000D (carriage return, '\r')
U+0020 (space, ' ')
U+0085 (next line)
U+200E (left-to-right mark)
U+200F (right-to-left mark)
U+2028 (line separator)
U+2029 (paragraph separator)
</code></pre>
<p>è¿™æ ·å°±å¯ä»¥æŠŠ<code>x\r\n</code>å˜æˆåªå‰©<code>x</code>äº†ã€‚ç°åœ¨å®ƒå¯ä»¥å·¥ä½œäº†:</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    println!("Please type something, or x to escape:");
    let mut input_string = String::new();

    while input_string.trim() != "x" {
        input_string.clear();
        io::stdin().read_line(&amp;mut input_string).unwrap();
        println!("You wrote {}", input_string);
    }
    println!("See you later!");
}</code></pre></pre>
<p>ç°åœ¨å¯ä»¥æ‰“å°äº†:</p>
<pre><code class="language-text">Please type something, or x to escape:
something
You wrote something

Something
You wrote Something

x
You wrote x

See you later!
</code></pre>
<p>è¿˜æœ‰ä¸€ç§ç”¨æˆ·è¾“å…¥å«<code>std::env::Args</code>(envæ˜¯ç¯å¢ƒçš„æ„æ€)ã€‚<code>Args</code>æ˜¯ç”¨æˆ·å¯åŠ¨ç¨‹åºæ—¶è¾“å…¥çš„å†…å®¹ã€‚å…¶å®åœ¨ä¸€ä¸ªç¨‹åºä¸­æ€»æ˜¯è‡³å°‘æœ‰ä¸€ä¸ª<code>Arg</code>ã€‚æˆ‘ä»¬å†™ä¸€ä¸ªç¨‹åºï¼Œåªç”¨<code>std::env::args()</code>æ¥æ‰“å°å®ƒä»¬ï¼Œçœ‹çœ‹å®ƒä»¬æ˜¯ä»€ä¹ˆã€‚</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{:?}", std::env::args());
}</code></pre></pre>
<p>å¦‚æœæˆ‘ä»¬å†™<code>cargo run</code>ï¼Œé‚£ä¹ˆå®ƒçš„æ‰“å°ç»“æœæ˜¯è¿™æ ·çš„:</p>
<pre><code class="language-text">Args { inner: ["target\\debug\\rust_book.exe"] }
</code></pre>
<p>è®©æˆ‘ä»¬ç»™å®ƒæ›´å¤šçš„è¾“å…¥ï¼Œçœ‹çœ‹å®ƒçš„ä½œç”¨ã€‚æˆ‘ä»¬è¾“å…¥ <code>cargo run but with some extra words</code> ã€‚ å®ƒç»™æˆ‘ä»¬:</p>
<pre><code class="language-text">Args { inner: ["target\\debug\\rust_book.exe", "but", "with", "some", "extra", "words"] }
</code></pre>
<p>æœ‰æ„æ€ã€‚è€Œå½“æˆ‘ä»¬æŸ¥çœ‹<a href="https://doc.rust-lang.org/std/env/struct.Args.html">Argsçš„é¡µé¢</a>æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°å®ƒå®ç°äº†<code>IntoIterator</code>ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥.ç”¨æ‰€æœ‰æˆ‘ä»¬çŸ¥é“çš„å…³äºè¿­ä»£å™¨çš„æ–¹æ³•æ¥è¯»å–å’Œæ”¹å˜å®ƒã€‚è®©æˆ‘ä»¬è¯•è¯•è¿™ä¸ª:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

fn main() {
    let input = args();

    for entry in input {
        println!("You entered: {}", entry);
    }
}</code></pre></pre>
<p>ç°åœ¨å®ƒè¯´:</p>
<pre><code class="language-text">You entered: target\debug\rust_book.exe
You entered: but
You entered: with
You entered: some
You entered: extra
You entered: words
</code></pre>
<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯ç¨‹åºåï¼Œæ‰€ä»¥ä½ ç»å¸¸ä¼šæƒ³è·³è¿‡å®ƒï¼Œæ¯”å¦‚è¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

fn main() {
    let input = args();

    input.skip(1).for_each(|item| {
        println!("You wrote {}, which in capital letters is {}", item, item.to_uppercase());
    })
}</code></pre></pre>
<p>è¿™å°†æ‰“å°:</p>
<pre><code class="language-text">You wrote but, which in capital letters is BUT
You wrote with, which in capital letters is WITH
You wrote some, which in capital letters is SOME
You wrote extra, which in capital letters is EXTRA
You wrote words, which in capital letters is WORDS
</code></pre>
<p><code>Args</code>çš„ä¸€ä¸ªå¸¸è§ç”¨é€”æ˜¯ç”¨äºç”¨æˆ·è®¾ç½®ã€‚ä½ å¯ä»¥ç¡®ä¿ç”¨æˆ·å†™å‡ºä½ éœ€è¦çš„è¾“å…¥ï¼Œåªæœ‰åœ¨æ­£ç¡®çš„æƒ…å†µä¸‹æ‰è¿è¡Œç¨‹åºã€‚è¿™é‡Œæœ‰ä¸€ä¸ªå°ç¨‹åºï¼Œå¯ä»¥è®©å­—æ¯å˜å¤§(å¤§å†™)æˆ–å˜å°(å°å†™)ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::env::args;

enum Letters {
    Capitalize,
    Lowercase,
    Nothing,
}

fn main() {
    let mut changes = Letters::Nothing;
    let input = args().collect::&lt;Vec&lt;_&gt;&gt;();

    if input.len() &gt; 2 {
        match input[1].as_str() {
            "capital" =&gt; changes = Letters::Capitalize,
            "lowercase" =&gt; changes = Letters::Lowercase,
            _ =&gt; {}
        }
    }

    for word in input.iter().skip(2) {
      match changes {
        Letters::Capitalize =&gt; println!("{}", word.to_uppercase()),
        Letters::Lowercase =&gt; println!("{}", word.to_lowercase()),
        _ =&gt; println!("{}", word)
      }
    }

}</code></pre></pre>
<p>ä¸‹é¢æ˜¯å®ƒç»™å‡ºçš„ä¸€äº›ä¾‹å­ã€‚</p>
<p>è¾“å…¥: <code>cargo run please make capitals</code>:</p>
<pre><code class="language-text">make capitals
</code></pre>
<p>è¾“å…¥:<code>cargo run capital</code>:</p>
<pre><code class="language-text">// Nothing here...
</code></pre>
<p>è¾“å…¥:<code>cargo run capital I think I understand now</code>:</p>
<pre><code class="language-text">I
THINK
I
UNDERSTAND
NOW
</code></pre>
<p>è¾“å…¥:<code>cargo run lowercase Does this work too?</code></p>
<pre><code class="language-text">does
this
work
too?
</code></pre>
<p>é™¤äº†ç”¨æˆ·ç»™å‡ºçš„ <code>Args</code>ï¼Œåœ¨ <code>std::env::args()</code> ä¸­å¯ç”¨ï¼Œè¿˜æœ‰ç³»ç»Ÿå˜é‡<code>Vars</code>ã€‚è¿™äº›éƒ½æ˜¯ç”¨æˆ·æ²¡æœ‰è¾“å…¥çš„ç¨‹åºçš„åŸºæœ¬è®¾ç½®ã€‚ä½ å¯ä»¥ç”¨<code>std::env::vars()</code>æŠŠå®ƒä»¬éƒ½çœ‹æˆä¸€ä¸ª<code>(String, String)</code>ã€‚è¿™ä¸ªæœ‰éå¸¸å¤šï¼Œæ¯”å¦‚è¯´:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for item in std::env::vars() {
        println!("{:?}", item);
    }
}</code></pre></pre>
<p>è¿è¡Œè¿™æ®µä»£ç ï¼Œå°±èƒ½æ˜¾ç¤ºå‡ºä½ çš„ç”¨æˆ·ä¼šè¯çš„æ‰€æœ‰ä¿¡æ¯ã€‚å®ƒå°†æ˜¾ç¤ºè¿™æ ·çš„ä¿¡æ¯:</p>
<pre><code class="language-text">("CARGO", "/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo")
("CARGO_HOME", "/playground/.cargo")
("CARGO_MANIFEST_DIR", "/playground")
("CARGO_PKG_AUTHORS", "The Rust Playground")
("CARGO_PKG_DESCRIPTION", "")
("CARGO_PKG_HOMEPAGE", "")
("CARGO_PKG_NAME", "playground")
("CARGO_PKG_REPOSITORY", "")
("CARGO_PKG_VERSION", "0.0.1")
("CARGO_PKG_VERSION_MAJOR", "0")
("CARGO_PKG_VERSION_MINOR", "0")
("CARGO_PKG_VERSION_PATCH", "1")
("CARGO_PKG_VERSION_PRE", "")
("DEBIAN_FRONTEND", "noninteractive")
("HOME", "/playground")
("HOSTNAME", "f94c15b8134b")
("LD_LIBRARY_PATH", "/playground/target/debug/build/backtrace-sys-3ec4c973f371c302/out:/playground/target/debug/build/libsqlite3-sys-fbddfbb9b241dacb/out:/playground/target/debug/build/ring-cadba5e583648abb/out:/playground/target/debug/deps:/playground/target/debug:/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib:/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib")
("PATH", "/playground/.cargo/bin:/playground/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin")
("PLAYGROUND_EDITION", "2018")
("PLAYGROUND_TIMEOUT", "10")
("PWD", "/playground")
("RUSTUP_HOME", "/playground/.rustup")
("RUSTUP_TOOLCHAIN", "stable-x86_64-unknown-linux-gnu")
("RUST_RECURSION_COUNT", "1")
("SHLVL", "1")
("SSL_CERT_DIR", "/usr/lib/ssl/certs")
("SSL_CERT_FILE", "/usr/lib/ssl/certs/ca-certificates.crt")
("USER", "playground")
("_", "/usr/bin/timeout")
</code></pre>
<p>æ‰€ä»¥å¦‚æœä½ éœ€è¦è¿™äº›ä¿¡æ¯ï¼Œ<code>Vars</code>å°±æ˜¯ä½ æƒ³è¦çš„ã€‚</p>
<p>è·å¾—å•ä¸ª<code>Var'çš„æœ€ç®€å•æ–¹æ³•æ˜¯ä½¿ç”¨</code>env!<code>å®ã€‚ä½ åªè¦ç»™å®ƒå˜é‡çš„åå­—ï¼Œå®ƒå°±ä¼šç»™ä½ ä¸€ä¸ª</code>&amp;str'çš„å€¼ã€‚å¦‚æœå˜é‡æ‹¼å†™é”™è¯¯æˆ–ä¸å­˜åœ¨ï¼Œå®ƒå°±ä¸èµ·ä½œç”¨ï¼Œæ‰€ä»¥å¦‚æœä½ ä¸ç¡®å®šï¼Œå°±ç”¨<code>option_env!</code>ä»£æ›¿ã€‚å¦‚æœæˆ‘ä»¬åœ¨Playgroundä¸Šå†™è¿™ä¸ª:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("{}", env!("USER"));
    println!("{}", option_env!("ROOT").unwrap_or("Can't find ROOT"));
    println!("{}", option_env!("CARGO").unwrap_or("Can't find CARGO"));
}</code></pre></pre>
<p>ç„¶åæˆ‘ä»¬å¾—åˆ°è¾“å‡º:</p>
<pre><code class="language-text">playground
Can't find ROOT
/playground/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo
</code></pre>
<p>æ‰€ä»¥<code>option_env!</code>æ°¸è¿œæ˜¯æ¯”è¾ƒå®‰å…¨çš„å®ã€‚å¦‚æœä½ çœŸçš„æƒ³è®©ç¨‹åºåœ¨æ‰¾ä¸åˆ°ç¯å¢ƒå˜é‡æ—¶å´©æºƒï¼Œé‚£ä¹ˆ<code>env!</code>ä¼šæ›´å¥½ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ä½¿ç”¨æ–‡ä»¶"><a class="header" href="#ä½¿ç”¨æ–‡ä»¶">ä½¿ç”¨æ–‡ä»¶</a></h2>
<p>ç°åœ¨æˆ‘ä»¬åœ¨ç”µè„‘ä¸Šä½¿ç”¨Rustï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å¤„ç†æ–‡ä»¶äº†ã€‚ä½ ä¼šæ³¨æ„åˆ°ï¼Œç°åœ¨æˆ‘ä»¬ä¼šå¼€å§‹åœ¨ä»£ç ä¸­è¶Šæ¥è¶Šå¤šçš„çœ‹åˆ°<code>Result</code>ã€‚è¿™æ˜¯å› ä¸ºä¸€æ—¦ä½ å¼€å§‹å¤„ç†æ–‡ä»¶å’Œç±»ä¼¼çš„äº‹æƒ…ï¼Œå¾ˆå¤šäº‹æƒ…éƒ½ä¼šå‡ºé”™ã€‚ä¸€ä¸ªæ–‡ä»¶å¯èƒ½ä¸åœ¨é‚£é‡Œï¼Œæˆ–è€…è®¡ç®—æœºæ— æ³•è¯»å–å®ƒã€‚</p>
<p>ä½ å¯èƒ½è¿˜è®°å¾—ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨<code>?</code>è¿ç®—ç¬¦ï¼Œè°ƒç”¨å®ƒçš„å‡½æ•°å¿…é¡»è¿”å›ä¸€ä¸ª<code>Result</code>ã€‚å¦‚æœä½ è®°ä¸ä½é”™è¯¯ç±»å‹ï¼Œä½ å¯ä»¥ä»€ä¹ˆéƒ½ä¸ç»™å®ƒï¼Œè®©ç¼–è¯‘å™¨å‘Šè¯‰ä½ ã€‚è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªè¯•å›¾ç”¨<code>.parse()</code>åˆ›å»ºä¸€ä¸ªæ•°å­—çš„å‡½æ•°æ¥è¯•è¯•ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
fn give_number(input: &amp;str) -&gt; Result&lt;i32, ()&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!("{:?}", give_number("88"));
    println!("{:?}", give_number("5"));
}</code></pre></pre>
<p>ç¼–è¯‘å™¨å‘Šè¯‰æˆ‘ä»¬åˆ°åº•è¯¥æ€ä¹ˆåšã€‚</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src\main.rs:4:5
  |
3 | fn give_number(input: &amp;str) -&gt; Result&lt;i32, ()&gt; {
  |                                --------------- expected `std::result::Result&lt;i32, ()&gt;` because of return type
4 |     input.parse::&lt;i32&gt;()
  |     ^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `std::num::ParseIntError`
  |
  = note: expected enum `std::result::Result&lt;_, ()&gt;`
             found enum `std::result::Result&lt;_, std::num::ParseIntError&gt;`
</code></pre>
<p>å¾ˆå¥½! æ‰€ä»¥æˆ‘ä»¬åªè¦æŠŠè¿”å›å€¼æ”¹æˆç¼–è¯‘å™¨è¯´çš„å°±å¯ä»¥äº†:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!("{:?}", give_number("88"));
    println!("{:?}", give_number("5"));
}</code></pre></pre>
<p>ç°åœ¨ç¨‹åºå¯ä»¥è¿è¡Œäº†!</p>
<pre><code class="language-text">Ok(88)
Ok(5)
</code></pre>
<p>æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æƒ³ç”¨<code>?</code>ï¼Œå¦‚æœèƒ½ç”¨å°±ç›´æ¥ç»™æˆ‘ä»¬æ•°å€¼ï¼Œå¦‚æœä¸èƒ½ç”¨å°±ç»™é”™è¯¯ã€‚ä½†æ˜¯å¦‚ä½•åœ¨<code>fn main()</code>ä¸­åšåˆ°è¿™ä¸€ç‚¹å‘¢ï¼Ÿå¦‚æœæˆ‘ä»¬å°è¯•åœ¨mainä¸­ä½¿ç”¨<code>?</code>ï¼Œé‚£å°±ä¸è¡Œäº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!("{:?}", give_number("88")?);
    println!("{:?}", give_number("5")?);
}</code></pre></pre>
<p>å®ƒè¯´:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
  --&gt; src\main.rs:8:22
   |
7  | / fn main() {
8  | |     println!("{:?}", give_number("88")?);
   | |                      ^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
9  | |     println!("{:?}", give_number("5")?);
10 | | }
   | |_- this function should return `Result` or `Option` to accept `?`
</code></pre>
<p>ä½†å®é™…ä¸Š<code>main()</code>å¯ä»¥è¿”å›ä¸€ä¸ª<code>Result</code>ï¼Œå°±åƒå…¶ä»–å‡½æ•°ä¸€æ ·ã€‚å¦‚æœæˆ‘ä»¬çš„å‡½æ•°èƒ½å·¥ä½œï¼Œæˆ‘ä»¬ä¸æƒ³è¿”å›ä»»ä½•ä¸œè¥¿(main()å¹¶æ²¡æœ‰ç»™å…¶ä»–ä»»ä½•ä¸œè¥¿)ã€‚è€Œå¦‚æœå®ƒä¸å·¥ä½œï¼Œæˆ‘ä»¬å°†é”™è¯¯è¿”å›ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    println!("{:?}", give_number("88")?);
    println!("{:?}", give_number("5")?);
    Ok(())
}</code></pre></pre>
<p>ä¸è¦å¿˜äº†æœ€åçš„<code>Ok(())</code>:è¿™åœ¨Rustä¸­æ˜¯å¾ˆå¸¸è§çš„ï¼Œå®ƒçš„æ„æ€æ˜¯<code>Ok</code>ï¼Œé‡Œé¢æ˜¯<code>()</code>ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„è¿”å›å€¼ã€‚ç°åœ¨å®ƒæ‰“å°å‡ºæ¥äº†:</p>
<pre><code class="language-text">88
5
</code></pre>
<p>åªç”¨<code>.parse()</code>çš„æ—¶å€™ä¸æ˜¯å¾ˆæœ‰ç”¨ï¼Œä½†æ˜¯ç”¨æ–‡ä»¶å°±å¾ˆæœ‰ç”¨ã€‚è¿™æ˜¯å› ä¸º<code>?</code>ä¹Ÿä¸ºæˆ‘ä»¬æ”¹å˜äº†é”™è¯¯ç±»å‹ã€‚ä¸‹é¢æ˜¯ç”¨ç®€å•è‹±è¯­å†™çš„<a href="https://doc.rust-lang.org/std/macro.try.html">?è¿ç®—ç¬¦é¡µé¢</a>:</p>
<pre><code class="language-text">If you get an `Err`, it will get the inner error. Then `?` does a conversion using `From`. With that it can change specialized errors to more general ones. The error it gets is then returned.
</code></pre>
<p>å¦å¤–ï¼ŒRuståœ¨ä½¿ç”¨<code>File</code>så’Œç±»ä¼¼çš„ä¸œè¥¿æ—¶ï¼Œæœ‰ä¸€ä¸ªæ–¹ä¾¿çš„<code>Result</code>ç±»å‹ã€‚å®ƒå«åš<code>std::io::Result</code>ï¼Œå½“ä½ åœ¨ä½¿ç”¨<code>?</code>å¯¹æ–‡ä»¶è¿›è¡Œæ‰“å¼€å’Œæ“ä½œæ—¶ï¼Œé€šå¸¸åœ¨<code>main()</code>ä¸­çœ‹åˆ°çš„å°±æ˜¯è¿™ä¸ªã€‚è¿™å…¶å®æ˜¯ä¸€ä¸ªç±»å‹åˆ«åã€‚å®ƒçš„æ ·å­æ˜¯è¿™æ ·çš„:</p>
<pre><code class="language-text">type Result&lt;T&gt; = Result&lt;T, Error&gt;;
</code></pre>
<p>æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ª<code>Result&lt;T, Error&gt;</code>ï¼Œä½†æˆ‘ä»¬åªéœ€è¦å†™å‡º<code>Result&lt;T&gt;</code>éƒ¨åˆ†ã€‚</p>
<p>ç°åœ¨è®©æˆ‘ä»¬ç¬¬ä¸€æ¬¡å°è¯•ä½¿ç”¨æ–‡ä»¶ã€‚<code>std::fs</code>æ˜¯å¤„ç†æ–‡ä»¶çš„æ–¹æ³•æ‰€åœ¨ï¼Œæœ‰äº†<code>std::io::Write</code>ï¼Œä½ å°±å¯ä»¥å†™ã€‚æœ‰äº†å®ƒï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨<code>.write_all()</code>æ¥å†™è¿›æ–‡ä»¶ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut file = fs::File::create("myfilename.txt")?; // Create a file with this name.
                                                        // CAREFUL! If you have a file with this name already,
                                                        // it will delete everything in it.
    file.write_all(b"Let's put this in the file")?;     // Don't forget the b in front of ". That's because files take bytes.
    Ok(())
}</code></pre></pre>
<p>ç„¶åå¦‚æœä½ æ‰“å¼€æ–°æ–‡ä»¶<code>myfilename.txt</code>ï¼Œä¼šçœ‹åˆ°å†…å®¹<code>Let's put this in the file</code>ã€‚</p>
<p>ä¸è¿‡æˆ‘ä»¬ä¸éœ€è¦å†™ä¸¤è¡Œï¼Œå› ä¸ºæˆ‘ä»¬æœ‰<code>?</code>æ“ä½œç¬¦ã€‚å¦‚æœæœ‰æ•ˆï¼Œå®ƒå°±ä¼šä¼ é€’æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼Œæœ‰ç‚¹åƒåœ¨è¿­ä»£å™¨ä¸Šå¾ˆå¤šæ–¹æ³•ä¸€æ ·ã€‚è¿™æ—¶å€™<code>?</code>å°±å˜å¾—éå¸¸æ–¹ä¾¿äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::File::create("myfilename.txt")?.write_all(b"Let's put this in the file")?;
    Ok(())
}</code></pre></pre>
<p>æ‰€ä»¥è¿™æ˜¯è¯´ "è¯·å°è¯•åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œç„¶åæ£€æŸ¥æ˜¯å¦æˆåŠŸã€‚å¦‚æœæˆåŠŸäº†ï¼Œé‚£å°±ä½¿ç”¨<code>.write_all()</code>ï¼Œç„¶åæ£€æŸ¥æ˜¯å¦æˆåŠŸã€‚"</p>
<p>è€Œäº‹å®ä¸Šï¼Œä¹Ÿæœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥åŒæ—¶åšè¿™ä¸¤ä»¶äº‹ã€‚å®ƒå«åš<code>std::fs::write</code>ã€‚åœ¨å®ƒé‡Œé¢ï¼Œä½ ç»™å®ƒä½ æƒ³è¦çš„æ–‡ä»¶åï¼Œä»¥åŠä½ æƒ³æ”¾åœ¨é‡Œé¢çš„å†…å®¹ã€‚å†æ¬¡å¼ºè°ƒï¼Œè¦å°å¿ƒ! å¦‚æœè¯¥æ–‡ä»¶å·²ç»å­˜åœ¨ï¼Œå®ƒå°†åˆ é™¤å…¶ä¸­çš„æ‰€æœ‰å†…å®¹ã€‚å¦å¤–ï¼Œå®ƒå…è®¸ä½ å†™ä¸€ä¸ª<code>&amp;str</code>ï¼Œå‰é¢ä¸å†™<code>b</code>ï¼Œå› ä¸ºè¿™ä¸ª:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write&lt;P: AsRef&lt;Path&gt;, C: AsRef&lt;[u8]&gt;&gt;(path: P, contents: C) -&gt; Result&lt;()&gt;
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>å°±æ˜¯ä¸ºä»€ä¹ˆä½ å¯ä»¥ç»™å®ƒä»»ä½•ä¸€ä¸ªã€‚</p>
<p>å¾ˆç®€å•çš„:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::write("calvin_with_dad.txt", 
"Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...")?;

    Ok(())
}</code></pre></pre>
<p>æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬è¦ç”¨çš„æ–‡ä»¶ã€‚è¿™æ˜¯ä¸€ä¸ªåå«Calvinçš„æ¼«ç”»äººç‰©å’Œä»–çˆ¸çˆ¸çš„å¯¹è¯ï¼Œä»–çˆ¸çˆ¸å¯¹ä»–çš„é—®é¢˜å¹¶ä¸è®¤çœŸã€‚æœ‰äº†è¿™ä¸ªï¼Œæ¯æ¬¡æˆ‘ä»¬éƒ½å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–‡ä»¶æ¥ä½¿ç”¨ã€‚</p>
<p>æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶å’Œåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ä¸€æ ·ç®€å•ã€‚ä½ åªè¦ç”¨<code>open()</code>ä»£æ›¿<code>create()</code>å°±å¯ä»¥äº†ã€‚ä¹‹å(å¦‚æœå®ƒæ‰¾åˆ°äº†ä½ çš„æ–‡ä»¶)ï¼Œä½ å°±å¯ä»¥åš<code>read_to_string()</code>è¿™æ ·çš„äº‹æƒ…ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªå¯å˜çš„ <code>String</code>ï¼Œç„¶åæŠŠæ–‡ä»¶è¯»åˆ°é‚£é‡Œã€‚å®ƒçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::fs::File;
use std::io::Read; // this is to use the function .read_to_string()

fn main() -&gt; std::io::Result&lt;()&gt; {
     fs::write("calvin_with_dad.txt", 
"Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...")?;


    let mut calvin_file = File::open("calvin_with_dad.txt")?; // Open the file we just made
    let mut calvin_string = String::new(); // This String will hold it
    calvin_file.read_to_string(&amp;mut calvin_string)?; // Read the file into it

    calvin_string.split_whitespace().for_each(|word| print!("{} ", word.to_uppercase())); // Do things with the String now

    Ok(())
}</code></pre></pre>
<p>ä¼šæ‰“å°:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CALVIN: DAD, HOW COME OLD PHOTOGRAPHS ARE ALWAYS BLACK AND WHITE? DIDN'T THEY HAVE COLOR FILM BACK THEN? DAD: SURE THEY DID. IN 
FACT, THOSE PHOTOGRAPHS *ARE* IN COLOR. IT'S JUST THE *WORLD* WAS BLACK AND WHITE THEN. CALVIN: REALLY? DAD: YEP. THE WORLD DIDN'T TURN COLOR UNTIL SOMETIMES IN THE 1930S...
<span class="boring">}</span></code></pre></pre>
<p>å¥½å§ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œä½†å¦‚æœå·²ç»æœ‰å¦ä¸€ä¸ªåŒåçš„æ–‡ä»¶å°±ä¸åšäº†æ€ä¹ˆåŠï¼Ÿä¹Ÿè®¸ä½ ä¸æƒ³ä¸ºäº†åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶è€Œåˆ é™¤å·²ç»å­˜åœ¨çš„å…¶ä»–æ–‡ä»¶ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæœ‰ä¸€ä¸ªç»“æ„å«<code>OpenOptions</code>ã€‚å…¶å®ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ç”¨<code>OpenOptions</code>ï¼Œå´ä¸çŸ¥é“ã€‚çœ‹çœ‹<code>File::open</code>çš„æºç å§ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        OpenOptions::new().read(true).open(path.as_ref())
    }
<span class="boring">}</span></code></pre></pre>
<p>æœ‰æ„æ€ï¼Œè¿™å¥½åƒæ˜¯æˆ‘ä»¬å­¦è¿‡çš„å»ºé€ è€…æ¨¡å¼ã€‚<code>File::create</code>ä¹Ÿæ˜¯å¦‚æ­¤ã€‚</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())
    }
<span class="boring">}</span></code></pre></pre>
<p>å¦‚æœä½ å»<a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html">OpenOptionsçš„é¡µé¢</a>ï¼Œä½ å¯ä»¥çœ‹åˆ°æ‰€æœ‰å¯ä»¥é€‰æ‹©çš„æ–¹æ³•ã€‚å¤§å¤šæ•°é‡‡å–<code>bool</code>ã€‚</p>
<ul>
<li><code>append()</code>: æ„æ€æ˜¯ "æ·»åŠ åˆ°å·²ç»å­˜åœ¨çš„å†…å®¹ä¸­ï¼Œè€Œä¸æ˜¯åˆ é™¤"ã€‚</li>
<li><code>create()</code>: è¿™è®© <code>OpenOptions</code> åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ã€‚</li>
<li><code>create_new()</code>: æ„æ€æ˜¯åªæœ‰åœ¨æ–‡ä»¶ä¸å­˜åœ¨çš„æƒ…å†µä¸‹æ‰ä¼šåˆ›å»ºæ–‡ä»¶ã€‚</li>
<li><code>read()</code>: å¦‚æœä½ æƒ³è®©å®ƒè¯»å–æ–‡ä»¶ï¼Œå°±æŠŠè¿™ä¸ªè®¾ç½®ä¸º <code>true</code>ã€‚</li>
<li><code>truncate()</code>: å¦‚æœä½ æƒ³åœ¨æ‰“å¼€æ–‡ä»¶æ—¶æŠŠæ–‡ä»¶å†…å®¹å‰ªä¸º0(åˆ é™¤å†…å®¹)ï¼Œå°±æŠŠè¿™ä¸ªè®¾ç½®ä¸ºtrueã€‚</li>
<li><code>write()</code>: è¿™å¯ä»¥è®©å®ƒå†™å…¥ä¸€ä¸ªæ–‡ä»¶ã€‚</li>
</ul>
<p>ç„¶ååœ¨æœ€åä½ ç”¨<code>.open()</code>åŠ ä¸Šæ–‡ä»¶åï¼Œå°±ä¼šå¾—åˆ°ä¸€ä¸ª<code>Result</code>ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ã€‚</p>
<pre><pre class="playground"><code class="language-rust">// âš ï¸
use std::fs;
use std::fs::OpenOptions;

fn main() -&gt; std::io::Result&lt;()&gt; {
     fs::write("calvin_with_dad.txt", 
"Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...")?;

    let calvin_file = OpenOptions::new().write(true).create_new(true).open("calvin_with_dad.txt")?;

    Ok(())
}</code></pre></pre>
<p>é¦–å…ˆæˆ‘ä»¬ç”¨<code>new</code>åšäº†ä¸€ä¸ª<code>OpenOptions</code>(æ€»æ˜¯ä»¥<code>new</code>å¼€å¤´)ã€‚ç„¶åæˆ‘ä»¬ç»™å®ƒçš„èƒ½åŠ›æ˜¯<code>write</code>ã€‚ä¹‹åæˆ‘ä»¬æŠŠ<code>create_new()</code>è®¾ç½®ä¸º<code>true</code>ï¼Œç„¶åè¯•ç€æ‰“å¼€æˆ‘ä»¬åšçš„æ–‡ä»¶ã€‚æ‰“ä¸å¼€ï¼Œè¿™æ˜¯æˆ‘ä»¬æƒ³è¦çš„ã€‚</p>
<pre><code class="language-text">Error: Os { code: 80, kind: AlreadyExists, message: "The file exists." }
</code></pre>
<p>è®©æˆ‘ä»¬å°è¯•ä½¿ç”¨<code>.append()</code>ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å‘ä¸€ä¸ªæ–‡ä»¶å†™å…¥ã€‚ä¸ºäº†å†™å…¥æ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>.write_all()</code>ï¼Œè¿™æ˜¯ä¸€ä¸ªå°è¯•å†™å…¥ä½ ç»™å®ƒçš„ä¸€åˆ‡å†…å®¹çš„æ–¹æ³•ã€‚</p>
<p>å¦å¤–ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ <code>write!</code> å®æ¥åšåŒæ ·çš„äº‹æƒ…ã€‚ä½ ä¼šè®°å¾—è¿™ä¸ªå®ï¼Œæˆ‘ä»¬åœ¨ä¸ºç»“æ„ä½“åš<code>impl Display</code>çš„æ—¶å€™ç”¨åˆ°è¿‡ã€‚è¿™æ¬¡æˆ‘ä»¬æ˜¯åœ¨æ–‡ä»¶ä¸Šä½¿ç”¨å®ƒï¼Œè€Œä¸æ˜¯åœ¨ç¼“å†²åŒºä¸Šã€‚</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::fs::OpenOptions;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::write("calvin_with_dad.txt", 
"Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...")?;

    let mut calvin_file = OpenOptions::new()
        .append(true) // Now we can write without deleting it
        .read(true)
        .open("calvin_with_dad.txt")?;
    calvin_file.write_all(b"And it was a pretty grainy color for a while too.\n")?;
    write!(&amp;mut calvin_file, "That's really weird.\n")?;
    write!(&amp;mut calvin_file, "Well, truth is stranger than fiction.")?;

    println!("{}", fs::read_to_string("calvin_with_dad.txt")?);

    Ok(())
}</code></pre></pre>
<p>è¿™ä¸ªæ‰“å°:</p>
<pre><code class="language-text">Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...And it was a pretty grainy color for a while too.
That's really weird.
Well, truth is stranger than fiction.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargoæ–‡æ¡£"><a class="header" href="#cargoæ–‡æ¡£">cargoæ–‡æ¡£</a></h2>
<p>ä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼ŒRustæ–‡æ¡£çœ‹èµ·æ¥æ€»æ˜¯å‡ ä¹ä¸€æ ·ã€‚åœ¨å·¦è¾¹ä½ å¯ä»¥çœ‹åˆ°<code>struct</code>å’Œ<code>trait</code>ï¼Œä»£ç ä¾‹å­åœ¨å³è¾¹ç­‰ç­‰ã€‚è¿™æ˜¯å› ä¸ºä½ åªè¦è¾“å…¥<code>cargo doc</code>å°±å¯ä»¥è‡ªåŠ¨åˆ›å»ºæ–‡æ¡£ã€‚</p>
<p>å³ä½¿æ˜¯åˆ›å»ºä¸€ä¸ªä»€ä¹ˆéƒ½ä¸åšçš„é¡¹ç›®ï¼Œä¹Ÿå¯ä»¥å¸®åŠ©ä½ äº†è§£Rustä¸­çš„ç‰¹æ€§ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªå‡ ä¹ä»€ä¹ˆéƒ½ä¸åšçš„ç»“æ„ä½“ï¼Œä»¥åŠä¸€ä¸ªä¹Ÿä»€ä¹ˆéƒ½ä¸åšçš„<code>fn main()</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust">struct DoesNothing {}
struct PrintThing {}

impl PrintThing {
    fn prints_something() {
        println!("I am printing something");
    }
}

fn main() {}</code></pre></pre>
<p>ä½†å¦‚æœä½ è¾“å…¥<code>cargo doc --open</code>ï¼Œä½ å¯ä»¥çœ‹åˆ°æ¯”ä½ æƒ³è±¡ä¸­æ›´å¤šçš„ä¿¡æ¯ã€‚é¦–å…ˆå®ƒç»™ä½ æ˜¾ç¤ºçš„æ˜¯è¿™æ ·çš„:</p>
<pre><code class="language-text">Crate rust_book

Structs
DoesNothing
PrintThing

Functions
main
</code></pre>
<p>ä½†æ˜¯å¦‚æœä½ ç‚¹å‡»å…¶ä¸­çš„ä¸€ä¸ªç»“æ„ï¼Œä¼šè®©ä½ çœ‹åˆ°å¾ˆå¤šä½ æ²¡æœ‰æƒ³åˆ°çš„traitã€‚</p>
<pre><code class="language-text">Struct rust_book::DoesNothing
[+] Show declaration
Auto Trait Implementations
impl RefUnwindSafe for DoesNothing
impl Send for DoesNothing
impl Sync for DoesNothing
impl Unpin for DoesNothing
impl UnwindSafe for DoesNothing
Blanket Implementations
impl&lt;T&gt; Any for T
where
    T: 'static + ?Sized,
[src]
[+]
impl&lt;T&gt; Borrow&lt;T&gt; for T
where
    T: ?Sized,
[src]
[+]
impl&lt;T&gt; BorrowMut&lt;T&gt; for T
where
    T: ?Sized,
[src]
[+]
impl&lt;T&gt; From&lt;T&gt; for T
[src]
[+]
impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
[src]
[+]
impl&lt;T, U&gt; TryFrom&lt;U&gt; for T
where
    U: Into&lt;T&gt;,
[src]
[+]
impl&lt;T, U&gt; TryInto&lt;U&gt; for T
where
    U: TryFrom&lt;T&gt;,
</code></pre>
<p>è¿™æ˜¯å› ä¸ºRustè‡ªåŠ¨ä¸ºæ¯ä¸ªç±»å‹å®ç°çš„æ‰€æœ‰traitã€‚</p>
<p>é‚£ä¹ˆå¦‚æœæˆ‘ä»¬æ·»åŠ ä¸€äº›æ–‡æ¡£æ³¨é‡Šï¼Œå½“ä½ è¾“å…¥<code>cargo doc</code>çš„æ—¶å€™å°±å¯ä»¥çœ‹åˆ°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">/// This is a struct that does nothing
struct DoesNothing {}
/// This struct only has one method.
struct PrintThing {}
/// It just prints the same message.
impl PrintThing {
    fn prints_something() {
        println!("I am printing something");
    }
}

fn main() {}</code></pre></pre>
<p>ç°åœ¨ä¼šæ‰“å°:</p>
<pre><code class="language-text">Crate rust_book
Structs
DoesNothing This is a struct that does nothing
PrintThing  This struct only has one method.
Functions
main
</code></pre>
<p>å½“ä½ ä½¿ç”¨å¾ˆå¤šåˆ«äººçš„crateæ—¶ï¼Œ<code>cargo doc</code>æ˜¯éå¸¸å¥½çš„ã€‚å› ä¸ºè¿™äº›crateéƒ½åœ¨ä¸åŒçš„ç½‘ç«™ä¸Šï¼Œå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´æ¥æœç´¢æ‰€æœ‰çš„crateã€‚ä½†å¦‚æœä½ ä½¿ç”¨<code>cargo doc</code>ï¼Œä½ å°±ä¼šæŠŠå®ƒä»¬éƒ½æ”¾åœ¨ä½ ç¡¬ç›˜çš„åŒä¸€ä¸ªåœ°æ–¹ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç»“æŸäº†å—"><a class="header" href="#ç»“æŸäº†å—">ç»“æŸäº†å—ï¼Ÿ</a></h2>
<p>ç®€å•è‹±è¯­å­¦Rustå°±è¿™æ ·ç»“æŸäº†ã€‚ä½†æ˜¯æˆ‘è¿˜åœ¨è¿™é‡Œï¼Œå¦‚æœä½ æœ‰ä»€ä¹ˆé—®é¢˜å¯ä»¥å‘Šè¯‰æˆ‘ã€‚æ¬¢è¿<a href="https://twitter.com/mithridates">åœ¨Twitterä¸Šè”ç³»æˆ‘</a>æˆ–è€…æ·»åŠ ä¸€ä¸ªpull requestã€issueç­‰ã€‚å¦‚æœæœ‰äº›åœ°æ–¹ä¸å®¹æ˜“ç†è§£ï¼Œä½ ä¹Ÿå¯ä»¥å‘Šè¯‰æˆ‘ã€‚ç®€å•è‹±è¯­å­¦Rustéœ€è¦éå¸¸å®¹æ˜“ç†è§£ï¼Œæ‰€ä»¥è¯·å‘Šè¯‰æˆ‘è‹±è¯­å¤ªéš¾çš„åœ°æ–¹ã€‚å½“ç„¶ï¼ŒRustæœ¬èº«ä¹Ÿå¯èƒ½æ˜¯å¾ˆéš¾ç†è§£çš„ï¼Œä½†æˆ‘ä»¬è‡³å°‘å¯ä»¥ç¡®ä¿è‹±è¯­æ˜¯å®¹æ˜“çš„ã€‚</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
