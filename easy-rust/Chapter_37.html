<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> 闭包 - 简单英语学Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong>  更新</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong>  介绍</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong>  我是谁？</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong>  简单英语学Rust</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong>  Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong>  🚧和⚠️</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong>  注释</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong>  类型</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong>  类型推导</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong>  打印hello, world!</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong>  显示和调试</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong>  可变性</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong>  栈、堆和指针</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong>  关于打印的更多信息</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong>  字符串</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong>  const和static</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong>  关于引用的更多信息</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong>  可变引用</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong>  函数的引用</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong>  拷贝类型</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong>  集合类型</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong>  向量</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong>  元组</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong>  控制流</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong>  结构体</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong>  枚举</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong>  循环</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong>  实现结构体和枚举</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong>  解构</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong>  引用和点运算符</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong>  泛型</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong>  Option和Result</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong>  其他集合类型</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong>  ?操作符</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong>  特性</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong>  链式方法</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong>  迭代器</a></li><li class="chapter-item expanded "><a href="Chapter_37.html" class="active"><strong aria-hidden="true">38.</strong>  闭包</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong>  dbg! 宏和.inspect</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong>  &str的类型</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong>  生命期</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong>  内部可变性</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong>  Cow</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong>  类型别名</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong>  todo!宏</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong>  Rc</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong>  多线程</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong>  函数中的闭包</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong>  impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong>  Arc</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong>  Channels</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong>  阅读Rust文档</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong>  属性</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong>  Box</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong>  用Box包裹trait</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong>  默认值和建造者模式</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong>  Deref和DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong>  Crate和模块</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong>  测试</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong>  外部crate</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong>  标准库之旅</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong>  编写宏</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong>  cargo</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong>  接受用户输入</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong>  使用文件</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong>  cargo文档</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong>  结束了吗？</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">简单英语学Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<p>闭包就像快速函数，不需要名字。有时它们被称为lambda。Closures很容易辨识，因为它们使用<code>||</code>而不是<code>()</code>。它们在 Rust 中非常常见，一旦你学会了使用它们，你就会爱不释手。</p>
<p>你可以将一个闭包绑定到一个变量上，然后当你使用它时，它看起来就像一个函数一样。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || println!("This is a closure");
    my_closure();
}</code></pre></pre>
<p>所以这个闭包什么都不需要:<code>||</code>，并打印一条信息。<code>This is a closure</code>.</p>
<p>在<code>||</code>之间我们可以添加输入变量和类型，就像在<code>()</code>里面添加函数一样。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = |x: i32| println!("{}", x);

    my_closure(5);
    my_closure(5+5);
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">5
10
</code></pre>
<p>当闭包变得更复杂时，你可以添加一个代码块。那就可以随心所欲的长。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || {
        let number = 7;
        let other_number = 10;
        println!("The two numbers are {} and {}.", number, other_number);
          // This closure can be as long as we want, just like a function.
    };

    my_closure();
}</code></pre></pre>
<p>但是闭包是特殊的，因为它可以接受闭包之外的变量，即使你只写<code>||</code>。所以你可以这样做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = || println!("{}", number_one + number_two);
    my_closure();
}</code></pre></pre>
<p>所以这就打印出了<code>16</code>。你不需要在 <code>||</code> 中放入任何东西，因为它可以直接取 <code>number_one</code> 和 <code>number_two</code> 并添加它们。</p>
<p>顺便说一下，这就是<strong>closure</strong>这个名字的由来，因为它们会取变量并将它们 "包围"在里面。如果你想很正确的说。</p>
<ul>
<li>一个<code>||</code>如果不把变量从外面包围起来 那就是一个 "匿名函数". 匿名的意思是 "没有名字"。它的工作原理更像一个普通函数。</li>
<li><code>||</code> 从外部包围变量的函数是 "closure"。它把周围的变量 "封闭"起来使用。</li>
</ul>
<p>但是人们经常会把所有的<code>||</code>函数都叫做闭包，所以你不用担心名字的问题。我们只对任何带有<code>||</code>的函数说 "closure"，但请记住，它可能意味着一个 "匿名函数"。</p>
<p>为什么要知道这两者的区别呢？因为匿名函数其实和有名字的函数做的机器代码是一样的。它们给人的感觉是 "高层抽象"，所以有时候大家会觉得机器代码会很复杂。但是Rust用它生成的机器码和普通函数一样快。</p>
<p>所以我们再来看看闭包能做的一些事情。你也可以这样做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = |x: i32| println!("{}", number_one + number_two + x);
    my_closure(5);
}</code></pre></pre>
<p>这个闭包取<code>number_one</code>和<code>number_two</code>。我们还给了它一个新的变量 <code>x</code>，并说 <code>x</code> 是 5.然后它把这三个加在一起打印 <code>21</code>。</p>
<p>通常在Rust中，你会在一个方法里面看到闭包，因为里面有一个闭包是非常方便的。我们在上一节的 <code>.map()</code> 和 <code>.for_each()</code> 中看到了闭包。在那一节中，我们写了 <code>|x|</code> 来引入迭代器中的下一个元素，这就是一个闭包。</p>
<p>下面再举一个例子:我们知道，如果<code>unwrap</code>不起作用，可以用<code>unwrap_or</code>方法给出一个值。之前我们写的是:<code>let fourth = my_vec.get(3).unwrap_or(&amp;0);</code>。但是还有一个<code>unwrap_or_else</code>方法，里面有一个闭包。所以你可以这样做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or_else(|| { // try to unwrap. If it doesn't work,
        if my_vec.get(0).is_some() {               // see if my_vec has something at index [0]
            &amp;my_vec[0]                             // Give the number at index 0 if there is something
        } else {
            &amp;0 // otherwise give a &amp;0
        }
    });

    println!("{}", fourth);
}</code></pre></pre>
<p>当然，闭包也可以很简单。例如，你可以只写<code>let fourth = my_vec.get(3).unwrap_or_else(|| &amp;0);</code>。你不需要总是因为有一个闭包就使用<code>{}</code>并写出复杂的代码。只要你把<code>||</code>放进去，编译器就知道你放了你需要的闭包。</p>
<p>最常用的闭包方法可能是<code>.map()</code>。我们再来看看它。下面是一种使用方法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec        // take num_vec
        .iter()                     // iterate over it
        .map(|number| number * 2)   // for each item, multiply by two
        .collect::&lt;Vec&lt;i32&gt;&gt;();     // then make a new Vec from this
    println!("{:?}", double_vec);
}</code></pre></pre>
<p>另一个很好的例子是在<code>.enumerate()</code>之后使用<code>.for_each()</code>。<code>.enumerate()</code>方法给出一个带有索引号和元素的迭代器。例如:<code>[10, 9, 8]</code>变成<code>(0, 10), (1, 9), (2, 8)</code>。这里每个项的类型是<code>(usize, i32)</code>。所以你可以这样做:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()      // iterate over num_vec
        .enumerate() // get (index, number)
        .for_each(|(index, number)| println!("Index number {} has number {}", index, number)); // do something for each one
}</code></pre></pre>
<p>这个将打印:</p>
<pre><code class="language-text">Index number 0 has number 10
Index number 1 has number 9
Index number 2 has number 8
</code></pre>
<p>在这种情况下，我们用<code>for_each</code>代替<code>map</code>。<code>map</code>是用于对<strong>每个元素做一些事情，并将其传递出去，而<code>for_each</code>是当你看到每个元素</strong>时做一些事情。另外，<code>map</code>不做任何事情，除非你使用<code>collect</code>这样的方法。</p>
<p>其实，这就是迭代器的有趣之处。如果你尝试<code>map</code>而不使用<code>collect</code>这样的方法，编译器会告诉你，它什么也不做。它不会崩溃，但编译器会告诉你，你什么都没做。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()
        .enumerate()
        .map(|(index, number)| println!("Index number {} has number {}", index, number));

}</code></pre></pre>
<p>它说:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` that must be used
 --&gt; src\main.rs:4:5
  |
4 | /     num_vec
5 | |         .iter()
6 | |         .enumerate()
7 | |         .map(|(index, number)| println!("Index number {} has number {}", index, number));
  | |_________________________________________________________________________________________^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
</code></pre>
<p>这是一个<strong>警告</strong>，所以这不是一个错误:程序运行正常。但是为什么num_vec没有任何作用呢？我们可以看看类型就知道了。</p>
<ul>
<li>
<p><code>let num_vec = vec![10, 9, 8];</code> 现在是一个<code>Vec&lt;i32&gt;</code>。</p>
</li>
<li>
<p><code>.iter()</code> 现在是一个 <code>Iter&lt;i32&gt;</code>。所以它是一个迭代器，其元素为 <code>i32</code>。</p>
</li>
<li>
<p><code>.enumerate()</code>现在是一个<code>Enumerate&lt;Iter&lt;i32&gt;&gt;</code>型。所以它是<code>Enumerate</code>型的<code>Iter</code>型的<code>i32</code>。</p>
</li>
<li>
<p><code>.map()</code>现在是一个<code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>的类型。所以它是一个类型<code>Map</code>的类型<code>Enumerate</code>的类型<code>Iter</code>的类型<code>i32</code>。</p>
</li>
</ul>
<p>我们所做的只是做了一个越来越复杂的结构。所以这个<code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>是一个准备好了的结构，但只有当我们告诉它要做什么的时候，它才会去做。Rust这样做是因为它需要保证足够快。它不想这样做:</p>
<ul>
<li>遍历Vec中所有的<code>i32</code></li>
<li>然后从迭代器中枚举出所有的<code>i32</code></li>
<li>然后将所有列举的<code>i32</code>映射过来</li>
</ul>
<p>Rust 只想做一次计算，所以它创建结构并等待。然后，如果我们说<code>.collect::&lt;Vec&lt;i32&gt;&gt;()</code>，它知道该怎么做，并开始移动。这就是<code>iterators are lazy and do nothing unless consumed</code>的意思。迭代器在你 "消耗"它们(用完它们)之前不会做任何事情。</p>
<p>你甚至可以用<code>.collect()</code>创建像<code>HashMap</code>这样复杂的东西，所以它非常强大。下面是一个如何将两个向量放入<code>HashMap</code>的例子。首先我们把两个向量创建出来，然后我们会对它们使用<code>.into_iter()</code>来得到一个值的迭代器。然后我们使用<code>.zip()</code>方法。这个方法将两个迭代器连接在一起，就像拉链一样。最后，我们使用<code>.collect()</code>来创建<code>HashMap</code>。</p>
<p>下面是代码。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // a Vec&lt;i32&gt;
    let some_words = vec!["zero", "one", "two", "three", "four", "five"]; // a Vec&lt;&amp;str&gt;

    let number_word_hashmap = some_numbers
        .into_iter()                 // now it is an iter
        .zip(some_words.into_iter()) // inside .zip() we put in the other iter. Now they are together.
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();

    println!("For key {} we get {}.", 2, number_word_hashmap.get(&amp;2).unwrap());
}</code></pre></pre>
<p>这个将打印:</p>
<pre><code class="language-text">For key 2 we get two.
</code></pre>
<p>你可以看到，我们写了 <code>&lt;HashMap&lt;_, _&gt;&gt;</code>，因为这足以让 Rust 决定 <code>HashMap&lt;i32, &amp;str&gt;</code> 的类型。如果你想写 <code>.collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();</code>也行，也可以这样写:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // a Vec&lt;i32&gt;
    let some_words = vec!["zero", "one", "two", "three", "four", "five"]; // a Vec&lt;&amp;str&gt;
    let number_word_hashmap: HashMap&lt;_, _&gt; = some_numbers  // Because we tell it the type here...
        .into_iter()
        .zip(some_words.into_iter())
        .collect(); // we don't have to tell it here
}</code></pre></pre>
<p>还有一种方法，就像<code>.enumerate()</code>的<code>char</code>。<code>char_indices()</code>. (Indices的意思是 "索引")。你用它的方法是一样的。假设我们有一个由3位数组成的大字符串。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers_together = "140399923481800622623218009598281";

    for (index, number) in numbers_together.char_indices() {
        match (index % 3, number) {
            (0..=1, number) =&gt; print!("{}", number), // just print the number if there is a remainder
            _ =&gt; print!("{}\t", number), // otherwise print the number with a tab space
        }
    }
}</code></pre></pre>
<p>打印<code>140     399     923     481     800     622     623     218     009     598    281</code>。</p>
<h3 id="闭包中的_"><a class="header" href="#闭包中的_">闭包中的|_|</a></h3>
<p>有时你会在一个闭包中看到 <code>|_|</code>。这意味着这个闭包需要一个参数(比如 <code>x</code>)，但你不想使用它。所以 <code>|_|</code> 意味着 "好吧，这个闭包需要一个参数，但我不会给它一个名字，因为我不关心它"。</p>
<p>下面是一个错误的例子，当你不这样做的时候。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    println!("{:?}", my_vec.iter().for_each(|| println!("We didn't use the variables at all"))); // ⚠️
}</code></pre></pre>
<p>Rust说</p>
<pre><code class="language-text">error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments
  --&gt; src\main.rs:28:36
   |
28 |     println!("{:?}", my_vec.iter().for_each(|| println!("We didn't use the variables at all")));
   |                                    ^^^^^^^^ -- takes 0 arguments
   |                                    |
   |                                    expected closure that takes 1 argument
</code></pre>
<p>编译器其实给你一些帮助。</p>
<pre><code class="language-text">help: consider changing the closure to take and ignore the expected argument
   |
28 |     println!("{:?}", my_vec.iter().for_each(|_| println!("We didn't use the variables at all")));
</code></pre>
<p>这是很好的建议。如果你把<code>||</code>改成<code>|_|</code>就可以了。</p>
<h3 id="闭包和迭代器的有用方法"><a class="header" href="#闭包和迭代器的有用方法">闭包和迭代器的有用方法</a></h3>
<p>一旦你熟悉了闭包，Rust就会成为一种非常有趣的语言。有了闭包，你可以将方法互相<em>链接</em>起来，用很少的代码做很多事情。下面是一些我们还没有见过的闭包和使用闭包的方法。</p>
<p><code>.filter()</code>: 这可以让你在迭代器中保留你想保留的元素。让我们过滤一年中的月份。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let months = vec!["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    let filtered_months = months
        .into_iter()                         // make an iter
        .filter(|month| month.len() &lt; 5)     // We don't want months more than 5 bytes in length.
                                             // We know that each letter is one byte so .len() is fine
        .filter(|month| month.contains("u")) // Also we only like months with the letter u
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

    println!("{:?}", filtered_months);
}</code></pre></pre>
<p>这个打印<code>["June", "July"]</code>。</p>
<p><code>.filter_map()</code>. 这个叫做<code>filter_map()</code>，因为它做了<code>.filter()</code>和<code>.map()</code>。闭包必须返回一个 <code>Option&lt;T&gt;</code>，然后对每个<code>Option</code>, 如果是 <code>Some</code>, <code>filter_map()</code>将取出它的值。所以比如说你<code>.filter_map()</code>一个<code>vec![Some(2), None, Some(3)]</code>，它就会返回<code>[2, 3]</code>。</p>
<p>我们将用一个<code>Company</code>结构体来写一个例子。每个公司都有一个<code>name</code>，所以这个字段是<code>String</code>，但是CEO可能最近已经辞职了。所以<code>ceo</code>字段是<code>Option&lt;String&gt;</code>。我们会<code>.filter_map()</code>过一些公司，只保留CEO名字。</p>
<pre><pre class="playground"><code class="language-rust">struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            "" =&gt; None,
            name =&gt; Some(name.to_string()),
        }; // ceo is decided, so now we return Self
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone() // Just returns a clone of the CEO (struct is not Copy)
    }
}

fn main() {
    let company_vec = vec![
        Company::new("Umbrella Corporation", "Unknown"),
        Company::new("Ovintiv", "Doug Suttles"),
        Company::new("The Red-Headed League", ""),
        Company::new("Stark Enterprises", ""),
    ];

    let all_the_ceos = company_vec
        .into_iter()
        .filter_map(|company| company.get_ceo()) // filter_map needs Option&lt;T&gt;
        .collect::&lt;Vec&lt;String&gt;&gt;();

    println!("{:?}", all_the_ceos);
}</code></pre></pre>
<p>这就打印出了<code>["Unknown", "Doug Suttles"]</code>。</p>
<p>既然 <code>.filter_map()</code> 需要 <code>Option</code>，那么 <code>Result</code> 呢？没问题:有一个叫做 <code>.ok()</code> 的方法，可以把 <code>Result</code> 变成 <code>Option</code>。之所以叫<code>.ok()</code>，是因为它能发送的只是<code>Ok</code>的结果(<code>Err</code>的信息没有了)。你记得<code>Option</code>是<code>Option&lt;T&gt;</code>，而<code>Result</code>是<code>Result&lt;T, E&gt;</code>，同时有<code>Ok</code>和<code>Err</code>的信息。所以当你使用<code>.ok()</code>时，任何<code>Err</code>的信息都会丢失，变成<code>None</code>。</p>
<p>使用 <code>.parse()</code> 是一个很简单的例子，我们尝试解析一些用户输入。<code>.parse()</code>在这里接受一个<code>&amp;str</code>，并试图把它变成一个<code>f32</code>。它返回一个 <code>Result</code>，但我们使用的是 <code>filter_map()</code>，所以我们只需抛出错误。<code>Err</code>的任何内容都会变成<code>None</code>，并被<code>.filter_map()</code>过滤掉。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let user_input = vec!["8.9", "Nine point nine five", "8.0", "7.6", "eleventy-twelve"];

    let actual_numbers = user_input
        .into_iter()
        .filter_map(|input| input.parse::&lt;f32&gt;().ok())
        .collect::&lt;Vec&lt;f32&gt;&gt;();

    println!("{:?}", actual_numbers);
}</code></pre></pre>
<p>将打印: <code>[8.9, 8.0, 7.6]</code>。</p>
<p>与<code>.ok()</code>相对的是<code>.ok_or()</code>和<code>ok_or_else()</code>。这样就把<code>Option</code>变成了<code>Result</code>。之所以叫<code>.ok_or()</code>，是因为<code>Result</code>给出了一个<code>Ok</code><strong>或</strong><code>Err</code>，所以你必须让它知道<code>Err</code>的值是多少。这是因为<code>None</code>中的<code>Option</code>没有任何信息。另外，你现在可以看到，这些方法名称中的<em>else</em>部分意味着它有一个闭包。</p>
<p>我们可以把我们的<code>Option</code>从<code>Company</code>结构中取出来，然后这样把它变成一个<code>Result</code>。对于长期的错误处理，最好是创建自己的错误类型。
但是现在我们只是给它一个错误信息，所以它就变成了<code>Result&lt;String, &amp;str&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">// Everything before main() is exactly the same
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            "" =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new("Umbrella Corporation", "Unknown"),
        Company::new("Ovintiv", "Doug Suttles"),
        Company::new("The Red-Headed League", ""),
        Company::new("Stark Enterprises", ""),
    ];

    let mut results_vec = vec![]; // Pretend we need to gather error results too

    company_vec
        .iter()
        .for_each(|company| results_vec.push(company.get_ceo().ok_or("No CEO found")));

    for item in results_vec {
        println!("{:?}", item);
    }
}</code></pre></pre>
<p>这行是最大的变化:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
.for_each(|company| results_vec.push(company.get_ceo().ok_or("No CEO found")));
<span class="boring">}</span></code></pre></pre>
<p>它的意思是:"每家公司，用<code>get_ceo()</code>. 如果你得到了，那就把<code>Ok</code>里面的数值传给你。如果没有，就在<code>Err</code>里面传递 "没有找到CEO"。然后把这个推到vec里。"</p>
<p>所以当我们打印<code>results_vec</code>的时候，就会得到这样的结果。</p>
<pre><code class="language-text">Ok("Unknown")
Ok("Doug Suttles")
Err("No CEO found")
Err("No CEO found")
</code></pre>
<p>所以现在我们有了所有四个条目。现在让我们使用 <code>.ok_or_else()</code>，这样我们就可以使用一个闭包，并得到一个更好的错误信息。现在我们有空间使用<code>format!</code>来创建一个<code>String</code>，并将公司名称放在其中。然后我们返回<code>String</code>。</p>
<pre><pre class="playground"><code class="language-rust">// Everything before main() is exactly the same
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            "" =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new("Umbrella Corporation", "Unknown"),
        Company::new("Ovintiv", "Doug Suttles"),
        Company::new("The Red-Headed League", ""),
        Company::new("Stark Enterprises", ""),
    ];

    let mut results_vec = vec![];

    company_vec.iter().for_each(|company| {
        results_vec.push(company.get_ceo().ok_or_else(|| {
            let err_message = format!("No CEO found for {}", company.name);
            err_message
        }))
    });

    for item in results_vec {
        println!("{:?}", item);
    }
}</code></pre></pre>
<p>这样一来，我们就有了。</p>
<pre><code class="language-text">Ok("Unknown")
Ok("Doug Suttles")
Err("No CEO found for The Red-Headed League")
Err("No CEO found for Stark Enterprises")
</code></pre>
<p><code>.and_then()</code>是一个有用的方法，它接收一个<code>Option</code>，然后让你对它的值做一些事情，并把它传递出去。所以它的输入是一个 <code>Option</code>，输出也是一个 <code>Option</code>。这有点像一个安全的 "解包，然后做一些事情，然后再包"。</p>
<p>一个简单的例子是，我们使用 <code>.get()</code> 从一个 vec 中得到一个数字，因为它返回一个 <code>Option</code>。现在我们可以把它传给 <code>and_then()</code>，如果它是 <code>Some</code>，我们可以对它做一些数学运算。如果是<code>None</code>，那么<code>None</code>就会被传递过去。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 0]; // just a vec with numbers

    let number_to_add = 5;       // use this in the math later
    let mut empty_vec = vec![];  // results go in here


    for index in 0..5 {
        empty_vec.push(
            new_vec
               .get(index)
                .and_then(|number| Some(number + 1))
                .and_then(|number| Some(number + number_to_add))
        );
    }
    println!("{:?}", empty_vec);
}</code></pre></pre>
<p>这就打印出了<code>[Some(14), Some(15), Some(6), None, None]</code>。你可以看到<code>None</code>并没有被过滤掉，只是传递了。</p>
<p><code>.and()</code>有点像<code>Option</code>的<code>bool</code>。你可以匹配很多个<code>Option</code>，如果它们都是<code>Some</code>，那么它会给出最后一个。而如果其中一个是<code>None</code>，那么就会给出<code>None</code>。</p>
<p>首先这里有一个<code>bool</code>的例子来帮助想象。你可以看到，如果你用的是<code>&amp;&amp;</code>(和)，哪怕是一个<code>false</code>，也会让一切<code>false</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let one = true;
    let two = false;
    let three = true;
    let four = true;

    println!("{}", one &amp;&amp; three); // prints true
    println!("{}", one &amp;&amp; two &amp;&amp; three &amp;&amp; four); // prints false
}</code></pre></pre>
<p>现在这里的<code>.and()</code>也是一样的。想象一下，我们做了五次操作，并把结果放在一个Vec&lt;Option&lt;&amp;str&gt;&gt;中。如果我们得到一个值，我们就把<code>Some("success!")</code>推到Vec中。然后我们再做两次这样的操作。之后我们用<code>.and()</code>每次只显示得到<code>Some</code>的索引。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_try = vec![Some("success!"), None, Some("success!"), Some("success!"), None];
    let second_try = vec![None, Some("success!"), Some("success!"), Some("success!"), Some("success!")];
    let third_try = vec![Some("success!"), Some("success!"), Some("success!"), Some("success!"), None];

    for i in 0..first_try.len() {
        println!("{:?}", first_try[i].and(second_try[i]).and(third_try[i]));
    }
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">None
None
Some("success!")
Some("success!")
None
</code></pre>
<p>第一个(索引0)是<code>None</code>，因为在<code>second_try</code>中有一个<code>None</code>为索引0。第二个是<code>None</code>，因为在<code>first_try</code>中有一个<code>None</code>。其次是<code>Some("success!")</code>，因为<code>first_try</code>、<code>second try</code>、<code>third_try</code>中没有<code>None</code>。</p>
<p><code>.any()</code>和<code>.all()</code>在迭代器中非常容易使用。它们根据你的输入返回一个<code>bool</code>。在这个例子中，我们做了一个非常大的vec(大约20000个元素)，包含了从<code>'a'</code>到<code>'働'</code>的所有字符。然后我们创建一个函数来检查是否有字符在其中。</p>
<p>接下来我们创建一个更小的vec，问它是否都是字母(用<code>.is_alphabetic()</code>方法)。然后我们问它是不是所有的字符都小于韩文字符<code>'행'</code>。</p>
<p>还要注意放一个参照物，因为<code>.iter()</code>给了一个参照物，你需要一个<code>&amp;</code>和另一个<code>&amp;</code>进行比较。</p>
<pre><pre class="playground"><code class="language-rust">fn in_char_vec(char_vec: &amp;Vec&lt;char&gt;, check: char) {
    println!("Is {} inside? {}", check, char_vec.iter().any(|&amp;char| char == check));
}

fn main() {
    let char_vec = ('a'..'働').collect::&lt;Vec&lt;char&gt;&gt;();
    in_char_vec(&amp;char_vec, 'i');
    in_char_vec(&amp;char_vec, '뷁');
    in_char_vec(&amp;char_vec, '鑿');

    let smaller_vec = ('A'..'z').collect::&lt;Vec&lt;char&gt;&gt;();
    println!("All alphabetic? {}", smaller_vec.iter().all(|&amp;x| x.is_alphabetic()));
    println!("All less than the character 행? {}", smaller_vec.iter().all(|&amp;x| x &lt; '행'));
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">Is i inside? true
Is 뷁 inside? false
Is 鑿 inside? false
All alphabetic? false
All less than the character 행? true
</code></pre>
<p>顺便说一下，<code>.any()</code>只检查到一个匹配的元素，然后就停止了。如果它已经找到了一个匹配项，它不会检查所有的元素。如果您要在 <code>Vec</code> 上使用 <code>.any()</code>，最好把可能匹配的元素推到前面。或者你可以在 <code>.iter()</code> 之后使用 <code>.rev()</code> 来反向迭代。这里有一个这样的vec。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);
}</code></pre></pre>
<p>所以这个<code>Vec</code>有1000个<code>6</code>，后面还有一个<code>5</code>。我们假设我们要用<code>.any()</code>来看看它是否包含5。首先让我们确定<code>.rev()</code>是有效的。记住，一个<code>Iterator</code>总是有<code>.next()</code>，让你每次都检查它的工作。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut iterator = big_vec.iter().rev();
    println!("{:?}", iterator.next());
    println!("{:?}", iterator.next());
}</code></pre></pre>
<p>它的打印。</p>
<pre><code class="language-text">Some(5)
Some(6)
</code></pre>
<p>我们是对的:有一个<code>Some(5)</code>，然后1000个<code>Some(6)</code>开始。所以我们可以这样写。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    println!("{:?}", big_vec.iter().rev().any(|&amp;number| number == 5));
}</code></pre></pre>
<p>而且因为是<code>.rev()</code>，所以它只调用<code>.next()</code>一次就停止了。如果我们不用<code>.rev()</code>，那么它将调用<code>.next()</code> 1001次才停止。这段代码显示了它。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut counter = 0; // Start counting
    let mut big_iter = big_vec.into_iter(); // Make it an Iterator

    loop {
        counter +=1;
        if big_iter.next() == Some(5) { // Keep calling .next() until we get Some(5)
            break;
        }
    }
    println!("Final counter is: {}", counter);
}</code></pre></pre>
<p>这将打印出 <code>Final counter is: 1001</code>，所以我们知道它必须调用 <code>.next()</code> 1001 次才能找到 5。</p>
<p><code>.find()</code> 告诉你一个迭代器是否有东西，而 <code>.position()</code> 告诉你它在哪里。<code>.find()</code>与<code>.any()</code>不同，因为它返回一个<code>Option</code>，里面有值(或<code>None</code>)。同时，<code>.position()</code>也是一个带有位置号的<code>Option</code>，或<code>None</code>。换句话说</p>
<ul>
<li><code>.find()</code>: "我尽量帮你拿"</li>
<li><code>.position()</code>:"我帮你找找看在哪里"</li>
</ul>
<p>下面是一个简单的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    println!("{:?}", num_vec.iter().find(|&amp;number| number % 3 == 0)); // find takes a reference, so we give it &amp;number
    println!("{:?}", num_vec.iter().find(|&amp;number| number * 2 == 30));

    println!("{:?}", num_vec.iter().position(|&amp;number| number % 3 == 0));
    println!("{:?}", num_vec.iter().position(|&amp;number| number * 2 == 30));

}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">Some(30) // This is the number itself
None // No number inside times 2 == 30
Some(2) // This is the position
None
</code></pre>
<p>使用 <code>.cycle()</code> 你可以创建一个永远循环的迭代器。这种类型的迭代器与 <code>.zip()</code> 很好地结合在一起，可以创建新的东西，就像这个例子，它创建了一个 <code>Vec&lt;(i32, &amp;str)&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let even_odd = vec!["even", "odd"];

    let even_odd_vec = (0..6)
        .zip(even_odd.into_iter().cycle())
        .collect::&lt;Vec&lt;(i32, &amp;str)&gt;&gt;();
    println!("{:?}", even_odd_vec);
}</code></pre></pre>
<p>所以，即使<code>.cycle()</code>可能永远不会结束，但当把它们压缩在一起时，另一个迭代器只运行了6次。
也就是说，<code>.cycle()</code>所做的迭代器不会再被<code>.next()</code>调用，所以六次之后就完成了。输出的结果是</p>
<pre><code>[(0, "even"), (1, "odd"), (2, "even"), (3, "odd"), (4, "even"), (5, "odd")]
</code></pre>
<p>类似的事情也可以用一个没有结尾的范围来完成。如果你写<code>0..</code>，那么你就创建了一个永不停止的范围。你可以很容易地使用这个方法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ten_chars = ('a'..).take(10).collect::&lt;Vec&lt;char&gt;&gt;();
    let skip_then_ten_chars = ('a'..).skip(1300).take(10).collect::&lt;Vec&lt;char&gt;&gt;();

    println!("{:?}", ten_chars);
    println!("{:?}", skip_then_ten_chars);
}</code></pre></pre>
<p>两者都是打印十个字符，但第二个跳过1300位，打印的是亚美尼亚语的十个字母。</p>
<pre><code>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
['յ', 'ն', 'շ', 'ո', 'չ', 'պ', 'ջ', 'ռ', 'ս', 'վ']
</code></pre>
<p>另一种流行的方法叫做<code>.fold()</code>。这个方法经常用于将迭代器中的元素加在一起，但你也可以做更多的事情。它与<code>.for_each()</code>有些类似。在 <code>.fold()</code> 中，你首先添加一个起始值 (如果你是把元素加在一起，那么就是 0)，然后是一个逗号，然后是闭包。结尾给你两个元素:到目前为止的总数，和下一个元素。首先这里有一个简单的例子，显示<code>.fold()</code>将元素加在一起。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_numbers = vec![9, 6, 9, 10, 11];

    println!("{}", some_numbers
        .iter()
        .fold(0, |total_so_far, next_number| total_so_far + next_number)
    );
}</code></pre></pre>
<p>所以，在第1步中，它从0开始，再加上下一个数字:9。</p>
<ul>
<li>第1步，从0开始，加上下一个数字9</li>
<li>然后把9加上6: 15。</li>
<li>然后把15加上9: 24。</li>
<li>然后取24，再加上10: 34。</li>
<li>最后取34，再加上11: 45。所以它的打印结果是<code>45</code>.</li>
</ul>
<p>但是你不需要只用它来添加东西。下面是一个例子，我们在每一个字符上加一个'-'，就会变成<code>String</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a_string = "I don't have any dashes in me.";

    println!(
        "{}",
        a_string
            .chars() // Now it's an iterator
            .fold("-".to_string(), |mut string_so_far, next_char| { // Start with a String "-". Bring it in as mutable each time along with the next char
                string_so_far.push(next_char); // Push the char on, then '-'
                string_so_far.push('-');
                string_so_far} // Don't forget to pass it on to the next loop
            ));
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">-I- -d-o-n-'-t- -h-a-v-e- -a-n-y- -d-a-s-h-e-s- -i-n- -m-e-.-
</code></pre>
<p>还有很多其他方便的方法，比如</p>
<ul>
<li><code>.take_while()</code>，只要得到<code>true</code>，就会带入一个迭代器(例如<code>take while x &gt; 5</code>)</li>
<li><code>.cloned()</code>，它在迭代器内做了一个克隆。这将一个引用变成了一个值。</li>
<li><code>.by_ref()</code>，它使迭代器取一个引用。这很好的保证了你使用<code>Vec</code>或类似的方法来创建迭代器后可以使用它。</li>
<li>许多其他的<code>_while</code>方法:<code>.skip_while()</code>、<code>.map_while()</code>等等。</li>
<li><code>.sum()</code>:就是把所有的东西加在一起。</li>
</ul>
<p><code>.chunks()</code>和<code>.windows()</code>是将矢量切割成你想要的尺寸的两种方法。你把你想要的尺寸放在括号里。比如说你有一个有10个元素的矢量，你想要一个3的尺寸，它的工作原理是这样的。</p>
<ul>
<li>
<p><code>.chunks()</code>会给你4个切片: [0, 1, 2], 然后是[3, 4, 5], 然后是[6, 7, 8], 最后是[9]. 所以它会尝试用三个元素创建一个切片，但如果它没有三个元素，那么它就不会崩溃。它只会给你剩下的东西。</p>
</li>
<li>
<p><code>.windows()</code>会先给你一个[0, 1, 2]的切片。然后它将移过一片，给你[1, 2, 3]。它将一直这样做，直到最后到达3的最后一片，然后停止。</p>
</li>
</ul>
<p>所以让我们在一个简单的数字向量上使用它们。它看起来像这样:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

    for chunk in num_vec.chunks(3) {
        println!("{:?}", chunk);
    }
    println!();
    for window in num_vec.windows(3) {
        println!("{:?}", window);
    }
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[0]

[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 0]
</code></pre>
<p>顺便说一下，如果你什么都不给它，<code>.chunks()</code>会崩溃。你可以为一个只有一项的向量写<code>.chunks(1000)</code>，但你不能为任何长度为0的东西写<code>.chunks()</code>。 如果你点击[src]，你可以在函数中看到这一点，因为它说<code>assert!(chunk_size != 0);</code>。</p>
<p><code>.match_indices()</code> 让你把 <code>String</code> 或 <code>&amp;str</code> 里面所有符合你的输入的东西都提取出来，并给你索引。它与 <code>.enumerate()</code> 类似，因为它返回一个包含两个元素的元组。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rules = "Rule number 1: No fighting. Rule number 2: Go to bed at 8 pm. Rule number 3: Wake up at 6 am.";
    let rule_locations = rules.match_indices("Rule").collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // This is Vec&lt;usize, &amp;str&gt; but we just tell Rust to do it
    println!("{:?}", rule_locations);
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">[(0, "Rule"), (28, "Rule"), (62, "Rule")]
</code></pre>
<p><code>.peekable()</code> 让你创建一个迭代器，在那里你可以看到 (窥视) 下一个元素。它就像调用 <code>.next()</code> (它给出了一个 <code>Option</code>)，除了迭代器不会移动，所以你可以随意使用它。实际上，你可以把peekable看成是 "可停止"的，因为你可以想停多久就停多久。下面是一个例子，我们对每个元素都使用<code>.peek()</code>三次。我们可以永远使用<code>.peek()</code>，直到我们使用<code>.next()</code>移动到下一个元素。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let just_numbers = vec![1, 5, 100];
    let mut number_iter = just_numbers.iter().peekable(); // This actually creates a type of iterator called Peekable

    for _ in 0..3 {
        println!("I love the number {}", number_iter.peek().unwrap());
        println!("I really love the number {}", number_iter.peek().unwrap());
        println!("{} is such a nice number", number_iter.peek().unwrap());
        number_iter.next();
    }
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">I love the number 1
I really love the number 1
1 is such a nice number
I love the number 5
I really love the number 5
5 is such a nice number
I love the number 100
I really love the number 100
100 is such a nice number
</code></pre>
<p>下面是另一个例子，我们使用<code>.peek()</code>对一个元素进行匹配。使用完后，我们调用<code>.next()</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let locations = vec![
        ("Nevis", 25),
        ("Taber", 8428),
        ("Markerville", 45),
        ("Cardston", 3585),
    ];
    let mut location_iter = locations.iter().peekable();
    while location_iter.peek().is_some() {
        match location_iter.peek() {
            Some((name, number)) if *number &lt; 100 =&gt; { // .peek() gives us a reference so we need *
                println!("Found a hamlet: {} with {} people", name, number)
            }
            Some((name, number)) =&gt; println!("Found a town: {} with {} people", name, number),
            None =&gt; break,
        }
        location_iter.next();
    }
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">Found a hamlet: Nevis with 25 people
Found a town: Taber with 8428 people
Found a hamlet: Markerville with 45 people
Found a town: Cardston with 3585 people
</code></pre>
<p>最后，这里有一个例子，我们也使用<code>.match_indices()</code>。在这个例子中，我们根据<code>&amp;str</code>中的空格数，将名字放入<code>struct</code>中。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Names {
    one_word: Vec&lt;String&gt;,
    two_words: Vec&lt;String&gt;,
    three_words: Vec&lt;String&gt;,
}

fn main() {
    let vec_of_names = vec![
        "Caesar",
        "Frodo Baggins",
        "Bilbo Baggins",
        "Jean-Luc Picard",
        "Data",
        "Rand Al'Thor",
        "Paul Atreides",
        "Barack Hussein Obama",
        "Bill Jefferson Clinton",
    ];

    let mut iter_of_names = vec_of_names.iter().peekable();

    let mut all_names = Names { // start an empty Names struct
        one_word: vec![],
        two_words: vec![],
        three_words: vec![],
    };

    while iter_of_names.peek().is_some() {
        let next_item = iter_of_names.next().unwrap(); // We can use .unwrap() because we know it is Some
        match next_item.match_indices(' ').collect::&lt;Vec&lt;_&gt;&gt;().len() { // Create a quick vec using .match_indices and check the length
            0 =&gt; all_names.one_word.push(next_item.to_string()),
            1 =&gt; all_names.two_words.push(next_item.to_string()),
            _ =&gt; all_names.three_words.push(next_item.to_string()),
        }
    }

    println!("{:?}", all_names);
}</code></pre></pre>
<p>这将打印:</p>
<pre><code class="language-text">Names { one_word: ["Caesar", "Data"], two_words: ["Frodo Baggins", "Bilbo Baggins", "Jean-Luc Picard", "Rand Al\'Thor", "Paul Atreides"], three_words:
["Barack Hussein Obama", "Bill Jefferson Clinton"] }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_36.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Chapter_38.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_36.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Chapter_38.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
