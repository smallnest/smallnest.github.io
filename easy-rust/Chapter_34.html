<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> 特性 - 简单英语学Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong>  更新</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong>  介绍</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong>  我是谁？</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong>  简单英语学Rust</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong>  Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong>  🚧和⚠️</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong>  注释</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong>  类型</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong>  类型推导</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong>  打印hello, world!</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong>  显示和调试</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong>  可变性</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong>  栈、堆和指针</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong>  关于打印的更多信息</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong>  字符串</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong>  const和static</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong>  关于引用的更多信息</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong>  可变引用</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong>  函数的引用</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong>  拷贝类型</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong>  集合类型</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong>  向量</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong>  元组</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong>  控制流</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong>  结构体</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong>  枚举</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong>  循环</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong>  实现结构体和枚举</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong>  解构</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong>  引用和点运算符</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong>  泛型</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong>  Option和Result</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong>  其他集合类型</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong>  ?操作符</a></li><li class="chapter-item expanded "><a href="Chapter_34.html" class="active"><strong aria-hidden="true">35.</strong>  特性</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong>  链式方法</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong>  迭代器</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong>  闭包</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong>  dbg! 宏和.inspect</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong>  &str的类型</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong>  生命期</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong>  内部可变性</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong>  Cow</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong>  类型别名</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong>  todo!宏</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong>  Rc</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong>  多线程</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong>  函数中的闭包</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong>  impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong>  Arc</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong>  Channels</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong>  阅读Rust文档</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong>  属性</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong>  Box</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong>  用Box包裹trait</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong>  默认值和建造者模式</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong>  Deref和DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong>  Crate和模块</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong>  测试</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong>  外部crate</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong>  标准库之旅</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong>  编写宏</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong>  cargo</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong>  接受用户输入</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong>  使用文件</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong>  cargo文档</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong>  结束了吗？</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">简单英语学Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<p>我们以前见过trait:<code>Debug</code>、<code>Copy</code>、<code>Clone</code>都是trait。要给一个类型一个trait，就必须实现它。因为<code>Debug</code>和其他的trait都很常见，所以我们有自动实现的属性。这就是当你写下<code>#[derive(Debug)]</code>所发生的事情:你自动实现了<code>Debug</code>。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyStruct {
    number: usize,
}

fn main() {}</code></pre></pre>
<p>但是其他的特性就比较困难了，所以需要用<code>impl</code>手动实现。例如，<code>Add</code>(在<code>std::ops::Add</code>处找到)是用来累加两个东西的。但是Rust并不知道你到底要怎么累加，所以你必须告诉它。</p>
<pre><pre class="playground"><code class="language-rust">struct ThingsToAdd {
    first_thing: u32,
    second_thing: f32,
}

fn main() {}</code></pre></pre>
<p>我们可以累加<code>first_thing</code>和<code>second_thing</code>，但我们需要提供更多信息。也许我们想要一个<code>f32</code>，所以像这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let result = self.second_thing + self.first_thing as f32
<span class="boring">}</span></code></pre></pre>
<p>但也许我们想要一个整数，所以像这样:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
let result = self.second_thing as u32 + self.first_thing
<span class="boring">}</span></code></pre></pre>
<p>或者我们想把<code>self.first_thing</code>放在<code>self.second_thing</code>旁边，这样加。所以如果我们把55加到33.4，我们要看到的是5533.4，而不是88.4。</p>
<p>所以首先我们看一下如何创建一个trait。关于<code>trait</code>，要记住的重要一点是，它们是关于行为的。要创建一个trait，写下单词<code>trait</code>，然后创建一些函数。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // A simple struct - an Animal only has a name
    name: String,
}

trait Dog { // The dog trait gives some functionality
    fn bark(&amp;self) { // It can bark
        println!("Woof woof!");
    }
    fn run(&amp;self) { // and it can run
        println!("The dog is running!");
    }
}

impl Dog for Animal {} // Now Animal has the trait Dog

fn main() {
    let rover = Animal {
        name: "Rover".to_string(),
    };

    rover.bark(); // Now Animal can use bark()
    rover.run();  // and it can use run()
}</code></pre></pre>
<p>这个是可以的，但是我们不想打印 "狗在跑"。如果你想的话，你可以改变<code>trait</code>给你的方法，但你必须有相同的签名。这意味着它需要接受同样的东西，并返回同样的东西。例如，我们可以改变 <code>.run()</code> 的方法，但我们必须遵循签名。签名说</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
fn run(&amp;self) {
    println!("The dog is running!");
}
<span class="boring">}</span></code></pre></pre>
<p><code>fn run(&amp;self)</code>的意思是 "fn <code>run()</code>以<code>&amp;self</code>为参数，不返回任何内容"。所以你不能这样做:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;self) -&gt; i32 { // ⚠️
    5
}
<span class="boring">}</span></code></pre></pre>
<p>Rust会说。</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>但我们可以做到这一点。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // A simple struct - an Animal only has a name
    name: String,
}

trait Dog { // The dog trait gives some functionality
    fn bark(&amp;self) { // It can bark
        println!("Woof woof!");
    }
    fn run(&amp;self) { // and it can run
        println!("The dog is running!");
    }
}

impl Dog for Animal {
    fn run(&amp;self) {
        println!("{} is running!", self.name);
    }
}

fn main() {
    let rover = Animal {
        name: "Rover".to_string(),
    };

    rover.bark(); // Now Animal can use bark()
    rover.run();  // and it can use run()
}</code></pre></pre>
<p>现在它打印的是 <code>Rover is running!</code>。这是好的，因为我们返回的是 <code>()</code>，或者说什么都没有，这就是trait所说的。</p>
<p>当你写一个trait的时候，你可以直接写函数签名，但如果你这样做，用户将不得不写函数实现。我们来试试。现在我们把<code>bark()</code>和<code>run()</code>改成只说<code>fn bark(&amp;self);</code>和<code>fn run(&amp;self);</code>。这不是一个完整的函数实现，所以必须由用户来写。</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    name: String,
}

trait Dog {
    fn bark(&amp;self); // bark() says it needs a &amp;self and returns nothing
    fn run(&amp;self); // run() says it needs a &amp;self and returns nothing.
                   // So now we have to write them ourselves.
}

impl Dog for Animal {
    fn bark(&amp;self) {
        println!("{}, stop barking!!", self.name);
    }
    fn run(&amp;self) {
        println!("{} is running!", self.name);
    }
}

fn main() {
    let rover = Animal {
        name: "Rover".to_string(),
    };

    rover.bark();
    rover.run();
}</code></pre></pre>
<p>所以，当你创建一个trait时，你必须思考:"我应该写哪些功能？而用户应该写哪些函数？" 如果你认为用户每次使用函数的方式应该是一样的，那么就把函数写出来。如果你认为用户会以不同的方式使用，那就写出函数签名即可。</p>
<p>所以，让我们尝试为我们的struct实现Display特性。首先我们将创建一个简单的结构体:</p>
<pre><pre class="playground"><code class="language-rust">struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };
}</code></pre></pre>
<p>现在我们要打印<code>mr_mantle</code>。调试很容易得出。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };

    println!("Mr. Mantle is a {:?}", mr_mantle);
}</code></pre></pre>
<p>但Debug打印不是最漂亮的方式，因为它看起来是这样的:</p>
<pre><code class="language-text">Mr. Mantle is a Cat { name: "Reggie Mantle", age: 4 }
</code></pre>
<p>因此，如果我们想要更好的打印，就需要实现<code>Display</code>为<code>Cat</code>。在<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a>上我们可以看到Display的信息，还有一个例子。它说</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.longitude, self.latitude)
    }
}

fn main() {}</code></pre></pre>
<p>有些部分我们还不明白，比如<code>&lt;'_&gt;</code>和<code>f</code>在做什么。但我们理解<code>Position</code>结构体:它只是两个<code>f32</code>。我们也明白，<code>self.longitude</code>和<code>self.latitude</code>是结构体中的字段。所以，也许我们的结构体就可以用这个代码，用<code>self.name</code>和<code>self.age</code>。另外，<code>write!</code>看起来很像<code>println!</code>，所以很熟悉。所以我们这样写。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{} is a cat who is {} years old.", self.name, self.age)
    }
}

fn main() {}</code></pre></pre>
<p>让我们添加一个<code>fn main()</code>。现在我们的代码是这样的。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
      write!(f, "{} is a cat who is {} years old.", self.name, self.age)
  }
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };

    println!("{}", mr_mantle);
}</code></pre></pre>
<p>成功了! 现在，当我们使用<code>{}</code>打印时，我们得到<code>Reggie Mantle is a cat who is 4 years old.</code>。这看起来好多了。</p>
<p>顺便说一下，如果你实现了<code>Display</code>，那么你就可以免费得到<code>ToString</code>的特性。这是因为你使用<code>format!</code>宏来实现<code>.fmt()</code>函数，这让你可以用<code>.to_string()</code>来创建一个<code>String</code>。所以我们可以做这样的事情，我们把<code>reggie_mantle</code>传给一个想要<code>String</code>的函数，或者其他任何东西。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{} is a cat who is {} years old.", self.name, self.age)
    }
}

fn print_cats(pet: String) {
    println!("{}", pet);
}

fn main() {
    let mr_mantle = Cat {
        name: "Reggie Mantle".to_string(),
        age: 4,
    };

    print_cats(mr_mantle.to_string()); // Turn him into a String here
    println!("Mr. Mantle's String is {} letters long.", mr_mantle.to_string().chars().count()); // Turn him into chars and count them
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">Reggie Mantle is a cat who is 4 years old.
Mr. Mantle's String is 42 letters long.
</code></pre>
<p>关于trait，要记住的是，它们是关于某些东西的行为。你的<code>struct</code>是如何行动的？它能做什么？这就是trait的作用。如果你想想我们到目前为止所看到的一些trait，它们都是关于行为的:<code>Copy</code>是一个类型可以做的事情。<code>Display</code>也是一个类型能做的事情。<code>ToString</code>是另一个trait，它也是一个类型可以做的事情:它可以变化成一个<code>String</code>。在我们的 <code>Dog</code> trait中，<em>Dog</em>这个词并不意味着你能做的事情，但它给出了一些让它做事情的方法。
你也可以为 <code>struct Poodle</code> 或 <code>struct Beagle</code> 实现它，它们都会得到 <code>Dog</code> 方法。</p>
<p>让我们再看一个与单纯行为联系更紧密的例子。我们将想象一个有一些简单角色的幻想游戏。一个是<code>Monster</code>，另外两个是<code>Wizard</code>和<code>Ranger</code>。<code>Monster</code>只是有<code>health</code>，所以我们可以攻击它，其他两个还没有什么。但是我们做了两个trait。一个叫<code>FightClose</code>，让你近身作战。另一个是<code>FightFromDistance</code>，让你在远处战斗。只有<code>Ranger</code>可以使用<code>FightFromDistance</code>。下面是它的样子:</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

struct Wizard {}
struct Ranger {}

trait FightClose {
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            "You attack with your sword. Your opponent now has {} health left.",
            opponent.health
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            "You attack with your hand. Your opponent now has {} health left.",
            opponent.health
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance {
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                "You attack with your bow. Your opponent now has {} health left.",
                opponent.health
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            "You attack with your rock. Your opponent now has {} health left.",
            opponent.health
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard {};
    let aragorn = Ranger {};

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left.
You attack with your bow. Your opponent now has 20 health left.
</code></pre>
<p>我们在trait里面一直传递<code>self</code>，但是我们现在不能用它做什么。那是因为 Rust 不知道什么类型会使用它。它可能是一个 <code>Wizard</code>，也可能是一个 <code>Ranger</code>，也可能是一个叫做 <code>Toefocfgetobjtnode</code> 的新结构，或者其他任何东西。为了让<code>self</code>具有一定的功能，我们可以在trait中添加必要的trait。比如说，如果我们想用<code>{:?}</code>打印，那么我们就需要<code>Debug</code>。你只要把它写在<code>:</code>(冒号)后面，就可以把它添加到trait中。现在我们的代码是这样的。</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

#[derive(Debug)] // Now Wizard has Debug
struct Wizard {
    health: i32, // Now Wizard has health
}
#[derive(Debug)] // So does Ranger
struct Ranger {
    health: i32, // So does Ranger
}

trait FightClose: std::fmt::Debug { // Now a type needs Debug to use FightClose
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            "You attack with your sword. Your opponent now has {} health left. You are now at: {:?}", // We can now print self with {:?} because we have Debug
            opponent.health, &amp;self
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            "You attack with your hand. Your opponent now has {} health left.  You are now at: {:?}",
            opponent.health, &amp;self
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance: std::fmt::Debug { // We could also do trait FightFromDistance: FightClose because FightClose needs Debug
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                "You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}",
                opponent.health, self
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            "You attack with your rock. Your opponent now has {} health left.  You are now at: {:?}",
            opponent.health, self
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>现在这个打印:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
</code></pre>
<p>在真实的游戏中，可能最好为每个类型重写这个，因为<code>You are now at: Wizard { health: 60 }</code>看起来有点可笑。这也是为什么trait里面的方法通常很简单，因为你不知道什么类型会使用它。例如，你不能写出 <code>self.0 += 10</code> 这样的东西。但是这个例子表明，我们可以在我们正在写的trait里面使用其他的trait。当我们这样做的时候，我们会得到一些我们可以使用的方法。</p>
<p>另外一种使用trait的方式是使用所谓的<code>trait bounds</code>。意思是 "通过一个trait进行限制"。trait限制很简单，因为一个trait实际上不需要任何方法，或者说根本不需要任何东西。让我们用类似但不同的东西重写我们的代码。这次我们的trait没有任何方法，但我们有其他需要trait使用的函数。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // So we don't have to write std::fmt::Debug every time now

struct Monster {
    health: i32,
}

#[derive(Debug)]
struct Wizard {
    health: i32,
}
#[derive(Debug)]
struct Ranger {
    health: i32,
}

trait Magic{} // No methods for any of these traits. They are just trait bounds
trait FightClose {}
trait FightFromDistance {}

impl FightClose for Ranger{} // Each type gets FightClose,
impl FightClose for Wizard {}
impl FightFromDistance for Ranger{} // but only Ranger gets FightFromDistance
impl Magic for Wizard{}  // and only Wizard gets Magic

fn attack_with_bow&lt;T: FightFromDistance + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 10 {
        opponent.health -= 10;
        println!(
            "You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}",
            opponent.health, character
        );
    }
}

fn attack_with_sword&lt;T: FightClose + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster) {
    opponent.health -= 10;
    println!(
        "You attack with your sword. Your opponent now has {} health left. You are now at: {:?}",
        opponent.health, character
    );
}

fn fireball&lt;T: Magic + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 15 {
        opponent.health -= 20;
        println!("You raise your hands and cast a fireball! Your opponent now has {} health left. You are now at: {:?}",
    opponent.health, character);
    }
}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    attack_with_sword(&amp;radagast, &amp;mut uruk_hai);
    attack_with_bow(&amp;aragorn, &amp;mut uruk_hai, 8);
    fireball(&amp;radagast, &amp;mut uruk_hai, 8);
}</code></pre></pre>
<p>这个打印出来的东西几乎是一样的。</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
You raise your hands and cast a fireball! Your opponent now has 0 health left. You are now at: Wizard { health: 60 }
</code></pre>
<p>所以你可以看到，当你使用traits时，有很多方法可以做同样的事情。这一切都取决于什么对你正在编写的程序最有意义。</p>
<p>现在让我们来看看如何实现一些在Rust中使用的主要trait。</p>
<h3 id="from-trait"><a class="header" href="#from-trait">From trait</a></h3>
<p><em>From</em>是一个非常方便的trait，你知道这一点，因为你已经看到了很多。使用<em>From</em>，你可以从一个<code>&amp;str</code>创建一个<code>String</code>，你也可以用许多其他类型创建多种类型。例如，Vec使用<em>From</em>来创建以下类型:</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>这里有很多<code>Vec::from()</code>我们还没有用过。我们来做几个，看看会怎么样:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // We will make a generic function to print them so we want Display

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // Take any Vec&lt;T&gt; if type T has Display
    for item in input {
        print!("{} ", item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // Try from an array
    print_vec(&amp;array_vec);

    let str_vec = Vec::from("What kind of vec will I be?"); // An array from a &amp;str? This will be interesting
    print_vec(&amp;str_vec);

    let string_vec = Vec::from("What kind of vec will a String be?".to_string()); // Also from a String
    print_vec(&amp;string_vec);
}</code></pre></pre>
<p>它打印的内容如下。</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>如果从类型上看，第二个和第三个向量是<code>Vec&lt;u8&gt;</code>，也就是<code>&amp;str</code>和<code>String</code>的字节。所以你可以看到<code>From</code>是非常灵活的，用的也很多。我们用自己的类型来试试。</p>
<p>我们将创建两个结构体，然后为其中一个结构体实现<code>From</code>。一个结构体将是<code>City</code>，另一个结构体将是<code>Country</code>。我们希望能够做到这一点。<code>let country_name = Country::from(vector_of_cities)</code>.</p>
<p>它看起来是这样的:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // So we can print City
struct City {
    name: String,
    population: u32,
}

impl City {
    fn new(name: &amp;str, population: u32) -&gt; Self { // just a new function
        Self {
            name: name.to_string(),
            population,
        }
    }
}
#[derive(Debug)] // Country also needs to be printed
struct Country {
    cities: Vec&lt;City&gt;, // Our cities go in here
}

impl From&lt;Vec&lt;City&gt;&gt; for Country { // Note: we don't have to write From&lt;City&gt;, we can also do
                                   // From&lt;Vec&lt;City&gt;&gt;. So we can also implement on a type that
                                   // we didn't create
    fn from(cities: Vec&lt;City&gt;) -&gt; Self {
        Self { cities }
    }
}

impl Country {
    fn print_cities(&amp;self) { // function to print the cities in Country
        for city in &amp;self.cities {
            // &amp; because Vec&lt;City&gt; isn't Copy
            println!("{:?} has a population of {:?}.", city.name, city.population);
        }
    }
}

fn main() {
    let helsinki = City::new("Helsinki", 631_695);
    let turku = City::new("Turku", 186_756);

    let finland_cities = vec![helsinki, turku]; // This is the Vec&lt;City&gt;
    let finland = Country::from(finland_cities); // So now we can use From

    finland.print_cities();
}</code></pre></pre>
<p>这个将打印:</p>
<pre><code class="language-text">"Helsinki" has a population of 631695.
"Turku" has a population of 186756.
</code></pre>
<p>你可以看到，<code>From</code>很容易从你没有创建的类型中实现，比如<code>Vec</code>、<code>i32</code>等等。这里还有一个例子，我们创建一个有两个向量的向量。第一个向量存放偶数，第二个向量存放奇数。对于<code>From</code>，你可以给它一个<code>i32</code>的向量，它会把它变成<code>Vec&lt;Vec&lt;i32&gt;&gt;</code>:一个容纳<code>i32</code>的向量。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct EvenOddVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for EvenOddVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut even_odd_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // A vec with two empty vecs inside
                                                                    // This is the return value but first we must fill it
        for item in input {
            if item % 2 == 0 {
                even_odd_vec[0].push(item);
            } else {
                even_odd_vec[1].push(item);
            }
        }
        Self(even_odd_vec) // Now it is done so we return it as Self (Self = EvenOddVec)
    }
}

fn main() {
    let bunch_of_numbers = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = EvenOddVec::from(bunch_of_numbers);

    println!("Even numbers: {:?}\nOdd numbers: {:?}", new_vec.0[0], new_vec.0[1]);
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">Even numbers: [8, 222, 0, 8]
Odd numbers: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>像 <code>EvenOddVec</code> 这样的类型可能最好是通用 <code>T</code>，这样我们就可以使用许多数字类型。如果你想练习的话，你可以试着把这个例子做成通用的。</p>
<h3 id="在函数中使用字符串和str"><a class="header" href="#在函数中使用字符串和str">在函数中使用字符串和&amp;str</a></h3>
<p>有时你想让一个函数可以同时接受 <code>String</code> 和 <code>&amp;str</code>。你可以通过泛型和 <code>AsRef</code> 特性来实现这一点。<code>AsRef</code> 用于从一个类型向另一个类型提供引用。如果你看看 <code>String</code> 的文档，你可以看到它对许多类型都有 <code>AsRef</code>。</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>下面是它们的一些函数签名。</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}</span></code></pre></pre>
<p>你可以看到，它需要<code>&amp;self</code>，并给出另一个类型的引用。这意味着，如果你有一个通用类型T，你可以说它需要<code>AsRef&lt;str&gt;</code>。如果你这样做，它将能够使用一个<code>&amp;str</code>和一个<code>String</code>。</p>
<p>我们先说说泛型函数。这个还不能用。</p>
<pre><pre class="playground"><code class="language-rust">fn print_it&lt;T&gt;(input: T) {
    println!("{}", input) // ⚠️
}

fn main() {
    print_it("Please print me");
}</code></pre></pre>
<p>Rust说<code>error[E0277]: T doesn't implement std::fmt::Display</code>。所以我们会要求T实现Display。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: Display&gt;(input: T) {
    println!("{}", input)
}

fn main() {
    print_it("Please print me");
}</code></pre></pre>
<p>现在可以用了，打印出<code>Please print me</code>。这是好的，但T仍然可以是多种类型。
可以是<code>i8</code>，也可以是<code>f32</code>，或者其他任何实现了<code>Display</code>的类型。我们加上<code>AsRef&lt;str&gt;</code>，现在T需要<code>AsRef&lt;str&gt;</code>和<code>Display</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!("{}", input)
}

fn main() {
    print_it("Please print me");
    print_it("Also, please print me".to_string());
    // print_it(7); &lt;- This will not print
}</code></pre></pre>
<p>现在，它不会接受<code>i8</code>这样的类型。</p>
<p>不要忘了，当函数变长时，你可以用<code>where</code>来写不同的函数。如果我们加上Debug，那么就会变成<code>fn print_it&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code>，这一行就很长了。所以我们可以这样写。</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // add Debug

fn print_it&lt;T&gt;(input: T) // Now this line is easy to read
where
    T: AsRef&lt;str&gt; + Debug + Display, // and these traits are easy to read
{
    println!("{}", input)
}

fn main() {
    print_it("Please print me");
    print_it("Also, please print me".to_string());
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_33.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Chapter_35.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_33.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Chapter_35.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
