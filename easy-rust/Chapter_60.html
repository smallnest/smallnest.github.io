<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> 标准库之旅 - 简单英语学Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong>  更新</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong>  介绍</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong>  我是谁？</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong>  简单英语学Rust</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong>  Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong>  🚧和⚠️</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong>  注释</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong>  类型</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong>  类型推导</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong>  打印hello, world!</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong>  显示和调试</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong>  可变性</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong>  栈、堆和指针</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong>  关于打印的更多信息</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong>  字符串</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong>  const和static</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong>  关于引用的更多信息</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong>  可变引用</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong>  函数的引用</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong>  拷贝类型</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong>  集合类型</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong>  向量</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong>  元组</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong>  控制流</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong>  结构体</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong>  枚举</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong>  循环</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong>  实现结构体和枚举</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong>  解构</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong>  引用和点运算符</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong>  泛型</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong>  Option和Result</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong>  其他集合类型</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong>  ?操作符</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong>  特性</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong>  链式方法</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong>  迭代器</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong>  闭包</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong>  dbg! 宏和.inspect</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong>  &str的类型</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong>  生命期</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong>  内部可变性</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong>  Cow</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong>  类型别名</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong>  todo!宏</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong>  Rc</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong>  多线程</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong>  函数中的闭包</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong>  impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong>  Arc</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong>  Channels</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong>  阅读Rust文档</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong>  属性</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong>  Box</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong>  用Box包裹trait</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong>  默认值和建造者模式</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong>  Deref和DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong>  Crate和模块</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong>  测试</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong>  外部crate</a></li><li class="chapter-item expanded "><a href="Chapter_60.html" class="active"><strong aria-hidden="true">61.</strong>  标准库之旅</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong>  编写宏</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong>  cargo</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong>  接受用户输入</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong>  使用文件</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong>  cargo文档</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong>  结束了吗？</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">简单英语学Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="标准库之旅"><a class="header" href="#标准库之旅">标准库之旅</a></h2>
<p>现在你已经知道了很多Rust的知识，你将能够理解标准库里面的大部分东西。它里面的代码已经不是那么可怕了。让我们来看看它里面一些我们还没有学过的部分。本篇游记将介绍标准库的大部分部分，你不需要安装Rust。我们将重温很多我们已经知道的内容，这样我们就可以更深入地学习它们。</p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>关于数组需要注意的一点是，它们没有实现<code>Iterator.</code>。这意味着，如果你有一个数组，你不能使用<code>for</code>。但是你可以对它们使用 <code>.iter()</code> 这样的方法。或者你可以使用<code>&amp;</code>来得到一个切片。实际上，如果你尝试使用<code>for</code>，编译器会准确地告诉你。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ⚠️
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];

    for city in my_cities {
        println!("{}", city);
    }
}</code></pre></pre>
<p>消息是:</p>
<pre><code class="language-text">error[E0277]: `[&amp;str; 3]` is not an iterator
 --&gt; src\main.rs:5:17
  |
  |                 ^^^^^^^^^ borrow the array with `&amp;` or call `.iter()` on it to iterate over it
</code></pre>
<p>所以让我们试试这两种方法。它们的结果是一样的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];

    for city in &amp;my_cities {
        println!("{}", city);
    }
    for city in my_cities.iter() {
        println!("{}", city);
    }
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
</code></pre>
<p>如果你想从一个数组中获取变量，你可以把它们的名字放在 <code>[]</code> 中来解构它。这与在 <code>match</code> 语句中使用元组或从结构体中获取变量是一样的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = ["Beirut", "Tel Aviv", "Nicosia"];
    let [city1, city2, city3] = my_cities;
    println!("{}", city1);
}</code></pre></pre>
<p>打印出<code>Beirut</code>.</p>
<h3 id="char"><a class="header" href="#char">char</a></h3>
<p>您可以使用<code>.escape_unicode()</code>的方法来获取<code>char</code>的Unicode号码。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let korean_word = "청춘예찬";
    for character in korean_word.chars() {
        print!("{} ", character.escape_unicode());
    }
}</code></pre></pre>
<p>这将打印出 <code>u{ccad} u{cd98} u{c608} u{cc2c}</code>。</p>
<p>你可以使用 <code>From</code> trait从 <code>u8</code> 中得到一个字符，但对于 <code>u32</code>，你使用 <code>TryFrom</code>，因为它可能无法工作。<code>u32</code>中的数字比Unicode中的字符多很多。我们可以通过一个简单的演示来了解。</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom; // You need to bring TryFrom in to use it
use rand::prelude::*;      // We will use random numbers too

fn main() {
    let some_character = char::from(99); // This one is easy - no need for TryFrom
    println!("{}", some_character);

    let mut random_generator = rand::thread_rng();
    // This will try 40,000 times to make a char from a u32.
    // The range is 0 (std::u32::MIN) to u32's highest number (std::u32::MAX). If it doesn't work, we will give it '-'.
    for _ in 0..40_000 {
        let bigger_character = char::try_from(random_generator.gen_range(std::u32::MIN..std::u32::MAX)).unwrap_or('-');
        print!("{}", bigger_character)
    }
}</code></pre></pre>
<p>几乎每次都会生成一个<code>-</code>。这是你会看到的那种输出的一部分。</p>
<pre><code class="language-text">------------------------------------------------------------------------𤒰---------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------춗--------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
------------򇍜----------------------------------------------------
</code></pre>
<p>所以，你要用<code>TryFrom</code>是件好事。</p>
<p>另外，从2020年8月底开始，你现在可以从<code>char</code>中得到一个<code>String</code>。(<code>String</code>实现了<code>From&lt;char&gt;</code>)只要写<code>String::from()</code>，然后在里面放一个<code>char</code>。</p>
<h3 id="整数"><a class="header" href="#整数">整数</a></h3>
<p>这些类型的数学方法有很多，另外还有一些其他的方法。下面是一些最有用的。</p>
<p><code>.checked_add()</code>, <code>.checked_sub()</code>, <code>.checked_mul()</code>, <code>.checked_div()</code>. 如果你认为你可能会得到一个不适合类型的数字，这些都是不错的方法。它们会返回一个 <code>Option</code>，这样你就可以安全地检查你的数学计算是否正常，而不会让程序崩溃。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 200_u8;
    let other_number = 200_u8;

    println!("{:?}", some_number.checked_add(other_number));
    println!("{:?}", some_number.checked_add(1));
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">None
Some(201)
</code></pre>
<p>你会注意到，在整数的页面上，经常说<code>rhs</code>。这意味着 "右边"，也就是你做一些数学运算时的右操作数。比如在<code>5 + 6</code>中，<code>5</code>在左边，<code>6</code>在右边，所以<code>6</code>就是<code>rhs</code>。这个不是关键词，但是你会经常看到，所以知道就好。</p>
<p>说到这里，我们来学习一下如何实现<code>Add</code>。在你实现了<code>Add</code>之后，你可以在你创建的类型上使用<code>+</code>。你需要自己实现<code>Add</code>，因为add可以表达很多意思。这是标准库页面中的例子。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add; // first bring in Add

#[derive(Debug, Copy, Clone, PartialEq)] // PartialEq is probably the most important part here. You want to be able to compare numbers
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self; // Remember, this is called an "associated type": a "type that goes together".
                        // In this case it's just another Point

    fn add(self, other: Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>现在让我们为自己的类型实现<code>Add</code>。让我们想象一下，我们想把两个国家加在一起，这样我们就可以比较它们的经济。它看起来像这样:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
use std::ops::Add;

#[derive(Clone)]
struct Country {
    name: String,
    population: u32,
    gdp: u32, // This is the size of the economy
}

impl Country {
    fn new(name: &amp;str, population: u32, gdp: u32) -&gt; Self {
        Self {
            name: name.to_string(),
            population,
            gdp,
        }
    }
}

impl Add for Country {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            name: format!("{} and {}", self.name, other.name), // We will add the names together,
            population: self.population + other.population, // and the population,
            gdp: self.gdp + other.gdp,   // and the GDP
        }
    }
}

impl fmt::Display for Country {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "In {} are {} people and a GDP of ${}", // Then we can print them all with just {}
            self.name, self.population, self.gdp
        )
    }
}

fn main() {
    let nauru = Country::new("Nauru", 10_670, 160_000_000);
    let vanuatu = Country::new("Vanuatu", 307_815, 820_000_000);
    let micronesia = Country::new("Micronesia", 104_468, 367_000_000);

    // We could have given Country a &amp;str instead of a String for the name. But we would have to write lifetimes everywhere
    // and that would be too much for a small example. Better to just clone them when we call println!.
    println!("{}", nauru.clone());
    println!("{}", nauru.clone() + vanuatu.clone());
    println!("{}", nauru + vanuatu + micronesia);
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">In Nauru are 10670 people and a GDP of $160000000
In Nauru and Vanuatu are 318485 people and a GDP of $980000000
In Nauru and Vanuatu and Micronesia are 422953 people and a GDP of $1347000000
</code></pre>
<p>以后在这段代码中，我们可以把<code>.fmt()</code>改成更容易阅读的数字显示。</p>
<p>另外三个叫<code>Sub</code>、<code>Mul</code>和<code>Div</code>，实现起来基本一样。<code>+=</code>、<code>-=</code>、<code>*=</code>和<code>/=</code>，只要加上<code>Assign</code>:<code>AddAssign</code>、<code>SubAssign</code>、<code>MulAssign</code>和<code>DivAssign</code>即可。你可以看到完整的列表<a href="https://doc.rust-lang.org/std/ops/index.html#structs">这里</a>，因为还有很多。例如 <code>%</code> 被称为 <code>Rem</code>, <code>-</code> 被称为 <code>Neg</code>, 等等。</p>
<h3 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h3>
<p><code>f32</code>和<code>f64</code>有非常多的方法，你在做数学计算的时候会用到。我们不看这些，但这里有一些你可能会用到的方法。它们分别是 <code>.floor()</code>, <code>.ceil()</code>, <code>.round()</code>, 和 <code>.trunc()</code>. 所有这些方法都返回一个 <code>f32</code> 或 <code>f64</code>，它像一个整数，小数点后面是 <code>0</code>。它们是这样做的。</p>
<ul>
<li><code>.floor()</code>: 给你下一个最低的整数.</li>
<li><code>.ceil()</code>: 给你下一个最高的整数。</li>
<li><code>.round()</code>: 如果小数部分大于等于0.5，返回数值加1;如果小数部分小于0.5，返回相同数值。这就是所谓的四舍五入，因为它给你一个 "舍入"的数字(一个数字的简短形式)。</li>
<li><code>.trunc()</code>:只是把小数点号后的部分截掉。Truncate是 "截断"的意思。</li>
</ul>
<p>这里有一个简单的函数来打印它们。</p>
<pre><pre class="playground"><code class="language-rust">fn four_operations(input: f64) {
    println!(
"For the number {}:
floor: {}
ceiling: {}
rounded: {}
truncated: {}\n",
        input,
        input.floor(),
        input.ceil(),
        input.round(),
        input.trunc()
    );
}

fn main() {
    four_operations(9.1);
    four_operations(100.7);
    four_operations(-1.1);
    four_operations(-19.9);
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">For the number 9.1:
floor: 9
ceiling: 10
rounded: 9 // because less than 9.5
truncated: 9

For the number 100.7:
floor: 100
ceiling: 101
rounded: 101 // because more than 100.5
truncated: 100

For the number -1.1:
floor: -2
ceiling: -1
rounded: -1
truncated: -1

For the number -19.9:
floor: -20
ceiling: -19
rounded: -20
truncated: -19
</code></pre>
<p><code>f32</code> 和 <code>f64</code> 有一个叫做 <code>.max()</code> 和 <code>.min()</code> 的方法，可以得到两个数字中较大或较小的数字。(对于其他类型，你可以直接使用<code>std::cmp::max</code>和<code>std::cmp::min</code>。)下面是用<code>.fold()</code>来得到最高或最低数的方法。你又可以看到，<code>.fold()</code>不仅仅是用来加数字的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8.0_f64, 7.6, 9.4, 10.0, 22.0, 77.345, 10.22, 3.2, -7.77, -10.0];
    let maximum = my_vec.iter().fold(f64::MIN, |current_number, next_number| current_number.max(*next_number)); // Note: start with the lowest possible number for an f64.
    let minimum = my_vec.iter().fold(f64::MAX, |current_number, next_number| current_number.min(*next_number)); // And here start with the highest possible number
    println!("{}, {}", maximum, minimum);
}</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">bool</a></h3>
<p>在 Rust 中，如果你愿意，你可以把 <code>bool</code> 变成一个整数，因为这样做是安全的。但你不能反过来做。如你所见，<code>true</code>变成了1，<code>false</code>变成了0。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false = (true, false);
    println!("{} {}", true_false.0 as u8, true_false.1 as i32);
}</code></pre></pre>
<p>这将打印出<code>1 0</code>。如果你告诉编译器类型，也可以使用 <code>.into()</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false: (i128, u16) = (true.into(), false.into());
    println!("{} {}", true_false.0, true_false.1);
}</code></pre></pre>
<p>这打印的是一样的东西。</p>
<p>从Rust 1.50(2021年2月发布)开始，有一个叫做 <code>then()</code>的方法，它将一个 <code>bool</code>变成一个 <code>Option</code>。使用<code>then()</code>时需要一个闭包，如果item是<code>true</code>，闭包就会被调用。同时，无论从闭包中返回什么，都会进入<code>Option</code>中。下面是一个小例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let (tru, fals) = (true.then(|| 8), false.then(|| 8));
    println!("{:?}, {:?}", tru, fals);
}</code></pre></pre>
<p>这个打印 <code>Some(8), None</code>。</p>
<p>下面是一个较长的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let bool_vec = vec![true, false, true, false, false];

    let option_vec = bool_vec
        .iter()
        .map(|item| {
            item.then(|| { // Put this inside of map so we can pass it on
                println!("Got a {}!", item);
                "It's true, you know" // This goes inside Some if it's true
                                      // Otherwise it just passes on None
            })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Now we have: {:?}", option_vec);

    // That printed out the Nones too. Let's filter map them out in a new Vec.
    let filtered_vec = option_vec.into_iter().filter_map(|c| c).collect::&lt;Vec&lt;_&gt;&gt;();

    println!("And without the Nones: {:?}", filtered_vec);
}</code></pre></pre>
<p>将打印:</p>
<pre><code class="language-text">Got a true!
Got a true!
Now we have: [Some("It\'s true, you know"), None, Some("It\'s true, you know"), None, None]
And without the Nones: ["It\'s true, you know", "It\'s true, you know"]
</code></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<p>Vec有很多方法我们还没有看。先说说<code>.sort()</code>。<code>.sort()</code>一点都不奇怪。它使用<code>&amp;mut self</code>来对一个向量进行排序。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![100, 90, 80, 0, 0, 0, 0, 0];
    my_vec.sort();
    println!("{:?}", my_vec);
}</code></pre></pre>
<p>这样打印出来的是<code>[0, 0, 0, 0, 0, 80, 90, 100]</code>。但还有一种更有趣的排序方式叫<code>.sort_unstable()</code>，它通常更快。它之所以更快，是因为它不在乎排序前后相同数字的先后顺序。在常规的<code>.sort()</code>中，你知道最后的<code>0, 0, 0, 0, 0</code>会在<code>.sort()</code>之后的顺序相同。但是<code>.sort_unstable()</code>可能会把最后一个0移到索引0，然后把第三个最后的0移到索引2，等等。</p>
<p><code>.dedup()</code>的意思是 "去重复"。它将删除一个向量中相同的元素，但只有当它们彼此相邻时才会删除。接下来这段代码不会只打印<code>"sun", "moon"</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec!["sun", "sun", "moon", "moon", "sun", "moon", "moon"];
    my_vec.dedup();
    println!("{:?}", my_vec);
}</code></pre></pre>
<p>它只是把另一个 "sun"旁边的 "sun"去掉，然后把一个 "moon"旁边的 "moon"去掉，再把另一个 "moon"旁边的 "moon"去掉。结果是 <code>["sun", "moon", "sun", "moon"]</code>.</p>
<p>如果你想把每个重复的东西都去掉，就先<code>.sort()</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec!["sun", "sun", "moon", "moon", "sun", "moon", "moon"];
    my_vec.sort();
    my_vec.dedup();
    println!("{:?}", my_vec);
}</code></pre></pre>
<p>结果:<code>["moon", "sun"]</code>.</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>你会记得，<code>String</code>有点像<code>Vec</code>。它很像<code>Vec</code>，你可以调用很多相同的方法。比如说，你可以用<code>String::with_capacity()</code>创建一个，如果你需要多次用<code>.push()</code>推一个<code>char</code>，或者用<code>.push_str()</code>推一个<code>&amp;str</code>。下面是一个有多次内存分配的<code>String</code>的例子。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::new();
    let mut capacity_counter = 0; // capacity starts at 0
    for _ in 0..100_000 { // Do this 100,000 times
        if push_string.capacity() != capacity_counter { // First check if capacity is different now
            println!("{}", push_string.capacity()); // If it is, print it
            capacity_counter = push_string.capacity(); // then update the counter
        }
        push_string.push_str("I'm getting pushed into the string!"); // and push this in every time
    }
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">35
70
140
280
560
1120
2240
4480
8960
17920
35840
71680
143360
286720
573440
1146880
2293760
4587520
</code></pre>
<p>我们不得不重新分配(把所有东西复制过来)18次。但既然我们知道了最终的容量，我们可以马上设置容量，不需要重新分配:只设置一次<code>String</code>容量就够了。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520); // We know the exact number. Some different big number could work too
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!("{}", push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str("I'm getting pushed into the string!");
    }
}</code></pre></pre>
<p>而这个打印<code>4587520</code>。完美的! 我们再也不用分配了。</p>
<p>当然，实际长度肯定比这个小。如果你试了100001次，101000次等等，还是会说<code>4587520</code>。这是因为每次的容量都是之前的2倍。不过我们可以用<code>.shrink_to_fit()</code>来缩小它(和<code>Vec</code>一样)。我们的<code>String</code>已经非常大了，我们不想再给它增加任何东西，所以我们可以把它缩小一点。但是只有在你有把握的情况下才可以这样做:下面是原因。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520);
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!("{}", push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str("I'm getting pushed into the string!");
    }
    push_string.shrink_to_fit();
    println!("{}", push_string.capacity());
    push_string.push('a');
    println!("{}", push_string.capacity());
    push_string.shrink_to_fit();
    println!("{}", push_string.capacity());
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">4587520
3500000
7000000
3500001
</code></pre>
<p>所以首先我们的大小是<code>4587520</code>，但我们没有全部使用。我们用了<code>.shrink_to_fit()</code>，然后把大小降到了<code>3500000</code>。但是我们忘记了我们需要推上一个 <code>a</code>。当我们这样做的时候，Rust 看到我们需要更多的空间，给了我们双倍的空间:现在是 <code>7000000</code>。Whoops! 所以我们又调用了<code>.shrink_to_fit()</code>，现在又回到了<code>3500001</code>。</p>
<p><code>.pop()</code>对<code>String</code>有用，就像对<code>Vec</code>一样。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(".daer ot drah tib elttil a si gnirts sihT");
    loop {
        let pop_result = my_string.pop();
        match pop_result {
            Some(character) =&gt; print!("{}", character),
            None =&gt; break,
        }
    }
}</code></pre></pre>
<p>这打印的是<code>This string is a little bit hard to read.</code>，因为它是从最后一个字符开始的。</p>
<p><code>.retain()</code>是一个使用闭包的方法，这对<code>String</code>来说是罕见的。就像在迭代器上的<code>.filter()</code>一样。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from("Age: 20 Height: 194 Weight: 80");
    my_string.retain(|character| character.is_alphabetic() || character == ' '); // Keep if a letter or a space
    dbg!(my_string); // Let's use dbg!() for fun this time instead of println!
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">[src\main.rs:4] my_string = "Age  Height  Weight "
</code></pre>
<h3 id="osstring和cstring"><a class="header" href="#osstring和cstring">OsString和CString</a></h3>
<p><code>std::ffi</code>是<code>std</code>的一部分，它帮助你将Rust与其他语言或操作系统一起使用。它有<code>OsString</code>和<code>CString</code>这样的类型，它们就像操作系统的<code>String</code>或语言C的<code>String</code>一样，它们各自也有自己的<code>&amp;str</code>类型:<code>OsStr</code>和<code>CStr</code>。<code>ffi</code>的意思是 "foreign function interface"(外部函数接口)。</p>
<p>当你必须与一个没有Unicode的操作系统一起工作时，你可以使用<code>OsString</code>。所有的Rust字符串都是unicode，但不是每个操作系统支持。下面是标准库中关于为什么我们有<code>OsString</code>的简单英文解释。</p>
<ul>
<li>Unix系统(Linux等)上的字符串可能是很多没有0的字节组合在一起。而且有时你会把它们读成Unicode UTF-8。</li>
<li>Windows上的字符串可能是由随机的16位值组成的，没有0。有时你会把它们读成Unicode UTF-16。</li>
<li>在Rust中，字符串总是有效的UTF-8，其中可能包含0。</li>
</ul>
<p>所以，<code>OsString</code>被设计为支持它们读取。</p>
<p>你可以用一个<code>OsString</code>做所有常规的事情，比如<code>OsString::from("Write something here")</code>。它还有一个有趣的方法，叫做 <code>.into_string()</code>，试图把自己变成一个常规的 <code>String</code>。它返回一个 <code>Result</code>，但 <code>Err</code> 部分只是原来的 <code>OsString</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn into_string(self) -&gt; Result&lt;String, OsString&gt;
<span class="boring">}</span></code></pre></pre>
<p>所以如果不行的话，那你就把它找回来。你不能调用<code>.unwrap()</code>，因为它会崩溃，但是你可以使用<code>match</code>来找回<code>OsString</code>。我们通过调用不存在的方法来测试一下。</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::OsString;

fn main() {
    // ⚠️
    let os_string = OsString::from("This string works for your OS too.");
    match os_string.into_string() {
        Ok(valid) =&gt; valid.thth(),           // Compiler: "What's .thth()??"
        Err(not_valid) =&gt; not_valid.occg(),  // Compiler: "What's .occg()??"
    }
}</code></pre></pre>
<p>然后编译器准确地告诉我们我们想知道的东西。</p>
<pre><code class="language-text">error[E0599]: no method named `thth` found for struct `std::string::String` in the current scope
 --&gt; src/main.rs:6:28
  |
6 |         Ok(valid) =&gt; valid.thth(),
  |                            ^^^^ method not found in `std::string::String`

error[E0599]: no method named `occg` found for struct `std::ffi::OsString` in the current scope
 --&gt; src/main.rs:7:37
  |
7 |         Err(not_valid) =&gt; not_valid.occg(),
  |                                     ^^^^ method not found in `std::ffi::OsString`
</code></pre>
<p>我们可以看到，<code>valid</code>的类型是<code>String</code>，<code>not_valid</code>的类型是<code>OsString</code>。</p>
<h3 id="mem"><a class="header" href="#mem">Mem</a></h3>
<p><code>std::mem</code>有一些非常有趣的方法。我们已经看到了一些，比如<code>.size_of()</code>、<code>.size_of_val()</code>和<code>.drop()</code>。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    println!("{}", mem::size_of::&lt;i32&gt;());
    let my_array = [8; 50];
    println!("{}", mem::size_of_val(&amp;my_array));
    let mut some_string = String::from("You can drop a String because it's on the heap");
    mem::drop(some_string);
    // some_string.clear();   If we did this it would panic
}</code></pre></pre>
<p>这个打印:</p>
<pre><code class="language-text">4
200
</code></pre>
<p>下面是<code>mem</code>中的一些其他方法。</p>
<p><code>swap()</code>: 用这个方法你可以交换两个变量之间的值。你可以通过为每个变量创建一个可变引用来做。当你有两个东西想交换，而Rust因为借用规则不让你交换时，这很有帮助。或者只是当你想快速切换两个东西的时候。</p>
<p>这里有一个例子。</p>
<pre><pre class="playground"><code class="language-rust">use std::{mem, fmt};

struct Ring { // Create a ring from Lord of the Rings
    owner: String,
    former_owner: String,
    seeker: String, // seeker means "person looking for it"
}

impl Ring {
    fn new(owner: &amp;str, former_owner: &amp;str, seeker: &amp;str) -&gt; Self {
        Self {
            owner: owner.to_string(),
            former_owner: former_owner.to_string(),
            seeker: seeker.to_string(),
        }
    }
}

impl fmt::Display for Ring { // Display to show who has it and who wants it
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "{} has the ring, {} used to have it, and {} wants it", self.owner, self.former_owner, self.seeker)
        }
}

fn main() {
    let mut one_ring = Ring::new("Frodo", "Gollum", "Sauron");
    println!("{}", one_ring);
    mem::swap(&amp;mut one_ring.owner, &amp;mut one_ring.former_owner); // Gollum got the ring back for a second
    println!("{}", one_ring);
}</code></pre></pre>
<p>这将打印:</p>
<pre><code class="language-text">Frodo has the ring, Gollum used to have it, and Sauron wants it
Gollum has the ring, Frodo used to have it, and Sauron wants it
</code></pre>
<p><code>replace()</code>:这个就像swap一样，其实里面也用了swap，你可以看到。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn replace&lt;T&gt;(dest: &amp;mut T, mut src: T) -&gt; T {
    swap(dest, &amp;mut src);
    src
}
<span class="boring">}</span></code></pre></pre>
<p>所以它只是做了一个交换，然后返回另一个元素。有了这个，你就用你放进去的其他东西来替换这个值。因为它返回的是旧的值，所以你应该用<code>let</code>来使用它。下面是一个简单的例子。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct City {
    name: String,
}

impl City {
    fn change_name(&amp;mut self, name: &amp;str) {
        let old_name = mem::replace(&amp;mut self.name, name.to_string());
        println!(
            "The city once called {} is now called {}.",
            old_name, self.name
        );
    }
}

fn main() {
    let mut capital_city = City {
        name: "Constantinople".to_string(),
    };
    capital_city.change_name("Istanbul");
}</code></pre></pre>
<p>这样就会打印出<code>The city once called Constantinople is now called Istanbul.</code>。</p>
<p>有一个函数叫<code>.take()</code>，和<code>.replace()</code>一样，但它在元素中留下了默认值。
你会记得，默认值通常是0、""之类的东西。这里是签名。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 🚧
pub fn take&lt;T&gt;(dest: &amp;mut T) -&gt; T
where
    T: Default,
<span class="boring">}</span></code></pre></pre>
<p>所以你可以做这样的事情。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    let mut number_vec = vec![8, 7, 0, 2, 49, 9999];
    let mut new_vec = vec![];

    number_vec.iter_mut().for_each(|number| {
        let taker = mem::take(number);
        new_vec.push(taker);
    });

    println!("{:?}\n{:?}", number_vec, new_vec);
}</code></pre></pre>
<p>你可以看到，它将所有数字都替换为0:没有删除任何索引。</p>
<pre><code class="language-text">[0, 0, 0, 0, 0, 0]
[8, 7, 0, 2, 49, 9999]
</code></pre>
<p>当然，对于你自己的类型，你可以把<code>Default</code>实现成任何你想要的类型。我们来看一个例子，我们有一个<code>Bank</code>和一个<code>Robber</code>。每次他抢了<code>Bank</code>，他就会在桌子上拿到钱。但是办公桌可以随时从后面拿钱，所以它永远有50。我们将为此自制一个类型，所以它将永远有50。下面是它的工作原理。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
use std::ops::{Deref, DerefMut}; // We will use this to get the power of u32

struct Bank {
    money_inside: u32,
    money_at_desk: DeskMoney, // This is our "smart pointer" type. It has its own default, but it will use u32
}

struct DeskMoney(u32);

impl Default for DeskMoney {
    fn default() -&gt; Self {
        Self(50) // default is always 50, not 0
    }
}

impl Deref for DeskMoney { // With this we can access the u32 using *
    type Target = u32;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for DeskMoney { // And with this we can add, subtract, etc.
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

impl Bank {
    fn check_money(&amp;self) {
        println!(
            "There is ${} in the back and ${} at the desk.\n",
            self.money_inside, *self.money_at_desk // Use * so we can just print the u32
        );
    }
}

struct Robber {
    money_in_pocket: u32,
}

impl Robber {
    fn check_money(&amp;self) {
        println!("The robber has ${} right now.\n", self.money_in_pocket);
    }

    fn rob_bank(&amp;mut self, bank: &amp;mut Bank) {
        let new_money = mem::take(&amp;mut bank.money_at_desk); // Here it takes the money, and leaves 50 because that is the default
        self.money_in_pocket += *new_money; // Use * because we can only add u32. DeskMoney can't add
        bank.money_inside -= *new_money;    // Same here
        println!("She robbed the bank. She now has ${}!\n", self.money_in_pocket);
    }
}

fn main() {
    let mut bank_of_klezkavania = Bank { // Set up our bank
        money_inside: 5000,
        money_at_desk: DeskMoney(50),
    };
    bank_of_klezkavania.check_money();

    let mut robber = Robber { // Set up our robber
        money_in_pocket: 50,
    };
    robber.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Rob, then check money
    robber.check_money();
    bank_of_klezkavania.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Do it again
    robber.check_money();
    bank_of_klezkavania.check_money();

}</code></pre></pre>
<p>这将打印:</p>
<pre><code class="language-text">There is $5000 in the back and $50 at the desk.

The robber has $50 right now.

She robbed the bank. She now has $100!

The robber has $100 right now.

There is $4950 in the back and $50 at the desk.

She robbed the bank. She now has $150!

The robber has $150 right now.

There is $4900 in the back and $50 at the desk.
</code></pre>
<p>你可以看到桌子上总是有50美元。</p>
<h3 id="prelude"><a class="header" href="#prelude">Prelude</a></h3>
<p>标准库也有一个prelude，这就是为什么你不用写<code>use std::vec::Vec</code>这样的东西来创建一个<code>Vec</code>。你可以<a href="https://doc.rust-lang.org/std/prelude/index.html#prelude-contents">在这里</a>看到所有这些元素，并且大致了解:</p>
<ul>
<li><code>std::marker::{Copy, Send, Sized, Sync, Unpin}</code>. 你以前没有见过<code>Unpin</code>，因为几乎每一种类型都会用到它(比如<code>Sized</code>，也很常见)。"Pin"的意思是不让东西动。在这种情况下，<code>Pin</code>意味着它在内存中不能移动，但大多数元素都有<code>Unpin</code>，所以你可以移动。这就是为什么像<code>std::mem::replace</code>这样的函数能用，因为它们没有被钉住。</li>
<li><code>std::ops::{Drop, Fn, FnMut, FnOnce}</code>.</li>
<li><code>std::mem::drop</code></li>
<li><code>std::boxed::Box</code>.</li>
<li><code>std::borrow::ToOwned</code>. 你之前用<code>Cow</code>看到过一点，它可以把借来的内容变成自己的。它使用<code>.to_owned()</code>来实现这个功能。你也可以在<code>&amp;str</code>上使用<code>.to_owned()</code>，得到一个<code>String</code>，对于其他借来的值也是一样。</li>
<li><code>std::clone::Clone</code></li>
<li><code>std::cmp::{PartialEq, PartialOrd, Eq, Ord}</code>.</li>
<li><code>std::convert::{AsRef, AsMut, Into, From}</code>.</li>
<li><code>std::default::Default</code>.</li>
<li><code>std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}</code>. 我们之前用<code>.rev()</code>来做迭代器:这实际上是做了一个<code>DoubleEndedIterator</code>。<code>ExactSizeIterator</code>只是类似于<code>0..10</code>的东西:它已经知道自己的<code>.len()</code>是10。其他迭代器不知道它们的长度是肯定的。</li>
<li><code>std::option::Option::{self, Some, None}</code>.</li>
<li><code>std::result::Result::{self, Ok, Err}</code>.</li>
<li><code>std::string::{String, ToString}</code>.</li>
<li><code>std::vec::Vec</code>.</li>
</ul>
<p>如果你因为某些原因不想要这个prelude怎么办？就加属性<code>#![no_implicit_prelude]</code>。我们来试一试，看编译器的抱怨。</p>
<pre><pre class="playground"><code class="language-rust">// ⚠️
#![no_implicit_prelude]
fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from("This won't work");
    println!("{:?}, {}", my_vec, my_string);
}</code></pre></pre>
<p>现在Rust根本不知道你想做什么。</p>
<pre><code class="language-text">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:5:5
  |
5 |     println!("{:?}, {}", my_vec, my_string);
  |     ^^^^^^^

error: cannot find macro `vec` in this scope
 --&gt; src/main.rs:3:18
  |
3 |     let my_vec = vec![8, 9, 10];
  |                  ^^^

error[E0433]: failed to resolve: use of undeclared type or module `String`
 --&gt; src/main.rs:4:21
  |
4 |     let my_string = String::from("This won't work");
  |                     ^^^^^^ use of undeclared type or module `String`

error: aborting due to 3 previous errors
</code></pre>
<p>因此，对于这个简单的代码，你需要告诉Rust使用<code>extern</code>(外部)crate，叫做<code>std</code>，然后是你想要的元素。这里是我们要做的一切，只是为了创建一个Vec和一个String，并打印它。</p>
<pre><pre class="playground"><code class="language-rust">#![no_implicit_prelude]

extern crate std; // Now you have to tell Rust that you want to use a crate called std
use std::vec; // We need the vec macro
use std::string::String; // and string
use std::convert::From; // and this to convert from a &amp;str to the String
use std::println; // and this to print

fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from("This won't work");
    println!("{:?}, {}", my_vec, my_string);
}</code></pre></pre>
<p>现在终于成功了，打印出<code>[8, 9, 10], This won't work</code>。所以你可以明白为什么Rust要用prelude了。但如果你愿意，你不需要使用它。而且你甚至可以使用<code>#![no_std]</code>(我们曾经看到过)，用于你连堆栈内存这种东西都用不上的时候。但大多数时候，你根本不用考虑不用prelude或<code>std</code>。</p>
<p>那么为什么之前我们没有看到<code>extern</code>这个关键字呢？是因为你已经不需要它了。以前，当带入外部crate时，你必须使用它。所以以前要使用<code>rand</code>，你必须要写成:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate rand;
<span class="boring">}</span></code></pre></pre>
<p>然后用 <code>use</code> 语句来表示你想使用的修改、trait等。但现在Rust编译器已经不需要这些帮助了--你只需要使用<code>use</code>，rust就知道在哪里可以找到它。所以你几乎再也不需要<code>extern crate</code>了，但在其他人的Rust代码中，你可能仍然会在顶部看到它。</p>
<h3 id="time"><a class="header" href="#time">Time</a></h3>
<p><code>std::time</code>是你可以找到时间函数的地方。(如果你想要更多的功能，<code>chrono</code>这样的crate也可以。)最简单的功能就是用<code>Instant::now()</code>获取系统时间即可。</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time = Instant::now();
    println!("{:?}", time);
}</code></pre></pre>
<p>如果你打印出来，你会得到这样的东西。<code>Instant { tv_sec: 2738771, tv_nsec: 685628140 }</code>. 这说的是秒和纳秒，但用处不大。比如你看2738771秒(写于8月)，就是31.70天。这和月份、日子没有任何关系。但是<code>Instant</code>的页面告诉我们，它本身不应该有用。它说它是 "不透明的，只有和Duration一起才有用"。Opaque的意思是 "你搞不清楚"，而Duration的意思是 "过了多少时间"。所以它只有在做比较时间这样的事情时才有用。</p>
<p>如果你看左边的trait，其中一个是<code>Sub&lt;Instant&gt;</code>。也就是说我们可以用<code>-</code>来减去一个。而当我们点击[src]看它的作用时，页面显示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sub&lt;Instant&gt; for Instant {
    type Output = Duration;

    fn sub(self, other: Instant) -&gt; Duration {
        self.duration_since(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，它需要一个<code>Instant</code>，并使用<code>.duration_since()</code>给出一个<code>Duration</code>。让我们试着打印一下。我们将创建两个相邻的 <code>Instant::now()</code>，然后让程序忙活一会儿，再创建一个 <code>Instant::now()</code>。然后我们再创建一个<code>Instant::now()</code>. 最后，我们来看看用了多长时间。</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = Instant::now();
    let time2 = Instant::now(); // These two are right next to each other

    let mut new_string = String::new();
    loop {
        new_string.push('წ'); // Make Rust push this Georgian letter onto the String
        if new_string.len() &gt; 100_000 { //  until it is 100,000 bytes long
            break;
        }
    }
    let time3 = Instant::now();
    println!("{:?}", time2 - time1);
    println!("{:?}", time3 - time1);
}</code></pre></pre>
<p>这将打印出这样的东西。</p>
<pre><code class="language-text">1.025µs
683.378µs
</code></pre>
<p>所以，这只是1微秒多与683毫秒。我们可以看到，Rust确实花了一些时间来做。</p>
<p>不过我们可以用一个<code>Instant</code>做一件有趣的事情。
我们可以把它变成<code>String</code>与<code>format!("{:?}", Instant::now());</code>。它的样子是这样的:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = format!("{:?}", Instant::now());
    println!("{}", time1);
}</code></pre></pre>
<p>这样就会打印出类似<code>Instant { tv_sec: 2740773, tv_nsec: 632821036 }</code>的东西。这是没有用的，但是如果我们使用 <code>.iter()</code> 和 <code>.rev()</code> 以及 <code>.skip(2)</code>，我们可以跳过最后的 <code>}</code> 和 <code> </code>。我们可以用它来创建一个随机数发生器。</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn bad_random_number(digits: usize) {
    if digits &gt; 9 {
        panic!("Random number can only be up to 9 digits");
    }
    let now = Instant::now();
    let output = format!("{:?}", now);

    output
        .chars()
        .rev()
        .skip(2)
        .take(digits)
        .for_each(|character| print!("{}", character));
    println!();
}

fn main() {
    bad_random_number(1);
    bad_random_number(1);
    bad_random_number(3);
    bad_random_number(3);
}</code></pre></pre>
<p>这样就会打印出类似这样的内容:</p>
<pre><code class="language-text">6
4
967
180
</code></pre>
<p>这个函数被称为<code>bad_random_number</code>，因为它不是一个很好的随机数生成器。Rust有更好的crate，可以用比<code>rand</code>更少的代码创建随机数，比如<code>fastrand</code>。但这是一个很好的例子，你可以利用你的想象力用<code>Instant</code>来做一些事情。</p>
<p>当你有一个线程时，你可以使用<code>std::thread::sleep</code>使它停止一段时间。当你这样做时，你必须给它一个duration。你不必创建多个线程来做这件事，因为每个程序至少在一个线程上。<code>sleep</code>虽然需要一个<code>Duration</code>，所以它可以知道要睡多久。你可以这样选单位:<code>Duration::from_millis()</code>, <code>Duration::from_secs</code>, 等等。这里举一个例子:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use std::thread::sleep;

fn main() {
    let three_seconds = Duration::from_secs(3);
    println!("I must sleep now.");
    sleep(three_seconds);
    println!("Did I miss anything?");
}</code></pre></pre>
<p>这将只打印</p>
<pre><code class="language-text">I must sleep now.
Did I miss anything?
</code></pre>
<p>但线程在三秒钟内什么也不做。当你有很多线程需要经常尝试一些事情时，比如连接，你通常会使用<code>.sleep()</code>。你不希望线程在一秒钟内使用你的处理器尝试10万次，而你只是想让它有时检查一下。所以，你就可以设置一个<code>Duration</code>，它就会在每次醒来的时候尝试做它的任务。</p>
<h3 id="其他宏"><a class="header" href="#其他宏">其他宏</a></h3>
<p>我们再来看看其他一些宏。</p>
<p><code>unreachable!()</code></p>
<p>这个宏有点像<code>todo!()</code>，除了它是针对你永远不会用的代码。也许你在一个枚举中有一个<code>match</code>，你知道它永远不会选择其中的一个分支，所以代码永远无法达到那个分支。如果是这样，你可以写<code>unreachable!()</code>，这样编译器就知道可以忽略这部分。</p>
<p>例如，假设你有一个程序，当你选择一个地方居住时，它会写一些东西。在乌克兰，除了切尔诺贝利，其他地方都不错。你的程序不让任何人选择切尔诺贝利，因为它现在不是一个好地方。但是这个枚举是很早以前在别人的代码里做的，你无法更改。所以在<code>match</code>的分支中，你可以用这个宏。它是这样的:</p>
<pre><pre class="playground"><code class="language-rust">enum UkrainePlaces {
    Kiev,
    Kharkiv,
    Chernobyl, // Pretend we can't change the enum - Chernobyl will always be here
    Odesa,
    Dnipro,
}

fn choose_city(place: &amp;UkrainePlaces) {
    use UkrainePlaces::*;
    match place {
        Kiev =&gt; println!("You will live in Kiev"),
        Kharkiv =&gt; println!("You will live in Kharkiv"),
        Chernobyl =&gt; unreachable!(),
        Odesa =&gt; println!("You will live in Odesa"),
        Dnipro =&gt; println!("You will live in Dnipro"),
    }
}

fn main() {
    let user_input = UkrainePlaces::Kiev; // Pretend the user input is made from some other function. The user can't choose Chernobyl, no matter what
    choose_city(&amp;user_input);
}</code></pre></pre>
<p>这将打印出 <code>You will live in Kiev</code>。</p>
<p><code>unreachable!()</code>对你来说也很好读，因为它提醒你代码的某些部分是不可访问的。不过你必须确定代码确实是不可访问的。如果编译器调用<code>unreachable!()</code>，程序就会崩溃。</p>
<p>此外，如果你曾经有不可达的代码，而编译器知道，它会告诉你。下面是一个简单的例子:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_or_false = true;

    match true_or_false {
        true =&gt; println!("It's true"),
        false =&gt; println!("It's false"),
        true =&gt; println!("It's true"), // Whoops, we wrote true again
    }
}</code></pre></pre>
<p>它会说</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; src/main.rs:7:9
  |
7 |         true =&gt; println!("It's true"),
  |         ^^^^
  |
</code></pre>
<p>但是<code>unreachable!()</code>是用于编译器无法知道的时候，就像我们另一个例子。</p>
<p><code>column!</code>, <code>line!</code>, <code>file!</code>, <code>module_path!</code></p>
<p>这四个宏有点像<code>dbg!()</code>，因为你只是把它们放进代码去给你调试信息。但是它们不需要任何变量--你只需要用它们和括号一起使用，而没有其他的东西。它们放到一起很容易学:</p>
<ul>
<li><code>column!()</code>给你写的那一列</li>
<li><code>file!()</code>给你写的文件的名称</li>
<li><code>line!()</code>给你写的那行字，然后是</li>
<li><code>module_path!()</code>给你模块的位置。</li>
</ul>
<p>接下来的代码在一个简单的例子中展示了这三者。我们将假装有更多的代码(mod里面的mod)，因为这就是我们要使用这些宏的原因。你可以想象一个大的Rust程序,它有许多mod和文件。</p>
<pre><pre class="playground"><code class="language-rust">pub mod something {
    pub mod third_mod {
        pub fn print_a_country(input: &amp;mut Vec&lt;&amp;str&gt;) {
            println!(
                "The last country is {} inside the module {}",
                input.pop().unwrap(),
                module_path!()
            );
        }
    }
}

fn main() {
    use something::third_mod::*;
    let mut country_vec = vec!["Portugal", "Czechia", "Finland"];

    // do some stuff
    println!("Hello from file {}", file!());

    // do some stuff
    println!(
        "On line {} we got the country {}",
        line!(),
        country_vec.pop().unwrap()
    );

    // do some more stuff

    println!(
        "The next country is {} on line {} and column {}.",
        country_vec.pop().unwrap(),
        line!(),
        column!(),
    );

    // lots more code

    print_a_country(&amp;mut country_vec);
}</code></pre></pre>
<p>它打印的是这样的。</p>
<pre><code class="language-text">Hello from file src/main.rs
On line 23 we got the country Finland
The next country is Czechia on line 32 and column 9.
The last country is Portugal inside the module rust_book::something::third_mod
</code></pre>
<p><code>cfg!</code></p>
<p>我们知道，你可以使用 <code>#[cfg(test)]</code> 和 <code>#[cfg(windows)]</code> 这样的属性来告诉编译器在某些情况下该怎么做。当你有<code>test</code>时，当你在测试模式下运行Rust时，它会运行代码(如果是在电脑上，你输入<code>cargo test</code>)。而当你使用<code>windows</code>时，如果用户使用的是Windows，它就会运行代码。但也许你只是想根据不同操作系统对依赖系统的代码做很小的修改。这时候这个宏就很有用了。它返回一个<code>bool</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let helpful_message = if cfg!(target_os = "windows") { "backslash" } else { "slash" };

    println!(
        "...then in your hard drive, type the directory name followed by a {}. Then you...",
        helpful_message
    );
}</code></pre></pre>
<p>这将以不同的方式打印，取决于你的系统。Rust Playground在Linux上运行，所以会打印:</p>
<pre><code class="language-text">...then in your hard drive, type the directory name followed by a slash. Then you...
</code></pre>
<p><code>cfg!()</code>适用于任何一种配置。下面是一个例子，当你在测试中使用一个函数时，它的运行方式会有所不同。</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)] // cfg! will know to look for the word test
mod testing {
    use super::*;
    #[test]
    fn check_if_five() {
        assert_eq!(bring_number(true), 5); // This bring_number() function should return 5
    }
}

fn bring_number(should_run: bool) -&gt; u32 { // This function takes a bool as to whether it should run
    if cfg!(test) &amp;&amp; should_run { // if it should run and has the configuration test, return 5
        5
    } else if should_run { // if it's not a test but it should run, print something. When you run a test it ignores println! statements
        println!("Returning 5. This is not a test");
        5
    } else {
        println!("This shouldn't run, returning 0."); // otherwise return 0
        0
    }
}

fn main() {
    bring_number(true);
    bring_number(false);
}</code></pre></pre>
<p>现在根据配置的不同，它的运行方式也会不同。如果你只是运行程序，它会给你这样的结果:</p>
<pre><code class="language-text">Returning 5. This is not a test
This shouldn't run, returning 0.
</code></pre>
<p>但如果你在测试模式下运行它(<code>cargo test</code>，用于电脑上的Rust)，它实际上会运行测试。因为在这种情况下，测试总是返回5，所以它会通过。</p>
<pre><code class="language-text">running 1 test
test testing::check_if_five ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_59.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Chapter_61.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_59.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Chapter_61.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
