<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Rust ü¶Ä</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
                data-autoload-cookie-consent-bar="true"></script>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZN78TEJMRW');
        </script>
        
<script>
          (function () {
              // See these pages for details:
              // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
              // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
              let base = "https://google.github.io/comprehensive-rust";
      let canonical_href = `${base}/print.md`;

              // mdbook gives us a string ending in ".md", we replace it with ".html":
              canonical_href = canonical_href.slice(0, -"md".length) + "html";
              if (canonical_href.endsWith("/index.html")) {
                  canonical_href = canonical_href.slice(0, -"index.html".length);
              }
        
              let link = document.createElement("link");
              link.rel = "canonical";
              link.href = canonical_href;
              document.head.appendChild(link);
          })()
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/svgbob.css">
        <link rel="stylesheet" href="theme/css/redbox.css">
        <link rel="stylesheet" href="theme/css/speaker-notes.css">
        <link rel="stylesheet" href="theme/css/language-picker.css">
        <link rel="stylesheet" href="theme/css/rtl.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Welcome to Comprehensive Rust ü¶Ä</a></li><li class="chapter-item "><a href="running-the-course.html"><strong aria-hidden="true">1.</strong> Running the Course</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.1.</strong> Course Structure</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">1.2.</strong> Keyboard Shortcuts</a></li><li class="chapter-item "><a href="running-the-course/translations.html"><strong aria-hidden="true">1.3.</strong> Translations</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">2.</strong> Using Cargo</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">2.1.</strong> Rust Ecosystem</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">2.2.</strong> Code Samples</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">2.3.</strong> Running Cargo Locally</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">Day 1: Morning</li><li class="chapter-item "><a href="welcome-day-1.html"><strong aria-hidden="true">3.</strong> Welcome</a></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">4.</strong> Hello, World</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/what-is-rust.html"><strong aria-hidden="true">4.1.</strong> What is Rust?</a></li><li class="chapter-item "><a href="hello-world/benefits.html"><strong aria-hidden="true">4.2.</strong> Benefits of Rust</a></li><li class="chapter-item "><a href="hello-world/playground.html"><strong aria-hidden="true">4.3.</strong> Playground</a></li></ol></li><li class="chapter-item "><a href="types-and-values.html"><strong aria-hidden="true">5.</strong> Types and Values</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types-and-values/hello-world.html"><strong aria-hidden="true">5.1.</strong> Hello, World</a></li><li class="chapter-item "><a href="types-and-values/variables.html"><strong aria-hidden="true">5.2.</strong> Variables</a></li><li class="chapter-item "><a href="types-and-values/values.html"><strong aria-hidden="true">5.3.</strong> Values</a></li><li class="chapter-item "><a href="types-and-values/arithmetic.html"><strong aria-hidden="true">5.4.</strong> Arithmetic</a></li><li class="chapter-item "><a href="types-and-values/inference.html"><strong aria-hidden="true">5.5.</strong> Type Inference</a></li><li class="chapter-item "><a href="types-and-values/exercise.html"><strong aria-hidden="true">5.6.</strong> Exercise: Fibonacci</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types-and-values/solution.html"><strong aria-hidden="true">5.6.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="control-flow-basics.html"><strong aria-hidden="true">6.</strong> Control Flow Basics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/if.html"><strong aria-hidden="true">6.1.</strong> if Expressions</a></li><li class="chapter-item "><a href="control-flow-basics/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/loops/for.html"><strong aria-hidden="true">6.2.1.</strong> for</a></li><li class="chapter-item "><a href="control-flow-basics/loops/loop.html"><strong aria-hidden="true">6.2.2.</strong> loop</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/break-continue.html"><strong aria-hidden="true">6.3.</strong> break and continue</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/break-continue/labels.html"><strong aria-hidden="true">6.3.1.</strong> Labels</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/blocks-and-scopes.html"><strong aria-hidden="true">6.4.</strong> Blocks and Scopes</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/blocks-and-scopes/scopes.html"><strong aria-hidden="true">6.4.1.</strong> Scopes and Shadowing</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/functions.html"><strong aria-hidden="true">6.5.</strong> Functions</a></li><li class="chapter-item "><a href="control-flow-basics/macros.html"><strong aria-hidden="true">6.6.</strong> Macros</a></li><li class="chapter-item "><a href="control-flow-basics/exercise.html"><strong aria-hidden="true">6.7.</strong> Exercise: Collatz Sequence</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/solution.html"><strong aria-hidden="true">6.7.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 1: Afternoon</li><li class="chapter-item "><a href="welcome-day-1-afternoon.html"><strong aria-hidden="true">7.</strong> Welcome</a></li><li class="chapter-item "><a href="tuples-and-arrays.html"><strong aria-hidden="true">8.</strong> Tuples and Arrays</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tuples-and-arrays/arrays.html"><strong aria-hidden="true">8.1.</strong> Arrays</a></li><li class="chapter-item "><a href="tuples-and-arrays/tuples.html"><strong aria-hidden="true">8.2.</strong> Tuples</a></li><li class="chapter-item "><a href="tuples-and-arrays/iteration.html"><strong aria-hidden="true">8.3.</strong> Array Iteration</a></li><li class="chapter-item "><a href="tuples-and-arrays/destructuring.html"><strong aria-hidden="true">8.4.</strong> Patterns and Destructuring</a></li><li class="chapter-item "><a href="tuples-and-arrays/exercise.html"><strong aria-hidden="true">8.5.</strong> Exercise: Nested Arrays</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tuples-and-arrays/solution.html"><strong aria-hidden="true">8.5.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="references.html"><strong aria-hidden="true">9.</strong> References</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/shared.html"><strong aria-hidden="true">9.1.</strong> Shared References</a></li><li class="chapter-item "><a href="references/exclusive.html"><strong aria-hidden="true">9.2.</strong> Exclusive References</a></li><li class="chapter-item "><a href="references/slices.html"><strong aria-hidden="true">9.3.</strong> Slices: &[T]</a></li><li class="chapter-item "><a href="references/strings.html"><strong aria-hidden="true">9.4.</strong> Strings</a></li><li class="chapter-item "><a href="references/exercise.html"><strong aria-hidden="true">9.5.</strong> Exercise: Geometry</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/solution.html"><strong aria-hidden="true">9.5.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="user-defined-types.html"><strong aria-hidden="true">10.</strong> User-Defined Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-defined-types/named-structs.html"><strong aria-hidden="true">10.1.</strong> Named Structs</a></li><li class="chapter-item "><a href="user-defined-types/tuple-structs.html"><strong aria-hidden="true">10.2.</strong> Tuple Structs</a></li><li class="chapter-item "><a href="user-defined-types/enums.html"><strong aria-hidden="true">10.3.</strong> Enums</a></li><li class="chapter-item "><a href="user-defined-types/static.html"><strong aria-hidden="true">10.4.</strong> Static</a></li><li class="chapter-item "><a href="user-defined-types/const.html"><strong aria-hidden="true">10.5.</strong> Const</a></li><li class="chapter-item "><a href="user-defined-types/aliases.html"><strong aria-hidden="true">10.6.</strong> Type Aliases</a></li><li class="chapter-item "><a href="user-defined-types/exercise.html"><strong aria-hidden="true">10.7.</strong> Exercise: Elevator Events</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-defined-types/solution.html"><strong aria-hidden="true">10.7.1.</strong> Solution</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 2: Morning</li><li class="chapter-item "><a href="welcome-day-2.html"><strong aria-hidden="true">11.</strong> Welcome</a></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">12.</strong> Pattern Matching</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/match.html"><strong aria-hidden="true">12.1.</strong> Matching Values</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">12.2.</strong> Destructuring Structs</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">12.3.</strong> Destructuring Enums</a></li><li class="chapter-item "><a href="pattern-matching/let-control-flow.html"><strong aria-hidden="true">12.4.</strong> Let Control Flow</a></li><li class="chapter-item "><a href="pattern-matching/exercise.html"><strong aria-hidden="true">12.5.</strong> Exercise: Expression Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/solution.html"><strong aria-hidden="true">12.5.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="methods-and-traits.html"><strong aria-hidden="true">13.</strong> Methods and Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/methods.html"><strong aria-hidden="true">13.1.</strong> Methods</a></li><li class="chapter-item "><a href="methods-and-traits/traits.html"><strong aria-hidden="true">13.2.</strong> Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/traits/implementing.html"><strong aria-hidden="true">13.2.1.</strong> Implementing Traits</a></li><li class="chapter-item "><a href="methods-and-traits/traits/supertraits.html"><strong aria-hidden="true">13.2.2.</strong> Supertraits</a></li><li class="chapter-item "><a href="methods-and-traits/traits/associated-types.html"><strong aria-hidden="true">13.2.3.</strong> Associated Types</a></li></ol></li><li class="chapter-item "><a href="methods-and-traits/deriving.html"><strong aria-hidden="true">13.3.</strong> Deriving</a></li><li class="chapter-item "><a href="methods-and-traits/exercise.html"><strong aria-hidden="true">13.4.</strong> Exercise: Generic Logger</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/solution.html"><strong aria-hidden="true">13.4.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 2: Afternoon</li><li class="chapter-item "><a href="welcome-day-2-afternoon.html"><strong aria-hidden="true">14.</strong> Welcome</a></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">15.</strong> Generics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/generic-functions.html"><strong aria-hidden="true">15.1.</strong> Generic Functions</a></li><li class="chapter-item "><a href="generics/generic-data.html"><strong aria-hidden="true">15.2.</strong> Generic Data Types</a></li><li class="chapter-item "><a href="generics/generic-traits.html"><strong aria-hidden="true">15.3.</strong> Generic Traits</a></li><li class="chapter-item "><a href="generics/trait-bounds.html"><strong aria-hidden="true">15.4.</strong> Trait Bounds</a></li><li class="chapter-item "><a href="generics/impl-trait.html"><strong aria-hidden="true">15.5.</strong> impl Trait</a></li><li class="chapter-item "><a href="generics/dyn-trait.html"><strong aria-hidden="true">15.6.</strong> dyn Trait</a></li><li class="chapter-item "><a href="generics/exercise.html"><strong aria-hidden="true">15.7.</strong> Exercise: Generic min</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/solution.html"><strong aria-hidden="true">15.7.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="std-types.html"><strong aria-hidden="true">16.</strong> Standard Library Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-types/std.html"><strong aria-hidden="true">16.1.</strong> Standard Library</a></li><li class="chapter-item "><a href="std-types/docs.html"><strong aria-hidden="true">16.2.</strong> Documentation</a></li><li class="chapter-item "><a href="std-types/option.html"><strong aria-hidden="true">16.3.</strong> Option</a></li><li class="chapter-item "><a href="std-types/result.html"><strong aria-hidden="true">16.4.</strong> Result</a></li><li class="chapter-item "><a href="std-types/string.html"><strong aria-hidden="true">16.5.</strong> String</a></li><li class="chapter-item "><a href="std-types/vec.html"><strong aria-hidden="true">16.6.</strong> Vec</a></li><li class="chapter-item "><a href="std-types/hashmap.html"><strong aria-hidden="true">16.7.</strong> HashMap</a></li><li class="chapter-item "><a href="std-types/exercise.html"><strong aria-hidden="true">16.8.</strong> Exercise: Counter</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-types/solution.html"><strong aria-hidden="true">16.8.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="std-traits.html"><strong aria-hidden="true">17.</strong> Standard Library Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-traits/comparisons.html"><strong aria-hidden="true">17.1.</strong> Comparisons</a></li><li class="chapter-item "><a href="std-traits/operators.html"><strong aria-hidden="true">17.2.</strong> Operators</a></li><li class="chapter-item "><a href="std-traits/from-and-into.html"><strong aria-hidden="true">17.3.</strong> From and Into</a></li><li class="chapter-item "><a href="std-traits/casting.html"><strong aria-hidden="true">17.4.</strong> Casting</a></li><li class="chapter-item "><a href="std-traits/read-and-write.html"><strong aria-hidden="true">17.5.</strong> Read and Write</a></li><li class="chapter-item "><a href="std-traits/default.html"><strong aria-hidden="true">17.6.</strong> Default, struct update syntax</a></li><li class="chapter-item "><a href="std-traits/closures.html"><strong aria-hidden="true">17.7.</strong> Closures</a></li><li class="chapter-item "><a href="std-traits/exercise.html"><strong aria-hidden="true">17.8.</strong> Exercise: ROT13</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-traits/solution.html"><strong aria-hidden="true">17.8.1.</strong> Solution</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 3: Morning</li><li class="chapter-item "><a href="welcome-day-3.html"><strong aria-hidden="true">18.</strong> Welcome</a></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">19.</strong> Memory Management</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/review.html"><strong aria-hidden="true">19.1.</strong> Review of Program Memory</a></li><li class="chapter-item "><a href="memory-management/approaches.html"><strong aria-hidden="true">19.2.</strong> Approaches to Memory Management</a></li><li class="chapter-item "><a href="memory-management/ownership.html"><strong aria-hidden="true">19.3.</strong> Ownership</a></li><li class="chapter-item "><a href="memory-management/move.html"><strong aria-hidden="true">19.4.</strong> Move Semantics</a></li><li class="chapter-item "><a href="memory-management/clone.html"><strong aria-hidden="true">19.5.</strong> Clone</a></li><li class="chapter-item "><a href="memory-management/copy-types.html"><strong aria-hidden="true">19.6.</strong> Copy Types</a></li><li class="chapter-item "><a href="memory-management/drop.html"><strong aria-hidden="true">19.7.</strong> Drop</a></li><li class="chapter-item "><a href="memory-management/exercise.html"><strong aria-hidden="true">19.8.</strong> Exercise: Builder Type</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/solution.html"><strong aria-hidden="true">19.8.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="smart-pointers.html"><strong aria-hidden="true">20.</strong> Smart Pointers</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">20.1.</strong> Box&lt;T&gt;</a></li><li class="chapter-item "><a href="smart-pointers/rc.html"><strong aria-hidden="true">20.2.</strong> Rc</a></li><li class="chapter-item "><a href="smart-pointers/trait-objects.html"><strong aria-hidden="true">20.3.</strong> Owned Trait Objects</a></li><li class="chapter-item "><a href="smart-pointers/exercise.html"><strong aria-hidden="true">20.4.</strong> Exercise: Binary Tree</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/solution.html"><strong aria-hidden="true">20.4.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 3: Afternoon</li><li class="chapter-item "><a href="welcome-day-3-afternoon.html"><strong aria-hidden="true">21.</strong> Welcome</a></li><li class="chapter-item "><a href="borrowing.html"><strong aria-hidden="true">22.</strong> Borrowing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowing/shared.html"><strong aria-hidden="true">22.1.</strong> Borrowing a Value</a></li><li class="chapter-item "><a href="borrowing/borrowck.html"><strong aria-hidden="true">22.2.</strong> Borrow Checking</a></li><li class="chapter-item "><a href="borrowing/examples.html"><strong aria-hidden="true">22.3.</strong> Borrow Errors</a></li><li class="chapter-item "><a href="borrowing/interior-mutability.html"><strong aria-hidden="true">22.4.</strong> Interior Mutability</a></li><li class="chapter-item "><a href="borrowing/exercise.html"><strong aria-hidden="true">22.5.</strong> Exercise: Health Statistics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowing/solution.html"><strong aria-hidden="true">22.5.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="lifetimes.html"><strong aria-hidden="true">23.</strong> Lifetimes</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetimes/lifetime-annotations.html"><strong aria-hidden="true">23.1.</strong> Lifetime Annotations</a></li><li class="chapter-item "><a href="lifetimes/lifetime-elision.html"><strong aria-hidden="true">23.2.</strong> Lifetime Elision</a></li><li class="chapter-item "><a href="lifetimes/struct-lifetimes.html"><strong aria-hidden="true">23.3.</strong> Struct Lifetimes</a></li><li class="chapter-item "><a href="lifetimes/exercise.html"><strong aria-hidden="true">23.4.</strong> Exercise: Protobuf Parsing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetimes/solution.html"><strong aria-hidden="true">23.4.1.</strong> Solution</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 4: Morning</li><li class="chapter-item "><a href="welcome-day-4.html"><strong aria-hidden="true">24.</strong> Welcome</a></li><li class="chapter-item "><a href="iterators.html"><strong aria-hidden="true">25.</strong> Iterators</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/iterator.html"><strong aria-hidden="true">25.1.</strong> Iterator</a></li><li class="chapter-item "><a href="iterators/intoiterator.html"><strong aria-hidden="true">25.2.</strong> IntoIterator</a></li><li class="chapter-item "><a href="iterators/fromiterator.html"><strong aria-hidden="true">25.3.</strong> FromIterator</a></li><li class="chapter-item "><a href="iterators/exercise.html"><strong aria-hidden="true">25.4.</strong> Exercise: Iterator Method Chaining</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/solution.html"><strong aria-hidden="true">25.4.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">26.</strong> Modules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/modules.html"><strong aria-hidden="true">26.1.</strong> Modules</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">26.2.</strong> Filesystem Hierarchy</a></li><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">26.3.</strong> Visibility</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">26.4.</strong> use, super, self</a></li><li class="chapter-item "><a href="modules/exercise.html"><strong aria-hidden="true">26.5.</strong> Exercise: Modules for a GUI Library</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/solution.html"><strong aria-hidden="true">26.5.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">27.</strong> Testing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">27.1.</strong> Test Modules</a></li><li class="chapter-item "><a href="testing/other.html"><strong aria-hidden="true">27.2.</strong> Other Types of Tests</a></li><li class="chapter-item "><a href="testing/lints.html"><strong aria-hidden="true">27.3.</strong> Compiler Lints and Clippy</a></li><li class="chapter-item "><a href="testing/exercise.html"><strong aria-hidden="true">27.4.</strong> Exercise: Luhn Algorithm</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/solution.html"><strong aria-hidden="true">27.4.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Day 4: Afternoon</li><li class="chapter-item "><a href="welcome-day-4-afternoon.html"><strong aria-hidden="true">28.</strong> Welcome</a></li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">29.</strong> Error Handling</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">29.1.</strong> Panics</a></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">29.2.</strong> Result</a></li><li class="chapter-item "><a href="error-handling/try.html"><strong aria-hidden="true">29.3.</strong> Try Operator</a></li><li class="chapter-item "><a href="error-handling/try-conversions.html"><strong aria-hidden="true">29.4.</strong> Try Conversions</a></li><li class="chapter-item "><a href="error-handling/error.html"><strong aria-hidden="true">29.5.</strong> Error Trait</a></li><li class="chapter-item "><a href="error-handling/thiserror-and-anyhow.html"><strong aria-hidden="true">29.6.</strong> thiserror and anyhow</a></li><li class="chapter-item "><a href="error-handling/exercise.html"><strong aria-hidden="true">29.7.</strong> Exercise: Rewriting with Result</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/solution.html"><strong aria-hidden="true">29.7.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><a href="unsafe-rust.html"><strong aria-hidden="true">30.</strong> Unsafe Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe-rust/unsafe.html"><strong aria-hidden="true">30.1.</strong> Unsafe</a></li><li class="chapter-item "><a href="unsafe-rust/dereferencing.html"><strong aria-hidden="true">30.2.</strong> Dereferencing Raw Pointers</a></li><li class="chapter-item "><a href="unsafe-rust/mutable-static.html"><strong aria-hidden="true">30.3.</strong> Mutable Static Variables</a></li><li class="chapter-item "><a href="unsafe-rust/unions.html"><strong aria-hidden="true">30.4.</strong> Unions</a></li><li class="chapter-item "><a href="unsafe-rust/unsafe-functions.html"><strong aria-hidden="true">30.5.</strong> Unsafe Functions</a></li><li class="chapter-item "><a href="unsafe-rust/unsafe-traits.html"><strong aria-hidden="true">30.6.</strong> Unsafe Traits</a></li><li class="chapter-item "><a href="unsafe-rust/exercise.html"><strong aria-hidden="true">30.7.</strong> Exercise: FFI Wrapper</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe-rust/solution.html"><strong aria-hidden="true">30.7.1.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Android</li><li class="spacer"></li><li class="chapter-item "><a href="android.html"><strong aria-hidden="true">31.</strong> Welcome</a></li><li class="chapter-item "><a href="android/setup.html"><strong aria-hidden="true">32.</strong> Setup</a></li><li class="chapter-item "><a href="android/build-rules.html"><strong aria-hidden="true">33.</strong> Build Rules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/build-rules/binary.html"><strong aria-hidden="true">33.1.</strong> Binary</a></li><li class="chapter-item "><a href="android/build-rules/library.html"><strong aria-hidden="true">33.2.</strong> Library</a></li></ol></li><li class="chapter-item "><a href="android/aidl.html"><strong aria-hidden="true">34.</strong> AIDL</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/birthday-service.html"><strong aria-hidden="true">34.1.</strong> Birthday Service Tutorial</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/example-service/interface.html"><strong aria-hidden="true">34.1.1.</strong> Interface</a></li><li class="chapter-item "><a href="android/aidl/example-service/service-bindings.html"><strong aria-hidden="true">34.1.2.</strong> Service API</a></li><li class="chapter-item "><a href="android/aidl/example-service/service.html"><strong aria-hidden="true">34.1.3.</strong> Service</a></li><li class="chapter-item "><a href="android/aidl/example-service/server.html"><strong aria-hidden="true">34.1.4.</strong> Server</a></li><li class="chapter-item "><a href="android/aidl/example-service/deploy.html"><strong aria-hidden="true">34.1.5.</strong> Deploy</a></li><li class="chapter-item "><a href="android/aidl/example-service/client.html"><strong aria-hidden="true">34.1.6.</strong> Client</a></li><li class="chapter-item "><a href="android/aidl/example-service/changing-definition.html"><strong aria-hidden="true">34.1.7.</strong> Changing API</a></li><li class="chapter-item "><a href="android/aidl/example-service/changing-implementation.html"><strong aria-hidden="true">34.1.8.</strong> Updating Implementations</a></li></ol></li><li class="chapter-item "><a href="android/aidl/types.html"><strong aria-hidden="true">34.2.</strong> AIDL Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/types/primitives.html"><strong aria-hidden="true">34.2.1.</strong> Primitive Types</a></li><li class="chapter-item "><a href="android/aidl/types/arrays.html"><strong aria-hidden="true">34.2.2.</strong> Array Types</a></li><li class="chapter-item "><a href="android/aidl/types/objects.html"><strong aria-hidden="true">34.2.3.</strong> Sending Objects</a></li><li class="chapter-item "><a href="android/aidl/types/parcelables.html"><strong aria-hidden="true">34.2.4.</strong> Parcelables</a></li><li class="chapter-item "><a href="android/aidl/types/file-descriptor.html"><strong aria-hidden="true">34.2.5.</strong> Sending Files</a></li></ol></li></ol></li><li class="chapter-item "><a href="android/testing.html"><strong aria-hidden="true">35.</strong> Testing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/testing/googletest.html"><strong aria-hidden="true">35.1.</strong> GoogleTest</a></li><li class="chapter-item "><a href="android/testing/mocking.html"><strong aria-hidden="true">35.2.</strong> Mocking</a></li></ol></li><li class="chapter-item "><a href="android/logging.html"><strong aria-hidden="true">36.</strong> Logging</a></li><li class="chapter-item "><a href="android/interoperability.html"><strong aria-hidden="true">37.</strong> Interoperability</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c.html"><strong aria-hidden="true">37.1.</strong> With C</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c/bindgen.html"><strong aria-hidden="true">37.1.1.</strong> Calling C with Bindgen</a></li><li class="chapter-item "><a href="android/interoperability/with-c/rust.html"><strong aria-hidden="true">37.1.2.</strong> Calling Rust from C</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/cpp.html"><strong aria-hidden="true">37.2.</strong> With C++</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/cpp/bridge.html"><strong aria-hidden="true">37.2.1.</strong> The Bridge Module</a></li><li class="chapter-item "><a href="android/interoperability/cpp/rust-bridge.html"><strong aria-hidden="true">37.2.2.</strong> Rust Bridge</a></li><li class="chapter-item "><a href="android/interoperability/cpp/generated-cpp.html"><strong aria-hidden="true">37.2.3.</strong> Generated C++</a></li><li class="chapter-item "><a href="android/interoperability/cpp/cpp-bridge.html"><strong aria-hidden="true">37.2.4.</strong> C++ Bridge</a></li><li class="chapter-item "><a href="android/interoperability/cpp/shared-types.html"><strong aria-hidden="true">37.2.5.</strong> Shared Types</a></li><li class="chapter-item "><a href="android/interoperability/cpp/shared-enums.html"><strong aria-hidden="true">37.2.6.</strong> Shared Enums</a></li><li class="chapter-item "><a href="android/interoperability/cpp/rust-result.html"><strong aria-hidden="true">37.2.7.</strong> Rust Error Handling</a></li><li class="chapter-item "><a href="android/interoperability/cpp/cpp-exception.html"><strong aria-hidden="true">37.2.8.</strong> C++ Error Handling</a></li><li class="chapter-item "><a href="android/interoperability/cpp/type-mapping.html"><strong aria-hidden="true">37.2.9.</strong> Additional Types</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-build-cpp.html"><strong aria-hidden="true">37.2.10.</strong> Building for Android: C++</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-cpp-genrules.html"><strong aria-hidden="true">37.2.11.</strong> Building for Android: Genrules</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-build-rust.html"><strong aria-hidden="true">37.2.12.</strong> Building for Android: Rust</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/java.html"><strong aria-hidden="true">37.3.</strong> With Java</a></li></ol></li><li class="chapter-item "><a href="exercises/android/morning.html"><strong aria-hidden="true">38.</strong> Exercises</a></li><li class="chapter-item affix "><li class="part-title">Chromium</li><li class="spacer"></li><li class="chapter-item "><a href="chromium.html"><strong aria-hidden="true">39.</strong> Welcome</a></li><li class="chapter-item "><a href="chromium/setup.html"><strong aria-hidden="true">40.</strong> Setup</a></li><li class="chapter-item "><a href="chromium/cargo.html"><strong aria-hidden="true">41.</strong> Comparing Chromium and Cargo Ecosystems</a></li><li class="chapter-item "><a href="chromium/policy.html"><strong aria-hidden="true">42.</strong> Policy</a></li><li class="chapter-item "><a href="chromium/build-rules.html"><strong aria-hidden="true">43.</strong> Build Rules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/build-rules/unsafe.html"><strong aria-hidden="true">43.1.</strong> Unsafe Code</a></li><li class="chapter-item "><a href="chromium/build-rules/depending.html"><strong aria-hidden="true">43.2.</strong> Depending on Rust Code from Chromium C++</a></li><li class="chapter-item "><a href="chromium/build-rules/vscode.html"><strong aria-hidden="true">43.3.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="exercises/chromium/build-rules.html"><strong aria-hidden="true">43.4.</strong> Exercise</a></li></ol></li><li class="chapter-item "><a href="chromium/testing.html"><strong aria-hidden="true">44.</strong> Testing</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/testing/rust-gtest-interop.html"><strong aria-hidden="true">44.1.</strong> rust_gtest_interop Library</a></li><li class="chapter-item "><a href="chromium/testing/build-gn.html"><strong aria-hidden="true">44.2.</strong> GN Rules for Rust Tests</a></li><li class="chapter-item "><a href="chromium/testing/chromium-import-macro.html"><strong aria-hidden="true">44.3.</strong> chromium::import! Macro</a></li><li class="chapter-item "><a href="exercises/chromium/testing.html"><strong aria-hidden="true">44.4.</strong> Exercise</a></li></ol></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp.html"><strong aria-hidden="true">45.</strong> Interoperability with C++</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/interoperability-with-cpp/example-bindings.html"><strong aria-hidden="true">45.1.</strong> Example Bindings</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/limitations-of-cxx.html"><strong aria-hidden="true">45.2.</strong> Limitations of CXX</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling.html"><strong aria-hidden="true">45.3.</strong> CXX Error Handling</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling-qr.html"><strong aria-hidden="true">45.3.1.</strong> Error Handling: QR Example</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling-png.html"><strong aria-hidden="true">45.3.2.</strong> Error Handling: PNG Example</a></li></ol></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/using-cxx-in-chromium.html"><strong aria-hidden="true">45.4.</strong> Using CXX in Chromium</a></li><li class="chapter-item "><a href="exercises/chromium/interoperability-with-cpp.html"><strong aria-hidden="true">45.5.</strong> Exercise</a></li></ol></li><li class="chapter-item "><a href="chromium/adding-third-party-crates.html"><strong aria-hidden="true">46.</strong> Adding Third Party Crates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/adding-third-party-crates/configuring-cargo-toml.html"><strong aria-hidden="true">46.1.</strong> Configuring Cargo.toml</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/configuring-gnrt-config-toml.html"><strong aria-hidden="true">46.2.</strong> Configuring gnrt_config.toml</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/downloading-crates.html"><strong aria-hidden="true">46.3.</strong> Downloading Crates</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/generating-gn-build-rules.html"><strong aria-hidden="true">46.4.</strong> Generating gn Build Rules</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems.html"><strong aria-hidden="true">46.5.</strong> Resolving Problems</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.html"><strong aria-hidden="true">46.5.1.</strong> Build Scripts Which Generate Code</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.html"><strong aria-hidden="true">46.5.2.</strong> Build Scripts Which Build C++ or Take Arbitrary Actions</a></li></ol></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/depending-on-a-crate.html"><strong aria-hidden="true">46.6.</strong> Depending on a Crate</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/reviews-and-audits.html"><strong aria-hidden="true">46.7.</strong> Reviews and Audits</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/checking-in.html"><strong aria-hidden="true">46.8.</strong> Checking into Chromium Source Code</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/keeping-up-to-date.html"><strong aria-hidden="true">46.9.</strong> Keeping Crates Up to Date</a></li><li class="chapter-item "><a href="exercises/chromium/third-party.html"><strong aria-hidden="true">46.10.</strong> Exercise</a></li></ol></li><li class="chapter-item "><a href="exercises/chromium/bringing-it-together.html"><strong aria-hidden="true">47.</strong> Bringing It Together - Exercise</a></li><li class="chapter-item "><a href="exercises/chromium/solutions.html"><strong aria-hidden="true">48.</strong> Exercise Solutions</a></li><li class="chapter-item affix "><li class="part-title">Bare Metal: Morning</li><li class="spacer"></li><li class="chapter-item "><a href="bare-metal.html"><strong aria-hidden="true">49.</strong> Welcome</a></li><li class="chapter-item "><a href="bare-metal/no_std.html"><strong aria-hidden="true">50.</strong> no_std</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/minimal.html"><strong aria-hidden="true">50.1.</strong> A Minimal Example</a></li><li class="chapter-item "><a href="bare-metal/alloc.html"><strong aria-hidden="true">50.2.</strong> alloc</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers.html"><strong aria-hidden="true">51.</strong> Microcontrollers</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/mmio.html"><strong aria-hidden="true">51.1.</strong> Raw MMIO</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/pacs.html"><strong aria-hidden="true">51.2.</strong> PACs</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/hals.html"><strong aria-hidden="true">51.3.</strong> HAL Crates</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/board-support.html"><strong aria-hidden="true">51.4.</strong> Board Support Crates</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/type-state.html"><strong aria-hidden="true">51.5.</strong> The Type State Pattern</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/embedded-hal.html"><strong aria-hidden="true">51.6.</strong> embedded-hal</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/probe-rs.html"><strong aria-hidden="true">51.7.</strong> probe-rs and cargo-embed</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/debugging.html"><strong aria-hidden="true">51.7.1.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers/other-projects.html"><strong aria-hidden="true">51.8.</strong> Other Projects</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/morning.html"><strong aria-hidden="true">52.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/compass.html"><strong aria-hidden="true">52.1.</strong> Compass</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-morning.html"><strong aria-hidden="true">52.2.</strong> Solutions</a></li></ol></li><li class="chapter-item "><li class="part-title">Bare Metal: Afternoon</li><li class="chapter-item "><a href="bare-metal/aps.html"><strong aria-hidden="true">53.</strong> Application Processors</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/entry-point.html"><strong aria-hidden="true">53.1.</strong> Getting Ready to Rust</a></li><li class="chapter-item "><a href="bare-metal/aps/inline-assembly.html"><strong aria-hidden="true">53.2.</strong> Inline Assembly</a></li><li class="chapter-item "><a href="bare-metal/aps/mmio.html"><strong aria-hidden="true">53.3.</strong> MMIO</a></li><li class="chapter-item "><a href="bare-metal/aps/uart.html"><strong aria-hidden="true">53.4.</strong> Let's Write a UART Driver</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/uart/traits.html"><strong aria-hidden="true">53.4.1.</strong> More Traits</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/better-uart.html"><strong aria-hidden="true">53.5.</strong> A Better UART Driver</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/better-uart/bitflags.html"><strong aria-hidden="true">53.5.1.</strong> Bitflags</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/registers.html"><strong aria-hidden="true">53.5.2.</strong> Multiple Registers</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/driver.html"><strong aria-hidden="true">53.5.3.</strong> Driver</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/using.html"><strong aria-hidden="true">53.5.4.</strong> Using It</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/logging.html"><strong aria-hidden="true">53.6.</strong> Logging</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/logging/using.html"><strong aria-hidden="true">53.6.1.</strong> Using It</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/exceptions.html"><strong aria-hidden="true">53.7.</strong> Exceptions</a></li><li class="chapter-item "><a href="bare-metal/aps/other-projects.html"><strong aria-hidden="true">53.8.</strong> Other Projects</a></li></ol></li><li class="chapter-item "><a href="bare-metal/useful-crates.html"><strong aria-hidden="true">54.</strong> Useful Crates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/useful-crates/zerocopy.html"><strong aria-hidden="true">54.1.</strong> zerocopy</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/aarch64-paging.html"><strong aria-hidden="true">54.2.</strong> aarch64-paging</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/buddy_system_allocator.html"><strong aria-hidden="true">54.3.</strong> buddy_system_allocator</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/tinyvec.html"><strong aria-hidden="true">54.4.</strong> tinyvec</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/spin.html"><strong aria-hidden="true">54.5.</strong> spin</a></li></ol></li><li class="chapter-item "><a href="bare-metal/android.html"><strong aria-hidden="true">55.</strong> Android</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/android/vmbase.html"><strong aria-hidden="true">55.1.</strong> vmbase</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/afternoon.html"><strong aria-hidden="true">56.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/rtc.html"><strong aria-hidden="true">56.1.</strong> RTC Driver</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-afternoon.html"><strong aria-hidden="true">56.2.</strong> Solutions</a></li></ol></li><li class="chapter-item "><li class="part-title">Concurrency: Morning</li><li class="spacer"></li><li class="chapter-item "><a href="concurrency/welcome.html"><strong aria-hidden="true">57.</strong> Welcome</a></li><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">58.</strong> Threads</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/threads/plain.html"><strong aria-hidden="true">58.1.</strong> Plain Threads</a></li><li class="chapter-item "><a href="concurrency/threads/scoped.html"><strong aria-hidden="true">58.2.</strong> Scoped Threads</a></li></ol></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">59.</strong> Channels</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/senders-receivers.html"><strong aria-hidden="true">59.1.</strong> Senders and Receivers</a></li><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">59.2.</strong> Unbounded Channels</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">59.3.</strong> Bounded Channels</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">60.</strong> Send and Sync</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/marker-traits.html"><strong aria-hidden="true">60.1.</strong> Marker Traits</a></li><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">60.2.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">60.3.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">60.4.</strong> Examples</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared-state.html"><strong aria-hidden="true">61.</strong> Shared State</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared-state/arc.html"><strong aria-hidden="true">61.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared-state/mutex.html"><strong aria-hidden="true">61.2.</strong> Mutex</a></li><li class="chapter-item "><a href="concurrency/shared-state/example.html"><strong aria-hidden="true">61.3.</strong> Example</a></li></ol></li><li class="chapter-item "><a href="concurrency/sync-exercises.html"><strong aria-hidden="true">62.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/sync-exercises/dining-philosophers.html"><strong aria-hidden="true">62.1.</strong> Dining Philosophers</a></li><li class="chapter-item "><a href="concurrency/sync-exercises/link-checker.html"><strong aria-hidden="true">62.2.</strong> Multi-threaded Link Checker</a></li><li class="chapter-item "><a href="concurrency/sync-exercises/solutions.html"><strong aria-hidden="true">62.3.</strong> Solutions</a></li></ol></li><li class="chapter-item "><li class="part-title">Concurrency: Afternoon</li><li class="chapter-item "><a href="concurrency/welcome-async.html"><strong aria-hidden="true">63.</strong> Welcome</a></li><li class="chapter-item "><a href="concurrency/async.html"><strong aria-hidden="true">64.</strong> Async Basics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async/async-await.html"><strong aria-hidden="true">64.1.</strong> async/await</a></li><li class="chapter-item "><a href="concurrency/async/futures.html"><strong aria-hidden="true">64.2.</strong> Futures</a></li><li class="chapter-item "><a href="concurrency/async/runtimes.html"><strong aria-hidden="true">64.3.</strong> Runtimes</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async/runtimes/tokio.html"><strong aria-hidden="true">64.3.1.</strong> Tokio</a></li></ol></li><li class="chapter-item "><a href="concurrency/async/tasks.html"><strong aria-hidden="true">64.4.</strong> Tasks</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-control-flow.html"><strong aria-hidden="true">65.</strong> Channels and Control Flow</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-control-flow/channels.html"><strong aria-hidden="true">65.1.</strong> Async Channels</a></li><li class="chapter-item "><a href="concurrency/async-control-flow/join.html"><strong aria-hidden="true">65.2.</strong> Join</a></li><li class="chapter-item "><a href="concurrency/async-control-flow/select.html"><strong aria-hidden="true">65.3.</strong> Select</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-pitfalls.html"><strong aria-hidden="true">66.</strong> Pitfalls</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-pitfalls/blocking-executor.html"><strong aria-hidden="true">66.1.</strong> Blocking the Executor</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/pin.html"><strong aria-hidden="true">66.2.</strong> Pin</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/async-traits.html"><strong aria-hidden="true">66.3.</strong> Async Traits</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/cancellation.html"><strong aria-hidden="true">66.4.</strong> Cancellation</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-exercises.html"><strong aria-hidden="true">67.</strong> Exercises</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-exercises/dining-philosophers.html"><strong aria-hidden="true">67.1.</strong> Dining Philosophers</a></li><li class="chapter-item "><a href="concurrency/async-exercises/chat-app.html"><strong aria-hidden="true">67.2.</strong> Broadcast Chat Application</a></li><li class="chapter-item "><a href="concurrency/async-exercises/solutions.html"><strong aria-hidden="true">67.3.</strong> Solutions</a></li></ol></li><li class="chapter-item "><li class="part-title">Final Words</li><li class="spacer"></li><li class="chapter-item "><a href="thanks.html"><strong aria-hidden="true">68.</strong> Thanks!</a></li><li class="chapter-item "><a href="glossary.html"><strong aria-hidden="true">69.</strong> Glossary</a></li><li class="chapter-item "><a href="other-resources.html"><strong aria-hidden="true">70.</strong> Other Resources</a></li><li class="chapter-item "><a href="credits.html"><strong aria-hidden="true">71.</strong> Credits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Comprehensive Rust ü¶Ä</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese (Portugu√™s do Brasil)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-CN">Chinese Simplified (Ê±âËØ≠)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-TW">Chinese Traditional (Êº¢Ë™û)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (Êó•Êú¨Ë™û)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">Korean (ÌïúÍµ≠Ïñ¥)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (Espa√±ol)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="uk">Ukrainian (—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("en");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/comprehensive-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div id="index"></div><h1 id="index-welcome-to-comprehensive-rust-"><a class="header" href="#index-welcome-to-comprehensive-rust-">Welcome to Comprehensive Rust ü¶Ä</a></h1>
<p><a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="Build workflow" /></a>
<a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub contributors" /></a>
<a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub stars" /></a></p>
<p>This is a free Rust course developed by the Android team at Google. The course
covers the full spectrum of Rust, from basic syntax to advanced topics like
generics and error handling.</p>
<blockquote>
<p>The latest version of the course can be found at
<a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a>. If you are reading somewhere
else, please check there for updates.</p>
<p>The course is available in other languages. Select your preferred language in
the top right corner of the page or check the
<a href="#running-the-course-translations">Translations</a> page for a list of all
available translations.</p>
<p>The course is also available <a href="#comprehensive-rust.pdf">as a PDF</a>.</p>
</blockquote>
<p>The goal of the course is to teach you Rust. We assume you don't know anything
about Rust and hope to:</p>
<ul>
<li>Give you a comprehensive understanding of the Rust syntax and language.</li>
<li>Enable you to modify existing programs and write new programs in Rust.</li>
<li>Show you common Rust idioms.</li>
</ul>
<p>We call the first four course days Rust Fundamentals.</p>
<p>Building on this, you're invited to dive into one or more specialized topics:</p>
<ul>
<li><a href="#android">Android</a>: a half-day course on using Rust for Android platform
development (AOSP). This includes interoperability with C, C++, and Java.</li>
<li><a href="#chromium">Chromium</a>: a half-day course on using Rust within Chromium based
browsers. This includes interoperability with C++ and how to include
third-party crates in Chromium.</li>
<li><a href="#bare-metal">Bare-metal</a>: a whole-day class on using Rust for bare-metal
(embedded) development. Both microcontrollers and application processors are
covered.</li>
<li><a href="#concurrency-welcome">Concurrency</a>: a whole-day class on concurrency in
Rust. We cover both classical concurrency (preemptively scheduling using
threads and mutexes) and async/await concurrency (cooperative multitasking
using futures).</li>
</ul>
<h2 id="index-non-goals"><a class="header" href="#index-non-goals">Non-Goals</a></h2>
<p>Rust is a large language and we won't be able to cover all of it in a few days.
Some non-goals of this course are:</p>
<ul>
<li>Learning how to develop macros: please see
<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Chapter 19.5 in the Rust Book</a>
and <a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by Example</a>
instead.</li>
</ul>
<h2 id="index-assumptions"><a class="header" href="#index-assumptions">Assumptions</a></h2>
<p>The course assumes that you already know how to program. Rust is a
statically-typed language and we will sometimes make comparisons with C and C++
to better explain or contrast the Rust approach.</p>
<p>If you know how to program in a dynamically-typed language such as Python or
JavaScript, then you will be able to follow along just fine too.</p>
<details>
<p>This is an example of a <em>speaker note</em>. We will use these to add additional
information to the slides. This could be key points which the instructor should
cover as well as answers to typical questions which come up in class.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="running-the-course"></div><h1 id="running-the-course-running-the-course"><a class="header" href="#running-the-course-running-the-course">Running the Course</a></h1>
<blockquote>
<p>This page is for the course instructor.</p>
</blockquote>
<p>Here is a bit of background information about how we've been running the course
internally at Google.</p>
<p>We typically run classes from 9:00 am to 4:00 pm, with a 1 hour lunch break in
the middle. This leaves 3 hours for the morning class and 3 hours for the
afternoon class. Both sessions contain multiple breaks and time for students to
work on exercises.</p>
<p>Before you run the course, you will want to:</p>
<ol>
<li>
<p>Make yourself familiar with the course material. We've included speaker notes
to help highlight the key points (please help us by contributing more speaker
notes!). When presenting, you should make sure to open the speaker notes in a
popup (click the link with a little arrow next to "Speaker Notes"). This way
you have a clean screen to present to the class.</p>
</li>
<li>
<p>Decide on the dates. Since the course takes four days, we recommend that you
schedule the days over two weeks. Course participants have said that they
find it helpful to have a gap in the course since it helps them process all
the information we give them.</p>
</li>
<li>
<p>Find a room large enough for your in-person participants. We recommend a
class size of 15-25 people. That's small enough that people are comfortable
asking questions --- it's also small enough that one instructor will have
time to answer the questions. Make sure the room has <em>desks</em> for yourself and
for the students: you will all need to be able to sit and work with your
laptops. In particular, you will be doing a lot of live-coding as an
instructor, so a lectern won't be very helpful for you.</p>
</li>
<li>
<p>On the day of your course, show up to the room a little early to set things
up. We recommend presenting directly using <code>mdbook serve</code> running on your
laptop (see the <a href="https://github.com/google/comprehensive-rust#building">installation instructions</a>). This ensures optimal
performance with no lag as you change pages. Using your laptop will also
allow you to fix typos as you or the course participants spot them.</p>
</li>
<li>
<p>Let people solve the exercises by themselves or in small groups. We typically
spend 30-45 minutes on exercises in the morning and in the afternoon
(including time to review the solutions). Make sure to ask people if they're
stuck or if there is anything you can help with. When you see that several
people have the same problem, call it out to the class and offer a solution,
e.g., by showing people where to find the relevant information in the
standard library.</p>
</li>
</ol>
<p>That is all, good luck running the course! We hope it will be as much fun for
you as it has been for us!</p>
<p>Please <a href="https://github.com/google/comprehensive-rust/discussions/86">provide feedback</a> afterwards so that we can keep improving the
course. We would love to hear what worked well for you and what can be made
better. Your students are also very welcome to <a href="https://github.com/google/comprehensive-rust/discussions/100">send us feedback</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><div id="running-the-course-course-structure"></div><h1 id="running-the-course-course-structure-course-structure"><a class="header" href="#running-the-course-course-structure-course-structure">Course Structure</a></h1>
<blockquote>
<p>This page is for the course instructor.</p>
</blockquote>
<h2 id="running-the-course-course-structure-rust-fundamentals"><a class="header" href="#running-the-course-course-structure-rust-fundamentals">Rust Fundamentals</a></h2>
<p>The first four days make up <a href="#welcome-day-1">Rust Fundamentals</a>. The days
are fast paced and we cover a lot of ground!</p>
<p>Course schedule:</p>
<ul>
<li>Day 1 Morning (2 hours and 5 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>5 minutes</td></tr>
<tr><td>Hello, World</td><td>15 minutes</td></tr>
<tr><td>Types and Values</td><td>40 minutes</td></tr>
<tr><td>Control Flow Basics</td><td>40 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 1 Afternoon (2 hours and 35 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Tuples and Arrays</td><td>35 minutes</td></tr>
<tr><td>References</td><td>55 minutes</td></tr>
<tr><td>User-Defined Types</td><td>50 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 2 Morning (2 hours and 10 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>3 minutes</td></tr>
<tr><td>Pattern Matching</td><td>1 hour</td></tr>
<tr><td>Methods and Traits</td><td>50 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 2 Afternoon (3 hours and 15 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Generics</td><td>45 minutes</td></tr>
<tr><td>Standard Library Types</td><td>1 hour</td></tr>
<tr><td>Standard Library Traits</td><td>1 hour and 10 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 3 Morning (2 hours and 20 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>3 minutes</td></tr>
<tr><td>Memory Management</td><td>1 hour</td></tr>
<tr><td>Smart Pointers</td><td>55 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 3 Afternoon (1 hour and 55 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Borrowing</td><td>55 minutes</td></tr>
<tr><td>Lifetimes</td><td>50 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 4 Morning (2 hours and 40 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>3 minutes</td></tr>
<tr><td>Iterators</td><td>45 minutes</td></tr>
<tr><td>Modules</td><td>40 minutes</td></tr>
<tr><td>Testing</td><td>45 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Day 4 Afternoon (2 hours and 15 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Error Handling</td><td>1 hour</td></tr>
<tr><td>Unsafe Rust</td><td>1 hour and 5 minutes</td></tr>
</tbody></table>
</div>
<h2 id="running-the-course-course-structure-deep-dives"><a class="header" href="#running-the-course-course-structure-deep-dives">Deep Dives</a></h2>
<p>In addition to the 4-day class on Rust Fundamentals, we cover some more
specialized topics:</p>
<h3 id="running-the-course-course-structure-rust-in-android"><a class="header" href="#running-the-course-course-structure-rust-in-android">Rust in Android</a></h3>
<p>The <a href="#android">Rust in Android</a> deep dive is a half-day course on using
Rust for Android platform development. This includes interoperability with C,
C++, and Java.</p>
<p>You will need an <a href="https://source.android.com/docs/setup/download/downloading">AOSP checkout</a>. Make a checkout of the
<a href="https://github.com/google/comprehensive-rust">course repository</a> on the same machine and move the <code>src/android/</code> directory
into the root of your AOSP checkout. This will ensure that the Android build
system sees the <code>Android.bp</code> files in <code>src/android/</code>.</p>
<p>Ensure that <code>adb sync</code> works with your emulator or real device and pre-build all
Android examples using <code>src/android/build_all.sh</code>. Read the script to see the
commands it runs and make sure they work when you run them by hand.</p>
<h3 id="running-the-course-course-structure-rust-in-chromium"><a class="header" href="#running-the-course-course-structure-rust-in-chromium">Rust in Chromium</a></h3>
<p>The <a href="#chromium">Rust in Chromium</a> deep dive is a half-day course on using
Rust as part of the Chromium browser. It includes using Rust in Chromium's <code>gn</code>
build system, bringing in third-party libraries ("crates") and C++
interoperability.</p>
<p>You will need to be able to build Chromium --- a debug, component build is
<a href="#chromium-setup">recommended</a> for speed but any build will work. Ensure
that you can run the Chromium browser that you've built.</p>
<h3 id="running-the-course-course-structure-bare-metal-rust"><a class="header" href="#running-the-course-course-structure-bare-metal-rust">Bare-Metal Rust</a></h3>
<p>The <a href="#bare-metal">Bare-Metal Rust</a> deep dive is a full day class on using
Rust for bare-metal (embedded) development. Both microcontrollers and
application processors are covered.</p>
<p>For the microcontroller part, you will need to buy the
<a href="https://microbit.org/">BBC micro:bit</a> v2 development board ahead of time.
Everybody will need to install a number of packages as described on the
<a href="#bare-metal">welcome page</a>.</p>
<h3 id="running-the-course-course-structure-concurrency-in-rust"><a class="header" href="#running-the-course-course-structure-concurrency-in-rust">Concurrency in Rust</a></h3>
<p>The <a href="#concurrency-welcome">Concurrency in Rust</a> deep dive is a full day
class on classical as well as <code>async</code>/<code>await</code> concurrency.</p>
<p>You will need a fresh crate set up and the dependencies downloaded and ready to
go. You can then copy/paste the examples into <code>src/main.rs</code> to experiment with
them:</p>
<pre><code class="language-shell">cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
</code></pre>
<p>Course schedule:</p>
<ul>
<li>Morning (3 hours and 20 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Threads</td><td>30 minutes</td></tr>
<tr><td>Channels</td><td>20 minutes</td></tr>
<tr><td>Send and Sync</td><td>15 minutes</td></tr>
<tr><td>Shared State</td><td>30 minutes</td></tr>
<tr><td>Exercises</td><td>1 hour and 10 minutes</td></tr>
</tbody></table>
</div>
<ul>
<li>Afternoon (3 hours and 20 minutes, including breaks)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Async Basics</td><td>30 minutes</td></tr>
<tr><td>Channels and Control Flow</td><td>20 minutes</td></tr>
<tr><td>Pitfalls</td><td>55 minutes</td></tr>
<tr><td>Exercises</td><td>1 hour and 10 minutes</td></tr>
</tbody></table>
</div>
<h2 id="running-the-course-course-structure-format"><a class="header" href="#running-the-course-course-structure-format">Format</a></h2>
<p>The course is meant to be very interactive and we recommend letting the
questions drive the exploration of Rust!</p>
<div style="break-before: page; page-break-before: always;"></div><div id="running-the-course-keyboard-shortcuts"></div><h1 id="running-the-course-keyboard-shortcuts-keyboard-shortcuts"><a class="header" href="#running-the-course-keyboard-shortcuts-keyboard-shortcuts">Keyboard Shortcuts</a></h1>
<p>There are several useful keyboard shortcuts in mdBook:</p>
<ul>
<li><kbd>Arrow-Left</kbd>: Navigate to the previous page.</li>
<li><kbd>Arrow-Right</kbd>: Navigate to the next page.</li>
<li><kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.</li>
<li><kbd>s</kbd>: Activate the search bar.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="running-the-course-translations"></div><h1 id="running-the-course-translations-translations"><a class="header" href="#running-the-course-translations-translations">Translations</a></h1>
<p>The course has been translated into other languages by a set of wonderful
volunteers:</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/pt-BR/">Brazilian Portuguese</a> by <a href="https://github.com/rastringer">@rastringer</a>, <a href="https://github.com/hugojacob">@hugojacob</a>,
<a href="https://github.com/joaovicmendes">@joaovicmendes</a>, and <a href="https://github.com/henrif75">@henrif75</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-CN/">Chinese (Simplified)</a> by <a href="https://github.com/suetfei">@suetfei</a>, <a href="https://github.com/wnghl">@wnghl</a>, <a href="https://github.com/anlunx">@anlunx</a>, <a href="https://github.com/kongy">@kongy</a>,
<a href="https://github.com/noahdragon">@noahdragon</a>, <a href="https://github.com/superwhd">@superwhd</a>, @SketchK, and <a href="https://github.com/nodmp">@nodmp</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-TW/">Chinese (Traditional)</a> by <a href="https://github.com/hueich">@hueich</a>, <a href="https://github.com/victorhsieh">@victorhsieh</a>, <a href="https://github.com/mingyc">@mingyc</a>,
<a href="https://github.com/kuanhungchen">@kuanhungchen</a>, and <a href="https://github.com/johnathan79717">@johnathan79717</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ja/">Japanese</a> by <a href="https://github.com/CoinEZ">@CoinEZ-JPN</a>, <a href="https://github.com/momotaro1105">@momotaro1105</a>, <a href="https://github.com/HidenoriKobayashi">@HidenoriKobayashi</a> and
<a href="https://github.com/kantasv">@kantasv</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ko/">Korean</a> by <a href="https://github.com/keispace">@keispace</a>, <a href="https://github.com/jiyongp">@jiyongp</a>, <a href="https://github.com/jooyunghan">@jooyunghan</a>, and <a href="https://github.com/namhyung">@namhyung</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/es/">Spanish</a> by <a href="https://github.com/deavid">@deavid</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/uk/">Ukrainian</a> by <a href="https://github.com/git-user-cpp">@git-user-cpp</a>, <a href="https://github.com/yaremam">@yaremam</a> and <a href="https://github.com/reta">@reta</a>.</li>
</ul>
<p>Use the language picker in the top-right corner to switch between languages.</p>
<h2 id="running-the-course-translations-incomplete-translations"><a class="header" href="#running-the-course-translations-incomplete-translations">Incomplete Translations</a></h2>
<p>There is a large number of in-progress translations. We link to the most
recently updated translations:</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/ar/">Arabic</a> by <a href="https://github.com/younies">@younies</a></li>
<li><a href="https://google.github.io/comprehensive-rust/bn/">Bengali</a> by <a href="https://github.com/raselmandol">@raselmandol</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/fr/">French</a> by <a href="https://github.com/KookaS">@KookaS</a>, <a href="https://github.com/vcaen">@vcaen</a> and <a href="https://github.com/AdrienBaudemont">@AdrienBaudemont</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/de/">German</a> by <a href="https://github.com/Throvn">@Throvn</a> and <a href="https://github.com/ronaldfw">@ronaldfw</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/it/">Italian</a> by <a href="https://github.com/henrythebuilder">@henrythebuilder</a> and <a href="https://github.com/detro">@detro</a>.</li>
</ul>
<p>The full list of translations with their current status is also available either
<a href="https://google.github.io/comprehensive-rust/translation-report.html">as of their last update</a> or
<a href="https://google.github.io/comprehensive-rust/synced-translation-report.html">synced to the latest version of the course</a>.</p>
<p>If you want to help with this effort, please see <a href="https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md">our instructions</a> for how to
get going. Translations are coordinated on the <a href="https://github.com/google/comprehensive-rust/issues/282">issue tracker</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="cargo"></div><h1 id="cargo-using-cargo"><a class="header" href="#cargo-using-cargo">Using Cargo</a></h1>
<p>When you start reading about Rust, you will soon meet
<a href="https://doc.rust-lang.org/cargo/">Cargo</a>, the standard tool used in the Rust
ecosystem to build and run Rust applications. Here we want to give a brief
overview of what Cargo is and how it fits into the wider ecosystem and how it
fits into this training.</p>
<h2 id="cargo-installation"><a class="header" href="#cargo-installation">Installation</a></h2>
<blockquote>
<p><strong>Please follow the instructions on <a href="https://rustup.rs/">https://rustup.rs/</a>.</strong></p>
</blockquote>
<p>This will give you the Cargo build tool (<code>cargo</code>) and the Rust compiler
(<code>rustc</code>). You will also get <code>rustup</code>, a command line utility that you can use
to install to different compiler versions.</p>
<p>After installing Rust, you should configure your editor or IDE to work with
Rust. Most editors do this by talking to <a href="https://rust-analyzer.github.io/">rust-analyzer</a>, which provides
auto-completion and jump-to-definition functionality for <a href="https://code.visualstudio.com/">VS Code</a>, <a href="https://rust-analyzer.github.io/manual.html#emacs">Emacs</a>,
<a href="https://rust-analyzer.github.io/manual.html#vimneovim">Vim/Neovim</a>, and many others. There is also a different IDE available called
<a href="https://www.jetbrains.com/rust/">RustRover</a>.</p>
<details>
<ul>
<li>
<p>On Debian/Ubuntu, you can also install Cargo, the Rust source and the
<a href="https://github.com/rust-lang/rustfmt">Rust formatter</a> via <code>apt</code>. However, this gets you an outdated rust version
and may lead to unexpected behavior. The command would be:</p>
<pre><code class="language-shell">sudo apt install cargo rust-src rustfmt
</code></pre>
</li>
<li>
<p>On macOS, you can use <a href="https://brew.sh/">Homebrew</a> to install Rust, but this
may provide an outdated version. Therefore, it is recommended to install Rust
from the official site.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="cargo-rust-ecosystem"></div><h1 id="cargo-rust-ecosystem-the-rust-ecosystem"><a class="header" href="#cargo-rust-ecosystem-the-rust-ecosystem">The Rust Ecosystem</a></h1>
<p>The Rust ecosystem consists of a number of tools, of which the main ones are:</p>
<ul>
<li>
<p><code>rustc</code>: the Rust compiler which turns <code>.rs</code> files into binaries and other
intermediate formats.</p>
</li>
<li>
<p><code>cargo</code>: the Rust dependency manager and build tool. Cargo knows how to
download dependencies, usually hosted on <a href="https://crates.io">https://crates.io</a>, and it will pass
them to <code>rustc</code> when building your project. Cargo also comes with a built-in
test runner which is used to execute unit tests.</p>
</li>
<li>
<p><code>rustup</code>: the Rust toolchain installer and updater. This tool is used to
install and update <code>rustc</code> and <code>cargo</code> when new versions of Rust are released.
In addition, <code>rustup</code> can also download documentation for the standard
library. You can have multiple versions of Rust installed at once and <code>rustup</code>
will let you switch between them as needed.</p>
</li>
</ul>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Rust has a rapid release schedule with a new release coming out every six
weeks. New releases maintain backwards compatibility with old releases ---
plus they enable new functionality.</p>
</li>
<li>
<p>There are three release channels: "stable", "beta", and "nightly".</p>
</li>
<li>
<p>New features are being tested on "nightly", "beta" is what becomes "stable"
every six weeks.</p>
</li>
<li>
<p>Dependencies can also be resolved from alternative <a href="https://doc.rust-lang.org/cargo/reference/registries.html">registries</a>, git, folders,
and more.</p>
</li>
<li>
<p>Rust also has <a href="https://doc.rust-lang.org/edition-guide/">editions</a>: the current edition is Rust 2021. Previous editions
were Rust 2015 and Rust 2018.</p>
<ul>
<li>
<p>The editions are allowed to make backwards incompatible changes to the
language.</p>
</li>
<li>
<p>To prevent breaking code, editions are opt-in: you select the edition for
your crate via the <code>Cargo.toml</code> file.</p>
</li>
<li>
<p>To avoid splitting the ecosystem, Rust compilers can mix code written for
different editions.</p>
</li>
<li>
<p>Mention that it is quite rare to ever use the compiler directly not through
<code>cargo</code> (most users never do).</p>
</li>
<li>
<p>It might be worth alluding that Cargo itself is an extremely powerful and
comprehensive tool. It is capable of many advanced features including but
not limited to:</p>
<ul>
<li>Project/package structure</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">workspaces</a></li>
<li>Dev Dependencies and Runtime Dependency management/caching</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripting</a></li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">global installation</a></li>
<li>It is also extensible with sub command plugins as well (such as
<a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>).</li>
</ul>
</li>
<li>
<p>Read more from the <a href="https://doc.rust-lang.org/cargo/">official Cargo Book</a></p>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="cargo-code-samples"></div><h1 id="cargo-code-samples-code-samples-in-this-training"><a class="header" href="#cargo-code-samples-code-samples-in-this-training">Code Samples in This Training</a></h1>
<p>For this training, we will mostly explore the Rust language through examples
which can be executed through your browser. This makes the setup much easier and
ensures a consistent experience for everyone.</p>
<p>Installing Cargo is still encouraged: it will make it easier for you to do the
exercises. On the last day, we will do a larger exercise which shows you how to
work with dependencies and for that you need Cargo.</p>
<p>The code blocks in this course are fully interactive:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!("Edit me!");
}</code></pre></pre>
<p>You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the
text box.</p>
<details>
<p>Most code samples are editable like shown above. A few code samples are not
editable for various reasons:</p>
<ul>
<li>
<p>The embedded playgrounds cannot execute unit tests. Copy-paste the code and
open it in the real Playground to demonstrate unit tests.</p>
</li>
<li>
<p>The embedded playgrounds lose their state the moment you navigate away from
the page! This is the reason that the students should solve the exercises
using a local Rust installation or via the Playground.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="cargo-running-locally"></div><h1 id="cargo-running-locally-running-code-locally-with-cargo"><a class="header" href="#cargo-running-locally-running-code-locally-with-cargo">Running Code Locally with Cargo</a></h1>
<p>If you want to experiment with the code on your own system, then you will need
to first install Rust. Do this by following the
<a href="https://doc.rust-lang.org/book/ch01-01-installation.html">instructions in the Rust Book</a>. This should give you a working <code>rustc</code> and
<code>cargo</code>. At the time of writing, the latest stable Rust release has these
version numbers:</p>
<pre><code class="language-shell">% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
</code></pre>
<p>You can use any later version too since Rust maintains backwards compatibility.</p>
<p>With this in place, follow these steps to build a Rust binary from one of the
examples in this training:</p>
<ol>
<li>
<p>Click the "Copy to clipboard" button on the example you want to copy.</p>
</li>
<li>
<p>Use <code>cargo new exercise</code> to create a new <code>exercise/</code> directory for your code:</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>Navigate into <code>exercise/</code> and use <code>cargo run</code> to build and run your binary:</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>Replace the boiler-plate code in <code>src/main.rs</code> with your own code. For
example, using the example on the previous page, make <code>src/main.rs</code> look like</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Edit me!");
}</code></pre></pre>
</li>
<li>
<p>Use <code>cargo run</code> to build and run your updated binary:</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>Use <code>cargo check</code> to quickly check your project for errors, use <code>cargo build</code>
to compile it without running it. You will find the output in <code>target/debug/</code>
for a normal debug build. Use <code>cargo build --release</code> to produce an optimized
release build in <code>target/release/</code>.</p>
</li>
<li>
<p>You can add dependencies for your project by editing <code>Cargo.toml</code>. When you
run <code>cargo</code> commands, it will automatically download and compile missing
dependencies for you.</p>
</li>
</ol>
<details>
<p>Try to encourage the class participants to install Cargo and use a local editor.
It will make their life easier since they will have a normal development
environment.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-1"></div><h1 id="welcome-day-1-welcome-to-day-1"><a class="header" href="#welcome-day-1-welcome-to-day-1">Welcome to Day 1</a></h1>
<p>This is the first day of Rust Fundamentals. We will cover a lot of ground today:</p>
<ul>
<li>Basic Rust syntax: variables, scalar and compound types, enums, structs,
references, functions, and methods.</li>
<li>Types and type inference.</li>
<li>Control flow constructs: loops, conditionals, and so on.</li>
<li>User-defined types: structs and enums.</li>
<li>Pattern matching: destructuring enums, structs, and arrays.</li>
</ul>
<h2 id="welcome-day-1-schedule"><a class="header" href="#welcome-day-1-schedule">Schedule</a></h2>
<p>Including 10 minute breaks, this session should take about 2 hours and 5 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>5 minutes</td></tr>
<tr><td>Hello, World</td><td>15 minutes</td></tr>
<tr><td>Types and Values</td><td>40 minutes</td></tr>
<tr><td>Control Flow Basics</td><td>40 minutes</td></tr>
</tbody></table>
</div><details>
This slide should take about 5 minutes. 
<p>Please remind the students that:</p>
<ul>
<li>They should ask questions when they get them, don't save them to the end.</li>
<li>The class is meant to be interactive and discussions are very much encouraged!
<ul>
<li>As an instructor, you should try to keep the discussions relevant, i.e.,
keep the discussions related to how Rust does things vs some other language.
It can be hard to find the right balance, but err on the side of allowing
discussions since they engage people much more than one-way communication.</li>
</ul>
</li>
<li>The questions will likely mean that we talk about things ahead of the slides.
<ul>
<li>This is perfectly okay! Repetition is an important part of learning.
Remember that the slides are just a support and you are free to skip them as
you like.</li>
</ul>
</li>
</ul>
<p>The idea for the first day is to show the "basic" things in Rust that should
have immediate parallels in other languages. The more advanced parts of Rust
come on the subsequent days.</p>
<p>If you're teaching this in a classroom, this is a good place to go over the
schedule. Note that there is an exercise at the end of each segment, followed by
a break. Plan to cover the exercise solution after the break. The times listed
here are a suggestion in order to keep the course on schedule. Feel free to be
flexible and adjust as necessary!</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="hello-world"></div><h1 id="hello-world-hello-world"><a class="header" href="#hello-world-hello-world">Hello, World</a></h1>
<p>This segment should take about 15 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>What is Rust?</td><td>10 minutes</td></tr>
<tr><td>Benefits of Rust</td><td>3 minutes</td></tr>
<tr><td>Playground</td><td>2 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="hello-world-what-is-rust"></div><h1 id="hello-world-what-is-rust-what-is-rust"><a class="header" href="#hello-world-what-is-rust-what-is-rust">What is Rust?</a></h1>
<p>Rust is a new programming language which had its <a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 release in 2015</a>:</p>
<ul>
<li>Rust is a statically compiled language in a similar role as C++
<ul>
<li><code>rustc</code> uses LLVM as its backend.</li>
</ul>
</li>
<li>Rust supports many
<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms and architectures</a>:
<ul>
<li>x86, ARM, WebAssembly, ...</li>
<li>Linux, Mac, Windows, ...</li>
</ul>
</li>
<li>Rust is used for a wide range of devices:
<ul>
<li>firmware and boot loaders,</li>
<li>smart displays,</li>
<li>mobile phones,</li>
<li>desktops,</li>
<li>servers.</li>
</ul>
</li>
</ul>
<details>
This slide should take about 10 minutes. 
<p>Rust fits in the same area as C++:</p>
<ul>
<li>High flexibility.</li>
<li>High level of control.</li>
<li>Can be scaled down to very constrained devices such as microcontrollers.</li>
<li>Has no runtime or garbage collection.</li>
<li>Focuses on reliability and safety without sacrificing performance.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="hello-world-benefits"></div><h1 id="hello-world-benefits-benefits-of-rust"><a class="header" href="#hello-world-benefits-benefits-of-rust">Benefits of Rust</a></h1>
<p>Some unique selling points of Rust:</p>
<ul>
<li>
<p><em>Compile time memory safety</em> - whole classes of memory bugs are prevented at
compile time</p>
<ul>
<li>No uninitialized variables.</li>
<li>No double-frees.</li>
<li>No use-after-free.</li>
<li>No <code>NULL</code> pointers.</li>
<li>No forgotten locked mutexes.</li>
<li>No data races between threads.</li>
<li>No iterator invalidation.</li>
</ul>
</li>
<li>
<p><em>No undefined runtime behavior</em> - what a Rust statement does is never left
unspecified</p>
<ul>
<li>Array access is bounds checked.</li>
<li>Integer overflow is defined (panic or wrap-around).</li>
</ul>
</li>
<li>
<p><em>Modern language features</em> - as expressive and ergonomic as higher-level
languages</p>
<ul>
<li>Enums and pattern matching.</li>
<li>Generics.</li>
<li>No overhead FFI.</li>
<li>Zero-cost abstractions.</li>
<li>Great compiler errors.</li>
<li>Built-in dependency manager.</li>
<li>Built-in support for testing.</li>
<li>Excellent Language Server Protocol support.</li>
</ul>
</li>
</ul>
<details>
This slide should take about 3 minutes. 
<p>Do not spend much time here. All of these points will be covered in more depth
later.</p>
<p>Make sure to ask the class which languages they have experience with. Depending
on the answer you can highlight different features of Rust:</p>
<ul>
<li>
<p>Experience with C or C++: Rust eliminates a whole class of <em>runtime errors</em>
via the borrow checker. You get performance like in C and C++, but you don't
have the memory unsafety issues. In addition, you get a modern language with
constructs like pattern matching and built-in dependency management.</p>
</li>
<li>
<p>Experience with Java, Go, Python, JavaScript...: You get the same memory
safety as in those languages, plus a similar high-level language feeling. In
addition you get fast and predictable performance like C and C++ (no garbage
collector) as well as access to low-level hardware (should you need it).</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="hello-world-playground"></div><h1 id="hello-world-playground-playground"><a class="header" href="#hello-world-playground-playground">Playground</a></h1>
<p>The <a href="https://play.rust-lang.org/">Rust Playground</a> provides an easy way to run
short Rust programs, and is the basis for the examples and exercises in this
course. Try running the "hello-world" program it starts with. It comes with a
few handy features:</p>
<ul>
<li>
<p>Under "Tools", use the <code>rustfmt</code> option to format your code in the "standard"
way.</p>
</li>
<li>
<p>Rust has two main "profiles" for generating code: Debug (extra runtime checks,
less optimization) and Release (fewer runtime checks, lots of optimization).
These are accessible under "Debug" at the top.</p>
</li>
<li>
<p>If you're interested, use "ASM" under "..." to see the generated assembly
code.</p>
</li>
</ul>
<details>
This slide should take about 2 minutes. 
<p>As students head into the break, encourage them to open up the playground and
experiment a little. Encourage them to keep the tab open and try things out
during the rest of the course. This is particularly helpful for advanced
students who want to know more about Rust's optimizations or generated assembly.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values"></div><h1 id="types-and-values-types-and-values"><a class="header" href="#types-and-values-types-and-values">Types and Values</a></h1>
<p>This segment should take about 40 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Hello, World</td><td>5 minutes</td></tr>
<tr><td>Variables</td><td>5 minutes</td></tr>
<tr><td>Values</td><td>5 minutes</td></tr>
<tr><td>Arithmetic</td><td>3 minutes</td></tr>
<tr><td>Type Inference</td><td>3 minutes</td></tr>
<tr><td>Exercise: Fibonacci</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-hello-world"></div><h1 id="types-and-values-hello-world-hello-world"><a class="header" href="#types-and-values-hello-world-hello-world">Hello, World</a></h1>
<p>Let us jump into the simplest possible Rust program, a classic Hello World
program:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!("Hello üåç!");
}</code></pre></pre>
<p>What you see:</p>
<ul>
<li>Functions are introduced with <code>fn</code>.</li>
<li>Blocks are delimited by curly braces like in C and C++.</li>
<li>The <code>main</code> function is the entry point of the program.</li>
<li>Rust has hygienic macros, <code>println!</code> is an example of this.</li>
<li>Rust strings are UTF-8 encoded and can contain any Unicode character.</li>
</ul>
<details>
This slide should take about 5 minutes. 
<p>This slide tries to make the students comfortable with Rust code. They will see
a ton of it over the next four days so we start small with something familiar.</p>
<p>Key points:</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is
imperative and it doesn't try to reinvent things unless absolutely necessary.</p>
</li>
<li>
<p>Rust is modern with full support for things like Unicode.</p>
</li>
<li>
<p>Rust uses macros for situations where you want to have a variable number of
arguments (no function <a href="#control-flow-basics-functions">overloading</a>).</p>
</li>
<li>
<p>Macros being 'hygienic' means they don't accidentally capture identifiers from
the scope they are used in. Rust macros are actually only
<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">partially hygienic</a>.</p>
</li>
<li>
<p>Rust is multi-paradigm. For example, it has powerful
<a href="https://doc.rust-lang.org/book/ch17-00-oop.html">object-oriented programming features</a>,
and, while it is not a functional language, it includes a range of
<a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">functional concepts</a>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-variables"></div><h1 id="types-and-values-variables-variables"><a class="header" href="#types-and-values-variables-variables">Variables</a></h1>
<p>Rust provides type safety via static typing. Variable bindings are made with
<code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 10;
    println!("x: {x}");
    // x = 20;
    // println!("x: {x}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Uncomment the <code>x = 20</code> to demonstrate that variables are immutable by default.
Add the <code>mut</code> keyword to allow changes.</p>
</li>
<li>
<p>The <code>i32</code> here is the type of the variable. This must be known at compile
time, but type inference (covered later) allows the programmer to omit it in
many cases.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-values"></div><h1 id="types-and-values-values-values"><a class="header" href="#types-and-values-values-values">Values</a></h1>
<p>Here are some basic built-in types, and the syntax for literal values of each
type.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Signed integers</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123_i64</code></td></tr>
<tr><td>Unsigned integers</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10_u16</code></td></tr>
<tr><td>Floating point numbers</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2_f32</code></td></tr>
<tr><td>Unicode scalar values</td><td><code>char</code></td><td><code>'a'</code>, <code>'Œ±'</code>, <code>'‚àû'</code></td></tr>
<tr><td>Booleans</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
</div>
<p>The types have widths as follows:</p>
<ul>
<li><code>iN</code>, <code>uN</code>, and <code>fN</code> are <em>N</em> bits wide,</li>
<li><code>isize</code> and <code>usize</code> are the width of a pointer,</li>
<li><code>char</code> is 32 bits wide,</li>
<li><code>bool</code> is 8 bits wide.</li>
</ul>
<details>
This slide should take about 5 minutes. 
<p>There are a few syntaxes which are not shown above:</p>
<ul>
<li>All underscores in numbers can be left out, they are for legibility only. So
<code>1_000</code> can be written as <code>1000</code> (or <code>10_00</code>), and <code>123_i64</code> can be written as
<code>123i64</code>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-arithmetic"></div><h1 id="types-and-values-arithmetic-arithmetic"><a class="header" href="#types-and-values-arithmetic-arithmetic">Arithmetic</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn interproduct(a: i32, b: i32, c: i32) -&gt; i32 {
    return a * b + b * c + c * a;
}

fn main() {
    println!("result: {}", interproduct(120, 100, 248));
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<p>This is the first time we've seen a function other than <code>main</code>, but the meaning
should be clear: it takes three integers, and returns an integer. Functions will
be covered in more detail later.</p>
<p>Arithmetic is very similar to other languages, with similar precedence.</p>
<p>What about integer overflow? In C and C++ overflow of <em>signed</em> integers is
actually undefined, and might do unknown things at runtime. In Rust, it's
defined.</p>
<p>Change the <code>i32</code>'s to <code>i16</code> to see an integer overflow, which panics (checked)
in a debug build and wraps in a release build. There are other options, such as
overflowing, saturating, and carrying. These are accessed with method syntax,
e.g., <code>(a * b).saturating_add(b * c).saturating_add(c * a)</code>.</p>
<p>In fact, the compiler will detect overflow of constant expressions, which is why
the example requires a separate function.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-inference"></div><h1 id="types-and-values-inference-type-inference"><a class="header" href="#types-and-values-inference-type-inference">Type Inference</a></h1>
<p>Rust will look at how the variable is <em>used</em> to determine the type:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn takes_u32(x: u32) {
    println!("u32: {x}");
}

fn takes_i8(y: i8) {
    println!("i8: {y}");
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<p>This slide demonstrates how the Rust compiler infers types based on constraints
given by variable declarations and usages.</p>
<p>It is very important to emphasize that variables declared like this are not of
some sort of dynamic "any type" that can hold any data. The machine code
generated by such declaration is identical to the explicit declaration of a
type. The compiler does the job for us and helps us write more concise code.</p>
<p>When nothing constrains the type of an integer literal, Rust defaults to <code>i32</code>.
This sometimes appears as <code>{integer}</code> in error messages. Similarly,
floating-point literals default to <code>f64</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">fn main() {
    let x = 3.14;
    let y = 20;
    assert_eq!(x, y);
    // ERROR: no implementation for `{float} == {integer}`
}</code></pre></pre>
</details><div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-exercise"></div><h1 id="types-and-values-exercise-exercise-fibonacci"><a class="header" href="#types-and-values-exercise-exercise-fibonacci">Exercise: Fibonacci</a></h1>
<p>The Fibonacci sequence begins with <code>[0,1]</code>. For n&gt;1, the n'th Fibonacci number
is calculated recursively as the sum of the n-1'th and n-2'th Fibonacci numbers.</p>
<p>Write a function <code>fib(n)</code> that calculates the n'th Fibonacci number. When will
this function panic?</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        // The base case.
        todo!("Implement this")
    } else {
        // The recursive case.
        todo!("Implement this")
    }
}

fn main() {
    let n = 20;
    println!("fib({n}) = {}", fib(n));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="types-and-values-solution"></div><h1 id="types-and-values-solution-solution"><a class="header" href="#types-and-values-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

fn main() {
    let n = 20;
    println!("fib({n}) = {}", fib(n));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics"></div><h1 id="control-flow-basics-control-flow-basics"><a class="header" href="#control-flow-basics-control-flow-basics">Control Flow Basics</a></h1>
<p>This segment should take about 40 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>if Expressions</td><td>4 minutes</td></tr>
<tr><td>Loops</td><td>5 minutes</td></tr>
<tr><td>break and continue</td><td>4 minutes</td></tr>
<tr><td>Blocks and Scopes</td><td>5 minutes</td></tr>
<tr><td>Functions</td><td>3 minutes</td></tr>
<tr><td>Macros</td><td>2 minutes</td></tr>
<tr><td>Exercise: Collatz Sequence</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-if"></div><h1 id="control-flow-basics-if-if-expressions"><a class="header" href="#control-flow-basics-if-if-expressions"><code>if</code> expressions</a></h1>
<p>You use
<a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> expressions</a>
exactly like <code>if</code> statements in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 10;
    if x == 0 {
        println!("zero!");
    } else if x &lt; 100 {
        println!("biggish");
    } else {
        println!("huge");
    }
}</code></pre></pre>
<p>In addition, you can use <code>if</code> as an expression. The last expression of each
block becomes the value of the <code>if</code> expression:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 10;
    let size = if x &lt; 20 { "small" } else { "large" };
    println!("number size: {}", size);
}</code></pre></pre>
<details>
This slide should take about 4 minutes. 
<p>Because <code>if</code> is an expression and must have a particular type, both of its
branch blocks must have the same type. Show what happens if you add <code>;</code> after
<code>"small"</code> in the second example.</p>
<p>When <code>if</code> is used in an expression, the expression must have a <code>;</code> to separate
it from the next statement. Remove the <code>;</code> before <code>println!</code> to see the compiler
error.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-loops"></div><h1 id="control-flow-basics-loops-loops"><a class="header" href="#control-flow-basics-loops-loops">Loops</a></h1>
<p>There are three looping keywords in Rust: <code>while</code>, <code>loop</code>, and <code>for</code>:</p>
<h2 id="control-flow-basics-loops-while"><a class="header" href="#control-flow-basics-loops-while"><code>while</code></a></h2>
<p>The
<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops"><code>while</code> keyword</a>
works much like in other languages, executing the loop body as long as the
condition is true.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 200;
    while x &gt;= 10 {
        x = x / 2;
    }
    println!("Final x: {x}");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-loops-for"></div><h1 id="control-flow-basics-loops-for-for"><a class="header" href="#control-flow-basics-loops-for-for"><code>for</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop</a> iterates over
ranges of values or the items in a collection:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    for x in 1..5 {
        println!("x: {x}");
    }

    for elem in [1, 2, 3, 4, 5] {
        println!("elem: {elem}");
    }
}</code></pre></pre>
<details>
<ul>
<li>Under the hood <code>for</code> loops use a concept called "iterators" to handle
iterating over different kinds of ranges/collections. Iterators will be
discussed in more detail later.</li>
<li>Note that the first <code>for</code> loop only iterates to <code>4</code>. Show the <code>1..=5</code> syntax
for an inclusive range.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-loops-loop"></div><h1 id="control-flow-basics-loops-loop-loop"><a class="header" href="#control-flow-basics-loops-loop-loop"><code>loop</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.loop.html"><code>loop</code> statement</a> just
loops forever, until a <code>break</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut i = 0;
    loop {
        i += 1;
        println!("{i}");
        if i &gt; 100 {
            break;
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-break-continue"></div><h1 id="control-flow-basics-break-continue-break-and-continue"><a class="header" href="#control-flow-basics-break-continue-break-and-continue"><code>break</code> and <code>continue</code></a></h1>
<p>If you want to immediately start the next iteration use
<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions"><code>continue</code></a>.</p>
<p>If you want to exit any kind of loop early, use
<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions"><code>break</code></a>.
With <code>loop</code>, this can take an optional expression that becomes the value of the
<code>loop</code> expression.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut i = 0;
    loop {
        i += 1;
        if i &gt; 5 {
            break;
        }
        if i % 2 == 0 {
            continue;
        }
        println!("{}", i);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-break-continue-labels"></div><h1 id="control-flow-basics-break-continue-labels-labels"><a class="header" href="#control-flow-basics-break-continue-labels-labels">Labels</a></h1>
<p>Both <code>continue</code> and <code>break</code> can optionally take a label argument which is used
to break out of nested loops:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = [[5, 6, 7], [8, 9, 10], [21, 15, 32]];
    let mut elements_searched = 0;
    let target_value = 10;
    'outer: for i in 0..=2 {
        for j in 0..=2 {
            elements_searched += 1;
            if s[i][j] == target_value {
                break 'outer;
            }
        }
    }
    print!("elements searched: {elements_searched}");
}</code></pre></pre>
<details>
<ul>
<li>Note that <code>loop</code> is the only looping construct which returns a non-trivial
value. This is because it's guaranteed to be entered at least once (unlike
<code>while</code> and <code>for</code> loops).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-blocks-and-scopes"></div><h1 id="control-flow-basics-blocks-and-scopes-blocks-and-scopes"><a class="header" href="#control-flow-basics-blocks-and-scopes-blocks-and-scopes">Blocks and Scopes</a></h1>
<h2 id="control-flow-basics-blocks-and-scopes-blocks"><a class="header" href="#control-flow-basics-blocks-and-scopes-blocks">Blocks</a></h2>
<p>A block in Rust contains a sequence of expressions, enclosed by braces <code>{}</code>.
Each block has a value and a type, which are those of the last expression of the
block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let z = 13;
    let x = {
        let y = 10;
        println!("y: {y}");
        z - y
    };
    println!("x: {x}");
}</code></pre></pre>
<p>If the last expression ends with <code>;</code>, then the resulting value and type is <code>()</code>.</p>
<details>
This slide and its sub-slides should take about 5 minutes. 
<ul>
<li>You can show how the value of the block changes by changing the last line in
the block. For instance, adding/removing a semicolon or using a <code>return</code>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-blocks-and-scopes-scopes"></div><h1 id="control-flow-basics-blocks-and-scopes-scopes-scopes-and-shadowing"><a class="header" href="#control-flow-basics-blocks-and-scopes-scopes-scopes-and-shadowing">Scopes and Shadowing</a></h1>
<p>A variable's scope is limited to the enclosing block.</p>
<p>You can shadow variables, both those from outer scopes and variables from the
same scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 10;
    println!("before: {a}");
    {
        let a = "hello";
        println!("inner scope: {a}");

        let a = true;
        println!("shadowed in inner scope: {a}");
    }

    println!("after: {a}");
}</code></pre></pre>
<details>
<ul>
<li>Show that a variable's scope is limited by adding a <code>b</code> in the inner block in
the last example, and then trying to access it outside that block.</li>
<li>Shadowing is different from mutation, because after shadowing both variable's
memory locations exist at the same time. Both are available under the same
name, depending where you use it in the code.</li>
<li>A shadowing variable can have a different type.</li>
<li>Shadowing looks obscure at first, but is convenient for holding on to values
after <code>.unwrap()</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-functions"></div><h1 id="control-flow-basics-functions-functions"><a class="header" href="#control-flow-basics-functions-functions">Functions</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn gcd(a: u32, b: u32) -&gt; u32 {
    if b &gt; 0 {
        gcd(b, a % b)
    } else {
        a
    }
}

fn main() {
    println!("gcd: {}", gcd(143, 52));
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<ul>
<li>Declaration parameters are followed by a type (the reverse of some programming
languages), then a return type.</li>
<li>The last expression in a function body (or any block) becomes the return
value. Simply omit the <code>;</code> at the end of the expression. The <code>return</code> keyword
can be used for early return, but the "bare value" form is idiomatic at the
end of a function (refactor <code>gcd</code> to use a <code>return</code>).</li>
<li>Some functions have no return value, and return the 'unit type', <code>()</code>. The
compiler will infer this if the <code>-&gt; ()</code> return type is omitted.</li>
<li>Overloading is not supported -- each function has a single implementation.
<ul>
<li>Always takes a fixed number of parameters. Default arguments are not
supported. Macros can be used to support variadic functions.</li>
<li>Always takes a single set of parameter types. These types can be generic,
which will be covered later.</li>
</ul>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-macros"></div><h1 id="control-flow-basics-macros-macros"><a class="header" href="#control-flow-basics-macros-macros">Macros</a></h1>
<p>Macros are expanded into Rust code during compilation, and can take a variable
number of arguments. They are distinguished by a <code>!</code> at the end. The Rust
standard library includes an assortment of useful macros.</p>
<ul>
<li><code>println!(format, ..)</code> prints a line to standard output, applying formatting
described in <a href="https://doc.rust-lang.org/std/fmt/index.html"><code>std::fmt</code></a>.</li>
<li><code>format!(format, ..)</code> works just like <code>println!</code> but returns the result as a
string.</li>
<li><code>dbg!(expression)</code> logs the value of the expression and returns it.</li>
<li><code>todo!()</code> marks a bit of code as not-yet-implemented. If executed, it will
panic.</li>
<li><code>unreachable!()</code> marks a bit of code as unreachable. If executed, it will
panic.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn factorial(n: u32) -&gt; u32 {
    let mut product = 1;
    for i in 1..=n {
        product *= dbg!(i);
    }
    product
}

fn fizzbuzz(n: u32) -&gt; u32 {
    todo!()
}

fn main() {
    let n = 4;
    println!("{n}! = {}", factorial(n));
}</code></pre></pre>
<details>
This slide should take about 2 minutes. 
<p>The takeaway from this section is that these common conveniences exist, and how
to use them. Why they are defined as macros, and what they expand to, is not
especially critical.</p>
<p>The course does not cover defining macros, but a later section will describe use
of derive macros.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-exercise"></div><h1 id="control-flow-basics-exercise-exercise-collatz-sequence"><a class="header" href="#control-flow-basics-exercise-exercise-collatz-sequence">Exercise: Collatz Sequence</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz Sequence</a> is
defined as follows, for an arbitrary n<sub>1</sub> greater than zero:</p>
<ul>
<li>If <em>n<sub>i</sub></em> is 1, then the sequence terminates at <em>n<sub>i</sub></em>.</li>
<li>If <em>n<sub>i</sub></em> is even, then <em>n<sub>i+1</sub> = n<sub>i</sub> / 2</em>.</li>
<li>If <em>n<sub>i</sub></em> is odd, then <em>n<sub>i+1</sub> = 3 * n<sub>i</sub> + 1</em>.</li>
</ul>
<p>For example, beginning with <em>n<sub>1</sub></em> = 3:</p>
<ul>
<li>3 is odd, so <em>n<sub>2</sub></em> = 3 * 3 + 1 = 10;</li>
<li>10 is even, so <em>n<sub>3</sub></em> = 10 / 2 = 5;</li>
<li>5 is odd, so <em>n<sub>4</sub></em> = 3 * 5 + 1 = 16;</li>
<li>16 is even, so <em>n<sub>5</sub></em> = 16 / 2 = 8;</li>
<li>8 is even, so <em>n<sub>6</sub></em> = 8 / 2 = 4;</li>
<li>4 is even, so <em>n<sub>7</sub></em> = 4 / 2 = 2;</li>
<li>2 is even, so <em>n<sub>8</sub></em> = 1; and</li>
<li>the sequence terminates.</li>
</ul>
<p>Write a function to calculate the length of the collatz sequence for a given
initial <code>n</code>.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
  todo!("Implement this")
}

fn main() {
  todo!("Implement this")
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="control-flow-basics-solution"></div><h1 id="control-flow-basics-solution-solution"><a class="header" href="#control-flow-basics-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
    let mut len = 1;
    while n &gt; 1 {
        n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };
        len += 1;
    }
    len
}

#[test]
fn test_collatz_length() {
    assert_eq!(collatz_length(11), 15);
}

fn main() {
    println!("Length: {}", collatz_length(11));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-1-afternoon"></div><h1 id="welcome-day-1-afternoon-welcome-back"><a class="header" href="#welcome-day-1-afternoon-welcome-back">Welcome Back</a></h1>
<p>Including 10 minute breaks, this session should take about 2 hours and 35 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Tuples and Arrays</td><td>35 minutes</td></tr>
<tr><td>References</td><td>55 minutes</td></tr>
<tr><td>User-Defined Types</td><td>50 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays"></div><h1 id="tuples-and-arrays-tuples-and-arrays"><a class="header" href="#tuples-and-arrays-tuples-and-arrays">Tuples and Arrays</a></h1>
<p>This segment should take about 35 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Arrays</td><td>5 minutes</td></tr>
<tr><td>Tuples</td><td>5 minutes</td></tr>
<tr><td>Array Iteration</td><td>3 minutes</td></tr>
<tr><td>Patterns and Destructuring</td><td>5 minutes</td></tr>
<tr><td>Exercise: Nested Arrays</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays-arrays"></div><h1 id="tuples-and-arrays-arrays-arrays"><a class="header" href="#tuples-and-arrays-arrays-arrays">Arrays</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!("a: {a:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>A value of the array type <code>[T; N]</code> holds <code>N</code> (a compile-time constant)
elements of the same type <code>T</code>. Note that the length of the array is <em>part of
its type</em>, which means that <code>[u8; 3]</code> and <code>[u8; 4]</code> are considered two
different types. Slices, which have a size determined at runtime, are covered
later.</p>
</li>
<li>
<p>Try accessing an out-of-bounds array element. Array accesses are checked at
runtime. Rust can usually optimize these checks away, and they can be avoided
using unsafe Rust.</p>
</li>
<li>
<p>We can use literals to assign values to arrays.</p>
</li>
<li>
<p>The <code>println!</code> macro asks for the debug implementation with the <code>?</code> format
parameter: <code>{}</code> gives the default output, <code>{:?}</code> gives the debug output. Types
such as integers and strings implement the default output, but arrays only
implement the debug output. This means that we must use debug output here.</p>
</li>
<li>
<p>Adding <code>#</code>, eg <code>{a:#?}</code>, invokes a "pretty printing" format, which can be
easier to read.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays-tuples"></div><h1 id="tuples-and-arrays-tuples-tuples"><a class="header" href="#tuples-and-arrays-tuples-tuples">Tuples</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let t: (i8, bool) = (7, true);
    println!("t.0: {}", t.0);
    println!("t.1: {}", t.1);
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Like arrays, tuples have a fixed length.</p>
</li>
<li>
<p>Tuples group together values of different types into a compound type.</p>
</li>
<li>
<p>Fields of a tuple can be accessed by the period and the index of the value,
e.g. <code>t.0</code>, <code>t.1</code>.</p>
</li>
<li>
<p>The empty tuple <code>()</code> is referred to as the "unit type" and signifies absence
of a return value, akin to <code>void</code> in other languages.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays-iteration"></div><h1 id="tuples-and-arrays-iteration-array-iteration"><a class="header" href="#tuples-and-arrays-iteration-array-iteration">Array Iteration</a></h1>
<p>The <code>for</code> statement supports iterating over arrays (but not tuples).</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let primes = [2, 3, 5, 7, 11, 13, 17, 19];
    for prime in primes {
        for i in 2..prime {
            assert_ne!(prime % i, 0);
        }
    }
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<p>This functionality uses the <code>IntoIterator</code> trait, but we haven't covered that
yet.</p>
<p>The <code>assert_ne!</code> macro is new here. There are also <code>assert_eq!</code> and <code>assert!</code>
macros. These are always checked, while debug-only variants like <code>debug_assert!</code>
compile to nothing in release builds.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays-destructuring"></div><h1 id="tuples-and-arrays-destructuring-patterns-and-destructuring"><a class="header" href="#tuples-and-arrays-destructuring-patterns-and-destructuring">Patterns and Destructuring</a></h1>
<p>When working with tuples and other structured values it's common to want to
extract the inner values into local variables. This can be done manually by
directly accessing the inner values:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn print_tuple(tuple: (i32, i32)) {
    let left = tuple.0;
    let right = tuple.1;
    println!("left: {left}, right: {right}");
}</code></pre></pre>
<p>However, Rust also supports using pattern matching to destructure a larger value
into its constituent parts:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn print_tuple(tuple: (i32, i32)) {
    let (left, right) = tuple;
    println!("left: {left}, right: {right}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>The patterns used here are "irrefutable", meaning that the compiler can
statically verify that the value on the right of <code>=</code> has the same structure as
the pattern.</li>
<li>A variable name is an irrefutable pattern that always matches any value, hence
why we can also use <code>let</code> to declare a single variable.</li>
<li>Rust also supports using patterns in conditionals, allowing for equality
comparison and destructuring to happen at the same time. This form of pattern
matching will be discussed in more detail later.</li>
<li>Edit the examples above to show the compiler error when the pattern doesn't
match the value being matched on.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays-exercise"></div><h1 id="tuples-and-arrays-exercise-exercise-nested-arrays"><a class="header" href="#tuples-and-arrays-exercise-exercise-nested-arrays">Exercise: Nested Arrays</a></h1>
<p>Arrays can contain other arrays:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
<span class="boring">}</span></code></pre></pre>
<p>What is the type of this variable?</p>
<p>Use an array such as the above to write a function <code>transpose</code> which will
transpose a matrix (turn rows into columns):</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="tuples-and-arrays-exercise-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="tuples-and-arrays-exercise-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="tuples-and-arrays-exercise-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="tuples-and-arrays-exercise-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="tuples-and-arrays-exercise-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7‚é§</text><text x="250" y="28" >8‚é•</text><text x="250" y="44" >9‚é¶</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">‚éõ</text><text x="98" y="12">‚é°</text><text x="106" y="12">1</text></g><g><text x="90" y="28">‚éú</text><text x="98" y="28">‚é¢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">‚éù</text><text x="98" y="44">‚é£</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3‚é§</text><text x="154" y="12">‚éû</text></g><g><text x="138" y="28">6‚é•</text><text x="154" y="28">‚éü</text></g><g><text x="138" y="44">9‚é¶</text><text x="154" y="44">‚é†</text></g><g><text x="210" y="12">‚é°</text><text x="218" y="12">1</text></g><g><text x="210" y="28">‚é¢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">‚é£</text><text x="218" y="44">3</text></g></svg></div>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the function.
This function only operates on 3x3 matrices.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!("matrix: {:#?}", matrix);
    let transposed = transpose(matrix);
    println!("transposed: {:#?}", transposed);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="tuples-and-arrays-solution"></div><h1 id="tuples-and-arrays-solution-solution"><a class="header" href="#tuples-and-arrays-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    result
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!("matrix: {:#?}", matrix);
    let transposed = transpose(matrix);
    println!("transposed: {:#?}", transposed);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="references"></div><h1 id="references-references"><a class="header" href="#references-references">References</a></h1>
<p>This segment should take about 55 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Shared References</td><td>10 minutes</td></tr>
<tr><td>Exclusive References</td><td>10 minutes</td></tr>
<tr><td>Slices: &amp;[T]</td><td>10 minutes</td></tr>
<tr><td>Strings</td><td>10 minutes</td></tr>
<tr><td>Exercise: Geometry</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="references-shared"></div><h1 id="references-shared-shared-references"><a class="header" href="#references-shared-shared-references">Shared References</a></h1>
<p>A reference provides a way to access another value without taking responsibility
for the value, and is also called "borrowing". Shared references are read-only,
and the referenced data cannot change.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 'A';
    let b = 'B';
    let mut r: &amp;char = &amp;a;
    println!("r: {}", *r);
    r = &amp;b;
    println!("r: {}", *r);
}</code></pre></pre>
<p>A shared reference to a type <code>T</code> has type <code>&amp;T</code>. A reference value is made with
the <code>&amp;</code> operator. The <code>*</code> operator "dereferences" a reference, yielding its
value.</p>
<p>Rust will statically forbid dangling references:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn x_axis(x: &amp;i32) -&gt; &amp;(i32, i32) {
    let point = (*x, 0);
    return &amp;point;
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li>
<p>A reference is said to "borrow" the value it refers to, and this is a good
model for students not familiar with pointers: code can use the reference to
access the value, but is still "owned" by the original variable. The course
will get into more detail on ownership in day 3.</p>
</li>
<li>
<p>References are implemented as pointers, and a key advantage is that they can
be much smaller than the thing they point to. Students familiar with C or C++
will recognize references as pointers. Later parts of the course will cover
how Rust prevents the memory-safety bugs that come from using raw pointers.</p>
</li>
<li>
<p>Rust does not automatically create references for you - the <code>&amp;</code> is always
required.</p>
</li>
<li>
<p>Rust will auto-dereference in some cases, in particular when invoking methods
(try <code>r.is_ascii()</code>). There is no need for an <code>-&gt;</code> operator like in C++.</p>
</li>
<li>
<p>In this example, <code>r</code> is mutable so that it can be reassigned (<code>r = &amp;b</code>). Note
that this re-binds <code>r</code>, so that it refers to something else. This is different
from C++, where assignment to a reference changes the referenced value.</p>
</li>
<li>
<p>A shared reference does not allow modifying the value it refers to, even if
that value was mutable. Try <code>*r = 'X'</code>.</p>
</li>
<li>
<p>Rust is tracking the lifetimes of all references to ensure they live long
enough. Dangling references cannot occur in safe Rust. <code>x_axis</code> would return a
reference to <code>point</code>, but <code>point</code> will be deallocated when the function
returns, so this will not compile.</p>
</li>
<li>
<p>We will talk more about borrowing when we get to ownership.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="references-exclusive"></div><h1 id="references-exclusive-exclusive-references"><a class="header" href="#references-exclusive-exclusive-references">Exclusive References</a></h1>
<p>Exclusive references, also known as mutable references, allow changing the value
they refer to. They have type <code>&amp;mut T</code>.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut point = (1, 2);
    let x_coord = &amp;mut point.0;
    *x_coord = 20;
    println!("point: {point:?}");
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<p>Key points:</p>
<ul>
<li>
<p>"Exclusive" means that only this reference can be used to access the value. No
other references (shared or exclusive) can exist at the same time, and the
referenced value cannot be accessed while the exclusive reference exists. Try
making an <code>&amp;point.0</code> or changing <code>point.0</code> while <code>x_coord</code> is alive.</p>
</li>
<li>
<p>Be sure to note the difference between <code>let mut x_coord: &amp;i32</code> and
<code>let x_coord: &amp;mut i32</code>. The first one represents a shared reference which can
be bound to different values, while the second represents an exclusive
reference to a mutable value.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="references-slices"></div><h1 id="references-slices-slices"><a class="header" href="#references-slices-slices">Slices</a></h1>
<p>A slice gives you a view into a larger collection:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!("a: {a:?}");

    let s: &amp;[i32] = &amp;a[2..4];

    println!("s: {s:?}");
}</code></pre></pre>
<ul>
<li>Slices borrow data from the sliced type.</li>
<li>Question: What happens if you modify <code>a[3]</code> right before printing <code>s</code>?</li>
</ul>
<details>
This slide should take about 10 minutes. 
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending
indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the
starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are
identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are
identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code>
(<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform
computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain
'alive' (in scope) for at least as long as our slice.</p>
</li>
<li>
<p>The question about modifying <code>a[3]</code> can spark an interesting discussion, but
the answer is that for memory safety reasons you cannot do it through <code>a</code> at
this point in the execution, but you can read the data from both <code>a</code> and <code>s</code>
safely. It works before you created the slice, and again after the <code>println</code>,
when the slice is no longer used.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="references-strings"></div><!-- NOTES:
Including `&str` as a way of representing a slice of valid utf-8
-->
<h1 id="references-strings-strings"><a class="header" href="#references-strings-strings">Strings</a></h1>
<p>We can now understand the two string types in Rust:</p>
<ul>
<li><code>&amp;str</code> is a slice of UTF-8 encoded bytes, similar to <code>&amp;[u8]</code>.</li>
<li><code>String</code> is an owned buffer of UTF-8 encoded bytes, similar to <code>Vec&lt;T&gt;</code>.</li>
</ul>
<!-- Avoid using fixed integers when slicing since this breaks
translations. Using the length of s1 and s2 is safe. -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: &amp;str = "World";
    println!("s1: {s1}");

    let mut s2: String = String::from("Hello ");
    println!("s2: {s2}");
    s2.push_str(s1);
    println!("s2: {s2}");

    let s3: &amp;str = &amp;s2[s2.len() - s1.len()..];
    println!("s3: {s3}");
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li>
<p><code>&amp;str</code> introduces a string slice, which is an immutable reference to UTF-8
encoded string data stored in a block of memory. String literals (<code>"Hello"</code>),
are stored in the program‚Äôs binary.</p>
</li>
<li>
<p>Rust's <code>String</code> type is a wrapper around a vector of bytes. As with a
<code>Vec&lt;T&gt;</code>, it is owned.</p>
</li>
<li>
<p>As with many other types <code>String::from()</code> creates a string from a string
literal; <code>String::new()</code> creates a new empty string, to which string data can
be added using the <code>push()</code> and <code>push_str()</code> methods.</p>
</li>
<li>
<p>The <code>format!()</code> macro is a convenient way to generate an owned string from
dynamic values. It accepts the same format specification as <code>println!()</code>.</p>
</li>
<li>
<p>You can borrow <code>&amp;str</code> slices from <code>String</code> via <code>&amp;</code> and optionally range
selection. If you select a byte range that is not aligned to character
boundaries, the expression will panic. The <code>chars</code> iterator iterates over
characters and is preferred over trying to get character boundaries right.</p>
</li>
<li>
<p>For C++ programmers: think of <code>&amp;str</code> as <code>std::string_view</code> from C++, but the
one that always points to a valid string in memory. Rust <code>String</code> is a rough
equivalent of <code>std::string</code> from C++ (main difference: it can only contain
UTF-8 encoded bytes and will never use a small-string optimization).</p>
</li>
<li>
<p>Byte strings literals allow you to create a <code>&amp;[u8]</code> value directly:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!("{:?}", b"abc");
    println!("{:?}", &amp;[97, 98, 99]);
}</code></pre></pre>
</li>
<li>
<p>Raw strings allow you to create a <code>&amp;str</code> value with escapes disabled:
<code>r"\n" == "\\n"</code>. You can embed double-quotes by using an equal amount of <code>#</code>
on either side of the quotes:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(r#"&lt;a href="link.html"&gt;link&lt;/a&gt;"#);
    println!("&lt;a href=\"link.html\"&gt;link&lt;/a&gt;");
}</code></pre></pre>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="references-exercise"></div><h1 id="references-exercise-exercise-geometry"><a class="header" href="#references-exercise-exercise-geometry">Exercise: Geometry</a></h1>
<p>We will create a few utility functions for 3-dimensional geometry, representing
a point as <code>[f64;3]</code>. It is up to you to determine the function signatures.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Calculate the magnitude of a vector by summing the squares of its coordinates
// and taking the square root. Use the `sqrt()` method to calculate the square
// root, like `v.sqrt()`.


fn magnitude(...) -&gt; f64 {
    todo!()
}

// Normalize a vector by calculating its magnitude and dividing all of its
// coordinates by that magnitude.


fn normalize(...) {
    todo!()
}

// Use the following `main` to test your work.

fn main() {
    println!("Magnitude of a unit vector: {}", magnitude(&amp;[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!("Magnitude of {v:?}: {}", magnitude(&amp;v));
    normalize(&amp;mut v);
    println!("Magnitude of {v:?} after normalization: {}", magnitude(&amp;v));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="references-solution"></div><h1 id="references-solution-solution"><a class="header" href="#references-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Calculate the magnitude of the given vector.
fn magnitude(vector: &amp;[f64; 3]) -&gt; f64 {
    let mut mag_squared = 0.0;
    for coord in vector {
        mag_squared += coord * coord;
    }
    mag_squared.sqrt()
}

/// Change the magnitude of the vector to 1.0 without changing its direction.
fn normalize(vector: &amp;mut [f64; 3]) {
    let mag = magnitude(vector);
    for item in vector {
        *item /= mag;
    }
}

fn main() {
    println!("Magnitude of a unit vector: {}", magnitude(&amp;[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!("Magnitude of {v:?}: {}", magnitude(&amp;v));
    normalize(&amp;mut v);
    println!("Magnitude of {v:?} after normalization: {}", magnitude(&amp;v));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types"></div><h1 id="user-defined-types-user-defined-types"><a class="header" href="#user-defined-types-user-defined-types">User-Defined Types</a></h1>
<p>This segment should take about 50 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Named Structs</td><td>10 minutes</td></tr>
<tr><td>Tuple Structs</td><td>10 minutes</td></tr>
<tr><td>Enums</td><td>5 minutes</td></tr>
<tr><td>Static</td><td>5 minutes</td></tr>
<tr><td>Type Aliases</td><td>2 minutes</td></tr>
<tr><td>Exercise: Elevator Events</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-named-structs"></div><h1 id="user-defined-types-named-structs-named-structs"><a class="header" href="#user-defined-types-named-structs-named-structs">Named Structs</a></h1>
<p>Like C and C++, Rust has support for custom structs:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}

fn describe(person: &amp;Person) {
    println!("{} is {} years old", person.name, person.age);
}

fn main() {
    let mut peter = Person { name: String::from("Peter"), age: 27 };
    describe(&amp;peter);

    peter.age = 28;
    describe(&amp;peter);

    let name = String::from("Avery");
    let age = 39;
    let avery = Person { name, age };
    describe(&amp;avery);

    let jackie = Person { name: String::from("Jackie"), ..avery };
    describe(&amp;jackie);
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<p>Key Points:</p>
<ul>
<li>Structs work like in C or C++.
<ul>
<li>Like in C++, and unlike in C, no typedef is needed to define a type.</li>
<li>Unlike in C++, there is no inheritance between structs.</li>
</ul>
</li>
<li>This may be a good time to let people know there are different types of
structs.
<ul>
<li>Zero-sized structs (e.g. <code>struct Foo;</code>) might be used when implementing a
trait on some type but don‚Äôt have any data that you want to store in the
value itself.</li>
<li>The next slide will introduce Tuple structs, used when the field names are
not important.</li>
</ul>
</li>
<li>If you already have variables with the right names, then you can create the
struct using a shorthand.</li>
<li>The syntax <code>..avery</code> allows us to copy the majority of the fields from the old
struct without having to explicitly type it all out. It must always be the
last element.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-tuple-structs"></div><!-- NOTES:
Tuple structs, newtype wrappers, unit-like structs, including initialization syntax
-->
<h1 id="user-defined-types-tuple-structs-tuple-structs"><a class="header" href="#user-defined-types-tuple-structs-tuple-structs">Tuple Structs</a></h1>
<p>If the field names are unimportant, you can use a tuple struct:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!("({}, {})", p.0, p.1);
}</code></pre></pre>
<p>This is often used for single-field wrappers (called newtypes):</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundsOfForce {
    todo!("Ask a rocket scientist at NASA")
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li>Newtypes are a great way to encode additional information about the value in a
primitive type, for example:
<ul>
<li>The number is measured in some units: <code>Newtons</code> in the example above.</li>
<li>The value passed some validation when it was created, so you no longer have
to validate it again at every use: <code>PhoneNumber(String)</code> or
<code>OddNumber(u32)</code>.</li>
</ul>
</li>
<li>Demonstrate how to add a <code>f64</code> value to a <code>Newtons</code> type by accessing the
single field in the newtype.
<ul>
<li>Rust generally doesn‚Äôt like inexplicit things, like automatic unwrapping or
for instance using booleans as integers.</li>
<li>Operator overloading is discussed on Day 3 (generics).</li>
</ul>
</li>
<li>The example is a subtle reference to the
<a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>
failure.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-enums"></div><h1 id="user-defined-types-enums-enums"><a class="header" href="#user-defined-types-enums-enums">Enums</a></h1>
<p>The <code>enum</code> keyword allows the creation of a type which has a few different
variants:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Direction {
    Left,
    Right,
}

#[derive(Debug)]
enum PlayerMove {
    Pass,                        // Simple variant
    Run(Direction),              // Tuple variant
    Teleport { x: u32, y: u32 }, // Struct variant
}

fn main() {
    let m: PlayerMove = PlayerMove::Run(Direction::Left);
    println!("On this turn: {:?}", m);
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>Key Points:</p>
<ul>
<li>Enumerations allow you to collect a set of values under one type.</li>
<li><code>Direction</code> is a type with variants. There are two values of <code>Direction</code>:
<code>Direction::Left</code> and <code>Direction::Right</code>.</li>
<li><code>PlayerMove</code> is a type with three variants. In addition to the payloads, Rust
will store a discriminant so that it knows at runtime which variant is in a
<code>PlayerMove</code> value.</li>
<li>This might be a good time to compare structs and enums:
<ul>
<li>In both, you can have a simple version without fields (unit struct) or one
with different types of fields (variant payloads).</li>
<li>You could even implement the different variants of an enum with separate
structs but then they wouldn‚Äôt be the same type as they would if they were
all defined in an enum.</li>
</ul>
</li>
<li>Rust uses minimal space to store the discriminant.
<ul>
<li>
<p>If necessary, it stores an integer of the smallest required size</p>
</li>
<li>
<p>If the allowed variant values do not cover all bit patterns, it will use
invalid bit patterns to encode the discriminant (the "niche optimization").
For example, <code>Option&lt;&amp;u8&gt;</code> stores either a pointer to an integer or <code>NULL</code>
for the <code>None</code> variant.</p>
</li>
<li>
<p>You can control the discriminant if needed (e.g., for compatibility with C):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">#[repr(u32)]
enum Bar {
    A, // 0
    B = 10000,
    C, // 10001
}

fn main() {
    println!("A: {}", Bar::A as u32);
    println!("B: {}", Bar::B as u32);
    println!("C: {}", Bar::C as u32);
}</code></pre></pre>
<p>Without <code>repr</code>, the discriminant type takes 2 bytes, because 10001 fits 2
bytes.</p>
</li>
</ul>
</li>
</ul>
<h2 id="user-defined-types-enums-more-to-explore"><a class="header" href="#user-defined-types-enums-more-to-explore">More to Explore</a></h2>
<p>Rust has several optimizations it can employ to make enums take up less space.</p>
<ul>
<li>
<p>Null pointer optimization: For
<a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust
guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</p>
<p>Example code if you want to show how the bitwise representation <em>may</em> look
like in practice. It's important to note that the compiler provides no
guarantees regarding this representation, therefore this is totally unsafe.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!("- {}: {:#x}", stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

fn main() {
    unsafe {
        println!("bool:");
        dbg_bits!(false, u8);
        dbg_bits!(true, u8);

        println!("Option&lt;bool&gt;:");
        dbg_bits!(None::&lt;bool&gt;, u8);
        dbg_bits!(Some(false), u8);
        dbg_bits!(Some(true), u8);

        println!("Option&lt;Option&lt;bool&gt;&gt;:");
        dbg_bits!(Some(Some(false)), u8);
        dbg_bits!(Some(Some(true)), u8);
        dbg_bits!(Some(None::&lt;bool&gt;), u8);
        dbg_bits!(None::&lt;Option&lt;bool&gt;&gt;, u8);

        println!("Option&lt;&amp;i32&gt;:");
        dbg_bits!(None::&lt;&amp;i32&gt;, usize);
        dbg_bits!(Some(&amp;0i32), usize);
    }
}</code></pre></pre>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-static"></div><h1 id="user-defined-types-static-static"><a class="header" href="#user-defined-types-static-static"><code>static</code></a></h1>
<p>Static variables will live during the whole execution of the program, and
therefore will not move:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static BANNER: &amp;str = "Welcome to RustOS 3.14";

fn main() {
    println!("{BANNER}");
}</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an
actual associated memory location. This is useful for unsafe and embedded code,
and the variable lives through the entirety of the program execution. When a
globally-scoped value does not have a reason to need object identity, <code>const</code> is
generally preferred.</p>
<details>
This slide should take about 5 minutes. 
<ul>
<li><code>static</code> is similar to mutable global variables in C++.</li>
<li><code>static</code> provides object identity: an address in memory and state as required
by types with interior mutability such as <code>Mutex&lt;T&gt;</code>.</li>
</ul>
<h1 id="user-defined-types-static-more-to-explore"><a class="header" href="#user-defined-types-static-more-to-explore">More to Explore</a></h1>
<p>Because <code>static</code> variables are accessible from any thread, they must be <code>Sync</code>.
Interior mutability is possible through a
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, atomic or
similar.</p>
<p>Thread-local data can be created with the macro <code>std::thread_local</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-const"></div><h1 id="user-defined-types-const-const"><a class="header" href="#user-defined-types-const-const"><code>const</code></a></h1>
<p>Constants are evaluated at compile time and their values are inlined wherever
they are used:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest("Hello");
    println!("digest: {digest:?}");
}</code></pre></pre>
<p>According to the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> these are inlined upon use.</p>
<p>Only functions marked <code>const</code> can be called at compile time to generate <code>const</code>
values. <code>const</code> functions can however be called at runtime.</p>
<details>
<ul>
<li>Mention that <code>const</code> behaves semantically similar to C++'s <code>constexpr</code></li>
<li>It isn't super common that one would need a runtime evaluated constant, but it
is helpful and safer than using a static.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-aliases"></div><h1 id="user-defined-types-aliases-type-aliases"><a class="header" href="#user-defined-types-aliases-type-aliases">Type Aliases</a></h1>
<p>A type alias creates a name for another type. The two types can be used
interchangeably.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum CarryableConcreteItem {
    Left,
    Right,
}

type Item = CarryableConcreteItem;

// Aliases are more useful with long, complex types:
use std::cell::RefCell;
use std::sync::{Arc, RwLock};
type PlayerInventory = RwLock&lt;Vec&lt;Arc&lt;RefCell&lt;Item&gt;&gt;&gt;&gt;;</code></pre></pre>
<details>
This slide should take about 2 minutes. 
<p>C programmers will recognize this as similar to a <code>typedef</code>.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-exercise"></div><h1 id="user-defined-types-exercise-exercise-elevator-events"><a class="header" href="#user-defined-types-exercise-exercise-elevator-events">Exercise: Elevator Events</a></h1>
<p>We will create a data structure to represent an event in an elevator control
system. It is up to you to define the types and functions to construct various
events. Use <code>#[derive(Debug)]</code> to allow the types to be formatted with <code>{:?}</code>.</p>
<p>This exercise only requires creating and populating data structures so that
<code>main</code> runs without errors. The next part of the course will cover getting data
out of these structures.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    // TODO: add required variants
}

/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}

/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -&gt; Event {
    todo!()
}

/// The car doors have opened.
fn car_door_opened() -&gt; Event {
    todo!()
}

/// The car doors have closed.
fn car_door_closed() -&gt; Event {
    todo!()
}

/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -&gt; Event {
    todo!()
}

/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -&gt; Event {
    todo!()
}

fn main() {
    println!(
        "A ground floor passenger has pressed the up button: {:?}",
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!("The car has arrived on the ground floor: {:?}", car_arrived(0));
    println!("The car door opened: {:?}", car_door_opened());
    println!(
        "A passenger has pressed the 3rd floor button: {:?}",
        car_floor_button_pressed(3)
    );
    println!("The car door closed: {:?}", car_door_closed());
    println!("The car has arrived on the 3rd floor: {:?}", car_arrived(3));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="user-defined-types-solution"></div><h1 id="user-defined-types-solution-solution"><a class="header" href="#user-defined-types-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    /// A button was pressed.
    ButtonPressed(Button),

    /// The car has arrived at the given floor.
    CarArrived(Floor),

    /// The car's doors have opened.
    CarDoorOpened,

    /// The car's doors have closed.
    CarDoorClosed,
}

/// A floor is represented as an integer.
type Floor = i32;

/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}

/// A user-accessible button.
#[derive(Debug)]
enum Button {
    /// A button in the elevator lobby on the given floor.
    LobbyCall(Direction, Floor),

    /// A floor button within the car.
    CarFloor(Floor),
}

/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -&gt; Event {
    Event::CarArrived(floor)
}

/// The car doors have opened.
fn car_door_opened() -&gt; Event {
    Event::CarDoorOpened
}

/// The car doors have closed.
fn car_door_closed() -&gt; Event {
    Event::CarDoorClosed
}

/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -&gt; Event {
    Event::ButtonPressed(Button::LobbyCall(dir, floor))
}

/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -&gt; Event {
    Event::ButtonPressed(Button::CarFloor(floor))
}

fn main() {
    println!(
        "A ground floor passenger has pressed the up button: {:?}",
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!("The car has arrived on the ground floor: {:?}", car_arrived(0));
    println!("The car door opened: {:?}", car_door_opened());
    println!(
        "A passenger has pressed the 3rd floor button: {:?}",
        car_floor_button_pressed(3)
    );
    println!("The car door closed: {:?}", car_door_closed());
    println!("The car has arrived on the 3rd floor: {:?}", car_arrived(3));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-2"></div><h1 id="welcome-day-2-welcome-to-day-2"><a class="header" href="#welcome-day-2-welcome-to-day-2">Welcome to Day 2</a></h1>
<p>Now that we have seen a fair amount of Rust, today will focus on Rust's type
system:</p>
<ul>
<li>Pattern matching: extracting data from structures.</li>
<li>Methods: associating functions with types.</li>
<li>Traits: behaviors shared by multiple types.</li>
<li>Generics: parameterizing types on other types.</li>
<li>Standard library types and traits: a tour of Rust's rich standard library.</li>
</ul>
<h2 id="welcome-day-2-schedule"><a class="header" href="#welcome-day-2-schedule">Schedule</a></h2>
<p>Including 10 minute breaks, this session should take about 2 hours and 10 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>3 minutes</td></tr>
<tr><td>Pattern Matching</td><td>1 hour</td></tr>
<tr><td>Methods and Traits</td><td>50 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching"></div><h1 id="pattern-matching-pattern-matching"><a class="header" href="#pattern-matching-pattern-matching">Pattern Matching</a></h1>
<p>This segment should take about 1 hour. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Matching Values</td><td>10 minutes</td></tr>
<tr><td>Destructuring Structs</td><td>4 minutes</td></tr>
<tr><td>Destructuring Enums</td><td>4 minutes</td></tr>
<tr><td>Let Control Flow</td><td>10 minutes</td></tr>
<tr><td>Exercise: Expression Evaluation</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching-match"></div><h1 id="pattern-matching-match-matching-values"><a class="header" href="#pattern-matching-match-matching-values">Matching Values</a></h1>
<p>The <code>match</code> keyword lets you match a value against one or more <em>patterns</em>. The
comparisons are done from top to bottom and the first match wins.</p>
<p>The patterns can be simple values, similarly to <code>switch</code> in C and C++:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let input = 'x';
    match input {
        'q'                       =&gt; println!("Quitting"),
        'a' | 's' | 'w' | 'd'     =&gt; println!("Moving around"),
        '0'..='9'                 =&gt; println!("Number input"),
        key if key.is_lowercase() =&gt; println!("Lowercase: {key}"),
        _                         =&gt; println!("Something else"),
    }
}</code></pre></pre>
<p>The <code>_</code> pattern is a wildcard pattern which matches any value. The expressions
<em>must</em> be exhaustive, meaning that it covers every possibility, so <code>_</code> is often
used as the final catch-all case.</p>
<p>Match can be used as an expression. Just like <code>if</code>, each match arm must have the
same type. The type is the last expression of the block, if any. In the example
above, the type is <code>()</code>.</p>
<p>A variable in the pattern (<code>key</code> in this example) will create a binding that can
be used within the match arm.</p>
<p>A match guard causes the arm to match only if the condition is true.</p>
<details>
This slide should take about 10 minutes. 
<p>Key Points:</p>
<ul>
<li>
<p>You might point out how some specific characters are being used when in a
pattern</p>
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li><code>_</code> is a wild card</li>
</ul>
</li>
<li>
<p>Match guards as a separate syntax feature are important and necessary when we
wish to concisely express more complex ideas than patterns alone would allow.</p>
</li>
<li>
<p>They are not the same as separate <code>if</code> expression inside of the match arm. An
<code>if</code> expression inside of the branch block (after <code>=&gt;</code>) happens after the
match arm is selected. Failing the <code>if</code> condition inside of that block won't
result in other arms of the original <code>match</code> expression being considered.</p>
</li>
<li>
<p>The condition defined in the guard applies to every expression in a pattern
with an <code>|</code>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching-destructuring-structs"></div><h1 id="pattern-matching-destructuring-structs-structs"><a class="header" href="#pattern-matching-destructuring-structs-structs">Structs</a></h1>
<p>Like tuples, Struct can also be destructured by matching:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!("x.0 = 1, b = {b}, y = {y}"),
        Foo { y: 2, x: i }   =&gt; println!("y = 2, x = {i:?}"),
        Foo { y, .. }        =&gt; println!("y = {y}, other fields were ignored"),
    }
}</code></pre></pre>
<details>
This slide should take about 4 minutes. 
<ul>
<li>Change the literal values in <code>foo</code> to match with the other patterns.</li>
<li>Add a new field to <code>Foo</code> and make changes to the pattern as needed.</li>
<li>The distinction between a capture and a constant expression can be hard to
spot. Try changing the <code>2</code> in the second arm to a variable, and see that it
subtly doesn't work. Change it to a <code>const</code> and see it working again.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching-destructuring-enums"></div><h1 id="pattern-matching-destructuring-enums-enums"><a class="header" href="#pattern-matching-destructuring-enums-enums">Enums</a></h1>
<p>Like tuples, enums can also be destructured by matching:</p>
<p>Patterns can also be used to bind variables to parts of your values. This is how
you inspect the structure of your types. Let us start with a simple <code>enum</code> type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!("cannot divide {n} into two equal parts"))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!("{n} divided in two is {half}"),
        Result::Err(msg) =&gt; println!("sorry, an error happened: {msg}"),
    }
}</code></pre></pre>
<p>Here we have used the arms to <em>destructure</em> the <code>Result</code> value. In the first
arm, <code>half</code> is bound to the value inside the <code>Ok</code> variant. In the second arm,
<code>msg</code> is bound to the error message.</p>
<details>
This slide should take about 4 minutes. 
<ul>
<li>The <code>if</code>/<code>else</code> expression is returning an enum that is later unpacked with a
<code>match</code>.</li>
<li>You can try adding a third variant to the enum definition and displaying the
errors when running the code. Point out the places where your code is now
inexhaustive and how the compiler tries to give you hints.</li>
<li>The values in the enum variants can only be accessed after being pattern
matched.</li>
<li>Demonstrate what happens when the search is inexhaustive. Note the advantage
the Rust compiler provides by confirming when all cases are handled.</li>
<li>Save the result of <code>divide_in_two</code> in the <code>result</code> variable and <code>match</code> it in
a loop. That won't compile because <code>msg</code> is consumed when matched. To fix it,
match <code>&amp;result</code> instead of <code>result</code>. That will make <code>msg</code> a reference so it
won't be consumed. This
<a href="https://rust-lang.github.io/rfcs/2005-match-ergonomics.html">"match ergonomics"</a>
appeared in Rust 2018. If you want to support older Rust, replace <code>msg</code> with
<code>ref msg</code> in the pattern.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching-let-control-flow"></div><h1 id="pattern-matching-let-control-flow-let-control-flow"><a class="header" href="#pattern-matching-let-control-flow-let-control-flow">Let Control Flow</a></h1>
<p>Rust has a few control flow constructs which differ from other languages. They
are used for pattern matching:</p>
<ul>
<li><code>if let</code> expressions</li>
<li><code>let else</code> expressions</li>
<li><code>while let</code> expressions</li>
</ul>
<h1 id="pattern-matching-let-control-flow-if-let-expressions"><a class="header" href="#pattern-matching-let-control-flow-if-let-expressions"><code>if let</code> expressions</a></h1>
<p>The
<a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code> expression</a>
lets you execute different code depending on whether a value matches a pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::time::Duration;

fn sleep_for(secs: f32) {
    if let Ok(dur) = Duration::try_from_secs_f32(secs) {
        std::thread::sleep(dur);
        println!("slept for {:?}", dur);
    }
}

fn main() {
    sleep_for(-10.0);
    sleep_for(0.8);
}</code></pre></pre>
<h1 id="pattern-matching-let-control-flow-let-else-expressions"><a class="header" href="#pattern-matching-let-control-flow-let-else-expressions"><code>let else</code> expressions</a></h1>
<p>For the common case of matching a pattern and returning from the function, use
<a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let else</code></a>.
The "else" case must diverge (<code>return</code>, <code>break</code>, or panic - anything but falling
off the end of the block).</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn hex_or_die_trying(maybe_string: Option&lt;String&gt;) -&gt; Result&lt;u32, String&gt; {
    if let Some(s) = maybe_string {
        if let Some(first_byte_char) = s.chars().next() {
            if let Some(digit) = first_byte_char.to_digit(16) {
                Ok(digit)
            } else {
                return Err(String::from("not a hex digit"));
            }
        } else {
            return Err(String::from("got empty string"));
        }
    } else {
        return Err(String::from("got None"));
    }
}

fn main() {
    println!("result: {:?}", hex_or_die_trying(Some(String::from("foo"))));
}</code></pre></pre>
<p>Like with <code>if let</code>, there is a
<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>
variant which repeatedly tests a value against a pattern:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut name = String::from("Comprehensive Rust ü¶Ä");
    while let Some(c) = name.pop() {
        println!("character: {c}");
    }
    // (There are more efficient ways to reverse a string!)
}</code></pre></pre>
<p>Here
<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.pop"><code>String::pop</code></a>
returns <code>Some(c)</code> until the string is empty, after which it will return <code>None</code>.
The <code>while let</code> lets us keep iterating through all items.</p>
<details>
This slide should take about 10 minutes. 
<h2 id="pattern-matching-let-control-flow-if-let"><a class="header" href="#pattern-matching-let-control-flow-if-let">if-let</a></h2>
<ul>
<li>Unlike <code>match</code>, <code>if let</code> does not have to cover all branches. This can make it
more concise than <code>match</code>.</li>
<li>A common usage is handling <code>Some</code> values when working with <code>Option</code>.</li>
<li>Unlike <code>match</code>, <code>if let</code> does not support guard clauses for pattern matching.</li>
</ul>
<h2 id="pattern-matching-let-control-flow-let-else"><a class="header" href="#pattern-matching-let-control-flow-let-else">let-else</a></h2>
<p><code>if-let</code>s can pile up, as shown. The <code>let-else</code> construct supports flattening
this nested code. Rewrite the awkward version for students, so they can see the
transformation.</p>
<p>The rewritten version is:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hex_or_die_trying(maybe_string: Option&lt;String&gt;) -&gt; Result&lt;u32, String&gt; {
    let Some(s) = maybe_string else {
        return Err(String::from("got None"));
    };

    let Some(first_byte_char) = s.chars().next() else {
        return Err(String::from("got empty string"));
    };

    let Some(digit) = first_byte_char.to_digit(16) else {
        return Err(String::from("not a hex digit"));
    };

    return Ok(digit);
}
<span class="boring">}</span></code></pre></pre>
<h1 id="pattern-matching-let-control-flow-while-let"><a class="header" href="#pattern-matching-let-control-flow-while-let">while-let</a></h1>
<ul>
<li>Point out that the <code>while let</code> loop will keep going as long as the value
matches the pattern.</li>
<li>You could rewrite the <code>while let</code> loop as an infinite loop with an if
statement that breaks when there is no value to unwrap for <code>name.pop()</code>. The
<code>while let</code> provides syntactic sugar for the above scenario.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching-exercise"></div><h1 id="pattern-matching-exercise-exercise-expression-evaluation"><a class="header" href="#pattern-matching-exercise-exercise-expression-evaluation">Exercise: Expression Evaluation</a></h1>
<p>Let's write a simple recursive evaluator for arithmetic expressions.</p>
<p>The <code>Box</code> type here is a smart pointer, and will be covered in detail later in
the course. An expression can be "boxed" with <code>Box::new</code> as seen in the tests.
To evaluate a boxed expression, use the deref operator (<code>*</code>) to "unbox" it:
<code>eval(*boxed_expr)</code>.</p>
<p>Some expressions cannot be evaluated and will return an error. The standard
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;Value, String&gt;</code></a>
type is an enum that represents either a successful value (<code>Ok(Value)</code>) or an
error (<code>Err(String)</code>). We will cover this type in detail later.</p>
<p>Copy and paste the code into the Rust playground, and begin implementing <code>eval</code>.
The final product should pass the tests. It may be helpful to use <code>todo!()</code> and
get the tests to pass one-by-one. You can also skip a test temporarily with
<code>#[ignore]</code>:</p>
<pre><code class="language-none">#[test]
#[ignore]
fn test_value() { .. }
</code></pre>
<p>If you finish early, try writing a test that results in division by zero or
integer overflow. How could you handle this with <code>Result</code> instead of a panic?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; Result&lt;i64, String&gt; {
    todo!()
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from("division by zero"))
    );
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="pattern-matching-solution"></div><h1 id="pattern-matching-solution-solution"><a class="header" href="#pattern-matching-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; Result&lt;i64, String&gt; {
    match e {
        Expression::Op { op, left, right } =&gt; {
            let left = match eval(*left) {
                Ok(v) =&gt; v,
                e @ Err(_) =&gt; return e,
            };
            let right = match eval(*right) {
                Ok(v) =&gt; v,
                e @ Err(_) =&gt; return e,
            };
            Ok(match op {
                Operation::Add =&gt; left + right,
                Operation::Sub =&gt; left - right,
                Operation::Mul =&gt; left * right,
                Operation::Div =&gt; {
                    if right == 0 {
                        return Err(String::from("division by zero"));
                    } else {
                        left / right
                    }
                }
            })
        }
        Expression::Value(v) =&gt; Ok(v),
    }
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from("division by zero"))
    );
}

fn main() {
    let expr = Expression::Op {
        op: Operation::Sub,
        left: Box::new(Expression::Value(20)),
        right: Box::new(Expression::Value(10)),
    };
    println!("expr: {:?}", expr);
    println!("result: {:?}", eval(expr));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits"></div><h1 id="methods-and-traits-methods-and-traits"><a class="header" href="#methods-and-traits-methods-and-traits">Methods and Traits</a></h1>
<p>This segment should take about 50 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Methods</td><td>10 minutes</td></tr>
<tr><td>Traits</td><td>15 minutes</td></tr>
<tr><td>Deriving</td><td>3 minutes</td></tr>
<tr><td>Exercise: Generic Logger</td><td>20 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-methods"></div><h1 id="methods-and-traits-methods-methods"><a class="header" href="#methods-and-traits-methods-methods">Methods</a></h1>
<p>Rust allows you to associate functions with your new types. You do this with an
<code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    // No receiver, a static method
    fn new(name: &amp;str) -&gt; Self {
        Self { name: String::from(name), laps: Vec::new() }
    }

    // Exclusive borrowed read-write access to self
    fn add_lap(&amp;mut self, lap: i32) {
        self.laps.push(lap);
    }

    // Shared and read-only borrowed access to self
    fn print_laps(&amp;self) {
        println!("Recorded {} laps for {}:", self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!("Lap {idx}: {lap} sec");
        }
    }

    // Exclusive ownership of self
    fn finish(self) {
        let total: i32 = self.laps.iter().sum();
        println!("Race {} is finished, total lap time: {}", self.name, total);
    }
}

fn main() {
    let mut race = Race::new("Monaco Grand Prix");
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}</code></pre></pre>
<p>The <code>self</code> arguments specify the "receiver" - the object the method acts on.
There are several common receivers for a method:</p>
<ul>
<li><code>&amp;self</code>: borrows the object from the caller using a shared and immutable
reference. The object can be used again afterwards.</li>
<li><code>&amp;mut self</code>: borrows the object from the caller using a unique and mutable
reference. The object can be used again afterwards.</li>
<li><code>self</code>: takes ownership of the object and moves it away from the caller. The
method becomes the owner of the object. The object will be dropped
(deallocated) when the method returns, unless its ownership is explicitly
transmitted. Complete ownership does not automatically mean mutability.</li>
<li><code>mut self</code>: same as above, but the method can mutate the object.</li>
<li>No receiver: this becomes a static method on the struct. Typically used to
create constructors which are called <code>new</code> by convention.</li>
</ul>
<details>
This slide should take about 8 minutes. 
<p>Key Points:</p>
<ul>
<li>It can be helpful to introduce methods by comparing them to functions.
<ul>
<li>Methods are called on an instance of a type (such as a struct or enum), the
first parameter represents the instance as <code>self</code>.</li>
<li>Developers may choose to use methods to take advantage of method receiver
syntax and to help keep them more organized. By using methods we can keep
all the implementation code in one predictable place.</li>
</ul>
</li>
<li>Point out the use of the keyword <code>self</code>, a method receiver.
<ul>
<li>Show that it is an abbreviated term for <code>self: Self</code> and perhaps show how
the struct name could also be used.</li>
<li>Explain that <code>Self</code> is a type alias for the type the <code>impl</code> block is in and
can be used elsewhere in the block.</li>
<li>Note how <code>self</code> is used like other structs and dot notation can be used to
refer to individual fields.</li>
<li>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code>
by trying to run <code>finish</code> twice.</li>
<li>Beyond variants on <code>self</code>, there are also
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a>
allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</li>
</ul>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-traits"></div><h1 id="methods-and-traits-traits-traits"><a class="header" href="#methods-and-traits-traits-traits">Traits</a></h1>
<p>Rust lets you abstract over types with traits. They're similar to interfaces:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pet {
    /// Return a sentence from this pet.
    fn talk(&amp;self) -&gt; String;

    /// Print a string to the terminal greeting this pet.
    fn greet(&amp;self);
}</code></pre></pre>
<details>
This slide and its sub-slides should take about 15 minutes. 
<ul>
<li>
<p>A trait defines a number of methods that types must have in order to implement
the trait.</p>
</li>
<li>
<p>In the "Generics" segment, next, we will see how to build functionality that
is generic over all types implementing a trait.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-traits-implementing"></div><h1 id="methods-and-traits-traits-implementing-implementing-traits"><a class="header" href="#methods-and-traits-traits-implementing-implementing-traits">Implementing Traits</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pet {
    fn talk(&amp;self) -&gt; String;

    fn greet(&amp;self) {
        println!("Oh you're a cutie! What's your name? {}", self.talk());
    }
}

struct Dog {
    name: String,
    age: i8,
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!("Woof, my name is {}!", self.name)
    }
}

fn main() {
    let fido = Dog { name: String::from("Fido"), age: 5 };
    fido.greet();
}</code></pre></pre>
<details>
<ul>
<li>
<p>To implement <code>Trait</code> for <code>Type</code>, you use an <code>impl Trait for Type { .. }</code>
block.</p>
</li>
<li>
<p>Unlike Go interfaces, just having matching methods is not enough: a <code>Cat</code> type
with a <code>talk()</code> method would not automatically satisfy <code>Pet</code> unless it is in
an <code>impl Pet</code> block.</p>
</li>
<li>
<p>Traits may provide default implementations of some methods. Default
implementations can rely on all the methods of the trait. In this case,
<code>greet</code> is provided, and relies on <code>talk</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-traits-supertraits"></div><h1 id="methods-and-traits-traits-supertraits-supertraits"><a class="header" href="#methods-and-traits-traits-supertraits-supertraits">Supertraits</a></h1>
<p>A trait can require that types implementing it also implement other traits,
called <em>supertraits</em>. Here, any type implementing <code>Pet</code> must implement <code>Animal</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Animal {
    fn leg_count(&amp;self) -&gt; u32;
}

trait Pet: Animal {
    fn name(&amp;self) -&gt; String;
}

struct Dog(String);

impl Animal for Dog {
    fn leg_count(&amp;self) -&gt; u32 {
        4
    }
}

impl Pet for Dog {
    fn name(&amp;self) -&gt; String {
        self.0.clone()
    }
}

fn main() {
    let puppy = Dog(String::from("Rex"));
    println!("{} has {} legs", puppy.name(), puppy.leg_count());
}</code></pre></pre>
<details>
<p>This is sometimes called "trait inheritance" but students should not expect this
to behave like OO inheritance. It just specifies an additional requirement on
implementations of a trait.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-traits-associated-types"></div><h1 id="methods-and-traits-traits-associated-types-associated-types"><a class="header" href="#methods-and-traits-traits-associated-types-associated-types">Associated Types</a></h1>
<p>Associated types are placeholder types which are supplied by the trait
implementation.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Meters(i32);
#[derive(Debug)]
struct MetersSquared(i32);

trait Multiply {
    type Output;
    fn multiply(&amp;self, other: &amp;Self) -&gt; Self::Output;
}

impl Multiply for Meters {
    type Output = MetersSquared;
    fn multiply(&amp;self, other: &amp;Self) -&gt; Self::Output {
        MetersSquared(self.0 * other.0)
    }
}

fn main() {
    println!("{:?}", Meters(10).multiply(&amp;Meters(20)));
}</code></pre></pre>
<details>
<ul>
<li>
<p>Associated types are sometimes also called "output types". The key observation
is that the implementer, not the caller, chooses this type.</p>
</li>
<li>
<p>Many standard library traits have associated types, including arithmetic
operators and <code>Iterator</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-deriving"></div><h1 id="methods-and-traits-deriving-deriving"><a class="header" href="#methods-and-traits-deriving-deriving">Deriving</a></h1>
<p>Supported traits can be automatically implemented for your custom types, as
follows:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Clone, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default(); // Default trait adds `default` constructor.
    let mut p2 = p1.clone(); // Clone trait adds `clone` method.
    p2.name = String::from("EldurScrollz");
    // Debug trait adds support for printing with `{:?}`.
    println!("{:?} vs. {:?}", p1, p2);
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<p>Derivation is implemented with macros, and many crates provide useful derive
macros to add useful functionality. For example, <code>serde</code> can derive
serialization support for a struct using <code>#[derive(Serialize)]</code>.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-exercise"></div><h1 id="methods-and-traits-exercise-exercise-logger-trait"><a class="header" href="#methods-and-traits-exercise-exercise-logger-trait">Exercise: Logger Trait</a></h1>
<p>Let's design a simple logging utility, using a trait <code>Logger</code> with a <code>log</code>
method. Code which might log its progress can then take an <code>&amp;impl Logger</code>. In
testing, this might put messages in the test logfile, while in a production
build it would send messages to a log server.</p>
<p>However, the <code>StderrLogger</code> given below logs all messages, regardless of
verbosity. Your task is to write a <code>VerbosityFilter</code> type that will ignore
messages above a maximum verbosity.</p>
<p>This is a common pattern: a struct wrapping a trait implementation and
implementing that same trait, adding behavior in the process. What other kinds
of wrappers might be useful in a logging utility?</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::fmt::Display;

pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: impl Display);
}

struct StderrLogger;

impl Logger for StderrLogger {
    fn log(&amp;self, verbosity: u8, message: impl Display) {
        eprintln!("verbosity={verbosity}: {message}");
    }
}

fn do_things(logger: &amp;impl Logger) {
    logger.log(5, "FYI");
    logger.log(2, "Uhoh");
}

// TODO: Define and implement `VerbosityFilter`.

fn main() {
    let l = VerbosityFilter { max_verbosity: 3, inner: StderrLogger };
    do_things(&amp;l);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="methods-and-traits-solution"></div><h1 id="methods-and-traits-solution-solution"><a class="header" href="#methods-and-traits-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: impl Display);
}

struct StderrLogger;

impl Logger for StderrLogger {
    fn log(&amp;self, verbosity: u8, message: impl Display) {
        eprintln!("verbosity={verbosity}: {message}");
    }
}

fn do_things(logger: &amp;impl Logger) {
    logger.log(5, "FYI");
    logger.log(2, "Uhoh");
}

/// Only log messages up to the given verbosity level.
struct VerbosityFilter {
    max_verbosity: u8,
    inner: StderrLogger,
}

impl Logger for VerbosityFilter {
    fn log(&amp;self, verbosity: u8, message: impl Display) {
        if verbosity &lt;= self.max_verbosity {
            self.inner.log(verbosity, message);
        }
    }
}

fn main() {
    let l = VerbosityFilter { max_verbosity: 3, inner: StderrLogger };
    do_things(&amp;l);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-2-afternoon"></div><h1 id="welcome-day-2-afternoon-welcome-back"><a class="header" href="#welcome-day-2-afternoon-welcome-back">Welcome Back</a></h1>
<p>Including 10 minute breaks, this session should take about 3 hours and 15 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Generics</td><td>45 minutes</td></tr>
<tr><td>Standard Library Types</td><td>1 hour</td></tr>
<tr><td>Standard Library Traits</td><td>1 hour and 10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="generics"></div><h1 id="generics-generics"><a class="header" href="#generics-generics">Generics</a></h1>
<p>This segment should take about 45 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Generic Functions</td><td>5 minutes</td></tr>
<tr><td>Generic Data Types</td><td>10 minutes</td></tr>
<tr><td>Trait Bounds</td><td>10 minutes</td></tr>
<tr><td>impl Trait</td><td>5 minutes</td></tr>
<tr><td>dyn Trait</td><td>5 minutes</td></tr>
<tr><td>Exercise: Generic min</td><td>10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="generics-generic-functions"></div><h1 id="generics-generic-functions-generic-functions"><a class="header" href="#generics-generic-functions-generic-functions">Generic Functions</a></h1>
<p>Rust supports generics, which lets you abstract algorithms or data structures
(such as sorting or a binary tree) over the types used or stored.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Pick `even` or `odd` depending on the value of `n`.
fn pick&lt;T&gt;(n: i32, even: T, odd: T) -&gt; T {
    if n % 2 == 0 {
        even
    } else {
        odd
    }
}

fn main() {
    println!("picked a number: {:?}", pick(97, 222, 333));
    println!("picked a tuple: {:?}", pick(28, ("dog", 1), ("cat", 2)));
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Rust infers a type for T based on the types of the arguments and return value.</p>
</li>
<li>
<p>This is similar to C++ templates, but Rust partially compiles the generic
function immediately, so that function must be valid for all types matching
the constraints. For example, try modifying <code>pick</code> to return <code>even + odd</code> if
<code>n == 0</code>. Even if only the <code>pick</code> instantiation with integers is used, Rust
still considers it invalid. C++ would let you do this.</p>
</li>
<li>
<p>Generic code is turned into non-generic code based on the call sites. This is
a zero-cost abstraction: you get exactly the same result as if you had
hand-coded the data structures without the abstraction.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="generics-generic-data"></div><h1 id="generics-generic-data-generic-data-types"><a class="header" href="#generics-generic-data-generic-data-types">Generic Data Types</a></h1>
<p>You can use generics to abstract over the concrete field type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn coords(&amp;self) -&gt; (&amp;T, &amp;T) {
        (&amp;self.x, &amp;self.y)
    }

    fn set_x(&amp;mut self, x: T) {
        self.x = x;
    }
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!("{integer:?} and {float:?}");
    println!("coords: {:?}", integer.coords());
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li>
<p><em>Q:</em> Why <code>T</code> is specified twice in <code>impl&lt;T&gt; Point&lt;T&gt; {}</code>? Isn't that
redundant?</p>
<ul>
<li>This is because it is a generic implementation section for generic type.
They are independently generic.</li>
<li>It means these methods are defined for any <code>T</code>.</li>
<li>It is possible to write <code>impl Point&lt;u32&gt; { .. }</code>.
<ul>
<li><code>Point</code> is still generic and you can use <code>Point&lt;f64&gt;</code>, but methods in this
block will only be available for <code>Point&lt;u32&gt;</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Try declaring a new variable <code>let p = Point { x: 5, y: 10.0 };</code>. Update the
code to allow points that have elements of different types, by using two type
variables, e.g., <code>T</code> and <code>U</code>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="generics-generic-traits"></div><h1 id="generics-generic-traits-generic-traits"><a class="header" href="#generics-generic-traits-generic-traits">Generic Traits</a></h1>
<p>Traits can also be generic, just like types and functions. A trait's parameters
get concrete types when it is used.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Foo(String);

impl From&lt;u32&gt; for Foo {
    fn from(from: u32) -&gt; Foo {
        Foo(format!("Converted from integer: {from}"))
    }
}

impl From&lt;bool&gt; for Foo {
    fn from(from: bool) -&gt; Foo {
        Foo(format!("Converted from bool: {from}"))
    }
}

fn main() {
    let from_int = Foo::from(123);
    let from_bool = Foo::from(true);
    println!("{from_int:?}, {from_bool:?}");
}</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>From</code> trait will be covered later in the course, but its
<a href="https://doc.rust-lang.org/std/convert/trait.From.html">definition in the <code>std</code> docs</a>
is simple.</p>
</li>
<li>
<p>Implementations of the trait do not need to cover all possible type
parameters. Here, <code>Foo::from("hello")</code> would not compile because there is no
<code>From&lt;&amp;str&gt;</code> implementation for <code>Foo</code>.</p>
</li>
<li>
<p>Generic traits take types as "input", while associated types are a kind of
"output" type. A trait can have multiple implementations for different input
types.</p>
</li>
<li>
<p>In fact, Rust requires that at most one implementation of a trait match for
any type T. Unlike some other languages, Rust has no heuristic for choosing
the "most specific" match. There is work on adding this support, called
<a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialization</a>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="generics-trait-bounds"></div><h1 id="generics-trait-bounds-trait-bounds"><a class="header" href="#generics-trait-bounds-trait-bounds">Trait Bounds</a></h1>
<p>When working with generics, you often want to require the types to implement
some trait, so that you can call this trait's methods.</p>
<p>You can do this with <code>T: Trait</code> or <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// struct NotClonable;

fn main() {
    let foo = String::from("foo");
    let pair = duplicate(foo);
    println!("{pair:?}");
}</code></pre></pre>
<details>
This slide should take about 8 minutes. 
<ul>
<li>
<p>Try making a <code>NonClonable</code> and passing it to <code>duplicate</code>.</p>
</li>
<li>
<p>When multiple traits are necessary, use <code>+</code> to join them.</p>
</li>
<li>
<p>Show a <code>where</code> clause, students will encounter it when reading code.</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}</code></pre>
<ul>
<li>It declutters the function signature if you have many parameters.</li>
<li>It has additional features making it more powerful.
<ul>
<li>If someone asks, the extra feature is that the type on the left of ":" can
be arbitrary, like <code>Option&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Note that Rust does not (yet) support specialization. For example, given the
original <code>duplicate</code>, it is invalid to add a specialized <code>duplicate(a: u32)</code>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="generics-impl-trait"></div><h1 id="generics-impl-trait-impl-trait"><a class="header" href="#generics-impl-trait-impl-trait"><code>impl Trait</code></a></h1>
<p>Similar to trait bounds, an <code>impl Trait</code> syntax can be used in function
arguments and return values:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Syntactic sugar for:
//   fn add_42_millions&lt;T: Into&lt;i32&gt;&gt;(x: T) -&gt; i32 {
fn add_42_millions(x: impl Into&lt;i32&gt;) -&gt; i32 {
    x.into() + 42_000_000
}

fn pair_of(x: u32) -&gt; impl std::fmt::Debug {
    (x + 1, x - 1)
}

fn main() {
    let many = add_42_millions(42_i8);
    println!("{many}");
    let many_more = add_42_millions(10_000_000);
    println!("{many_more}");
    let debuggable = pair_of(27);
    println!("debuggable: {debuggable:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p><code>impl Trait</code> allows you to work with types which you cannot name. The meaning of
<code>impl Trait</code> is a bit different in the different positions.</p>
<ul>
<li>
<p>For a parameter, <code>impl Trait</code> is like an anonymous generic parameter with a
trait bound.</p>
</li>
<li>
<p>For a return type, it means that the return type is some concrete type that
implements the trait, without naming the type. This can be useful when you
don't want to expose the concrete type in a public API.</p>
<p>Inference is hard in return position. A function returning <code>impl Foo</code> picks
the concrete type it returns, without writing it out in the source. A function
returning a generic type like <code>collect&lt;B&gt;() -&gt; B</code> can return any type
satisfying <code>B</code>, and the caller may need to choose one, such as with
<code>let x: Vec&lt;_&gt; = foo.collect()</code> or with the turbofish,
<code>foo.collect::&lt;Vec&lt;_&gt;&gt;()</code>.</p>
</li>
</ul>
<p>What is the type of <code>debuggable</code>? Try <code>let debuggable: () = ..</code> to see what the
error message shows.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="generics-dyn-trait"></div><h1 id="generics-dyn-trait-dyn-trait"><a class="header" href="#generics-dyn-trait-dyn-trait"><code>dyn Trait</code></a></h1>
<p>In addition to using traits for static dispatch via generics, Rust also supports
using them for type-erased, dynamic dispatch via trait objects:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!("Woof, my name is {}!", self.name)
    }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String {
        String::from("Miau!")
    }
}

// Uses generics and static dispatch.
fn generic(pet: &amp;impl Pet) {
    println!("Hello, who are you? {}", pet.talk());
}

// Uses type-erasure and dynamic dispatch.
fn dynamic(pet: &amp;dyn Pet) {
    println!("Hello, who are you? {}", pet.talk());
}

fn main() {
    let cat = Cat { lives: 9 };
    let dog = Dog { name: String::from("Fido"), age: 5 };

    generic(&amp;cat);
    generic(&amp;dog);

    dynamic(&amp;cat);
    dynamic(&amp;dog);
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Generics, including <code>impl Trait</code>, use monomorphization to create a specialized
instance of the function for each different type that the generic is
instantiated with. This means that calling a trait method from within a
generic function still uses static dispatch, as the compiler has full type
information and can resolve which type's trait implementation to use.</p>
</li>
<li>
<p>When using <code>dyn Trait</code>, it instead uses dynamic dispatch through a
<a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> (vtable). This means that there's a single
version of <code>fn dynamic</code> that is used regardless of what type of <code>Pet</code> is
passed in.</p>
</li>
<li>
<p>When using <code>dyn Trait</code>, the trait object needs to be behind some kind of
indirection. In this case it's a reference, though smart pointer types like
<code>Box</code> can also be used (this will be demonstrated on day 3).</p>
</li>
<li>
<p>At runtime, a <code>&amp;dyn Pet</code> is represented as a "fat pointer", i.e. a pair of two
pointers: One pointer points to the concrete object that implements <code>Pet</code>, and
the other points to the vtable for the trait implementation for that type.
When calling the <code>talk</code> method on <code>&amp;dyn Pet</code> the compiler looks up the
function pointer for <code>talk</code> in the vtable and then invokes the function,
passing the pointer to the <code>Dog</code> or <code>Cat</code> into that function. The compiler
doesn't need to know the concrete type of the <code>Pet</code> in order to do this.</p>
</li>
<li>
<p>A <code>dyn Trait</code> is considered to be "type-erased", because we no longer have
compile-time knowledge of what the concrete type is.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="generics-exercise"></div><h1 id="generics-exercise-exercise-generic-min"><a class="header" href="#generics-exercise-exercise-generic-min">Exercise: Generic <code>min</code></a></h1>
<p>In this short exercise, you will implement a generic <code>min</code> function that
determines the minimum of two values, using the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a> trait.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::cmp::Ordering;

// TODO: implement the `min` function used in `main`.

fn main() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);

    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');

    assert_eq!(min("hello", "goodbye"), "goodbye");
    assert_eq!(min("bat", "armadillo"), "armadillo");
}</code></pre></pre>
<details>
This slide and its sub-slides should take about 10 minutes. 
<ul>
<li>Show students the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a> trait and <a href="https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html"><code>Ordering</code></a> enum.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="generics-solution"></div><h1 id="generics-solution-solution"><a class="header" href="#generics-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::cmp::Ordering;

fn min&lt;T: Ord&gt;(l: T, r: T) -&gt; T {
    match l.cmp(&amp;r) {
        Ordering::Less | Ordering::Equal =&gt; l,
        Ordering::Greater =&gt; r,
    }
}

fn main() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);

    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');

    assert_eq!(min("hello", "goodbye"), "goodbye");
    assert_eq!(min("bat", "armadillo"), "armadillo");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="std-types"></div><h1 id="std-types-standard-library-types"><a class="header" href="#std-types-standard-library-types">Standard Library Types</a></h1>
<p>This segment should take about 1 hour. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Standard Library</td><td>3 minutes</td></tr>
<tr><td>Documentation</td><td>5 minutes</td></tr>
<tr><td>Option</td><td>10 minutes</td></tr>
<tr><td>Result</td><td>5 minutes</td></tr>
<tr><td>String</td><td>5 minutes</td></tr>
<tr><td>Vec</td><td>5 minutes</td></tr>
<tr><td>HashMap</td><td>5 minutes</td></tr>
<tr><td>Exercise: Counter</td><td>20 minutes</td></tr>
</tbody></table>
</div><details>
<p>For each of the slides in this section, spend some time reviewing the
documentation pages, highlighting some of the more common methods.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="std-types-std"></div><h1 id="std-types-std-standard-library"><a class="header" href="#std-types-std-standard-library">Standard Library</a></h1>
<p>Rust comes with a standard library which helps establish a set of common types
used by Rust libraries and programs. This way, two libraries can work together
smoothly because they both use the same <code>String</code> type.</p>
<p>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code>
and <code>std</code>.</p>
<ul>
<li><code>core</code> includes the most basic types and functions that don't depend on
<code>libc</code>, allocator or even the presence of an operating system.</li>
<li><code>alloc</code> includes types which require a global heap allocator, such as <code>Vec</code>,
<code>Box</code> and <code>Arc</code>.</li>
<li>Embedded Rust applications often only use <code>core</code>, and sometimes <code>alloc</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="std-types-docs"></div><h1 id="std-types-docs-documentation"><a class="header" href="#std-types-docs-documentation">Documentation</a></h1>
<p>Rust comes with extensive documentation. For example:</p>
<ul>
<li>All of the details about
<a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html">loops</a>.</li>
<li>Primitive types like
<a href="https://doc.rust-lang.org/stable/std/primitive.u8.html"><code>u8</code></a>.</li>
<li>Standard library types like
<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> or
<a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a>.</li>
</ul>
<p>In fact, you can document your own code:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;
    }
    lhs % rhs == 0
}</code></pre></pre>
<p>The contents are treated as Markdown. All published Rust library crates are
automatically documented at <a href="https://docs.rs"><code>docs.rs</code></a> using the
<a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> tool. It is
idiomatic to document all public items in an API using this pattern.</p>
<p>To document an item from inside the item (such as inside a module), use <code>//!</code> or
<code>/*! .. */</code>, called "inner doc comments":</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">//! This module contains functionality relating to divisibility of integers.</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>Show students the generated docs for the <code>rand</code> crate at
<a href="https://docs.rs/rand">https://docs.rs/rand</a>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-types-option"></div><h1 id="std-types-option-option"><a class="header" href="#std-types-option-option">Option</a></h1>
<p>We have already seen some use of <code>Option&lt;T&gt;</code>. It stores either a value of type
<code>T</code> or nothing. For example,
<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.find"><code>String::find</code></a>
returns an <code>Option&lt;usize&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn main() {
    let name = "L√∂we ËÄÅËôé L√©opard Gepardi";
    let mut position: Option&lt;usize&gt; = name.find('√©');
    println!("find returned {position:?}");
    assert_eq!(position.unwrap(), 14);
    position = name.find('Z');
    println!("find returned {position:?}");
    assert_eq!(position.expect("Character not found"), 0);
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li><code>Option</code> is widely used, not just in the standard library.</li>
<li><code>unwrap</code> will return the value in an <code>Option</code>, or panic. <code>expect</code> is similar
but takes an error message.
<ul>
<li>You can panic on None, but you can't "accidentally" forget to check for
None.</li>
<li>It's common to <code>unwrap</code>/<code>expect</code> all over the place when hacking something
together, but production code typically handles <code>None</code> in a nicer fashion.</li>
</ul>
</li>
<li>The niche optimization means that <code>Option&lt;T&gt;</code> often has the same size in
memory as <code>T</code>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-types-result"></div><h1 id="std-types-result-result"><a class="header" href="#std-types-result-result">Result</a></h1>
<p><code>Result</code> is similar to <code>Option</code>, but indicates the success or failure of an
operation, each with a different enum variant. It is generic: <code>Result&lt;T, E&gt;</code>
where <code>T</code> is used in the <code>Ok</code> variant and <code>E</code> appears in the <code>Err</code> variant.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result&lt;File, std::io::Error&gt; = File::open("diary.txt");
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&amp;mut contents) {
                println!("Dear diary: {contents} ({bytes} bytes)");
            } else {
                println!("Could not read file content");
            }
        }
        Err(err) =&gt; {
            println!("The diary could not be opened: {err}");
        }
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>As with <code>Option</code>, the successful value sits inside of <code>Result</code>, forcing the
developer to explicitly extract it. This encourages error checking. In the
case where an error should never happen, <code>unwrap()</code> or <code>expect()</code> can be
called, and this is a signal of the developer intent too.</li>
<li><code>Result</code> documentation is a recommended read. Not during the course, but it is
worth mentioning. It contains a lot of convenience methods and functions that
help functional-style programming.</li>
<li><code>Result</code> is the standard type to implement error handling as we will see on
Day 4.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-types-string"></div><h1 id="std-types-string-string"><a class="header" href="#std-types-string-string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is a growable UTF-8 encoded string:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1 = String::new();
    s1.push_str("Hello");
    println!("s1: len = {}, capacity = {}", s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!("s2: len = {}, capacity = {}", s2.len(), s2.capacity());

    let s3 = String::from("üá®üá≠");
    println!("s3: len = {}, number of chars = {}", s3.len(), s3.chars().count());
}</code></pre></pre>
<p><code>String</code> implements <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>, which means that you can call
all <code>str</code> methods on a <code>String</code>.</p>
<details>
This slide should take about 5 minutes. 
<ul>
<li><code>String::new</code> returns a new empty string, use <code>String::with_capacity</code> when you
know how much data you want to push to the string.</li>
<li><code>String::len</code> returns the size of the <code>String</code> in bytes (which can be
different from its length in characters).</li>
<li><code>String::chars</code> returns an iterator over the actual characters. Note that a
<code>char</code> can be different from what a human will consider a "character" due to
<a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html">grapheme clusters</a>.</li>
<li>When people refer to strings they could either be talking about <code>&amp;str</code> or
<code>String</code>.</li>
<li>When a type implements <code>Deref&lt;Target = T&gt;</code>, the compiler will let you
transparently call methods from <code>T</code>.
<ul>
<li>We haven't discussed the <code>Deref</code> trait yet, so at this point this mostly
explains the structure of the sidebar in the documentation.</li>
<li><code>String</code> implements <code>Deref&lt;Target = str&gt;</code> which transparently gives it
access to <code>str</code>'s methods.</li>
<li>Write and compare <code>let s3 = s1.deref();</code> and <code>let s3 = &amp;*s1;</code>.</li>
</ul>
</li>
<li><code>String</code> is implemented as a wrapper around a vector of bytes, many of the
operations you see supported on vectors are also supported on <code>String</code>, but
with some extra guarantees.</li>
<li>Compare the different ways to index a <code>String</code>:
<ul>
<li>To a character by using <code>s3.chars().nth(i).unwrap()</code> where <code>i</code> is in-bound,
out-of-bounds.</li>
<li>To a substring by using <code>s3[0..4]</code>, where that slice is on character
boundaries or not.</li>
</ul>
</li>
<li>Many types can be converted to a string with the
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string"><code>to_string</code></a>
method. This trait is automatically implemented for all types that implement
<code>Display</code>, so anything that can be formatted can also be converted to a
string.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-types-vec"></div><h1 id="std-types-vec-vec"><a class="header" href="#std-types-vec-vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> is the standard resizable heap-allocated buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!("v1: len = {}, capacity = {}", v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!("v2: len = {}, capacity = {}", v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!("{v3:?}");

    // Remove consecutive duplicates.
    v3.dedup();
    println!("{v3:?}");
}</code></pre></pre>
<p><code>Vec</code> implements <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>, which means that you can call slice
methods on a <code>Vec</code>.</p>
<details>
This slide should take about 5 minutes. 
<ul>
<li><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it
contains is stored on the heap. This means the amount of data doesn't need to
be known at compile time. It can grow or shrink at runtime.</li>
<li>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don't have to specify <code>T</code>
explicitly. As always with Rust type inference, the <code>T</code> was established during
the first <code>push</code> call.</li>
<li><code>vec![...]</code> is a canonical macro to use instead of <code>Vec::new()</code> and it
supports adding initial elements to the vector.</li>
<li>To index the vector you use <code>[</code> <code>]</code>, but they will panic if out of bounds.
Alternatively, using <code>get</code> will return an <code>Option</code>. The <code>pop</code> function will
remove the last element.</li>
<li>Slices are covered on day 3. For now, students only need to know that a value
of type <code>Vec</code> gives access to all of the documented slice methods, too.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-types-hashmap"></div><h1 id="std-types-hashmap-hashmap"><a class="header" href="#std-types-hashmap-hashmap"><code>HashMap</code></a></h1>
<p>Standard hash map with protection against HashDoS attacks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert("Adventures of Huckleberry Finn", 207);
    page_counts.insert("Grimms' Fairy Tales", 751);
    page_counts.insert("Pride and Prejudice", 303);

    if !page_counts.contains_key("Les Mis√©rables") {
        println!(
            "We know about {} books, but not Les Mis√©rables.",
            page_counts.len()
        );
    }

    for book in ["Pride and Prejudice", "Alice's Adventure in Wonderland"] {
        match page_counts.get(book) {
            Some(count) =&gt; println!("{book}: {count} pages"),
            None =&gt; println!("{book} is unknown."),
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in ["Pride and Prejudice", "Alice's Adventure in Wonderland"] {
        let page_count: &amp;mut i32 = page_counts.entry(book).or_insert(0);
        *page_count += 1;
    }

    println!("{page_counts:#?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p><code>HashMap</code> is not defined in the prelude and needs to be brought into scope.</p>
</li>
<li>
<p>Try the following lines of code. The first line will see if a book is in the
hashmap and if not return an alternative value. The second line will insert
the alternative value in the hashmap if the book is not found.</p>
<pre><code class="language-rust ignore">let pc1 = page_counts
    .get("Harry Potter and the Sorcerer's Stone")
    .unwrap_or(&amp;336);
let pc2 = page_counts
    .entry("The Hunger Games".to_string())
    .or_insert(374);</code></pre>
</li>
<li>
<p>Unlike <code>vec!</code>, there is unfortunately no standard <code>hashmap!</code> macro.</p>
<ul>
<li>
<p>Although, since Rust 1.56, HashMap implements <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E"><code>From&lt;[(K, V); N]&gt;</code></a>,
which allows us to easily initialize a hash map from a literal array:</p>
<pre><code class="language-rust ignore">let page_counts = HashMap::from([
  ("Harry Potter and the Sorcerer's Stone".to_string(), 336),
  ("The Hunger Games".to_string(), 374),
]);</code></pre>
</li>
</ul>
</li>
<li>
<p>Alternatively HashMap can be built from any <code>Iterator</code> which yields key-value
tuples.</p>
</li>
<li>
<p>We are showing <code>HashMap&lt;String, i32&gt;</code>, and avoid using <code>&amp;str</code> as key to make
examples easier. Using references in collections can, of course, be done, but
it can lead into complications with the borrow checker.</p>
<ul>
<li>Try removing <code>to_string()</code> from the example above and see if it still
compiles. Where do you think we might run into issues?</li>
</ul>
</li>
<li>
<p>This type has several "method-specific" return types, such as
<code>std::collections::hash_map::Keys</code>. These types often appear in searches of
the Rust docs. Show students the docs for this type, and the helpful link back
to the <code>keys</code> method.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-types-exercise"></div><h1 id="std-types-exercise-exercise-counter"><a class="header" href="#std-types-exercise-exercise-counter">Exercise: Counter</a></h1>
<p>In this exercise you will take a very simple data structure and make it generic.
It uses a
<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>std::collections::HashMap</code></a>
to keep track of which values have been seen and how many times each one has
appeared.</p>
<p>The initial version of <code>Counter</code> is hard coded to only work for <code>u32</code> values.
Make the struct and its methods generic over the type of value being tracked,
that way <code>Counter</code> can track any type of value.</p>
<p>If you finish early, try using the
<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.entry"><code>entry</code></a>
method to halve the number of hash lookups required to implement the <code>count</code>
method.</p>
<pre><pre class="playground"><code class="language-rust compile_fail editable edition2021">use std::collections::HashMap;

/// Counter counts the number of times each value of type T has been seen.
struct Counter {
    values: HashMap&lt;u32, u64&gt;,
}

impl Counter {
    /// Create a new Counter.
    fn new() -&gt; Self {
        Counter {
            values: HashMap::new(),
        }
    }

    /// Count an occurrence of the given value.
    fn count(&amp;mut self, value: u32) {
        if self.values.contains_key(&amp;value) {
            *self.values.get_mut(&amp;value).unwrap() += 1;
        } else {
            self.values.insert(value, 1);
        }
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&amp;self, value: u32) -&gt; u64 {
        self.values.get(&amp;value).copied().unwrap_or_default()
    }
}

fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!("saw {} values equal to {}", ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count("apple");
    strctr.count("orange");
    strctr.count("apple");
    println!("got {} apples", strctr.times_seen("apple"));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="std-types-solution"></div><h1 id="std-types-solution-solution"><a class="header" href="#std-types-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;
use std::hash::Hash;

/// Counter counts the number of times each value of type T has been seen.
struct Counter&lt;T&gt; {
    values: HashMap&lt;T, u64&gt;,
}

impl&lt;T: Eq + Hash&gt; Counter&lt;T&gt; {
    /// Create a new Counter.
    fn new() -&gt; Self {
        Counter { values: HashMap::new() }
    }

    /// Count an occurrence of the given value.
    fn count(&amp;mut self, value: T) {
        *self.values.entry(value).or_default() += 1;
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&amp;self, value: T) -&gt; u64 {
        self.values.get(&amp;value).copied().unwrap_or_default()
    }
}

fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!("saw {} values equal to {}", ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count("apple");
    strctr.count("orange");
    strctr.count("apple");
    println!("got {} apples", strctr.times_seen("apple"));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits"></div><h1 id="std-traits-standard-library-traits"><a class="header" href="#std-traits-standard-library-traits">Standard Library Traits</a></h1>
<p>This segment should take about 1 hour and 10 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Comparisons</td><td>5 minutes</td></tr>
<tr><td>Operators</td><td>5 minutes</td></tr>
<tr><td>From and Into</td><td>5 minutes</td></tr>
<tr><td>Casting</td><td>5 minutes</td></tr>
<tr><td>Read and Write</td><td>5 minutes</td></tr>
<tr><td>Default, struct update syntax</td><td>5 minutes</td></tr>
<tr><td>Closures</td><td>10 minutes</td></tr>
<tr><td>Exercise: ROT13</td><td>30 minutes</td></tr>
</tbody></table>
</div><details>
<p>As with the standard-library types, spend time reviewing the documentation for
each trait.</p>
<p>This section is long. Take a break midway through.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits-comparisons"></div><h1 id="std-traits-comparisons-comparisons"><a class="header" href="#std-traits-comparisons-comparisons">Comparisons</a></h1>
<p>These traits support comparisons between values. All traits can be derived for
types containing fields that implement these traits.</p>
<h2 id="std-traits-comparisons-partialeq-and-eq"><a class="header" href="#std-traits-comparisons-partialeq-and-eq"><code>PartialEq</code> and <code>Eq</code></a></h2>
<p><code>PartialEq</code> is a partial equivalence relation, with required method <code>eq</code> and
provided method <code>ne</code>. The <code>==</code> and <code>!=</code> operators will call these methods.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Key {
    id: u32,
    metadata: Option&lt;String&gt;,
}
impl PartialEq for Key {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.id == other.id
    }
}</code></pre></pre>
<p><code>Eq</code> is a full equivalence relation (reflexive, symmetric, and transitive) and
implies <code>PartialEq</code>. Functions that require full equivalence will use <code>Eq</code> as a
trait bound.</p>
<h2 id="std-traits-comparisons-partialord-and-ord"><a class="header" href="#std-traits-comparisons-partialord-and-ord"><code>PartialOrd</code> and <code>Ord</code></a></h2>
<p><code>PartialOrd</code> defines a partial ordering, with a <code>partial_cmp</code> method. It is used
to implement the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, and <code>&gt;</code> operators.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::cmp::Ordering;
#[derive(Eq, PartialEq)]
struct Citation {
    author: String,
    year: u32,
}
impl PartialOrd for Citation {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        match self.author.partial_cmp(&amp;other.author) {
            Some(Ordering::Equal) =&gt; self.year.partial_cmp(&amp;other.year),
            author_ord =&gt; author_ord,
        }
    }
}</code></pre></pre>
<p><code>Ord</code> is a total ordering, with <code>cmp</code> returning <code>Ordering</code>.</p>
<details>
This slide should take about 5 minutes. 
<p><code>PartialEq</code> can be implemented between different types, but <code>Eq</code> cannot, because
it is reflexive:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Key {
    id: u32,
    metadata: Option&lt;String&gt;,
}
impl PartialEq&lt;u32&gt; for Key {
    fn eq(&amp;self, other: &amp;u32) -&gt; bool {
        self.id == *other
    }
}</code></pre></pre>
<p>In practice, it's common to derive these traits, but uncommon to implement them.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-traits-operators"></div><h1 id="std-traits-operators-operators"><a class="header" href="#std-traits-operators-operators">Operators</a></h1>
<p>Operator overloading is implemented via traits in <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!("{:?} + {:?} = {:?}", p1, p2, p1 + p2);
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>Discussion points:</p>
<ul>
<li>You could implement <code>Add</code> for <code>&amp;Point</code>. In which situations is that useful?
<ul>
<li>Answer: <code>Add:add</code> consumes <code>self</code>. If type <code>T</code> for which you are overloading
the operator is not <code>Copy</code>, you should consider overloading the operator for
<code>&amp;T</code> as well. This avoids unnecessary cloning on the call site.</li>
</ul>
</li>
<li>Why is <code>Output</code> an associated type? Could it be made a type parameter of the
method?
<ul>
<li>Short answer: Function type parameters are controlled by the caller, but
associated types (like <code>Output</code>) are controlled by the implementer of a
trait.</li>
</ul>
</li>
<li>You could implement <code>Add</code> for two different types, e.g.
<code>impl Add&lt;(i32, i32)&gt; for Point</code> would add a tuple to a <code>Point</code>.</li>
</ul>
<p>The <code>Not</code> trait (<code>!</code> operator) is notable because it does not "boolify" like the
same operator in C-family languages; instead, for integer types it negates each
bit of the number, which arithmetically is equivalent to subtracting it from -1:
<code>!5 == -6</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits-from-and-into"></div><h1 id="std-traits-from-and-into-from-and-into"><a class="header" href="#std-traits-from-and-into-from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>Types implement <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> to facilitate type conversions.
Unlike <code>as</code>, these traits correspond to lossless, infallible conversions.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from("hello");
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123_i16);
    println!("{s}, {addr}, {one}, {bigger}");
}</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> is automatically implemented when <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> is implemented:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s: String = "hello".into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123_i16.into();
    println!("{s}, {addr}, {one}, {bigger}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>That's why it is common to only implement <code>From</code>, as your type will get <code>Into</code>
implementation too.</li>
<li>When declaring a function argument input type like "anything that can be
converted into a <code>String</code>", the rule is opposite, you should use <code>Into</code>. Your
function will accept types that implement <code>From</code> and those that <em>only</em>
implement <code>Into</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits-casting"></div><h1 id="std-traits-casting-casting"><a class="header" href="#std-traits-casting-casting">Casting</a></h1>
<p>Rust has no <em>implicit</em> type conversions, but does support explicit casts with
<code>as</code>. These generally follow C semantics where those are defined.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let value: i64 = 1000;
    println!("as u16: {}", value as u16);
    println!("as i16: {}", value as i16);
    println!("as u8: {}", value as u8);
}</code></pre></pre>
<p>The results of <code>as</code> are <em>always</em> defined in Rust and consistent across
platforms. This might not match your intuition for changing sign or casting to a
smaller type -- check the docs, and comment for clarity.</p>
<p>Casting with <code>as</code> is a relatively sharp tool that is easy to use incorrectly,
and can be a source of subtle bugs as future maintenance work changes the types
that are used or the ranges of values in types. Casts are best used only when
the intent is to indicate unconditional truncation (e.g. selecting the bottom 32
bits of a <code>u64</code> with <code>as u32</code>, regardless of what was in the high bits).</p>
<p>For infallible casts (e.g. <code>u32</code> to <code>u64</code>), prefer using <code>From</code> or <code>Into</code> over
<code>as</code> to confirm that the cast is in fact infallible. For fallible casts,
<code>TryFrom</code> and <code>TryInto</code> are available when you want to handle casts that fit
differently from those that don't.</p>
<details>
This slide should take about 5 minutes. 
<p>Consider taking a break after this slide.</p>
<p><code>as</code> is similar to a C++ static cast. Use of <code>as</code> in cases where data might be
lost is generally discouraged, or at least deserves an explanatory comment.</p>
<p>This is common in casting integers to <code>usize</code> for use as an index.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-traits-read-and-write"></div><h1 id="std-traits-read-and-write-read-and-write"><a class="header" href="#std-traits-read-and-write-read-and-write"><code>Read</code> and <code>Write</code></a></h1>
<p>Using <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a>, you can abstract over <code>u8</code> sources:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b"foo\nbar\nbaz\n";
    println!("lines in slice: {}", count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!("lines in file: {}", count_lines(file));
    Ok(())
}</code></pre></pre>
<p>Similarly, <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> lets you abstract over <code>u8</code> sinks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all("\n".as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, "Hello")?;
    log(&amp;mut buffer, "World")?;
    println!("Logged: {:?}", buffer);
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits-default"></div><h1 id="std-traits-default-the-default-trait"><a class="header" href="#std-traits-default-the-default-trait">The <code>Default</code> Trait</a></h1>
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait produces a default value for a type.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -&gt; Self {
        Self("John Smith".into())
    }
}

fn main() {
    let default_struct = Derived::default();
    println!("{default_struct:#?}");

    let almost_default_struct =
        Derived { y: "Y is set!".into(), ..Derived::default() };
    println!("{almost_default_struct:#?}");

    let nothing: Option&lt;Derived&gt; = None;
    println!("{:#?}", nothing.unwrap_or_default());
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>It can be implemented directly or it can be derived via <code>#[derive(Default)]</code>.</li>
<li>A derived implementation will produce a value where all fields are set to
their default values.
<ul>
<li>This means all types in the struct must implement <code>Default</code> too.</li>
</ul>
</li>
<li>Standard Rust types often implement <code>Default</code> with reasonable values (e.g.
<code>0</code>, <code>""</code>, etc).</li>
<li>The partial struct initialization works nicely with default.</li>
<li>The Rust standard library is aware that types can implement <code>Default</code> and
provides convenience methods that use it.</li>
<li>The <code>..</code> syntax is called <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits-closures"></div><h1 id="std-traits-closures-closures"><a class="header" href="#std-traits-closures-closures">Closures</a></h1>
<p>Closures or lambda expressions have types which cannot be named. However, they
implement special <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and
<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> traits:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn apply_with_log(func: impl FnOnce(i32) -&gt; i32, input: i32) -&gt; i32 {
    println!("Calling function on {input}");
    func(input)
}

fn main() {
    let add_3 = |x| x + 3;
    println!("add_3: {}", apply_with_log(add_3, 10));
    println!("add_3: {}", apply_with_log(add_3, 20));

    let mut v = Vec::new();
    let mut accumulate = |x: i32| {
        v.push(x);
        v.iter().sum::&lt;i32&gt;()
    };
    println!("accumulate: {}", apply_with_log(&amp;mut accumulate, 4));
    println!("accumulate: {}", apply_with_log(&amp;mut accumulate, 5));

    let multiply_sum = |x| x * v.into_iter().sum::&lt;i32&gt;();
    println!("multiply_sum: {}", apply_with_log(multiply_sum, 3));
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<p>An <code>Fn</code> (e.g. <code>add_3</code>) neither consumes nor mutates captured values, or perhaps
captures nothing at all. It can be called multiple times concurrently.</p>
<p>An <code>FnMut</code> (e.g. <code>accumulate</code>) might mutate captured values. You can call it
multiple times, but not concurrently.</p>
<p>If you have an <code>FnOnce</code> (e.g. <code>multiply_sum</code>), you may only call it once. It
might consume captured values.</p>
<p><code>FnMut</code> is a subtype of <code>FnOnce</code>. <code>Fn</code> is a subtype of <code>FnMut</code> and <code>FnOnce</code>.
I.e. you can use an <code>FnMut</code> wherever an <code>FnOnce</code> is called for, and you can use
an <code>Fn</code> wherever an <code>FnMut</code> or <code>FnOnce</code> is called for.</p>
<p>When you define a function that takes a closure, you should take <code>FnOnce</code> if you
can (i.e. you call it once), or <code>FnMut</code> else, and last <code>Fn</code>. This allows the
most flexibility for the caller.</p>
<p>In contrast, when you have a closure, the most flexible you can have is <code>Fn</code> (it
can be passed everywhere), then <code>FnMut</code>, and lastly <code>FnOnce</code>.</p>
<p>The compiler also infers <code>Copy</code> (e.g. for <code>add_3</code>) and <code>Clone</code> (e.g.
<code>multiply_sum</code>), depending on what the closure captures.</p>
<p>By default, closures will capture by reference if they can. The <code>move</code> keyword
makes them capture by value.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn make_greeter(prefix: String) -&gt; impl Fn(&amp;str) {
    return move |name| println!("{} {}", prefix, name);
}

fn main() {
    let hi = make_greeter("Hi".to_string());
    hi("Greg");
}</code></pre></pre>
</details><div style="break-before: page; page-break-before: always;"></div><div id="std-traits-exercise"></div><h1 id="std-traits-exercise-exercise-rot13"><a class="header" href="#std-traits-exercise-exercise-rot13">Exercise: ROT13</a></h1>
<p>In this example, you will implement the classic
<a href="https://en.wikipedia.org/wiki/ROT13">"ROT13" cipher</a>. Copy this code to the
playground, and implement the missing bits. Only rotate ASCII alphabetic
characters, to ensure the result is still valid UTF-8.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::io::Read;

struct RotDecoder&lt;R: Read&gt; {
    input: R,
    rot: u8,
}

// Implement the `Read` trait for `RotDecoder`.

fn main() {
    let mut rot =
        RotDecoder { input: "Gb trg gb gur bgure fvqr!".as_bytes(), rot: 13 };
    let mut result = String::new();
    rot.read_to_string(&amp;mut result).unwrap();
    println!("{}", result);
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: "Gb trg gb gur bgure fvqr!".as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&amp;mut result).unwrap();
        assert_eq!(&amp;result, "To get to the other side!");
    }

    #[test]
    fn binary() {
        let input: Vec&lt;u8&gt; = (0..=255u8).collect();
        let mut rot = RotDecoder::&lt;&amp;[u8]&gt; { input: input.as_ref(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&amp;mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}</code></pre></pre>
<p>What happens if you chain two <code>RotDecoder</code> instances together, each rotating by
13 characters?</p>
<div style="break-before: page; page-break-before: always;"></div><div id="std-traits-solution"></div><h1 id="std-traits-solution-solution"><a class="header" href="#std-traits-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::Read;

struct RotDecoder&lt;R: Read&gt; {
    input: R,
    rot: u8,
}

impl&lt;R: Read&gt; Read for RotDecoder&lt;R&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
        let size = self.input.read(buf)?;
        for b in &amp;mut buf[..size] {
            if b.is_ascii_alphabetic() {
                let base = if b.is_ascii_uppercase() { 'A' } else { 'a' } as u8;
                *b = (*b - base + self.rot) % 26 + base;
            }
        }
        Ok(size)
    }
}

fn main() {
    let mut rot =
        RotDecoder { input: "Gb trg gb gur bgure fvqr!".as_bytes(), rot: 13 };
    let mut result = String::new();
    rot.read_to_string(&amp;mut result).unwrap();
    println!("{}", result);
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: "Gb trg gb gur bgure fvqr!".as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&amp;mut result).unwrap();
        assert_eq!(&amp;result, "To get to the other side!");
    }

    #[test]
    fn binary() {
        let input: Vec&lt;u8&gt; = (0..=255u8).collect();
        let mut rot = RotDecoder::&lt;&amp;[u8]&gt; { input: input.as_ref(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&amp;mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-3"></div><h1 id="welcome-day-3-welcome-to-day-3"><a class="header" href="#welcome-day-3-welcome-to-day-3">Welcome to Day 3</a></h1>
<p>Today, we will cover:</p>
<ul>
<li>Memory management, lifetimes, and the borrow checker: how Rust ensures memory
safety.</li>
<li>Smart pointers: standard library pointer types.</li>
</ul>
<h2 id="welcome-day-3-schedule"><a class="header" href="#welcome-day-3-schedule">Schedule</a></h2>
<p>Including 10 minute breaks, this session should take about 2 hours and 20 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>3 minutes</td></tr>
<tr><td>Memory Management</td><td>1 hour</td></tr>
<tr><td>Smart Pointers</td><td>55 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="memory-management"></div><h1 id="memory-management-memory-management"><a class="header" href="#memory-management-memory-management">Memory Management</a></h1>
<p>This segment should take about 1 hour. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Review of Program Memory</td><td>5 minutes</td></tr>
<tr><td>Approaches to Memory Management</td><td>10 minutes</td></tr>
<tr><td>Ownership</td><td>5 minutes</td></tr>
<tr><td>Move Semantics</td><td>5 minutes</td></tr>
<tr><td>Clone</td><td>2 minutes</td></tr>
<tr><td>Copy Types</td><td>5 minutes</td></tr>
<tr><td>Drop</td><td>10 minutes</td></tr>
<tr><td>Exercise: Builder Type</td><td>20 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="memory-management-review"></div><h1 id="memory-management-review-review-of-program-memory"><a class="header" href="#memory-management-review-review-of-program-memory">Review of Program Memory</a></h1>
<p>Programs allocate memory in two ways:</p>
<ul>
<li>
<p>Stack: Continuous area of memory for local variables.</p>
<ul>
<li>Values have fixed sizes known at compile time.</li>
<li>Extremely fast: just move a stack pointer.</li>
<li>Easy to manage: follows function calls.</li>
<li>Great memory locality.</li>
</ul>
</li>
<li>
<p>Heap: Storage of values outside of function calls.</p>
<ul>
<li>Values have dynamic sizes determined at runtime.</li>
<li>Slightly slower than the stack: some book-keeping needed.</li>
<li>No guarantee of memory locality.</li>
</ul>
</li>
</ul>
<h2 id="memory-management-review-example"><a class="header" href="#memory-management-review-example">Example</a></h2>
<p>Creating a <code>String</code> puts fixed-sized metadata on the stack and dynamically sized
data, the actual string, on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from("Hello");
}</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="memory-management-review-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="memory-management-review-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="memory-management-review-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="memory-management-review-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="memory-management-review-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><text x="282" y="28" >Heap</text><line x1="296" y1="40" x2="304" y2="40" class="solid"></line><line x1="312" y1="40" x2="320" y2="40" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >capacity</text><text x="178" y="92" >5</text><text x="50" y="108" >ptr</text><circle cx="180" cy="104" r="3" class="nofill"></circle><text x="322" y="108" >H</text><text x="362" y="108" >e</text><text x="402" y="108" >l</text><text x="442" y="108" >l</text><text x="482" y="108" >o</text><text x="50" y="124" >len</text><text x="178" y="124" >5</text><line x1="328" y1="40" x2="336" y2="40" class="solid"></line><line x1="344" y1="40" x2="352" y2="40" class="solid"></line><line x1="360" y1="40" x2="368" y2="40" class="solid"></line><line x1="376" y1="40" x2="384" y2="40" class="solid"></line><line x1="392" y1="40" x2="400" y2="40" class="solid"></line><line x1="408" y1="40" x2="416" y2="40" class="solid"></line><line x1="424" y1="40" x2="432" y2="40" class="solid"></line><line x1="440" y1="40" x2="448" y2="40" class="solid"></line><line x1="456" y1="40" x2="464" y2="40" class="solid"></line><line x1="472" y1="40" x2="480" y2="40" class="solid"></line><line x1="488" y1="40" x2="496" y2="40" class="solid"></line><line x1="504" y1="40" x2="512" y2="40" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><line x1="296" y1="168" x2="304" y2="168" class="solid"></line><line x1="312" y1="168" x2="320" y2="168" class="solid"></line><line x1="328" y1="168" x2="336" y2="168" class="solid"></line><line x1="344" y1="168" x2="352" y2="168" class="solid"></line><line x1="360" y1="168" x2="368" y2="168" class="solid"></line><line x1="376" y1="168" x2="384" y2="168" class="solid"></line><line x1="392" y1="168" x2="400" y2="168" class="solid"></line><line x1="408" y1="168" x2="416" y2="168" class="solid"></line><line x1="424" y1="168" x2="432" y2="168" class="solid"></line><line x1="440" y1="168" x2="448" y2="168" class="solid"></line><line x1="456" y1="168" x2="464" y2="168" class="solid"></line><line x1="472" y1="168" x2="480" y2="168" class="solid"></line><line x1="488" y1="168" x2="496" y2="168" class="solid"></line><line x1="504" y1="168" x2="512" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,40 A 4,4 0,0,0 276,44" class="nofill"></path><line x1="276" y1="44" x2="276" y2="164" class="broken"></line><line x1="280" y1="40" x2="288" y2="40" class="solid"></line><path d="M 276,164 A 4,4 0,0,0 280,168" class="nofill"></path><line x1="280" y1="168" x2="288" y2="168" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="88" x2="508" y2="88" class="solid"></line><line x1="308" y1="88" x2="308" y2="120" class="solid"></line><line x1="348" y1="88" x2="348" y2="120" class="solid"></line><line x1="388" y1="88" x2="388" y2="120" class="solid"></line><line x1="428" y1="88" x2="428" y2="120" class="solid"></line><line x1="468" y1="88" x2="468" y2="120" class="solid"></line><line x1="508" y1="88" x2="508" y2="120" class="solid"></line><line x1="308" y1="120" x2="508" y2="120" class="solid"></line></g><g><line x1="184" y1="104" x2="296" y2="104" class="solid"></line><polygon points="296,100 304,104 296,108" class="filled"></polygon></g><g><line x1="520" y1="40" x2="528" y2="40" class="solid"></line><path d="M 528,40 A 4,4 0,0,1 532,44" class="nofill"></path><line x1="532" y1="44" x2="532" y2="164" class="broken"></line><line x1="520" y1="168" x2="528" y2="168" class="solid"></line><path d="M 532,164 A 4,4 0,0,1 528,168" class="nofill"></path></g></svg></div>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Mention that a <code>String</code> is backed by a <code>Vec</code>, so it has a capacity and length
and can grow if mutable via reallocation on the heap.</p>
</li>
<li>
<p>If students ask about it, you can mention that the underlying memory is heap
allocated using the <a href="https://doc.rust-lang.org/std/alloc/struct.System.html">System Allocator</a> and custom allocators can be
implemented using the <a href="https://doc.rust-lang.org/std/alloc/index.html">Allocator API</a></p>
</li>
</ul>
<h2 id="memory-management-review-more-to-explore"><a class="header" href="#memory-management-review-more-to-explore">More to Explore</a></h2>
<p>We can inspect the memory layout with <code>unsafe</code> Rust. However, you should point
out that this is rightfully unsafe!</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1 = String::from("Hello");
    s1.push(' ');
    s1.push_str("world");
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!("capacity = {capacity}, ptr = {ptr:#x}, len = {len}");
    }
}</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="memory-management-approaches"></div><h1 id="memory-management-approaches-approaches-to-memory-management"><a class="header" href="#memory-management-approaches-approaches-to-memory-management">Approaches to Memory Management</a></h1>
<p>Traditionally, languages have fallen into two broad categories:</p>
<ul>
<li>Full control via manual memory management: C, C++, Pascal, ...
<ul>
<li>Programmer decides when to allocate or free heap memory.</li>
<li>Programmer must determine whether a pointer still points to valid memory.</li>
<li>Studies show, programmers make mistakes.</li>
</ul>
</li>
<li>Full safety via automatic memory management at runtime: Java, Python, Go,
Haskell, ...
<ul>
<li>A runtime system ensures that memory is not freed until it can no longer be
referenced.</li>
<li>Typically implemented with reference counting, garbage collection, or RAII.</li>
</ul>
</li>
</ul>
<p>Rust offers a new mix:</p>
<blockquote>
<p>Full control <em>and</em> safety via compile time enforcement of correct memory
management.</p>
</blockquote>
<p>It does this with an explicit ownership concept.</p>
<details>
This slide should take about 10 minutes. 
<p>This slide is intended to help students coming from other languages to put Rust
in context.</p>
<ul>
<li>
<p>C must manage heap manually with <code>malloc</code> and <code>free</code>. Common errors include
forgetting to call <code>free</code>, calling it multiple times for the same pointer, or
dereferencing a pointer after the memory it points to has been freed.</p>
</li>
<li>
<p>C++ has tools like smart pointers (<code>unique_ptr</code>, <code>shared_ptr</code>) that take
advantage of language guarantees about calling destructors to ensure memory is
freed when a function returns. It is still quite easy to mis-use these tools
and create similar bugs to C.</p>
</li>
<li>
<p>Java, Go, and Python rely on the garbage collector to identify memory that is
no longer reachable and discard it. This guarantees that any pointer can be
dereferenced, eliminating use-after-free and other classes of bugs. But, GC
has a runtime cost and is difficult to tune properly.</p>
</li>
</ul>
<p>Rust's ownership and borrowing model can, in many cases, get the performance of
C, with alloc and free operations precisely where they are required -- zero
cost. It also provides tools similar to C++'s smart pointers. When required,
other options such as reference counting are available, and there are even
third-party crates available to support runtime garbage collection (not covered
in this class).</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="memory-management-ownership"></div><h1 id="memory-management-ownership-ownership"><a class="header" href="#memory-management-ownership-ownership">Ownership</a></h1>
<p>All variable bindings have a <em>scope</em> where they are valid and it is an error to
use a variable outside its scope:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!("x: {}", p.0);
    }
    println!("y: {}", p.1);
}</code></pre></pre>
<p>We say that the variable <em>owns</em> the value. Every Rust value has precisely one
owner at all times.</p>
<p>At the end of the scope, the variable is <em>dropped</em> and the data is freed. A
destructor can run here to free up resources.</p>
<details>
This slide should take about 5 minutes. 
<p>Students familiar with garbage-collection implementations will know that a
garbage collector starts with a set of "roots" to find all reachable memory.
Rust's "single owner" principle is a similar idea.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="memory-management-move"></div><h1 id="memory-management-move-move-semantics"><a class="header" href="#memory-management-move-move-semantics">Move Semantics</a></h1>
<p>An assignment will transfer <em>ownership</em> between variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from("Hello!");
    let s2: String = s1;
    println!("s2: {s2}");
    // println!("s1: {s1}");
}</code></pre></pre>
<ul>
<li>The assignment of <code>s1</code> to <code>s2</code> transfers ownership.</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it does not own anything.</li>
<li>When <code>s2</code> goes out of scope, the string data is freed.</li>
</ul>
<p>Before move to <code>s2</code>:</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="592" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="memory-management-move-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="memory-management-move-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="memory-management-move-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="memory-management-move-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="memory-management-move-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="592" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="522" y="92" >!</text><text x="50" y="108" >len</text><text x="178" y="108" >6</text><text x="50" y="124" >capacity</text><text x="178" y="124" >6</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="548" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="548" y1="72" x2="548" y2="104" class="solid"></line><line x1="308" y1="104" x2="548" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><path d="M 576,24 A 4,4 0,0,1 580,28" class="nofill"></path><line x1="580" y1="28" x2="580" y2="148" class="broken"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><path d="M 580,148 A 4,4 0,0,1 576,152" class="nofill"></path></g></svg></div>
<p>After move to <code>s2</code>:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="592" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="memory-management-move-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="memory-management-move-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="memory-management-move-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="memory-management-move-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="memory-management-move-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="592" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="522" y="92" >!</text><text x="50" y="108" >len</text><text x="178" y="108" >6</text><text x="50" y="124" >capacity</text><text x="178" y="124" >6</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >6</text><text x="50" y="236" >capacity</text><text x="178" y="236" >6</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >(inaccessible)</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="548" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="548" y1="72" x2="548" y2="104" class="solid"></line><line x1="308" y1="104" x2="548" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><path d="M 576,24 A 4,4 0,0,1 580,28" class="nofill"></path><line x1="580" y1="28" x2="580" y2="148" class="broken"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><path d="M 580,148 A 4,4 0,0,1 576,152" class="nofill"></path></g></svg></div>
<p>When you pass a value to a function, the value is assigned to the function
parameter. This transfers ownership:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!("Hello {name}")
}

fn main() {
    let name = String::from("Alice");
    say_hello(name);
    // say_hello(name);
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Mention that this is the opposite of the defaults in C++, which copies by
value unless you use <code>std::move</code> (and the move constructor is defined!).</p>
</li>
<li>
<p>It is only the ownership that moves. Whether any machine code is generated to
manipulate the data itself is a matter of optimization, and such copies are
aggressively optimized away.</p>
</li>
<li>
<p>Simple values (such as integers) can be marked <code>Copy</code> (see later slides).</p>
</li>
<li>
<p>In Rust, clones are explicit (by using <code>clone</code>).</p>
</li>
</ul>
<p>In the <code>say_hello</code> example:</p>
<ul>
<li>With the first call to <code>say_hello</code>, <code>main</code> gives up ownership of <code>name</code>.
Afterwards, <code>name</code> cannot be used anymore within <code>main</code>.</li>
<li>The heap memory allocated for <code>name</code> will be freed at the end of the
<code>say_hello</code> function.</li>
<li><code>main</code> can retain ownership if it passes <code>name</code> as a reference (<code>&amp;name</code>) and
if <code>say_hello</code> accepts a reference as a parameter.</li>
<li>Alternatively, <code>main</code> can pass a clone of <code>name</code> in the first call
(<code>name.clone()</code>).</li>
<li>Rust makes it harder than C++ to inadvertently create copies by making move
semantics the default, and by forcing programmers to make clones explicit.</li>
</ul>
<h1 id="memory-management-move-more-to-explore"><a class="header" href="#memory-management-move-more-to-explore">More to Explore</a></h1>
<h2 id="memory-management-move-defensive-copies-in-modern-c"><a class="header" href="#memory-management-move-defensive-copies-in-modern-c">Defensive Copies in Modern C++</a></h2>
<p>Modern C++ solves this differently:</p>
<pre><code class="language-c++">std::string s1 = "Cpp";
std::string s2 = s1;  // Duplicate the data in s1.
</code></pre>
<ul>
<li>The heap data from <code>s1</code> is duplicated and <code>s2</code> gets its own independent copy.</li>
<li>When <code>s1</code> and <code>s2</code> go out of scope, they each free their own memory.</li>
</ul>
<p>Before copy-assignment:</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="memory-management-move-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="memory-management-move-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="memory-management-move-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="memory-management-move-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="memory-management-move-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>After copy-assignment:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="memory-management-move-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="memory-management-move-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="memory-management-move-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="memory-management-move-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="memory-management-move-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div>
<p>Key points:</p>
<ul>
<li>
<p>C++ has made a slightly different choice than Rust. Because <code>=</code> copies data,
the string data has to be cloned. Otherwise we would get a double-free when
either string goes out of scope.</p>
</li>
<li>
<p>C++ also has <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>, which is used to indicate when a value may be
moved from. If the example had been <code>s2 = std::move(s1)</code>, no heap allocation
would take place. After the move, <code>s1</code> would be in a valid but unspecified
state. Unlike Rust, the programmer is allowed to keep using <code>s1</code>.</p>
</li>
<li>
<p>Unlike Rust, <code>=</code> in C++ can run arbitrary code as determined by the type which
is being copied or moved.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="memory-management-clone"></div><h1 id="memory-management-clone-clone"><a class="header" href="#memory-management-clone-clone">Clone</a></h1>
<p>Sometimes you <em>want</em> to make a copy of a value. The <code>Clone</code> trait accomplishes
this.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!("Hello {name}")
}

fn main() {
    let name = String::from("Alice");
    say_hello(name.clone());
    say_hello(name);
}</code></pre></pre>
<details>
This slide should take about 2 minutes. 
<ul>
<li>
<p>The idea of <code>Clone</code> is to make it easy to spot where heap allocations are
occurring. Look for <code>.clone()</code> and a few others like <code>vec!</code> or <code>Box::new</code>.</p>
</li>
<li>
<p>It's common to "clone your way out" of problems with the borrow checker, and
return later to try to optimize those clones away.</p>
</li>
<li>
<p><code>clone</code> generally performs a deep copy of the value, meaning that if you e.g.
clone an array, all of the elements of the array are cloned as well.</p>
</li>
<li>
<p>The behavior for <code>clone</code> is user-defined, so it can perform custom cloning
logic if needed.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="memory-management-copy-types"></div><h1 id="memory-management-copy-types-copy-types"><a class="header" href="#memory-management-copy-types-copy-types">Copy Types</a></h1>
<p>While move semantics are the default, certain types are copied by default:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 42;
    let y = x;
    println!("x: {x}"); // would not be accessible if not Copy
    println!("y: {y}");
}</code></pre></pre>
<p>These types implement the <code>Copy</code> trait.</p>
<p>You can opt-in your own types to use copy semantics:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!("p1: {p1:?}");
    println!("p2: {p2:?}");
}</code></pre></pre>
<ul>
<li>After the assignment, both <code>p1</code> and <code>p2</code> own their own data.</li>
<li>We can also use <code>p1.clone()</code> to explicitly copy the data.</li>
</ul>
<details>
This slide should take about 5 minutes. 
<p>Copying and cloning are not the same thing:</p>
<ul>
<li>Copying refers to bitwise copies of memory regions and does not work on
arbitrary objects.</li>
<li>Copying does not allow for custom logic (unlike copy constructors in C++).</li>
<li>Cloning is a more general operation and also allows for custom behavior by
implementing the <code>Clone</code> trait.</li>
<li>Copying does not work on types that implement the <code>Drop</code> trait.</li>
</ul>
<p>In the above example, try the following:</p>
<ul>
<li>Add a <code>String</code> field to <code>struct Point</code>. It will not compile because <code>String</code>
is not a <code>Copy</code> type.</li>
<li>Remove <code>Copy</code> from the <code>derive</code> attribute. The compiler error is now in the
<code>println!</code> for <code>p1</code>.</li>
<li>Show that it works if you clone <code>p1</code> instead.</li>
</ul>
<h1 id="memory-management-copy-types-more-to-explore"><a class="header" href="#memory-management-copy-types-more-to-explore">More to Explore</a></h1>
<ul>
<li>Shared references are <code>Copy</code>/<code>Clone</code>, mutable references are not. This is
because rust requires that mutable references be exclusive, so while it's
valid to make a copy of a shared reference, creating a copy of a mutable
reference would violate Rust's borrowing rules.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="memory-management-drop"></div><h1 id="memory-management-drop-the-drop-trait"><a class="header" href="#memory-management-drop-the-drop-trait">The <code>Drop</code> Trait</a></h1>
<p>Values which implement <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> can specify code to run when they go out of
scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!("Dropping {}", self.name);
    }
}

fn main() {
    let a = Droppable { name: "a" };
    {
        let b = Droppable { name: "b" };
        {
            let c = Droppable { name: "c" };
            let d = Droppable { name: "d" };
            println!("Exiting block B");
        }
        println!("Exiting block A");
    }
    drop(a);
    println!("Exiting main");
}</code></pre></pre>
<details>
This slide should take about 8 minutes. 
<ul>
<li>Note that <code>std::mem::drop</code> is not the same as <code>std::ops::Drop::drop</code>.</li>
<li>Values are automatically dropped when they go out of scope.</li>
<li>When a value is dropped, if it implements <code>std::ops::Drop</code> then its
<code>Drop::drop</code> implementation will be called.</li>
<li>All its fields will then be dropped too, whether or not it implements <code>Drop</code>.</li>
<li><code>std::mem::drop</code> is just an empty function that takes any value. The
significance is that it takes ownership of the value, so at the end of its
scope it gets dropped. This makes it a convenient way to explicitly drop
values earlier than they would otherwise go out of scope.
<ul>
<li>This can be useful for objects that do some work on <code>drop</code>: releasing locks,
closing files, etc.</li>
</ul>
</li>
</ul>
<p>Discussion points:</p>
<ul>
<li>Why doesn't <code>Drop::drop</code> take <code>self</code>?
<ul>
<li>Short-answer: If it did, <code>std::mem::drop</code> would be called at the end of the
block, resulting in another call to <code>Drop::drop</code>, and a stack overflow!</li>
</ul>
</li>
<li>Try replacing <code>drop(a)</code> with <code>a.drop()</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="memory-management-exercise"></div><h1 id="memory-management-exercise-exercise-builder-type"><a class="header" href="#memory-management-exercise-exercise-builder-type">Exercise: Builder Type</a></h1>
<p>In this example, we will implement a complex data type that owns all of its
data. We will use the "builder pattern" to support building a new value
piece-by-piece, using convenience functions.</p>
<p>Fill in the missing pieces.</p>
<pre><pre class="playground"><code class="language-rust should_panic editable edition2021">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        todo!("1")
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        todo!("2")
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        todo!("3")
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        todo!("4")
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        todo!("5")
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new("base64").version("0.13").build();
    println!("base64: {base64:?}");
    let log =
        PackageBuilder::new("log").version("0.4").language(Language::Rust).build();
    println!("log: {log:?}");
    let serde = PackageBuilder::new("serde")
        .authors(vec!["djmitche".into()])
        .version(String::from("4.0"))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    println!("serde: {serde:?}");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="memory-management-solution"></div><h1 id="memory-management-solution-solution"><a class="header" href="#memory-management-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        Dependency {
            name: self.name.clone(),
            version_expression: self.version.clone(),
        }
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        Self(Package {
            name: name.into(),
            version: "0.1".into(),
            authors: vec![],
            dependencies: vec![],
            language: None,
        })
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        self.0.authors = authors;
        self
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        self.0.dependencies.push(dependency);
        self
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        self.0.language = Some(language);
        self
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new("base64").version("0.13").build();
    println!("base64: {base64:?}");
    let log =
        PackageBuilder::new("log").version("0.4").language(Language::Rust).build();
    println!("log: {log:?}");
    let serde = PackageBuilder::new("serde")
        .authors(vec!["djmitche".into()])
        .version(String::from("4.0"))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    println!("serde: {serde:?}");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="smart-pointers"></div><h1 id="smart-pointers-smart-pointers"><a class="header" href="#smart-pointers-smart-pointers">Smart Pointers</a></h1>
<p>This segment should take about 55 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Box<T></td><td>10 minutes</td></tr>
<tr><td>Rc</td><td>5 minutes</td></tr>
<tr><td>Owned Trait Objects</td><td>10 minutes</td></tr>
<tr><td>Exercise: Binary Tree</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="smart-pointers-box"></div><h1 id="smart-pointers-box-boxt"><a class="header" href="#smart-pointers-box-boxt"><code>Box&lt;T&gt;</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> is an owned pointer
to data on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let five = Box::new(5);
    println!("five: {}", *five);
}</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="smart-pointers-box-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="smart-pointers-box-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="smart-pointers-box-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="smart-pointers-box-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="smart-pointers-box-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> implements <code>Deref&lt;Target = T&gt;</code>, which means that you can
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">call methods
from <code>T</code> directly on a <code>Box&lt;T&gt;</code></a>.</p>
<p>Recursive data types or data types with dynamic sizes cannot be stored inline
without a pointer indirection, which can be worked around using <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    /// A non-empty list: first element and the rest of the list.
    Element(T, Box&lt;List&lt;T&gt;&gt;),
    /// An empty list.
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; =
        List::Element(1, Box::new(List::Element(2, Box::new(List::Nil))));
    println!("{list:?}");
}</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="696" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="smart-pointers-box-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="smart-pointers-box-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="smart-pointers-box-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="smart-pointers-box-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="smart-pointers-box-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="696" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="236" y1="28" x2="236" y2="148" class="broken"></line><text x="42" y="60" >list</text><text x="50" y="92" >Element</text><text x="130" y="92" >1</text><circle cx="172" cy="88" r="3" class="nofill"></circle><text x="338" y="92" >Element</text><text x="418" y="92" >2</text><circle cx="460" cy="88" r="3" class="nofill"></circle><text x="538" y="92" >Nil</text><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="608" y1="80" x2="600" y2="96" class="solid"></line><line x1="640" y1="80" x2="632" y2="96" class="solid"></line><line x1="648" y1="80" x2="640" y2="96" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="304" y1="24" x2="312" y2="24" class="solid"></line><line x1="320" y1="24" x2="328" y2="24" class="solid"></line><line x1="336" y1="24" x2="344" y2="24" class="solid"></line><line x1="352" y1="24" x2="360" y2="24" class="solid"></line><line x1="368" y1="24" x2="376" y2="24" class="solid"></line><line x1="384" y1="24" x2="392" y2="24" class="solid"></line><line x1="400" y1="24" x2="408" y2="24" class="solid"></line><line x1="416" y1="24" x2="424" y2="24" class="solid"></line><line x1="432" y1="24" x2="440" y2="24" class="solid"></line><line x1="448" y1="24" x2="456" y2="24" class="solid"></line><line x1="464" y1="24" x2="472" y2="24" class="solid"></line><line x1="480" y1="24" x2="488" y2="24" class="solid"></line><line x1="496" y1="24" x2="504" y2="24" class="solid"></line><line x1="512" y1="24" x2="520" y2="24" class="solid"></line><line x1="528" y1="24" x2="536" y2="24" class="solid"></line><line x1="544" y1="24" x2="552" y2="24" class="solid"></line><line x1="560" y1="24" x2="568" y2="24" class="solid"></line><line x1="576" y1="24" x2="584" y2="24" class="solid"></line><line x1="592" y1="24" x2="600" y2="24" class="solid"></line><line x1="608" y1="24" x2="616" y2="24" class="solid"></line><line x1="624" y1="24" x2="632" y2="24" class="solid"></line><line x1="640" y1="24" x2="648" y2="24" class="solid"></line><line x1="656" y1="24" x2="664" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="304" y1="152" x2="312" y2="152" class="solid"></line><line x1="320" y1="152" x2="328" y2="152" class="solid"></line><line x1="336" y1="152" x2="344" y2="152" class="solid"></line><line x1="352" y1="152" x2="360" y2="152" class="solid"></line><line x1="368" y1="152" x2="376" y2="152" class="solid"></line><line x1="384" y1="152" x2="392" y2="152" class="solid"></line><line x1="400" y1="152" x2="408" y2="152" class="solid"></line><line x1="416" y1="152" x2="424" y2="152" class="solid"></line><line x1="432" y1="152" x2="440" y2="152" class="solid"></line><line x1="448" y1="152" x2="456" y2="152" class="solid"></line><line x1="464" y1="152" x2="472" y2="152" class="solid"></line><line x1="480" y1="152" x2="488" y2="152" class="solid"></line><line x1="496" y1="152" x2="504" y2="152" class="solid"></line><line x1="512" y1="152" x2="520" y2="152" class="solid"></line><line x1="528" y1="152" x2="536" y2="152" class="solid"></line><line x1="544" y1="152" x2="552" y2="152" class="solid"></line><line x1="560" y1="152" x2="568" y2="152" class="solid"></line><line x1="576" y1="152" x2="584" y2="152" class="solid"></line><line x1="592" y1="152" x2="600" y2="152" class="solid"></line><line x1="608" y1="152" x2="616" y2="152" class="solid"></line><line x1="624" y1="152" x2="632" y2="152" class="solid"></line><line x1="640" y1="152" x2="648" y2="152" class="solid"></line><line x1="656" y1="152" x2="664" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><path d="M 288,24 A 4,4 0,0,0 284,28" class="nofill"></path><line x1="284" y1="28" x2="284" y2="148" class="broken"></line><line x1="288" y1="24" x2="296" y2="24" class="solid"></line><path d="M 284,148 A 4,4 0,0,0 288,152" class="nofill"></path><line x1="288" y1="152" x2="296" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="116" y1="72" x2="116" y2="104" class="solid"></line><line x1="156" y1="72" x2="156" y2="104" class="solid"></line><line x1="196" y1="72" x2="196" y2="104" class="solid"></line><line x1="36" y1="104" x2="196" y2="104" class="solid"></line></g><g><line x1="324" y1="72" x2="484" y2="72" class="solid"></line><line x1="324" y1="72" x2="324" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="444" y1="72" x2="444" y2="104" class="solid"></line><line x1="484" y1="72" x2="484" y2="104" class="solid"></line><line x1="324" y1="104" x2="484" y2="104" class="solid"></line></g><g><line x1="524" y1="72" x2="660" y2="72" class="solid"></line><line x1="524" y1="72" x2="524" y2="104" class="solid"></line><line x1="580" y1="72" x2="580" y2="104" class="solid"></line><line x1="620" y1="72" x2="620" y2="104" class="solid"></line><line x1="660" y1="72" x2="660" y2="104" class="solid"></line><line x1="524" y1="104" x2="660" y2="104" class="solid"></line></g><g><line x1="176" y1="88" x2="312" y2="88" class="solid"></line><polygon points="312,84 320,88 312,92" class="filled"></polygon></g><g><line x1="464" y1="88" x2="512" y2="88" class="solid"></line><polygon points="512,84 520,88 512,92" class="filled"></polygon></g><g><line x1="672" y1="24" x2="680" y2="24" class="solid"></line><path d="M 680,24 A 4,4 0,0,1 684,28" class="nofill"></path><line x1="684" y1="28" x2="684" y2="148" class="broken"></line><line x1="672" y1="152" x2="680" y2="152" class="solid"></line><path d="M 684,148 A 4,4 0,0,1 680,152" class="nofill"></path></g></svg></div>
<details>
This slide should take about 8 minutes. 
<ul>
<li>
<p><code>Box</code> is like <code>std::unique_ptr</code> in C++, except that it's guaranteed to be not
null.</p>
</li>
<li>
<p>A <code>Box</code> can be useful when you:</p>
<ul>
<li>have a type whose size that can't be known at compile time, but the Rust
compiler wants to know an exact size.</li>
<li>want to transfer ownership of a large amount of data. To avoid copying large
amounts of data on the stack, instead store the data on the heap in a <code>Box</code>
so only the pointer is moved.</li>
</ul>
</li>
<li>
<p>If <code>Box</code> was not used and we attempted to embed a <code>List</code> directly into the
<code>List</code>, the compiler would not be able to compute a fixed size for the struct
in memory (the <code>List</code> would be of infinite size).</p>
</li>
<li>
<p><code>Box</code> solves this problem as it has the same size as a regular pointer and
just points at the next element of the <code>List</code> in the heap.</p>
</li>
<li>
<p>Remove the <code>Box</code> in the List definition and show the compiler error. We get
the message "recursive without indirection", because for data recursion, we
have to use indirection, a <code>Box</code> or reference of some kind, instead of storing
the value directly.</p>
</li>
</ul>
<h1 id="smart-pointers-box-more-to-explore"><a class="header" href="#smart-pointers-box-more-to-explore">More to Explore</a></h1>
<h2 id="smart-pointers-box-niche-optimization"><a class="header" href="#smart-pointers-box-niche-optimization">Niche Optimization</a></h2>
<p>Though <code>Box</code> looks like <code>std::unique_ptr</code> in C++, it cannot be empty/null. This
makes <code>Box</code> one of the types that allow the compiler to optimize storage of some
enums.</p>
<p>For example, <code>Option&lt;Box&lt;T&gt;&gt;</code> has the same size, as just <code>Box&lt;T&gt;</code>, because
compiler uses NULL-value to discriminate variants instead of using explicit tag
(<a href="https://doc.rust-lang.org/std/option/#representation">"Null Pointer Optimization"</a>):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::size_of_val;

struct Item(String);

fn main() {
    let just_box: Box&lt;Item&gt; = Box::new(Item("Just box".into()));
    let optional_box: Option&lt;Box&lt;Item&gt;&gt; =
        Some(Box::new(Item("Optional box".into())));
    let none: Option&lt;Box&lt;Item&gt;&gt; = None;

    assert_eq!(size_of_val(&amp;just_box), size_of_val(&amp;optional_box));
    assert_eq!(size_of_val(&amp;just_box), size_of_val(&amp;none));

    println!("Size of just_box: {}", size_of_val(&amp;just_box));
    println!("Size of optional_box: {}", size_of_val(&amp;optional_box));
    println!("Size of none: {}", size_of_val(&amp;none));
}</code></pre></pre>
</details><div style="break-before: page; page-break-before: always;"></div><div id="smart-pointers-rc"></div><h1 id="smart-pointers-rc-rc"><a class="header" href="#smart-pointers-rc-rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> is a reference-counted shared pointer. Use this when you need to refer
to the same data from multiple places:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::rc::Rc;

fn main() {
    let a = Rc::new(10);
    let b = Rc::clone(&amp;a);

    println!("a: {a}");
    println!("b: {b}");
}</code></pre></pre>
<ul>
<li>See <a href="#concurrency-shared-state-arc"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> if you are in a multi-threaded context.</li>
<li>You can <em>downgrade</em> a shared pointer into a <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a> pointer to create
cycles that will get dropped.</li>
</ul>
<details>
This slide should take about 5 minutes. 
<ul>
<li><code>Rc</code>'s count ensures that its contained value is valid for as long as there
are references.</li>
<li><code>Rc</code> in Rust is like <code>std::shared_ptr</code> in C++.</li>
<li><code>Rc::clone</code> is cheap: it creates a pointer to the same allocation and
increases the reference count. Does not make a deep clone and can generally be
ignored when looking for performance issues in code.</li>
<li><code>make_mut</code> actually clones the inner value if necessary ("clone-on-write") and
returns a mutable reference.</li>
<li>Use <code>Rc::strong_count</code> to check the reference count.</li>
<li><code>Rc::downgrade</code> gives you a <em>weakly reference-counted</em> object to create cycles
that will be dropped properly (likely in combination with <code>RefCell</code>).</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="smart-pointers-trait-objects"></div><h1 id="smart-pointers-trait-objects-owned-trait-objects"><a class="header" href="#smart-pointers-trait-objects-owned-trait-objects">Owned Trait Objects</a></h1>
<p>We previously saw how trait objects can be used with references, e.g <code>&amp;dyn Pet</code>.
However, we can also use trait objects with smart pointers like <code>Box</code> to create
an owned trait object: <code>Box&lt;dyn Pet&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!("Woof, my name is {}!", self.name)
    }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String {
        String::from("Miau!")
    }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Pet&gt;&gt; = vec![
        Box::new(Cat { lives: 9 }),
        Box::new(Dog { name: String::from("Fido"), age: 5 }),
    ];
    for pet in pets {
        println!("Hello, who are you? {}", pet.talk());
    }
}</code></pre></pre>
<p>Memory layout after allocating <code>pets</code>:</p>
<div style='width:100%; height:480px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="480"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="smart-pointers-trait-objects-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="smart-pointers-trait-objects-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="smart-pointers-trait-objects-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="smart-pointers-trait-objects-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="smart-pointers-trait-objects-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="480"></rect><rect x="428" y="328" width="184" height="32" class="solid nofill" rx="0"></rect><text x="442" y="348" >&lt;Dog as Pet&gt;::talk</text><rect x="428" y="392" width="184" height="32" class="solid nofill" rx="0"></rect><text x="442" y="412" >&lt;Cat as Pet&gt;::talk</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="482" y="76" >F</text><text x="522" y="76" >i</text><text x="562" y="76" >d</text><text x="602" y="76" >o</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >lives</text><text x="410" y="92" >9</text><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><text x="466" y="156" >data:</text><text x="474" y="188" >name</text><circle cx="548" cy="184" r="3" class="nofill"></circle><text x="554" y="188" >,</text><text x="570" y="188" >4,</text><text x="594" y="188" >4</text><circle cx="324" cy="200" r="3" class="nofill"></circle><circle cx="340" cy="200" r="3" class="nofill"></circle><circle cx="372" cy="200" r="3" class="nofill"></circle><circle cx="388" cy="200" r="3" class="nofill"></circle><text x="474" y="204" >age</text><text x="594" y="204" >5</text><line x1="424" y1="296" x2="432" y2="296" class="solid"></line><line x1="440" y1="296" x2="448" y2="296" class="solid"></line><line x1="456" y1="296" x2="464" y2="296" class="solid"></line><line x1="472" y1="296" x2="480" y2="296" class="solid"></line><text x="434" y="316" >vtable</text><text x="434" y="380" >vtable</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><line x1="296" y1="248" x2="304" y2="248" class="solid"></line><line x1="336" y1="248" x2="344" y2="248" class="solid"></line><line x1="352" y1="248" x2="360" y2="248" class="solid"></line><line x1="392" y1="248" x2="400" y2="248" class="solid"></line><line x1="408" y1="248" x2="416" y2="248" class="solid"></line><line x1="424" y1="248" x2="432" y2="248" class="solid"></line><line x1="440" y1="248" x2="448" y2="248" class="solid"></line><line x1="456" y1="248" x2="464" y2="248" class="solid"></line><line x1="472" y1="248" x2="480" y2="248" class="solid"></line><line x1="488" y1="248" x2="496" y2="248" class="solid"></line><line x1="504" y1="248" x2="512" y2="248" class="solid"></line><line x1="520" y1="248" x2="528" y2="248" class="solid"></line><line x1="536" y1="248" x2="544" y2="248" class="solid"></line><line x1="552" y1="248" x2="560" y2="248" class="solid"></line><line x1="568" y1="248" x2="576" y2="248" class="solid"></line><line x1="584" y1="248" x2="592" y2="248" class="solid"></line><line x1="600" y1="248" x2="608" y2="248" class="solid"></line><line x1="616" y1="248" x2="624" y2="248" class="solid"></line><line x1="296" y1="296" x2="304" y2="296" class="solid"></line><line x1="336" y1="296" x2="344" y2="296" class="solid"></line><line x1="352" y1="296" x2="360" y2="296" class="solid"></line><line x1="392" y1="296" x2="400" y2="296" class="solid"></line><line x1="408" y1="296" x2="416" y2="296" class="solid"></line><line x1="488" y1="296" x2="496" y2="296" class="solid"></line><line x1="504" y1="296" x2="512" y2="296" class="solid"></line><line x1="520" y1="296" x2="528" y2="296" class="solid"></line><line x1="536" y1="296" x2="544" y2="296" class="solid"></line><line x1="552" y1="296" x2="560" y2="296" class="solid"></line><line x1="568" y1="296" x2="576" y2="296" class="solid"></line><line x1="584" y1="296" x2="592" y2="296" class="solid"></line><line x1="600" y1="296" x2="608" y2="296" class="solid"></line><line x1="616" y1="296" x2="624" y2="296" class="solid"></line><line x1="296" y1="456" x2="304" y2="456" class="solid"></line><line x1="312" y1="456" x2="320" y2="456" class="solid"></line><line x1="328" y1="456" x2="336" y2="456" class="solid"></line><line x1="344" y1="456" x2="352" y2="456" class="solid"></line><line x1="360" y1="456" x2="368" y2="456" class="solid"></line><line x1="376" y1="456" x2="384" y2="456" class="solid"></line><line x1="392" y1="456" x2="400" y2="456" class="solid"></line><line x1="408" y1="456" x2="416" y2="456" class="solid"></line><line x1="424" y1="456" x2="432" y2="456" class="solid"></line><line x1="440" y1="456" x2="448" y2="456" class="solid"></line><line x1="456" y1="456" x2="464" y2="456" class="solid"></line><line x1="472" y1="456" x2="480" y2="456" class="solid"></line><line x1="488" y1="456" x2="496" y2="456" class="solid"></line><line x1="504" y1="456" x2="512" y2="456" class="solid"></line><line x1="520" y1="456" x2="528" y2="456" class="solid"></line><line x1="536" y1="456" x2="544" y2="456" class="solid"></line><line x1="552" y1="456" x2="560" y2="456" class="solid"></line><line x1="568" y1="456" x2="576" y2="456" class="solid"></line><line x1="584" y1="456" x2="592" y2="456" class="solid"></line><line x1="600" y1="456" x2="608" y2="456" class="solid"></line><line x1="616" y1="456" x2="624" y2="456" class="solid"></line><text x="42" y="60" >pets: Vec&lt;dyn Pet&gt;</text><text x="306" y="60" >data: Cat</text><text x="506" y="156" >Dog</text><text x="554" y="284" >Program text</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="244" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,244 A 4,4 0,0,0 280,248" class="nofill"></path><line x1="280" y1="248" x2="288" y2="248" class="solid"></line></g><g><line x1="468" y1="56" x2="628" y2="56" class="solid"></line><line x1="468" y1="56" x2="468" y2="88" class="solid"></line><line x1="508" y1="56" x2="508" y2="88" class="solid"></line><line x1="548" y1="56" x2="548" y2="88" class="solid"></line><line x1="588" y1="56" x2="588" y2="88" class="solid"></line><line x1="628" y1="56" x2="628" y2="88" class="solid"></line><line x1="468" y1="88" x2="628" y2="88" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="300" y1="72" x2="428" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="364" y1="72" x2="364" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="300" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="248" y2="88" class="solid"></line><path d="M 248,88 A 4,4 0,0,1 252,92" class="nofill"></path><line x1="252" y1="92" x2="252" y2="196" class="solid"></line><path d="M 252,196 A 4,4 0,0,0 256,200" class="nofill"></path><line x1="256" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><polygon points="480,108 484,96 488,108" class="filled"></polygon><line x1="484" y1="108" x2="484" y2="132" class="solid"></line><path d="M 484,132 A 4,4 0,0,0 488,136" class="nofill"></path><line x1="488" y1="136" x2="544" y2="136" class="solid"></line><path d="M 544,136 A 4,4 0,0,1 548,140" class="nofill"></path><line x1="548" y1="140" x2="548" y2="180" class="solid"></line></g><g><polygon points="336,124 340,112 344,124" class="filled"></polygon><line x1="340" y1="124" x2="340" y2="196" class="solid"></line></g><g><line x1="460" y1="168" x2="612" y2="168" class="solid"></line><line x1="460" y1="168" x2="460" y2="216" class="solid"></line><line x1="524" y1="168" x2="524" y2="216" class="solid"></line><line x1="612" y1="168" x2="612" y2="216" class="solid"></line><line x1="460" y1="216" x2="612" y2="216" class="solid"></line></g><g><line x1="308" y1="184" x2="404" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="356" y1="184" x2="356" y2="216" class="solid"></line><line x1="404" y1="184" x2="404" y2="216" class="solid"></line><line x1="308" y1="216" x2="404" y2="216" class="solid"></line></g><g><line x1="324" y1="204" x2="324" y2="404" class="solid"></line><line x1="312" y1="248" x2="324" y2="248" class="solid"></line><line x1="312" y1="296" x2="324" y2="296" class="solid"></line><path d="M 324,404 A 4,4 0,0,0 328,408" class="nofill"></path><line x1="328" y1="408" x2="416" y2="408" class="solid"></line><polygon points="416,404 424,408 416,412" class="filled"></polygon></g><g><line x1="372" y1="204" x2="372" y2="340" class="solid"></line><line x1="372" y1="248" x2="384" y2="248" class="solid"></line><line x1="372" y1="296" x2="384" y2="296" class="solid"></line><path d="M 372,340 A 4,4 0,0,0 376,344" class="nofill"></path><line x1="376" y1="344" x2="416" y2="344" class="solid"></line><polygon points="416,340 424,344 416,348" class="filled"></polygon></g><g><line x1="392" y1="200" x2="448" y2="200" class="solid"></line><polygon points="448,196 456,200 448,204" class="filled"></polygon></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="244" class="broken"></line><line x1="632" y1="248" x2="640" y2="248" class="solid"></line><path d="M 644,244 A 4,4 0,0,1 640,248" class="nofill"></path></g><g><path d="M 280,296 A 4,4 0,0,0 276,300" class="nofill"></path><line x1="276" y1="300" x2="276" y2="452" class="broken"></line><line x1="280" y1="296" x2="288" y2="296" class="solid"></line><path d="M 276,452 A 4,4 0,0,0 280,456" class="nofill"></path><line x1="280" y1="456" x2="288" y2="456" class="solid"></line></g><g><line x1="632" y1="296" x2="640" y2="296" class="solid"></line><path d="M 640,296 A 4,4 0,0,1 644,300" class="nofill"></path><line x1="644" y1="300" x2="644" y2="452" class="broken"></line><line x1="632" y1="456" x2="640" y2="456" class="solid"></line><path d="M 644,452 A 4,4 0,0,1 640,456" class="nofill"></path></g></svg></div>
<details>
This slide should take about 10 minutes. 
<ul>
<li>Types that implement a given trait may be of different sizes. This makes it
impossible to have things like <code>Vec&lt;dyn Pet&gt;</code> in the example above.</li>
<li><code>dyn Pet</code> is a way to tell the compiler about a dynamically sized type that
implements <code>Pet</code>.</li>
<li>In the example, <code>pets</code> is allocated on the stack and the vector data is on the
heap. The two vector elements are <em>fat pointers</em>:
<ul>
<li>A fat pointer is a double-width pointer. It has two components: a pointer to
the actual object and a pointer to the <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> (vtable) for
the <code>Pet</code> implementation of that particular object.</li>
<li>The data for the <code>Dog</code> named Fido is the <code>name</code> and <code>age</code> fields. The <code>Cat</code>
has a <code>lives</code> field.</li>
</ul>
</li>
<li>Compare these outputs in the above example:
<pre><code class="language-rust ignore">println!("{} {}", std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
println!("{} {}", std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
println!("{}", std::mem::size_of::&lt;&amp;dyn Pet&gt;());
println!("{}", std::mem::size_of::&lt;Box&lt;dyn Pet&gt;&gt;());</code></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="smart-pointers-exercise"></div><h1 id="smart-pointers-exercise-exercise-binary-tree"><a class="header" href="#smart-pointers-exercise-exercise-binary-tree">Exercise: Binary Tree</a></h1>
<p>A binary tree is a tree-type data structure where every node has two children
(left and right). We will create a tree where each node stores a value. For a
given node N, all nodes in a N's left subtree contain smaller values, and all
nodes in N's right subtree will contain larger values.</p>
<p>Implement the following types, so that the given tests pass.</p>
<p>Extra Credit: implement an iterator over a binary tree that returns the values
in order.</p>
<pre><code class="language-rust editable ignore">/// A node in the binary tree.
#[derive(Debug)]
struct Node&lt;T: Ord&gt; {
    value: T,
    left: Subtree&lt;T&gt;,
    right: Subtree&lt;T&gt;,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree&lt;T: Ord&gt;(Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree&lt;T: Ord&gt; {
    root: Subtree&lt;T&gt;,
}

impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        Self { root: Subtree::new() }
    }

    fn insert(&amp;mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        self.root.has(value)
    }

    fn len(&amp;self) -&gt; usize {
        self.root.len()
    }
}

// Implement `new`, `insert`, `len`, and `has` for `Subtree`.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &amp;BinaryTree&lt;i32&gt;, exp: &amp;[bool]) {
            let got: Vec&lt;bool&gt; =
                (0..exp.len()).map(|i| tree.has(&amp;(i as i32))).collect();
            assert_eq!(&amp;got, exp);
        }

        check_has(&amp;tree, &amp;[false, false, false, false, false]);
        tree.insert(0);
        check_has(&amp;tree, &amp;[true, false, false, false, false]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(3);
        check_has(&amp;tree, &amp;[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&amp;50));
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="smart-pointers-solution"></div><h1 id="smart-pointers-solution-solution"><a class="header" href="#smart-pointers-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::cmp::Ordering;

/// A node in the binary tree.
#[derive(Debug)]
struct Node&lt;T: Ord&gt; {
    value: T,
    left: Subtree&lt;T&gt;,
    right: Subtree&lt;T&gt;,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree&lt;T: Ord&gt;(Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree&lt;T: Ord&gt; {
    root: Subtree&lt;T&gt;,
}

impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        Self { root: Subtree::new() }
    }

    fn insert(&amp;mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        self.root.has(value)
    }

    fn len(&amp;self) -&gt; usize {
        self.root.len()
    }
}

impl&lt;T: Ord&gt; Subtree&lt;T&gt; {
    fn new() -&gt; Self {
        Self(None)
    }

    fn insert(&amp;mut self, value: T) {
        match &amp;mut self.0 {
            None =&gt; self.0 = Some(Box::new(Node::new(value))),
            Some(n) =&gt; match value.cmp(&amp;n.value) {
                Ordering::Less =&gt; n.left.insert(value),
                Ordering::Equal =&gt; {}
                Ordering::Greater =&gt; n.right.insert(value),
            },
        }
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        match &amp;self.0 {
            None =&gt; false,
            Some(n) =&gt; match value.cmp(&amp;n.value) {
                Ordering::Less =&gt; n.left.has(value),
                Ordering::Equal =&gt; true,
                Ordering::Greater =&gt; n.right.has(value),
            },
        }
    }

    fn len(&amp;self) -&gt; usize {
        match &amp;self.0 {
            None =&gt; 0,
            Some(n) =&gt; 1 + n.left.len() + n.right.len(),
        }
    }
}

impl&lt;T: Ord&gt; Node&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, left: Subtree::new(), right: Subtree::new() }
    }
}

fn main() {
    let mut tree = BinaryTree::new();
    tree.insert("foo");
    assert_eq!(tree.len(), 1);
    tree.insert("bar");
    assert!(tree.has(&amp;"foo"));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &amp;BinaryTree&lt;i32&gt;, exp: &amp;[bool]) {
            let got: Vec&lt;bool&gt; =
                (0..exp.len()).map(|i| tree.has(&amp;(i as i32))).collect();
            assert_eq!(&amp;got, exp);
        }

        check_has(&amp;tree, &amp;[false, false, false, false, false]);
        tree.insert(0);
        check_has(&amp;tree, &amp;[true, false, false, false, false]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(3);
        check_has(&amp;tree, &amp;[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&amp;50));
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-3-afternoon"></div><h1 id="welcome-day-3-afternoon-welcome-back"><a class="header" href="#welcome-day-3-afternoon-welcome-back">Welcome Back</a></h1>
<p>Including 10 minute breaks, this session should take about 1 hour and 55 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Borrowing</td><td>55 minutes</td></tr>
<tr><td>Lifetimes</td><td>50 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="borrowing"></div><h1 id="borrowing-borrowing"><a class="header" href="#borrowing-borrowing">Borrowing</a></h1>
<p>This segment should take about 55 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Borrowing a Value</td><td>10 minutes</td></tr>
<tr><td>Borrow Checking</td><td>10 minutes</td></tr>
<tr><td>Borrow Errors</td><td>3 minutes</td></tr>
<tr><td>Interior Mutability</td><td>10 minutes</td></tr>
<tr><td>Exercise: Health Statistics</td><td>20 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="borrowing-shared"></div><h1 id="borrowing-shared-borrowing-a-value"><a class="header" href="#borrowing-shared-borrowing-a-value">Borrowing a Value</a></h1>
<p>As we saw before, instead of transferring ownership when calling a function, you
can let a function <em>borrow</em> the value:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!("{p1:?} + {p2:?} = {p3:?}");
}</code></pre></pre>
<ul>
<li>The <code>add</code> function <em>borrows</em> two points and returns a new point.</li>
<li>The caller retains ownership of the inputs.</li>
</ul>
<details>
This slide should take about 10 minutes. 
<p>This slide is a review of the material on references from day 1, expanding
slightly to include function arguments and return values.</p>
<h1 id="borrowing-shared-more-to-explore"><a class="header" href="#borrowing-shared-more-to-explore">More to Explore</a></h1>
<p>Notes on stack returns and inlining:</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can
eliminate the copy operation, by inlining the call to add into main. Change
the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=0cb13be1c05d7e3446686ad9947c4671">Playground</a> or look
at the assembly in <a href="https://rust.godbolt.org/">Godbolt</a>. In the "DEBUG"
optimization level, the addresses should change, while they stay the same when
changing to the "RELEASE" setting:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!("&amp;p.0: {:p}", &amp;p.0);
    p
}

pub fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!("&amp;p3.0: {:p}", &amp;p3.0);
    println!("{p1:?} + {p2:?} = {p3:?}");
}</code></pre></pre>
</li>
<li>
<p>The Rust compiler can do automatic inlining, that can be disabled on a
function level with <code>#[inline(never)]</code>.</p>
</li>
<li>
<p>Once disabled, the printed address will change on all optimization levels.
Looking at Godbolt or Playground, one can see that in this case, the return of
the value depends on the ABI, e.g. on amd64 the two i32 that is making up the
point will be returned in 2 registers (eax and edx).</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="borrowing-borrowck"></div><h1 id="borrowing-borrowck-borrow-checking"><a class="header" href="#borrowing-borrowck-borrow-checking">Borrow Checking</a></h1>
<p>Rust's <em>borrow checker</em> puts constraints on the ways you can borrow values. For
a given value, at any time:</p>
<ul>
<li>You can have one or more shared references to the value, <em>or</em></li>
<li>You can have exactly one exclusive reference to the value.</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!("a: {a}");
    println!("b: {b}");
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li>Note that the requirement is that conflicting references not <em>exist</em> at the
same point. It does not matter where the reference is dereferenced.</li>
<li>The above code does not compile because <code>a</code> is borrowed as mutable (through
<code>c</code>) and as immutable (through <code>b</code>) at the same time.</li>
<li>Move the <code>println!</code> statement for <code>b</code> before the scope that introduces <code>c</code> to
make the code compile.</li>
<li>After that change, the compiler realizes that <code>b</code> is only ever used before the
new mutable borrow of <code>a</code> through <code>c</code>. This is a feature of the borrow checker
called "non-lexical lifetimes".</li>
<li>The exclusive reference constraint is quite strong. Rust uses it to ensure
that data races do not occur. Rust also <em>relies</em> on this constraint to
optimize code. For example, a value behind a shared reference can be safely
cached in a register for the lifetime of that reference.</li>
<li>The borrow checker is designed to accommodate many common patterns, such as
taking exclusive references to different fields in a struct at the same time.
But, there are some situations where it doesn't quite "get it" and this often
results in "fighting with the borrow checker."</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="borrowing-examples"></div><h1 id="borrowing-examples-borrow-errors"><a class="header" href="#borrowing-examples-borrow-errors">Borrow Errors</a></h1>
<p>As a concrete example of how these borrowing rules prevent memory errors,
consider the case of modifying a collection while there are references to its
elements:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    let elem = &amp;vec[2];
    vec.push(6);
    println!("{elem}");
}</code></pre></pre>
<p>Similarly, consider the case of iterator invalidation:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    for elem in &amp;vec {
        vec.push(elem * 2);
    }
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<ul>
<li>In both of these cases, modifying the collection by pushing new elements into
it can potentially invalidate existing references to the collection's elements
if the collection has to reallocate.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="borrowing-interior-mutability"></div><h1 id="borrowing-interior-mutability-interior-mutability"><a class="header" href="#borrowing-interior-mutability-interior-mutability">Interior Mutability</a></h1>
<p>In some situations, it's necessary to modify data behind a shared (read-only)
reference. For example, a shared data structure might have an internal cache,
and wish to update that cache from read-only methods.</p>
<p>The "interior mutability" pattern allows exclusive (mutable) access behind a
shared reference. The standard library provides several ways to do this, all
while still ensuring safety, typically by performing a runtime check.</p>
<h2 id="borrowing-interior-mutability-refcell"><a class="header" href="#borrowing-interior-mutability-refcell"><code>RefCell</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::cell::RefCell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = RefCell::new(5);

    {
        let mut cell_ref = cell.borrow_mut();
        *cell_ref = 123;

        // This triggers an error at runtime.
        // let other = cell.borrow();
        // println!("{}", *other);
    }

    println!("{cell:?}");
}</code></pre></pre>
<h2 id="borrowing-interior-mutability-cell"><a class="header" href="#borrowing-interior-mutability-cell"><code>Cell</code></a></h2>
<p><code>Cell</code> wraps a value and allows getting or setting the value, even with a shared
reference to the <code>Cell</code>. However, it does not allow any references to the value.
Since there are no references, borrowing rules cannot be broken.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::cell::Cell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = Cell::new(5);

    cell.set(123);
    println!("{}", cell.get());
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<p>The main thing to take away from this slide is that Rust provides <em>safe</em> ways to
modify data behind a shared reference. There are a variety of ways to ensure
that safety, and <code>RefCell</code> and <code>Cell</code> are two of them.</p>
<ul>
<li>
<p><code>RefCell</code> enforces Rust's usual borrowing rules (either multiple shared
references or a single exclusive reference) with a runtime check. In this
case, all borrows are very short and never overlap, so the checks always
succeed.</p>
<ul>
<li>The extra block in the <code>RefCell</code> example is to end the borrow created by the
call to <code>borrow_mut</code> before we print the cell. Trying to print a borrowed
<code>RefCell</code> just shows the message <code>"{borrowed}"</code>.</li>
</ul>
</li>
<li>
<p><code>Cell</code> is a simpler means to ensure safety: it has a <code>set</code> method that takes
<code>&amp;self</code>. This needs no runtime check, but requires moving values, which can
have its own cost.</p>
</li>
<li>
<p>Both <code>RefCell</code> and <code>Cell</code> are <code>!Sync</code>, which means <code>&amp;RefCell</code> and <code>&amp;Cell</code>
can't be passed between threads. This prevents two threads trying to access
the cell at once.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="borrowing-exercise"></div><h1 id="borrowing-exercise-exercise-health-statistics"><a class="header" href="#borrowing-exercise-exercise-health-statistics">Exercise: Health Statistics</a></h1>
<p>You're working on implementing a health-monitoring system. As part of that, you
need to keep track of users' health statistics.</p>
<p>You'll start with a stubbed function in an <code>impl</code> block as well as a <code>User</code>
struct definition. Your goal is to implement the stubbed out method on the
<code>User</code> <code>struct</code> defined in the <code>impl</code> block.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]


#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        todo!("Update a user's statistics based on measurements from a visit to the doctor")
    }
}

fn main() {
    let bob = User::new(String::from("Bob"), 32, 155.2);
    println!("I'm {} and my age is {}", bob.name, bob.age);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from("Bob"), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, "Bob");
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() &lt; 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="borrowing-solution"></div><h1 id="borrowing-solution-solution"><a class="header" href="#borrowing-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        self.visit_count += 1;
        let bp = measurements.blood_pressure;
        let report = HealthReport {
            patient_name: &amp;self.name,
            visit_count: self.visit_count as u32,
            height_change: measurements.height - self.height,
            blood_pressure_change: match self.last_blood_pressure {
                Some(lbp) =&gt; {
                    Some((bp.0 as i32 - lbp.0 as i32, bp.1 as i32 - lbp.1 as i32))
                }
                None =&gt; None,
            },
        };
        self.height = measurements.height;
        self.last_blood_pressure = Some(bp);
        report
    }
}

fn main() {
    let bob = User::new(String::from("Bob"), 32, 155.2);
    println!("I'm {} and my age is {}", bob.name, bob.age);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from("Bob"), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, "Bob");
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() &lt; 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="lifetimes"></div><h1 id="lifetimes-lifetimes"><a class="header" href="#lifetimes-lifetimes">Lifetimes</a></h1>
<p>This segment should take about 50 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Lifetime Annotations</td><td>10 minutes</td></tr>
<tr><td>Lifetime Elision</td><td>5 minutes</td></tr>
<tr><td>Struct Lifetimes</td><td>5 minutes</td></tr>
<tr><td>Exercise: Protobuf Parsing</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="lifetimes-lifetime-annotations"></div><h1 id="lifetimes-lifetime-annotations-lifetime-annotations"><a class="header" href="#lifetimes-lifetime-annotations-lifetime-annotations">Lifetime Annotations</a></h1>
<p>A reference has a <em>lifetime</em>, which must not "outlive" the value it refers to.
This is verified by the borrow checker.</p>
<p>The lifetime can be implicit - this is what we have seen so far. Lifetimes can
also be explicit: <code>&amp;'a Point</code>, <code>&amp;'document str</code>. Lifetimes start with <code>'</code> and
<code>'a</code> is a typical default name. Read <code>&amp;'a Point</code> as "a borrowed <code>Point</code> which is
valid for at least the lifetime <code>a</code>".</p>
<p>Lifetimes are always inferred by the compiler: you cannot assign a lifetime
yourself. Explicit lifetime annotations create constraints where there is
ambiguity; the compiler verifies that there is a valid solution.</p>
<p>Lifetimes become more complicated when considering passing values to and
returning values from functions.</p>
<!-- The multi-line formatting by rustfmt in left_most is apparently
     intentional: https://github.com/rust-lang/rustfmt/issues/1908 -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn left_most(p1: &amp;Point, p2: &amp;Point) -&gt; &amp;Point {
    if p1.0 &lt; p2.0 {
        p1
    } else {
        p2
    }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3 = left_most(&amp;p1, &amp;p2); // What is the lifetime of p3?
    println!("p3: {p3:?}");
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<p>In this example, the compiler does not know what lifetime to infer for <code>p3</code>.
Looking inside the function body shows that it can only safely assume that
<code>p3</code>'s lifetime is the shorter of <code>p1</code> and <code>p2</code>. But just like types, Rust
requires explicit annotations of lifetimes on function arguments and return
values.</p>
<p>Add <code>'a</code> appropriately to <code>left_most</code>:</p>
<pre><code class="language-rust ignore">fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {</code></pre>
<p>This says, "given p1 and p2 which both outlive <code>'a</code>, the return value lives for
at least <code>'a</code>.</p>
<p>In common cases, lifetimes can be elided, as described on the next slide.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="lifetimes-lifetime-elision"></div><h1 id="lifetimes-lifetime-elision-lifetimes-in-function-calls"><a class="header" href="#lifetimes-lifetime-elision-lifetimes-in-function-calls">Lifetimes in Function Calls</a></h1>
<p>Lifetimes for function arguments and return values must be fully specified, but
Rust allows lifetimes to be elided in most cases with
<a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">a few simple rules</a>.
This is not inference -- it is just a syntactic shorthand.</p>
<ul>
<li>Each argument which does not have a lifetime annotation is given one.</li>
<li>If there is only one argument lifetime, it is given to all un-annotated return
values.</li>
<li>If there are multiple argument lifetimes, but the first one is for <code>self</code>,
that lifetime is given to all un-annotated return values.</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn cab_distance(p1: &amp;Point, p2: &amp;Point) -&gt; i32 {
    (p1.0 - p2.0).abs() + (p1.1 - p2.1).abs()
}

fn nearest&lt;'a&gt;(points: &amp;'a [Point], query: &amp;Point) -&gt; Option&lt;&amp;'a Point&gt; {
    let mut nearest = None;
    for p in points {
        if let Some((_, nearest_dist)) = nearest {
            let dist = cab_distance(p, query);
            if dist &lt; nearest_dist {
                nearest = Some((p, dist));
            }
        } else {
            nearest = Some((p, cab_distance(p, query)));
        };
    }
    nearest.map(|(p, _)| p)
}

fn main() {
    println!(
        "{:?}",
        nearest(
            &amp;[Point(1, 0), Point(1, 0), Point(-1, 0), Point(0, -1),],
            &amp;Point(0, 2)
        )
    );
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>In this example, <code>cab_distance</code> is trivially elided.</p>
<p>The <code>nearest</code> function provides another example of a function with multiple
references in its arguments that requires explicit annotation.</p>
<p>Try adjusting the signature to "lie" about the lifetimes returned:</p>
<pre><code class="language-rust ignore">fn nearest&lt;'a, 'q&gt;(points: &amp;'a [Point], query: &amp;'q Point) -&gt; Option&lt;&amp;'q Point&gt; {</code></pre>
<p>This won't compile, demonstrating that the annotations are checked for validity
by the compiler. Note that this is not the case for raw pointers (unsafe), and
this is a common source of errors with unsafe Rust.</p>
<p>Students may ask when to use lifetimes. Rust borrows <em>always</em> have lifetimes.
Most of the time, elision and type inference mean these don't need to be written
out. In more complicated cases, lifetime annotations can help resolve ambiguity.
Often, especially when prototyping, it's easier to just work with owned data by
cloning values where necessary.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="lifetimes-struct-lifetimes"></div><h1 id="lifetimes-struct-lifetimes-lifetimes-in-data-structures"><a class="header" href="#lifetimes-struct-lifetimes-lifetimes-in-data-structures">Lifetimes in Data Structures</a></h1>
<p>If a data type stores borrowed data, it must be annotated with a lifetime:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!("Bye {text}!");
}

fn main() {
    let text = String::from("The quick brown fox jumps over the lazy dog.");
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!("{fox:?}");
    println!("{dog:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>In the above example, the annotation on <code>Highlight</code> enforces that the data
underlying the contained <code>&amp;str</code> lives at least as long as any instance of
<code>Highlight</code> that uses that data.</li>
<li>If <code>text</code> is consumed before the end of the lifetime of <code>fox</code> (or <code>dog</code>), the
borrow checker throws an error.</li>
<li>Types with borrowed data force users to hold on to the original data. This can
be useful for creating lightweight views, but it generally makes them somewhat
harder to use.</li>
<li>When possible, make data structures own their data directly.</li>
<li>Some structs with multiple references inside can have more than one lifetime
annotation. This can be necessary if there is a need to describe lifetime
relationships between the references themselves, in addition to the lifetime
of the struct itself. Those are very advanced use cases.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="lifetimes-exercise"></div><h1 id="lifetimes-exercise-exercise-protobuf-parsing"><a class="header" href="#lifetimes-exercise-exercise-protobuf-parsing">Exercise: Protobuf Parsing</a></h1>
<p>In this exercise, you will build a parser for the
<a href="https://protobuf.dev/programming-guides/encoding/">protobuf binary encoding</a>.
Don't worry, it's simpler than it seems! This illustrates a common parsing
pattern, passing slices of data. The underlying data itself is never copied.</p>
<p>Fully parsing a protobuf message requires knowing the types of the fields,
indexed by their field numbers. That is typically provided in a <code>proto</code> file. In
this exercise, we'll encode that information into <code>match</code> statements in
functions that get called for each field.</p>
<p>We'll use the following proto:</p>
<pre><code class="language-proto">message PhoneNumber {
  optional string number = 1;
  optional string type = 2;
}

message Person {
  optional string name = 1;
  optional int32 id = 2;
  repeated PhoneNumber phones = 3;
}
</code></pre>
<p>A proto message is encoded as a series of fields, one after the next. Each is
implemented as a "tag" followed by the value. The tag contains a field number
(e.g., <code>2</code> for the <code>id</code> field of a <code>Person</code> message) and a wire type defining
how the payload should be determined from the byte stream.</p>
<p>Integers, including the tag, are represented with a variable-length encoding
called VARINT. Luckily, <code>parse_varint</code> is defined for you below. The given code
also defines callbacks to handle <code>Person</code> and <code>PhoneNumber</code> fields, and to parse
a message into a series of calls to those callbacks.</p>
<p>What remains for you is to implement the <code>parse_field</code> function and the
<code>ProtoMessage</code> trait for <code>Person</code> and <code>PhoneNumber</code>.</p>
<!-- compile_fail because the stubbed out code has type inference errors. -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">/// A wire type as seen on the wire.
enum WireType {
    /// The Varint WireType indicates the value is a single VARINT.
    Varint,
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    /// The I32 WireType indicates that the value is precisely 4 bytes in
    /// little-endian order containing a 32-bit signed integer.
    I32,
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue&lt;'a&gt; {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&amp;'a [u8]),
    I32(i32),
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field&lt;'a&gt; {
    field_num: u64,
    value: FieldValue&lt;'a&gt;,
}

trait ProtoMessage&lt;'a&gt;: Default {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;);
}

impl From&lt;u64&gt; for WireType {
    fn from(value: u64) -&gt; Self {
        match value {
            0 =&gt; WireType::Varint,
            //1 =&gt; WireType::I64,  -- not needed for this exercise
            2 =&gt; WireType::Len,
            5 =&gt; WireType::I32,
            _ =&gt; panic!("Invalid wire type: {value}"),
        }
    }
}

impl&lt;'a&gt; FieldValue&lt;'a&gt; {
    fn as_string(&amp;self) -&gt; &amp;'a str {
        let FieldValue::Len(data) = self else {
            panic!("Expected string to be a `Len` field");
        };
        std::str::from_utf8(data).expect("Invalid string")
    }

    fn as_bytes(&amp;self) -&gt; &amp;'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!("Expected bytes to be a `Len` field");
        };
        data
    }

    fn as_u64(&amp;self) -&gt; u64 {
        let FieldValue::Varint(value) = self else {
            panic!("Expected `u64` to be a `Varint` field");
        };
        *value
    }

    #[allow(dead_code)]
    fn as_i32(&amp;self) -&gt; i32 {
        let FieldValue::I32(value) = self else {
            panic!("Expected `i32` to be an `I32` field");
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &amp;[u8]) -&gt; (u64, &amp;[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!("Not enough bytes for varint");
        };
        if b &amp; 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value &lt;&lt; 7) | (b &amp; 0x7f) as u64;
            }
            return (value, &amp;data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!("Too many bytes for varint");
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -&gt; (u64, WireType) {
    let field_num = tag &gt;&gt; 3;
    let wire_type = WireType::from(tag &amp; 0x7);
    (field_num, wire_type)
}


/// Parse a field, returning the remaining bytes
fn parse_field(data: &amp;[u8]) -&gt; (Field, &amp;[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        _ =&gt; todo!("Based on the wire type, build a Field, consuming as many bytes as necessary.")
    };
    todo!("Return the field, and any un-consumed bytes.")
}

/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message&lt;'a, T: ProtoMessage&lt;'a&gt;&gt;(mut data: &amp;'a [u8]) -&gt; T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}

#[derive(Debug, Default)]
struct PhoneNumber&lt;'a&gt; {
    number: &amp;'a str,
    type_: &amp;'a str,
}

#[derive(Debug, Default)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    id: u64,
    phone: Vec&lt;PhoneNumber&lt;'a&gt;&gt;,
}

// TODO: Implement ProtoMessage for Person and PhoneNumber.

fn main() {
    let person: Person = parse_message(&amp;[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    println!("{:#?}", person);
}</code></pre></pre>
<details>
This slide and its sub-slides should take about 30 minutes. 
<ul>
<li>In this exercise there are various cases where protobuf parsing might fail,
e.g. if you try to parse an <code>i32</code> when there are fewer than 4 bytes left in
the data buffer. In normal Rust code we'd handle this with the <code>Result</code> enum,
but for simplicity in this exercise we panic if any errors are encountered. On
day 4 we'll cover error handling in Rust in more detail.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="lifetimes-solution"></div><h1 id="lifetimes-solution-solution"><a class="header" href="#lifetimes-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// A wire type as seen on the wire.
enum WireType {
    /// The Varint WireType indicates the value is a single VARINT.
    Varint,
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    /// The I32 WireType indicates that the value is precisely 4 bytes in
    /// little-endian order containing a 32-bit signed integer.
    I32,
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue&lt;'a&gt; {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&amp;'a [u8]),
    I32(i32),
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field&lt;'a&gt; {
    field_num: u64,
    value: FieldValue&lt;'a&gt;,
}

trait ProtoMessage&lt;'a&gt;: Default {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;);
}

impl From&lt;u64&gt; for WireType {
    fn from(value: u64) -&gt; Self {
        match value {
            0 =&gt; WireType::Varint,
            //1 =&gt; WireType::I64,  -- not needed for this exercise
            2 =&gt; WireType::Len,
            5 =&gt; WireType::I32,
            _ =&gt; panic!("Invalid wire type: {value}"),
        }
    }
}

impl&lt;'a&gt; FieldValue&lt;'a&gt; {
    fn as_string(&amp;self) -&gt; &amp;'a str {
        let FieldValue::Len(data) = self else {
            panic!("Expected string to be a `Len` field");
        };
        std::str::from_utf8(data).expect("Invalid string")
    }

    fn as_bytes(&amp;self) -&gt; &amp;'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!("Expected bytes to be a `Len` field");
        };
        data
    }

    fn as_u64(&amp;self) -&gt; u64 {
        let FieldValue::Varint(value) = self else {
            panic!("Expected `u64` to be a `Varint` field");
        };
        *value
    }

    #[allow(dead_code)]
    fn as_i32(&amp;self) -&gt; i32 {
        let FieldValue::I32(value) = self else {
            panic!("Expected `i32` to be an `I32` field");
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &amp;[u8]) -&gt; (u64, &amp;[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!("Not enough bytes for varint");
        };
        if b &amp; 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value &lt;&lt; 7) | (b &amp; 0x7f) as u64;
            }
            return (value, &amp;data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!("Too many bytes for varint");
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -&gt; (u64, WireType) {
    let field_num = tag &gt;&gt; 3;
    let wire_type = WireType::from(tag &amp; 0x7);
    (field_num, wire_type)
}

/// Parse a field, returning the remaining bytes
fn parse_field(data: &amp;[u8]) -&gt; (Field, &amp;[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        WireType::Varint =&gt; {
            let (value, remainder) = parse_varint(remainder);
            (FieldValue::Varint(value), remainder)
        }
        WireType::Len =&gt; {
            let (len, remainder) = parse_varint(remainder);
            let len: usize = len.try_into().expect("len not a valid `usize`");
            if remainder.len() &lt; len {
                panic!("Unexpected EOF");
            }
            let (value, remainder) = remainder.split_at(len);
            (FieldValue::Len(value), remainder)
        }
        WireType::I32 =&gt; {
            if remainder.len() &lt; 4 {
                panic!("Unexpected EOF");
            }
            let (value, remainder) = remainder.split_at(4);
            // Unwrap error because `value` is definitely 4 bytes long.
            let value = i32::from_le_bytes(value.try_into().unwrap());
            (FieldValue::I32(value), remainder)
        }
    };
    (Field { field_num, value: fieldvalue }, remainder)
}

/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message&lt;'a, T: ProtoMessage&lt;'a&gt;&gt;(mut data: &amp;'a [u8]) -&gt; T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}

#[derive(Debug, Default)]
struct PhoneNumber&lt;'a&gt; {
    number: &amp;'a str,
    type_: &amp;'a str,
}

#[derive(Debug, Default)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    id: u64,
    phone: Vec&lt;PhoneNumber&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; ProtoMessage&lt;'a&gt; for Person&lt;'a&gt; {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;) {
        match field.field_num {
            1 =&gt; self.name = field.value.as_string(),
            2 =&gt; self.id = field.value.as_u64(),
            3 =&gt; self.phone.push(parse_message(field.value.as_bytes())),
            _ =&gt; {} // skip everything else
        }
    }
}

impl&lt;'a&gt; ProtoMessage&lt;'a&gt; for PhoneNumber&lt;'a&gt; {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;) {
        match field.field_num {
            1 =&gt; self.number = field.value.as_string(),
            2 =&gt; self.type_ = field.value.as_string(),
            _ =&gt; {} // skip everything else
        }
    }
}

fn main() {
    let person: Person = parse_message(&amp;[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    println!("{:#?}", person);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-4"></div><h1 id="welcome-day-4-welcome-to-day-4"><a class="header" href="#welcome-day-4-welcome-to-day-4">Welcome to Day 4</a></h1>
<p>Today we will cover topics relating to building large-scale software in Rust:</p>
<ul>
<li>Iterators: a deep dive on the <code>Iterator</code> trait.</li>
<li>Modules and visibility.</li>
<li>Testing.</li>
<li>Error handling: panics, <code>Result</code>, and the try operator <code>?</code>.</li>
<li>Unsafe Rust: the escape hatch when you can't express yourself in safe Rust.</li>
</ul>
<h2 id="welcome-day-4-schedule"><a class="header" href="#welcome-day-4-schedule">Schedule</a></h2>
<p>Including 10 minute breaks, this session should take about 2 hours and 40 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Welcome</td><td>3 minutes</td></tr>
<tr><td>Iterators</td><td>45 minutes</td></tr>
<tr><td>Modules</td><td>40 minutes</td></tr>
<tr><td>Testing</td><td>45 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="iterators"></div><h1 id="iterators-iterators"><a class="header" href="#iterators-iterators">Iterators</a></h1>
<p>This segment should take about 45 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Iterator</td><td>5 minutes</td></tr>
<tr><td>IntoIterator</td><td>5 minutes</td></tr>
<tr><td>FromIterator</td><td>5 minutes</td></tr>
<tr><td>Exercise: Iterator Method Chaining</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="iterators-iterator"></div><h1 id="iterators-iterator-iterator"><a class="header" href="#iterators-iterator-iterator"><code>Iterator</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait supports iterating over values in a collection. It
requires a <code>next</code> method and provides lots of methods. Many standard library
types implement <code>Iterator</code>, and you can implement it yourself, too:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!("fib({i}): {n}");
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>The <code>Iterator</code> trait implements many common functional programming operations
over collections (e.g. <code>map</code>, <code>filter</code>, <code>reduce</code>, etc). This is the trait
where you can find all the documentation about them. In Rust these functions
should produce the code as efficient as equivalent imperative implementations.</p>
</li>
<li>
<p><code>IntoIterator</code> is the trait that makes for loops work. It is implemented by
collection types such as <code>Vec&lt;T&gt;</code> and references to them such as <code>&amp;Vec&lt;T&gt;</code> and
<code>&amp;[T]</code>. Ranges also implement it. This is why you can iterate over a vector
with <code>for i in some_vec { .. }</code> but <code>some_vec.next()</code> doesn't exist.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="iterators-intoiterator"></div><h1 id="iterators-intoiterator-intoiterator"><a class="header" href="#iterators-intoiterator-intoiterator"><code>IntoIterator</code></a></h1>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an
iterator. The related trait
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
defines how to create an iterator for a type. It is used automatically by the
<code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Grid {
    x_coords: Vec&lt;u32&gt;,
    y_coords: Vec&lt;u32&gt;,
}

impl IntoIterator for Grid {
    type Item = (u32, u32);
    type IntoIter = GridIter;
    fn into_iter(self) -&gt; GridIter {
        GridIter { grid: self, i: 0, j: 0 }
    }
}

struct GridIter {
    grid: Grid,
    i: usize,
    j: usize,
}

impl Iterator for GridIter {
    type Item = (u32, u32);

    fn next(&amp;mut self) -&gt; Option&lt;(u32, u32)&gt; {
        if self.i &gt;= self.grid.x_coords.len() {
            self.i = 0;
            self.j += 1;
            if self.j &gt;= self.grid.y_coords.len() {
                return None;
            }
        }
        let res = Some((self.grid.x_coords[self.i], self.grid.y_coords[self.j]));
        self.i += 1;
        res
    }
}

fn main() {
    let grid = Grid { x_coords: vec![3, 5, 7, 9], y_coords: vec![10, 20, 30, 40] };
    for (x, y) in grid {
        println!("point = {x}, {y}");
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>Click through to the docs for <code>IntoIterator</code>. Every implementation of
<code>IntoIterator</code> must declare two types:</p>
<ul>
<li><code>Item</code>: the type to iterate over, such as <code>i8</code>,</li>
<li><code>IntoIter</code>: the <code>Iterator</code> type returned by the <code>into_iter</code> method.</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same
<code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>The example iterates over all combinations of x and y coordinates.</p>
<p>Try iterating over the grid twice in <code>main</code>. Why does this fail? Note that
<code>IntoIterator::into_iter</code> takes ownership of <code>self</code>.</p>
<p>Fix this issue by implementing <code>IntoIterator</code> for <code>&amp;Grid</code> and storing a
reference to the <code>Grid</code> in <code>GridIter</code>.</p>
<p>The same problem can occur for standard library types: <code>for e in some_vector</code>
will take ownership of <code>some_vector</code> and iterate over owned elements from that
vector. Use <code>for e in &amp;some_vector</code> instead, to iterate over references to
elements of <code>some_vector</code>.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="iterators-fromiterator"></div><h1 id="iterators-fromiterator-fromiterator"><a class="header" href="#iterators-fromiterator-fromiterator">FromIterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> lets you build a collection from an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes.into_iter().map(|p| p * p).collect::&lt;Vec&lt;_&gt;&gt;();
    println!("prime_squares: {prime_squares:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p><code>Iterator</code> implements</p>
<pre><code class="language-rust ignore">fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;,
    Self: Sized</code></pre>
<p>There are two ways to specify <code>B</code> for this method:</p>
<ul>
<li>With the "turbofish": <code>some_iterator.collect::&lt;COLLECTION_TYPE&gt;()</code>, as shown.
The <code>_</code> shorthand used here lets Rust infer the type of the <code>Vec</code> elements.</li>
<li>With type inference: <code>let prime_squares: Vec&lt;_&gt; = some_iterator.collect()</code>.
Rewrite the example to use this form.</li>
</ul>
<p>There are basic implementations of <code>FromIterator</code> for <code>Vec</code>, <code>HashMap</code>, etc.
There are also more specialized implementations which let you do cool things
like convert an <code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> into a <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="iterators-exercise"></div><h1 id="iterators-exercise-exercise-iterator-method-chaining"><a class="header" href="#iterators-exercise-exercise-iterator-method-chaining">Exercise: Iterator Method Chaining</a></h1>
<p>In this exercise, you will need to find and use some of the provided methods in
the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait to implement a complex calculation.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests
pass. Use an iterator expression and <code>collect</code> the result to construct the
return value.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences&lt;N&gt;(offset: usize, values: Vec&lt;N&gt;) -&gt; Vec&lt;N&gt;
where
    N: Copy + std::ops::Sub&lt;Output = N&gt;,
{
    unimplemented!()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_custom_type() {
    assert_eq!(
        offset_differences(1, vec![1.0, 11.0, 5.0, 0.0]),
        vec![10.0, -6.0, -5.0, 1.0]
    );
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="iterators-solution"></div><h1 id="iterators-solution-solution"><a class="header" href="#iterators-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences&lt;N&gt;(offset: usize, values: Vec&lt;N&gt;) -&gt; Vec&lt;N&gt;
where
    N: Copy + std::ops::Sub&lt;Output = N&gt;,
{
    let a = (&amp;values).into_iter();
    let b = (&amp;values).into_iter().cycle().skip(offset);
    a.zip(b).map(|(a, b)| *b - *a).collect()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_custom_type() {
    assert_eq!(
        offset_differences(1, vec![1.0, 11.0, 5.0, 0.0]),
        vec![10.0, -6.0, -5.0, 1.0]
    );
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="modules"></div><h1 id="modules-modules"><a class="header" href="#modules-modules">Modules</a></h1>
<p>This segment should take about 40 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Modules</td><td>3 minutes</td></tr>
<tr><td>Filesystem Hierarchy</td><td>5 minutes</td></tr>
<tr><td>Visibility</td><td>5 minutes</td></tr>
<tr><td>use, super, self</td><td>10 minutes</td></tr>
<tr><td>Exercise: Modules for a GUI Library</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="modules-modules"></div><h1 id="modules-modules-modules"><a class="header" href="#modules-modules-modules">Modules</a></h1>
<p>We have seen how <code>impl</code> blocks let us namespace functions to a type.</p>
<p>Similarly, <code>mod</code> lets us namespace types and functions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod foo {
    pub fn do_something() {
        println!("In the foo module");
    }
}

mod bar {
    pub fn do_something() {
        println!("In the bar module");
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<ul>
<li>Packages provide functionality and include a <code>Cargo.toml</code> file that describes
how to build a bundle of 1+ crates.</li>
<li>Crates are a tree of modules, where a binary crate creates an executable and a
library crate compiles to a library.</li>
<li>Modules define organization, scope, and are the focus of this section.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="modules-filesystem"></div><h1 id="modules-filesystem-filesystem-hierarchy"><a class="header" href="#modules-filesystem-filesystem-hierarchy">Filesystem Hierarchy</a></h1>
<p>Omitting the module content will tell Rust to look for it in another file:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">mod garden;</code></pre></pre>
<p>This tells rust that the <code>garden</code> module content is found at <code>src/garden.rs</code>.
Similarly, a <code>garden::vegetables</code> module can be found at
<code>src/garden/vegetables.rs</code>.</p>
<p>The <code>crate</code> root is in:</p>
<ul>
<li><code>src/lib.rs</code> (for a library crate)</li>
<li><code>src/main.rs</code> (for a binary crate)</li>
</ul>
<p>Modules defined in files can be documented, too, using "inner doc comments".
These document the item that contains them -- in this case, a module.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use garden::Garden;
pub use seeds::SeedPacket;

/// Sow the given seed packets.
pub fn sow(seeds: Vec&lt;SeedPacket&gt;) {
    todo!()
}

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &amp;mut Garden) {
    todo!()
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Before Rust 2018, modules needed to be located at <code>module/mod.rs</code> instead of
<code>module.rs</code>, and this is still a working alternative for editions after 2018.</p>
</li>
<li>
<p>The main reason to introduce <code>filename.rs</code> as alternative to <code>filename/mod.rs</code>
was because many files named <code>mod.rs</code> can be hard to distinguish in IDEs.</p>
</li>
<li>
<p>Deeper nesting can use folders, even if the main module is a file:</p>
<pre><code class="language-ignore">src/
‚îú‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ top_module.rs
‚îî‚îÄ‚îÄ top_module/
    ‚îî‚îÄ‚îÄ sub_module.rs
</code></pre>
</li>
<li>
<p>The place rust will look for modules can be changed with a compiler directive:</p>
<pre><code class="language-rust ignore">#[path = "some/path.rs"]
mod some_module;</code></pre>
<p>This is useful, for example, if you would like to place tests for a module in
a file named <code>some_module_test.rs</code>, similar to the convention in Go.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="modules-visibility"></div><h1 id="modules-visibility-visibility"><a class="header" href="#modules-visibility-visibility">Visibility</a></h1>
<p>Modules are a privacy boundary:</p>
<ul>
<li>Module items are private by default (hides implementation details).</li>
<li>Parent and sibling items are always visible.</li>
<li>In other words, if an item is visible in module <code>foo</code>, it's visible in all the
descendants of <code>foo</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod outer {
    fn private() {
        println!("outer::private");
    }

    pub fn public() {
        println!("outer::public");
    }

    mod inner {
        fn private() {
            println!("outer::inner::private");
        }

        pub fn public() {
            println!("outer::inner::public");
            super::private();
        }
    }
}

fn main() {
    outer::public();
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>Use the <code>pub</code> keyword to make modules public.</li>
</ul>
<p>Additionally, there are advanced <code>pub(...)</code> specifiers to restrict the scope of
public visibility.</p>
<ul>
<li>See the
<a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">Rust Reference</a>.</li>
<li>Configuring <code>pub(crate)</code> visibility is a common pattern.</li>
<li>Less commonly, you can give visibility to a specific path.</li>
<li>In any case, visibility must be granted to an ancestor module (and all of its
descendants).</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="modules-paths"></div><h1 id="modules-paths-use-super-self"><a class="header" href="#modules-paths-use-super-self">use, super, self</a></h1>
<p>A module can bring symbols from another module into scope with <code>use</code>. You will
typically see something like this at the top of each module:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashSet;
use std::process::abort;</code></pre></pre>
<h2 id="modules-paths-paths"><a class="header" href="#modules-paths-paths">Paths</a></h2>
<p>Paths are resolved as follows:</p>
<ol>
<li>
<p>As a relative path:</p>
<ul>
<li><code>foo</code> or <code>self::foo</code> refers to <code>foo</code> in the current module,</li>
<li><code>super::foo</code> refers to <code>foo</code> in the parent module.</li>
</ul>
</li>
<li>
<p>As an absolute path:</p>
<ul>
<li><code>crate::foo</code> refers to <code>foo</code> in the root of the current crate,</li>
<li><code>bar::foo</code> refers to <code>foo</code> in the <code>bar</code> crate.</li>
</ul>
</li>
</ol>
<details>
This slide should take about 8 minutes. 
<ul>
<li>
<p>It is common to "re-export" symbols at a shorter path. For example, the
top-level <code>lib.rs</code> in a crate might have</p>
<pre><code class="language-rust ignore">mod storage;

pub use storage::disk::DiskStorage;
pub use storage::network::NetworkStorage;</code></pre>
<p>making <code>DiskStorage</code> and <code>NetworkStorage</code> available to other crates with a
convenient, short path.</p>
</li>
<li>
<p>For the most part, only items that appear in a module need to be <code>use</code>'d.
However, a trait must be in scope to call any methods on that trait, even if a
type implementing that trait is already in scope. For example, to use the
<code>read_to_string</code> method on a type implementing the <code>Read</code> trait, you need to
<code>use std::io::Read</code>.</p>
</li>
<li>
<p>The <code>use</code> statement can have a wildcard: <code>use std::io::*</code>. This is discouraged
because it is not clear which items are imported, and those might change over
time.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="modules-exercise"></div><h1 id="modules-exercise-exercise-modules-for-a-gui-library"><a class="header" href="#modules-exercise-exercise-modules-for-a-gui-library">Exercise: Modules for a GUI Library</a></h1>
<p>In this exercise, you will reorganize a small GUI Library implementation. This
library defines a <code>Widget</code> trait and a few implementations of that trait, as
well as a <code>main</code> function.</p>
<p>It is typical to put each type or set of closely-related types into its own
module, so each widget type should get its own module.</p>
<h2 id="modules-exercise-cargo-setup"><a class="header" href="#modules-exercise-cargo-setup">Cargo Setup</a></h2>
<p>The Rust playground only supports one file, so you will need to make a Cargo
project on your local filesystem:</p>
<pre><code class="language-shell">cargo init gui-modules
cd gui-modules
cargo run
</code></pre>
<p>Edit the resulting <code>src/main.rs</code> to add <code>mod</code> statements, and add additional
files in the <code>src</code> directory.</p>
<h2 id="modules-exercise-source"><a class="header" href="#modules-exercise-source">Source</a></h2>
<p>Here's the single-module implementation of the GUI library:</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!("{buffer}");
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label { label: label.to_owned() }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button { label: Label::new(label) }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: Change draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use the
        // ?-operator here instead of .unwrap().
        writeln!(buffer, "+-{:-&lt;inner_width$}-+", "").unwrap();
        writeln!(buffer, "| {:^inner_width$} |", &amp;self.title).unwrap();
        writeln!(buffer, "+={:=&lt;inner_width$}=+", "").unwrap();
        for line in inner.lines() {
            writeln!(buffer, "| {:inner_width$} |", line).unwrap();
        }
        writeln!(buffer, "+-{:-&lt;inner_width$}-+", "").unwrap();
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        self.label.width() + 8 // add a bit of padding
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, "+{:-&lt;width$}+", "").unwrap();
        for line in label.lines() {
            writeln!(buffer, "|{:^width$}|", &amp;line).unwrap();
        }
        writeln!(buffer, "+{:-&lt;width$}+", "").unwrap();
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        writeln!(buffer, "{}", &amp;self.label).unwrap();
    }
}

fn main() {
    let mut window = Window::new("Rust GUI Demo 1.23");
    window.add_widget(Box::new(Label::new("This is a small text GUI demo.")));
    window.add_widget(Box::new(Button::new("Click me!")));
    window.draw();
}</code></pre></pre>
<details>
This slide and its sub-slides should take about 15 minutes. 
<p>Encourage students to divide the code in a way that feels natural for them, and
get accustomed to the required <code>mod</code>, <code>use</code>, and <code>pub</code> declarations. Afterward,
discuss what organizations are most idiomatic.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="modules-solution"></div><h1 id="modules-solution-solution"><a class="header" href="#modules-solution-solution">Solution</a></h1>
<!--
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
-->
<pre><code class="language-ignore">src
‚îú‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ widgets
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ button.rs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ label.rs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ window.rs
‚îî‚îÄ‚îÄ widgets.rs
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets.rs ----
mod button;
mod label;
mod window;

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!("{buffer}");
    }
}

pub use button::Button;
pub use label::Label;
pub use window::Window;</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/label.rs ----
use super::Widget;

pub struct Label {
    label: String,
}

impl Label {
    pub fn new(label: &amp;str) -&gt; Label {
        Label { label: label.to_owned() }
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Label-width
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    // ANCHOR: Label-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Label-draw_into
        writeln!(buffer, "{}", &amp;self.label).unwrap();
    }
}</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/button.rs ----
use super::{Label, Widget};

pub struct Button {
    label: Label,
}

impl Button {
    pub fn new(label: &amp;str) -&gt; Button {
        Button { label: Label::new(label) }
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Button-width
        self.label.width() + 8 // add a bit of padding
    }

    // ANCHOR: Button-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Button-draw_into
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, "+{:-&lt;width$}+", "").unwrap();
        for line in label.lines() {
            writeln!(buffer, "|{:^width$}|", &amp;line).unwrap();
        }
        writeln!(buffer, "+{:-&lt;width$}+", "").unwrap();
    }
}</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/window.rs ----
use super::Widget;

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    pub fn new(title: &amp;str) -&gt; Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    pub fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Window-width
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    // ANCHOR: Window-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Window-draw_into
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, "+-{:-&lt;inner_width$}-+", "").unwrap();
        writeln!(buffer, "| {:^inner_width$} |", &amp;self.title).unwrap();
        writeln!(buffer, "+={:=&lt;inner_width$}=+", "").unwrap();
        for line in inner.lines() {
            writeln!(buffer, "| {:inner_width$} |", line).unwrap();
        }
        writeln!(buffer, "+-{:-&lt;inner_width$}-+", "").unwrap();
    }
}</code></pre>
<pre><code class="language-rust ignore">// ---- src/main.rs ----
mod widgets;

use widgets::Widget;

fn main() {
    let mut window = widgets::Window::new("Rust GUI Demo 1.23");
    window
        .add_widget(Box::new(widgets::Label::new("This is a small text GUI demo.")));
    window.add_widget(Box::new(widgets::Button::new("Click me!")));
    window.draw();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="testing"></div><h1 id="testing-testing"><a class="header" href="#testing-testing">Testing</a></h1>
<p>This segment should take about 45 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Test Modules</td><td>5 minutes</td></tr>
<tr><td>Other Types of Tests</td><td>5 minutes</td></tr>
<tr><td>Compiler Lints and Clippy</td><td>3 minutes</td></tr>
<tr><td>Exercise: Luhn Algorithm</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="testing-unit-tests"></div><h1 id="testing-unit-tests-unit-tests"><a class="header" href="#testing-unit-tests-unit-tests">Unit Tests</a></h1>
<p>Rust and Cargo come with a simple unit test framework:</p>
<ul>
<li>
<p>Unit tests are supported throughout your code.</p>
</li>
<li>
<p>Integration tests are supported via the <code>tests/</code> directory.</p>
</li>
</ul>
<p>Tests are marked with <code>#[test]</code>. Unit tests are often put in a nested <code>tests</code>
module, using <code>#[cfg(test)]</code> to conditionally compile them only when building
tests.</p>
<pre><code class="language-rust editable ignore">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty() {
        assert_eq!(first_word(""), "");
    }

    #[test]
    fn test_single_word() {
        assert_eq!(first_word("Hello"), "Hello");
    }

    #[test]
    fn test_multiple_words() {
        assert_eq!(first_word("Hello World"), "Hello");
    }
}</code></pre>
<ul>
<li>This lets you unit test private helpers.</li>
<li>The <code>#[cfg(test)]</code> attribute is only active when you run <code>cargo test</code>.</li>
</ul>
<details>
This slide should take about 5 minutes. 
<p>Run the tests in the playground in order to show their results.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="testing-other"></div><h1 id="testing-other-other-types-of-tests"><a class="header" href="#testing-other-other-types-of-tests">Other Types of Tests</a></h1>
<h2 id="testing-other-integration-tests"><a class="header" href="#testing-other-integration-tests">Integration Tests</a></h2>
<p>If you want to test your library as a client, use an integration test.</p>
<p>Create a <code>.rs</code> file under <code>tests/</code>:</p>
<pre><code class="language-rust ignore">// tests/my_library.rs
use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}</code></pre>
<p>These tests only have access to the public API of your crate.</p>
<h2 id="testing-other-documentation-tests"><a class="header" href="#testing-other-documentation-tests">Documentation Tests</a></h2>
<p>Rust has built-in support for documentation tests:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// # use playground::shorten_string;
/// assert_eq!(shorten_string("Hello World", 5), "Hello");
/// assert_eq!(shorten_string("Hello World", 20), "Hello World");
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Code blocks in <code>///</code> comments are automatically seen as Rust code.</li>
<li>The code will be compiled and executed as part of <code>cargo test</code>.</li>
<li>Adding <code>#</code> in the code will hide it from the docs, but will still compile/run
it.</li>
<li>Test the above code on the
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="testing-lints"></div><h1 id="testing-lints-compiler-lints-and-clippy"><a class="header" href="#testing-lints-compiler-lints-and-clippy">Compiler Lints and Clippy</a></h1>
<p>The Rust compiler produces fantastic error messages, as well as helpful built-in
lints. <a href="https://doc.rust-lang.org/clippy/">Clippy</a> provides even more lints,
organized into groups that can be enabled per-project.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">#[deny(clippy::cast_possible_truncation)]
fn main() {
    let x = 3;
    while (x &lt; 70000) {
        x *= 2;
    }
    println!("X probably fits in a u16, right? {}", x as u16);
}</code></pre></pre>
<details>
This slide should take about 3 minutes. 
<p>Run the code sample and examine the error message. There are also lints visible
here, but those will not be shown once the code compiles. Switch to the
Playground site to show those lints.</p>
<p>After resolving the lints, run <code>clippy</code> on the playground site to show clippy
warnings. Clippy has extensive documentation of its lints, and adds new lints
(including default-deny lints) all the time.</p>
<p>Note that errors or warnings with <code>help: ...</code> can be fixed with <code>cargo fix</code> or
via your editor.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="testing-exercise"></div><h1 id="testing-exercise-exercise-luhn-algorithm"><a class="header" href="#testing-exercise-exercise-luhn-algorithm">Exercise: Luhn Algorithm</a></h1>
<h1 id="testing-exercise-luhn-algorithm"><a class="header" href="#testing-exercise-luhn-algorithm">Luhn Algorithm</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a> is used to
validate credit card numbers. The algorithm takes a string as input and does the
following to validate the credit card number:</p>
<ul>
<li>
<p>Ignore all spaces. Reject numbers with fewer than two digits.</p>
</li>
<li>
<p>Moving from <strong>right to left</strong>, double every second digit: for the number
<code>1234</code>, we double <code>3</code> and <code>1</code>. For the number <code>98765</code>, we double <code>6</code> and <code>8</code>.</p>
</li>
<li>
<p>After doubling a digit, sum the digits if the result is greater than 9. So
doubling <code>7</code> becomes <code>14</code> which becomes <code>1 + 4 = 5</code>.</p>
</li>
<li>
<p>Sum all the undoubled and doubled digits.</p>
</li>
<li>
<p>The credit card number is valid if the sum ends with <code>0</code>.</p>
</li>
</ul>
<p>The provided code provides a buggy implementation of the luhn algorithm, along
with two basic unit tests that confirm that most of the algorithm is implemented
correctly.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and write additional tests
to uncover bugs in the provided implementation, fixing any bugs you find.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn("4263 9826 4026 9299"));
        assert!(luhn("4539 3195 0343 6467"));
        assert!(luhn("7992 7398 713"));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn("4223 9826 4026 9299"));
        assert!(!luhn("4539 3195 0343 6476"));
        assert!(!luhn("8273 1232 7352 0569"));
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="testing-solution"></div><h1 id="testing-solution-solution"><a class="header" href="#testing-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">// This is the buggy version that appears in the problem.
#[cfg(never)]
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}

// This is the solution and passes all of the tests below.
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;
    let mut digits = 0;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            digits += 1;
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else if c.is_whitespace() {
            continue;
        } else {
            return false;
        }
    }

    digits &gt;= 2 &amp;&amp; sum % 10 == 0
}

fn main() {
    let cc_number = "1234 5678 1234 5670";
    println!(
        "Is {cc_number} a valid credit card number? {}",
        if luhn(cc_number) { "yes" } else { "no" }
    );
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn("4263 9826 4026 9299"));
        assert!(luhn("4539 3195 0343 6467"));
        assert!(luhn("7992 7398 713"));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn("4223 9826 4026 9299"));
        assert!(!luhn("4539 3195 0343 6476"));
        assert!(!luhn("8273 1232 7352 0569"));
    }

    #[test]
    fn test_non_digit_cc_number() {
        assert!(!luhn("foo"));
        assert!(!luhn("foo 0 0"));
    }

    #[test]
    fn test_empty_cc_number() {
        assert!(!luhn(""));
        assert!(!luhn(" "));
        assert!(!luhn("  "));
        assert!(!luhn("    "));
    }

    #[test]
    fn test_single_digit_cc_number() {
        assert!(!luhn("0"));
    }

    #[test]
    fn test_two_digit_cc_number() {
        assert!(luhn(" 0 0 "));
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="welcome-day-4-afternoon"></div><h1 id="welcome-day-4-afternoon-welcome-back"><a class="header" href="#welcome-day-4-afternoon-welcome-back">Welcome Back</a></h1>
<p>Including 10 minute breaks, this session should take about 2 hours and 15 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Error Handling</td><td>1 hour</td></tr>
<tr><td>Unsafe Rust</td><td>1 hour and 5 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="error-handling"></div><h1 id="error-handling-error-handling"><a class="header" href="#error-handling-error-handling">Error Handling</a></h1>
<p>This segment should take about 1 hour. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Panics</td><td>3 minutes</td></tr>
<tr><td>Result</td><td>5 minutes</td></tr>
<tr><td>Try Operator</td><td>5 minutes</td></tr>
<tr><td>Try Conversions</td><td>5 minutes</td></tr>
<tr><td>Error Trait</td><td>5 minutes</td></tr>
<tr><td>thiserror and anyhow</td><td>5 minutes</td></tr>
<tr><td>Exercise: Rewriting with Result</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="error-handling-panics"></div><h1 id="error-handling-panics-panics"><a class="header" href="#error-handling-panics-panics">Panics</a></h1>
<p>Rust handles fatal errors with a "panic".</p>
<p>Rust will trigger a panic if a fatal error happens at runtime:</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn main() {
    let v = vec![10, 20, 30];
    println!("v[100]: {}", v[100]);
}</code></pre></pre>
<ul>
<li>Panics are for unrecoverable and unexpected errors.
<ul>
<li>Panics are symptoms of bugs in the program.</li>
<li>Runtime failures like failed bounds checks can panic</li>
<li>Assertions (such as <code>assert!</code>) panic on failure</li>
<li>Purpose-specific panics can use the <code>panic!</code> macro.</li>
</ul>
</li>
<li>A panic will "unwind" the stack, dropping values just as if the functions had
returned.</li>
<li>Use non-panicking APIs (such as <code>Vec::get</code>) if crashing is not acceptable.</li>
</ul>
<details>
This slide should take about 3 minutes. 
<p>By default, a panic will cause the stack to unwind. The unwinding can be caught:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| "No problem here!");
    println!("{result:?}");

    let result = panic::catch_unwind(|| {
        panic!("oh no!");
    });
    println!("{result:?}");
}</code></pre></pre>
<ul>
<li>Catching is unusual; do not attempt to implement exceptions with
<code>catch_unwind</code>!</li>
<li>This can be useful in servers which should keep running even if a single
request crashes.</li>
<li>This does not work if <code>panic = 'abort'</code> is set in your <code>Cargo.toml</code>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="error-handling-result"></div><h1 id="error-handling-result-result"><a class="header" href="#error-handling-result-result"><code>Result</code></a></h1>
<p>Our primary mechanism for error handling in Rust is the <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> enum, which
we briefly saw when discussing standard library types.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result&lt;File, std::io::Error&gt; = File::open("diary.txt");
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&amp;mut contents) {
                println!("Dear diary: {contents} ({bytes} bytes)");
            } else {
                println!("Could not read file content");
            }
        }
        Err(err) =&gt; {
            println!("The diary could not be opened: {err}");
        }
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p><code>Result</code> has two variants: <code>Ok</code> which contains the success value, and <code>Err</code>
which contains an error value of some kind.</p>
</li>
<li>
<p>Whether or not a function can produce an error is encoded in the function's
type signature by having the function return a <code>Result</code> value.</p>
</li>
<li>
<p>Like with <code>Option</code>, there is no way to forget to handle an error: You cannot
access either the success value or the error value without first pattern
matching on the <code>Result</code> to check which variant you have. Methods like
<code>unwrap</code> make it easier to write quick-and-dirty code that doesn't do robust
error handling, but means that you can always see in your source code where
proper error handling is being skipped.</p>
</li>
</ul>
<h1 id="error-handling-result-more-to-explore"><a class="header" href="#error-handling-result-more-to-explore">More to Explore</a></h1>
<p>It may be helpful to compare error handling in Rust to error handling
conventions that students may be familiar with from other programming languages.</p>
<h2 id="error-handling-result-exceptions"><a class="header" href="#error-handling-result-exceptions">Exceptions</a></h2>
<ul>
<li>
<p>Many languages use exceptions, e.g. C++, Java, Python.</p>
</li>
<li>
<p>In most languages with exceptions, whether or not a function can throw an
exception is not visible as part of its type signature. This generally means
that you can't tell when calling a function if it may throw an exception or
not.</p>
</li>
<li>
<p>Exceptions generally unwind the call stack, propagating upward until a <code>try</code>
block is reached. An error originating deep in the call stack may impact an
unrelated function further up.</p>
</li>
</ul>
<h2 id="error-handling-result-error-numbers"><a class="header" href="#error-handling-result-error-numbers">Error Numbers</a></h2>
<ul>
<li>
<p>Some languages have functions return an error number (or some other error
value) separately from the successful return value of the function. Examples
include C and Go.</p>
</li>
<li>
<p>Depending on the language it may be possible to forget to check the error
value, in which case you may be accessing an uninitialized or otherwise
invalid success value.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="error-handling-try"></div><h1 id="error-handling-try-try-operator"><a class="header" href="#error-handling-try-try-operator">Try Operator</a></h1>
<p>Runtime errors like connection-refused or file-not-found are handled with the
<code>Result</code> type, but matching this type on every call can be cumbersome. The
try-operator <code>?</code> is used to return errors to the caller. It lets you turn the
common</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}</code></pre>
<p>into the much simpler</p>
<pre><code class="language-rust ignore">some_expression?</code></pre>
<p>We can use this to simplify our error handling code:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::Read;
use std::{fs, io};

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    //fs::write("config.dat", "alice").unwrap();
    let username = read_username("config.dat");
    println!("username or error: {username:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>Simplify the <code>read_username</code> function to use <code>?</code>.</p>
<p>Key points:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty
file, file with username.</li>
<li>Note that <code>main</code> can return a <code>Result&lt;(), E&gt;</code> as long as it implements
<code>std::process::Termination</code>. In practice, this means that <code>E</code> implements
<code>Debug</code>. The executable will print the <code>Err</code> variant and return a nonzero exit
status on error.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="error-handling-try-conversions"></div><h1 id="error-handling-try-conversions-try-conversions"><a class="header" href="#error-handling-try-conversions-try-conversions">Try Conversions</a></h1>
<p>The effective expansion of <code>?</code> is a little more complicated than previously
indicated:</p>
<pre><code class="language-rust ignore">expression?</code></pre>
<p>works the same as</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}</code></pre>
<p>The <code>From::from</code> call here means we attempt to convert the error type to the
type returned by the function. This makes it easy to encapsulate errors into
higher-level errors.</p>
<h2 id="error-handling-try-conversions-example"><a class="header" href="#error-handling-try-conversions-example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::fs::File;
use std::io::{self, Read};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, "IO error: {e}"),
            Self::EmptyUsername(path) =&gt; write!(f, "Found no username in {path}"),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; Self {
        Self::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //std::fs::write("config.dat", "").unwrap();
    let username = read_username("config.dat");
    println!("username or error: {username:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>The <code>?</code> operator must return a value compatible with the return type of the
function. For <code>Result</code>, it means that the error types have to be compatible. A
function that returns <code>Result&lt;T, ErrorOuter&gt;</code> can only use <code>?</code> on a value of
type <code>Result&lt;U, ErrorInner&gt;</code> if <code>ErrorOuter</code> and <code>ErrorInner</code> are the same type
or if <code>ErrorOuter</code> implements <code>From&lt;ErrorInner&gt;</code>.</p>
<p>A common alternative to a <code>From</code> implementation is <code>Result::map_err</code>, especially
when the conversion only happens in one place.</p>
<p>There is no compatibility requirement for <code>Option</code>. A function returning
<code>Option&lt;T&gt;</code> can use the <code>?</code> operator on <code>Option&lt;U&gt;</code> for arbitrary <code>T</code> and <code>U</code>
types.</p>
<p>A function that returns <code>Result</code> cannot use <code>?</code> on <code>Option</code> and vice versa.
However, <code>Option::ok_or</code> converts <code>Option</code> to <code>Result</code> whereas <code>Result::ok</code>
turns <code>Result</code> into <code>Option</code>.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="error-handling-error"></div><h1 id="error-handling-error-dynamic-error-types"><a class="header" href="#error-handling-error-dynamic-error-types">Dynamic Error Types</a></h1>
<p>Sometimes we want to allow any type of error to be returned without writing our
own enum covering all the different possibilities. The <code>std::error::Error</code> trait
makes it easy to create a trait object that can contain any error.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error::Error;
use std::fs;
use std::io::Read;

fn read_count(path: &amp;str) -&gt; Result&lt;i32, Box&lt;dyn Error&gt;&gt; {
    let mut count_str = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut count_str)?;
    let count: i32 = count_str.parse()?;
    Ok(count)
}

fn main() {
    fs::write("count.dat", "1i3").unwrap();
    match read_count("count.dat") {
        Ok(count) =&gt; println!("Count: {count}"),
        Err(err) =&gt; println!("Error: {err}"),
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>The <code>read_count</code> function can return <code>std::io::Error</code> (from file operations) or
<code>std::num::ParseIntError</code> (from <code>String::parse</code>).</p>
<p>Boxing errors saves on code, but gives up the ability to cleanly handle
different error cases differently in the program. As such it's generally not a
good idea to use <code>Box&lt;dyn Error&gt;</code> in the public API of a library, but it can be
a good option in a program where you just want to display the error message
somewhere.</p>
<p>Make sure to implement the <code>std::error::Error</code> trait when defining a custom
error type so it can be boxed. But if you need to support the <code>no_std</code>
attribute, keep in mind that the <code>std::error::Error</code> trait is currently
compatible with <code>no_std</code> in
<a href="https://github.com/rust-lang/rust/issues/103765">nightly</a> only.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="error-handling-thiserror-and-anyhow"></div><h1 id="error-handling-thiserror-and-anyhow-thiserror-and-anyhow"><a class="header" href="#error-handling-thiserror-and-anyhow-thiserror-and-anyhow"><code>thiserror</code> and <code>anyhow</code></a></h1>
<p>The <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> and
<a href="https://docs.rs/anyhow/"><code>anyhow</code></a> crates are widely used to simplify error
handling.</p>
<ul>
<li><code>thiserror</code> is often used in libraries to create custom error types that
implement <code>From&lt;T&gt;</code>.</li>
<li><code>anyhow</code> is often used by applications to help with error handling in
functions, including adding contextual information to your errors.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use anyhow::{bail, Context, Result};
use std::fs;
use std::io::Read;
use thiserror::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error("Found no username in {0}")]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!("Failed to open {path}"))?
        .read_to_string(&amp;mut username)
        .context("Failed to read")?;
    if username.is_empty() {
        bail!(EmptyUsernameError(path.to_string()));
    }
    Ok(username)
}

fn main() {
    //fs::write("config.dat", "").unwrap();
    match read_username("config.dat") {
        Ok(username) =&gt; println!("Username: {username}"),
        Err(err) =&gt; println!("Error: {err:?}"),
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<h2 id="error-handling-thiserror-and-anyhow-thiserror"><a class="header" href="#error-handling-thiserror-and-anyhow-thiserror"><code>thiserror</code></a></h2>
<ul>
<li>The <code>Error</code> derive macro is provided by <code>thiserror</code>, and has lots of useful
attributes to help define error types in a compact way.</li>
<li>The <code>std::error::Error</code> trait is derived automatically.</li>
<li>The message from <code>#[error]</code> is used to derive the <code>Display</code> trait.</li>
</ul>
<h2 id="error-handling-thiserror-and-anyhow-anyhow"><a class="header" href="#error-handling-thiserror-and-anyhow-anyhow"><code>anyhow</code></a></h2>
<ul>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such it's
again generally not a good choice for the public API of a library, but is
widely used in applications.</li>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li>Actual error type inside of it can be extracted for examination if necessary.</li>
<li>Functionality provided by <code>anyhow::Result&lt;T&gt;</code> may be familiar to Go
developers, as it provides similar usage patterns and ergonomics to
<code>(T, error)</code> from Go.</li>
<li><code>anyhow::Context</code> is a trait implemented for the standard <code>Result</code> and
<code>Option</code> types. <code>use anyhow::Context</code> is necessary to enable <code>.context()</code> and
<code>.with_context()</code> on those types.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="error-handling-exercise"></div><h1 id="error-handling-exercise-exercise-rewriting-with-result"><a class="header" href="#error-handling-exercise-exercise-rewriting-with-result">Exercise: Rewriting with Result</a></h1>
<p>The following implements a very simple parser for an expression language.
However, it handles errors by panicking. Rewrite it to instead use idiomatic
error handling and propagate errors to a return from <code>main</code>. Feel free to use
<code>thiserror</code> and <code>anyhow</code>.</p>
<p>HINT: start by fixing error handling in the <code>parse</code> function. Once that is
working correctly, update <code>Tokenizer</code> to implement
<code>Iterator&lt;Item=Result&lt;Token, TokenizerError&gt;&gt;</code> and handle that in the parser.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::iter::Peekable;
use std::str::Chars;

/// An arithmetic operator.
#[derive(Debug, PartialEq, Clone, Copy)]
enum Op {
    Add,
    Sub,
}

/// A token in the expression language.
#[derive(Debug, PartialEq)]
enum Token {
    Number(String),
    Identifier(String),
    Operator(Op),
}

/// An expression in the expression language.
#[derive(Debug, PartialEq)]
enum Expression {
    /// A reference to a variable.
    Var(String),
    /// A literal number.
    Number(u32),
    /// A binary operation.
    Operation(Box&lt;Expression&gt;, Op, Box&lt;Expression&gt;),
}

fn tokenize(input: &amp;str) -&gt; Tokenizer {
    return Tokenizer(input.chars().peekable());
}

struct Tokenizer&lt;'a&gt;(Peekable&lt;Chars&lt;'a&gt;&gt;);

impl&lt;'a&gt; Tokenizer&lt;'a&gt; {
    fn collect_number(&amp;mut self, first_char: char) -&gt; Token {
        let mut num = String::from(first_char);
        while let Some(&amp;c @ '0'..='9') = self.0.peek() {
            num.push(c);
            self.0.next();
        }
        Token::Number(num)
    }

    fn collect_identifier(&amp;mut self, first_char: char) -&gt; Token {
        let mut ident = String::from(first_char);
        while let Some(&amp;c @ ('a'..='z' | '_' | '0'..='9')) = self.0.peek() {
            ident.push(c);
            self.0.next();
        }
        Token::Identifier(ident)
    }
}

impl&lt;'a&gt; Iterator for Tokenizer&lt;'a&gt; {
    type Item = Token;

    fn next(&amp;mut self) -&gt; Option&lt;Token&gt; {
        let c = self.0.next()?;
        match c {
            '0'..='9' =&gt; Some(self.collect_number(c)),
            'a'..='z' =&gt; Some(self.collect_identifier(c)),
            '+' =&gt; Some(Token::Operator(Op::Add)),
            '-' =&gt; Some(Token::Operator(Op::Sub)),
            _ =&gt; panic!("Unexpected character {c}"),
        }
    }
}

fn parse(input: &amp;str) -&gt; Expression {
    let mut tokens = tokenize(input);

    fn parse_expr&lt;'a&gt;(tokens: &amp;mut Tokenizer&lt;'a&gt;) -&gt; Expression {
        let Some(tok) = tokens.next() else {
            panic!("Unexpected end of input");
        };
        let expr = match tok {
            Token::Number(num) =&gt; {
                let v = num.parse().expect("Invalid 32-bit integer'");
                Expression::Number(v)
            }
            Token::Identifier(ident) =&gt; Expression::Var(ident),
            Token::Operator(_) =&gt; panic!("Unexpected token {tok:?}"),
        };
        // Look ahead to parse a binary operation if present.
        match tokens.next() {
            None =&gt; expr,
            Some(Token::Operator(op)) =&gt; Expression::Operation(
                Box::new(expr),
                op,
                Box::new(parse_expr(tokens)),
            ),
            Some(tok) =&gt; panic!("Unexpected token {tok:?}"),
        }
    }

    parse_expr(&amp;mut tokens)
}

fn main() {
    let expr = parse("10+foo+20-30");
    println!("{expr:?}");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="error-handling-solution"></div><h1 id="error-handling-solution-solution"><a class="header" href="#error-handling-solution-solution">Solution</a></h1>
<!-- compile_fail because `mdbook test` does not allow use of `thiserror` -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use thiserror::Error;
use std::iter::Peekable;
use std::str::Chars;

/// An arithmetic operator.
#[derive(Debug, PartialEq, Clone, Copy)]
enum Op {
    Add,
    Sub,
}

/// A token in the expression language.
#[derive(Debug, PartialEq)]
enum Token {
    Number(String),
    Identifier(String),
    Operator(Op),
}

/// An expression in the expression language.
#[derive(Debug, PartialEq)]
enum Expression {
    /// A reference to a variable.
    Var(String),
    /// A literal number.
    Number(u32),
    /// A binary operation.
    Operation(Box&lt;Expression&gt;, Op, Box&lt;Expression&gt;),
}

fn tokenize(input: &amp;str) -&gt; Tokenizer {
    return Tokenizer(input.chars().peekable());
}

#[derive(Debug, Error)]
enum TokenizerError {
    #[error("Unexpected character '{0}' in input")]
    UnexpectedCharacter(char),
}

struct Tokenizer&lt;'a&gt;(Peekable&lt;Chars&lt;'a&gt;&gt;);

impl&lt;'a&gt; Tokenizer&lt;'a&gt; {
    fn collect_number(&amp;mut self, first_char: char) -&gt; Token {
        let mut num = String::from(first_char);
        while let Some(&amp;c @ '0'..='9') = self.0.peek() {
            num.push(c);
            self.0.next();
        }
        Token::Number(num)
    }

    fn collect_identifier(&amp;mut self, first_char: char) -&gt; Token {
        let mut ident = String::from(first_char);
        while let Some(&amp;c @ ('a'..='z' | '_' | '0'..='9')) = self.0.peek() {
            ident.push(c);
            self.0.next();
        }
        Token::Identifier(ident)
    }
}

impl&lt;'a&gt; Iterator for Tokenizer&lt;'a&gt; {
    type Item = Result&lt;Token, TokenizerError&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Token, TokenizerError&gt;&gt; {
        let c = self.0.next()?;
        match c {
            '0'..='9' =&gt; Some(Ok(self.collect_number(c))),
            'a'..='z' | '_' =&gt; Some(Ok(self.collect_identifier(c))),
            '+' =&gt; Some(Ok(Token::Operator(Op::Add))),
            '-' =&gt; Some(Ok(Token::Operator(Op::Sub))),
            _ =&gt; Some(Err(TokenizerError::UnexpectedCharacter(c))),
        }
    }
}

#[derive(Debug, Error)]
enum ParserError {
    #[error("Tokenizer error: {0}")]
    TokenizerError(#[from] TokenizerError),
    #[error("Unexpected end of input")]
    UnexpectedEOF,
    #[error("Unexpected token {0:?}")]
    UnexpectedToken(Token),
    #[error("Invalid number")]
    InvalidNumber(#[from] std::num::ParseIntError),
}

fn parse(input: &amp;str) -&gt; Result&lt;Expression, ParserError&gt; {
    let mut tokens = tokenize(input);

    fn parse_expr&lt;'a&gt;(
        tokens: &amp;mut Tokenizer&lt;'a&gt;,
    ) -&gt; Result&lt;Expression, ParserError&gt; {
        let tok = tokens.next().ok_or(ParserError::UnexpectedEOF)??;
        let expr = match tok {
            Token::Number(num) =&gt; {
                let v = num.parse()?;
                Expression::Number(v)
            }
            Token::Identifier(ident) =&gt; Expression::Var(ident),
            Token::Operator(_) =&gt; return Err(ParserError::UnexpectedToken(tok)),
        };
        // Look ahead to parse a binary operation if present.
        Ok(match tokens.next() {
            None =&gt; expr,
            Some(Ok(Token::Operator(op))) =&gt; Expression::Operation(
                Box::new(expr),
                op,
                Box::new(parse_expr(tokens)?),
            ),
            Some(Err(e)) =&gt; return Err(e.into()),
            Some(Ok(tok)) =&gt; return Err(ParserError::UnexpectedToken(tok)),
        })
    }

    parse_expr(&amp;mut tokens)
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let expr = parse("10+foo+20-30")?;
    println!("{expr:?}");
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust"></div><h1 id="unsafe-rust-unsafe-rust"><a class="header" href="#unsafe-rust-unsafe-rust">Unsafe Rust</a></h1>
<p>This segment should take about 1 hour and 5 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Unsafe</td><td>5 minutes</td></tr>
<tr><td>Dereferencing Raw Pointers</td><td>10 minutes</td></tr>
<tr><td>Mutable Static Variables</td><td>5 minutes</td></tr>
<tr><td>Unions</td><td>5 minutes</td></tr>
<tr><td>Unsafe Functions</td><td>5 minutes</td></tr>
<tr><td>Unsafe Traits</td><td>5 minutes</td></tr>
<tr><td>Exercise: FFI Wrapper</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-unsafe"></div><h1 id="unsafe-rust-unsafe-unsafe-rust"><a class="header" href="#unsafe-rust-unsafe-unsafe-rust">Unsafe Rust</a></h1>
<p>The Rust language has two parts:</p>
<ul>
<li><strong>Safe Rust:</strong> memory safe, no undefined behavior possible.</li>
<li><strong>Unsafe Rust:</strong> can trigger undefined behavior if preconditions are violated.</li>
</ul>
<p>We saw mostly safe Rust in this course, but it's important to know what Unsafe
Rust is.</p>
<p>Unsafe code is usually small and isolated, and its correctness should be
carefully documented. It is usually wrapped in a safe abstraction layer.</p>
<p>Unsafe Rust gives you access to five new capabilities:</p>
<ul>
<li>Dereference raw pointers.</li>
<li>Access or modify mutable static variables.</li>
<li>Access <code>union</code> fields.</li>
<li>Call <code>unsafe</code> functions, including <code>extern</code> functions.</li>
<li>Implement <code>unsafe</code> traits.</li>
</ul>
<p>We will briefly cover unsafe capabilities next. For full details, please see
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Chapter 19.1 in the Rust Book</a>
and the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>
<details>
This slide should take about 5 minutes. 
<p>Unsafe Rust does not mean the code is incorrect. It means that developers have
turned off some compiler safety features and have to write correct code by
themselves. It means the compiler no longer enforces Rust's memory-safety rules.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-dereferencing"></div><h1 id="unsafe-rust-dereferencing-dereferencing-raw-pointers"><a class="header" href="#unsafe-rust-dereferencing-dereferencing-raw-pointers">Dereferencing Raw Pointers</a></h1>
<p>Creating pointers is safe, but dereferencing them requires <code>unsafe</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s = String::from("careful!");

    let r1 = &amp;mut s as *mut String;
    let r2 = r1 as *const String;

    // SAFETY: r1 and r2 were obtained from references and so are guaranteed to
    // be non-null and properly aligned, the objects underlying the references
    // from which they were obtained are live throughout the whole unsafe
    // block, and they are not accessed either through the references or
    // concurrently through any other pointers.
    unsafe {
        println!("r1 is: {}", *r1);
        *r1 = String::from("uhoh");
        println!("r2 is: {}", *r2);
    }

    // NOT SAFE. DO NOT DO THIS.
    /*
    let r3: &amp;String = unsafe { &amp;*r1 };
    drop(s);
    println!("r3 is: {}", *r3);
    */
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<p>It is good practice (and required by the Android Rust style guide) to write a
comment for each <code>unsafe</code> block explaining how the code inside it satisfies the
safety requirements of the unsafe operations it is doing.</p>
<p>In the case of pointer dereferences, this means that the pointers must be
<a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>, i.e.:</p>
<ul>
<li>The pointer must be non-null.</li>
<li>The pointer must be <em>dereferenceable</em> (within the bounds of a single allocated
object).</li>
<li>The object must not have been deallocated.</li>
<li>There must not be concurrent accesses to the same location.</li>
<li>If the pointer was obtained by casting a reference, the underlying object must
be live and no reference may be used to access the memory.</li>
</ul>
<p>In most cases the pointer must also be properly aligned.</p>
<p>The "NOT SAFE" section gives an example of a common kind of UB bug: <code>*r1</code> has
the <code>'static</code> lifetime, so <code>r3</code> has type <code>&amp;'static String</code>, and thus outlives
<code>s</code>. Creating a reference from a pointer requires <em>great care</em>.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-mutable-static"></div><h1 id="unsafe-rust-mutable-static-mutable-static-variables"><a class="header" href="#unsafe-rust-mutable-static-mutable-static-variables">Mutable Static Variables</a></h1>
<p>It is safe to read an immutable static variable:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("HELLO_WORLD: {HELLO_WORLD}");
}</code></pre></pre>
<p>However, since data races can occur, it is unsafe to read and write mutable
static variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_counter(42);

    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        println!("COUNTER: {COUNTER}");
    }
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>The program here is safe because it is single-threaded. However, the Rust
compiler is conservative and will assume the worst. Try removing the <code>unsafe</code>
and see how the compiler explains that it is undefined behavior to mutate a
static from multiple threads.</p>
</li>
<li>
<p>Using a mutable static is generally a bad idea, but there are some cases where
it might make sense in low-level <code>no_std</code> code, such as implementing a heap
allocator or working with some C APIs.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-unions"></div><h1 id="unsafe-rust-unions-unions"><a class="header" href="#unsafe-rust-unions-unions">Unions</a></h1>
<p>Unions are like enums, but you need to track the active field yourself:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!("int: {}", unsafe { u.i });
    println!("bool: {}", unsafe { u.b }); // Undefined behavior!
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>Unions are very rarely needed in Rust as you can usually use an enum. They are
occasionally needed for interacting with C library APIs.</p>
<p>If you just want to reinterpret bytes as a different type, you probably want
<a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a>
or a safe wrapper such as the <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a>
crate.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-unsafe-functions"></div><h1 id="unsafe-rust-unsafe-functions-unsafe-functions"><a class="header" href="#unsafe-rust-unsafe-functions-unsafe-functions">Unsafe Functions</a></h1>
<h2 id="unsafe-rust-unsafe-functions-calling-unsafe-functions"><a class="header" href="#unsafe-rust-unsafe-functions-calling-unsafe-functions">Calling Unsafe Functions</a></h2>
<p>A function or method can be marked <code>unsafe</code> if it has extra preconditions you
must uphold to avoid undefined behaviour:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    let emojis = "üóª‚ààüåè";

    // SAFETY: The indices are in the correct order, within the bounds of the
    // string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!("emoji: {}", emojis.get_unchecked(0..4));
        println!("emoji: {}", emojis.get_unchecked(4..7));
        println!("emoji: {}", emojis.get_unchecked(7..11));
    }

    println!("char count: {}", count_chars(unsafe { emojis.get_unchecked(0..7) }));

    // SAFETY: `abs` doesn't deal with pointers and doesn't have any safety
    // requirements.
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }

    // Not upholding the UTF-8 encoding requirement breaks memory safety!
    // println!("emoji: {}", unsafe { emojis.get_unchecked(0..3) });
    // println!("char count: {}", count_chars(unsafe {
    // emojis.get_unchecked(0..3) }));
}

fn count_chars(s: &amp;str) -&gt; usize {
    s.chars().count()
}</code></pre></pre>
<h2 id="unsafe-rust-unsafe-functions-writing-unsafe-functions"><a class="header" href="#unsafe-rust-unsafe-functions-writing-unsafe-functions">Writing Unsafe Functions</a></h2>
<p>You can mark your own functions as <code>unsafe</code> if they require particular
conditions to avoid undefined behaviour.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // SAFETY: ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!("a = {}, b = {}", a, b);
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<h2 id="unsafe-rust-unsafe-functions-calling-unsafe-functions-1"><a class="header" href="#unsafe-rust-unsafe-functions-calling-unsafe-functions-1">Calling Unsafe Functions</a></h2>
<p><code>get_unchecked</code>, like most <code>_unchecked</code> functions, is unsafe, because it can
create UB if the range is incorrect. <code>abs</code> is incorrect for a different reason:
it is an external function (FFI). Calling external functions is usually only a
problem when those functions do things with pointers which might violate Rust's
memory model, but in general any C function might have undefined behaviour under
any arbitrary circumstances.</p>
<p>The <code>"C"</code> in this example is the ABI;
<a href="https://doc.rust-lang.org/reference/items/external-blocks.html">other ABIs are available too</a>.</p>
<h2 id="unsafe-rust-unsafe-functions-writing-unsafe-functions-1"><a class="header" href="#unsafe-rust-unsafe-functions-writing-unsafe-functions-1">Writing Unsafe Functions</a></h2>
<p>We wouldn't actually use pointers for a <code>swap</code> function - it can be done safely
with references.</p>
<p>Note that unsafe code is allowed within an unsafe function without an <code>unsafe</code>
block. We can prohibit this with <code>#[deny(unsafe_op_in_unsafe_fn)]</code>. Try adding
it and see what happens. This will likely change in a future Rust edition.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-unsafe-traits"></div><h1 id="unsafe-rust-unsafe-traits-implementing-unsafe-traits"><a class="header" href="#unsafe-rust-unsafe-traits-implementing-unsafe-traits">Implementing Unsafe Traits</a></h1>
<p>Like with functions, you can mark a trait as <code>unsafe</code> if the implementation must
guarantee particular conditions to avoid undefined behaviour.</p>
<p>For example, the <code>zerocopy</code> crate has an unsafe trait that looks
<a href="https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html">something like this</a>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::size_of_val;
use std::slice;

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait AsBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            slice::from_raw_parts(
                self as *const Self as *const u8,
                size_of_val(self),
            )
        }
    }
}

// SAFETY: `u32` has a defined representation and no padding.
unsafe impl AsBytes for u32 {}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<p>There should be a <code># Safety</code> section on the Rustdoc for the trait explaining the
requirements for the trait to be safely implemented.</p>
<p>The actual safety section for <code>AsBytes</code> is rather longer and more complicated.</p>
<p>The built-in <code>Send</code> and <code>Sync</code> traits are unsafe.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-exercise"></div><h1 id="unsafe-rust-exercise-safe-ffi-wrapper"><a class="header" href="#unsafe-rust-exercise-safe-ffi-wrapper">Safe FFI Wrapper</a></h1>
<p>Rust has great support for calling functions through a <em>foreign function
interface</em> (FFI). We will use this to build a safe wrapper for the <code>libc</code>
functions you would use from C to read the names of files in a directory.</p>
<p>You will want to consult the manual pages:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>You will also want to browse the <a href="https://doc.rust-lang.org/std/ffi/"><code>std::ffi</code></a> module. There you find a number of
string types which you need for the exercise:</p>
<div class="table-wrapper"><table><thead><tr><th>Types</th><th>Encoding</th><th>Use</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> and <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></td><td>UTF-8</td><td>Text processing in Rust</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a></td><td>NUL-terminated</td><td>Communicating with C functions</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a></td><td>OS-specific</td><td>Communicating with the OS</td></tr>
</tbody></table>
</div>
<p>You will convert between all these types:</p>
<ul>
<li><code>&amp;str</code> to <code>CString</code>: you need to allocate space for a trailing <code>\0</code> character,</li>
<li><code>CString</code> to <code>*const i8</code>: you need a pointer to call C functions,</li>
<li><code>*const i8</code> to <code>&amp;CStr</code>: you need something which can find the trailing <code>\0</code>
character,</li>
<li><code>&amp;CStr</code> to <code>&amp;[u8]</code>: a slice of bytes is the universal interface for "some
unknown data",</li>
<li><code>&amp;[u8]</code> to <code>&amp;OsStr</code>: <code>&amp;OsStr</code> is a step towards <code>OsString</code>, use
<a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a> to
create it,</li>
<li><code>&amp;OsStr</code> to <code>OsString</code>: you need to clone the data in <code>&amp;OsStr</code> to be able to
return it and call <code>readdir</code> again.</li>
</ul>
<p>The <a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon</a> also has a very useful chapter about FFI.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
functions and methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = "macos"))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = "macos"))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = "macos"))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern "C" {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = "macos", target_arch = "x86_64")))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // "Platforms that existed before these updates were available" refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
        #[link_name = "readdir$INODE64"]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(".")?;
    println!("files: {:#?}", iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="unsafe-rust-solution"></div><h1 id="unsafe-rust-solution-solution"><a class="header" href="#unsafe-rust-solution-solution">Solution</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = "macos"))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = "macos"))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = "macos"))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern "C" {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = "macos", target_arch = "x86_64")))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // "Platforms that existed before these updates were available" refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
        #[link_name = "readdir$INODE64"]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        let path =
            CString::new(path).map_err(|err| format!("Invalid path: {err}"))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!("Could not open {:?}", path))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        if !self.dir.is_null() {
            // SAFETY: self.dir is not NULL.
            if unsafe { ffi::closedir(self.dir) } != 0 {
                panic!("Could not close {:?}", self.path);
            }
        }
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(".")?;
    println!("files: {:#?}", iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new("no-such-directory");
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or("Non UTF-8 character in path")?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[".", ".."]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join("foo.txt"), "The Foo Diaries\n")?;
        std::fs::write(tmp.path().join("bar.png"), "&lt;PNG&gt;\n")?;
        std::fs::write(tmp.path().join("crab.rs"), "//! Crab\n")?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or("Non UTF-8 character in path")?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[".", "..", "bar.png", "crab.rs", "foo.txt"]);
        Ok(())
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android"></div><h1 id="android-welcome-to-rust-in-android"><a class="header" href="#android-welcome-to-rust-in-android">Welcome to Rust in Android</a></h1>
<p>Rust is supported for system software on Android. This means that you can write
new services, libraries, drivers or even firmware in Rust (or improve existing
code as needed).</p>
<blockquote>
<p>We will attempt to call Rust from one of your own projects today. So try to
find a little corner of your code base where we can move some lines of code to
Rust. The fewer dependencies and "exotic" types the better. Something that
parses some raw bytes would be ideal.</p>
</blockquote>
<details>
<p>The speaker may mention any of the following given the increased use of Rust in
Android:</p>
<ul>
<li>
<p>Service example:
<a href="https://security.googleblog.com/2022/07/dns-over-http3-in-android.html">DNS over HTTP</a></p>
</li>
<li>
<p>Libraries:
<a href="https://crosvm.dev/book/appendix/rutabaga_gfx.html">Rutabaga Virtual Graphics Interface</a></p>
</li>
<li>
<p>Kernel Drivers:
<a href="https://lore.kernel.org/rust-for-linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/">Binder</a></p>
</li>
<li>
<p>Firmware:
<a href="https://security.googleblog.com/2023/10/bare-metal-rust-in-android.html">pKVM firmware</a></p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="android-setup"></div><h1 id="android-setup-setup"><a class="header" href="#android-setup-setup">Setup</a></h1>
<p>We will be using a Cuttlefish Android Virtual Device to test our code. Make sure
you have access to one or create a new one with:</p>
<pre><code class="language-shell">source build/envsetup.sh
lunch aosp_cf_x86_64_phone-trunk_staging-userdebug
acloud create
</code></pre>
<p>Please see the
<a href="https://source.android.com/docs/setup/start">Android Developer Codelab</a> for
details.</p>
<details>
<p>Key points:</p>
<ul>
<li>
<p>Cuttlefish is a reference Android device designed to work on generic Linux
desktops. MacOS support is also planned.</p>
</li>
<li>
<p>The Cuttlefish system image maintains high fidelity to real devices, and is
the ideal emulator to run many Rust use cases.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-build-rules"></div><h1 id="android-build-rules-build-rules"><a class="header" href="#android-build-rules-build-rules">Build Rules</a></h1>
<p>The Android build system (Soong) supports Rust via a number of modules:</p>
<div class="table-wrapper"><table><thead><tr><th>Module Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rust_binary</code></td><td>Produces a Rust binary.</td></tr>
<tr><td><code>rust_library</code></td><td>Produces a Rust library, and provides both <code>rlib</code> and <code>dylib</code> variants.</td></tr>
<tr><td><code>rust_ffi</code></td><td>Produces a Rust C library usable by <code>cc</code> modules, and provides both static and shared variants.</td></tr>
<tr><td><code>rust_proc_macro</code></td><td>Produces a <code>proc-macro</code> Rust library. These are analogous to compiler plugins.</td></tr>
<tr><td><code>rust_test</code></td><td>Produces a Rust test binary that uses the standard Rust test harness.</td></tr>
<tr><td><code>rust_fuzz</code></td><td>Produces a Rust fuzz binary leveraging <code>libfuzzer</code>.</td></tr>
<tr><td><code>rust_protobuf</code></td><td>Generates source and produces a Rust library that provides an interface for a particular protobuf.</td></tr>
<tr><td><code>rust_bindgen</code></td><td>Generates source and produces a Rust library containing Rust bindings to C libraries.</td></tr>
</tbody></table>
</div>
<p>We will look at <code>rust_binary</code> and <code>rust_library</code> next.</p>
<details>
<p>Additional items speaker may mention:</p>
<ul>
<li>
<p>Cargo is not optimized for multi-language repos, and also downloads packages
from the internet.</p>
</li>
<li>
<p>For compliance and performance, Android must have crates in-tree. It must also
interop with C/C++/Java code. Soong fills that gap.</p>
</li>
<li>
<p>Soong has many similarities to Bazel, which is the open-source variant of
Blaze (used in google3).</p>
</li>
<li>
<p>There is a plan to transition
<a href="https://source.android.com/docs/setup/build/bazel/introduction">Android</a>,
<a href="https://chromium.googlesource.com/chromiumos/bazel/">ChromeOS</a>, and
<a href="https://source.android.com/docs/setup/build/bazel/introduction">Fuchsia</a> to
Bazel.</p>
</li>
<li>
<p>Learning Bazel-like build rules is useful for all Rust OS developers.</p>
</li>
<li>
<p>Fun fact: Data from Star Trek is a Soong-type Android.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-build-rules-binary"></div><h1 id="android-build-rules-binary-rust-binaries"><a class="header" href="#android-build-rules-binary-rust-binaries">Rust Binaries</a></h1>
<p>Let us start with a simple application. At the root of an AOSP checkout, create
the following files:</p>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: "hello_rust",
    crate_name: "hello_rust",
    srcs: ["src/main.rs"],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!("Hello from Rust!");
}</code></pre></pre>
<p>You can now build, push, and run the binary:</p>
<pre><code class="language-shell">m hello_rust
adb push "$ANDROID_PRODUCT_OUT/system/bin/hello_rust" /data/local/tmp
adb shell /data/local/tmp/hello_rust
</code></pre>
<pre><code class="language-text">Hello from Rust!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-build-rules-library"></div><h1 id="android-build-rules-library-rust-libraries"><a class="header" href="#android-build-rules-library-rust-libraries">Rust Libraries</a></h1>
<p>You use <code>rust_library</code> to create a new Rust library for Android.</p>
<p>Here we declare a dependency on two libraries:</p>
<ul>
<li><code>libgreeting</code>, which we define below,</li>
<li><code>libtextwrap</code>, which is a crate already vendored in
<a href="https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"><code>external/rust/crates/</code></a>.</li>
</ul>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: "hello_rust_with_dep",
    crate_name: "hello_rust_with_dep",
    srcs: ["src/main.rs"],
    rustlibs: [
        "libgreetings",
        "libtextwrap",
    ],
    prefer_rlib: true, // Need this to avoid dynamic link error.
}

rust_library {
    name: "libgreetings",
    crate_name: "greetings",
    srcs: ["src/lib.rs"],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!("{}", fill(&amp;greeting("Bob"), 24));
}</code></pre>
<p><em>hello_rust/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}, it is very nice to meet you!")
}</code></pre>
<p>You build, push, and run the binary like before:</p>
<pre><code class="language-shell">m hello_rust_with_dep
adb push "$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep" /data/local/tmp
adb shell /data/local/tmp/hello_rust_with_dep
</code></pre>
<pre><code class="language-text">Hello Bob, it is very
nice to meet you!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl"></div><h1 id="android-aidl-aidl"><a class="header" href="#android-aidl-aidl">AIDL</a></h1>
<p>The
<a href="https://developer.android.com/guide/components/aidl">Android Interface Definition Language
(AIDL)</a> is supported in
Rust:</p>
<ul>
<li>Rust code can call existing AIDL servers,</li>
<li>You can create new AIDL servers in Rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-birthday-service"></div><h1 id="android-aidl-birthday-service-birthday-service-tutorial"><a class="header" href="#android-aidl-birthday-service-birthday-service-tutorial">Birthday Service Tutorial</a></h1>
<p>To illustrate how to use Rust with Binder, we're going to walk through the
process of creating a Binder interface. We're then going to both implement the
described service and write client code that talks to that service.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-interface"></div><h1 id="android-aidl-example-service-interface-aidl-interfaces"><a class="header" href="#android-aidl-example-service-interface-aidl-interfaces">AIDL Interfaces</a></h1>
<p>You declare the API of your service using an AIDL interface:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>birthday_service/aidl/Android.bp</em>:</p>
<pre><code class="language-javascript">aidl_interface {
    name: "com.example.birthdayservice",
    srcs: ["com/example/birthdayservice/*.aidl"],
    unstable: true,
    backend: {
        rust: { // Rust is not enabled by default
            enabled: true,
        },
    },
}
</code></pre>
<details>
<ul>
<li>Note that the directory structure under the <code>aidl/</code> directory needs to match
the package name used in the AIDL file, i.e. the package is
<code>com.example.birthdayservice</code> and the file is at
<code>aidl/com/example/IBirthdayService.aidl</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-service-bindings"></div><h1 id="android-aidl-example-service-service-bindings-generated-service-api"><a class="header" href="#android-aidl-example-service-service-bindings-generated-service-api">Generated Service API</a></h1>
<p>Binder generates a trait corresponding to the interface definition. trait to
talk to the service.</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>Generated trait</em>:</p>
<pre><code class="language-rust ignore">trait IBirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt;;
}</code></pre>
<p>Your service will need to implement this trait, and your client will use this
trait to talk to the service.</p>
<details>
<ul>
<li>The generated bindings can be found at
<code>out/soong/.intermediates/&lt;path to module&gt;/</code>.</li>
<li>Point out how the generated function signature, specifically the argument and
return types, correspond the interface definition.
<ul>
<li><code>String</code> for an argument results in a different Rust type than <code>String</code> as a
return type.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-service"></div><h1 id="android-aidl-example-service-service-service-implementation"><a class="header" href="#android-aidl-example-service-service-service-implementation">Service Implementation</a></h1>
<p>We can now implement the AIDL service:</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

/// The `IBirthdayService` implementation.
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt; {
        Ok(format!("Happy Birthday {name}, congratulations with the {years} years!"))
    }
}</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: "libbirthdayservice",
    srcs: ["src/lib.rs"],
    crate_name: "birthdayservice",
    rustlibs: [
        "com.example.birthdayservice-rust",
        "libbinder_rs",
    ],
}
</code></pre>
<details>
<ul>
<li>Point out the path to the generated <code>IBirthdayService</code> trait, and explain why
each of the segments is necessary.</li>
<li>TODO: What does the <code>binder::Interface</code> trait do? Are there methods to
override? Where source?</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-server"></div><h1 id="android-aidl-example-service-server-aidl-server"><a class="header" href="#android-aidl-example-service-server-aidl-server">AIDL Server</a></h1>
<p>Finally, we can create a server which exposes the service:</p>
<p><em>birthday_service/src/server.rs</em>:</p>
<pre><code class="language-rust ignore">//! Birthday service.
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = "birthdayservice";

/// Entry point for birthday service.
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect("Failed to register service");
    binder::ProcessState::join_thread_pool()
}</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: "birthday_server",
    crate_name: "birthday_server",
    srcs: ["src/server.rs"],
    rustlibs: [
        "com.example.birthdayservice-rust",
        "libbinder_rs",
        "libbirthdayservice",
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
</code></pre>
<details>
<p>The process for taking a user-defined service implementation (in this case the
<code>BirthdayService</code> type, which implements the <code>IBirthdayService</code>) and starting it
as a Binder service has multiple steps, and may appear more complicated than
students are used to if they've used Binder from C++ or another language.
Explain to students why each step is necessary.</p>
<ol>
<li>Create an instance of your service type (<code>BirthdayService</code>).</li>
<li>Wrap the service object in corresponding <code>Bn*</code> type (<code>BnBirthdayService</code> in
this case). This type is generated by Binder and provides the common Binder
functionality that would be provided by the <code>BnBinder</code> base class in C++. We
don't have inheritance in Rust, so instead we use composition, putting our
<code>BirthdayService</code> within the generated <code>BnBinderService</code>.</li>
<li>Call <code>add_service</code>, giving it a service identifier and your service object
(the <code>BnBirthdayService</code> object in the example).</li>
<li>Call <code>join_thread_pool</code> to add the current thread to Binder's thread pool and
start listening for connections.</li>
</ol>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-deploy"></div><h1 id="android-aidl-example-service-deploy-deploy"><a class="header" href="#android-aidl-example-service-deploy-deploy">Deploy</a></h1>
<p>We can now build, push, and start the service:</p>
<pre><code class="language-shell">m birthday_server
adb push "$ANDROID_PRODUCT_OUT/system/bin/birthday_server" /data/local/tmp
adb root
adb shell /data/local/tmp/birthday_server
</code></pre>
<p>In another terminal, check that the service runs:</p>
<pre><code class="language-shell">adb shell service check birthdayservice
</code></pre>
<pre><code class="language-text">Service birthdayservice: found
</code></pre>
<p>You can also call the service with <code>service call</code>:</p>
<pre><code class="language-shell">adb shell service call birthdayservice 1 s16 Bob i32 24
</code></pre>
<pre><code class="language-text">Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-client"></div><h1 id="android-aidl-example-service-client-aidl-client"><a class="header" href="#android-aidl-example-service-client-aidl-client">AIDL Client</a></h1>
<p>Finally, we can create a Rust client for our new service.</p>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = "birthdayservice";

/// Call the birthday service.
fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let name = std::env::args().nth(1).unwrap_or_else(|| String::from("Bob"));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::&lt;i32&gt;().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = binder::get_interface::&lt;dyn IBirthdayService&gt;(SERVICE_IDENTIFIER)
        .map_err(|_| "Failed to connect to BirthdayService")?;

    // Call the service.
    let msg = service.wishHappyBirthday(&amp;name, years)?;
    println!("{msg}");
}</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: "birthday_client",
    crate_name: "birthday_client",
    srcs: ["src/client.rs"],
    rustlibs: [
        "com.example.birthdayservice-rust",
        "libbinder_rs",
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
</code></pre>
<p>Notice that the client does not depend on <code>libbirthdayservice</code>.</p>
<p>Build, push, and run the client on your device:</p>
<pre><code class="language-shell">m birthday_client
adb push "$ANDROID_PRODUCT_OUT/system/bin/birthday_client" /data/local/tmp
adb shell /data/local/tmp/birthday_client Charlie 60
</code></pre>
<pre><code class="language-text">Happy Birthday Charlie, congratulations with the 60 years!
</code></pre>
<details>
<ul>
<li><code>Strong&lt;dyn IBirthdayService&gt;</code> is the trait object representing the service
that the client has connected to.
<ul>
<li><code>Strong</code> is a custom smart pointer type for Binder. It handles both an
in-process ref count for the service trait object, and the global Binder ref
count that tracks how many processes have a reference to the object.</li>
<li>Note that the trait object that the client uses to talk to the service uses
the exact same trait that the server implements. For a given Binder
interface, there is a single Rust trait generated that both client and
server use.</li>
</ul>
</li>
<li>Use the same service identifier used when registering the service. This should
ideally be defined in a common crate that both the client and server can
depend on.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-changing-definition"></div><h1 id="android-aidl-example-service-changing-definition-changing-api"><a class="header" href="#android-aidl-example-service-changing-definition-changing-api">Changing API</a></h1>
<p>Let us extend the API with more functionality: we want to let clients specify a
list of lines for the birthday card:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
</code></pre>
<p>This results in an updated trait definition for <code>IBirthdayService</code>:</p>
<pre><code class="language-rust ignore">trait IBirthdayService {
    fn wishHappyBirthday(
        &amp;self,
        name: &amp;str,
        years: i32,
        text: &amp;[String],
    ) -&gt; binder::Result&lt;String&gt;;
}</code></pre>
<details>
<ul>
<li>Note how the <code>String[]</code> in the AIDL definition is translated as a <code>&amp;[String]</code>
in Rust, i.e. that idiomatic Rust types are used in the generated bindings
wherever possible:
<ul>
<li><code>in</code> array arguments are translated to slices.</li>
<li><code>out</code> and <code>inout</code> args are translated to <code>&amp;mut Vec&lt;T&gt;</code>.</li>
<li>Return values are translated to returning a <code>Vec&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-example-service-changing-implementation"></div><h1 id="android-aidl-example-service-changing-implementation-updating-client-and-service"><a class="header" href="#android-aidl-example-service-changing-implementation-updating-client-and-service">Updating Client and Service</a></h1>
<p>Update the client and server code to account for the new API.</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(
        &amp;self,
        name: &amp;str,
        years: i32,
        text: &amp;[String],
    ) -&gt; binder::Result&lt;String&gt; {
        let mut msg = format!(
            "Happy Birthday {name}, congratulations with the {years} years!",
        );

        for line in text {
            msg.push('\n');
            msg.push_str(line);
        }

        Ok(msg)
    }
}</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">let msg = service.wishHappyBirthday(
    &amp;name,
    years,
    &amp;[
        String::from("Habby birfday to yuuuuu"),
        String::from("And also: many more"),
    ],
)?;</code></pre>
<details>
<ul>
<li>TODO: Move code snippets into project files where they'll actually be built?</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-types"></div><h1 id="android-aidl-types-working-with-aidl-types"><a class="header" href="#android-aidl-types-working-with-aidl-types">Working With AIDL Types</a></h1>
<p>AIDL types translate into the appropriate idiomatic Rust type:</p>
<ul>
<li>Primitive types map (mostly) to idiomatic Rust types.</li>
<li>Collection types like slices, <code>Vec</code>s and string types are supported.</li>
<li>References to AIDL objects and file handles can be sent between clients and
services.</li>
<li>File handles and parcelables are fully supported.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-types-primitives"></div><h1 id="android-aidl-types-primitives-primitive-types"><a class="header" href="#android-aidl-types-primitives-primitive-types">Primitive Types</a></h1>
<p>Primitive types map (mostly) idiomatically:</p>
<div class="table-wrapper"><table><thead><tr><th>AIDL Type</th><th>Rust Type</th><th>Note</th></tr></thead><tbody>
<tr><td><code>boolean</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>byte</code></td><td><code>i8</code></td><td>Note that bytes are signed.</td></tr>
<tr><td><code>char</code></td><td><code>u16</code></td><td>Note the usage of <code>u16</code>, NOT <code>u32</code>.</td></tr>
<tr><td><code>int</code></td><td><code>i32</code></td><td></td></tr>
<tr><td><code>long</code></td><td><code>i64</code></td><td></td></tr>
<tr><td><code>float</code></td><td><code>f32</code></td><td></td></tr>
<tr><td><code>double</code></td><td><code>f64</code></td><td></td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-types-arrays"></div><h1 id="android-aidl-types-arrays-array-types"><a class="header" href="#android-aidl-types-arrays-array-types">Array Types</a></h1>
<p>The array types (<code>T[]</code>, <code>byte[]</code>, and <code>List&lt;T&gt;</code>) get translated to the
appropriate Rust array type depending on how they are used in the function
signature:</p>
<div class="table-wrapper"><table><thead><tr><th>Position</th><th>Rust Type</th></tr></thead><tbody>
<tr><td><code>in</code> argument</td><td><code>&amp;[T]</code></td></tr>
<tr><td><code>out</code>/<code>inout</code> argument</td><td><code>&amp;mut Vec&lt;T&gt;</code></td></tr>
<tr><td>Return</td><td><code>Vec&lt;T&gt;</code></td></tr>
</tbody></table>
</div><details>
<ul>
<li>In Android 13 or higher, fixed-size arrays are supported, i.e. <code>T[N]</code> becomes
<code>[T; N]</code>. Fixed-size arrays can have multiple dimensions (e.g. <code>int[3][4]</code>).
In the Java backend, fixed-size arrays are represented as array types.</li>
<li>Arrays in parcelable fields always get translated to <code>Vec&lt;T&gt;</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-types-objects"></div><h1 id="android-aidl-types-objects-sending-objects"><a class="header" href="#android-aidl-types-objects-sending-objects">Sending Objects</a></h1>
<p>AIDL objects can be sent either as a concrete AIDL type or as the type-erased
<code>IBinder</code> interface:</p>
<p><strong>birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider.aidl</strong>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

interface IBirthdayInfoProvider {
    String name();
    int years();
}
</code></pre>
<p><strong>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</strong>:</p>
<pre><code class="language-java">import com.example.birthdayservice.IBirthdayInfoProvider;

interface IBirthdayService {
    /** The same thing, but using a binder object. */
    String wishWithProvider(IBirthdayInfoProvider provider);

    /** The same thing, but using `IBinder`. */
    String wishWithErasedProvider(IBinder provider);
}
</code></pre>
<p><strong>birthday_service/src/client.rs</strong>:</p>
<pre><code class="language-rust ignore">/// Rust struct implementing the `IBirthdayInfoProvider` interface.
struct InfoProvider {
    name: String,
    age: u8,
}

impl binder::Interface for InfoProvider {}

impl IBirthdayInfoProvider for InfoProvider {
    fn name(&amp;self) -&gt; binder::Result&lt;String&gt; {
        Ok(self.name.clone())
    }

    fn years(&amp;self) -&gt; binder::Result&lt;i32&gt; {
        Ok(self.age as i32)
    }
}

fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect("Failed to connect to BirthdayService");

    // Create a binder object for the `IBirthdayInfoProvider` interface.
    let provider = BnBirthdayInfoProvider::new_binder(
        InfoProvider { name: name.clone(), age: years as u8 },
        BinderFeatures::default(),
    );

    // Send the binder object to the service.
    service.wishWithProvider(&amp;provider)?;

    // Perform the same operation but passing the provider as an `SpIBinder`.
    service.wishWithErasedProvider(&amp;provider.as_binder())?;
}</code></pre>
<details>
<ul>
<li>Note the usage of <code>BnBirthdayInfoProvider</code>. This serves the same purpose as
<code>BnBirthdayService</code> that we saw previously.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-types-parcelables"></div><h1 id="android-aidl-types-parcelables-parcelables"><a class="header" href="#android-aidl-types-parcelables-parcelables">Parcelables</a></h1>
<p>Binder for Rust supports sending parcelables directly:</p>
<p><strong>birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl</strong>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

parcelable BirthdayInfo {
    String name;
    int years;
}
</code></pre>
<p><strong>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</strong>:</p>
<pre><code class="language-java">import com.example.birthdayservice.BirthdayInfo;

interface IBirthdayService {
    /** The same thing, but with a parcelable. */
    String wishWithInfo(in BirthdayInfo info);
}
</code></pre>
<p><strong>birthday_service/src/client.rs</strong>:</p>
<pre><code class="language-rust ignore">fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect("Failed to connect to BirthdayService");

    service.wishWithInfo(&amp;BirthdayInfo { name: name.clone(), years })?;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-aidl-types-file-descriptor"></div><h1 id="android-aidl-types-file-descriptor-sending-files"><a class="header" href="#android-aidl-types-file-descriptor-sending-files">Sending Files</a></h1>
<p>Files can be sent between Binder clients/servers using the
<code>ParcelFileDescriptor</code> type:</p>
<p><strong>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</strong>:</p>
<pre><code class="language-java">interface IBirthdayService {
    /** The same thing, but loads info from a file. */
    String wishFromFile(in ParcelFileDescriptor infoFile);
}
</code></pre>
<p><strong>birthday_service/src/client.rs</strong>:</p>
<pre><code class="language-rust ignore">fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect("Failed to connect to BirthdayService");

    // Open a file and put the birthday info in it.
    let mut file = File::create("/data/local/tmp/birthday.info").unwrap();
    writeln!(file, "{name}")?;
    writeln!(file, "{years}")?;

    // Create a `ParcelFileDescriptor` from the file and send it.
    let file = ParcelFileDescriptor::new(file);
    service.wishFromFile(&amp;file)?;
}</code></pre>
<p><strong>birthday_service/src/lib.rs</strong>:</p>
<pre><code class="language-rust ignore">impl IBirthdayService for BirthdayService {
    fn wishFromFile(
        &amp;self,
        info_file: &amp;ParcelFileDescriptor,
    ) -&gt; binder::Result&lt;String&gt; {
        // Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps
        // an `OwnedFd`, which can be cloned and then used to create a `File`
        // object.
        let mut info_file = info_file
            .as_ref()
            .try_clone()
            .map(File::from)
            .expect("Invalid file handle");

        let mut contents = String::new();
        info_file.read_to_string(&amp;mut contents).unwrap();

        let mut lines = contents.lines();
        let name = lines.next().unwrap();
        let years: i32 = lines.next().unwrap().parse().unwrap();

        Ok(format!("Happy Birthday {name}, congratulations with the {years} years!"))
    }
}</code></pre>
<details>
<ul>
<li><code>ParcelFileDescriptor</code> wraps an <code>OwnedFd</code>, and so can be created from a <code>File</code>
(or any other type that wraps an <code>OwnedFd</code>), and can be used to create a new
<code>File</code> handle on the other side.</li>
<li>Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and
UNIX sockets.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-testing"></div><h1 id="android-testing-testing-in-android"><a class="header" href="#android-testing-testing-in-android">Testing in Android</a></h1>
<p>Building on <a href="#testing">Testing</a>, we will now look at how unit tests work in
AOSP. Use the <code>rust_test</code> module for your unit tests:</p>
<p><em>testing/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: "libleftpad",
    crate_name: "leftpad",
    srcs: ["src/lib.rs"],
}

rust_test {
    name: "libleftpad_test",
    crate_name: "leftpad_test",
    srcs: ["src/lib.rs"],
    host_supported: true,
    test_suites: ["general-tests"],
}
</code></pre>
<p><em>testing/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Left-padding library.

/// Left-pad `s` to `width`.
pub fn leftpad(s: &amp;str, width: usize) -&gt; String {
    format!("{s:&gt;width$}")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn short_string() {
        assert_eq!(leftpad("foo", 5), "  foo");
    }

    #[test]
    fn long_string() {
        assert_eq!(leftpad("foobar", 6), "foobar");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can now run the test with</p>
<pre><code class="language-shell">atest --host libleftpad_test
</code></pre>
<p>The output looks like this:</p>
<pre><code class="language-text">INFO: Elapsed time: 2.666s, Critical Path: 2.40s
INFO: 3 processes: 2 internal, 1 linux-sandbox.
INFO: Build completed successfully, 3 total actions
//comprehensive-rust-android/testing:libleftpad_test_host            PASSED in 2.3s
    PASSED  libleftpad_test.tests::long_string (0.0s)
    PASSED  libleftpad_test.tests::short_string (0.0s)
Test cases: finished with 2 passing and 0 failing out of 2 test cases
</code></pre>
<p>Notice how you only mention the root of the library crate. Tests are found
recursively in nested modules.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="android-testing-googletest"></div><h1 id="android-testing-googletest-googletest"><a class="header" href="#android-testing-googletest-googletest">GoogleTest</a></h1>
<p>The <a href="https://docs.rs/googletest/">GoogleTest</a> crate allows for flexible test
assertions using <em>matchers</em>:</p>
<pre><code class="language-rust ignore">use googletest::prelude::*;

#[googletest::test]
fn test_elements_are() {
    let value = vec!["foo", "bar", "baz"];
    expect_that!(value, elements_are!(eq("foo"), lt("xyz"), starts_with("b")));
}</code></pre>
<p>If we change the last element to <code>"!"</code>, the test fails with a structured error
message pin-pointing the error:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-text">---- test_elements_are stdout ----
Value of: value
Expected: has elements:
  0. is equal to "foo"
  1. is less than "xyz"
  2. starts with prefix "!"
Actual: ["foo", "bar", "baz"],
  where element #2 is "baz", which does not start with "!"
  at src/testing/googletest.rs:6:5
Error: See failure output above
</code></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>GoogleTest is not part of the Rust Playground, so you need to run this example
in a local environment. Use <code>cargo add googletest</code> to quickly add it to an
existing Cargo project.</p>
</li>
<li>
<p>The <code>use googletest::prelude::*;</code> line imports a number of
<a href="https://docs.rs/googletest/latest/googletest/prelude/index.html">commonly used macros and types</a>.</p>
</li>
<li>
<p>This just scratches the surface, there are many builtin matchers. Consider
going through the first chapter of
<a href="https://rust-exercises.com/advanced-testing/">"Advanced testing for Rust applications"</a>,
a self-guided Rust course: it provides a guided introduction to the library,
with exercises to help you get comfortable with <code>googletest</code> macros, its
matchers and its overall philosophy.</p>
</li>
<li>
<p>A particularly nice feature is that mismatches in multi-line strings are shown
as a diff:</p>
</li>
</ul>
<pre><code class="language-rust ignore">#[test]
fn test_multiline_string_diff() {
    let haiku = "Memory safety found,\n\
                 Rust's strong typing guides the way,\n\
                 Secure code you'll write.";
    assert_that!(
        haiku,
        eq("Memory safety found,\n\
            Rust's silly humor guides the way,\n\
            Secure code you'll write.")
    );
}</code></pre>
<p>shows a color-coded diff (colors not shown here):</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-text">    Value of: haiku
Expected: is equal to "Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write."
Actual: "Memory safety found,\nRust's strong typing guides the way,\nSecure code you'll write.",
  which isn't equal to "Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write."
Difference(-actual / +expected):
 Memory safety found,
-Rust's strong typing guides the way,
+Rust's silly humor guides the way,
 Secure code you'll write.
  at src/testing/googletest.rs:17:5
</code></pre>
<ul>
<li>The crate is a Rust port of
<a href="https://google.github.io/googletest/">GoogleTest for C++</a>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="android-testing-mocking"></div><h1 id="android-testing-mocking-mocking"><a class="header" href="#android-testing-mocking-mocking">Mocking</a></h1>
<p>For mocking, <a href="https://docs.rs/mockall/">Mockall</a> is a widely used library. You need to refactor your code
to use traits, which you can then quickly mock:</p>
<pre><code class="language-rust ignore">use std::time::Duration;

#[mockall::automock]
pub trait Pet {
    fn is_hungry(&amp;self, since_last_meal: Duration) -&gt; bool;
}

#[test]
fn test_robot_dog() {
    let mut mock_dog = MockPet::new();
    mock_dog.expect_is_hungry().return_const(true);
    assert_eq!(mock_dog.is_hungry(Duration::from_secs(10)), true);
}</code></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>Mockall is the recommended mocking library in Android (AOSP). There are other
<a href="https://crates.io/keywords/mock">mocking libraries available on crates.io</a>,
in particular in the area of mocking HTTP services. The other mocking
libraries work in a similar fashion as Mockall, meaning that they make it easy
to get a mock implementation of a given trait.</p>
</li>
<li>
<p>Note that mocking is somewhat <em>controversial</em>: mocks allow you to completely
isolate a test from its dependencies. The immediate result is faster and more
stable test execution. On the other hand, the mocks can be configured wrongly
and return output different from what the real dependencies would do.</p>
<p>If at all possible, it is recommended that you use the real dependencies. As
an example, many databases allow you to configure an in-memory backend. This
means that you get the correct behavior in your tests, plus they are fast and
will automatically clean up after themselves.</p>
<p>Similarly, many web frameworks allow you to start an in-process server which
binds to a random port on <code>localhost</code>. Always prefer this over mocking away
the framework since it helps you test your code in the real environment.</p>
</li>
<li>
<p>Mockall is not part of the Rust Playground, so you need to run this example in
a local environment. Use <code>cargo add mockall</code> to quickly add Mockall to an
existing Cargo project.</p>
</li>
<li>
<p>Mockall has a lot more functionality. In particular, you can set up
expectations which depend on the arguments passed. Here we use this to mock a
cat which becomes hungry 3 hours after the last time it was fed:</p>
</li>
</ul>
<pre><code class="language-rust ignore">#[test]
fn test_robot_cat() {
    let mut mock_cat = MockPet::new();
    mock_cat
        .expect_is_hungry()
        .with(mockall::predicate::gt(Duration::from_secs(3 * 3600)))
        .return_const(true);
    mock_cat.expect_is_hungry().return_const(false);
    assert_eq!(mock_cat.is_hungry(Duration::from_secs(1 * 3600)), false);
    assert_eq!(mock_cat.is_hungry(Duration::from_secs(5 * 3600)), true);
}</code></pre>
<ul>
<li>You can use <code>.times(n)</code> to limit the number of times a mock method can be
called to <code>n</code> --- the mock will automatically panic when dropped if this isn't
satisfied.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-logging"></div><h1 id="android-logging-logging"><a class="header" href="#android-logging-logging">Logging</a></h1>
<p>You should use the <code>log</code> crate to automatically log to <code>logcat</code> (on-device) or
<code>stdout</code> (on-host):</p>
<p><em>hello_rust_logs/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: "hello_rust_logs",
    crate_name: "hello_rust_logs",
    srcs: ["src/main.rs"],
    rustlibs: [
        "liblog_rust",
        "liblogger",
    ],
    host_supported: true,
}
</code></pre>
<p><em>hello_rust_logs/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device("rust")
            .with_min_level(log::Level::Trace),
    );
    debug!("Starting program.");
    info!("Things are going fine.");
    error!("Something went wrong!");
}</code></pre>
<p>Build, push, and run the binary on your device:</p>
<pre><code class="language-shell">m hello_rust_logs
adb push "$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs" /data/local/tmp
adb shell /data/local/tmp/hello_rust_logs
</code></pre>
<p>The logs show up in <code>adb logcat</code>:</p>
<pre><code class="language-shell">adb logcat -s rust
</code></pre>
<pre><code class="language-text">09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability"></div><h1 id="android-interoperability-interoperability"><a class="header" href="#android-interoperability-interoperability">Interoperability</a></h1>
<p>Rust has excellent support for interoperability with other languages. This means
that you can:</p>
<ul>
<li>Call Rust functions from other languages.</li>
<li>Call functions written in other languages from Rust.</li>
</ul>
<p>When you call functions in a foreign language we say that you're using a
<em>foreign function interface</em>, also known as FFI.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-with-c"></div><h1 id="android-interoperability-with-c-interoperability-with-c"><a class="header" href="#android-interoperability-with-c-interoperability-with-c">Interoperability with C</a></h1>
<p>Rust has full support for linking object files with a C calling convention.
Similarly, you can export Rust functions and call them from C.</p>
<p>You can do it by hand if you want:</p>
<pre><pre class="playground"><code class="language-rust edition2021">extern "C" {
    fn abs(x: i32) -&gt; i32;
}

fn main() {
    let x = -42;
    // SAFETY: `abs` doesn't have any safety requirements.
    let abs_x = unsafe { abs(x) };
    println!("{x}, {abs_x}");
}</code></pre></pre>
<p>We already saw this in the
<a href="#unsafe-rust-exercise">Safe FFI Wrapper exercise</a>.</p>
<blockquote>
<p>This assumes full knowledge of the target platform. Not recommended for
production.</p>
</blockquote>
<p>We will look at better options next.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-with-c-bindgen"></div><h1 id="android-interoperability-with-c-bindgen-using-bindgen"><a class="header" href="#android-interoperability-with-c-bindgen-using-bindgen">Using Bindgen</a></h1>
<p>The <a href="https://rust-lang.github.io/rust-bindgen/introduction.html">bindgen</a> tool
can auto-generate bindings from a C header file.</p>
<p>First create a small C library:</p>
<p><em>interoperability/bindgen/libbirthday.h</em>:</p>
<pre><code class="language-c">typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);
</code></pre>
<p><em>interoperability/bindgen/libbirthday.c</em>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include "libbirthday.h"

void print_card(const card* card) {
  printf("+--------------\n");
  printf("| Happy Birthday %s!\n", card-&gt;name);
  printf("| Congratulations with the %i years!\n", card-&gt;years);
  printf("+--------------\n");
}
</code></pre>
<p>Add this to your <code>Android.bp</code> file:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">cc_library {
    name: "libbirthday",
    srcs: ["libbirthday.c"],
}
</code></pre>
<p>Create a wrapper header file for the library (not strictly needed in this
example):</p>
<p><em>interoperability/bindgen/libbirthday_wrapper.h</em>:</p>
<pre><code class="language-c">#include "libbirthday.h"
</code></pre>
<p>You can now auto-generate the bindings:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_bindgen {
    name: "libbirthday_bindgen",
    crate_name: "birthday_bindgen",
    wrapper_src: "libbirthday_wrapper.h",
    source_stem: "bindings",
    static_libs: ["libbirthday"],
}
</code></pre>
<p>Finally, we can use the bindings in our Rust program:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: "print_birthday_card",
    srcs: ["main.rs"],
    rustlibs: ["libbirthday_bindgen"],
}
</code></pre>
<p><em>interoperability/bindgen/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new("Peter").unwrap();
    let card = card { name: name.as_ptr(), years: 42 };
    // SAFETY: The pointer we pass is valid because it came from a Rust
    // reference, and the `name` it contains refers to `name` above which also
    // remains valid. `print_card` doesn't store either pointer to use later
    // after it returns.
    unsafe {
        print_card(&amp;card as *const card);
    }
}</code></pre></pre>
<p>Build, push, and run the binary on your device:</p>
<pre><code class="language-shell">m print_birthday_card
adb push "$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card" /data/local/tmp
adb shell /data/local/tmp/print_birthday_card
</code></pre>
<p>Finally, we can run auto-generated tests to ensure the bindings work:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_test {
    name: "libbirthday_bindgen_test",
    srcs: [":libbirthday_bindgen"],
    crate_name: "libbirthday_bindgen_test",
    test_suites: ["general-tests"],
    auto_gen_config: true,
    clippy_lints: "none", // Generated file, skip linting
    lints: "none",
}
</code></pre>
<pre><code class="language-shell">atest libbirthday_bindgen_test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-with-c-rust"></div><h1 id="android-interoperability-with-c-rust-calling-rust"><a class="header" href="#android-interoperability-with-c-rust-calling-rust">Calling Rust</a></h1>
<p>Exporting Rust functions and types to C is easy:</p>
<p><em>interoperability/rust/libanalyze/analyze.rs</em></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
#[no_mangle]
pub extern "C" fn analyze_numbers(x: c_int, y: c_int) {
    if x &lt; y {
        println!("x ({x}) is smallest!");
    } else {
        println!("y ({y}) is probably larger than x ({x})");
    }
}</code></pre></pre>
<p><em>interoperability/rust/libanalyze/analyze.h</em></p>
<pre><code class="language-c">#ifndef ANALYSE_H
#define ANALYSE_H

extern "C" {
void analyze_numbers(int x, int y);
}

#endif
</code></pre>
<p><em>interoperability/rust/libanalyze/Android.bp</em></p>
<pre><code class="language-javascript">rust_ffi {
    name: "libanalyze_ffi",
    crate_name: "analyze_ffi",
    srcs: ["analyze.rs"],
    include_dirs: ["."],
}
</code></pre>
<p>We can now call this from a C binary:</p>
<p><em>interoperability/rust/analyze/main.c</em></p>
<pre><code class="language-c">#include "analyze.h"

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}
</code></pre>
<p><em>interoperability/rust/analyze/Android.bp</em></p>
<pre><code class="language-javascript">cc_binary {
    name: "analyze_numbers",
    srcs: ["main.c"],
    static_libs: ["libanalyze_ffi"],
}
</code></pre>
<p>Build, push, and run the binary on your device:</p>
<pre><code class="language-shell">m analyze_numbers
adb push "$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers" /data/local/tmp
adb shell /data/local/tmp/analyze_numbers
</code></pre>
<details>
<p><code>#[no_mangle]</code> disables Rust's usual name mangling, so the exported symbol will
just be the name of the function. You can also use
<code>#[export_name = "some_name"]</code> to specify whatever name you want.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp"></div><h1 id="android-interoperability-cpp-with-c"><a class="header" href="#android-interoperability-cpp-with-c">With C++</a></h1>
<p>The <a href="https://cxx.rs/">CXX crate</a> makes it possible to do safe interoperability between Rust
and C++.</p>
<p>The overall approach looks like this:</p>
<img src="android/interoperability/cpp/overview.svg">
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-bridge"></div><h1 id="android-interoperability-cpp-bridge-the-bridge-module"><a class="header" href="#android-interoperability-cpp-bridge-the-bridge-module">The Bridge Module</a></h1>
<p>CXX relies on a description of the function signatures that will be exposed from
each language to the other. You provide this description using extern blocks in
a Rust module annotated with the <code>#[cxx::bridge]</code> attribute macro.</p>
<pre><code class="language-rust ignore">#[allow(unsafe_op_in_unsafe_fn)]
#[cxx::bridge(namespace = "org::blobstore")]
mod ffi {
    // Shared structs with fields visible to both languages.
    struct BlobMetadata {
        size: usize,
        tags: Vec&lt;String&gt;,
    }

    // Rust types and signatures exposed to C++.
    extern "Rust" {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    // C++ types and signatures exposed to Rust.
    unsafe extern "C++" {
        include!("include/blobstore.h");

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: Pin&lt;&amp;mut BlobstoreClient&gt;, parts: &amp;mut MultiBuf) -&gt; u64;
        fn tag(self: Pin&lt;&amp;mut BlobstoreClient&gt;, blobid: u64, tag: &amp;str);
        fn metadata(&amp;self, blobid: u64) -&gt; BlobMetadata;
    }
}</code></pre>
<details>
<ul>
<li>The bridge is generally declared in an <code>ffi</code> module within your crate.</li>
<li>From the declarations made in the bridge module, CXX will generate matching
Rust and C++ type/function definitions in order to expose those items to both
languages.</li>
<li>To view the generated Rust code, use <a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> to view the expanded proc
macro. For most of the examples you would use <code>cargo expand ::ffi</code> to expand
just the <code>ffi</code> module (though this doesn't apply for Android projects).</li>
<li>To view the generated C++ code, look in <code>target/cxxbridge</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-rust-bridge"></div><h1 id="android-interoperability-cpp-rust-bridge-rust-bridge-declarations"><a class="header" href="#android-interoperability-cpp-rust-bridge-rust-bridge-declarations">Rust Bridge Declarations</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern "Rust" {
        type MyType; // Opaque type
        fn foo(&amp;self); // Method on `MyType`
        fn bar() -&gt; Box&lt;MyType&gt;; // Free function
    }
}

struct MyType(i32);

impl MyType {
    fn foo(&amp;self) {
        println!("{}", self.0);
    }
}

fn bar() -&gt; Box&lt;MyType&gt; {
    Box::new(MyType(123))
}</code></pre>
<details>
<ul>
<li>Items declared in the <code>extern "Rust"</code> reference items that are in scope in the
parent module.</li>
<li>The CXX code generator uses your <code>extern "Rust"</code> section(s) to produce a C++
header file containing the corresponding C++ declarations. The generated
header has the same path as the Rust source file containing the bridge, except
with a .rs.h file extension.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-generated-cpp"></div><h1 id="android-interoperability-cpp-generated-cpp-generated-c"><a class="header" href="#android-interoperability-cpp-generated-cpp-generated-c">Generated C++</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    // Rust types and signatures exposed to C++.
    extern "Rust" {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }
}</code></pre>
<p>Results in (roughly) the following C++:</p>
<pre><code class="language-cpp">struct MultiBuf final : public ::rust::Opaque {
  ~MultiBuf() = delete;

private:
  friend ::rust::layout;
  struct layout {
    static ::std::size_t size() noexcept;
    static ::std::size_t align() noexcept;
  };
};

::rust::Slice&lt;::std::uint8_t const&gt; next_chunk(::org::blobstore::MultiBuf &amp;buf) noexcept;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-cpp-bridge"></div><h1 id="android-interoperability-cpp-cpp-bridge-c-bridge-declarations"><a class="header" href="#android-interoperability-cpp-cpp-bridge-c-bridge-declarations">C++ Bridge Declarations</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    // C++ types and signatures exposed to Rust.
    unsafe extern "C++" {
        include!("include/blobstore.h");

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: Pin&lt;&amp;mut BlobstoreClient&gt;, parts: &amp;mut MultiBuf) -&gt; u64;
        fn tag(self: Pin&lt;&amp;mut BlobstoreClient&gt;, blobid: u64, tag: &amp;str);
        fn metadata(&amp;self, blobid: u64) -&gt; BlobMetadata;
    }
}</code></pre>
<p>Results in (roughly) the following Rust:</p>
<pre><code class="language-rust ignore">#[repr(C)]
pub struct BlobstoreClient {
    _private: ::cxx::private::Opaque,
}

pub fn new_blobstore_client() -&gt; ::cxx::UniquePtr&lt;BlobstoreClient&gt; {
    extern "C" {
        #[link_name = "org$blobstore$cxxbridge1$new_blobstore_client"]
        fn __new_blobstore_client() -&gt; *mut BlobstoreClient;
    }
    unsafe { ::cxx::UniquePtr::from_raw(__new_blobstore_client()) }
}

impl BlobstoreClient {
    pub fn put(&amp;self, parts: &amp;mut MultiBuf) -&gt; u64 {
        extern "C" {
            #[link_name = "org$blobstore$cxxbridge1$BlobstoreClient$put"]
            fn __put(
                _: &amp;BlobstoreClient,
                parts: *mut ::cxx::core::ffi::c_void,
            ) -&gt; u64;
        }
        unsafe {
            __put(self, parts as *mut MultiBuf as *mut ::cxx::core::ffi::c_void)
        }
    }
}

// ...</code></pre>
<details>
<ul>
<li>The programmer does not need to promise that the signatures they have typed in
are accurate. CXX performs static assertions that the signatures exactly
correspond with what is declared in C++.</li>
<li><code>unsafe extern</code> blocks allow you to declare C++ functions that are safe to
call from Rust.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-shared-types"></div><h1 id="android-interoperability-cpp-shared-types-shared-types"><a class="header" href="#android-interoperability-cpp-shared-types-shared-types">Shared Types</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    #[derive(Clone, Debug, Hash)]
    struct PlayingCard {
        suit: Suit,
        value: u8,  // A=1, J=11, Q=12, K=13
    }

    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}</code></pre>
<details>
<ul>
<li>Only C-like (unit) enums are supported.</li>
<li>A limited number of traits are supported for <code>#[derive()]</code> on shared types.
Corresponding functionality is also generated for the C++ code, e.g. if you
derive <code>Hash</code> also generates an implementation of <code>std::hash</code> for the
corresponding C++ type.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-shared-enums"></div><h1 id="android-interoperability-cpp-shared-enums-shared-enums"><a class="header" href="#android-interoperability-cpp-shared-enums-shared-enums">Shared Enums</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}</code></pre>
<p>Generated Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct Suit {
    pub repr: u8,
}

#[allow(non_upper_case_globals)]
impl Suit {
    pub const Clubs: Self = Suit { repr: 0 };
    pub const Diamonds: Self = Suit { repr: 1 };
    pub const Hearts: Self = Suit { repr: 2 };
    pub const Spades: Self = Suit { repr: 3 };
}
<span class="boring">}</span></code></pre></pre>
<p>Generated C++:</p>
<pre><code class="language-c++">enum class Suit : uint8_t {
  Clubs = 0,
  Diamonds = 1,
  Hearts = 2,
  Spades = 3,
};
</code></pre>
<details>
<ul>
<li>On the Rust side, the code generated for shared enums is actually a struct
wrapping a numeric value. This is because it is not UB in C++ for an enum
class to hold a value different from all of the listed variants, and our Rust
representation needs to have the same behavior.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-rust-result"></div><h1 id="android-interoperability-cpp-rust-result-rust-error-handling"><a class="header" href="#android-interoperability-cpp-rust-result-rust-error-handling">Rust Error Handling</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern "Rust" {
        fn fallible(depth: usize) -&gt; Result&lt;String&gt;;
    }
}

fn fallible(depth: usize) -&gt; anyhow::Result&lt;String&gt; {
    if depth == 0 {
        return Err(anyhow::Error::msg("fallible1 requires depth &gt; 0"));
    }

    Ok("Success!".into())
}</code></pre>
<details>
<ul>
<li>Rust functions that return <code>Result</code> are translated to exceptions on the C++
side.</li>
<li>The exception thrown will always be of type <code>rust::Error</code>, which primarily
exposes a way to get the error message string. The error message will come
from the error type's <code>Display</code> impl.</li>
<li>A panic unwinding from Rust to C++ will always cause the process to
immediately terminate.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-cpp-exception"></div><h1 id="android-interoperability-cpp-cpp-exception-c-error-handling"><a class="header" href="#android-interoperability-cpp-cpp-exception-c-error-handling">C++ Error Handling</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    unsafe extern "C++" {
        include!("example/include/example.h");
        fn fallible(depth: usize) -&gt; Result&lt;String&gt;;
    }
}

fn main() {
    if let Err(err) = ffi::fallible(99) {
        eprintln!("Error: {}", err);
        process::exit(1);
    }
}</code></pre>
<details>
<ul>
<li>C++ functions declared to return a <code>Result</code> will catch any thrown exception on
the C++ side and return it as an <code>Err</code> value to the calling Rust function.</li>
<li>If an exception is thrown from an extern "C++" function that is not declared
by the CXX bridge to return <code>Result</code>, the program calls C++'s
<code>std::terminate</code>. The behavior is equivalent to the same exception being
thrown through a <code>noexcept</code> C++ function.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-type-mapping"></div><h1 id="android-interoperability-cpp-type-mapping-additional-types"><a class="header" href="#android-interoperability-cpp-type-mapping-additional-types">Additional Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Rust Type</th><th>C++ Type</th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>rust::String</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>rust::Str</code></td></tr>
<tr><td><code>CxxString</code></td><td><code>std::string</code></td></tr>
<tr><td><code>&amp;[T]</code>/<code>&amp;mut [T]</code></td><td><code>rust::Slice</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>rust::Box&lt;T&gt;</code></td></tr>
<tr><td><code>UniquePtr&lt;T&gt;</code></td><td><code>std::unique_ptr&lt;T&gt;</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>rust::Vec&lt;T&gt;</code></td></tr>
<tr><td><code>CxxVector&lt;T&gt;</code></td><td><code>std::vector&lt;T&gt;</code></td></tr>
</tbody></table>
</div><details>
<ul>
<li>These types can be used in the fields of shared structs and the arguments and
returns of extern functions.</li>
<li>Note that Rust's <code>String</code> does not map directly to <code>std::string</code>. There are a
few reasons for this:
<ul>
<li><code>std::string</code> does not uphold the UTF-8 invariant that <code>String</code> requires.</li>
<li>The two types have different layouts in memory and so can't be passed
directly between languages.</li>
<li><code>std::string</code> requires move constructors that don't match Rust's move
semantics, so a <code>std::string</code> can't be passed by value to Rust.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-android-build-cpp"></div><h1 id="android-interoperability-cpp-android-build-cpp-building-in-android"><a class="header" href="#android-interoperability-cpp-android-build-cpp-building-in-android">Building in Android</a></h1>
<p>Create a <code>cc_library_static</code> to build the C++ library, including the CXX
generated header and source file.</p>
<pre><code class="language-javascript">cc_library_static {
    name: "libcxx_test_cpp",
    srcs: ["cxx_test.cpp"],
    generated_headers: [
        "cxx-bridge-header",
        "libcxx_test_bridge_header"
    ],
    generated_sources: ["libcxx_test_bridge_code"],
}
</code></pre>
<details>
<ul>
<li>Point out that <code>libcxx_test_bridge_header</code> and <code>libcxx_test_bridge_code</code> are
the dependencies for the CXX-generated C++ bindings. We'll show how these are
setup on the next slide.</li>
<li>Note that you also need to depend on the <code>cxx-bridge-header</code> library in order
to pull in common CXX definitions.</li>
<li>Full docs for using CXX in Android can be found in <a href="https://source.android.com/docs/setup/build/rust/building-rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx">the Android docs</a>. You may
want to share that link with the class so that students know where they can
find these instructions again in the future.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-android-cpp-genrules"></div><h1 id="android-interoperability-cpp-android-cpp-genrules-building-in-android"><a class="header" href="#android-interoperability-cpp-android-cpp-genrules-building-in-android">Building in Android</a></h1>
<p>Create two genrules: One to generate the CXX header, and one to generate the CXX
source file. These are then used as inputs to the <code>cc_library_static</code>.</p>
<pre><code class="language-javascript">// Generate a C++ header containing the C++ bindings
// to the Rust exported functions in lib.rs.
genrule {
    name: "libcxx_test_bridge_header",
    tools: ["cxxbridge"],
    cmd: "$(location cxxbridge) $(in) --header &gt; $(out)",
    srcs: ["lib.rs"],
    out: ["lib.rs.h"],
}

// Generate the C++ code that Rust calls into.
genrule {
    name: "libcxx_test_bridge_code",
    tools: ["cxxbridge"],
    cmd: "$(location cxxbridge) $(in) &gt; $(out)",
    srcs: ["lib.rs"],
    out: ["lib.rs.cc"],
}
</code></pre>
<details>
<ul>
<li>The <code>cxxbridge</code> tool is a standalone tool that generates the C++ side of the
bridge module. It is included in Android and available as a Soong tool.</li>
<li>By convention, if your Rust source file is <code>lib.rs</code> your header file will be
named <code>lib.rs.h</code> and your source file will be named <code>lib.rs.cc</code>. This naming
convention isn't enforced, though.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-cpp-android-build-rust"></div><h1 id="android-interoperability-cpp-android-build-rust-building-in-android"><a class="header" href="#android-interoperability-cpp-android-build-rust-building-in-android">Building in Android</a></h1>
<p>Create a <code>rust_binary</code> that depends on <code>libcxx</code> and your <code>cc_library_static</code>.</p>
<pre><code class="language-javascript">rust_binary {
    name: "cxx_test",
    srcs: ["lib.rs"],
    rustlibs: ["libcxx"],
    static_libs: ["libcxx_test_cpp"],
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="android-interoperability-java"></div><h1 id="android-interoperability-java-interoperability-with-java"><a class="header" href="#android-interoperability-java-interoperability-with-java">Interoperability with Java</a></h1>
<p>Java can load shared objects via
<a href="https://en.wikipedia.org/wiki/Java_Native_Interface">Java Native Interface (JNI)</a>.
The <a href="https://docs.rs/jni/"><code>jni</code> crate</a> allows you to create a compatible
library.</p>
<p>First, we create a Rust function to export to Java:</p>
<p><em>interoperability/java/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Rust &lt;-&gt; Java FFI demo.

use jni::objects::{JClass, JString};
use jni::sys::jstring;
use jni::JNIEnv;

/// HelloWorld::hello method implementation.
#[no_mangle]
pub extern "system" fn Java_HelloWorld_hello(
    env: JNIEnv,
    _class: JClass,
    name: JString,
) -&gt; jstring {
    let input: String = env.get_string(name).unwrap().into();
    let greeting = format!("Hello, {input}!");
    let output = env.new_string(greeting).unwrap();
    output.into_inner()
}
<span class="boring">}</span></code></pre></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_ffi_shared {
    name: "libhello_jni",
    crate_name: "hello_jni",
    srcs: ["src/lib.rs"],
    rustlibs: ["libjni"],
}
</code></pre>
<p>We then call this function from Java:</p>
<p><em>interoperability/java/HelloWorld.java</em>:</p>
<pre><code class="language-java">class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary("hello_jni");
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello("Alice");
        System.out.println(output);
    }
}
</code></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">java_binary {
    name: "helloworld_jni",
    srcs: ["HelloWorld.java"],
    main_class: "HelloWorld",
    required: ["libhello_jni"],
}
</code></pre>
<p>Finally, you can build, sync, and run the binary:</p>
<pre><code class="language-shell">m helloworld_jni
adb sync  # requires adb root &amp;&amp; adb remount
adb shell /system/bin/helloworld_jni
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-android-morning"></div><h1 id="exercises-android-morning-exercises"><a class="header" href="#exercises-android-morning-exercises">Exercises</a></h1>
<p>This is a group exercise: We will look at one of the projects you work with and
try to integrate some Rust into it. Some suggestions:</p>
<ul>
<li>
<p>Call your AIDL service with a client written in Rust.</p>
</li>
<li>
<p>Move a function from your project to Rust and call it.</p>
</li>
</ul>
<details>
<p>No solution is provided here since this is open-ended: it relies on someone in
the class having a piece of code which you can turn in to Rust on the fly.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium"></div><h1 id="chromium-welcome-to-rust-in-chromium"><a class="header" href="#chromium-welcome-to-rust-in-chromium">Welcome to Rust in Chromium</a></h1>
<p>Rust is supported for third-party libraries in Chromium, with first-party glue
code to connect between Rust and existing Chromium C++ code.</p>
<blockquote>
<p>Today, we'll call into Rust to do something silly with strings. If you've got
a corner of the code where you're displaying a UTF8 string to the user, feel
free to follow this recipe in your part of the codebase instead of the exact
part we talk about.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-setup"></div><h1 id="chromium-setup-setup"><a class="header" href="#chromium-setup-setup">Setup</a></h1>
<p>Make sure you can build and run Chromium. Any platform and set of build flags is
OK, so long as your code is relatively recent (commit position 1223636 onwards,
corresponding to November 2023):</p>
<pre><code class="language-shell">gn gen out/Debug
autoninja -C out/Debug chrome
out/Debug/chrome # or on Mac, out/Debug/Chromium.app/Contents/MacOS/Chromium
</code></pre>
<p>(A component, debug build is recommended for quickest iteration time. This is
the default!)</p>
<p>See
<a href="https://www.chromium.org/developers/how-tos/get-the-code/">How to build Chromium</a>
if you aren't already at that point. Be warned: setting up to build Chromium
takes time.</p>
<p>It's also recommended that you have Visual Studio code installed.</p>
<h1 id="chromium-setup-about-the-exercises"><a class="header" href="#chromium-setup-about-the-exercises">About the exercises</a></h1>
<p>This part of the course has a series of exercises which build on each other.
We'll be doing them spread throughout the course instead of just at the end. If
you don't have time to complete a certain part, don't worry: you can catch up in
the next slot.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-cargo"></div><h1 id="chromium-cargo-comparing-chromium-and-cargo-ecosystems"><a class="header" href="#chromium-cargo-comparing-chromium-and-cargo-ecosystems">Comparing Chromium and Cargo Ecosystems</a></h1>
<p>The Rust community typically uses <code>cargo</code> and libraries from <a href="https://crates.io/">crates.io</a>.
Chromium is built using <code>gn</code> and <code>ninja</code> and a curated set of dependencies.</p>
<p>When writing code in Rust, your choices are:</p>
<ul>
<li>Use <code>gn</code> and <code>ninja</code> with the help of the templates from <code>//build/rust/*.gni</code>
(e.g. <code>rust_static_library</code> that we'll meet later). This uses Chromium's
audited toolchain and crates.</li>
<li>Use <code>cargo</code>, but
<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Using-cargo">restrict yourself to Chromium's audited toolchain and crates</a></li>
<li>Use <code>cargo</code>, trusting a <a href="https://rustup.rs/">toolchain</a> and/or
<a href="https://crates.io/">crates downloaded from the internet</a></li>
</ul>
<p>From here on we'll be focusing on <code>gn</code> and <code>ninja</code>, because this is how Rust
code can be built into the Chromium browser. At the same time, Cargo is an
important part of the Rust ecosystem and you should keep it in your toolbox.</p>
<h2 id="chromium-cargo-mini-exercise"><a class="header" href="#chromium-cargo-mini-exercise">Mini exercise</a></h2>
<p>Split into small groups and:</p>
<ul>
<li>Brainstorm scenarios where <code>cargo</code> may offer an advantage and assess the risk
profile of these scenarios.</li>
<li>Discuss which tools, libraries, and groups of people need to be trusted when
using <code>gn</code> and <code>ninja</code>, offline <code>cargo</code>, etc.</li>
</ul>
<details>
<p>Ask students to avoid peeking at the speaker notes before completing the
exercise. Assuming folks taking the course are physically together, ask them to
discuss in small groups of 3-4 people.</p>
<p>Notes/hints related to the first part of the exercise ("scenarios where Cargo
may offer an advantage"):</p>
<ul>
<li>
<p>It's fantastic that when writing a tool, or prototyping a part of Chromium,
one has access to the rich ecosystem of crates.io libraries. There is a crate
for almost anything and they are usually quite pleasant to use. (<code>clap</code> for
command-line parsing, <code>serde</code> for serializing/deserializing to/from various
formats, <code>itertools</code> for working with iterators, etc.).</p>
<ul>
<li><code>cargo</code> makes it easy to try a library (just add a single line to
<code>Cargo.toml</code> and start writing code)</li>
<li>It may be worth comparing how CPAN helped make <code>perl</code> a popular choice. Or
comparing with <code>python</code> + <code>pip</code>.</li>
</ul>
</li>
<li>
<p>Development experience is made really nice not only by core Rust tools (e.g.
using <code>rustup</code> to switch to a different <code>rustc</code> version when testing a crate
that needs to work on nightly, current stable, and older stable) but also by
an ecosystem of third-party tools (e.g. Mozilla provides <code>cargo vet</code> for
streamlining and sharing security audits; <code>criterion</code> crate gives a
streamlined way to run benchmarks).</p>
<ul>
<li><code>cargo</code> makes it easy to add a tool via <code>cargo install --locked cargo-vet</code>.</li>
<li>It may be worth comparing with Chrome Extensions or VScode extensions.</li>
</ul>
</li>
<li>
<p>Broad, generic examples of projects where <code>cargo</code> may be the right choice:</p>
<ul>
<li>Perhaps surprisingly, Rust is becoming increasingly popular in the industry
for writing command line tools. The breadth and ergonomics of libraries is
comparable to Python, while being more robust (thanks to the rich
typesystem) and running faster (as a compiled, rather than interpreted
language).</li>
<li>Participating in the Rust ecosystem requires using standard Rust tools like
Cargo. Libraries that want to get external contributions, and want to be
used outside of Chromium (e.g. in Bazel or Android/Soong build environments)
should probably use Cargo.</li>
</ul>
</li>
<li>
<p>Examples of Chromium-related projects that are <code>cargo</code>-based:</p>
<ul>
<li><code>serde_json_lenient</code> (experimented with in other parts of Google which
resulted in PRs with performance improvements)</li>
<li>Fontations libraries like <code>font-types</code></li>
<li><code>gnrt</code> tool (we will meet it later in the course) which depends on <code>clap</code>
for command-line parsing and on <code>toml</code> for configuration files.
<ul>
<li>Disclaimer: a unique reason for using <code>cargo</code> was unavailability of <code>gn</code>
when building and bootstrapping Rust standard library when building Rust
toolchain.</li>
<li><code>run_gnrt.py</code> uses Chromium's copy of <code>cargo</code> and <code>rustc</code>. <code>gnrt</code> depends
on third-party libraries downloaded from the internet, but <code>run_gnrt.py</code>
asks <code>cargo</code> that only <code>--locked</code> content is allowed via <code>Cargo.lock</code>.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Students may identify the following items as being implicitly or explicitly
trusted:</p>
<ul>
<li><code>rustc</code> (the Rust compiler) which in turn depends on the LLVM libraries, the
Clang compiler, the <code>rustc</code> sources (fetched from GitHub, reviewed by Rust
compiler team), binary Rust compiler downloaded for bootstrapping</li>
<li><code>rustup</code> (it may be worth pointing out that <code>rustup</code> is developed under the
umbrella of the https://github.com/rust-lang/ organization - same as <code>rustc</code>)</li>
<li><code>cargo</code>, <code>rustfmt</code>, etc.</li>
<li>Various internal infrastructure (bots that build <code>rustc</code>, system for
distributing the prebuilt toolchain to Chromium engineers, etc.)</li>
<li>Cargo tools like <code>cargo audit</code>, <code>cargo vet</code>, etc.</li>
<li>Rust libraries vendored into <code>//third_party/rust</code> (audited by
security@chromium.org)</li>
<li>Other Rust libraries (some niche, some quite popular and commonly used)</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-policy"></div><h1 id="chromium-policy-chromium-rust-policy"><a class="header" href="#chromium-policy-chromium-rust-policy">Chromium Rust policy</a></h1>
<p>Chromium does not yet allow first-party Rust except in rare cases as approved by
Chromium's
<a href="https://source.chromium.org/chromium/chromium/src/+/main:ATL_OWNERS">Area Tech Leads</a>.</p>
<p>Chromium's policy on third party libraries is outlined
<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#rust">here</a> -
Rust is allowed for third party libraries under various circumstances, including
if they're the best option for performance or for security.</p>
<p>Very few Rust libraries directly expose a C/C++ API, so that means that nearly
all such libraries will require a small amount of first-party glue code.</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="640" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="chromium-policy-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="chromium-policy-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="chromium-policy-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="chromium-policy-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="chromium-policy-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="640" height="208"></rect><rect x="20" y="88" width="128" height="64" class="solid nofill" rx="0"></rect><circle cx="100" cy="120" r="3" class="nofill"></circle><rect x="276" y="88" width="136" height="64" class="solid nofill" rx="0"></rect><circle cx="396" cy="120" r="3" class="nofill"></circle><rect x="500" y="88" width="112" height="64" class="solid nofill" rx="0"></rect><text x="258" y="12" >Rust</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><text x="498" y="60" >Existing</text><text x="498" y="76" >crate</text><text x="178" y="140" >Language</text><text x="426" y="140" >Crate</text><text x="178" y="156" >boundary</text><text x="426" y="156" >API</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><text x="18" y="60" >Existing</text><text x="90" y="60" >Chromium</text><text x="282" y="60" >Chromium</text><text x="354" y="60" >Rust</text><text x="570" y="60" >Rust</text><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="280" y1="184" x2="288" y2="184" class="solid"></line><line x1="296" y1="184" x2="304" y2="184" class="solid"></line><line x1="312" y1="184" x2="320" y2="184" class="solid"></line><line x1="328" y1="184" x2="336" y2="184" class="solid"></line><line x1="344" y1="184" x2="352" y2="184" class="solid"></line><line x1="360" y1="184" x2="368" y2="184" class="solid"></line><line x1="376" y1="184" x2="384" y2="184" class="solid"></line><line x1="392" y1="184" x2="400" y2="184" class="solid"></line><line x1="408" y1="184" x2="416" y2="184" class="solid"></line><line x1="424" y1="184" x2="432" y2="184" class="solid"></line><line x1="440" y1="184" x2="448" y2="184" class="solid"></line><line x1="456" y1="184" x2="464" y2="184" class="solid"></line><line x1="472" y1="184" x2="480" y2="184" class="solid"></line><line x1="488" y1="184" x2="496" y2="184" class="solid"></line><line x1="504" y1="184" x2="512" y2="184" class="solid"></line><line x1="520" y1="184" x2="528" y2="184" class="solid"></line><line x1="536" y1="184" x2="544" y2="184" class="solid"></line><line x1="552" y1="184" x2="560" y2="184" class="solid"></line><line x1="568" y1="184" x2="576" y2="184" class="solid"></line><line x1="584" y1="184" x2="592" y2="184" class="solid"></line><line x1="600" y1="184" x2="608" y2="184" class="solid"></line><text x="2" y="12" >C++</text><text x="18" y="76" >C++</text><text x="282" y="76" >wrapper</text><g><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><path d="M 160,24 A 4,4 0,0,1 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="180" class="broken"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><path d="M 164,180 A 4,4 0,0,1 160,184" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="180" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,180 A 4,4 0,0,0 264,184" class="nofill"></path><line x1="264" y1="184" x2="272" y2="184" class="solid"></line></g><g><line x1="104" y1="120" x2="288" y2="120" class="solid"></line><polygon points="288,116 296,120 288,124" class="filled"></polygon></g><g><line x1="400" y1="120" x2="520" y2="120" class="solid"></line><polygon points="520,116 528,120 520,124" class="filled"></polygon></g><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><path d="M 624,24 A 4,4 0,0,1 628,28" class="nofill"></path><line x1="628" y1="28" x2="628" y2="180" class="broken"></line><line x1="616" y1="184" x2="624" y2="184" class="solid"></line><path d="M 628,180 A 4,4 0,0,1 624,184" class="nofill"></path></g></svg></div>
<blockquote>
<p>First-party Rust glue code for a particular third-party crate should normally
be kept in <code>third_party/rust/&lt;crate&gt;/&lt;version&gt;/wrapper</code>.</p>
</blockquote>
<p>Because of this, today's course will be heavily focused on:</p>
<ul>
<li>Bringing in third-party Rust libraries ("crates")</li>
<li>Writing glue code to be able to use those crates from Chromium C++.</li>
</ul>
<p>If this policy changes over time, the course will evolve to keep up.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-build-rules"></div><h1 id="chromium-build-rules-build-rules"><a class="header" href="#chromium-build-rules-build-rules">Build rules</a></h1>
<p>Rust code is usually built using <code>cargo</code>. Chromium builds with <code>gn</code> and <code>ninja</code>
for efficiency --- its static rules allow maximum parallelism. Rust is no
exception.</p>
<h2 id="chromium-build-rules-adding-rust-code-to-chromium"><a class="header" href="#chromium-build-rules-adding-rust-code-to-chromium">Adding Rust code to Chromium</a></h2>
<p>In some existing Chromium <code>BUILD.gn</code> file, declare a <code>rust_static_library</code>:</p>
<pre><code class="language-gn">import("//build/rust/rust_static_library.gni")

rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [ "lib.rs" ]
}
</code></pre>
<p>You can also add <code>deps</code> on other Rust targets. Later we'll use this to depend
upon third party code.</p>
<details>
<p>You must specify <em>both</em> the crate root, <em>and</em> a full list of sources. The
<code>crate_root</code> is the file given to the Rust compiler representing the root file
of the compilation unit --- typically <code>lib.rs</code>. <code>sources</code> is a complete list of
all source files which <code>ninja</code> needs in order to determine when rebuilds are
necessary.</p>
<p>(There's no such thing as a Rust <code>source_set</code>, because in Rust, an entire crate
is a compilation unit. A <code>static_library</code> is the smallest unit.)</p>
<p>Students might be wondering why we need a gn template, rather than using
<a href="https://gn.googlesource.com/gn/+/main/docs/reference.md#func_static_library">gn's built-in support for Rust static libraries</a>. The answer is that this
template provides support for CXX interop, Rust features, and unit tests, some
of which we'll use later.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-build-rules-unsafe"></div><h1 id="chromium-build-rules-unsafe-including-unsafe-rust-code"><a class="header" href="#chromium-build-rules-unsafe-including-unsafe-rust-code">Including <code>unsafe</code> Rust Code</a></h1>
<p>Unsafe Rust code is forbidden in <code>rust_static_library</code> by default --- it won't
compile. If you need unsafe Rust code, add <code>allow_unsafe = true</code> to the gn
target. (Later in the course we'll see circumstances where this is necessary.)</p>
<pre><code class="language-gn">import("//build/rust/rust_static_library.gni")

rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [
    "lib.rs",
    "hippopotamus.rs"
  ]
  allow_unsafe = true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-build-rules-depending"></div><h1 id="chromium-build-rules-depending-depending-on-rust-code-from-chromium-c"><a class="header" href="#chromium-build-rules-depending-depending-on-rust-code-from-chromium-c">Depending on Rust Code from Chromium C++</a></h1>
<p>Simply add the above target to the <code>deps</code> of some Chromium C++ target.</p>
<pre><code class="language-gn">import("//build/rust/rust_static_library.gni")

rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [ "lib.rs" ]
}

# or source_set, static_library etc.
component("preexisting_cpp") {
  deps = [ ":my_rust_lib" ]
}
</code></pre>
<details>
We'll see that this relationship only works if the Rust code exposes plain C APIs
which can be called from C++, or if we use a C++/Rust interop tool.
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-build-rules-vscode"></div><h1 id="chromium-build-rules-vscode-visual-studio-code"><a class="header" href="#chromium-build-rules-vscode-visual-studio-code">Visual Studio Code</a></h1>
<p>Types are elided in Rust code, which makes a good IDE even more useful than for
C++. Visual Studio code works well for Rust in Chromium. To use it,</p>
<ul>
<li>Ensure your VSCode has the <code>rust-analyzer</code> extension, not earlier forms of
Rust support</li>
<li><code>gn gen out/Debug --export-rust-project</code> (or equivalent for your output
directory)</li>
<li><code>ln -s out/Debug/rust-project.json rust-project.json</code></li>
</ul>
<img src="chromium/build-rules/vscode.png" style="border: 1px solid black;" alt="Example screenshot from VSCode">
<details>
<p>A demo of some of the code annotation and exploration features of rust-analyzer
might be beneficial if the audience are naturally skeptical of IDEs.</p>
<p>The following steps may help with the demo (but feel free to instead use a piece
of Chromium-related Rust that you are most familiar with):</p>
<ul>
<li>Open <code>components/qr_code_generator/qr_code_generator_ffi_glue.rs</code></li>
<li>Place the cursor over the <code>QrCode::new</code> call (around line 26) in
`qr_code_generator_ffi_glue.rs</li>
<li>Demo <strong>show documentation</strong> (typical bindings: vscode = ctrl k i; vim/CoC =
K).</li>
<li>Demo <strong>go to definition</strong> (typical bindings: vscode = F12; vim/CoC = g d).
(This will take you to <code>//third_party/rust/.../qr_code-.../src/lib.rs</code>.)</li>
<li>Demo <strong>outline</strong> and navigate to the <code>QrCode::with_bits</code> method (around line
164; the outline is in the file explorer pane in vscode; typical vim/CoC
bindings = space o)</li>
<li>Demo <strong>type annotations</strong> (there are quite a few nice examples in the
<code>QrCode::with_bits</code> method)</li>
</ul>
<p>It may be worth pointing out that <code>gn gen ... --export-rust-project</code> will need
to be rerun after editing <code>BUILD.gn</code> files (which we will do a few times
throughout the exercises in this session).</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-chromium-build-rules"></div><h1 id="exercises-chromium-build-rules-build-rules-exercise"><a class="header" href="#exercises-chromium-build-rules-build-rules-exercise">Build rules exercise</a></h1>
<p>In your Chromium build, add a new Rust target to <code>//ui/base/BUILD.gn</code>
containing:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn hello_from_rust() {
    println!("Hello from Rust!")
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Important</strong>: note that <code>no_mangle</code> here is considered a type of unsafety by
the Rust compiler, so you'll need to allow unsafe code in your <code>gn</code> target.</p>
<p>Add this new Rust target as a dependency of <code>//ui/base:base</code>. Declare this
function at the top of <code>ui/base/resource/resource_bundle.cc</code> (later, we'll see
how this can be automated by bindings generation tools):</p>
<pre><code class="language-cpp">extern "C" void hello_from_rust();
</code></pre>
<p>Call this function from somewhere in <code>ui/base/resource/resource_bundle.cc</code> - we
suggest the top of <code>ResourceBundle::MaybeMangleLocalizedString</code>. Build and run
Chromium, and ensure that "Hello from Rust!" is printed lots of times.</p>
<p>If you use VSCode, now set up Rust to work well in VSCode. It will be useful in
subsequent exercises. If you've succeeded, you will be able to use right-click
"Go to definition" on <code>println!</code>.</p>
<h2 id="exercises-chromium-build-rules-where-to-find-help"><a class="header" href="#exercises-chromium-build-rules-where-to-find-help">Where to find help</a></h2>
<ul>
<li>The options available to the <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16"><code>rust_static_library</code> gn template</a></li>
<li>Information about <a href="https://doc.rust-lang.org/beta/reference/abi.html#the-no_mangle-attribute"><code>#[no_mangle]</code></a></li>
<li>Information about <a href="https://doc.rust-lang.org/std/keyword.extern.html"><code>extern "C"</code></a></li>
<li>Information about gn's <a href="https://gn.googlesource.com/gn/+/main/docs/reference.md#compilation-database"><code>--export-rust-project</code></a> switch</li>
<li><a href="https://code.visualstudio.com/docs/languages/rust">How to install rust-analyzer in VSCode</a></li>
</ul>
<details>
It's really important that students get this running, because future exercises
will build on it.
<p>This example is unusual because it boils down to the lowest-common-denominator
interop language, C. Both C++ and Rust can natively declare and call C ABI
functions. Later in the course, we'll connect C++ directly to Rust.</p>
<p><code>allow_unsafe = true</code> is required here because <code>#[no_mangle]</code> might allow Rust
to generate two functions with the same name, and Rust can no longer guarantee
that the right one is called.</p>
<p>If you need a pure Rust executable, you can also do that using the
<code>rust_executable</code> gn template.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-testing"></div><h1 id="chromium-testing-testing"><a class="header" href="#chromium-testing-testing">Testing</a></h1>
<p>Rust community typically authors unit tests in a module placed in the same
source file as the code being tested. This was covered <a href="#testing">earlier</a>
in the course and looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn my_test() {
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In Chromium we place unit tests in a separate source file and we continue to
follow this practice for Rust --- this makes tests consistently discoverable and
helps to avoid rebuilding <code>.rs</code> files a second time (in the <code>test</code>
configuration).</p>
<p>This results in the following options for testing Rust code in Chromium:</p>
<ul>
<li>Native Rust tests (i.e. <code>#[test]</code>). Discouraged outside of
<code>//third_party/rust</code>.</li>
<li><code>gtest</code> tests authored in C++ and exercising Rust via FFI calls. Sufficient
when Rust code is just a thin FFI layer and the existing unit tests provide
sufficient coverage for the feature.</li>
<li><code>gtest</code> tests authored in Rust and using the crate under test through its
public API (using <code>pub mod for_testing { ... }</code> if needed). This is the
subject of the next few slides.</li>
</ul>
<details>
<p>Mention that native Rust tests of third-party crates should eventually be
exercised by Chromium bots. (Such testing is needed rarely --- only after adding
or updating third-party crates.)</p>
<p>Some examples may help illustrate when C++ <code>gtest</code> vs Rust <code>gtest</code> should be
used:</p>
<ul>
<li>
<p>QR has very little functionality in the first-party Rust layer (it's just a
thin FFI glue) and therefore uses the existing C++ unit tests for testing both
the C++ and the Rust implementation (parameterizing the tests so they enable
or disable Rust using a <code>ScopedFeatureList</code>).</p>
</li>
<li>
<p>Hypothetical/WIP PNG integration may need to implement memory-safe
implementation of pixel transformations that are provided by <code>libpng</code> but
missing in the <code>png</code> crate - e.g. RGBA =&gt; BGRA, or gamma correction. Such
functionality may benefit from separate tests authored in Rust.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-testing-rust-gtest-interop"></div><h1 id="chromium-testing-rust-gtest-interop-rust_gtest_interop-library"><a class="header" href="#chromium-testing-rust-gtest-interop-rust_gtest_interop-library"><code>rust_gtest_interop</code> Library</a></h1>
<p>The <a href="https://chromium.googlesource.com/chromium/src/+/main/testing/rust_gtest_interop/README.md"><code>rust_gtest_interop</code></a> library provides a way to:</p>
<ul>
<li>Use a Rust function as a <code>gtest</code> testcase (using the <code>#[gtest(...)]</code>
attribute)</li>
<li>Use <code>expect_eq!</code> and similar macros (similar to <code>assert_eq!</code> but not panicking
and not terminating the test when the assertion fails).</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">use rust_gtest_interop::prelude::*;

#[gtest(MyRustTestSuite, MyAdditionTest)]
fn test_addition() {
    expect_eq!(2 + 2, 4);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-testing-build-gn"></div><h1 id="chromium-testing-build-gn-gn-rules-for-rust-tests"><a class="header" href="#chromium-testing-build-gn-gn-rules-for-rust-tests">GN Rules for Rust Tests</a></h1>
<p>The simplest way to build Rust <code>gtest</code> tests is to add them to an existing test
binary that already contains tests authored in C++. For example:</p>
<pre><code class="language-gn">test("ui_base_unittests") {
  ...
  sources += [ "my_rust_lib_unittest.rs" ]
  deps += [ ":my_rust_lib" ]
}
</code></pre>
<p>Authoring Rust tests in a separate <code>static_library</code> also works, but requires
manually declaring the dependency on the support libraries:</p>
<pre><code class="language-gn">rust_static_library("my_rust_lib_unittests") {
  testonly = true
  is_gtest_unittests = true
  crate_root = "my_rust_lib_unittest.rs"
  sources = [ "my_rust_lib_unittest.rs" ]
  deps = [
    ":my_rust_lib",
    "//testing/rust_gtest_interop",
  ]
}

test("ui_base_unittests") {
  ...
  deps += [ ":my_rust_lib_unittests" ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-testing-chromium-import-macro"></div><h1 id="chromium-testing-chromium-import-macro-chromiumimport-macro"><a class="header" href="#chromium-testing-chromium-import-macro-chromiumimport-macro"><code>chromium::import!</code> Macro</a></h1>
<p>After adding <code>:my_rust_lib</code> to GN <code>deps</code>, we still need to learn how to import
and use <code>my_rust_lib</code> from <code>my_rust_lib_unittest.rs</code>. We haven't provided an
explicit <code>crate_name</code> for <code>my_rust_lib</code> so its crate name is computed based on
the full target path and name. Fortunately we can avoid working with such an
unwieldy name by using the <code>chromium::import!</code> macro from the
automatically-imported <code>chromium</code> crate:</p>
<pre><code class="language-rust ignore">chromium::import! {
    "//ui/base:my_rust_lib";
}

use my_rust_lib::my_function_under_test;</code></pre>
<p>Under the covers the macro expands to something similar to:</p>
<pre><code class="language-rust ignore">extern crate ui_sbase_cmy_urust_ulib as my_rust_lib;

use my_rust_lib::my_function_under_test;</code></pre>
<p>More information can be found in <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/chromium_prelude/chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:third_party&amp;ss=chromium%2Fchromium%2Fsrc">the doc comment</a> of the <code>chromium::import</code>
macro.</p>
<details>
<p><code>rust_static_library</code> supports specifying an explicit name via <code>crate_name</code>
property, but doing this is discouraged. And it is discouraged because the crate
name has to be globally unique. crates.io guarantees uniqueness of its crate
names so <code>cargo_crate</code> GN targets (generated by the <code>gnrt</code> tool covered in a
later section) use short crate names.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-chromium-testing"></div><h1 id="exercises-chromium-testing-testing-exercise"><a class="header" href="#exercises-chromium-testing-testing-exercise">Testing exercise</a></h1>
<p>Time for another exercise!</p>
<p>In your Chromium build:</p>
<ul>
<li>Add a testable function next to <code>hello_from_rust</code>. Some suggestions: adding
two integers received as arguments, computing the nth Fibonacci number,
summing integers in a slice, etc.</li>
<li>Add a separate <code>..._unittest.rs</code> file with a test for the new function.</li>
<li>Add the new tests to <code>BUILD.gn</code>.</li>
<li>Build the tests, run them, and verify that the new test works.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp"></div><h1 id="chromium-interoperability-with-cpp-interoperability-with-c"><a class="header" href="#chromium-interoperability-with-cpp-interoperability-with-c">Interoperability with C++</a></h1>
<p>The Rust community offers multiple options for C++/Rust interop, with new tools
being developed all the time. At the moment, Chromium uses a tool called CXX.</p>
<p>You describe your whole language boundary in an interface definition language
(which looks a lot like Rust) and then CXX tools generate declarations for
functions and types in both Rust and C++.</p>
<img src="chromium/../android/interoperability/cpp/overview.svg" alt="Overview diagram of cxx, showing that the same interface definition is used to create both C++ and Rust side code which then communicate via a lowest common denominator C API">
<p>See the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a> for a full example of using this.</p>
<details>
<p>Talk through the diagram. Explain that behind the scenes, this is doing just the
same as you previously did. Point out that automating the process has the
following benefits:</p>
<ul>
<li>The tool guarantees that the C++ and Rust sides match (e.g. you get compile
errors if the <code>#[cxx::bridge]</code> doesn't match the actual C++ or Rust
definitions, but with out-of-sync manual bindings you'd get Undefined
Behavior)</li>
<li>The tool automates generation of FFI thunks (small, C-ABI-compatible, free
functions) for non-C features (e.g. enabling FFI calls into Rust or C++
methods; manual bindings would require authoring such top-level, free
functions manually)</li>
<li>The tool and the library can handle a set of core types - for example:
<ul>
<li><code>&amp;[T]</code> can be passed across the FFI boundary, even though it doesn't
guarantee any particular ABI or memory layout. With manual bindings
<code>std::span&lt;T&gt;</code> / <code>&amp;[T]</code> have to be manually destructured and rebuilt out of
a pointer and length - this is error-prone given that each language
represents empty slices slightly differently)</li>
<li>Smart pointers like <code>std::unique_ptr&lt;T&gt;</code>, <code>std::shared_ptr&lt;T&gt;</code>, and/or <code>Box</code>
are natively supported. With manual bindings, one would have to pass
C-ABI-compatible raw pointers, which would increase lifetime and
memory-safety risks.</li>
<li><code>rust::String</code> and <code>CxxString</code> types understand and maintain differences in
string representation across the languages (e.g. <code>rust::String::lossy</code> can
build a Rust string from non-UTF8 input and <code>rust::String::c_str</code> can
NUL-terminate a string).</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp-example-bindings"></div><h1 id="chromium-interoperability-with-cpp-example-bindings-example-bindings"><a class="header" href="#chromium-interoperability-with-cpp-example-bindings-example-bindings">Example Bindings</a></h1>
<p>CXX requires that the whole C++/Rust boundary is declared in <code>cxx::bridge</code>
modules inside <code>.rs</code> source code.</p>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern "Rust" {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    unsafe extern "C++" {
        include!("example/include/blobstore.h");

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: &amp;BlobstoreClient, buf: &amp;mut MultiBuf) -&gt; Result&lt;u64&gt;;
    }
}

// Definitions of Rust types and functions go here</code></pre>
<details>
<p>Point out:</p>
<ul>
<li>Although this looks like a regular Rust <code>mod</code>, the <code>#[cxx::bridge]</code> procedural
macro does complex things to it. The generated code is quite a bit more
sophisticated - though this does still result in a <code>mod</code> called <code>ffi</code> in your
code.</li>
<li>Native support for C++'s <code>std::unique_ptr</code> in Rust</li>
<li>Native support for Rust slices in C++</li>
<li>Calls from C++ to Rust, and Rust types (in the top part)</li>
<li>Calls from Rust to C++, and C++ types (in the bottom part)</li>
</ul>
<p><strong>Common misconception</strong>: It <em>looks</em> like a C++ header is being parsed by Rust,
but this is misleading. This header is never interpreted by Rust, but simply
<code>#include</code>d in the generated C++ code for the benefit of C++ compilers.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp-limitations-of-cxx"></div><h2 id="chromium-interoperability-with-cpp-limitations-of-cxx-limitations-of-cxx"><a class="header" href="#chromium-interoperability-with-cpp-limitations-of-cxx-limitations-of-cxx">Limitations of CXX</a></h2>
<p>By far the most useful page when using CXX is the <a href="https://cxx.rs/bindings.html">type reference</a>.</p>
<p>CXX fundamentally suits cases where:</p>
<ul>
<li>Your Rust-C++ interface is sufficiently simple that you can declare all of it.</li>
<li>You're using only the types natively supported by CXX already, for example
<code>std::unique_ptr</code>, <code>std::string</code>, <code>&amp;[u8]</code> etc.</li>
</ul>
<p>It has many limitations --- for example lack of support for Rust's <code>Option</code>
type.</p>
<p>These limitations constrain us to using Rust in Chromium only for well isolated
"leaf nodes" rather than for arbitrary Rust-C++ interop. When considering a
use-case for Rust in Chromium, a good starting point is to draft the CXX
bindings for the language boundary to see if it appears simple enough.</p>
<details>
In addition, right now, Rust code in one component cannot depend on Rust
code in another, due to linking details in our component build. That's another
reason to restrict Rust to use in leaf nodes.
<p>You should also discuss some of the other sticky points with CXX, for example:</p>
<ul>
<li>Its error handling is based around C++ exceptions (given on the next slide)</li>
<li>Function pointers are awkward to use.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp-error-handling"></div><h1 id="chromium-interoperability-with-cpp-error-handling-cxx-error-handling"><a class="header" href="#chromium-interoperability-with-cpp-error-handling-cxx-error-handling">CXX Error Handling</a></h1>
<p>CXX's <a href="https://cxx.rs/binding/result.html">support for <code>Result&lt;T,E&gt;</code></a> relies on C++ exceptions, so we can't use
that in Chromium. Alternatives:</p>
<ul>
<li>
<p>The <code>T</code> part of <code>Result&lt;T, E&gt;</code> can be:</p>
<ul>
<li>Returned via out parameters (e.g. via <code>&amp;mut T</code>). This requires that <code>T</code> can
be passed across the FFI boundary - for example <code>T</code> has to be:
<ul>
<li>A primitive type (like <code>u32</code> or <code>usize</code>)</li>
<li>A type natively supported by <code>cxx</code> (like <code>UniquePtr&lt;T&gt;</code>) that has a
suitable default value to use in a failure case (<em>unlike</em> <code>Box&lt;T&gt;</code>).</li>
</ul>
</li>
<li>Retained on the Rust side, and exposed via reference. This may be needed
when <code>T</code> is a Rust type, which cannot be passed across the FFI boundary, and
cannot be stored in <code>UniquePtr&lt;T&gt;</code>.</li>
</ul>
</li>
<li>
<p>The <code>E</code> part of <code>Result&lt;T, E&gt;</code> can be:</p>
<ul>
<li>Returned as a boolean (e.g. <code>true</code> representing success, and <code>false</code>
representing failure)</li>
<li>Preserving error details is in theory possible, but so far hasn't been
needed in practice.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp-error-handling-qr"></div><h1 id="chromium-interoperability-with-cpp-error-handling-qr-cxx-error-handling-qr-example"><a class="header" href="#chromium-interoperability-with-cpp-error-handling-qr-cxx-error-handling-qr-example">CXX Error Handling: QR Example</a></h1>
<p>The QR code generator is <a href="https://source.chromium.org/chromium/chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue.rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca">an example</a> where a boolean is used to communicate
success vs failure, and where the successful result can be passed across the FFI
boundary:</p>
<pre><code class="language-rust ignore">#[cxx::bridge(namespace = "qr_code_generator")]
mod ffi {
    extern "Rust" {
        fn generate_qr_code_using_rust(
            data: &amp;[u8],
            min_version: i16,
            out_pixels: Pin&lt;&amp;mut CxxVector&lt;u8&gt;&gt;,
            out_qr_size: &amp;mut usize,
        ) -&gt; bool;
    }
}</code></pre>
<details>
<p>Students may be curious about the semantics of the <code>out_qr_size</code> output. This is
not the size of the vector, but the size of the QR code (and admittedly it is a
bit redundant - this is the square root of the size of the vector).</p>
<p>It may be worth pointing out the importance of initializing <code>out_qr_size</code> before
calling into the Rust function. Creation of a Rust reference that points to
uninitialized memory results in Undefined Behavior (unlike in C++, when only the
act of dereferencing such memory results in UB).</p>
<p>If students ask about <code>Pin</code>, then explain why CXX needs it for mutable
references to C++ data: the answer is that C++ data can‚Äôt be moved around like
Rust data, because it may contain self-referential pointers.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp-error-handling-png"></div><h1 id="chromium-interoperability-with-cpp-error-handling-png-cxx-error-handling-png-example"><a class="header" href="#chromium-interoperability-with-cpp-error-handling-png-cxx-error-handling-png-example">CXX Error Handling: PNG Example</a></h1>
<p>A prototype of a PNG decoder illustrates what can be done when the successful
result cannot be passed across the FFI boundary:</p>
<pre><code class="language-rust ignore">#[cxx::bridge(namespace = "gfx::rust_bindings")]
mod ffi {
    extern "Rust" {
        /// This returns an FFI-friendly equivalent of `Result&lt;PngReader&lt;'a&gt;,
        /// ()&gt;`.
        fn new_png_reader&lt;'a&gt;(input: &amp;'a [u8]) -&gt; Box&lt;ResultOfPngReader&lt;'a&gt;&gt;;

        /// C++ bindings for the `crate::png::ResultOfPngReader` type.
        type ResultOfPngReader&lt;'a&gt;;
        fn is_err(self: &amp;ResultOfPngReader) -&gt; bool;
        fn unwrap_as_mut&lt;'a, 'b&gt;(
            self: &amp;'b mut ResultOfPngReader&lt;'a&gt;,
        ) -&gt; &amp;'b mut PngReader&lt;'a&gt;;

        /// C++ bindings for the `crate::png::PngReader` type.
        type PngReader&lt;'a&gt;;
        fn height(self: &amp;PngReader) -&gt; u32;
        fn width(self: &amp;PngReader) -&gt; u32;
        fn read_rgba8(self: &amp;mut PngReader, output: &amp;mut [u8]) -&gt; bool;
    }
}</code></pre>
<details>
<p><code>PngReader</code> and <code>ResultOfPngReader</code> are Rust types --- objects of these types
cannot cross the FFI boundary without indirection of a <code>Box&lt;T&gt;</code>. We can't have
an <code>out_parameter: &amp;mut PngReader</code>, because CXX doesn't allow C++ to store Rust
objects by value.</p>
<p>This example illustrates that even though CXX doesn't support arbitrary generics
nor templates, we can still pass them across the FFI boundary by manually
specializing / monomorphizing them into a non-generic type. In the example
<code>ResultOfPngReader</code> is a non-generic type that forwards into appropriate methods
of <code>Result&lt;T, E&gt;</code> (e.g. into <code>is_err</code>, <code>unwrap</code>, and/or <code>as_mut</code>).</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-interoperability-with-cpp-using-cxx-in-chromium"></div><h2 id="chromium-interoperability-with-cpp-using-cxx-in-chromium-using-cxx-in-chromium"><a class="header" href="#chromium-interoperability-with-cpp-using-cxx-in-chromium-using-cxx-in-chromium">Using cxx in Chromium</a></h2>
<p>In Chromium, we define an independent <code>#[cxx::bridge] mod</code> for each leaf-node
where we want to use Rust. You'd typically have one for each
<code>rust_static_library</code>. Just add</p>
<pre><code class="language-gn">cxx_bindings = [ "my_rust_file.rs" ]
   # list of files containing #[cxx::bridge], not all source files
allow_unsafe = true
</code></pre>
<p>to your existing <code>rust_static_library</code> target alongside <code>crate_root</code> and
<code>sources</code>.</p>
<p>C++ headers will be generated at a sensible location, so you can just</p>
<pre><code class="language-cpp">#include "ui/base/my_rust_file.rs.h"
</code></pre>
<p>You will find some utility functions in <code>//base</code> to convert to/from Chromium C++
types to CXX Rust types --- for example <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;l=21"><code>SpanToRustSlice</code></a>.</p>
<details>
<p>Students may ask --- why do we still need <code>allow_unsafe = true</code>?</p>
<p>The broad answer is that no C/C++ code is "safe" by the normal Rust standards.
Calling back and forth to C/C++ from Rust may do arbitrary things to memory, and
compromise the safety of Rust's own data layouts. Presence of <em>too many</em>
<code>unsafe</code> keywords in C/C++ interop can harm the signal-to-noise ratio of such a
keyword, and is <a href="https://steveklabnik.com/writing/the-cxx-debate">controversial</a>, but strictly, bringing any foreign code into
a Rust binary can cause unexpected behavior from Rust's perspective.</p>
<p>The narrow answer lies in the diagram at the top of <a href="#chromium-interoperability-with-cpp">this page</a> --- behind
the scenes, CXX generates Rust <code>unsafe</code> and <code>extern "C"</code> functions just like we
did manually in the previous section.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-chromium-interoperability-with-cpp"></div><h1 id="exercises-chromium-interoperability-with-cpp-exercise-interoperability-with-c"><a class="header" href="#exercises-chromium-interoperability-with-cpp-exercise-interoperability-with-c">Exercise: Interoperability with C++</a></h1>
<h2 id="exercises-chromium-interoperability-with-cpp-part-one"><a class="header" href="#exercises-chromium-interoperability-with-cpp-part-one">Part one</a></h2>
<ul>
<li>In the Rust file you previously created, add a <code>#[cxx::bridge]</code> which
specifies a single function, to be called from C++, called <code>hello_from_rust</code>,
taking no parameters and returning no value.</li>
<li>Modify your previous <code>hello_from_rust</code> function to remove <code>extern "C"</code> and
<code>#[no_mangle]</code>. This is now just a standard Rust function.</li>
<li>Modify your <code>gn</code> target to build these bindings.</li>
<li>In your C++ code, remove the forward-declaration of <code>hello_from_rust</code>.
Instead, include the generated header file.</li>
<li>Build and run!</li>
</ul>
<h2 id="exercises-chromium-interoperability-with-cpp-part-two"><a class="header" href="#exercises-chromium-interoperability-with-cpp-part-two">Part two</a></h2>
<p>It's a good idea to play with CXX a little. It helps you think about how
flexible Rust in Chromium actually is.</p>
<p>Some things to try:</p>
<ul>
<li>Call back into C++ from Rust. You will need:
<ul>
<li>An additional header file which you can <code>include!</code> from your <code>cxx::bridge</code>.
You'll need to declare your C++ function in that new header file.</li>
<li>An <code>unsafe</code> block to call such a function, or alternatively specify the
<code>unsafe</code> keyword in your <code>#[cxx::bridge]</code> <a href="https://cxx.rs/extern-c++.html#functions-and-member-functions">as described here</a>.</li>
<li>You may also need to
<code>#include "third_party/rust/cxx/v1/crate/include/cxx.h"</code></li>
</ul>
</li>
<li>Pass a C++ string from C++ into Rust.</li>
<li>Pass a reference to a C++ object into Rust.</li>
<li>Intentionally get the Rust function signatures mismatched from the
<code>#[cxx::bridge]</code>, and get used to the errors you see.</li>
<li>Intentionally get the C++ function signatures mismatched from the
<code>#[cxx::bridge]</code>, and get used to the errors you see.</li>
<li>Pass a <code>std::unique_ptr</code> of some type from C++ into Rust, so that Rust can own
some C++ object.</li>
<li>Create a Rust object and pass it into C++, so that C++ owns it. (Hint: you
need a <code>Box</code>).</li>
<li>Declare some methods on a C++ type. Call them from Rust.</li>
<li>Declare some methods on a Rust type. Call them from C++.</li>
</ul>
<h2 id="exercises-chromium-interoperability-with-cpp-part-three"><a class="header" href="#exercises-chromium-interoperability-with-cpp-part-three">Part three</a></h2>
<p>Now you understand the strengths and limitations of CXX interop, think of a
couple of use-cases for Rust in Chromium where the interface would be
sufficiently simple. Sketch how you might define that interface.</p>
<h2 id="exercises-chromium-interoperability-with-cpp-where-to-find-help"><a class="header" href="#exercises-chromium-interoperability-with-cpp-where-to-find-help">Where to find help</a></h2>
<ul>
<li>The <a href="https://cxx.rs/bindings.html"><code>cxx</code> binding reference</a></li>
<li>The <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16"><code>rust_static_library</code> gn template</a></li>
</ul>
<details>
As students explore Part Two, they're bound to have lots of questions about how
to achieve these things, and also how CXX works behind the scenes.
<p>Some of the questions you may encounter:</p>
<ul>
<li>I'm seeing a problem initializing a variable of type X with type Y, where X
and Y are both function types. This is because your C++ function doesn't quite
match the declaration in your <code>cxx::bridge</code>.</li>
<li>I seem to be able to freely convert C++ references into Rust references.
Doesn't that risk UB? For CXX's <em>opaque</em> types, no, because they are
zero-sized. For CXX trivial types yes, it's <em>possible</em> to cause UB, although
CXX's design makes it quite difficult to craft such an example.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates"></div><h1 id="chromium-adding-third-party-crates-adding-third-party-crates"><a class="header" href="#chromium-adding-third-party-crates-adding-third-party-crates">Adding Third Party Crates</a></h1>
<p>Rust libraries are called "crates" and are found at <a href="https://crates.io">crates.io</a>. It's <em>very
easy</em> for Rust crates to depend upon one another. So they do!</p>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>C++ library</th><th>Rust crate</th></tr></thead><tbody>
<tr><td>Build system</td><td>Lots</td><td>Consistent: <code>Cargo.toml</code></td></tr>
<tr><td>Typical library size</td><td>Large-ish</td><td>Small</td></tr>
<tr><td>Transitive dependencies</td><td>Few</td><td>Lots</td></tr>
</tbody></table>
</div>
<p>For a Chromium engineer, this has pros and cons:</p>
<ul>
<li>All crates use a common build system so we can automate their inclusion into
Chromium...</li>
<li>... but, crates typically have transitive dependencies, so you will likely
have to bring in multiple libraries.</li>
</ul>
<p>We'll discuss:</p>
<ul>
<li>How to put a crate in the Chromium source code tree</li>
<li>How to make <code>gn</code> build rules for it</li>
<li>How to audit its source code for sufficient safety.</li>
</ul>
<details>
All of the things in the table on this slide are generalizations, and
counter-examples can be found. But in general it's important for students
to understand that most Rust code depends on other Rust libraries, because
it's easy to do so, and that this has both benefits and costs.
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-configuring-cargo-toml"></div><h1 id="chromium-adding-third-party-crates-configuring-cargo-toml-configuring-the-cargotoml-file-to-add-crates"><a class="header" href="#chromium-adding-third-party-crates-configuring-cargo-toml-configuring-the-cargotoml-file-to-add-crates">Configuring the <code>Cargo.toml</code> file to add crates</a></h1>
<p>Chromium has a single set of centrally-managed direct crate dependencies. These
are managed through a single <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo.toml"><code>Cargo.toml</code></a>:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1"
cfg-if = "1"
cxx = "1"
# lots more...
</code></pre>
<p>As with any other <code>Cargo.toml</code>, you can specify
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">more details about the dependencies</a> --- most commonly, you'll want to
specify the <code>features</code> that you wish to enable in the crate.</p>
<p>When adding a crate to Chromium, you'll often need to provide some extra
information in an additional file, <code>gnrt_config.toml</code>, which we'll meet next.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-configuring-gnrt-config-toml"></div><h1 id="chromium-adding-third-party-crates-configuring-gnrt-config-toml-configuring-gnrt_configtoml"><a class="header" href="#chromium-adding-third-party-crates-configuring-gnrt-config-toml-configuring-gnrt_configtoml">Configuring <code>gnrt_config.toml</code></a></h1>
<p>Alongside <code>Cargo.toml</code> is <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config.toml"><code>gnrt_config.toml</code></a>. This contains
Chromium-specific extensions to crate handling.</p>
<p>If you add a new crate, you should specify at least the <code>group</code>. This is one of:</p>
<pre><code class="language-toml">#   'safe': The library satisfies the rule-of-2 and can be used in any process.
#   'sandbox': The library does not satisfy the rule-of-2 and must be used in
#              a sandboxed process such as the renderer or a utility process.
#   'test': The library is only used in tests.
</code></pre>
<p>For instance,</p>
<pre><code class="language-toml">[crate.my-new-crate]
group = 'test' # only used in test code
</code></pre>
<p>Depending on the crate source code layout, you may also need to use this file to
specify where its <code>LICENSE</code> file(s) can be found.</p>
<p>Later, we'll see some other things you will need to configure in this file to
resolve problems.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-downloading-crates"></div><h1 id="chromium-adding-third-party-crates-downloading-crates-downloading-crates"><a class="header" href="#chromium-adding-third-party-crates-downloading-crates-downloading-crates">Downloading Crates</a></h1>
<p>A tool called <code>gnrt</code> knows how to download crates and how to generate <code>BUILD.gn</code>
rules.</p>
<p>To start, download the crate you want like this:</p>
<pre><code class="language-shell">cd chromium/src
vpython3 tools/crates/run_gnrt.py -- vendor
</code></pre>
<blockquote>
<p>Although the <code>gnrt</code> tool is part of the Chromium source code, by running this
command you will be downloading and running its dependencies from <code>crates.io</code>.
See <a href="#chromium-cargo">the earlier section</a> discussing this security decision.</p>
</blockquote>
<p>This <code>vendor</code> command may download:</p>
<ul>
<li>Your crate</li>
<li>Direct and transitive dependencies</li>
<li>New versions of other crates, as required by <code>cargo</code> to resolve the complete
set of crates required by Chromium.</li>
</ul>
<p>Chromium maintains patches for some crates, kept in
<code>//third_party/rust/chromium_crates_io/patches</code>. These will be reapplied
automatically, but if patching fails you may need to take manual action.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-generating-gn-build-rules"></div><h1 id="chromium-adding-third-party-crates-generating-gn-build-rules-generating-gn-build-rules"><a class="header" href="#chromium-adding-third-party-crates-generating-gn-build-rules-generating-gn-build-rules">Generating <code>gn</code> Build Rules</a></h1>
<p>Once you've downloaded the crate, generate the <code>BUILD.gn</code> files like this:</p>
<pre><code class="language-shell">vpython3 tools/crates/run_gnrt.py -- gen
</code></pre>
<p>Now run <code>git status</code>. You should find:</p>
<ul>
<li>At least one new crate source code in
<code>third_party/rust/chromium_crates_io/vendor</code></li>
<li>At least one new <code>BUILD.gn</code> in
<code>third_party/rust/&lt;crate name&gt;/v&lt;major semver version&gt;</code></li>
<li>An appropriate <code>README.chromium</code></li>
</ul>
<p>The "major semver version" is a <a href="https://doc.rust-lang.org/cargo/reference/semver.html">Rust "semver" version number</a>.</p>
<p>Take a close look, especially at the things generated in <code>third_party/rust</code>.</p>
<details>
<p>Talk a little about semver --- and specifically the way that in Chromium it's to
allow multiple incompatible versions of a crate, which is discouraged but
sometimes necessary in the Cargo ecosystem.</p>
</detail>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-resolving-problems"></div><h1 id="chromium-adding-third-party-crates-resolving-problems-resolving-problems"><a class="header" href="#chromium-adding-third-party-crates-resolving-problems-resolving-problems">Resolving Problems</a></h1>
<p>If your build fails, it may be because of a <code>build.rs</code>: programs which do
arbitrary things at build time. This is fundamentally at odds with the design of
<code>gn</code> and <code>ninja</code> which aim for static, deterministic, build rules to maximize
parallelism and repeatability of builds.</p>
<p>Some <code>build.rs</code> actions are automatically supported; others require action:</p>
<div class="table-wrapper"><table><thead><tr><th>build script effect</th><th>Supported by our gn templates</th><th>Work required by you</th></tr></thead><tbody>
<tr><td>Checking rustc version to configure features on and off</td><td>Yes</td><td>None</td></tr>
<tr><td>Checking platform or CPU to configure features on and off</td><td>Yes</td><td>None</td></tr>
<tr><td>Generating code</td><td>Yes</td><td>Yes - specify in <code>gnrt_config.toml</code></td></tr>
<tr><td>Building C/C++</td><td>No</td><td>Patch around it</td></tr>
<tr><td>Arbitrary other actions</td><td>No</td><td>Patch around it</td></tr>
</tbody></table>
</div>
<p>Fortunately, most crates don't contain a build script, and fortunately, most
build scripts only do the top two actions.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-resolving-problems-build-scripts-which-generate-code"></div><h1 id="chromium-adding-third-party-crates-resolving-problems-build-scripts-which-generate-code-build-scripts-which-generate-code"><a class="header" href="#chromium-adding-third-party-crates-resolving-problems-build-scripts-which-generate-code-build-scripts-which-generate-code">Build Scripts Which Generate Code</a></h1>
<p>If <code>ninja</code> complains about missing files, check the <code>build.rs</code> to see if it
writes source code files.</p>
<p>If so, modify <a href="#chromium-adding-third-party-crates-configuring-gnrt-config-toml"><code>gnrt_config.toml</code></a> to add <code>build-script-outputs</code> to the
crate. If this is a transitive dependency, that is, one on which Chromium code
should not directly depend, also add <code>allow-first-party-usage=false</code>. There are
several examples already in that file:</p>
<pre><code class="language-toml">[crate.unicode-linebreak]
allow-first-party-usage = false
build-script-outputs = ["tables.rs"]
</code></pre>
<p>Now rerun <a href="#chromium-adding-third-party-crates-generating-gn-build-rules"><code>gnrt.py -- gen</code></a> to regenerate <code>BUILD.gn</code> files to inform ninja
that this particular output file is input to subsequent build steps.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-resolving-problems-build-scripts-which-take-arbitrary-actions"></div><h1 id="chromium-adding-third-party-crates-resolving-problems-build-scripts-which-take-arbitrary-actions-build-scripts-which-build-c-or-take-arbitrary-actions"><a class="header" href="#chromium-adding-third-party-crates-resolving-problems-build-scripts-which-take-arbitrary-actions-build-scripts-which-build-c-or-take-arbitrary-actions">Build Scripts Which Build C++ or Take Arbitrary Actions</a></h1>
<p>Some crates use the <a href="https://crates.io/crates/cc"><code>cc</code></a> crate to build and link C/C++ libraries. Other
crates parse C/C++ using <a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> within their build scripts. These
actions can't be supported in a Chromium context --- our gn, ninja and LLVM
build system is very specific in expressing relationships between build actions.</p>
<p>So, your options are:</p>
<ul>
<li>Avoid these crates</li>
<li>Apply a patch to the crate.</li>
</ul>
<p>Patches should be kept in
<code>third_party/rust/chromium_crates_io/patches/&lt;crate&gt;</code> - see for example the
<a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/patches/cxx/">patches against the <code>cxx</code> crate</a> - and will be applied automatically by
<code>gnrt</code> each time it upgrades the crate.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-depending-on-a-crate"></div><h1 id="chromium-adding-third-party-crates-depending-on-a-crate-depending-on-a-crate"><a class="header" href="#chromium-adding-third-party-crates-depending-on-a-crate-depending-on-a-crate">Depending on a Crate</a></h1>
<p>Once you've added a third-party crate and generated build rules, depending on a
crate is simple. Find your <code>rust_static_library</code> target, and add a <code>dep</code> on the
<code>:lib</code> target within your crate.</p>
<p>Specifically,</p>
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="528" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="chromium-adding-third-party-crates-depending-on-a-crate-arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="chromium-adding-third-party-crates-depending-on-a-crate-diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="chromium-adding-third-party-crates-depending-on-a-crate-circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="chromium-adding-third-party-crates-depending-on-a-crate-open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="chromium-adding-third-party-crates-depending-on-a-crate-big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="528" height="64"></rect><rect x="172" y="8" width="104" height="32" class="solid nofill" rx="0"></rect><text x="186" y="28" >crate</text><text x="234" y="28" >name</text><rect x="332" y="8" width="184" height="32" class="solid nofill" rx="0"></rect><text x="346" y="28" >major</text><text x="394" y="28" >semver</text><text x="450" y="28" >version</text><text x="2" y="28" >//third_party/rust</text><text x="290" y="28" >/v</text><text x="530" y="28" >:lib</text></svg></div>
<p>For instance,</p>
<pre><code class="language-gn">rust_static_library("my_rust_lib") {
  crate_root = "lib.rs"
  sources = [ "lib.rs" ]
  deps = [ "//third_party/rust/example_rust_crate/v1:lib" ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-reviews-and-audits"></div><h1 id="chromium-adding-third-party-crates-reviews-and-audits-auditing-third-party-crates"><a class="header" href="#chromium-adding-third-party-crates-reviews-and-audits-auditing-third-party-crates">Auditing Third Party Crates</a></h1>
<p>Adding new libraries is subject to Chromium's standard <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Third_party-review">policies</a>, but of
course also subject to security review. As you may be bringing in not just a
single crate but also transitive dependencies, there may be a lot of code to
review. On the other hand, safe Rust code can have limited negative side
effects. How should you review it?</p>
<p>Over time Chromium aims to move to a process based around <a href="https://mozilla.github.io/cargo-vet/">cargo vet</a>.</p>
<p>Meanwhile, for each new crate addition, we are checking for the following:</p>
<ul>
<li>Understand why each crate is used. What's the relationship between crates? If
the build system for each crate contains a <code>build.rs</code> or procedural macros,
work out what they're for. Are they compatible with the way Chromium is
normally built?</li>
<li>Check each crate seems to be reasonably well maintained</li>
<li>Use <code>cd third-party/rust/chromium_crates_io; cargo audit</code> to check for known
vulnerabilities (first you'll need to <code>cargo install cargo-audit</code>, which
ironically involves downloading lots of dependencies from the internet<a href="#chromium-cargo">2</a>)</li>
<li>Ensure any <code>unsafe</code> code is good enough for the <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2.md#unsafe-code-in-safe-languages">Rule of Two</a></li>
<li>Check for any use of <code>fs</code> or <code>net</code> APIs</li>
<li>Read all the code at a sufficient level to look for anything out of place that
might have been maliciously inserted. (You can't realistically aim for 100%
perfection here: there's often just too much code.)</li>
</ul>
<p>These are just guidelines --- work with reviewers from <code>security@chromium.org</code>
to work out the right way to become confident of the crate.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-checking-in"></div><h1 id="chromium-adding-third-party-crates-checking-in-checking-crates-into-chromium-source-code"><a class="header" href="#chromium-adding-third-party-crates-checking-in-checking-crates-into-chromium-source-code">Checking Crates into Chromium Source Code</a></h1>
<p><code>git status</code> should reveal:</p>
<ul>
<li>Crate code in <code>//third_party/rust/chromium_crates_io</code></li>
<li>Metadata (<code>BUILD.gn</code> and <code>README.chromium</code>) in
<code>//third_party/rust/&lt;crate&gt;/&lt;version&gt;</code></li>
</ul>
<p>Please also add an <code>OWNERS</code> file in the latter location.</p>
<p>You should land all this, along with your <code>Cargo.toml</code> and <code>gnrt_config.toml</code>
changes, into the Chromium repo.</p>
<p><strong>Important</strong>: you need to use <code>git add -f</code> because otherwise <code>.gitignore</code> files
may result in some files being skipped.</p>
<p>As you do so, you might find presubmit checks fail because of non-inclusive
language. This is because Rust crate data tends to include names of git
branches, and many projects still use non-inclusive terminology there. So you
may need to run:</p>
<pre><code class="language-shell">infra/update_inclusive_language_presubmit_exempt_dirs.sh &gt; infra/inclusive_language_presubmit_exempt_dirs.txt
git add -p infra/inclusive_language_presubmit_exempt_dirs.txt # add whatever changes are yours
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="chromium-adding-third-party-crates-keeping-up-to-date"></div><h1 id="chromium-adding-third-party-crates-keeping-up-to-date-keeping-crates-up-to-date"><a class="header" href="#chromium-adding-third-party-crates-keeping-up-to-date-keeping-crates-up-to-date">Keeping Crates Up to Date</a></h1>
<p>As the OWNER of any third party Chromium dependency, you are
<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners">expected to keep it up to date with any security fixes</a>. It is hoped that we
will soon automate this for Rust crates, but for now, it's still your
responsibility just as it is for any other third party dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-chromium-third-party"></div><h1 id="exercises-chromium-third-party-exercise"><a class="header" href="#exercises-chromium-third-party-exercise">Exercise</a></h1>
<p>Add <a href="https://crates.io/crates/uwuify">uwuify</a> to Chromium, turning off the crate's <a href="https://doc.rust-lang.org/cargo/reference/features.html#the-default-feature">default features</a>.
Assume that the crate will be used in shipping Chromium, but won't be used to
handle untrustworthy input.</p>
<p>(In the next exercise we'll use uwuify from Chromium, but feel free to skip
ahead and do that now if you like. Or, you could create a new
<a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_executable.gni"><code>rust_executable</code> target</a> which uses <code>uwuify</code>).</p>
<details>
<p>Students will need to download lots of transitive dependencies.</p>
<p>The total crates needed are:</p>
<ul>
<li><code>instant</code>,</li>
<li><code>lock_api</code>,</li>
<li><code>parking_lot</code>,</li>
<li><code>parking_lot_core</code>,</li>
<li><code>redox_syscall</code>,</li>
<li><code>scopeguard</code>,</li>
<li><code>smallvec</code>, and</li>
<li><code>uwuify</code>.</li>
</ul>
<p>If students are downloading even more than that, they probably forgot to turn
off the default features.</p>
<p>Thanks to <a href="https://github.com/Daniel-Liu-c0deb0t">Daniel Liu</a> for this crate!</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-chromium-bringing-it-together"></div><h1 id="exercises-chromium-bringing-it-together-bringing-it-together-----exercise"><a class="header" href="#exercises-chromium-bringing-it-together-bringing-it-together-----exercise">Bringing It Together --- Exercise</a></h1>
<p>In this exercise, you're going to add a whole new Chromium feature, bringing
together everything you already learned.</p>
<h2 id="exercises-chromium-bringing-it-together-the-brief-from-product-management"><a class="header" href="#exercises-chromium-bringing-it-together-the-brief-from-product-management">The Brief from Product Management</a></h2>
<p>A community of pixies has been discovered living in a remote rainforest. It's
important that we get Chromium for Pixies delivered to them as soon as possible.</p>
<p>The requirement is to translate all Chromium's UI strings into Pixie language.</p>
<p>There's not time to wait for proper translations, but fortunately pixie language
is very close to English, and it turns out there's a Rust crate which does the
translation.</p>
<p>In fact, you already <a href="https://crates.io/crates/uwuify">imported that crate in the previous exercise</a>.</p>
<p>(Obviously, real translations of Chrome require incredible care and diligence.
Don't ship this!)</p>
<h2 id="exercises-chromium-bringing-it-together-steps"><a class="header" href="#exercises-chromium-bringing-it-together-steps">Steps</a></h2>
<p>Modify <code>ResourceBundle::MaybeMangleLocalizedString</code> so that it uwuifies all
strings before display. In this special build of Chromium, it should always do
this irrespective of the setting of <code>mangle_localized_strings_</code>.</p>
<p>If you've done everything right across all these exercises, congratulations, you
should have created Chrome for pixies!</p>
<img src="exercises/chromium/chwomium.png" alt="Chromium UI screenshot with uwu language">
<details>
Students will likely need some hints here. Hints include:
<ul>
<li>UTF16 vs UTF8. Students should be aware that Rust strings are always UTF8, and
will probably decide that it's better to do the conversion on the C++ side
using <code>base::UTF16ToUTF8</code> and back again.</li>
<li>If students decide to do the conversion on the Rust side, they'll need to
consider <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16"><code>String::from_utf16</code></a>, consider error handling, and consider
which <a href="https://cxx.rs/binding/slice.html">CXX supported types can transfer a lot of u16s</a>.</li>
<li>Students may design the C++/Rust boundary in several different ways, e.g.
taking and returning strings by value, or taking a mutable reference to a
string. If a mutable reference is used, CXX will likely tell the student that
they need to use <a href="https://doc.rust-lang.org/std/pin/"><code>Pin</code></a>. You may need to explain what <code>Pin</code> does, and then
explain why CXX needs it for mutable references to C++ data: the answer is
that C++ data can't be moved around like Rust data, because it may contain
self-referential pointers.</li>
<li>The C++ target containing <code>ResourceBundle::MaybeMangleLocalizedString</code> will
need to depend on a <code>rust_static_library</code> target. The student probably already
did this.</li>
<li>The <code>rust_static_library</code> target will need to depend on
<code>//third_party/rust/uwuify/v0_2:lib</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-chromium-solutions"></div><h1 id="exercises-chromium-solutions-exercise-solutions"><a class="header" href="#exercises-chromium-solutions-exercise-solutions">Exercise Solutions</a></h1>
<p>Solutions to the Chromium exercises can be found in <a href="https://chromium-review.googlesource.com/c/chromium/src/+/5096560">this series of CLs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal"></div><h1 id="bare-metal-welcome-to-bare-metal-rust"><a class="header" href="#bare-metal-welcome-to-bare-metal-rust">Welcome to Bare Metal Rust</a></h1>
<p>This is a standalone one-day course about bare-metal Rust, aimed at people who
are familiar with the basics of Rust (perhaps from completing the Comprehensive
Rust course), and ideally also have some experience with bare-metal programming
in some other language such as C.</p>
<p>Today we will talk about 'bare-metal' Rust: running Rust code without an OS
underneath us. This will be divided into several parts:</p>
<ul>
<li>What is <code>no_std</code> Rust?</li>
<li>Writing firmware for microcontrollers.</li>
<li>Writing bootloader / kernel code for application processors.</li>
<li>Some useful crates for bare-metal Rust development.</li>
</ul>
<p>For the microcontroller part of the course we will use the
<a href="https://microbit.org/">BBC micro:bit</a> v2 as an example. It's a
<a href="https://tech.microbit.org/hardware/">development board</a> based on the Nordic
nRF52833 microcontroller with some LEDs and buttons, an I2C-connected
accelerometer and compass, and an on-board SWD debugger.</p>
<p>To get started, install some tools we'll need later. On gLinux or Debian:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<p>And give users in the <code>plugdev</code> group access to the micro:bit programmer:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">echo 'SUBSYSTEM=="hidraw", ATTRS{idVendor}=="0d28", MODE="0660", GROUP="logindev", TAG+="uaccess"' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
</code></pre>
<p>On MacOS:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">xcode-select --install
brew install gdb picocom qemu
brew install --cask gcc-aarch64-embedded
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-no_std"></div><h1 id="bare-metal-no_std-no_std"><a class="header" href="#bare-metal-no_std-no_std"><code>no_std</code></a></h1>
<table>
<tr>
<th>
<p><code>core</code></p>
</th>
<th>
<p><code>alloc</code></p>
</th>
<th>
<p><code>std</code></p>
</th>
</tr>
<tr valign="top">
<td>
<ul>
<li>Slices, <code>&amp;str</code>, <code>CStr</code></li>
<li><code>NonZeroU8</code>...</li>
<li><code>Option</code>, <code>Result</code></li>
<li><code>Display</code>, <code>Debug</code>, <code>write!</code>...</li>
<li><code>Iterator</code></li>
<li><code>panic!</code>, <code>assert_eq!</code>...</li>
<li><code>NonNull</code> and all the usual pointer-related functions</li>
<li><code>Future</code> and <code>async</code>/<code>await</code></li>
<li><code>fence</code>, <code>AtomicBool</code>, <code>AtomicPtr</code>, <code>AtomicU32</code>...</li>
<li><code>Duration</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Box</code>, <code>Cow</code>, <code>Arc</code>, <code>Rc</code></li>
<li><code>Vec</code>, <code>BinaryHeap</code>, <code>BtreeMap</code>, <code>LinkedList</code>, <code>VecDeque</code></li>
<li><code>String</code>, <code>CString</code>, <code>format!</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Error</code></li>
<li><code>HashMap</code></li>
<li><code>Mutex</code>, <code>Condvar</code>, <code>Barrier</code>, <code>Once</code>, <code>RwLock</code>, <code>mpsc</code></li>
<li><code>File</code> and the rest of <code>fs</code></li>
<li><code>println!</code>, <code>Read</code>, <code>Write</code>, <code>Stdin</code>, <code>Stdout</code> and the rest of <code>io</code></li>
<li><code>Path</code>, <code>OsString</code></li>
<li><code>net</code></li>
<li><code>Command</code>, <code>Child</code>, <code>ExitCode</code></li>
<li><code>spawn</code>, <code>sleep</code> and the rest of <code>thread</code></li>
<li><code>SystemTime</code>, <code>Instant</code></li>
</ul>
</td>
</tr>
</table>
<details>
<ul>
<li><code>HashMap</code> depends on RNG.</li>
<li><code>std</code> re-exports the contents of both <code>core</code> and <code>alloc</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-minimal"></div><h1 id="bare-metal-minimal-a-minimal-no_std-program"><a class="header" href="#bare-metal-minimal-a-minimal-no_std-program">A minimal <code>no_std</code> program</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo) -&gt; ! {
    loop {}
}</code></pre></pre>
<details>
<ul>
<li>This will compile to an empty binary.</li>
<li><code>std</code> provides a panic handler; without it we must provide our own.</li>
<li>It can also be provided by another crate, such as <code>panic-halt</code>.</li>
<li>Depending on the target, you may need to compile with <code>panic = "abort"</code> to
avoid an error about <code>eh_personality</code>.</li>
<li>Note that there is no <code>main</code> or any other entry point; it's up to you to
define your own entry point. This will typically involve a linker script and
some assembly code to set things up ready for Rust code to run.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-alloc"></div><h1 id="bare-metal-alloc-alloc"><a class="header" href="#bare-metal-alloc-alloc"><code>alloc</code></a></h1>
<p>To use <code>alloc</code> you must implement a
<a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">global (heap) allocator</a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap&lt;32&gt; = LockedHeap::&lt;32&gt;::new();

static mut HEAP: [u8; 65536] = [0; 65536];

pub fn entry() {
    // SAFETY: `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR.lock().init(HEAP.as_mut_ptr() as usize, HEAP.len());
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push("A string".to_string());
}</code></pre></pre>
<details>
<ul>
<li><code>buddy_system_allocator</code> is a third-party crate implementing a basic buddy
system allocator. Other crates are available, or you can write your own or
hook into your existing allocator.</li>
<li>The const parameter of <code>LockedHeap</code> is the max order of the allocator; i.e. in
this case it can allocate regions of up to 2**32 bytes.</li>
<li>If any crate in your dependency tree depends on <code>alloc</code> then you must have
exactly one global allocator defined in your binary. Usually this is done in
the top-level binary crate.</li>
<li><code>extern crate panic_halt as _</code> is necessary to ensure that the <code>panic_halt</code>
crate is linked in so we get its panic handler.</li>
<li>This example will build but not run, as it doesn't have an entry point.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers"></div><h1 id="bare-metal-microcontrollers-microcontrollers"><a class="header" href="#bare-metal-microcontrollers-microcontrollers">Microcontrollers</a></h1>
<p>The <code>cortex_m_rt</code> crate provides (among other things) a reset handler for Cortex
M microcontrollers.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}</code></pre></pre>
<p>Next we'll look at how to access peripherals, with increasing levels of
abstraction.</p>
<details>
<ul>
<li>The <code>cortex_m_rt::entry</code> macro requires that the function have type
<code>fn() -&gt; !</code>, because returning to the reset handler doesn't make sense.</li>
<li>Run the example with <code>cargo embed --bin minimal</code></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-mmio"></div><h1 id="bare-metal-microcontrollers-mmio-raw-mmio"><a class="header" href="#bare-metal-microcontrollers-mmio-raw-mmio">Raw MMIO</a></h1>
<p>Most microcontrollers access peripherals via memory-mapped IO. Let's try turning
on an LED on our micro:bit:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use core::mem::size_of;
use cortex_m_rt::entry;

/// GPIO port 0 peripheral address
const GPIO_P0: usize = 0x5000_0000;

// GPIO peripheral offsets
const PIN_CNF: usize = 0x700;
const OUTSET: usize = 0x508;
const OUTCLR: usize = 0x50c;

// PIN_CNF fields
const DIR_OUTPUT: u32 = 0x1;
const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;
const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;
const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;
const SENSE_DISABLED: u32 = 0x0 &lt;&lt; 16;

#[entry]
fn main() -&gt; ! {
    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::&lt;u32&gt;()) as *mut u32;
    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::&lt;u32&gt;()) as *mut u32;
    // SAFETY: The pointers are to valid peripheral control registers, and no
    // aliases exist.
    unsafe {
        pin_cnf_21.write_volatile(
            DIR_OUTPUT
                | INPUT_DISCONNECT
                | PULL_DISABLED
                | DRIVE_S0S1
                | SENSE_DISABLED,
        );
        pin_cnf_28.write_volatile(
            DIR_OUTPUT
                | INPUT_DISCONNECT
                | PULL_DISABLED
                | DRIVE_S0S1
                | SENSE_DISABLED,
        );
    }

    // Set pin 28 low and pin 21 high to turn the LED on.
    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;
    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;
    // SAFETY: The pointers are to valid peripheral control registers, and no
    // aliases exist.
    unsafe {
        gpio0_outclr.write_volatile(1 &lt;&lt; 28);
        gpio0_outset.write_volatile(1 &lt;&lt; 21);
    }

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28
to the first row.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin mmio
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-pacs"></div><h1 id="bare-metal-microcontrollers-pacs-peripheral-access-crates"><a class="header" href="#bare-metal-microcontrollers-pacs-peripheral-access-crates">Peripheral Access Crates</a></h1>
<p><a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> generates mostly-safe Rust
wrappers for memory-mapped peripherals from
<a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a> files.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p.P0;

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    gpio0.pin_cnf[21].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });
    gpio0.pin_cnf[28].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });

    // Set pin 28 low and pin 21 high to turn the LED on.
    gpio0.outclr.write(|w| w.pin28().clear());
    gpio0.outset.write(|w| w.pin21().set());

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>SVD (System View Description) files are XML files typically provided by
silicon vendors which describe the memory map of the device.
<ul>
<li>They are organised by peripheral, register, field and value, with names,
descriptions, addresses and so on.</li>
<li>SVD files are often buggy and incomplete, so there are various projects
which patch the mistakes, add missing details, and publish the generated
crates.</li>
</ul>
</li>
<li><code>cortex-m-rt</code> provides the vector table, among other things.</li>
<li>If you <code>cargo install cargo-binutils</code> then you can run
<code>cargo objdump --bin pac -- -d --no-show-raw-insn</code> to see the resulting
binary.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin pac
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-hals"></div><h1 id="bare-metal-microcontrollers-hals-hal-crates"><a class="header" href="#bare-metal-microcontrollers-hals-hal-crates">HAL crates</a></h1>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates">HAL crates</a>
for many microcontrollers provide wrappers around various peripherals. These
generally implement traits from
<a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::gpio::{p0, Level};
use nrf52833_hal::pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();

    // Create HAL wrapper for GPIO port 0.
    let gpio0 = p0::Parts::new(p.P0);

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);
    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);

    // Set pin 28 low and pin 21 high to turn the LED on.
    col1.set_low().unwrap();
    row1.set_high().unwrap();

    loop {}
}</code></pre></pre>
<details>
<ul>
<li><code>set_low</code> and <code>set_high</code> are methods on the <code>embedded_hal</code> <code>OutputPin</code> trait.</li>
<li>HAL crates exist for many Cortex-M and RISC-V devices, including various
STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin hal
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-board-support"></div><h1 id="bare-metal-microcontrollers-board-support-board-support-crates"><a class="header" href="#bare-metal-microcontrollers-board-support-board-support-crates">Board support crates</a></h1>
<p>Board support crates provide a further level of wrapping for a specific board
for convenience.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use microbit::Board;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>In this case the board support crate is just providing more useful names, and
a bit of initialisation.</li>
<li>The crate may also include drivers for some on-board devices outside of the
microcontroller itself.
<ul>
<li><code>microbit-v2</code> includes a simple driver for the LED matrix.</li>
</ul>
</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin board_support
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-type-state"></div><h1 id="bare-metal-microcontrollers-type-state-the-type-state-pattern"><a class="header" href="#bare-metal-microcontrollers-type-state-the-type-state-pattern">The type state pattern</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p0::Parts::new(p.P0);

    let pin: P0_01&lt;Disconnected&gt; = gpio0.p0_01;

    // let gpio0_01_again = gpio0.p0_01; // Error, moved.
    let mut pin_input: P0_01&lt;Input&lt;Floating&gt;&gt; = pin.into_floating_input();
    if pin_input.is_high().unwrap() {
        // ...
    }
    let mut pin_output: P0_01&lt;Output&lt;OpenDrain&gt;&gt; = pin_input
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    pin_output.set_high().unwrap();
    // pin_input.is_high(); // Error, moved.

    let _pin2: P0_02&lt;Output&lt;OpenDrain&gt;&gt; = gpio0
        .p0_02
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    let _pin3: P0_03&lt;Output&lt;PushPull&gt;&gt; =
        gpio0.p0_03.into_push_pull_output(Level::Low);

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>Pins don't implement <code>Copy</code> or <code>Clone</code>, so only one instance of each can
exist. Once a pin is moved out of the port struct nobody else can take it.</li>
<li>Changing the configuration of a pin consumes the old pin instance, so you
can‚Äôt keep use the old instance afterwards.</li>
<li>The type of a value indicates the state that it is in: e.g. in this case, the
configuration state of a GPIO pin. This encodes the state machine into the
type system, and ensures that you don't try to use a pin in a certain way
without properly configuring it first. Illegal state transitions are caught at
compile time.</li>
<li>You can call <code>is_high</code> on an input pin and <code>set_high</code> on an output pin, but
not vice-versa.</li>
<li>Many HAL crates follow this pattern.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-embedded-hal"></div><h1 id="bare-metal-microcontrollers-embedded-hal-embedded-hal"><a class="header" href="#bare-metal-microcontrollers-embedded-hal-embedded-hal"><code>embedded-hal</code></a></h1>
<p>The <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> crate provides a number of traits covering common
microcontroller peripherals:</p>
<ul>
<li>GPIO</li>
<li>PWM</li>
<li>Delay timers</li>
<li>I2C and SPI buses and devices</li>
</ul>
<p>Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs and broken out
into <a href="https://crates.io/crates/embedded-io"><code>embedded-io</code></a>, <a href="https://crates.io/crates/embedded-can"><code>embedded-can</code></a> and <a href="https://crates.io/crates/rand_core"><code>rand_core</code></a> respectively.</p>
<p>Other crates then implement <a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">drivers</a> in terms of these traits, e.g. an
accelerometer driver might need an I2C or SPI device instance.</p>
<details>
<ul>
<li>The traits cover using the peripherals but not initialising or configuring
them, as initialisation and configuration is usually highly platform-specific.</li>
<li>There are implementations for many microcontrollers, as well as other
platforms such as Linux on Raspberry Pi.</li>
<li><a href="https://crates.io/crates/embedded-hal-async"><code>embedded-hal-async</code></a> provides async versions of the traits.</li>
<li><a href="https://crates.io/crates/embedded-hal-nb"><code>embedded-hal-nb</code></a> provides another approach to non-blocking I/O, based on
the <a href="https://crates.io/crates/nb"><code>nb</code></a> crate.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-probe-rs"></div><h1 id="bare-metal-microcontrollers-probe-rs-probe-rs-and-cargo-embed"><a class="header" href="#bare-metal-microcontrollers-probe-rs-probe-rs-and-cargo-embed"><code>probe-rs</code> and <code>cargo-embed</code></a></h1>
<p><a href="https://probe.rs/">probe-rs</a> is a handy toolset for embedded debugging, like
OpenOCD but better integrated.</p>
<ul>
<li>SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes</li>
<li>GDB stub and Microsoft DAP (Debug Adapter Protocol) server</li>
<li>Cargo integration</li>
</ul>
<p><code>cargo-embed</code> is a cargo subcommand to build and flash binaries, log RTT (Real
Time Transfers) output and connect GDB. It's configured by an <code>Embed.toml</code> file
in your project directory.</p>
<details>
<ul>
<li><a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a> is an
Arm standard protocol over USB for an in-circuit debugger to access the
CoreSight Debug Access Port of various Arm Cortex processors. It's what the
on-board debugger on the BBC micro:bit uses.</li>
<li>ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is
a range from SEGGER.</li>
<li>The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial
Wire Debug.</li>
<li>probe-rs is a library which you can integrate into your own tools if you want
to.</li>
<li>The
<a href="https://microsoft.github.io/debug-adapter-protocol/">Microsoft Debug Adapter Protocol</a>
lets VSCode and other IDEs debug code running on any supported
microcontroller.</li>
<li>cargo-embed is a binary built using the probe-rs library.</li>
<li>RTT (Real Time Transfers) is a mechanism to transfer data between the debug
host and the target through a number of ringbuffers.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-debugging"></div><h1 id="bare-metal-microcontrollers-debugging-debugging"><a class="header" href="#bare-metal-microcontrollers-debugging-debugging">Debugging</a></h1>
<p><em>Embed.toml</em>:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[default.general]
chip = "nrf52833_xxAA"

[debug.gdb]
enabled = true
</code></pre>
<p>In one terminal under <code>src/bare-metal/microcontrollers/examples/</code>:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">cargo embed --bin board_support debug
</code></pre>
<p>In another terminal in the same directory:</p>
<p>On gLinux or Debian:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command="target remote :1337"
</code></pre>
<p>On MacOS:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">arm-none-eabi-gdb target/thumbv7em-none-eabihf/debug/board_support --eval-command="target remote :1337"
</code></pre>
<details>
<p>In GDB, try running:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-gdb">b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-microcontrollers-other-projects"></div><h1 id="bare-metal-microcontrollers-other-projects-other-projects"><a class="header" href="#bare-metal-microcontrollers-other-projects-other-projects">Other projects</a></h1>
<ul>
<li><a href="https://rtic.rs/">RTIC</a>
<ul>
<li>"Real-Time Interrupt-driven Concurrency"</li>
<li>Shared resource management, message passing, task scheduling, timer queue</li>
</ul>
</li>
<li><a href="https://embassy.dev/">Embassy</a>
<ul>
<li><code>async</code> executors with priorities, timers, networking, USB</li>
</ul>
</li>
<li><a href="https://www.tockos.org/documentation/getting-started">TockOS</a>
<ul>
<li>Security-focused RTOS with preemptive scheduling and Memory Protection Unit
support</li>
</ul>
</li>
<li><a href="https://hubris.oxide.computer/">Hubris</a>
<ul>
<li>Microkernel RTOS from Oxide Computer Company with memory protection,
unprivileged drivers, IPC</li>
</ul>
</li>
<li><a href="https://github.com/lobaro/FreeRTOS-rust">Bindings for FreeRTOS</a></li>
<li>Some platforms have <code>std</code> implementations, e.g.
<a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">esp-idf</a>.</li>
</ul>
<details>
<ul>
<li>RTIC can be considered either an RTOS or a concurrency framework.
<ul>
<li>It doesn't include any HALs.</li>
<li>It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for
scheduling rather than a proper kernel.</li>
<li>Cortex-M only.</li>
</ul>
</li>
<li>Google uses TockOS on the Haven microcontroller for Titan security keys.</li>
<li>FreeRTOS is mostly written in C, but there are Rust bindings for writing
applications.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-bare-metal-morning"></div><h1 id="exercises-bare-metal-morning-exercises"><a class="header" href="#exercises-bare-metal-morning-exercises">Exercises</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial
port.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="#exercises-bare-metal-solutions-morning">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-bare-metal-compass"></div><h1 id="exercises-bare-metal-compass-compass"><a class="header" href="#exercises-bare-metal-compass-compass">Compass</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial
port. If you have time, try displaying it on the LEDs somehow too, or use the
buttons somehow.</p>
<p>Hints:</p>
<ul>
<li>Check the documentation for the
<a href="https://docs.rs/lsm303agr/latest/lsm303agr/"><code>lsm303agr</code></a> and
<a href="https://docs.rs/microbit-v2/latest/microbit/"><code>microbit-v2</code></a> crates, as well
as the <a href="https://tech.microbit.org/hardware/">micro:bit hardware</a>.</li>
<li>The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.</li>
<li>TWI is another name for I2C, so the I2C master peripheral is called TWIM.</li>
<li>The LSM303AGR driver needs something implementing the <code>embedded_hal::i2c::I2c</code>
trait. The
<a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html"><code>microbit::hal::Twim</code></a>
struct implements this.</li>
<li>You have a
<a href="https://docs.rs/microbit-v2/latest/microbit/struct.Board.html"><code>microbit::Board</code></a>
struct with fields for the various pins and peripherals.</li>
<li>You can also look at the
<a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf">nRF52833 datasheet</a>
if you want, but it shouldn't be necessary for this exercise.</li>
</ul>
<p>Download the <a href="#comprehensive-rust-exercises.zip">exercise template</a> and
look in the <code>compass</code> directory for the following files.</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use microbit::{hal::{Delay, uarte::{Baudrate, Parity, Uarte}}, Board};

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    // TODO

    writeln!(serial, "Ready.").unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // TODO
    }
}</code></pre></pre>
<p><em>Cargo.toml</em> (you shouldn't need to change this):</p>
<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[workspace]

[package]
name = "compass"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
cortex-m-rt = "0.7.3"
embedded-hal = "1.0.0"
lsm303agr = "1.1.0"
microbit-v2 = "0.15.1"
panic-halt = "0.2.0"
</code></pre>
<p><em>Embed.toml</em> (you shouldn't need to change this):</p>
<!-- File Embed.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[default.general]
chip = "nrf52833_xxAA"

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true
</code></pre>
<p><em>.cargo/config.toml</em> (you shouldn't need to change this):</p>
<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[build]
target = "thumbv7em-none-eabihf" # Cortex-M4F

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
rustflags = ["-C", "link-arg=-Tlink.x"]
</code></pre>
<p>See the serial output on Linux with:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
</code></pre>
<p>Or on Mac OS something like (the device name may be slightly different):</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
</code></pre>
<p>Use Ctrl+A Ctrl+Q to quit picocom.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-bare-metal-solutions-morning"></div><h1 id="exercises-bare-metal-solutions-morning-bare-metal-rust-morning-exercise"><a class="header" href="#exercises-bare-metal-solutions-morning-bare-metal-rust-morning-exercise">Bare Metal Rust Morning Exercise</a></h1>
<h2 id="exercises-bare-metal-solutions-morning-compass"><a class="header" href="#exercises-bare-metal-solutions-morning-compass">Compass</a></h2>
<p>(<a href="#exercises-bare-metal-compass">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use core::cmp::{max, min};
use embedded_hal::digital::InputPin;
use lsm303agr::{
    AccelMode, AccelOutputDataRate, Lsm303agr, MagMode, MagOutputDataRate,
};
use microbit::display::blocking::Display;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::{Delay, Timer};
use microbit::pac::twim0::frequency::FREQUENCY_A;
use microbit::Board;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    writeln!(serial, "Setting up IMU...").unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_mode_and_odr(
        &amp;mut delay,
        MagMode::HighResolution,
        MagOutputDataRate::Hz50,
    )
    .unwrap();
    imu.set_accel_mode_and_odr(
        &amp;mut delay,
        AccelMode::Normal,
        AccelOutputDataRate::Hz50,
    )
    .unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    writeln!(serial, "Ready.").unwrap();

    loop {
        // Read compass data and log it to the serial port.
        while !(imu.mag_status().unwrap().xyz_new_data()
            &amp;&amp; imu.accel_status().unwrap().xyz_new_data())
        {}
        let compass_reading = imu.magnetic_field().unwrap();
        let accelerometer_reading = imu.acceleration().unwrap();
        writeln!(
            serial,
            "{},{},{}\t{},{},{}",
            compass_reading.x_nt(),
            compass_reading.y_nt(),
            compass_reading.z_nt(),
            accelerometer_reading.x_mg(),
            accelerometer_reading.y_mg(),
            accelerometer_reading.z_mg(),
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass =&gt; (
                scale(-compass_reading.x_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
                scale(compass_reading.y_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
            ),
            Mode::Accelerometer =&gt; (
                scale(
                    accelerometer_reading.x_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&amp;mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs
        // on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&amp;mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -&gt; Self {
        match self {
            Self::Compass =&gt; Self::Accelerometer,
            Self::Accelerometer =&gt; Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -&gt; i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    cap(min_out + range_out * (value - min_in) / range_in, min_out, max_out)
}

fn cap(value: i32, min_value: i32, max_value: i32) -&gt; i32 {
    max(min_value, min(value, max_value))
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps"></div><h1 id="bare-metal-aps-application-processors"><a class="header" href="#bare-metal-aps-application-processors">Application processors</a></h1>
<p>So far we've talked about microcontrollers, such as the Arm Cortex-M series. Now
let's try writing something for Cortex-A. For simplicity we'll just work with
QEMU's aarch64
<a href="https://qemu-project.gitlab.io/qemu/system/arm/virt.html">'virt'</a> board.</p>
<details>
<ul>
<li>Broadly speaking, microcontrollers don't have an MMU or multiple levels of
privilege (exception levels on Arm CPUs, rings on x86), while application
processors do.</li>
<li>QEMU supports emulating various different machines or board models for each
architecture. The 'virt' board doesn't correspond to any particular real
hardware, but is designed purely for virtual machines.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-entry-point"></div><h1 id="bare-metal-aps-entry-point-getting-ready-to-rust"><a class="header" href="#bare-metal-aps-entry-point-getting-ready-to-rust">Getting Ready to Rust</a></h1>
<p>Before we can start running Rust code, we need to do some initialisation.</p>
<pre><code class="language-armasm">.section .init.entry, "ax"
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to enable MMU and
     * caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then invalidate any
     * potentially stale local TLB entries before they start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed until this
     * has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 &lt;&lt; 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b
</code></pre>
<details>
<ul>
<li>This is the same as it would be for C: initialising the processor state,
zeroing the BSS, and setting up the stack pointer.
<ul>
<li>The BSS (block starting symbol, for historical reasons) is the part of the
object file which containing statically allocated variables which are
initialised to zero. They are omitted from the image, to avoid wasting space
on zeroes. The compiler assumes that the loader will take care of zeroing
them.</li>
</ul>
</li>
<li>The BSS may already be zeroed, depending on how memory is initialised and the
image is loaded, but we zero it to be sure.</li>
<li>We need to enable the MMU and cache before reading or writing any memory. If
we don't:
<ul>
<li>Unaligned accesses will fault. We build the Rust code for the
<code>aarch64-unknown-none</code> target which sets <code>+strict-align</code> to prevent the
compiler generating unaligned accesses, so it should be fine in this case,
but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The
problem is that the VM is accessing memory directly with the cache disabled,
while the host has cacheable aliases to the same memory. Even if the host
doesn't explicitly access the memory, speculative accesses can lead to cache
fills, and then changes from one or the other will get lost when the cache
is cleaned or the VM enables the cache. (Cache is keyed by physical address,
not VA or IPA.)</li>
</ul>
</li>
<li>For simplicity, we just use a hardcoded pagetable (see <code>idmap.S</code>) which
identity maps the first 1 GiB of address space for devices, the next 1 GiB for
DRAM, and another 1 GiB higher up for more devices. This matches the memory
layout that QEMU uses.</li>
<li>We also set up the exception vector (<code>vbar_el1</code>), which we'll see more about
later.</li>
<li>All examples this afternoon assume we will be running at exception level 1
(EL1). If you need to run at a different exception level you'll need to modify
<code>entry.S</code> accordingly.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-inline-assembly"></div><h1 id="bare-metal-aps-inline-assembly-inline-assembly"><a class="header" href="#bare-metal-aps-inline-assembly-inline-assembly">Inline assembly</a></h1>
<p>Sometimes we need to use assembly to do things that aren't possible with Rust
code. For example, to make an HVC (hypervisor call) to tell the firmware to
power off the system:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

#[no_mangle]
extern "C" fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // SAFETY: this only uses the declared registers and doesn't do anything
    // with memory.
    unsafe {
        asm!("hvc #0",
            inout("w0") PSCI_SYSTEM_OFF =&gt; _,
            inout("w1") 0 =&gt; _,
            inout("w2") 0 =&gt; _,
            inout("w3") 0 =&gt; _,
            inout("w4") 0 =&gt; _,
            inout("w5") 0 =&gt; _,
            inout("w6") 0 =&gt; _,
            inout("w7") 0 =&gt; _,
            options(nomem, nostack)
        );
    }

    loop {}
}</code></pre></pre>
<p>(If you actually want to do this, use the <a href="https://crates.io/crates/smccc"><code>smccc</code></a> crate which has wrappers
for all these functions.)</p>
<details>
<ul>
<li>PSCI is the Arm Power State Coordination Interface, a standard set of
functions to manage system and CPU power states, among other things. It is
implemented by EL3 firmware and hypervisors on many systems.</li>
<li>The <code>0 =&gt; _</code> syntax means initialise the register to 0 before running the
inline assembly code, and ignore its contents afterwards. We need to use
<code>inout</code> rather than <code>in</code> because the call could potentially clobber the
contents of the registers.</li>
<li>This <code>main</code> function needs to be <code>#[no_mangle]</code> and <code>extern "C"</code> because it is
called from our entry point in <code>entry.S</code>.</li>
<li><code>_x0</code>‚Äì<code>_x3</code> are the values of registers <code>x0</code>‚Äì<code>x3</code>, which are conventionally
used by the bootloader to pass things like a pointer to the device tree.
According to the standard aarch64 calling convention (which is what
<code>extern "C"</code> specifies to use), registers <code>x0</code>‚Äì<code>x7</code> are used for the first 8
arguments passed to a function, so <code>entry.S</code> doesn't need to do anything
special except make sure it doesn't change these registers.</li>
<li>Run the example in QEMU with <code>make qemu_psci</code> under
<code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-mmio"></div><h1 id="bare-metal-aps-mmio-volatile-memory-access-for-mmio"><a class="header" href="#bare-metal-aps-mmio-volatile-memory-access-for-mmio">Volatile memory access for MMIO</a></h1>
<ul>
<li>Use <code>pointer::read_volatile</code> and <code>pointer::write_volatile</code>.</li>
<li>Never hold a reference.</li>
<li><code>addr_of!</code> lets you get fields of structs without creating an intermediate
reference.</li>
</ul>
<details>
<ul>
<li>Volatile access: read or write operations may have side-effects, so prevent
the compiler or hardware from reordering, duplicating or eliding them.
<ul>
<li>Usually if you write and then read, e.g. via a mutable reference, the
compiler may assume that the value read is the same as the value just
written, and not bother actually reading memory.</li>
</ul>
</li>
<li>Some existing crates for volatile access to hardware do hold references, but
this is unsound. Whenever a reference exist, the compiler may choose to
dereference it.</li>
<li>Use the <code>addr_of!</code> macro to get struct field pointers from a pointer to the
struct.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-uart"></div><h1 id="bare-metal-aps-uart-lets-write-a-uart-driver"><a class="header" href="#bare-metal-aps-uart-lets-write-a-uart-driver">Let's write a UART driver</a></h1>
<p>The QEMU 'virt' machine has a <a href="https://developer.arm.com/documentation/ddi0183/g">PL011</a> UART, so let's write a driver for that.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 &lt;&lt; 3;
const FR_TXFF: u8 = 1 &lt;&lt; 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -&gt; Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() &amp; FR_TXFF != 0 {}

        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() &amp; FR_BUSY != 0 {}
    }

    fn read_flag_register(&amp;self) -&gt; u8 {
        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}</code></pre></pre>
<details>
<ul>
<li>Note that <code>Uart::new</code> is unsafe while the other methods are safe. This is
because as long as the caller of <code>Uart::new</code> guarantees that its safety
requirements are met (i.e. that there is only ever one instance of the driver
for a given UART, and nothing else aliasing its address space), then it is
always safe to call <code>write_byte</code> later because we can assume the necessary
preconditions.</li>
<li>We could have done it the other way around (making <code>new</code> safe but <code>write_byte</code>
unsafe), but that would be much less convenient to use as every place that
calls <code>write_byte</code> would need to reason about the safety</li>
<li>This is a common pattern for writing safe wrappers of unsafe code: moving the
burden of proof for soundness from a large number of places to a smaller
number of places.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-uart-traits"></div><h1 id="bare-metal-aps-uart-traits-more-traits"><a class="header" href="#bare-metal-aps-uart-traits-more-traits">More traits</a></h1>
<p>We derived the <code>Debug</code> trait. It would be useful to implement a few more traits
too.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// SAFETY: `Uart` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}</code></pre></pre>
<details>
<ul>
<li>Implementing <code>Write</code> lets us use the <code>write!</code> and <code>writeln!</code> macros with our
<code>Uart</code> type.</li>
<li>Run the example in QEMU with <code>make qemu_minimal</code> under
<code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-better-uart"></div><h1 id="bare-metal-aps-better-uart-a-better-uart-driver"><a class="header" href="#bare-metal-aps-better-uart-a-better-uart-driver">A better UART driver</a></h1>
<p>The PL011 actually has <a href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers">a bunch more registers</a>, and adding offsets to
construct pointers to access them is error-prone and hard to read. Plus, some of
them are bit fields which would be nice to access in a structured way.</p>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Register name</th><th>Width</th></tr></thead><tbody>
<tr><td>0x00</td><td>DR</td><td>12</td></tr>
<tr><td>0x04</td><td>RSR</td><td>4</td></tr>
<tr><td>0x18</td><td>FR</td><td>9</td></tr>
<tr><td>0x20</td><td>ILPR</td><td>8</td></tr>
<tr><td>0x24</td><td>IBRD</td><td>16</td></tr>
<tr><td>0x28</td><td>FBRD</td><td>6</td></tr>
<tr><td>0x2c</td><td>LCR_H</td><td>8</td></tr>
<tr><td>0x30</td><td>CR</td><td>16</td></tr>
<tr><td>0x34</td><td>IFLS</td><td>6</td></tr>
<tr><td>0x38</td><td>IMSC</td><td>11</td></tr>
<tr><td>0x3c</td><td>RIS</td><td>11</td></tr>
<tr><td>0x40</td><td>MIS</td><td>11</td></tr>
<tr><td>0x44</td><td>ICR</td><td>11</td></tr>
<tr><td>0x48</td><td>DMACR</td><td>3</td></tr>
</tbody></table>
</div><details>
<ul>
<li>There are also some ID registers which have been omitted for brevity.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-better-uart-bitflags"></div><h1 id="bare-metal-aps-better-uart-bitflags-bitflags"><a class="header" href="#bare-metal-aps-better-uart-bitflags-bitflags">Bitflags</a></h1>
<p>The <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate is useful for working
with bitflags.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}</code></pre></pre>
<details>
<ul>
<li>The <code>bitflags!</code> macro creates a newtype something like <code>Flags(u16)</code>, along
with a bunch of method implementations to get and set flags.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-better-uart-registers"></div><h1 id="bare-metal-aps-better-uart-registers-multiple-registers"><a class="header" href="#bare-metal-aps-better-uart-registers-multiple-registers">Multiple registers</a></h1>
<p>We can use a struct to represent the memory layout of the UART's registers.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}</code></pre></pre>
<details>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a>
tells the compiler to lay the struct fields out in order, following the same
rules as C. This is necessary for our struct to have a predictable layout, as
default Rust representation allows the compiler to (among other things)
reorder fields however it sees fit.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-better-uart-driver"></div><h1 id="bare-metal-aps-better-uart-driver-driver"><a class="header" href="#bare-metal-aps-better-uart-driver-driver">Driver</a></h1>
<p>Now let's use the new <code>Registers</code> struct in our driver.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}</code></pre></pre>
<details>
<ul>
<li>Note the use of <code>addr_of!</code> / <code>addr_of_mut!</code> to get pointers to individual
fields without creating an intermediate reference, which would be unsound.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-better-uart-using"></div><h1 id="bare-metal-aps-better-uart-using-using-it"><a class="header" href="#bare-metal-aps-better-uart-using-using-it">Using it</a></h1>
<p>Let's write a small program using our driver to write to the serial console, and
echo incoming bytes.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, "main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})").unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' =&gt; {
                    uart.write_byte(b'\n');
                }
                b'q' =&gt; break,
                _ =&gt; {}
            }
        }
    }

    writeln!(uart, "Bye!").unwrap();
    system_off::&lt;Hvc&gt;().unwrap();
}</code></pre></pre>
<details>
<ul>
<li>As in the <a href="#bare-metal-aps-inline-assembly">inline assembly</a> example, this <code>main</code>
function is called from our entry point code in <code>entry.S</code>. See the speaker
notes there for details.</li>
<li>Run the example in QEMU with <code>make qemu</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-logging"></div><h1 id="bare-metal-aps-logging-logging"><a class="header" href="#bare-metal-aps-logging-logging">Logging</a></h1>
<p>It would be nice to be able to use the logging macros from the <a href="https://crates.io/crates/log"><code>log</code></a> crate.
We can do this by implementing the <code>Log</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            "[{}] {}",
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}</code></pre></pre>
<details>
<ul>
<li>The unwrap in <code>log</code> is safe because we initialise <code>LOGGER</code> before calling
<code>set_logger</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-logging-using"></div><h1 id="bare-metal-aps-logging-using-using-it"><a class="header" href="#bare-metal-aps-logging-using-using-it">Using it</a></h1>
<p>We need to initialise the logger before we use it.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use log::{error, info, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!("main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})");

    assert_eq!(x1, 42);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!("{info}");
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}</code></pre></pre>
<details>
<ul>
<li>Note that our panic handler can now log details of panics.</li>
<li>Run the example in QEMU with <code>make qemu_logger</code> under
<code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-exceptions"></div><h1 id="bare-metal-aps-exceptions-exceptions"><a class="header" href="#bare-metal-aps-exceptions-exceptions">Exceptions</a></h1>
<p>AArch64 defines an exception vector table with 16 entries, for 4 types of
exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with SP0,
current EL with SPx, lower EL using AArch64, lower EL using AArch32). We
implement this in assembly to save volatile registers to the stack before
calling into Rust code:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern "C" fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!("sync_exception_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn irq_current(_elr: u64, _spsr: u64) {
    error!("irq_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn fiq_current(_elr: u64, _spsr: u64) {
    error!("fiq_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn serr_current(_elr: u64, _spsr: u64) {
    error!("serr_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn sync_lower(_elr: u64, _spsr: u64) {
    error!("sync_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn irq_lower(_elr: u64, _spsr: u64) {
    error!("irq_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn fiq_lower(_elr: u64, _spsr: u64) {
    error!("fiq_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn serr_lower(_elr: u64, _spsr: u64) {
    error!("serr_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}</code></pre></pre>
<details>
<ul>
<li>EL is exception level; all our examples this afternoon run in EL1.</li>
<li>For simplicity we aren't distinguishing between SP0 and SPx for the current EL
exceptions, or between AArch32 and AArch64 for the lower EL exceptions.</li>
<li>For this example we just log the exception and power down, as we don't expect
any of them to actually happen.</li>
<li>We can think of exception handlers and our main execution context more or less
like different threads. <a href="#concurrency-send-sync"><code>Send</code> and <code>Sync</code></a> will control what we can share
between them, just like with threads. For example, if we want to share some
value between exception handlers and the rest of the program, and it's <code>Send</code>
but not <code>Sync</code>, then we'll need to wrap it in something like a <code>Mutex</code> and put
it in a static.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-aps-other-projects"></div><h1 id="bare-metal-aps-other-projects-other-projects"><a class="header" href="#bare-metal-aps-other-projects-other-projects">Other projects</a></h1>
<ul>
<li><a href="https://github.com/oreboot/oreboot">oreboot</a>
<ul>
<li>"coreboot without the C"</li>
<li>Supports x86, aarch64 and RISC-V.</li>
<li>Relies on LinuxBoot rather than having many drivers itself.</li>
</ul>
</li>
<li><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Rust RaspberryPi OS tutorial</a>
<ul>
<li>Initialisation, UART driver, simple bootloader, JTAG, exception levels,
exception handling, page tables</li>
<li>Some dodginess around cache maintenance and initialisation in Rust, not
necessarily a good example to copy for production code.</li>
</ul>
</li>
<li><a href="https://crates.io/crates/cargo-call-stack"><code>cargo-call-stack</code></a>
<ul>
<li>Static analysis to determine maximum stack usage.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>The RaspberryPi OS tutorial runs Rust code before the MMU and caches are
enabled. This will read and write memory (e.g. the stack). However:
<ul>
<li>Without the MMU and cache, unaligned accesses will fault. It builds with
<code>aarch64-unknown-none</code> which sets <code>+strict-align</code> to prevent the compiler
generating unaligned accesses so it should be alright, but this is not
necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The
problem is that the VM is accessing memory directly with the cache disabled,
while the host has cacheable aliases to the same memory. Even if the host
doesn't explicitly access the memory, speculative accesses can lead to cache
fills, and then changes from one or the other will get lost. Again this is
alright in this particular case (running directly on the hardware with no
hypervisor), but isn't a good pattern in general.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-useful-crates"></div><h1 id="bare-metal-useful-crates-useful-crates"><a class="header" href="#bare-metal-useful-crates-useful-crates">Useful crates</a></h1>
<p>We'll go over a few crates which solve some common problems in bare-metal
programming.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-useful-crates-zerocopy"></div><h1 id="bare-metal-useful-crates-zerocopy-zerocopy"><a class="header" href="#bare-metal-useful-crates-zerocopy-zerocopy"><code>zerocopy</code></a></h1>
<p>The <a href="https://docs.rs/zerocopy/"><code>zerocopy</code></a> crate (from Fuchsia) provides traits and macros for safely
converting between byte sequences and other types.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use zerocopy::AsBytes;

#[repr(u32)]
#[derive(AsBytes, Debug, Default)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(AsBytes, Debug, Default)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &amp;[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}</code></pre></pre>
<p>This is not suitable for MMIO (as it doesn't use volatile reads and writes), but
can be useful for working with structures shared with hardware e.g. by DMA, or
sent over some external interface.</p>
<details>
<ul>
<li><code>FromBytes</code> can be implemented for types for which any byte pattern is valid,
and so can safely be converted from an untrusted sequence of bytes.</li>
<li>Attempting to derive <code>FromBytes</code> for these types would fail, because
<code>RequestType</code> doesn't use all possible u32 values as discriminants, so not all
byte patterns are valid.</li>
<li><code>zerocopy::byteorder</code> has types for byte-order aware numeric primitives.</li>
<li>Run the example with <code>cargo run</code> under
<code>src/bare-metal/useful-crates/zerocopy-example/</code>. (It won't run in the
Playground because of the crate dependency.)</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-useful-crates-aarch64-paging"></div><h1 id="bare-metal-useful-crates-aarch64-paging-aarch64-paging"><a class="header" href="#bare-metal-useful-crates-aarch64-paging-aarch64-paging"><code>aarch64-paging</code></a></h1>
<p>The <a href="https://crates.io/crates/aarch64-paging"><code>aarch64-paging</code></a> crate lets you create page tables according to the
AArch64 Virtual Memory System Architecture.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &amp;MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();</code></pre></pre>
<details>
<ul>
<li>For now it only supports EL1, but support for other exception levels should be
straightforward to add.</li>
<li>This is used in Android for the <a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Virtualization/pvmfw/">Protected VM Firmware</a>.</li>
<li>There's no easy way to run this example, as it needs to run on real hardware
or under QEMU.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-useful-crates-buddy_system_allocator"></div><h1 id="bare-metal-useful-crates-buddy_system_allocator-buddy_system_allocator"><a class="header" href="#bare-metal-useful-crates-buddy_system_allocator-buddy_system_allocator"><code>buddy_system_allocator</code></a></h1>
<p><a href="https://crates.io/crates/buddy_system_allocator"><code>buddy_system_allocator</code></a> is a third-party crate implementing a basic buddy
system allocator. It can be used both for <a href="https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html"><code>LockedHeap</code></a> implementing
<a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> so you can use the standard <code>alloc</code> crate (as we saw
<a href="#bare-metal-alloc">before</a>), or for allocating other address space. For example, we might want
to allocate MMIO space for PCI BARs:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::&lt;32&gt;::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect("Failed to allocate 0x100 byte MMIO region");
    println!("Allocated 0x100 byte MMIO region at {:#x}", bar);
}</code></pre></pre>
<details>
<ul>
<li>PCI BARs always have alignment equal to their size.</li>
<li>Run the example with <code>cargo run</code> under
<code>src/bare-metal/useful-crates/allocator-example/</code>. (It won't run in the
Playground because of the crate dependency.)</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-useful-crates-tinyvec"></div><h1 id="bare-metal-useful-crates-tinyvec-tinyvec"><a class="header" href="#bare-metal-useful-crates-tinyvec-tinyvec"><code>tinyvec</code></a></h1>
<p>Sometimes you want something which can be resized like a <code>Vec</code>, but without heap
allocation. <a href="https://crates.io/crates/tinyvec"><code>tinyvec</code></a> provides this: a vector backed by an array or slice,
which could be statically allocated or on the stack, which keeps track of how
many elements are used and panics if you try to use more than are allocated.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tinyvec::{array_vec, ArrayVec};

fn main() {
    let mut numbers: ArrayVec&lt;[u32; 5]&gt; = array_vec!(42, 66);
    println!("{numbers:?}");
    numbers.push(7);
    println!("{numbers:?}");
    numbers.remove(1);
    println!("{numbers:?}");
}</code></pre></pre>
<details>
<ul>
<li><code>tinyvec</code> requires that the element type implement <code>Default</code> for
initialisation.</li>
<li>The Rust Playground includes <code>tinyvec</code>, so this example will run fine inline.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-useful-crates-spin"></div><h1 id="bare-metal-useful-crates-spin-spin"><a class="header" href="#bare-metal-useful-crates-spin-spin"><code>spin</code></a></h1>
<p><code>std::sync::Mutex</code> and the other synchronisation primitives from <code>std::sync</code> are
not available in <code>core</code> or <code>alloc</code>. How can we manage synchronisation or
interior mutability, such as for sharing state between different CPUs?</p>
<p>The <a href="https://crates.io/crates/spin"><code>spin</code></a> crate provides spinlock-based equivalents of many of these
primitives.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use spin::mutex::SpinMutex;

static counter: SpinMutex&lt;u32&gt; = SpinMutex::new(0);

fn main() {
    println!("count: {}", counter.lock());
    *counter.lock() += 2;
    println!("count: {}", counter.lock());
}</code></pre></pre>
<details>
<ul>
<li>Be careful to avoid deadlock if you take locks in interrupt handlers.</li>
<li><code>spin</code> also has a ticket lock mutex implementation; equivalents of <code>RwLock</code>,
<code>Barrier</code> and <code>Once</code> from <code>std::sync</code>; and <code>Lazy</code> for lazy initialisation.</li>
<li>The <a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crate also has some useful types for late initialisation
with a slightly different approach to <code>spin::once::Once</code>.</li>
<li>The Rust Playground includes <code>spin</code>, so this example will run fine inline.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-android"></div><h1 id="bare-metal-android-android"><a class="header" href="#bare-metal-android-android">Android</a></h1>
<p>To build a bare-metal Rust binary in AOSP, you need to use a <code>rust_ffi_static</code>
Soong rule to build your Rust code, then a <code>cc_binary</code> with a linker script to
produce the binary itself, and then a <code>raw_binary</code> to convert the ELF to a raw
binary ready to be run.</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-soong">rust_ffi_static {
    name: "libvmbase_example",
    defaults: ["vmbase_ffi_defaults"],
    crate_name: "vmbase_example",
    srcs: ["src/main.rs"],
    rustlibs: [
        "libvmbase",
    ],
}

cc_binary {
    name: "vmbase_example",
    defaults: ["vmbase_elf_defaults"],
    srcs: [
        "idmap.S",
    ],
    static_libs: [
        "libvmbase_example",
    ],
    linker_scripts: [
        "image.ld",
        ":vmbase_sections",
    ],
}

raw_binary {
    name: "vmbase_example_bin",
    stem: "vmbase_example.bin",
    src: ":vmbase_example",
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="bare-metal-android-vmbase"></div><h1 id="bare-metal-android-vmbase-vmbase"><a class="header" href="#bare-metal-android-vmbase-vmbase">vmbase</a></h1>
<p>For VMs running under crosvm on aarch64, the <a href="https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/main/libs/libvmbase/">vmbase</a> library provides a
linker script and useful defaults for the build rules, along with an entry
point, UART console logging and more.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!("Hello world");
}</code></pre></pre>
<details>
<ul>
<li>The <code>main!</code> macro marks your main function, to be called from the <code>vmbase</code>
entry point.</li>
<li>The <code>vmbase</code> entry point handles console initialisation, and issues a
PSCI_SYSTEM_OFF to shutdown the VM if your main function returns.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-bare-metal-afternoon"></div><h1 id="exercises-bare-metal-afternoon-exercises"><a class="header" href="#exercises-bare-metal-afternoon-exercises">Exercises</a></h1>
<p>We will write a driver for the PL031 real-time clock device.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="#exercises-bare-metal-solutions-afternoon">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-bare-metal-rtc"></div><h1 id="exercises-bare-metal-rtc-rtc-driver"><a class="header" href="#exercises-bare-metal-rtc-rtc-driver">RTC driver</a></h1>
<p>The QEMU aarch64 virt machine has a <a href="https://developer.arm.com/documentation/ddi0224/c">PL031</a> real-time clock at 0x9010000. For
this exercise, you should write a driver for it.</p>
<ol>
<li>Use it to print the current time to the serial console. You can use the
<a href="https://crates.io/crates/chrono"><code>chrono</code></a> crate for date/time formatting.</li>
<li>Use the match register and raw interrupt status to busy-wait until a given
time, e.g. 3 seconds in the future. (Call <a href="https://doc.rust-lang.org/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop</code></a> inside
the loop.)</li>
<li><em>Extension if you have time:</em> Enable and handle the interrupt generated by
the RTC match. You can use the driver provided in the <a href="https://docs.rs/arm-gic/"><code>arm-gic</code></a> crate to
configure the Arm Generic Interrupt Controller.
<ul>
<li>Use the RTC interrupt, which is wired to the GIC as <code>IntId::spi(2)</code>.</li>
<li>Once the interrupt is enabled, you can put the core to sleep via
<code>arm_gic::wfi()</code>, which will cause the core to sleep until it receives an
interrupt.</li>
</ul>
</li>
</ol>
<p>Download the <a href="#comprehensive-rust-exercises.zip">exercise template</a> and
look in the <code>rtc</code> directory for the following files.</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!("main({:#x}, {:#x}, {:#x}, {:#x})", x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!("{info}");
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}</code></pre></pre>
<p><em>src/exceptions.rs</em> (you should only need to change this for the 3rd part of the
exercise):</p>
<!-- File src/exceptions.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::GicV3;
use log::{error, info, trace};
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern "C" fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!("sync_exception_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn irq_current(_elr: u64, _spsr: u64) {
    trace!("irq_current");
    let intid =
        GicV3::get_and_acknowledge_interrupt().expect("No pending interrupt");
    info!("IRQ {intid:?}");
}

#[no_mangle]
extern "C" fn fiq_current(_elr: u64, _spsr: u64) {
    error!("fiq_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn serr_current(_elr: u64, _spsr: u64) {
    error!("serr_current");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn sync_lower(_elr: u64, _spsr: u64) {
    error!("sync_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn irq_lower(_elr: u64, _spsr: u64) {
    error!("irq_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn fiq_lower(_elr: u64, _spsr: u64) {
    error!("fiq_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern "C" fn serr_lower(_elr: u64, _spsr: u64) {
    error!("serr_lower");
    system_off::&lt;Hvc&gt;().unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p><em>src/logger.rs</em> (you shouldn't need to change this):</p>
<!-- File src/logger.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            "[{}] {}",
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><em>src/pl011.rs</em> (you shouldn't need to change this):</p>
<!-- File src/pl011.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused)]

use core::fmt::{self, Write};
use core::ptr::{addr_of, addr_of_mut};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 &lt;&lt; 0;
        /// Parity error.
        const PE = 1 &lt;&lt; 1;
        /// Break error.
        const BE = 1 &lt;&lt; 2;
        /// Overrun error.
        const OE = 1 &lt;&lt; 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
<span class="boring">}</span></code></pre></pre>
<p><em>Cargo.toml</em> (you shouldn't need to change this):</p>
<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[workspace]

[package]
name = "rtc"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
arm-gic = "0.1.1"
bitflags = "2.6.0"
chrono = { version = "0.4.38", default-features = false }
log = "0.4.22"
smccc = "0.1.1"
spin = "0.9.8"

[build-dependencies]
cc = "1.1.10"
</code></pre>
<p><em>build.rs</em> (you shouldn't need to change this):</p>
<!-- File build.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use cc::Build;
use std::env;

fn main() {
    #[cfg(target_os = "linux")]
    env::set_var("CROSS_COMPILE", "aarch64-linux-gnu");
    #[cfg(not(target_os = "linux"))]
    env::set_var("CROSS_COMPILE", "aarch64-none-elf");

    Build::new()
        .file("entry.S")
        .file("exceptions.S")
        .file("idmap.S")
        .compile("empty")
}</code></pre></pre>
<p><em>entry.S</em> (you shouldn't need to change this):</p>
<!-- File entry.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
	adrp \reg, \sym
	add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
	movz \reg, :abs_g3:\imm
	movk \reg, :abs_g2_nc:\imm
	movk \reg, :abs_g1_nc:\imm
	movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE,	0x04
.set .L_MAIR_MEM_WBWA,	0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA &lt;&lt; 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 &lt;&lt; 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 &lt;&lt; 30
/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */
.set .L_TCR_EPD1, 0x1 &lt;&lt; 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 &lt;&lt; 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 &lt;&lt; 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 &lt;&lt; 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 &lt;&lt; 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 &lt;&lt; 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 &lt;&lt; 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 &lt;&lt; 0
/* Privileged Access Never is unchanged on taking an exception to EL1. */
.set .L_SCTLR_EL1_SPAN, 0x1 &lt;&lt; 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 &lt;&lt; 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 &lt;&lt; 7
.set .L_SCTLR_EL1_RES1, (0x1 &lt;&lt; 11) | (0x1 &lt;&lt; 20) | (0x1 &lt;&lt; 22) | (0x1 &lt;&lt; 28) | (0x1 &lt;&lt; 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

/**
 * This is a generic entry point for an image. It carries out the operations required to prepare the
 * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,
 * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-x3
 * for the Rust entry point, as these may contain boot parameters.
 */
.section .init.entry, "ax"
.global entry
entry:
	/* Load and apply the memory management configuration, ready to enable MMU and caches. */
	adrp x30, idmap
	msr ttbr0_el1, x30

	mov_i x30, .Lmairval
	msr mair_el1, x30

	mov_i x30, .Ltcrval
	/* Copy the supported PA range into TCR_EL1.IPS. */
	mrs x29, id_aa64mmfr0_el1
	bfi x30, x29, #32, #4

	msr tcr_el1, x30

	mov_i x30, .Lsctlrval

	/*
	 * Ensure everything before this point has completed, then invalidate any potentially stale
	 * local TLB entries before they start being used.
	 */
	isb
	tlbi vmalle1
	ic iallu
	dsb nsh
	isb

	/*
	 * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.
	 */
	msr sctlr_el1, x30
	isb

	/* Disable trapping floating point access in EL1. */
	mrs x30, cpacr_el1
	orr x30, x30, #(0x3 &lt;&lt; 20)
	msr cpacr_el1, x30
	isb

	/* Zero out the bss section. */
	adr_l x29, bss_begin
	adr_l x30, bss_end
0:	cmp x29, x30
	b.hs 1f
	stp xzr, xzr, [x29], #16
	b 0b

1:	/* Prepare the stack. */
	adr_l x30, boot_stack_end
	mov sp, x30

	/* Set up exception vector. */
	adr x30, vector_table_el1
	msr vbar_el1, x30

	/* Call into Rust code. */
	bl main

	/* Loop forever waiting for interrupts. */
2:	wfi
	b 2b
</code></pre>
<p><em>exceptions.S</em> (you shouldn't need to change this):</p>
<!-- File exceptions.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes 14
 * instructions, so it can be used in exception handlers with 18 instructions
 * left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,
 * which can be used as the first and second arguments of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 &amp; x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 &amp; spsr_el1. This such that we can take nested exception
	 * and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently takes 14
 * instructions, so it can be used in exception handlers while still leaving 18
 * instructions left; if paired with save_volatile_to_stack, there are 4
 * instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 &amp; x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/* Restore registers elr_el1 &amp; spsr_el1, using x0 &amp; x1 as scratch. */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 &amp; x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SP0. It behaves similarly to the SPx case by first switching to SPx, doing
 * the work, then switching back to SP0 before returning.
 *
 * Switching to SPx and calling the Rust handler takes 16 instructions. To
 * restore and return we need an additional 16 instructions, so we can implement
 * the whole handler within the allotted 32 instructions.
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SPx. It saves volatile registers, calls the Rust handler, restores volatile
 * registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care about
 * non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions, and
 * restoring and returning also takes 15 instructions, so we can fit the whole
 * handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, "ax"
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower
</code></pre>
<p><em>idmap.S</em> (you shouldn't need to change this):</p>
<!-- File idmap.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 &lt;&lt; 10
/* Not global. */
.set .L_TT_NG, 0x1 &lt;&lt; 11
.set .L_TT_XN, 0x3 &lt;&lt; 53

.set .L_TT_MT_DEV, 0x0 &lt;&lt; 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 &lt;&lt; 2) | (0x3 &lt;&lt; 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section ".rodata.idmap", "a", %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space
</code></pre>
<p><em>image.ld</em> (you shouldn't need to change this):</p>
<!-- File image.ld -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-ld">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start of the
 * image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} &gt;image
	.text : {
		*(.text.*)
	} &gt;image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} &gt;image
	.got : {
		*(.got)
	} &gt;image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end which
	 * will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} &gt;image

	/* Everything beyond this point will not be included in the binary. */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} &gt;image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} &gt;image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}
</code></pre>
<p><em>Makefile</em> (you shouldn't need to change this):</p>
<!-- File Makefile -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-makefile"># Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

UNAME := $(shell uname -s)
ifeq ($(UNAME),Linux)
	TARGET = aarch64-linux-gnu
else
	TARGET = aarch64-none-elf
endif
OBJCOPY = $(TARGET)-objcopy

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $&lt; -s

clean:
	cargo clean
	rm -f *.bin
</code></pre>
<p><em>.cargo/config.toml</em> (you shouldn't need to change this):</p>
<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[build]
target = "aarch64-unknown-none"
rustflags = ["-C", "link-arg=-Timage.ld"]
</code></pre>
<p>Run the code in QEMU with <code>make qemu</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="exercises-bare-metal-solutions-afternoon"></div><h1 id="exercises-bare-metal-solutions-afternoon-bare-metal-rust-afternoon"><a class="header" href="#exercises-bare-metal-solutions-afternoon-bare-metal-rust-afternoon">Bare Metal Rust Afternoon</a></h1>
<h2 id="exercises-bare-metal-solutions-afternoon-rtc-driver"><a class="header" href="#exercises-bare-metal-solutions-afternoon-rtc-driver">RTC driver</a></h2>
<p>(<a href="#exercises-bare-metal-rtc">back to exercise</a>)</p>
<p><em>main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;
mod pl031;

use crate::pl031::Rtc;
use arm_gic::gicv3::{IntId, Trigger};
use arm_gic::{irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

#[no_mangle]
extern "C" fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!("main({:#x}, {:#x}, {:#x}, {:#x})", x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and
    // nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!("RTC: {time}");

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, 0x80);
    gic.set_trigger(PL031_IRQ, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!("Waiting for {}", Utc.timestamp_opt(target.into(), 0).unwrap());
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!("Finished waiting");

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!("Waiting for {}", Utc.timestamp_opt(target.into(), 0).unwrap());
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        "matched={}, interrupt_pending={}",
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!("Finished waiting");

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!("{info}");
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}</code></pre></pre>
<p><em>pl031.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ptr::{addr_of, addr_of_mut};

#[repr(C, align(4))]
struct Registers {
    /// Data register
    dr: u32,
    /// Match register
    mr: u32,
    /// Load register
    lr: u32,
    /// Control register
    cr: u8,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: u8,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: u8,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: u8,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: u8,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc {
    registers: *mut Registers,
}

impl Rtc {
    /// Constructs a new instance of the RTC driver for a PL031 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL031 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Reads the current RTC value.
    pub fn read(&amp;self) -&gt; u32 {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).dr).read_volatile() }
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&amp;mut self, value: u32) {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&amp;self) -&gt; bool {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).ris).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&amp;self) -&gt; bool {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).mis).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&amp;mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).imsc).write_volatile(imsc) }
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&amp;mut self) {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }
    }
}

// SAFETY: `Rtc` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Rtc {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-welcome"></div><h1 id="concurrency-welcome-welcome-to-concurrency-in-rust"><a class="header" href="#concurrency-welcome-welcome-to-concurrency-in-rust">Welcome to Concurrency in Rust</a></h1>
<p>Rust has full support for concurrency using OS threads with mutexes and
channels.</p>
<p>The Rust type system plays an important role in making many concurrency bugs
compile time bugs. This is often referred to as <em>fearless concurrency</em> since you
can rely on the compiler to ensure correctness at runtime.</p>
<h2 id="concurrency-welcome-schedule"><a class="header" href="#concurrency-welcome-schedule">Schedule</a></h2>
<p>Including 10 minute breaks, this session should take about 3 hours and 20 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Threads</td><td>30 minutes</td></tr>
<tr><td>Channels</td><td>20 minutes</td></tr>
<tr><td>Send and Sync</td><td>15 minutes</td></tr>
<tr><td>Shared State</td><td>30 minutes</td></tr>
<tr><td>Exercises</td><td>1 hour and 10 minutes</td></tr>
</tbody></table>
</div><details>
<ul>
<li>Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc.</li>
<li>The type system gives us safety for concurrency without any special features.</li>
<li>The same tools that help with "concurrent" access in a single thread (e.g., a
called function that might mutate an argument or save references to it to read
later) save us from multi-threading issues.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-threads"></div><h1 id="concurrency-threads-threads"><a class="header" href="#concurrency-threads-threads">Threads</a></h1>
<p>This segment should take about 30 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Plain Threads</td><td>15 minutes</td></tr>
<tr><td>Scoped Threads</td><td>15 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-threads-plain"></div><h1 id="concurrency-threads-plain-plain-threads"><a class="header" href="#concurrency-threads-plain-plain-threads">Plain Threads</a></h1>
<p>Rust threads work similarly to threads in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 0..10 {
            println!("Count in thread: {i}!");
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 0..5 {
        println!("Main thread: {i}");
        thread::sleep(Duration::from_millis(5));
    }
}</code></pre></pre>
<ul>
<li>Spawning new threads does not automatically delay program termination at the
end of <code>main</code>.</li>
<li>Thread panics are independent of each other.
<ul>
<li>Panics can carry a payload, which can be unpacked with <code>downcast_ref</code>.</li>
</ul>
</li>
</ul>
<details>
This slide should take about 15 minutes. 
<ul>
<li>
<p>Rust thread APIs look not too different from e.g. C++ ones.</p>
</li>
<li>
<p>Run the example.</p>
<ul>
<li>5ms timing is loose enough that main and spawned threads stay mostly in
lockstep.</li>
<li>Notice that the program ends before the spawned thread reaches 10!</li>
<li>This is because main ends the program and spawned threads do not make it
persist.
<ul>
<li>Compare to pthreads/C++ std::thread/boost::thread if desired.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How do we wait around for the spawned thread to complete?</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a> returns a <code>JoinHandle</code>. Look at the docs.</p>
<ul>
<li><code>JoinHandle</code> has a <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>.join()</code></a> method that blocks.</li>
</ul>
</li>
<li>
<p>Use <code>let handle = thread::spawn(...)</code> and later <code>handle.join()</code> to wait for
the thread to finish and have the program count all the way to 10.</p>
</li>
<li>
<p>Now what if we want to return a value?</p>
</li>
<li>
<p>Look at docs again:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a>'s closure returns <code>T</code></li>
<li><code>JoinHandle</code> <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>.join()</code></a> returns <code>thread::Result&lt;T&gt;</code></li>
</ul>
</li>
<li>
<p>Use the <code>Result</code> return value from <code>handle.join()</code> to get access to the
returned value.</p>
</li>
<li>
<p>Ok, what about the other case?</p>
<ul>
<li>Trigger a panic in the thread. Note that this doesn't panic <code>main</code>.</li>
<li>Access the panic payload. This is a good time to talk about <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>.</li>
</ul>
</li>
<li>
<p>Now we can return values from threads! What about taking inputs?</p>
<ul>
<li>Capture something by reference in the thread closure.</li>
<li>An error message indicates we must move it.</li>
<li>Move it in, see we can compute and then return a derived value.</li>
</ul>
</li>
<li>
<p>If we want to borrow?</p>
<ul>
<li>Main kills child threads when it returns, but another function would just
return and leave them running.</li>
<li>That would be stack use-after-return, which violates memory safety!</li>
<li>How do we avoid this? see next slide.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-threads-scoped"></div><h1 id="concurrency-threads-scoped-scoped-threads"><a class="header" href="#concurrency-threads-scoped-scoped-threads">Scoped Threads</a></h1>
<p>Normal threads cannot borrow from their environment:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;

fn foo() {
    let s = String::from("Hello");
    thread::spawn(|| {
        println!("Length: {}", s.len());
    });
}

fn main() {
    foo();
}</code></pre></pre>
<p>However, you can use a <a href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped thread</a> for this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;

fn main() {
    let s = String::from("Hello");

    thread::scope(|scope| {
        scope.spawn(|| {
            println!("Length: {}", s.len());
        });
    });
}</code></pre></pre>
<details>
This slide should take about 13 minutes. 
<ul>
<li>The reason for that is that when the <code>thread::scope</code> function completes, all
the threads are guaranteed to be joined, so they can return borrowed data.</li>
<li>Normal Rust borrowing rules apply: you can either borrow mutably by one
thread, or immutably by any number of threads.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-channels"></div><h1 id="concurrency-channels-channels"><a class="header" href="#concurrency-channels-channels">Channels</a></h1>
<p>This segment should take about 20 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Senders and Receivers</td><td>10 minutes</td></tr>
<tr><td>Unbounded Channels</td><td>2 minutes</td></tr>
<tr><td>Bounded Channels</td><td>10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-channels-senders-receivers"></div><h1 id="concurrency-channels-senders-receivers-senders-and-receivers"><a class="header" href="#concurrency-channels-senders-receivers-senders-and-receivers">Senders and Receivers</a></h1>
<p>Rust channels have two parts: a <code>Sender&lt;T&gt;</code> and a <code>Receiver&lt;T&gt;</code>. The two parts
are connected via the channel, but you only see the end-points.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!("Received: {:?}", rx.recv());
    println!("Received: {:?}", rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!("Received: {:?}", rx.recv());
}</code></pre></pre>
<details>
This slide should take about 9 minutes. 
<ul>
<li><code>mpsc</code> stands for Multi-Producer, Single-Consumer. <code>Sender</code> and <code>SyncSender</code>
implement <code>Clone</code> (so you can make multiple producers) but <code>Receiver</code> does
not.</li>
<li><code>send()</code> and <code>recv()</code> return <code>Result</code>. If they return <code>Err</code>, it means the
counterpart <code>Sender</code> or <code>Receiver</code> is dropped and the channel is closed.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-channels-unbounded"></div><h1 id="concurrency-channels-unbounded-unbounded-channels"><a class="header" href="#concurrency-channels-unbounded-unbounded-channels">Unbounded Channels</a></h1>
<p>You get an unbounded and asynchronous channel with <code>mpsc::channel()</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!("Message {i}")).unwrap();
            println!("{thread_id:?}: sent Message {i}");
        }
        println!("{thread_id:?}: done");
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!("Main: got {msg}");
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-channels-bounded"></div><h1 id="concurrency-channels-bounded-bounded-channels"><a class="header" href="#concurrency-channels-bounded-bounded-channels">Bounded Channels</a></h1>
<p>With bounded (synchronous) channels, <code>send</code> can block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!("Message {i}")).unwrap();
            println!("{thread_id:?}: sent Message {i}");
        }
        println!("{thread_id:?}: done");
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!("Main: got {msg}");
    }
}</code></pre></pre>
<details>
This slide should take about 8 minutes. 
<ul>
<li>Calling <code>send</code> will block the current thread until there is space in the
channel for the new message. The thread can be blocked indefinitely if there
is nobody who reads from the channel.</li>
<li>A call to <code>send</code> will abort with an error (that is why it returns <code>Result</code>) if
the channel is closed. A channel is closed when the receiver is dropped.</li>
<li>A bounded channel with a size of zero is called a "rendezvous channel". Every
send will block the current thread until another thread calls <code>recv</code>.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-send-sync"></div><h1 id="concurrency-send-sync-send-and-sync"><a class="header" href="#concurrency-send-sync-send-and-sync"><code>Send</code> and <code>Sync</code></a></h1>
<p>This segment should take about 15 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Marker Traits</td><td>2 minutes</td></tr>
<tr><td>Send</td><td>2 minutes</td></tr>
<tr><td>Sync</td><td>2 minutes</td></tr>
<tr><td>Examples</td><td>10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-send-sync-marker-traits"></div><h1 id="concurrency-send-sync-marker-traits-marker-traits"><a class="header" href="#concurrency-send-sync-marker-traits-marker-traits">Marker Traits</a></h1>
<p>How does Rust know to forbid shared access across threads? The answer is in two
traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>: a type <code>T</code> is <code>Send</code> if it is safe to move a <code>T</code> across a thread
boundary.</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>: a type <code>T</code> is <code>Sync</code> if it is safe to move a <code>&amp;T</code> across a thread
boundary.</li>
</ul>
<p><code>Send</code> and <code>Sync</code> are <a href="#unsafe-rust-unsafe-traits">unsafe traits</a>. The compiler will automatically derive
them for your types as long as they only contain <code>Send</code> and <code>Sync</code> types. You
can also implement them manually when you know it is valid.</p>
<details>
This slide should take about 2 minutes. 
<ul>
<li>One can think of these traits as markers that the type has certain
thread-safety properties.</li>
<li>They can be used in the generic constraints as normal traits.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-send-sync-send"></div><h1 id="concurrency-send-sync-send-send"><a class="header" href="#concurrency-send-sync-send-send"><code>Send</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> if it is safe to move a <code>T</code> value to another thread.</p>
</blockquote>
<p>The effect of moving ownership to another thread is that <em>destructors</em> will run
in that thread. So the question is when you can allocate a value in one thread
and deallocate it in another.</p>
<details>
This slide should take about 2 minutes. 
<p>As an example, a connection to the SQLite library must only be accessed from a
single thread.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-send-sync-sync"></div><h1 id="concurrency-send-sync-sync-sync"><a class="header" href="#concurrency-send-sync-sync-sync"><code>Sync</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> if it is safe to access a <code>T</code> value from multiple
threads at the same time.</p>
</blockquote>
<p>More precisely, the definition is:</p>
<blockquote>
<p><code>T</code> is <code>Sync</code> if and only if <code>&amp;T</code> is <code>Send</code></p>
</blockquote>
<details>
This slide should take about 2 minutes. 
<p>This statement is essentially a shorthand way of saying that if a type is
thread-safe for shared use, it is also thread-safe to pass references of it
across threads.</p>
<p>This is because if a type is Sync it means that it can be shared across multiple
threads without the risk of data races or other synchronization issues, so it is
safe to move it to another thread. A reference to the type is also safe to move
to another thread, because the data it references can be accessed from any
thread safely.</p>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-send-sync-examples"></div><h1 id="concurrency-send-sync-examples-examples"><a class="header" href="#concurrency-send-sync-examples-examples">Examples</a></h1>
<h2 id="concurrency-send-sync-examples-send--sync"><a class="header" href="#concurrency-send-sync-examples-send--sync"><code>Send + Sync</code></a></h2>
<p>Most types you come across are <code>Send + Sync</code>:</p>
<ul>
<li><code>i8</code>, <code>f32</code>, <code>bool</code>, <code>char</code>, <code>&amp;str</code>, ...</li>
<li><code>(T1, T2)</code>, <code>[T; N]</code>, <code>&amp;[T]</code>, <code>struct { x: T }</code>, ...</li>
<li><code>String</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>, ...</li>
<li><code>Arc&lt;T&gt;</code>: Explicitly thread-safe via atomic reference count.</li>
<li><code>Mutex&lt;T&gt;</code>: Explicitly thread-safe via internal locking.</li>
<li><code>mpsc::Sender&lt;T&gt;</code>: As of 1.72.0.</li>
<li><code>AtomicBool</code>, <code>AtomicU8</code>, ...: Uses special atomic instructions.</li>
</ul>
<p>The generic types are typically <code>Send + Sync</code> when the type parameters are
<code>Send + Sync</code>.</p>
<h2 id="concurrency-send-sync-examples-send--sync-1"><a class="header" href="#concurrency-send-sync-examples-send--sync-1"><code>Send + !Sync</code></a></h2>
<p>These types can be moved to other threads, but they're not thread-safe.
Typically because of interior mutability:</p>
<ul>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2 id="concurrency-send-sync-examples-send--sync-2"><a class="header" href="#concurrency-send-sync-examples-send--sync-2"><code>!Send + Sync</code></a></h2>
<p>These types are thread-safe, but they cannot be moved to another thread:</p>
<ul>
<li><code>MutexGuard&lt;T: Sync&gt;</code>: Uses OS level primitives which must be deallocated on
the thread which created them.</li>
</ul>
<h2 id="concurrency-send-sync-examples-send--sync-3"><a class="header" href="#concurrency-send-sync-examples-send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>These types are not thread-safe and cannot be moved to other threads:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>: each <code>Rc&lt;T&gt;</code> has a reference to an <code>RcBox&lt;T&gt;</code>, which contains a
non-atomic reference count.</li>
<li><code>*const T</code>, <code>*mut T</code>: Rust assumes raw pointers may have special concurrency
considerations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-shared-state"></div><h1 id="concurrency-shared-state-shared-state"><a class="header" href="#concurrency-shared-state-shared-state">Shared State</a></h1>
<p>This segment should take about 30 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Arc</td><td>5 minutes</td></tr>
<tr><td>Mutex</td><td>15 minutes</td></tr>
<tr><td>Example</td><td>10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-shared-state-arc"></div><h1 id="concurrency-shared-state-arc-arc"><a class="header" href="#concurrency-shared-state-arc-arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> allows shared read-only access via <code>Arc::clone</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::Arc;
use std::thread;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 0..5 {
        let v = Arc::clone(&amp;v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!("{thread_id:?}: {v:?}");
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!("v: {v:?}");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li><code>Arc</code> stands for "Atomic Reference Counted", a thread safe version of <code>Rc</code>
that uses atomic operations.</li>
<li><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and
<code>Sync</code> if and only if <code>T</code> implements them both.</li>
<li><code>Arc::clone()</code> has the cost of atomic operations that get executed, but after
that the use of the <code>T</code> is free.</li>
<li>Beware of reference cycles, <code>Arc</code> does not use a garbage collector to detect
them.
<ul>
<li><code>std::sync::Weak</code> can help.</li>
</ul>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-shared-state-mutex"></div><h1 id="concurrency-shared-state-mutex-mutex"><a class="header" href="#concurrency-shared-state-mutex-mutex"><code>Mutex</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> ensures mutual exclusion <em>and</em> allows mutable access to <code>T</code>
behind a read-only interface (another form of
<a href="#borrowing-interior-mutability">interior mutability</a>):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!("v: {:?}", v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!("v: {:?}", v.lock().unwrap());
}</code></pre></pre>
<p>Notice how we have a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> blanket
implementation.</p>
<details>
This slide should take about 14 minutes. 
<ul>
<li><code>Mutex</code> in Rust looks like a collection with just one element --- the
protected data.
<ul>
<li>It is not possible to forget to acquire the mutex before accessing the
protected data.</li>
</ul>
</li>
<li>You can get an <code>&amp;mut T</code> from an <code>&amp;Mutex&lt;T&gt;</code> by taking the lock. The
<code>MutexGuard</code> ensures that the <code>&amp;mut T</code> doesn't outlive the lock being held.</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> iff (if and only if) <code>T</code>
implements <code>Send</code>.</li>
<li>A read-write lock counterpart: <code>RwLock</code>.</li>
<li>Why does <code>lock()</code> return a <code>Result</code>?
<ul>
<li>If the thread that held the <code>Mutex</code> panicked, the <code>Mutex</code> becomes "poisoned"
to signal that the data it protected might be in an inconsistent state.
Calling <code>lock()</code> on a poisoned mutex fails with a <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>. You can
call <code>into_inner()</code> on the error to recover the data regardless.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-shared-state-example"></div><h1 id="concurrency-shared-state-example-example"><a class="header" href="#concurrency-shared-state-example-example">Example</a></h1>
<p>Let us see <code>Arc</code> and <code>Mutex</code> in action:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!("v: {v:?}");
}</code></pre></pre>
<details>
This slide should take about 8 minutes. 
<p>Possible solution:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = Arc::clone(&amp;v);
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    println!("v: {v:?}");
}</code></pre></pre>
<p>Notable parts:</p>
<ul>
<li><code>v</code> is wrapped in both <code>Arc</code> and <code>Mutex</code>, because their concerns are
orthogonal.
<ul>
<li>Wrapping a <code>Mutex</code> in an <code>Arc</code> is a common pattern to share mutable state
between threads.</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> needs to be cloned as <code>v2</code> before it can be moved into another
thread. Note <code>move</code> was added to the lambda signature.</li>
<li>Blocks are introduced to narrow the scope of the <code>LockGuard</code> as much as
possible.</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-sync-exercises"></div><h1 id="concurrency-sync-exercises-exercises"><a class="header" href="#concurrency-sync-exercises-exercises">Exercises</a></h1>
<p>This segment should take about 1 hour and 10 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Dining Philosophers</td><td>20 minutes</td></tr>
<tr><td>Multi-threaded Link Checker</td><td>20 minutes</td></tr>
<tr><td>Solutions</td><td>30 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-sync-exercises-dining-philosophers"></div><h1 id="concurrency-sync-exercises-dining-philosophers-dining-philosophers"><a class="header" href="#concurrency-sync-exercises-dining-philosophers-dining-philosophers">Dining Philosophers</a></h1>
<p>The dining philosophers problem is a classic problem in concurrency:</p>
<blockquote>
<p>Five philosophers dine together at the same table. Each philosopher has their
own place at the table. There is a fork between each plate. The dish served is
a kind of spaghetti which has to be eaten with two forks. Each philosopher can
only alternately think and eat. Moreover, a philosopher can only eat their
spaghetti when they have both a left and right fork. Thus two forks will only
be available when their two nearest neighbors are thinking, not eating. After
an individual philosopher finishes eating, they will put down both forks.</p>
</blockquote>
<p>You will need a local <a href="#cargo-running-locally">Cargo installation</a> for
this exercise. Copy the code below to a file called <code>src/main.rs</code>, fill out the
blanks, and test that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!("Eureka! {} has a new idea!", &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!("{} is eating...", &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;["Socrates", "Hypatia", "Plato", "Aristotle", "Pythagoras"];

fn main() {
    // Create forks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}</code></pre></pre>
<p>You can use the following <code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = "dining-philosophers"
version = "0.1.0"
edition = "2021"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-sync-exercises-link-checker"></div><h1 id="concurrency-sync-exercises-link-checker-multi-threaded-link-checker"><a class="header" href="#concurrency-sync-exercises-link-checker-multi-threaded-link-checker">Multi-threaded Link Checker</a></h1>
<p>Let us use our new knowledge to create a multi-threaded link checker. It should
start at a webpage and check that links on the page are valid. It should
recursively check other pages on the same domain and keep doing this until all
pages have been validated.</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. You will also
need a way to find links, we can use <a href="https://docs.rs/scraper/"><code>scraper</code></a>. Finally, we'll need some
way of handling errors, we will use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a>.</p>
<p>Create a new Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
cargo add scraper
cargo add thiserror
</code></pre>
<blockquote>
<p>If <code>cargo add</code> fails with <code>error: no such subcommand</code>, then please edit the
<code>Cargo.toml</code> file by hand. Add the dependencies listed below.</p>
</blockquote>
<p>The <code>cargo add</code> calls will update the <code>Cargo.toml</code> file to look like this:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = "link-checker"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
reqwest = { version = "0.11.12", features = ["blocking", "rustls-tls"] }
scraper = "0.13.0"
thiserror = "1.0.37"
</code></pre>
<p>You can now download the start page. Try with a small site such as
<code>https://www.google.org/</code>.</p>
<p>Your <code>src/main.rs</code> file should look something like this:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use reqwest::blocking::Client;
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error("request error: {0}")]
    ReqwestError(#[from] reqwest::Error),
    #[error("bad http response: {0}")]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!("Checking {:#}", command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse("a").unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr("href"));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!("On {base_url:#}: ignored unparsable {href:?}: {err}");
            }
        }
    }
    Ok(link_urls)
}

fn main() {
    let client = Client::new();
    let start_url = Url::parse("https://www.google.org").unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&amp;client, &amp;crawl_command) {
        Ok(links) =&gt; println!("Links: {links:#?}"),
        Err(err) =&gt; println!("Could not extract links: {err:#}"),
    }
}</code></pre></pre>
<p>Run the code in <code>src/main.rs</code> with</p>
<pre><code class="language-shell">cargo run
</code></pre>
<h2 id="concurrency-sync-exercises-link-checker-tasks"><a class="header" href="#concurrency-sync-exercises-link-checker-tasks">Tasks</a></h2>
<ul>
<li>Use threads to check the links in parallel: send the URLs to be checked to a
channel and let a few threads check the URLs in parallel.</li>
<li>Extend this to recursively extract links from all pages on the
<code>www.google.org</code> domain. Put an upper limit of 100 pages or so so that you
don't end up being blocked by the site.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-sync-exercises-solutions"></div><h1 id="concurrency-sync-exercises-solutions-solutions"><a class="header" href="#concurrency-sync-exercises-solutions-solutions">Solutions</a></h1>
<h2 id="concurrency-sync-exercises-solutions-dining-philosophers"><a class="header" href="#concurrency-sync-exercises-solutions-dining-philosophers">Dining Philosophers</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::SyncSender&lt;String&gt;,
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!("Eureka! {} has a new idea!", &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        println!("{} is trying to eat", &amp;self.name);
        let _left = self.left_fork.lock().unwrap();
        let _right = self.right_fork.lock().unwrap();

        println!("{} is eating...", &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;["Socrates", "Hypatia", "Plato", "Aristotle", "Pythagoras"];

fn main() {
    let (tx, rx) = mpsc::sync_channel(10);

    let forks = (0..PHILOSOPHERS.len())
        .map(|_| Arc::new(Mutex::new(Fork)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for i in 0..forks.len() {
        let tx = tx.clone();
        let mut left_fork = Arc::clone(&amp;forks[i]);
        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the forks without deinitializing
        // either of them.
        if i == forks.len() - 1 {
            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_fork,
            right_fork,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!("{thought}");
    }
}</code></pre></pre>
<h2 id="concurrency-sync-exercises-solutions-link-checker"><a class="header" href="#concurrency-sync-exercises-solutions-link-checker">Link Checker</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::{mpsc, Arc, Mutex};
use std::thread;

use reqwest::blocking::Client;
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error("request error: {0}")]
    ReqwestError(#[from] reqwest::Error),
    #[error("bad http response: {0}")]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!("Checking {:#}", command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse("a").unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr("href"));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!("On {base_url:#}: ignored unparsable {href:?}: {err}");
            }
        }
    }
    Ok(link_urls)
}

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet&lt;String&gt;,
}

impl CrawlState {
    fn new(start_url: &amp;Url) -&gt; CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState { domain: start_url.domain().unwrap().to_string(), visited_pages }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning false if it had already
    /// been visited.
    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result&lt;Vec&lt;Url&gt;, (Url, Error)&gt;;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver&lt;CrawlCommand&gt;,
    result_sender: mpsc::Sender&lt;CrawlResult&gt;,
    thread_count: u32,
) {
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = command_receiver.clone();
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&amp;client, &amp;crawl_command) {
                    Ok(link_urls) =&gt; Ok(link_urls),
                    Err(error) =&gt; Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender&lt;CrawlCommand&gt;,
    result_receiver: mpsc::Receiver&lt;CrawlResult&gt;,
) -&gt; Vec&lt;Url&gt; {
    let mut crawl_state = CrawlState::new(&amp;start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls &gt; 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) =&gt; {
                for url in link_urls {
                    if crawl_state.mark_visited(&amp;url) {
                        let extract_links = crawl_state.should_extract_links(&amp;url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) =&gt; {
                bad_urls.push(url);
                println!("Got crawling error: {:#}", error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -&gt; Vec&lt;Url&gt; {
    let (result_sender, result_receiver) = mpsc::channel::&lt;CrawlResult&gt;();
    let (command_sender, command_receiver) = mpsc::channel::&lt;CrawlCommand&gt;();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse("https://www.google.org").unwrap();
    let bad_urls = check_links(start_url);
    println!("Bad URLs: {:#?}", bad_urls);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-welcome-async"></div><h1 id="concurrency-welcome-async-welcome"><a class="header" href="#concurrency-welcome-async-welcome">Welcome</a></h1>
<p>"Async" is a concurrency model where multiple tasks are executed concurrently by
executing each task until it would block, then switching to another task that is
ready to make progress. The model allows running a larger number of tasks on a
limited number of threads. This is because the per-task overhead is typically
very low and operating systems provide primitives for efficiently identifying
I/O that is able to proceed.</p>
<p>Rust's asynchronous operation is based on "futures", which represent work that
may be completed in the future. Futures are "polled" until they signal that they
are complete.</p>
<p>Futures are polled by an async runtime, and several different runtimes are
available.</p>
<h2 id="concurrency-welcome-async-comparisons"><a class="header" href="#concurrency-welcome-async-comparisons">Comparisons</a></h2>
<ul>
<li>
<p>Python has a similar model in its <code>asyncio</code>. However, its <code>Future</code> type is
callback-based, and not polled. Async Python programs require a "loop",
similar to a runtime in Rust.</p>
</li>
<li>
<p>JavaScript's <code>Promise</code> is similar, but again callback-based. The language
runtime implements the event loop, so many of the details of Promise
resolution are hidden.</p>
</li>
</ul>
<h2 id="concurrency-welcome-async-schedule"><a class="header" href="#concurrency-welcome-async-schedule">Schedule</a></h2>
<p>Including 10 minute breaks, this session should take about 3 hours and 20 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Duration</th></tr></thead><tbody>
<tr><td>Async Basics</td><td>30 minutes</td></tr>
<tr><td>Channels and Control Flow</td><td>20 minutes</td></tr>
<tr><td>Pitfalls</td><td>55 minutes</td></tr>
<tr><td>Exercises</td><td>1 hour and 10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async"></div><h1 id="concurrency-async-async-basics"><a class="header" href="#concurrency-async-async-basics">Async Basics</a></h1>
<p>This segment should take about 30 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>async/await</td><td>10 minutes</td></tr>
<tr><td>Futures</td><td>4 minutes</td></tr>
<tr><td>Runtimes</td><td>10 minutes</td></tr>
<tr><td>Tasks</td><td>10 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-async-await"></div><h1 id="concurrency-async-async-await-asyncawait"><a class="header" href="#concurrency-async-async-await-asyncawait"><code>async</code>/<code>await</code></a></h1>
<p>At a high level, async Rust code looks very much like "normal" sequential code:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 0..count {
        println!("Count is: {i}!");
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}</code></pre></pre>
<details>
This slide should take about 6 minutes. 
<p>Key points:</p>
<ul>
<li>
<p>Note that this is a simplified example to show the syntax. There is no long
running operation or any real concurrency in it!</p>
</li>
<li>
<p>What is the return type of an async call?</p>
<ul>
<li>Use <code>let future: () = async_main(10);</code> in <code>main</code> to see the type.</li>
</ul>
</li>
<li>
<p>The "async" keyword is syntactic sugar. The compiler replaces the return type
with a future.</p>
</li>
<li>
<p>You cannot make <code>main</code> async, without additional instructions to the compiler
on how to use the returned future.</p>
</li>
<li>
<p>You need an executor to run async code. <code>block_on</code> blocks the current thread
until the provided future has run to completion.</p>
</li>
<li>
<p><code>.await</code> asynchronously waits for the completion of another operation. Unlike
<code>block_on</code>, <code>.await</code> doesn't block the current thread.</p>
</li>
<li>
<p><code>.await</code> can only be used inside an <code>async</code> function (or block; these are
introduced later).</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-futures"></div><h1 id="concurrency-async-futures-futures"><a class="header" href="#concurrency-async-futures-futures">Futures</a></h1>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> is a trait,
implemented by objects that represent an operation that may not be complete yet.
A future can be polled, and <code>poll</code> returns a
<a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>An async function returns an <code>impl Future</code>. It's also possible (but uncommon) to
implement <code>Future</code> for your own types. For example, the <code>JoinHandle</code> returned
from <code>tokio::spawn</code> implements <code>Future</code> to allow joining to it.</p>
<p>The <code>.await</code> keyword, applied to a Future, causes the current async function to
pause until that Future is ready, and then evaluates to its output.</p>
<details>
This slide should take about 4 minutes. 
<ul>
<li>
<p>The <code>Future</code> and <code>Poll</code> types are implemented exactly as shown; click the
links to show the implementations in the docs.</p>
</li>
<li>
<p>We will not get to <code>Pin</code> and <code>Context</code>, as we will focus on writing async
code, rather than building new async primitives. Briefly:</p>
<ul>
<li>
<p><code>Context</code> allows a Future to schedule itself to be polled again when an
event occurs.</p>
</li>
<li>
<p><code>Pin</code> ensures that the Future isn't moved in memory, so that pointers into
that future remain valid. This is required to allow references to remain
valid after an <code>.await</code>.</p>
</li>
</ul>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-runtimes"></div><h1 id="concurrency-async-runtimes-runtimes"><a class="header" href="#concurrency-async-runtimes-runtimes">Runtimes</a></h1>
<p>A <em>runtime</em> provides support for performing operations asynchronously (a
<em>reactor</em>) and is responsible for executing futures (an <em>executor</em>). Rust does
not have a "built-in" runtime, but several options are available:</p>
<ul>
<li><a href="https://tokio.rs/">Tokio</a>: performant, with a well-developed ecosystem of
functionality like <a href="https://hyper.rs/">Hyper</a> for HTTP or
<a href="https://github.com/hyperium/tonic">Tonic</a> for gRPC.</li>
<li><a href="https://async.rs/">async-std</a>: aims to be a "std for async", and includes a
basic runtime in <code>async::task</code>.</li>
<li><a href="https://docs.rs/smol/latest/smol/">smol</a>: simple and lightweight</li>
</ul>
<p>Several larger applications have their own runtimes. For example,
<a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs">Fuchsia</a>
already has one.</p>
<details>
This slide and its sub-slides should take about 10 minutes. 
<ul>
<li>
<p>Note that of the listed runtimes, only Tokio is supported in the Rust
playground. The playground also does not permit any I/O, so most interesting
async things can't run in the playground.</p>
</li>
<li>
<p>Futures are "inert" in that they do not do anything (not even start an I/O
operation) unless there is an executor polling them. This differs from JS
Promises, for example, which will run to completion even if they are never
used.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-runtimes-tokio"></div><h1 id="concurrency-async-runtimes-tokio-tokio"><a class="header" href="#concurrency-async-runtimes-tokio-tokio">Tokio</a></h1>
<p>Tokio provides:</p>
<ul>
<li>A multi-threaded runtime for executing asynchronous code.</li>
<li>An asynchronous version of the standard library.</li>
<li>A large ecosystem of libraries.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::time;

async fn count_to(count: i32) {
    for i in 0..count {
        println!("Count in task: {i}!");
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 0..5 {
        println!("Main task: {i}");
        time::sleep(time::Duration::from_millis(5)).await;
    }
}</code></pre></pre>
<details>
<ul>
<li>
<p>With the <code>tokio::main</code> macro we can now make <code>main</code> async.</p>
</li>
<li>
<p>The <code>spawn</code> function creates a new, concurrent "task".</p>
</li>
<li>
<p>Note: <code>spawn</code> takes a <code>Future</code>, you don't call <code>.await</code> on <code>count_to</code>.</p>
</li>
</ul>
<p><strong>Further exploration:</strong></p>
<ul>
<li>
<p>Why does <code>count_to</code> not (usually) get to 10? This is an example of async
cancellation. <code>tokio::spawn</code> returns a handle which can be awaited to wait
until it finishes.</p>
</li>
<li>
<p>Try <code>count_to(10).await</code> instead of spawning.</p>
</li>
<li>
<p>Try awaiting the task returned from <code>tokio::spawn</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-tasks"></div><h1 id="concurrency-async-tasks-tasks"><a class="header" href="#concurrency-async-tasks-tasks">Tasks</a></h1>
<p>Rust has a task system, which is a form of lightweight threading.</p>
<p>A task has a single top-level future which the executor polls to make progress.
That future may have one or more nested futures that its <code>poll</code> method polls,
corresponding loosely to a call stack. Concurrency within a task is possible by
polling multiple child futures, such as racing a timer and an I/O operation.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let listener = TcpListener::bind("127.0.0.1:0").await?;
    println!("listening on port {}", listener.local_addr()?.port());

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!("connection from {addr:?}");

        tokio::spawn(async move {
            socket.write_all(b"Who are you?\n").await.expect("socket error");

            let mut buf = vec![0; 1024];
            let name_size = socket.read(&amp;mut buf).await.expect("socket error");
            let name = std::str::from_utf8(&amp;buf[..name_size]).unwrap().trim();
            let reply = format!("Thanks for dialing in, {name}!\n");
            socket.write_all(reply.as_bytes()).await.expect("socket error");
        });
    }
}</code></pre></pre>
<details>
This slide should take about 6 minutes. 
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<p>Try connecting to it with a TCP connection tool like
<a href="https://www.unix.com/man-page/linux/1/nc/">nc</a> or
<a href="https://www.unix.com/man-page/linux/1/telnet/">telnet</a>.</p>
<ul>
<li>
<p>Ask students to visualize what the state of the example server would be with a
few connected clients. What tasks exist? What are their Futures?</p>
</li>
<li>
<p>This is the first time we've seen an <code>async</code> block. This is similar to a
closure, but does not take any arguments. Its return value is a Future,
similar to an <code>async fn</code>.</p>
</li>
<li>
<p>Refactor the async block into a function, and improve the error handling using
<code>?</code>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-control-flow"></div><h1 id="concurrency-async-control-flow-channels-and-control-flow"><a class="header" href="#concurrency-async-control-flow-channels-and-control-flow">Channels and Control Flow</a></h1>
<p>This segment should take about 20 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Async Channels</td><td>10 minutes</td></tr>
<tr><td>Join</td><td>4 minutes</td></tr>
<tr><td>Select</td><td>5 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-control-flow-channels"></div><h1 id="concurrency-async-control-flow-channels-async-channels"><a class="header" href="#concurrency-async-control-flow-channels-async-channels">Async Channels</a></h1>
<p>Several crates have support for asynchronous channels. For instance <code>tokio</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::sync::mpsc::{self, Receiver};

async fn ping_handler(mut input: Receiver&lt;()&gt;) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!("Received {count} pings so far.");
    }

    println!("ping_handler complete");
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect("Failed to send ping.");
        println!("Sent {} pings so far.", i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect("Something went wrong in ping handler task.");
}</code></pre></pre>
<details>
This slide should take about 8 minutes. 
<ul>
<li>
<p>Change the channel size to <code>3</code> and see how it affects the execution.</p>
</li>
<li>
<p>Overall, the interface is similar to the <code>sync</code> channels as seen in the
<a href="#concurrency-channels">morning class</a>.</p>
</li>
<li>
<p>Try removing the <code>std::mem::drop</code> call. What happens? Why?</p>
</li>
<li>
<p>The <a href="https://docs.rs/flume/latest/flume/">Flume</a> crate has channels that
implement both <code>sync</code> and <code>async</code> <code>send</code> and <code>recv</code>. This can be convenient
for complex applications with both IO and heavy CPU processing tasks.</p>
</li>
<li>
<p>What makes working with <code>async</code> channels preferable is the ability to combine
them with other <code>future</code>s to combine them and create complex control flow.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-control-flow-join"></div><h1 id="concurrency-async-control-flow-join-join"><a class="header" href="#concurrency-async-control-flow-join-join">Join</a></h1>
<p>A join operation waits until all of a set of futures are ready, and returns a
collection of their results. This is similar to <code>Promise.all</code> in JavaScript or
<code>asyncio.gather</code> in Python.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &amp;str) -&gt; Result&lt;usize&gt; {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&amp;str; 4] = [
        "https://google.com",
        "https://httpbin.org/ip",
        "https://play.rust-lang.org/",
        "BAD_URL",
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap&lt;&amp;str, Result&lt;usize&gt;&gt; =
        urls.into_iter().zip(results.into_iter()).collect();
    println!("{:?}", page_sizes_dict);
}</code></pre></pre>
<details>
This slide should take about 4 minutes. 
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>For multiple futures of disjoint types, you can use <code>std::future::join!</code> but
you must know how many futures you will have at compile time. This is
currently in the <code>futures</code> crate, soon to be stabilised in <code>std::future</code>.</p>
</li>
<li>
<p>The risk of <code>join</code> is that one of the futures may never resolve, this would
cause your program to stall.</p>
</li>
<li>
<p>You can also combine <code>join_all</code> with <code>join!</code> for instance to join all requests
to an http service as well as a database query. Try adding a
<code>tokio::time::sleep</code> to the future, using <code>futures::join!</code>. This is not a
timeout (that requires <code>select!</code>, explained in the next chapter), but
demonstrates <code>join!</code>.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-control-flow-select"></div><h1 id="concurrency-async-control-flow-select-select"><a class="header" href="#concurrency-async-control-flow-select-select">Select</a></h1>
<p>A select operation waits until any of a set of futures is ready, and responds to
that future's result. In JavaScript, this is similar to <code>Promise.race</code>. In
Python, it compares to
<code>asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)</code>.</p>
<p>Similar to a match statement, the body of <code>select!</code> has a number of arms, each
of the form <code>pattern = future =&gt; statement</code>. When a <code>future</code> is ready, its
return value is destructured by the <code>pattern</code>. The <code>statement</code> is then run with
the resulting variables. The <code>statement</code> result becomes the result of the
<code>select!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let listener = tokio::spawn(async move {
        tokio::select! {
            Some(msg) = rx.recv() =&gt; println!("got: {msg}"),
            _ = sleep(Duration::from_millis(50)) =&gt; println!("timeout"),
        };
    });
    sleep(Duration::from_millis(10)).await;
    tx.send(String::from("Hello!")).await.expect("Failed to send greeting");

    listener.await.expect("Listener failed");
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p>The <code>listener</code> async block here is a common form: wait for some async event,
or for a timeout. Change the <code>sleep</code> to sleep longer to see it fail. Why does
the <code>send</code> also fail in this situation?</p>
</li>
<li>
<p><code>select!</code> is also often used in a loop in "actor" architectures, where a task
reacts to events in a loop. That has some pitfalls, which will be discussed in
the next segment.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-pitfalls"></div><h1 id="concurrency-async-pitfalls-pitfalls"><a class="header" href="#concurrency-async-pitfalls-pitfalls">Pitfalls</a></h1>
<p>Async / await provides convenient and efficient abstraction for concurrent
asynchronous programming. However, the async/await model in Rust also comes with
its share of pitfalls and footguns. We illustrate some of them in this chapter.</p>
<p>This segment should take about 55 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Blocking the Executor</td><td>10 minutes</td></tr>
<tr><td>Pin</td><td>20 minutes</td></tr>
<tr><td>Async Traits</td><td>5 minutes</td></tr>
<tr><td>Cancellation</td><td>20 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-pitfalls-blocking-executor"></div><h1 id="concurrency-async-pitfalls-blocking-executor-blocking-the-executor"><a class="header" href="#concurrency-async-pitfalls-blocking-executor-blocking-the-executor">Blocking the executor</a></h1>
<p>Most async runtimes only allow IO tasks to run concurrently. This means that CPU
blocking tasks will block the executor and prevent other tasks from being
executed. An easy workaround is to use async equivalent methods where possible.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &amp;Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        "future {id} slept for {duration_ms}ms, finished after {}ms",
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = "current_thread")]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&amp;start, t, t * 10));
    join_all(sleep_futures).await;
}</code></pre></pre>
<details>
This slide should take about 10 minutes. 
<ul>
<li>
<p>Run the code and see that the sleeps happen consecutively rather than
concurrently.</p>
</li>
<li>
<p>The <code>"current_thread"</code> flavor puts all tasks on a single thread. This makes
the effect more obvious, but the bug is still present in the multi-threaded
flavor.</p>
</li>
<li>
<p>Switch the <code>std::thread::sleep</code> to <code>tokio::time::sleep</code> and await its result.</p>
</li>
<li>
<p>Another fix would be to <code>tokio::task::spawn_blocking</code> which spawns an actual
thread and transforms its handle into a future without blocking the executor.</p>
</li>
<li>
<p>You should not think of tasks as OS threads. They do not map 1 to 1 and most
executors will allow many tasks to run on a single OS thread. This is
particularly problematic when interacting with other libraries via FFI, where
that library might depend on thread-local storage or map to specific OS
threads (e.g., CUDA). Prefer <code>tokio::task::spawn_blocking</code> in such situations.</p>
</li>
<li>
<p>Use sync mutexes with care. Holding a mutex over an <code>.await</code> may cause another
task to block, and that task may be running on the same thread.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-pitfalls-pin"></div><h1 id="concurrency-async-pitfalls-pin-pin"><a class="header" href="#concurrency-async-pitfalls-pin-pin"><code>Pin</code></a></h1>
<p>Async blocks and functions return types implementing the <code>Future</code> trait. The
type returned is the result of a compiler transformation which turns local
variables into data stored inside the future.</p>
<p>Some of those variables can hold pointers to other local variables. Because of
that, the future should never be moved to a different memory location, as it
would invalidate those pointers.</p>
<p>To prevent moving the future type in memory, it can only be polled through a
pinned pointer. <code>Pin</code> is a wrapper around a reference that disallows all
operations that would move the instance it points to into a different memory
location.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{sleep, Duration};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender&lt;u32&gt;,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver&lt;Work&gt;) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() =&gt; {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect("failed to send response");
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &amp;mpsc::Sender&lt;Work&gt;, input: u32) -&gt; u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work { input, respond_on: tx })
        .await
        .expect("failed to send on work queue");
    rx.await.expect("failed waiting for response")
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&amp;tx, i).await;
        println!("work result for iteration {i}: {resp}");
    }
}</code></pre></pre>
<details>
This slide should take about 20 minutes. 
<ul>
<li>
<p>You may recognize this as an example of the actor pattern. Actors typically
call <code>select!</code> in a loop.</p>
</li>
<li>
<p>This serves as a summation of a few of the previous lessons, so take your time
with it.</p>
<ul>
<li>
<p>Naively add a <code>_ = sleep(Duration::from_millis(100)) =&gt; { println!(..) }</code> to
the <code>select!</code>. This will never execute. Why?</p>
</li>
<li>
<p>Instead, add a <code>timeout_fut</code> containing that future outside of the <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let timeout_fut = sleep(Duration::from_millis(100));
loop {
    select! {
        ..,
        _ = timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This still doesn't work. Follow the compiler errors, adding <code>&amp;mut</code> to the
<code>timeout_fut</code> in the <code>select!</code> to work around the move, then using
<code>Box::pin</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        ..,
        _ = &amp;mut timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This compiles, but once the timeout expires it is <code>Poll::Ready</code> on every
iteration (a fused future would help with this). Update to reset
<code>timeout_fut</code> every time it expires:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        _ = &amp;mut timeout_fut =&gt; {
            println!(..);
            timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
        },
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Box allocates on the heap. In some cases, <code>std::pin::pin!</code> (only recently
stabilized, with older code often using <code>tokio::pin!</code>) is also an option, but
that is difficult to use for a future that is reassigned.</p>
</li>
<li>
<p>Another alternative is to not use <code>pin</code> at all but spawn another task that
will send to a <code>oneshot</code> channel every 100ms.</p>
</li>
<li>
<p>Data that contains pointers to itself is called self-referential. Normally,
the Rust borrow checker would prevent self-referential data from being moved,
as the references cannot outlive the data they point to. However, the code
transformation for async blocks and functions is not verified by the borrow
checker.</p>
</li>
<li>
<p><code>Pin</code> is a wrapper around a reference. An object cannot be moved from its
place using a pinned pointer. However, it can still be moved through an
unpinned pointer.</p>
</li>
<li>
<p>The <code>poll</code> method of the <code>Future</code> trait uses <code>Pin&lt;&amp;mut Self&gt;</code> instead of
<code>&amp;mut Self</code> to refer to the instance. That's why it can only be called on a
pinned pointer.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-pitfalls-async-traits"></div><h1 id="concurrency-async-pitfalls-async-traits-async-traits"><a class="header" href="#concurrency-async-pitfalls-async-traits-async-traits">Async Traits</a></h1>
<p>Async methods in traits are were stabilized only recently, in the 1.75 release.
This required support for using return-position <code>impl Trait</code> (RPIT) in traits,
as the desugaring for <code>async fn</code> includes <code>-&gt; impl Future&lt;Output = ...&gt;</code>.</p>
<p>However, even with the native support today there are some pitfalls around
<code>async fn</code> and RPIT in traits:</p>
<ul>
<li>
<p>Return-position impl Trait captures all in-scope lifetimes (so some patterns
of borrowing cannot be expressed)</p>
</li>
<li>
<p>Traits whose methods use return-position <code>impl trait</code> or <code>async</code> are not <code>dyn</code>
compatible.</p>
</li>
</ul>
<p>If we do need <code>dyn</code> support, the crate
<a href="https://docs.rs/async-trait/latest/async_trait/">async_trait</a> provides a
workaround through a macro, with some caveats:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[async_trait]
trait Sleeper {
    async fn sleep(&amp;self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&amp;self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(
    sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt;,
    n_times: usize,
) {
    for _ in 0..n_times {
        println!("running all sleepers..");
        for sleeper in &amp;sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!("slept for {}ms", start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt; = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}</code></pre></pre>
<details>
This slide should take about 5 minutes. 
<ul>
<li>
<p><code>async_trait</code> is easy to use, but note that it's using heap allocations to
achieve this. This heap allocation has performance overhead.</p>
</li>
<li>
<p>The challenges in language support for <code>async trait</code> are deep Rust and
probably not worth describing in-depth. Niko Matsakis did a good job of
explaining them in
<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">this post</a>
if you are interested in digging deeper.</p>
</li>
<li>
<p>Try creating a new sleeper struct that will sleep for a random amount of time
and adding it to the Vec.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-pitfalls-cancellation"></div><h1 id="concurrency-async-pitfalls-cancellation-cancellation"><a class="header" href="#concurrency-async-pitfalls-cancellation-cancellation">Cancellation</a></h1>
<p>Dropping a future implies it can never be polled again. This is called
<em>cancellation</em> and it can occur at any <code>await</code> point. Care is needed to ensure
the system works correctly even when futures are cancelled. For example, it
shouldn't deadlock or lose data.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::io::{self, ErrorKind};
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream }
    }

    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&amp;mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None);
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(ErrorKind::InvalidData, "not UTF-8"))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; std::io::Result&lt;()&gt; {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy("hi\nthere\n".to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() =&gt; println!("tick!"),
            line = lines.next() =&gt; if let Some(l) = line? {
                print!("{}", l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}</code></pre></pre>
<details>
This slide should take about 18 minutes. 
<ul>
<li>
<p>The compiler doesn't help with cancellation-safety. You need to read API
documentation and consider what state your <code>async fn</code> holds.</p>
</li>
<li>
<p>Unlike <code>panic</code> and <code>?</code>, cancellation is part of normal control flow (vs
error-handling).</p>
</li>
<li>
<p>The example loses parts of the string.</p>
<ul>
<li>
<p>Whenever the <code>tick()</code> branch finishes first, <code>next()</code> and its <code>buf</code> are
dropped.</p>
</li>
<li>
<p><code>LinesReader</code> can be made cancellation-safe by making <code>buf</code> part of the
struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LinesReader {
    stream: DuplexStream,
    bytes: Vec&lt;u8&gt;,
    buf: [u8; 1],
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream, bytes: Vec::new(), buf: [0] }
    }
    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        // prefix buf and bytes with self.
        // ...
        let raw = std::mem::take(&amp;mut self.bytes);
        let s = String::from_utf8(raw)
            .map_err(|_| io::Error::new(ErrorKind::InvalidData, "not UTF-8"))?;
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick"><code>Interval::tick</code></a>
is cancellation-safe because it keeps track of whether a tick has been
'delivered'.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a>
is cancellation-safe because it either returns or doesn't read data.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line"><code>AsyncBufReadExt::read_line</code></a>
is similar to the example and <em>isn't</em> cancellation-safe. See its documentation
for details and alternatives.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-exercises"></div><h1 id="concurrency-async-exercises-exercises"><a class="header" href="#concurrency-async-exercises-exercises">Exercises</a></h1>
<p>This segment should take about 1 hour and 10 minutes. It contains:</p>
<div class="table-wrapper"><table><thead><tr><th>Slide</th><th>Duration</th></tr></thead><tbody>
<tr><td>Dining Philosophers</td><td>20 minutes</td></tr>
<tr><td>Broadcast Chat Application</td><td>30 minutes</td></tr>
<tr><td>Solutions</td><td>20 minutes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-exercises-dining-philosophers"></div><h1 id="concurrency-async-exercises-dining-philosophers-dining-philosophers-----async"><a class="header" href="#concurrency-async-exercises-dining-philosophers-dining-philosophers-----async">Dining Philosophers --- Async</a></h1>
<p>See <a href="#concurrency-sync-exercises-dining-philosophers">dining philosophers</a> for a
description of the problem.</p>
<p>As before, you will need a local
<a href="#cargo-running-locally">Cargo installation</a> for this exercise. Copy the
code below to a file called <code>src/main.rs</code>, fill out the blanks, and test that
<code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::Arc;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;
use tokio::time;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!("Eureka! {} has a new idea!", &amp;self.name))
            .await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Keep trying until we have both forks
        println!("{} is eating...", &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;["Socrates", "Hypatia", "Plato", "Aristotle", "Pythagoras"];

#[tokio::main]
async fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}</code></pre></pre>
<p>Since this time you are using Async Rust, you'll need a <code>tokio</code> dependency. You
can use the following <code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = "dining-philosophers-async-dine"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.26.0", features = ["sync", "time", "macros", "rt-multi-thread"] }
</code></pre>
<p>Also note that this time you have to use the <code>Mutex</code> and the <code>mpsc</code> module from
the <code>tokio</code> crate.</p>
<details>
This slide should take about 20 minutes. 
<ul>
<li>Can you make your implementation single-threaded?</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-exercises-chat-app"></div><h1 id="concurrency-async-exercises-chat-app-broadcast-chat-application"><a class="header" href="#concurrency-async-exercises-chat-app-broadcast-chat-application">Broadcast Chat Application</a></h1>
<p>In this exercise, we want to use our new knowledge to implement a broadcast chat
application. We have a chat server that the clients connect to and publish their
messages. The client reads user messages from the standard input, and sends them
to the server. The chat server broadcasts each message that it receives to all
the clients.</p>
<p>For this, we use <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html">a broadcast channel</a> on the server, and
<a href="https://docs.rs/tokio-websockets/"><code>tokio_websockets</code></a> for the communication between the client and the server.</p>
<p>Create a new Cargo project and add the following dependencies:</p>
<p><em>Cargo.toml</em>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = "chat-async"
version = "0.1.0"
edition = "2021"

[dependencies]
futures-util = { version = "0.3.30", features = ["sink"] }
http = "1.1.0"
tokio = { version = "1.39.2", features = ["full"] }
tokio-websockets = { version = "0.9.0", features = ["client", "fastrand", "server", "sha1_smol"] }
</code></pre>
<h2 id="concurrency-async-exercises-chat-app-the-required-apis"><a class="header" href="#concurrency-async-exercises-chat-app-the-required-apis">The required APIs</a></h2>
<p>You are going to need the following functions from <code>tokio</code> and
<a href="https://docs.rs/tokio-websockets/"><code>tokio_websockets</code></a>. Spend a few minutes to familiarize yourself with the
API.</p>
<ul>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next">StreamExt::next()</a> implemented by <code>WebSocketStream</code>: for asynchronously
reading messages from a Websocket Stream.</li>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send">SinkExt::send()</a> implemented by <code>WebSocketStream</code>: for asynchronously
sending messages on a Websocket Stream.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line">Lines::next_line()</a>: for asynchronously reading user messages from the
standard input.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe">Sender::subscribe()</a>: for subscribing to a broadcast channel.</li>
</ul>
<h2 id="concurrency-async-exercises-chat-app-two-binaries"><a class="header" href="#concurrency-async-exercises-chat-app-two-binaries">Two binaries</a></h2>
<p>Normally in a Cargo project, you can have only one binary, and one <code>src/main.rs</code>
file. In this project, we need two binaries. One for the client, and one for the
server. You could potentially make them two separate Cargo projects, but we are
going to put them in a single Cargo project with two binaries. For this to work,
the client and the server code should go under <code>src/bin</code> (see the
<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">documentation</a>).</p>
<p>Copy the following server and client code into <code>src/bin/server.rs</code> and
<code>src/bin/client.rs</code>, respectively. Your task is to complete these files as
described below.</p>
<p><em>src/bin/server.rs</em>:</p>
<!-- File src/bin/server.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebSocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebSocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    // TODO: For a hint, see the description of the task below.

}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind("127.0.0.1:2000").await?;
    println!("listening on port 2000");

    loop {
        let (socket, addr) = listener.accept().await?;
        println!("New connection from {addr:?}");
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<!-- File src/bin/client.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static("ws://127.0.0.1:2000"))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();


    // TODO: For a hint, see the description of the task below.

}</code></pre></pre>
<h2 id="concurrency-async-exercises-chat-app-running-the-binaries"><a class="header" href="#concurrency-async-exercises-chat-app-running-the-binaries">Running the binaries</a></h2>
<p>Run the server with:</p>
<pre><code class="language-shell">cargo run --bin server
</code></pre>
<p>and the client with:</p>
<pre><code class="language-shell">cargo run --bin client
</code></pre>
<h2 id="concurrency-async-exercises-chat-app-tasks"><a class="header" href="#concurrency-async-exercises-chat-app-tasks">Tasks</a></h2>
<ul>
<li>Implement the <code>handle_connection</code> function in <code>src/bin/server.rs</code>.
<ul>
<li>Hint: Use <code>tokio::select!</code> for concurrently performing two tasks in a
continuous loop. One task receives messages from the client and broadcasts
them. The other sends messages received by the server to the client.</li>
</ul>
</li>
<li>Complete the main function in <code>src/bin/client.rs</code>.
<ul>
<li>Hint: As before, use <code>tokio::select!</code> in a continuous loop for concurrently
performing two tasks: (1) reading user messages from standard input and
sending them to the server, and (2) receiving messages from the server, and
displaying them for the user.</li>
</ul>
</li>
<li>Optional: Once you are done, change the code to broadcast messages to all
clients, but the sender of the message.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="concurrency-async-exercises-solutions"></div><h1 id="concurrency-async-exercises-solutions-solutions"><a class="header" href="#concurrency-async-exercises-solutions-solutions">Solutions</a></h1>
<h2 id="concurrency-async-exercises-solutions-dining-philosophers-----async"><a class="header" href="#concurrency-async-exercises-solutions-dining-philosophers-----async">Dining Philosophers --- Async</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::Arc;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;
use tokio::time;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: Sender&lt;String&gt;,
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!("Eureka! {} has a new idea!", &amp;self.name))
            .await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Keep trying until we have both forks
        let (_left_fork, _right_fork) = loop {
            // Pick up forks...
            let left_fork = self.left_fork.try_lock();
            let right_fork = self.right_fork.try_lock();
            let Ok(left_fork) = left_fork else {
                // If we didn't get the left fork, drop the right fork if we
                // have it and let other tasks make progress.
                drop(right_fork);
                time::sleep(time::Duration::from_millis(1)).await;
                continue;
            };
            let Ok(right_fork) = right_fork else {
                // If we didn't get the right fork, drop the left fork and let
                // other tasks make progress.
                drop(left_fork);
                time::sleep(time::Duration::from_millis(1)).await;
                continue;
            };
            break (left_fork, right_fork);
        };

        println!("{} is eating...", &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;

        // The locks are dropped here
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;["Socrates", "Hypatia", "Plato", "Aristotle", "Pythagoras"];

#[tokio::main]
async fn main() {
    // Create forks
    let mut forks = vec![];
    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let left_fork = Arc::clone(&amp;forks[i]);
            let right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS.len()]);
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_fork,
                right_fork,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });
    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!("Here is a thought: {thought}");
    }
}</code></pre></pre>
<h2 id="concurrency-async-exercises-solutions-broadcast-chat-application"><a class="header" href="#concurrency-async-exercises-solutions-broadcast-chat-application">Broadcast Chat Application</a></h2>
<p><em>src/bin/server.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebSocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebSocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    ws_stream
        .send(Message::text("Welcome to chat! Type a message".to_string()))
        .await?;
    let mut bcast_rx = bcast_tx.subscribe();

    // A continuous loop for concurrently performing two tasks: (1) receiving
    // messages from `ws_stream` and broadcasting them, and (2) receiving
    // messages on `bcast_rx` and sending them to the client.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!("From client {addr:?} {text:?}");
                            bcast_tx.send(text.into())?;
                        }
                    }
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            msg = bcast_rx.recv() =&gt; {
                ws_stream.send(Message::text(msg?)).await?;
            }
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind("127.0.0.1:2000").await?;
    println!("listening on port 2000");

    loop {
        let (socket, addr) = listener.accept().await?;
        println!("New connection from {addr:?}");
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static("ws://127.0.0.1:2000"))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();

    // Continuous loop for concurrently sending and receiving messages.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!("From server: {}", text);
                        }
                    },
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            res = stdin.next_line() =&gt; {
                match res {
                    Ok(None) =&gt; return Ok(()),
                    Ok(Some(line)) =&gt; ws_stream.send(Message::text(line.to_string())).await?,
                    Err(err) =&gt; return Err(err.into()),
                }
            }

        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="thanks"></div><h1 id="thanks-thanks"><a class="header" href="#thanks-thanks">Thanks!</a></h1>
<p><em>Thank you for taking Comprehensive Rust ü¶Ä!</em> We hope you enjoyed it and that it
was useful.</p>
<p>We've had a lot of fun putting the course together. The course is not perfect,
so if you spotted any mistakes or have ideas for improvements, please get in
<a href="https://github.com/google/comprehensive-rust/discussions">contact with us on GitHub</a>.
We would love to hear from you.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="glossary"></div><!-- i18n:comment Please keep { #glossary } untranslated. -->
<h1 id="glossary-glossary"><a class="header" href="#glossary-glossary">Glossary</a></h1>
<p>The following is a glossary which aims to give a short definition of many Rust
terms. For translations, this also serves to connect the term back to the
English original.</p>
<style>
h1#glossary ~ ul {
    list-style: none;
    padding-inline-start: 0;
}

h1#glossary ~ ul > li {
    /* Simplify with "text-indent: 2em hanging" when supported:
       https://caniuse.com/mdn-css_properties_text-indent_hanging */
    padding-left: 2em;
    text-indent: -2em;
}

h1#glossary ~ ul > li:first-line {
    font-weight: bold;
}
</style>
<!-- i18n:comment Please add the English term in italic after your -->
<!-- i18n:comment translated term. Also, please keep the hard line -->
<!-- i18n:comment breaks to ensure a nice formatting. -->
<ul>
<li>allocate:<br />
Dynamic memory allocation on <a href="#memory-management-review">the heap</a>.</li>
<li>argument:<br />
Information that is passed into a function or method.</li>
<li>Bare-metal Rust:<br />
Low-level Rust development, often deployed to a system without an operating
system. See <a href="#bare-metal">Bare-metal Rust</a>.</li>
<li>block:<br />
See <a href="#control-flow-basics-blocks-and-scopes">Blocks</a> and <em>scope</em>.</li>
<li>borrow:<br />
See <a href="#borrowing-shared">Borrowing</a>.</li>
<li>borrow checker:<br />
The part of the Rust compiler which checks that all borrows are valid.</li>
<li>brace:<br />
<code>{</code> and <code>}</code>. Also called <em>curly brace</em>, they delimit <em>blocks</em>.</li>
<li>build:<br />
The process of converting source code into executable code or a usable
program.</li>
<li>call:<br />
To invoke or execute a function or method.</li>
<li>channel:<br />
Used to safely pass messages <a href="#concurrency-channels">between threads</a>.</li>
<li>Comprehensive Rust ü¶Ä:<br />
The courses here are jointly called Comprehensive Rust ü¶Ä.</li>
<li>concurrency:<br />
The execution of multiple tasks or processes at the same time.</li>
<li>Concurrency in Rust:<br />
See <a href="#concurrency-welcome">Concurrency in Rust</a>.</li>
<li>constant:<br />
A value that does not change during the execution of a program.</li>
<li>control flow:<br />
The order in which the individual statements or instructions are executed in a
program.</li>
<li>crash:<br />
An unexpected and unhandled failure or termination of a program.</li>
<li>enumeration:<br />
A data type that holds one of several named constants, possibly with an
associated tuple or struct.</li>
<li>error:<br />
An unexpected condition or result that deviates from the expected behavior.</li>
<li>error handling:<br />
The process of managing and responding to errors that occur during program
execution.</li>
<li>exercise:<br />
A task or problem designed to practice and test programming skills.</li>
<li>function:<br />
A reusable block of code that performs a specific task.</li>
<li>garbage collector:<br />
A mechanism that automatically frees up memory occupied by objects that are no
longer in use.</li>
<li>generics:<br />
A feature that allows writing code with placeholders for types, enabling code
reuse with different data types.</li>
<li>immutable:<br />
Unable to be changed after creation.</li>
<li>integration test:<br />
A type of test that verifies the interactions between different parts or
components of a system.</li>
<li>keyword:<br />
A reserved word in a programming language that has a specific meaning and
cannot be used as an identifier.</li>
<li>library:<br />
A collection of precompiled routines or code that can be used by programs.</li>
<li>macro:<br />
Rust macros can be recognized by a <code>!</code> in the name. Macros are used when
normal functions are not enough. A typical example is <code>format!</code>, which takes a
variable number of arguments, which isn't supported by Rust functions.</li>
<li><code>main</code> function:<br />
Rust programs start executing with the <code>main</code> function.</li>
<li>match:<br />
A control flow construct in Rust that allows for pattern matching on the value
of an expression.</li>
<li>memory leak:<br />
A situation where a program fails to release memory that is no longer needed,
leading to a gradual increase in memory usage.</li>
<li>method:<br />
A function associated with an object or a type in Rust.</li>
<li>module:<br />
A namespace that contains definitions, such as functions, types, or traits, to
organize code in Rust.</li>
<li>move:<br />
The transfer of ownership of a value from one variable to another in Rust.</li>
<li>mutable:<br />
A property in Rust that allows variables to be modified after they have been
declared.</li>
<li>ownership:<br />
The concept in Rust that defines which part of the code is responsible for
managing the memory associated with a value.</li>
<li>panic:<br />
An unrecoverable error condition in Rust that results in the termination of
the program.</li>
<li>parameter:<br />
A value that is passed into a function or method when it is called.</li>
<li>pattern:<br />
A combination of values, literals, or structures that can be matched against
an expression in Rust.</li>
<li>payload:<br />
The data or information carried by a message, event, or data structure.</li>
<li>program:<br />
A set of instructions that a computer can execute to perform a specific task
or solve a particular problem.</li>
<li>programming language:<br />
A formal system used to communicate instructions to a computer, such as Rust.</li>
<li>receiver:<br />
The first parameter in a Rust method that represents the instance on which the
method is called.</li>
<li>reference counting:<br />
A memory management technique in which the number of references to an object
is tracked, and the object is deallocated when the count reaches zero.</li>
<li>return:<br />
A keyword in Rust used to indicate the value to be returned from a function.</li>
<li>Rust:<br />
A systems programming language that focuses on safety, performance, and
concurrency.</li>
<li>Rust Fundamentals:<br />
Days 1 to 4 of this course.</li>
<li>Rust in Android:<br />
See <a href="#android">Rust in Android</a>.</li>
<li>Rust in Chromium:<br />
See <a href="#chromium">Rust in Chromium</a>.</li>
<li>safe:<br />
Refers to code that adheres to Rust's ownership and borrowing rules,
preventing memory-related errors.</li>
<li>scope:<br />
The region of a program where a variable is valid and can be used.</li>
<li>standard library:<br />
A collection of modules providing essential functionality in Rust.</li>
<li>static:<br />
A keyword in Rust used to define static variables or items with a <code>'static</code>
lifetime.</li>
<li>string:<br />
A data type storing textual data. See <a href="#references-strings">Strings</a> for
more.</li>
<li>struct:<br />
A composite data type in Rust that groups together variables of different
types under a single name.</li>
<li>test:<br />
A Rust module containing functions that test the correctness of other
functions.</li>
<li>thread:<br />
A separate sequence of execution in a program, allowing concurrent execution.</li>
<li>thread safety:<br />
The property of a program that ensures correct behavior in a multithreaded
environment.</li>
<li>trait:<br />
A collection of methods defined for an unknown type, providing a way to
achieve polymorphism in Rust.</li>
<li>trait bound:<br />
An abstraction where you can require types to implement some traits of your
interest.</li>
<li>tuple:<br />
A composite data type that contains variables of different types. Tuple fields
have no names, and are accessed by their ordinal numbers.</li>
<li>type:<br />
A classification that specifies which operations can be performed on values of
a particular kind in Rust.</li>
<li>type inference:<br />
The ability of the Rust compiler to deduce the type of a variable or
expression.</li>
<li>undefined behavior:<br />
Actions or conditions in Rust that have no specified result, often leading to
unpredictable program behavior.</li>
<li>union:<br />
A data type that can hold values of different types but only one at a time.</li>
<li>unit test:<br />
Rust comes with built-in support for running small unit tests and larger
integration tests. See <a href="#testing-unit-tests">Unit Tests</a>.</li>
<li>unit type:<br />
Type that holds no data, written as a tuple with no members.</li>
<li>unsafe:<br />
The subset of Rust which allows you to trigger <em>undefined behavior</em>. See
<a href="#unsafe-rust-unsafe">Unsafe Rust</a>.</li>
<li>variable:<br />
A memory location storing data. Variables are valid in a <em>scope</em>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="other-resources"></div><h1 id="other-resources-other-rust-resources"><a class="header" href="#other-resources-other-rust-resources">Other Rust Resources</a></h1>
<p>The Rust community has created a wealth of high-quality and free resources
online.</p>
<h2 id="other-resources-official-documentation"><a class="header" href="#other-resources-official-documentation">Official Documentation</a></h2>
<p>The Rust project hosts many resources. These cover Rust in general:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>: the
canonical free book about Rust. Covers the language in detail and includes a
few projects for people to build.</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>: covers the Rust
syntax via a series of examples which showcase different constructs. Sometimes
includes small exercises where you are asked to expand on the code in the
examples.</li>
<li><a href="https://doc.rust-lang.org/std/">Rust Standard Library</a>: full documentation of
the standard library for Rust.</li>
<li><a href="https://doc.rust-lang.org/reference/">The Rust Reference</a>: an incomplete book
which describes the Rust grammar and memory model.</li>
</ul>
<p>More specialized guides hosted on the official Rust site:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>: covers unsafe Rust,
including working with raw pointers and interfacing with other languages
(FFI).</li>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a>:
covers the new asynchronous programming model which was introduced after the
Rust Book was written.</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">The Embedded Rust Book</a>: an
introduction to using Rust on embedded devices without an operating system.</li>
</ul>
<h2 id="other-resources-unofficial-learning-material"><a class="header" href="#other-resources-unofficial-learning-material">Unofficial Learning Material</a></h2>
<p>A small selection of other guides and tutorial for Rust:</p>
<ul>
<li><a href="http://cliffle.com/p/dangerust/">Learn Rust the Dangerous Way</a>: covers Rust
from the perspective of low-level C programmers.</li>
<li><a href="https://opentitan.org/book/doc/rust_for_c_devs.html">Rust for Embedded C Programmers</a>:
covers Rust from the perspective of developers who write firmware in C.</li>
<li><a href="https://overexact.com/rust-for-professionals/">Rust for professionals</a>:
covers the syntax of Rust using side-by-side comparisons with other languages
such as C, C++, Java, JavaScript, and Python.</li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercism</a>: 100+ exercises to help
you learn Rust.</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/index.html">Ferrous Teaching Material</a>:
a series of small presentations covering both basic and advanced part of the
Rust language. Other topics such as WebAssembly, and async/await are also
covered.</li>
<li><a href="https://rust-exercises.com/advanced-testing/">Advanced testing for Rust applications</a>:
a self-paced workshop that goes beyond Rust's built-in testing framework. It
covers <code>googletest</code>, snapshot testing, mocking as well as how to write your
own custom test harness.</li>
<li><a href="https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/">Beginner's Series to Rust</a>
and
<a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Take your first steps with Rust</a>:
two Rust guides aimed at new developers. The first is a set of 35 videos and
the second is a set of 11 modules which covers Rust syntax and basic
constructs.</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked
Lists</a>: in-depth
exploration of Rust's memory management rules, through implementing a few
different types of list structures.</li>
</ul>
<p>Please see the <a href="https://lborb.github.io/book/">Little Book of Rust Books</a> for
even more Rust books.</p>
<div style="break-before: page; page-break-before: always;"></div><div id="credits"></div><h1 id="credits-credits"><a class="header" href="#credits-credits">Credits</a></h1>
<p>The material here builds on top of the many great sources of Rust documentation.
See the page on <a href="#other-resources">other resources</a> for a full list of useful
resources.</p>
<p>The material of Comprehensive Rust is licensed under the terms of the Apache 2.0
license, please see
<a href="https://github.com/google/comprehensive-rust/blob/main/LICENSE"><code>LICENSE</code></a> for
details.</p>
<h2 id="credits-rust-by-example"><a class="header" href="#credits-rust-by-example">Rust by Example</a></h2>
<p>Some examples and exercises have been copied and adapted from
<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>. Please see the
<code>third_party/rust-by-example/</code> directory for details, including the license
terms.</p>
<h2 id="credits-rust-on-exercism"><a class="header" href="#credits-rust-on-exercism">Rust on Exercism</a></h2>
<p>Some exercises have been copied and adapted from
<a href="https://exercism.org/tracks/rust">Rust on Exercism</a>. Please see the
<code>third_party/rust-on-exercism/</code> directory for details, including the license
terms.</p>
<h2 id="credits-cxx"><a class="header" href="#credits-cxx">CXX</a></h2>
<p>The <a href="#android-interoperability-cpp">Interoperability with C++</a> section uses an
image from <a href="https://cxx.rs/">CXX</a>. Please see the <code>third_party/cxx/</code> directory
for details, including the license terms.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/speaker-notes.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
