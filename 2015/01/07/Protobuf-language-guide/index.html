<!DOCTYPE html><html><head><meta charset="utf-8"><title>[译]Protobuf 语法指南</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="英文: Proto Buffers Language Guide
本指南描述了怎样使用protocol buffer 语法来构造你的protocol buffer数据，包括.proto文件语法以及怎样生成.proto文件的数据访问类。(本文只针对proto2的语法)
本文是一个参考指南——如果要查看如何使用本文中描述的多个特性的循序渐进的例子，请在http://code.google.com/in"><meta property="og:type" content="article"><meta property="og:title" content="[译]Protobuf 语法指南"><meta property="og:url" content="https://colobu.com/2015/01/07/Protobuf-language-guide/"><meta property="og:site_name" content="鸟窝"><meta property="og:description" content="英文: Proto Buffers Language Guide
本指南描述了怎样使用protocol buffer 语法来构造你的protocol buffer数据，包括.proto文件语法以及怎样生成.proto文件的数据访问类。(本文只针对proto2的语法)
本文是一个参考指南——如果要查看如何使用本文中描述的多个特性的循序渐进的例子，请在http://code.google.com/in"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="[译]Protobuf 语法指南"><meta name="twitter:description" content="英文: Proto Buffers Language Guide
本指南描述了怎样使用protocol buffer 语法来构造你的protocol buffer数据，包括.proto文件语法以及怎样生成.proto文件的数据访问类。(本文只针对proto2的语法)
本文是一个参考指南——如果要查看如何使用本文中描述的多个特性的循序渐进的例子，请在http://code.google.com/in"><link rel="alternative" href="/atom.xml" title="鸟窝" type="application/atom+xml"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/style.css" type="text/css"><link href="//cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/css/jquery.fancybox.min.css" media="screen" type="text/css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" media="screen" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap" class="animated bounceInLeft"><a href="/" id="logo">鸟窝</a></h1><h2 id="subtitle-wrap" class="animated bounceInLeft"><a href="/" id="subtitle">大道至简 Simplicity is the ultimate form of sophistication</a></h2></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/"><i class="fa fa-home">&nbsp;</i>首页</a> <a class="main-nav-link" href="/archives"><i class="fa fa-folder-o">&nbsp;</i>归档</a> <a class="main-nav-link" href="https://github.com/smallnest"><i class="fa fa-github">&nbsp;</i>github</a><div class="dropdown main-nav-link"><a class="main-nav-link" href="#"><i class="fa fa-bars">&nbsp;</i>网站群</a><div class="dropdown-content"><a href="/goasm"><i class="fa fa-language"></i>&nbsp;Go汇编示例</a> <a href="https://gowebexamples.com"><i class="fa fa-external-link"></i>&nbsp;Go Web开发示例</a> <a href="http://go-database-sql.org"><i class="fa fa-external-link"></i>&nbsp;Go 数据库开发教程</a><hr><a href="http://rpcx.io"><i class="fa undefined"></i>&nbsp;RPCX官网</a> <a href="http://cn.doc.rpcx.io"><i class="fa undefined"></i>&nbsp;RPC开发指南</a></div></div><a class="main-nav-link" href="/ScalaCollectionsCookbook"><i class="fa fa-book">&nbsp;</i>Scala集合技术手册</a> <a class="main-nav-link" href="/about"><i class="fa fa-lemon-o">&nbsp;</i>关于</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="Search"></a></nav><div id="search-form-wrap"><form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form"><input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search"> <input type="submit" class="search-form-submit"> <input name="tn" type="hidden" value="bds"> <input name="cl" type="hidden" value="3"> <input name="ct" type="hidden" value="2097152"> <input type="hidden" name="si" value="colobu.com"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-Protobuf-language-guide" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2015/01/07/Protobuf-language-guide/" class="article-date"><time datetime="2015-01-07T03:36:04.000Z" itemprop="datePublished">2015年01月07日</time></a><div class="article-author">by Google</div></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">[译]Protobuf 语法指南</h1></header><div class="article-entry" itemprop="articleBody"><h1 id="expanderHead" style="cursor:pointer">目录 <span id="expanderSign">[−]</span></h1><div id="article-entry-toc" data-role="collapsible" class="article-entry-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义一个消息类型"><span class="toc-text">定义一个消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定字段类型"><span class="toc-text">指定字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配标识号"><span class="toc-text">分配标识号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定字段规则"><span class="toc-text">指定字段规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加更多消息类型"><span class="toc-text">添加更多消息类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加注释"><span class="toc-text">添加注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从-proto文件生成了什么？"><span class="toc-text">从.proto文件生成了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标量数值类型"><span class="toc-text">标量数值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional的字段和默认值"><span class="toc-text">Optional的字段和默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举"><span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用其他消息类型"><span class="toc-text">使用其他消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#导入定义"><span class="toc-text">导入定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套类型"><span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组"><span class="toc-text">组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新一个消息类型"><span class="toc-text">更新一个消息类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展"><span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套的扩展"><span class="toc-text">嵌套的扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择可扩展的标量符号"><span class="toc-text">选择可扩展的标量符号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Oneof"><span class="toc-text">Oneof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Oneof"><span class="toc-text">使用Oneof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向后兼容性问题"><span class="toc-text">向后兼容性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包（Package）"><span class="toc-text">包（Package）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包及名称的解析"><span class="toc-text">包及名称的解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义服务(Service)"><span class="toc-text">定义服务(Service)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选项（Options）"><span class="toc-text">选项（Options）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义选项"><span class="toc-text">自定义选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成访问类"><span class="toc-text">生成访问类</span></a></li></ol></div><script>function show_answer(e,l){"显示答案"===e.value?e.value="隐藏答案":e.value="显示答案";var n=document.getElementById(l);"none"===n.style.display?n.style.display="block":n.style.display="none"}</script><p>英文: <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">Proto Buffers Language Guide</a></p><p>本指南描述了怎样使用protocol buffer 语法来构造你的protocol buffer数据，包括.proto文件语法以及怎样生成.proto文件的数据访问类。<br>(本文只针对proto2的语法)</p><p>本文是一个参考指南——如果要查看如何使用本文中描述的多个特性的循序渐进的例子，请在<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/tutorials.html" target="_blank" rel="external">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/tutorials.html</a>中查找需要的语言的教程。</p><a id="more"></a><h2 id="定义一个消息类型">定义一个消息类型</h2><p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>SearchRequest消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</p><h3 id="指定字段类型">指定字段类型</h3><p>在上面的例子中，所有字段都是<a href="https://developers.google.com/protocol-buffers/docs/proto#scalar" target="_blank" rel="external">标量类型</a>：两个整型（page_number和result_per_page），一个string类型（query）。当然，你也可以为字段指定其他的合成类型，包括<a href="https://developers.google.com/protocol-buffers/docs/proto#enum" target="_blank" rel="external">枚举</a>（enumerations）或其他消息类型。</p><h3 id="分配标识号">分配标识号</h3><p>正如上述文件格式，在消息定义中，每个字段都有唯一的一个<strong>数字标识符</strong>。这些标识符是用来在消息的<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">二进制格式</a>中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p><p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。</p><h3 id="指定字段规则">指定字段规则</h3><p>所指定的消息字段修饰符必须是如下之一：</p><ul><li>required：一个格式良好的消息一定要含有1个这种字段。表示该值是必须要设置的；</li><li>optional：消息格式中该字段可以有0个或1个值（不超过1个）。</li><li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。表示该值可以重复，相当于java中的List。</li></ul><p>由于一些历史原因，基本数值类型的repeated的字段并没有被尽可能地高效编码。在新的代码中，用户应该使用特殊选项[packed=true]来保证更高效的编码。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> samples = <span class="number">4</span> [packed=<span class="literal">true</span>];</div></pre></td></tr></table></figure><blockquote><p>required是永久性的：在将一个字段标识为required的时候，应该特别小心。如果在某些情况下不想写入或者发送一个required的字段，将原始该字段修饰符更改为optional可能会遇到问题——旧版本的使用者会认为不含该字段的消息是不完整的，从而可能会无目的的拒绝解析。在这种情况下，你应该考虑编写特别针对于应用程序的、自定义的消息校验函数。Google的一些工程师得出了一个结论：使用required弊多于利；他们更 愿意使用optional和repeated而不是required。当然，这个观点并不具有普遍性。</p></blockquote><h3 id="添加更多消息类型">添加更多消息类型</h3><p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line"> ...</div><div class="line">}</div></pre></td></tr></table></figure><h3 id="添加注释">添加注释</h3><p>向.proto文件添加注释，可以使用C/C++/java风格的双斜杠（//） 语法格式，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;<span class="comment">// Which page number do we want?</span></div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;<span class="comment">// Number of results to return per page.</span></div><div class="line">}</div></pre></td></tr></table></figure><h3 id="从-proto文件生成了什么？">从.proto文件生成了什么？</h3><p>当用protocolbuffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p><ul><li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li><li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li><li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</li></ul><p>你可以从如下的文档链接中获取每种语言更多API。<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html" target="_blank" rel="external">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html</a></p><h3 id="标量数值类型">标量数值类型</h3><p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p><table><tbody><tr><td><p>.proto类型</p></td><td><p>Java 类型</p></td><td><p>C++类型</p></td><td><p>备注</p></td></tr><tr><td><p>double</p></td><td><p>double</p></td><td><p>double</p></td><td><p>&nbsp;</p></td></tr><tr><td><p>float</p></td><td><p>float</p></td><td><p>float</p></td><td><p>&nbsp;</p></td></tr><tr><td><p>int32</p></td><td><p>int</p></td><td><p>int32</p></td><td><p>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint32。</p></td></tr><tr><td><p>int64</p></td><td><p>long</p></td><td><p>int64</p></td><td><p>使用可变长编码方式。编码负数时不够高效——如果你的字段可能含有负数，那么请使用sint64。</p></td></tr><tr><td><p>uint32</p></td><td><p>int[1]</p></td><td><p>uint32</p></td><td><p>Uses variable-length encoding.</p></td></tr><tr><td><p>uint64</p></td><td>long[1]</td><td>uint64</td><td>Uses variable-length encoding.</td></tr><tr><td><p>sint32</p></td><td><p>int</p></td><td><p>int32</p></td><td><p>使用可变长编码方式。有符号的整型值。编码时比通常的int32高效。</p></td></tr><tr><td><p>sint64</p></td><td><p>long</p></td><td><p>int64</p></td><td><p>使用可变长编码方式。有符号的整型值。编码时比通常的int64高效。</p></td></tr><tr><td><p>fixed32</p></td><td><p>int[1]</p></td><td><p>uint32</p></td><td><p>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</p></td></tr><tr><td><p>fixed64</p></td><td><p>long[1]</p></td><td><p>uint64</p></td><td><p>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</p></td></tr><tr><td><p>sfixed32</p></td><td><p>int</p></td><td><p>int32</p></td><td><p>总是4个字节。</p></td></tr><tr><td><p>sfixed64</p></td><td><p>long</p></td><td><p>int64</p></td><td><p>总是8个字节。</p></td></tr><tr><td><p>bool</p></td><td><p>boolean</p></td><td><p>bool</p></td><td><p>&nbsp;</p></td></tr><tr><td><p>string</p></td><td><p>String</p></td><td><p>string</p></td><td><p>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</p></td></tr><tr><td><p>bytes</p></td><td><p>ByteString</p></td><td><p>string</p></td><td><p>可能包含任意顺序的字节数据。</p></td></tr></tbody></table><p>你可以在文章<a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html" target="_blank" rel="external">http://code.google.com/apis/protocolbuffers/docs/encoding.html</a> 中，找到更多“序列化消息时各种类型如何编码”的信息。</p><h3 id="Optional的字段和默认值">Optional的字段和默认值</h3><p>如上所述，消息描述中的一个元素可以被标记为“可选的”（optional）。一个格式良好的消息可以包含0个或一个optional的元素。当解 析消息时，如果它不包含optional的元素值，那么解析出来的对象中的对应字段就被置为默认值。默认值可以在消息描述文件中指定。例如，要为 <em>SearchRequest</em>消息的<em>result_per_page</em>字段指定默认值10，在定义消息格式时如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</div></pre></td></tr></table></figure><p>如果没有为optional的元素指定默认值，就会使用与特定类型相关的默认值：对string来说，默认值是空字符串。对bool来说，默认值是false。对数值类型来说，默认值是0。对枚举来说，默认值是枚举类型定义中的第一个值。</p><h3 id="枚举">枚举</h3><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）就可以了。一个enum类型的字段只能用指定的常量集中的一个值作为其值（如果尝 试指定不同的值，解析器就会把它当作一个未知的字段来对待）。在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>{</div><div class="line"><span class="constant">    UNIVERSAL</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">    WEB</span> = <span class="number">1</span>;</div><div class="line"><span class="constant">    IMAGES</span> = <span class="number">2</span>;</div><div class="line"><span class="constant">    LOCAL</span> = <span class="number">3</span>;</div><div class="line"><span class="constant">    NEWS</span> = <span class="number">4</span>;</div><div class="line"><span class="constant">    PRODUCTS</span> = <span class="number">5</span>;</div><div class="line"><span class="constant">    VIDEO</span> = <span class="number">6</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">optional</span> Corpus corpus = <span class="number">4</span> [default = UNIVERSAL];</div><div class="line">}</div></pre></td></tr></table></figure><p>你可以为枚举常量定义别名。 需要设置allow_alias option 为 true, 否则 protocol编译器会产生错误信息。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAllowingAlias</span> </span>{</div><div class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</div><div class="line"><span class="constant">  UNKNOWN</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">  STARTED</span> = <span class="number">1</span>;</div><div class="line"><span class="constant">  RUNNING</span> = <span class="number">1</span>;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> </span>{</div><div class="line"><span class="constant">  UNKNOWN</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">  STARTED</span> = <span class="number">1</span>;</div><div class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></div><div class="line">}</div></pre></td></tr></table></figure><p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p><p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p><p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html。" target="_blank" rel="external">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html。</a></p><h2 id="使用其他消息类型">使用其他消息类型</h2><p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">2</span>;</div><div class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</div><div class="line">}</div></pre></td></tr></table></figure><h3 id="导入定义">导入定义</h3><p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</div></pre></td></tr></table></figure><p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个dummy .proto 文件在老的位置， 然后使用import转向新的位置:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// new.proto</span></div><div class="line"><span class="comment">// All definitions are moved here</span></div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// old.proto</span></div><div class="line"><span class="comment">// This is the proto that all clients are importing.</span></div><div class="line"><span class="keyword">import</span> <span class="keyword">public</span> "<span class="keyword">new</span>.proto";</div><div class="line"><span class="keyword">import</span> <span class="string">"other.proto"</span>;</div></pre></td></tr></table></figure><p>// client.proto</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"old.proto"</span>;</div><div class="line">// You use definitions <span class="keyword">from</span> old.proto <span class="keyword">and</span> new.proto, but <span class="keyword">not</span> other.proto</div></pre></td></tr></table></figure><p>protocol编译器就会在一系列目录中查找需要被导入的文件，这些目录通过protocol编译器的命令行参数-I/–import_path指定。如果不提供参数，编译器就在其调用目录下查找。</p><h3 id="嵌套类型">嵌套类型</h3><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</div><div class="line">    <span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">1</span>;</div><div class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">2</span>;</div><div class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">message <span class="type">SomeOtherMessage</span> {</div><div class="line">  optional <span class="type">SearchResponse</span>.<span class="type">Result</span> <span class="literal">result</span> = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>当然，你也可以将消息嵌套任意多层，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>{                  <span class="comment">// Level 0</span></div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>{  <span class="comment">// Level 1</span></div><div class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></div><div class="line">      <span class="keyword">required</span> <span class="built_in">int64</span> ival = <span class="number">1</span>;</div><div class="line">      <span class="keyword">optional</span> <span class="built_in">bool</span>  booly = <span class="number">2</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>{  <span class="comment">// Level 1</span></div><div class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></div><div class="line">      <span class="keyword">required</span> <span class="built_in">int32</span> ival = <span class="number">1</span>;</div><div class="line">      <span class="keyword">optional</span> <span class="built_in">bool</span>  booly = <span class="number">2</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure><h3 id="组">组</h3><p><strong>注：该特性已被弃用，在创建新的消息类型的时候，不应该再使用它——可以使用嵌套消息类型来代替它。</strong></p><p>“组”是指在消息定义中嵌套信息的另一种方法。比如，在SearchResponse中包含若干Result的另一种方法是 ：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="keyword">repeated</span> <span class="keyword">group</span> Result = <span class="number">1</span> {</div><div class="line">    <span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">2</span>;</div><div class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">3</span>;</div><div class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">4</span>;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure><p>一个“组”只是简单地将一个嵌套消息类型和一个字段捆绑到一个单独的声明中。在代码中，可以把它看成是含有一个Result类型、名叫result的字段的消息（后面的名字被转换成了小写，所以它不会与前面的冲突）。</p><p>因此，除了数据传输格式不同之外，这个例子与上面的SearchResponse例子是完全等价的。</p><h3 id="更新一个消息类型">更新一个消息类型</h3><p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p><ul><li>不要更改任何已有的字段的数值标识。<br>*所添加的任何字段都必须是optional或repeated的。这就意味着任何使用“旧”的消息格式的代码序列化的消息可以被新的代码所解析，因为它们 不会丢掉任何required的元素。应该为这些元素设置合理的默认值，这样新的代码就能够正确地与老代码生成的消息交互了。类似地，新的代码创建的消息 也能被老的代码解析：老的二进制程序在解析的时候只是简单地将新字段忽略。然而，未知的字段是没有被抛弃的。此后，如果消息被序列化，未知的字段会随之一 起被序列化——所以，如果消息传到了新代码那里，则新的字段仍然可用。注意：对Python来说，对未知字段的保留策略是无效的。</li><li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li><li>一个非required的字段可以转换为一个扩展，反之亦然——只要它的类型和标识号保持不变。</li><li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li><li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li><li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li><li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li><li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li></ul><h3 id="扩展">扩展</h3><p>通过扩展，可以将一个范围内的字段标识号声明为可被第三方扩展所用。然后，其他人就可以在他们自己的.proto文件中为该消息类型声明新的字段，而不必去编辑原始文件了。看个具体例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">message Foo {</div><div class="line">  // <span class="keyword">...</span></div><div class="line">  extensions <span class="number">100</span> to <span class="number">199</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>这个例子表明：在消息Foo中，范围[100,199]之内的字段标识号被保留为扩展用。现在，其他人就可以在他们自己的.proto文件中添加新字段到Foo里了，但是添加的字段标识号要在指定的范围内——例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend Foo {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> bar = <span class="number">126</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>这个例子表明：消息Foo现在有一个名为bar的optional int32字段。</p><p>当用户的Foo消息被编码的时候，数据的传输格式与用户在Foo里定义新字段的效果是完全一样的。<br>然而，要在程序代码中访问扩展字段的方法与访问普通的字段稍有不同——生成的数据访问代码为扩展准备了特殊的访问函数来访问它。例如，下面是如何在C++中设置bar的值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Foo foo;</div><div class="line">foo.SetExtension(bar, 15);</div></pre></td></tr></table></figure><p>类似地，Foo类也定义了模板函数 HasExtension()，ClearExtension()，GetExtension()，MutableExtension()，以及 AddExtension()。这些函数的语义都与对应的普通字段的访问函数相符。要查看更多使用扩展的信息，请参考相应语言的代码生成指南。注：扩展可 以是任何字段类型，包括消息类型。</p><h3 id="嵌套的扩展">嵌套的扩展</h3><p>可以在另一个类型的范围内声明扩展，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message Baz {</div><div class="line">  extend Foo {</div><div class="line">    optional int32 bar = <span class="number">126</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure><p>在此例中，访问此扩展的C++代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Foo foo<span class="comment">;</span></div><div class="line">foo.SetExtension(<span class="literal">Baz::bar</span>, <span class="number">15</span>)<span class="comment">;</span></div></pre></td></tr></table></figure><p>In other words, the only effect is that bar is defined within the scope of Baz.</p><blockquote><p>This is a common source of confusion: Declaring an extend block nested inside a message type does not imply any relationship between the outer type and the extended type. In particular, the above example does not mean that Baz is any sort of subclass of Foo. All it means is that the symbol bar is declared inside the scope of Baz; it&#39;s simply a static member.</p></blockquote><p>一个通常的设计模式就是：在扩展的字段类型的范围内定义该扩展——例如，下面是一个Foo的扩展（该扩展是Baz类型的），其中，扩展被定义为了Baz的一部分：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message Baz {</div><div class="line">  extend Foo {</div><div class="line">    optional Baz foo_ext = <span class="number">127</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure><p>然而，并没有强制要求一个消息类型的扩展一定要定义在那个消息中。也可以这样做：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">message Baz {</div><div class="line">  <span class="keyword">...</span></div><div class="line">}</div><div class="line"></div><div class="line">// This can even be <span class="keyword">in</span> a different file.</div><div class="line">extend Foo {</div><div class="line">  optional Baz foo_baz_ext = <span class="number">127</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>事实上，这种语法格式更能防止引起混淆。正如上面所提到的，嵌套的语法通常被错误地认为有子类化的关系——尤其是对那些还不熟悉扩展的用户来说。</p><h3 id="选择可扩展的标量符号">选择可扩展的标量符号</h3><p>在同一个消息类型中一定要确保两个用户不会扩展新增相同的标识号，否则可能会导致数据的不一致。可以通过为新项目定义一个可扩展标识号规则来防止该情况的发生。</p><p>如果标识号需要很大的数量时，可以将该可扩展标符号的范围扩大至max，其中max是229 - 1, 或536,870,911。如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>{</div><div class="line"></div><div class="line">  extensions <span class="number">1000</span> to max;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure><p>max 是 2^29 - 1, 或者 536,870,911.</p><p>通常情况下在选择标符号时，标识号产生的规则中应该避开[19000－19999]之间的数字，因为这些已经被Protocol Buffers实现中预留了。</p><h2 id="Oneof">Oneof</h2><p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用<code>oneof</code>特性节省内存.</p><p>Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它oneof字段。 你可以使用case()或者WhichOneof() 方法检查哪个oneof字段被设置， 看你使用什么语言了.</p><h3 id="使用Oneof">使用Oneof</h3><p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>{</div><div class="line">  oneof test_oneof {</div><div class="line">     <span class="built_in">string</span> name = <span class="number">4</span>;</div><div class="line"><span class="constant">     SubMessage sub_message</span> = <span class="number">9</span>;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure><p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用 required, optional, repeated 关键字.</p><p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言API中找到oneof API介绍.</p><p>Oneof 特性:</p><ul><li>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SampleMessage <span class="keyword">message</span>;</div><div class="line"><span class="keyword">message</span>.set_name(“name”);</div><div class="line">CHECK(<span class="keyword">message</span>.has_name());</div><div class="line"><span class="keyword">message</span>.mutable_sub_message();   <span class="comment">// Will clear name field.</span></div><div class="line">CHECK(!<span class="keyword">message</span>.has_name());</div></pre></td></tr></table></figure><ul><li>If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message.</li><li>oneof不支持扩展.</li><li>oneof不能 repeated.</li><li>反射API对oneof 字段有效.</li><li>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SampleMessage <span class="keyword">message</span>;</div><div class="line">SubMessage* sub_message = <span class="keyword">message</span>.mutable_sub_message();</div><div class="line"><span class="keyword">message</span>.set_name(“name”);      <span class="comment">// Will delete sub_message</span></div><div class="line">sub_message.set_…              <span class="comment">// Crashes here</span></div></pre></td></tr></table></figure><ul><li>Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case: in the example below, msg1 will have a sub_message and msg2 will have a name.</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SampleMessage msg1;</div><div class="line">msg1.set_name(“name”);</div><div class="line">SampleMessage msg2;</div><div class="line">msg2.mutable_sub_message();</div><div class="line">msg1.swap(&msg2);</div><div class="line"><span class="operator"><span class="keyword">CHECK</span>(msg1.has_sub_message());</span></div><div class="line"><span class="operator"><span class="keyword">CHECK</span>(msg2.has_name());</span></div></pre></td></tr></table></figure><h3 id="向后兼容性问题">向后兼容性问题</h3><p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None/NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况。</p><p><strong>Tag 重用问题</strong></p><ul><li><strong>Move optional fields into or out of a oneof</strong>: You may lose some of your information (some fields will be cleared) after the message is serialized and parsed.</li><li><strong>Delete a oneof field and add it back</strong>: This may clear your currently set oneof field after the message is serialized and parsed.</li><li><strong>Split or merge oneof</strong>: This has similar issues to moving regular optional fields.</li></ul><h2 id="包（Package）">包（Package）</h2><p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">package foo.bar;</div><div class="line">message Open { <span class="keyword">...</span> }</div></pre></td></tr></table></figure><p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message Foo {</div><div class="line">  <span class="keyword">...</span></div><div class="line">  required foo.bar.Open open = <span class="number">1</span>;</div><div class="line">  <span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure><p>包的声明符会根据使用语言的不同影响生成的代码。</p><ul><li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中；</li><li>对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li><li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li></ul><h3 id="包及名称的解析">包及名称的解析</h3><p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p><h2 id="定义服务(Service)">定义服务(Service)</h2><p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>protocol编译器将产生一个抽象接口SearchService以及一个相应的存根实现。存根将所有的调用指向RpcChannel，它是一 个抽象接口，必须在RPC系统中对该接口进行实现。如，可以实现RpcChannel以完成序列化消息并通过HTTP方式来发送到一个服务器。换句话说， 产生的存根提供了一个类型安全的接口用来完成基于protocolbuffer的RPC调用，而不是将你限定在一个特定的RPC的实现中。C++中的代码 如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> google::protobuf;</div><div class="line"></div><div class="line">protobuf::RpcChannel* channel;</div><div class="line">protobuf::RpcController* controller;</div><div class="line">SearchService* service;</div><div class="line">SearchRequest request;</div><div class="line">SearchResponse response;</div><div class="line"></div><div class="line"><span class="keyword">void</span> DoSearch() {</div><div class="line">  <span class="comment">// You provide classes MyRpcChannel and MyRpcController, which implement</span></div><div class="line">  <span class="comment">// the abstract interfaces protobuf::RpcChannel and protobuf::RpcController.</span></div><div class="line">  channel = <span class="keyword">new</span> MyRpcChannel(<span class="string">"somehost.example.com:1234"</span>);</div><div class="line">  controller = <span class="keyword">new</span> MyRpcController;</div><div class="line"></div><div class="line">  <span class="comment">// The protocol compiler generates the SearchService class based on the</span></div><div class="line">  <span class="comment">// definition given above.</span></div><div class="line">  service = <span class="keyword">new</span> SearchService::Stub(channel);</div><div class="line"></div><div class="line">  <span class="comment">// Set up the request.</span></div><div class="line">  request.set_query(<span class="string">"protocol buffers"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Execute the RPC.</span></div><div class="line">  service-&gt;Search(controller, request, response, protobuf::NewCallback(&Done));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Done() {</div><div class="line">  <span class="keyword">delete</span> service;</div><div class="line">  <span class="keyword">delete</span> channel;</div><div class="line">  <span class="keyword">delete</span> controller;</div><div class="line">}</div></pre></td></tr></table></figure><p>所有service类都必须实现Service接口，它提供了一种用来调用具体方法的方式，即在编译期不需要知道方法名及它的输入、输出类型。在服务器端，通过服务注册它可以被用来实现一个RPC Server。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> google::protobuf;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ExampleSearchService : <span class="keyword">public</span> SearchService {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">void</span> Search(protobuf::RpcController* controller,</div><div class="line">              <span class="keyword">const</span> SearchRequest* request,</div><div class="line">              SearchResponse* response,</div><div class="line">              protobuf::Closure* done) {</div><div class="line">    <span class="keyword">if</span> (request-&gt;query() == <span class="string">"google"</span>) {</div><div class="line">      response-&gt;add_result()-&gt;set_url(<span class="string">"http://www.google.com"</span>);</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (request-&gt;query() == <span class="string">"protocol buffers"</span>) {</div><div class="line">      response-&gt;add_result()-&gt;set_url(<span class="string">"http://protobuf.googlecode.com"</span>);</div><div class="line">    }</div><div class="line">    done-&gt;Run();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">  <span class="comment">// You provide class MyRpcServer.  It does not have to implement any</span></div><div class="line">  <span class="comment">// particular interface; this is just an example.</span></div><div class="line">  MyRpcServer server;</div><div class="line"></div><div class="line">  protobuf::Service* service = <span class="keyword">new</span> ExampleSearchService;</div><div class="line">  server.ExportOnPort(<span class="number">1234</span>, service);</div><div class="line">  server.Run();</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> service;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>There are a number of ongoing third-party projects to develop RPC implementations for Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.</p><h2 id="选项（Options）">选项（Options）</h2><p>在定义.proto文件时能够标注一系列的options。Options并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在google/protobuf/descriptor.proto找到。</p><p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定 义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p><p>如下就是一些常用的选择：</p><ul><li><code>java_package (file option)</code>: 这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> java_package = <span class="string">"com.example.foo"</span>;</div></pre></td></tr></table></figure><ul><li><code>java_outer_classname (file option)</code>: 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"Ponycopter"</span>;</div></pre></td></tr></table></figure><ul><li><code>optimize_for (fileoption)</code>: 可以被设置为 SPEED, CODE_SIZE,or LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成：<ul><li><code>SPEED</code> (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li><li><code>CODE_SIZE</code>: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li><li>LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">option optimize_<span class="keyword">for</span> = CODE_SIZE;</div></pre></td></tr></table></figure><ul><li><strong>cc_generic_services, java_generic_services, py_generic_services (file options)</strong>: 在C++、java、python中protocol buffer编译器是否应该基于服务定义产生抽象服务代码。由于历史遗留问题，该值默认是true。但是自2.3.0版本以来，它被认为通过提供代码生成 器插件来对RPC实现更可取，而不是依赖于“抽象”服务。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This file relies on plugins to generate service code.</span></div><div class="line"></div><div class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">option</span> java_generic_services = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">option</span> py_generic_services = <span class="literal">false</span>;</div></pre></td></tr></table></figure><ul><li><strong>message_set_wire_format (message option)</strong>: 如果该值被设置为true，该消息将使用一种不同的二进制格式来与Google内部的MessageSet的老格式相兼容。对于Google外部的用户来说，该选项将不会被用到。如下所示:</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>{</div><div class="line"></div><div class="line">  <span class="keyword">option</span> message_set_wire_format = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  extensions <span class="number">4</span> to max;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure><ul><li><strong>packed (field option)</strong>: 如果该选项在一个整型基本类型上被设置为真，则采用更紧凑的编码方式。当然使用该值并不会对数值造成任何损失。在2.3.0版本之前，解析器将会忽略那些 非期望的包装值。因此，它不可能在不破坏现有框架的兼容性上而改变压缩格式。在2.3.0之后，这种改变将是安全的，解析器能够接受上述两种格式，但是在 处理protobuf老版本程序时，还是要多留意一下。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> samples = <span class="number">4</span> [packed=<span class="literal">true</span>];</div></pre></td></tr></table></figure><ul><li><strong>deprecated (field option)</strong>: 如果该选项被设置为true，表明该字段已经被弃用了，在新代码中不建议使用。在多数语言中，这并没有实际的含义。在java中，它将会变成一个 @Deprecated注释。也许在将来，其它基于语言声明的代码在生成时也会如此使用，当使用该字段时，编译器将自动报警。如：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</div></pre></td></tr></table></figure><h3 id="自定义选项">自定义选项</h3><p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。由于options是定在 google/protobuf/descriptor.proto中的，因此你可以在该文件中进行扩展，定义自己的选项。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/descriptor.proto"</span>;</div><div class="line"></div><div class="line">extend google.protobuf.MessageOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> my_option = <span class="number">51234</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>{</div><div class="line">  <span class="keyword">option</span> (my_option) = <span class="string">"Hello world!"</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>在上述代码中，通过对MessageOptions进行扩展定义了一个新的消息级别的选项。当使用该选项时，选项的名称需要使用（）包裹起来，以表明它是一个扩展。在C++代码中可以看出my_option是以如下方式被读取的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> value = MyMessage::descriptor()-&gt;options().GetExtension(my_option);</div></pre></td></tr></table></figure><p>在Java代码中的读取方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String value = MyProtoFile.MyMessage.getDescriptor().getOptions()</div><div class="line">  .getExtension(MyProtoFile.myOption);</div></pre></td></tr></table></figure><p>在Python中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions()</div><div class="line">  .Extensions[my_proto_file_pb2.my_option]</div></pre></td></tr></table></figure><p>正如上面的读取方式，定制选项对于Python并不支持。定制选项在protocol buffer语言中可用于任何结构。下面就是一些具体的例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/descriptor.proto"</span>;</div><div class="line"></div><div class="line">extend google.protobuf.FileOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> my_file_option = <span class="number">50000</span>;</div><div class="line">}</div><div class="line">extend google.protobuf.MessageOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> my_message_option = <span class="number">50001</span>;</div><div class="line">}</div><div class="line">extend google.protobuf.FieldOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">float</span> my_field_option = <span class="number">50002</span>;</div><div class="line">}</div><div class="line">extend google.protobuf.EnumOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> my_enum_option = <span class="number">50003</span>;</div><div class="line">}</div><div class="line">extend google.protobuf.EnumValueOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">uint32</span> my_enum_value_option = <span class="number">50004</span>;</div><div class="line">}</div><div class="line">extend google.protobuf.ServiceOptions {</div><div class="line">  <span class="keyword">optional</span> MyEnum my_service_option = <span class="number">50005</span>;</div><div class="line">}</div><div class="line">extend google.protobuf.MethodOptions {</div><div class="line">  <span class="keyword">optional</span> MyMessage my_method_option = <span class="number">50006</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">option</span> (my_file_option) = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>{</div><div class="line">  <span class="keyword">option</span> (my_message_option) = <span class="number">1234</span>;</div><div class="line"></div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> foo = <span class="number">1</span> [(my_field_option) = <span class="number">4.5</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> bar = <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyEnum</span> </span>{</div><div class="line">  <span class="keyword">option</span> (my_enum_option) = <span class="literal">true</span>;</div><div class="line"><span class="constant"></span></div><div class="line">  FOO = <span class="number">1</span> [(my_enum_value_option) = <span class="number">321</span>];</div><div class="line"><span class="constant">  BAR</span> = <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">RequestType</span> </span>{}</div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">ResponseType</span> </span>{}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">service</span> <span class="title">MyService</span> </span>{</div><div class="line">  <span class="keyword">option</span> (my_service_option) = FOO;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">rpc</span> MyMethod(RequestType) <span class="keyword">returns</span>(ResponseType) {</span></div><div class="line">    // Note:  my_method_option has type MyMessage.  We can set each field</div><div class="line">    //   within it using a separate "option" line.</div><div class="line">    option (my_method_option).foo = 567;</div><div class="line">    <span class="keyword">option</span> (my_method_option).bar = <span class="string">"Some string"</span>;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure><p>注：如果要在该选项定义之外使用一个自定义的选项，必须要由包名 + 选项名来定义该选项。如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foo.proto</span></div><div class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/descriptor.proto"</span>;</div><div class="line"><span class="keyword">package</span> foo;</div><div class="line">extend google.protobuf.MessageOptions {</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> my_option = <span class="number">51234</span>;</div><div class="line">}</div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bar.proto</span></div><div class="line"><span class="keyword">import</span> <span class="string">"foo.proto"</span>;</div><div class="line"><span class="keyword">package</span> bar;</div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>{</div><div class="line">  <span class="keyword">option</span> (foo.my_option) = <span class="string">"Hello world!"</span>;</div><div class="line">}</div></pre></td></tr></table></figure><p>最后一件事情需要注意：因为自定义选项是可扩展的，它必须象其它的域或扩展一样来定义标识号。正如上述示例，[50000－99999]已经被占 用，该范围内的值已经被内部所使用，当然了你可以在内部应用中随意使用。如果你想在一些公共应用中进行自定义选项，你必须确保它是全局唯一的。可以通过<a href="mailto:protobuf-global-extension-registry@google.com" target="_blank" rel="external">protobuf-global-extension-registry@google.com</a>来获取全局唯一标识号。 只需提供你的项目名和项目网站. 通常你只需要一个扩展号。 你可以使用一个扩展号声明多个选项:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">FooOptions</span> </span>{</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> opt1 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> opt2 = <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line">extend google.protobuf.FieldOptions {</div><div class="line">  <span class="keyword">optional</span> FooOptions foo_options = <span class="number">1234</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// usage:</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>{</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span> [(foo_options).opt1 = <span class="number">123</span>, (foo_options).opt2 = <span class="string">"baz"</span>];</div><div class="line">  <span class="comment">// alternative aggregate syntax (uses TextFormat):</span></div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> b = <span class="number">2</span> [(foo_options) = { opt1: <span class="number">123</span> opt2: <span class="string">"baz"</span> }];</div><div class="line">}</div></pre></td></tr></table></figure><h2 id="生成访问类">生成访问类</h2><p>可以通过定义好的.proto文件来生成Java、Python、C++代码，需要基于.proto文件运行protocol buffer编译器protoc。运行的命令如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto</div></pre></td></tr></table></figure><ul><li><p>IMPORT_PATH声明了一个.proto文件所在的具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以 对--proto_path 写多次，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是它的简化形式。</p></li><li><p>当然也可以提供一个或多个输出路径：</p><ul><li>--cpp_out 在目标目录DST_DIR中产生C++代码，可以在 <a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference" target="_blank" rel="external">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference</a> /cpp-generated.html中查看更多。</li><li>--java_out 在目标目录DST_DIR中产生Java代码，可以在 <a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference" target="_blank" rel="external">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference</a> /java-generated.html中查看更多。</li><li>--python_out 在目标目录 DST_DIR 中产生Python代码，可以在<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers" target="_blank" rel="external">http://code.google.com/intl/zh-CN/apis/protocolbuffers</a> /docs/reference/python-generated.html中查看更多。<br>作为一种额外的约定，如果DST_DIR 是以.zip或.jar结尾的，编译器将输出结果打包成一个zip格式的归档文件。.jar将会输出一个 Java JAR声明必须的manifest文件。注：如果该输出归档文件已经存在，它将会被重写，编译器并没有做到足够的智能来为已经存在的归档文件添加新的文 件。</li></ul></li></ul><p>你必须提供一个或多个.proto文件作为输入。多个.proto文件能够一次全部声明。虽然这些文件是相对于当前目录来命名的，每个文件必须在一个IMPORT_PATH中，只有如此编译器才可以决定它的标准名称。</p><hr><p>中文翻译出处: <a href="http://www.open-open.com/home/space.php?uid=37924&amp;do=blog&amp;id=5873" target="_blank" rel="external">http://www.open-open.com/home/space.php?uid=37924&amp;do=blog&amp;id=5873</a><br>原文： <a href="https://developers.google.com/protocol-buffers/docs/proto#generating" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/proto#generating</a></p><p>转载时加入了新增加的内容</p></div><footer class="article-footer"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/protobuf/">protobuf</a></li></ul><section id="comments"><script src="https://utteranc.es/client.js" repo="smallnest/gitalk" issue-term="title" theme="github-light" crossorigin="anonymous" async></script><noscript>为正常使用评论功能请激活JavaScript</noscript></section></footer></div><nav id="article-nav"><a href="/2015/01/14/Scala-Quick-Start-for-Java-Programmers/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Scala简明教程</div></a> <a href="/2015/01/05/kafka-spark-streaming-integration-summary/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Spark Streaming 集成 Kafka 总结</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">微信公众号</h3><div class="widget"><img width="100%" src="/images/widgets/gopatterns.jpg"></div></div><div class="widget-wrap"><h3 class="widget-title">极客时间专栏</h3><div class="widget"><a href="https://time.geekbang.org/column/intro/100061801"><img width="100%" src="/images/widgets/geekbang.png"></a></div></div><div class="widget-wrap"><h3 class="widget-title">原创图书</h3><div class="widget"><a href="/ScalaCollectionsCookbook/"><img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook.jpg"> <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook_tw.png"></a></div></div><div class="widget-wrap"><h3 class="widget-title">分类</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DOTNET/">DOTNET</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">191</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">64</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">60</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理/">管理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高并发编程/">高并发编程</a><span class="category-list-count">20</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/Android/" style="font-size: 15.71px">Android</a><a href="/tags/ApacheBench/" style="font-size: 11.43px">ApacheBench</a><a href="/tags/Bower/" style="font-size: 10.00px">Bower</a><a href="/tags/C/" style="font-size: 10.00px">C#</a><a href="/tags/CDN/" style="font-size: 10.00px">CDN</a><a href="/tags/CQRS/" style="font-size: 10.00px">CQRS</a><a href="/tags/CRC/" style="font-size: 10.00px">CRC</a><a href="/tags/CSS/" style="font-size: 11.43px">CSS</a><a href="/tags/CompletableFuture/" style="font-size: 10.00px">CompletableFuture</a><a href="/tags/Comsat/" style="font-size: 10.00px">Comsat</a><a href="/tags/Curator/" style="font-size: 18.57px">Curator</a><a href="/tags/DSL/" style="font-size: 10.00px">DSL</a><a href="/tags/Disruptor/" style="font-size: 10.00px">Disruptor</a><a href="/tags/Docker/" style="font-size: 11.43px">Docker</a><a href="/tags/Ember/" style="font-size: 11.43px">Ember</a><a href="/tags/FastJson/" style="font-size: 10.00px">FastJson</a><a href="/tags/Fiber/" style="font-size: 10.00px">Fiber</a><a href="/tags/GAE/" style="font-size: 10.00px">GAE</a><a href="/tags/GC/" style="font-size: 12.86px">GC</a><a href="/tags/Gnuplot/" style="font-size: 10.00px">Gnuplot</a><a href="/tags/Go/" style="font-size: 14.29px">Go</a><a href="/tags/Gradle/" style="font-size: 10.00px">Gradle</a><a href="/tags/Grunt/" style="font-size: 10.00px">Grunt</a><a href="/tags/Gulp/" style="font-size: 10.00px">Gulp</a><a href="/tags/Hadoop/" style="font-size: 10.00px">Hadoop</a><a href="/tags/Hazelcast/" style="font-size: 10.00px">Hazelcast</a><a href="/tags/IPFS/" style="font-size: 10.00px">IPFS</a><a href="/tags/Ignite/" style="font-size: 10.00px">Ignite</a><a href="/tags/JVM/" style="font-size: 10.00px">JVM</a><a href="/tags/Java/" style="font-size: 17.14px">Java</a><a href="/tags/Kafka/" style="font-size: 20.00px">Kafka</a><a href="/tags/Lambda/" style="font-size: 14.29px">Lambda</a><a href="/tags/Linux/" style="font-size: 12.86px">Linux</a><a href="/tags/LongAdder/" style="font-size: 10.00px">LongAdder</a><a href="/tags/MathJax/" style="font-size: 10.00px">MathJax</a><a href="/tags/Maven/" style="font-size: 11.43px">Maven</a><a href="/tags/Memcached/" style="font-size: 10.00px">Memcached</a><a href="/tags/Metrics/" style="font-size: 10.00px">Metrics</a><a href="/tags/Mongo/" style="font-size: 12.86px">Mongo</a><a href="/tags/Netty/" style="font-size: 15.71px">Netty</a></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">近期文章</h3><div class="widget"><ul><li><a href="/2022/05/22/use-ebpf-to-trace-rpcx-microservices/">使用ebpf跟踪rpcx微服务</a></li><li><a href="/2022/05/06/changes-in-atomic-package/">atomic包的新变化</a></li><li><a href="/2022/04/26/Crimes-with-Go-Generics/">Go泛型的坏例子</a></li><li><a href="/2022/04/07/A-Study-of-Real-World-Data-Races-in-Golang/">Uber工程师对真实世界并发问题的研究</a></li><li><a href="/2022/03/06/most-useful-software-architecture-patterns/">最常用的架构模式</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">友情链接</h3><div class="widget"><ul><li><a href="http://stackshare.io" target="_blank">技术栈</a></li><li>&nbsp;</li><li><a href="https://toutiao.io/" target="_blank">开发者头条</a></li><li><a href="http://weekly.manong.io/issues/" target="_blank">码农周刊</a></li><li><a href="http://www.tuicool.com/mags" target="_blank">编程狂人周刊</a></li><li><a href="http://www.importnew.com/" target="_blank">importnew</a></li><li><a href="http://ifeve.com/" target="_blank">并发编程网</a></li><li>&nbsp;</li><li><a href="http://github.com" target="_blank">github</a></li><li><a href="http://stackoverflow.com/" target="_blank">stackoverflow</a></li><li><a href="http://www.javacodegeeks.com/" target="_blank">javacodegeeks</a></li><li><a href="http://www.infoq.com/" target="_blank">infoq</a></li><li><a href="http://www.dzone.com/links/index.html" target="_blank">dzone</a></li><li><a href="https://oj.leetcode.com/problems/" target="_blank">leetcode</a></li><li><a href="http://tutorials.jenkov.com" target="_blank">jenkov</a></li><li><a href="https://howtodoinjava.com" target="_blank">HowToDoInJava</a></li><li><a href="https://java-design-patterns.com/patterns/" target="_blank">java design patterns</a></li><li>&nbsp;</li><li><a href="https://medium.com/netflix-techblog" target="_blank">Netflix技术博客</a></li><li><a href="https://www.techiedelight.com" target="_blank">Techie Delight</a></li><li><a href="https://engineering.linkedin.com/blog" target="_blank">Linkedin技术博客</a></li><li><a href="https://blogs.dropbox.com/tech/" target="_blank">Dropbox技术博客</a></li><li><a href="https://code.fb.com" target="_blank">Facebook技术博客</a></li><li><a href="http://jm.taobao.org" target="_blank">淘宝中间件团队</a></li><li><a href="https://tech.meituan.com" target="_blank">美团技术博客</a></li><li><a href="http://blogs.360.cn" target="_blank">360技术博客</a></li><li><a href="https://xiaomi-info.github.io" target="_blank">小米信息部技术团队</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2022 smallnest<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></div></div></footer></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link"><i class="fa fa-home">&nbsp;</i>首页</a> <a href="/archives" class="mobile-nav-link"><i class="fa fa-folder-o">&nbsp;</i>归档</a> <a href="https://github.com/smallnest" class="mobile-nav-link"><i class="fa fa-github">&nbsp;</i>github</a> <a class="mobile-nav-link" href="#"><i class="fa fa-bars">&nbsp;</i>网站群</a> <a class="mobile-nav-link" href="/goasm">&nbsp;&nbsp;<i class="fa fa-language">&nbsp;</i>Go汇编示例</a> <a class="mobile-nav-link" href="https://gowebexamples.com">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go Web开发示例</a> <a class="mobile-nav-link" href="http://go-database-sql.org">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go 数据库开发教程</a> <a class="mobile-nav-link" href="http://rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPCX官网</a> <a class="mobile-nav-link" href="http://cn.doc.rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPC开发指南</a> <a href="/ScalaCollectionsCookbook" class="mobile-nav-link"><i class="fa fa-book">&nbsp;</i>Scala集合技术手册</a> <a href="/about" class="mobile-nav-link"><i class="fa fa-lemon-o">&nbsp;</i>关于</a></nav><script src="//cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script><script src="//cdn.bootcss.com/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script><script src="/js/script.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],processEscapes:!0,skipTags:["script","noscript","style","textarea","pre","code"]}}),MathJax.Hub.Queue(function(){var a,e=MathJax.Hub.getAllJax();for(a=0;a<e.length;a+=1)e[a].SourceElement().parentNode.className+=" has-jax"});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.6.0-beta.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div id="totop" style="position:fixed;bottom:150px;right:10px;cursor: pointer;z-index: 2000"><a title="返回顶部"><img src="/images/scrollup.png"></a></div><script src="/js/totop.js" type="text/javascript"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e085d87993250aab11f3e0c15f1c2785";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}();</script></div></body></html>