<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[转][译]Go 终极指南：编写一个 Go 工具 | 鸟窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文: https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/作者：Fatih Arslan译文：http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/译者：oopsguy.com">
<meta property="og:type" content="article">
<meta property="og:title" content="[转][译]Go 终极指南：编写一个 Go 工具">
<meta property="og:url" content="http://colobu.com/2017/12/12/The-ultimate-guide-to-writing-a-Go-tool/">
<meta property="og:site_name" content="鸟窝">
<meta property="og:description" content="原文: https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/作者：Fatih Arslan译文：http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/译者：oopsguy.com">
<meta property="og:image" content="gomodifytags.gif">
<meta property="og:image" content="gomodifytags-009.jpg">
<meta property="og:image" content="gomodifytags-014.jpg">
<meta property="og:image" content="gomodifytags-027.jpg">
<meta property="og:image" content="gomodifytags-091.jpg">
<meta property="og:image" content="gomodifytags-0721.jpg">
<meta property="og:image" content="gomodifytags-101-e1503693113141.jpg">
<meta property="og:image" content="gomodifytags-128.jpg">
<meta property="og:image" content="gomodifytags-130.jpg">
<meta property="og:image" content="gomodifytags-111.jpg">
<meta property="og:image" content="gomodifytags-118.jpg">
<meta property="og:image" content="gomodifytags-001.jpg">
<meta property="og:image" content="gomodifytags-136.jpg">
<meta property="og:image" content="gomodifytags-0013.jpg">
<meta property="og:image" content="gomodifytags-175.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转][译]Go 终极指南：编写一个 Go 工具">
<meta name="twitter:description" content="原文: https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/作者：Fatih Arslan译文：http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/译者：oopsguy.com">

  
    <link rel="alternative" href="/atom.xml" title="鸟窝" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <link href="//cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
  <link rel="stylesheet" href="//libs.cncdn.cn/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//cdn.staticfile.org/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->

  <script type="text/javascript">
	//visit my previous blog: http://old.colobu.com just like this http://colobu.com/?=123456
    var blog_url = location.href.toString();
	if (blog_url.indexOf("http://colobu.com/?p=") >= 0) {
		blog_url = blog_url.replace("colobu.com", "old.colobu.com");
		window.location.assign(blog_url);
	} else if (blog_url.indexOf("http://smallnest.gitcafe.com") >= 0) {
		blog_url = blog_url.replace("smallnest.gitcafe.com", "colobu.com");
		window.location.assign(blog_url);
	}  else if (blog_url.indexOf("http://smallnest.gitcafe.io") >= 0) {
		blog_url = blog_url.replace("smallnest.gitcafe.io", "colobu.com");
		window.location.assign(blog_url);
	}
</script>
  <style type="text/css">
    .news-essay
    {
      display: inline !important;
    }
    .hot-news
    {
      text-align: left !important;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap" class="animated bounceInLeft">
        <a href="/" id="logo">鸟窝</a>
      </h1>
      
        <h2 id="subtitle-wrap" class="animated bounceInLeft">
          <a href="/" id="subtitle">大道至简 Simplicity is the ultimate form of sophistication</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/"><i class="fa fa-home">&nbsp;</i>首页</a>
        
          <a class="main-nav-link" href="/archives"><i class="fa fa-folder-o">&nbsp;</i>归档</a>
        
          <a class="main-nav-link" href="https://github.com/smallnest"><i class="fa fa-github">&nbsp;</i>github</a>
        
          <a class="main-nav-link" href="/goasm"><i class="fa fa-language">&nbsp;</i>Go汇编示例</a>
        
          <a class="main-nav-link" href="/ScalaCollectionsCookbook"><i class="fa fa-book">&nbsp;</i>Scala集合技术手册</a>
        
          <a class="main-nav-link" href="/techreview"><i class="fa fa-newspaper-o">&nbsp;</i>技术快报</a>
        
          <a class="main-nav-link" href="/about"><i class="fa fa-lemon-o">&nbsp;</i>关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="colobu.com">
        </form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-The-ultimate-guide-to-writing-a-Go-tool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/12/The-ultimate-guide-to-writing-a-Go-tool/" class="article-date">
  <time datetime="2017-12-12T06:52:23.000Z" itemprop="datePublished">2017年12月12日</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

	
  <div class="article-author"> by Fatih Arslan</div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [转][译]Go 终极指南：编写一个 Go 工具
	  
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
	  
	  
      
        <p>原文: <a href="https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/</a><br>作者：Fatih Arslan<br>译文：<a href="http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/</a><br>译者：oopsguy.com</p>
<a id="more"></a>
<p>我之前编写过一个叫 gomodifytags 的工具，它使我的生活变得很轻松。它会根据字段名称自动填充结构体标签字段。让我来展示一下它的功能：</p>
<p><img src="gomodifytags.gif" alt="An example usage of gomodifytags used within vim-go"></p>
<p>使用这样的工具可以<strong>很容易管理</strong>结构体的多个字段。该工具还可以添加和删除标签、管理标签选项（如 omitempty）、定义转换规则（snake_case、camelCase 等）等。但该工具是怎样工作的呢？它内部使用了什么 Go 包？有很多问题需要回答。</p>
<p>这是一篇非常长的博文，其解释了如何编写这样的工具以及每个构建细节。它包含许多独特的细节、技巧和未知的 Go 知识。</p>
<p>拿起一杯咖啡☕️，让我们深入一下吧！</p>
<hr>

<p>首先，让我列出这个工具需要做的事情：</p>
<ul>
<li>它需要读取源文件、理解并能够解析 Go 文件</li>
<li>它需要找到相关的结构体</li>
<li>找到结构体后，它需要获取字段名称</li>
<li>它需要根据字段名来更新结构体标签（根据转换规则，如 _snake<em>case</em>）</li>
<li>它需要能够把这些更改更新到文件中，或者能够以可消费的方式输出更改后的结果</li>
</ul>
<p>我们首先来了解什么是 <strong>结构体（struct）标签（tag）</strong>，从这里我们可以学习到所有东西以及如何把它们组合在一起使用，在此基础上您可以构建出这样的工具。</p>
<p><img src="gomodifytags-009.jpg" alt=""></p>
<p>结构体的标签值（内容，如 <code>json: &quot;foo&quot;</code>）<strong>不是官方规范的一部分</strong>，但是 <code>reflect</code> 包定义了一个非官方规范的格式标准，这个格式同样被 <code>stdlib</code> 包（如 <code>encoding/json</code>）所使用。它通过 <code>reflect.StructTag</code> 类型定义：</p>
<p><img src="gomodifytags-014.jpg" alt=""></p>
<p>这个定义有点长，不是很容易让人理解。我们尝试分解一下它：</p>
<ul>
<li>一个结构体标签是一个字符串文字（因为它有字符串类型）</li>
<li>键（key）部分是一个<strong>无引号</strong>的字符串文字</li>
<li>值（value）部分是<strong>带引号</strong>的字符串文字</li>
<li>键和值由冒号（:)分隔。键与值且由冒号分隔组成的值称为<strong>键值对</strong></li>
<li>结构体标签可以包含多个键值对（可选）。键值对由<strong>空格分隔</strong>。</li>
<li>不是定义的部分是选项设置。像 <code>encoding/json</code> 这样的包在读取值时当作一个由逗号分隔列表。 第一个逗号后的内容都是选项部分，比如 <code>foo,omitempty,string</code>。其有一个名为 <code>foo</code> 的值和 <code>[omitempty, string]</code> 选项</li>
<li>因为结构体标签是字符串文字，所以需要使用双引号或反引号包围。因为值必须使用引号，因此我们总是使用反引号对整个标签做处理。</li>
</ul>
<p>总结一下：<br><img src="gomodifytags-027.jpg" alt="结构体标签定义有许多隐藏的细节"></p>
<p>我们已经了解了什么是结构体标签，我们可以根据需要轻松地修改它。 现在的问题是，我们如何解析它才能使我们能够轻松进行修改？幸运的是，<code>reflect.StructTag</code> 包含一个<code>方法</code>，它允许我们进行解析并返回指定键的值。以下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    tag := reflect.StructTag(<span class="string">`species:"gopher" color:"blue"`</span>)</div><div class="line">    fmt.Println(tag.Get(<span class="string">"color"</span>), tag.Get(<span class="string">"species"</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blue gopher</div></pre></td></tr></table></figure>

<p>如果键不存在，则返回一个空字符串。</p>
<p>这是非常有用，<strong>但是</strong>也有一些不足使得它并不适合我们，因为我们需要更多的灵活性：</p>
<ul>
<li>它无法检测到标签是否<strong>格式错误</strong>（如：键部分用引号包裹，值部分没有使用引号等）。</li>
<li>它无法得知选项的<strong>语义</strong>。</li>
<li>它<strong>没有办法迭代现有的标签</strong>或返回它们。我们必须要知道要修改哪些标签。如果不知道名字怎么办？</li>
<li>修改现有标签是不可能的。</li>
<li>我们<strong>不能从头开始构建新的结构体标签</strong>。</li>
</ul>
<p>为了改进这一点，我写了一个自定义的 Go 包，它解决了上面提到的所有问题，并提供了一个 API，可以轻松地改变结构体标签的各个方面。</p>
<p><img src="gomodifytags-091.jpg" alt=""></p>
<p>该包名为 <strong>structtag</strong>，可以从 github.com/fatih/structtag 获取。 这个包允许我们以简洁的方式解析和修改标签。以下是一个完整的示例，您可以复制/粘贴并自行尝试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/fatih/structtag"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    tag := <span class="string">`json:"foo,omitempty,string" xml:"foo"`</span></div><div class="line"></div><div class="line">    <span class="comment">// parse the tag</span></div><div class="line">    tags, err := structtag.Parse(<span class="typename">string</span>(tag))</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// iterate over all tags</span></div><div class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tags.Tags() {</div><div class="line">        fmt.Printf(<span class="string">"tag: %+v\n"</span>, t)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// get a single tag</span></div><div class="line">    jsonTag, err := tags.Get(<span class="string">"json"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// change existing tag</span></div><div class="line">    jsonTag.Name = <span class="string">"foo_bar"</span></div><div class="line">    jsonTag.Options = <span class="constant">nil</span></div><div class="line">    tags.Set(jsonTag)</div><div class="line"></div><div class="line">    <span class="comment">// add new tag</span></div><div class="line">    tags.Set(&structtag.Tag{</div><div class="line">        Key:     <span class="string">"hcl"</span>,</div><div class="line">        Name:    <span class="string">"foo"</span>,</div><div class="line">        Options: []<span class="typename">string</span>{<span class="string">"squash"</span>},</div><div class="line">    })</div><div class="line"></div><div class="line">    <span class="comment">// print the tags</span></div><div class="line">    fmt.Println(tags) <span class="comment">// Output: json:"foo_bar" xml:"foo" hcl:"foo,squash"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在我们了解了如何解析、修改或创建结构体标签，是时候尝试修改一个 Go 源文件了。在上面的示例中，标签已经存在，但是如何从现有的 Go 结构体中获取标签呢？</p>
<p>答案是通过 <strong>AST</strong>。AST（Abstract Syntax Tree，抽象语法树）允许我们从源代码中检索每个标识符（节点）。 下面你可以看到一个结构体类型的 AST（简化版）：</p>
<p><img src="gomodifytags-0721.jpg" alt=""></p>
<p>在这棵树中，我们可以检索和操作每个标识符、每个字符串、每个括号等。这些都由 <a href="https://golang.org/pkg/go/ast/#Node" target="_blank" rel="external">AST 节点</a>表示。例如，我们可以通过替换表示它的节点将字段名称从 <code>Foo</code> 更改为 <code>Bar</code>。 该逻辑同样适用于结构体标签。</p>
<p>要获得一个 <strong>Go AST</strong>，我们需要解析源文件并将其转换成一个 <strong>AST</strong>。实际上，这两者都是通过同一个步骤来处理的。</p>
<p>要实现这一点，我们将使用 <code>go/parser</code> 包来解析文件以获取 AST（整个文件），然后使用 <code>go/ast</code> 包来处理整个树（我们可以手动做这个工作，但这是另一篇博文的主题）。 您在下面可以看到一个完整的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"go/ast"</span></div><div class="line">    <span class="string">"go/parser"</span></div><div class="line">    <span class="string">"go/token"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    src := <span class="string">`package main</span></div><div class="line">        type Example struct {</div><div class="line">    Foo string` + <span class="string">" `json:\"foo\"` }"</span></div><div class="line"></div><div class="line">    fset := token.NewFileSet()</div><div class="line">    file, err := parser.ParseFile(fset, <span class="string">"demo"</span>, src, parser.ParseComments)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    ast.Inspect(file, <span class="keyword">func</span>(x ast.Node) <span class="typename">bool</span> {</div><div class="line">        s, ok := x.(*ast.StructType)</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">for</span> _, field := <span class="keyword">range</span> s.Fields.List {</div><div class="line">            fmt.Printf(<span class="string">"Field: %s\n"</span>, field.Names<span class="number">[0</span>].Name)</div><div class="line">            fmt.Printf(<span class="string">"Tag:   %s\n"</span>, field.Tag.Value)</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    })</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Field</span>: <span class="string">Foo</span></div><div class="line"><span class="attribute">Tag</span>: <span class="string">  `json:"foo"`</span></div></pre></td></tr></table></figure>

<p>代码执行以下操作：</p>
<ul>
<li>我们使用一个单独的结构体定义了一个 Go 包示例</li>
<li>我们使用 <code>go/parser</code> 包来解析这个字符串。<code>parser</code> 包也可以从磁盘读取文件（或整个包）。</li>
<li>在解析后，我们处理了节点（分配给变量文件）并查找由 <a href="https://golang.org/pkg/go/ast/#StructType" target="_blank" rel="external">*ast.StructType</a> 定义的 AST 节点（参考 AST 图）。通过 <code>ast.Inspect()</code> 函数完成树的处理。它会遍历所有节点，直到它收到 false 值。 这是非常方便的，因为它不需要知道每个节点。</li>
<li>我们打印了结构体的字段名称和结构体标签。</li>
</ul>
<hr>

<p>我们现在可以做两件重要的事，首先，我们知道了如何解析一个 Go 源文件并检索结构体标签（通过 <code>go/parser</code>）。其次，我们知道了如何解析 Go 结构体标签，并根据需要进行修改（通过 <code>github.com/fatih/structtag</code>）。</p>
<p>我们有了这些，现在可以通过使用这两个知识点开始构建我们的工具（命名为 gomodifytags）。该工具应按顺序执行以下操作</p>
<ul>
<li>获取配置，用于告诉我们要修改哪个结构体</li>
<li>根据配置查找和修改结构体</li>
<li>输出结果</li>
</ul>
<p>由于 gomodifytags 将主要应用于编辑器，我们将通过 CLI 标志传入配置。第二步包含多个步骤，如解析文件，找到正确的结构体，然后修改结构体（通过修改 AST）。最后，我们将结果输出，无论结果的格式是原始的 Go 源文件还是某种自定义协议（如 JSON，稍后再说）。</p>
<p>以下是简化版 gomodifytags 的主要功能：</p>
<p><img src="gomodifytags-101-e1503693113141.jpg" alt=""></p>
<p>让我们更详细地解释每一个步骤。为了简单起见，我将尝试以概括的形式来解释重要部分。 原理都一样，一旦你读完这篇博文，你将能够在没有任何指导情况下阅整个源码（指南末尾附带了所有资源）</p>
<p>让我们从第一步开始，了解如何<strong>获取配置</strong>。以下是我们的配置，包含所有必要的信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// first section - input & output</span></div><div class="line">    file     <span class="typename">string</span></div><div class="line">    modified io.Reader</div><div class="line">    output   <span class="typename">string</span></div><div class="line">    write    <span class="typename">bool</span></div><div class="line"></div><div class="line">    <span class="comment">// second section - struct selection</span></div><div class="line">    offset     <span class="typename">int</span></div><div class="line">    structName <span class="typename">string</span></div><div class="line">    line       <span class="typename">string</span></div><div class="line">    start, end <span class="typename">int</span></div><div class="line"></div><div class="line">    <span class="comment">// third section - struct modification</span></div><div class="line">    remove    []<span class="typename">string</span></div><div class="line">    add       []<span class="typename">string</span></div><div class="line">    override  <span class="typename">bool</span></div><div class="line">    transform <span class="typename">string</span></div><div class="line">    sort      <span class="typename">bool</span></div><div class="line">    clear     <span class="typename">bool</span></div><div class="line">    addOpts    []<span class="typename">string</span></div><div class="line">    removeOpts []<span class="typename">string</span></div><div class="line">    clearOpt   <span class="typename">bool</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它分为三个主要部分：</p>
<p><strong>第一部分</strong>包含有关如何读取和读取哪个文件的设置。这可以是本地文件系统的文件名，也可以直接来自 stdin（主要用在编辑器中）。 它还设置如何输出结果（go 源文件或 JSON），以及是否应该覆盖文件而不是输出到 stdout。</p>
<p><strong>第二部分</strong>定义了如何选择一个结构体及其字段。有多种方法可以做到这一点。 我们可以通过它的偏移（光标位置）、结构体名称、一行单行（仅选择字段）或一系列行来定义它。最后，我们无论如何都得到开始行/结束行。例如在下面的例子中，您可以看到，我们使用它的名字来选择结构体，然后提取开始行和结束行以选择正确的字段：<br><img src="gomodifytags-128.jpg" alt=""></p>
<p>如果是用于编辑器，则最好使用<strong>字节偏移量</strong>。例如下面你可以发现我们的光标刚好在 <code>port</code> 字段名称后面，从那里我们可以很容易地得到开始行/结束行：</p>
<p><img src="gomodifytags-130.jpg" alt=""></p>
<p>配置中的第三个部分实际上是一个映射到 <code>structtag</code> 包的一对一映射。它基本上允许我们在读取字段后将配置传给 <code>structtag</code> 包。 如你所知，<code>structtag</code> 包允许我们解析一个结构体标签并对各个部分进行修改。但它不会覆盖或更新结构体字段。</p>
<p>我们如何获得配置？我们只需使用 <code>flag</code> 包，然后为配置中的每个字段创建一个标志，然后分配它们。举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">flagFile := flag.String(<span class="string">"file"</span>, <span class="string">""</span>, <span class="string">"Filename to be parsed"</span>)</div><div class="line">cfg := &config{</div><div class="line">	file: *flagFile,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们对<strong>配置中的每个字段</strong>执行相同操作。有关完整内容，请查看 <code>gomodifytag</code> 当前 master 分支的标志定义</p>
<p>一旦我们有了配置，就可以做些基本的验证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    cfg := config{ ... }</div><div class="line"></div><div class="line">    err := cfg.validate()</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatalln(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// continue parsing</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// validate validates whether the config is valid or not</span></div><div class="line"><span class="keyword">func</span> (c *config) validate() error {</div><div class="line">    <span class="keyword">if</span> c.file == <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"no file is passed"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> c.line == <span class="string">""</span> && c.offset ==<span class="number"> 0</span> && c.structName == <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"-line, -offset or -struct is not passed"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> c.line != <span class="string">""</span> && c.offset !=<span class="number"> 0</span> ||</div><div class="line">        c.line != <span class="string">""</span> && c.structName != <span class="string">""</span> ||</div><div class="line">        c.offset !=<span class="number"> 0</span> && c.structName != <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"-line, -offset or -struct cannot be used together. pick one"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c.add == <span class="constant">nil</span> || <span class="built_in">len</span>(c.add) ==<span class="number"> 0</span>) &&</div><div class="line">        (c.addOptions == <span class="constant">nil</span> || <span class="built_in">len</span>(c.addOptions) ==<span class="number"> 0</span>) &&</div><div class="line">        !c.clear &&</div><div class="line">        !c.clearOption &&</div><div class="line">        (c.removeOptions == <span class="constant">nil</span> || <span class="built_in">len</span>(c.removeOptions) ==<span class="number"> 0</span>) &&</div><div class="line">        (c.remove == <span class="constant">nil</span> || <span class="built_in">len</span>(c.remove) ==<span class="number"> 0</span>) {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"one of "</span> +</div><div class="line">            <span class="string">"[-add-tags, -add-options, -remove-tags, -remove-options, -clear-tags, -clear-options]"</span> +</div><div class="line">            <span class="string">" should be defined"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>将验证部分放置在一个单独的函数中，以便测试。<br>现在我们了解了如何获取配置并进行验证，我们继续解析文件：<br><img src="gomodifytags-111.jpg" alt=""></p>
<p>我们已经开始讨论如何解析文件了。这里的解析是 <code>config</code> 结构体的一个方法。实际上，所有的方法都是 <code>config</code> 结构体的一部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    cfg := config{}</div><div class="line"></div><div class="line">    node, err := cfg.parse()</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// continue find struct selection ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (c *config) parse() (ast.Node, error) {</div><div class="line">    c.fset = token.NewFileSet()</div><div class="line">    <span class="keyword">var</span> contents <span class="keyword">interface</span>{}</div><div class="line">    <span class="keyword">if</span> c.modified != <span class="constant">nil</span> {</div><div class="line">        archive, err := buildutil.ParseOverlayArchive(c.modified)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"failed to parse -modified archive: %v"</span>, err)</div><div class="line">        }</div><div class="line">        fc, ok := archive[c.file]</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"couldn't find %s in archive"</span>, c.file)</div><div class="line">        }</div><div class="line">        contents = fc</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parser.ParseFile(c.fset, c.file, contents, parser.ParseComments)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>parse</strong> 函数只做一件事：解析源代码并返回一个 <code>ast.Node</code>。如果我们传入的是文件，那就非常简单了，在这种情况下，我们使用 <code>parser.ParseFile()</code> 函数。需要注意的是 <code>token.NewFileSet()</code>，它创建一个 <code>*token.FileSet</code> 类型。我们将它存储在 <code>c.fset</code> 中，同时也传给了 <code>parser.ParseFile()</code> 函数。为什么呢？</p>
<p>因为 <code>fileset</code> 用于为每个文件<strong>单独</strong>存储每个节点的位置信息。这在以后非常有用，可以用于获得 <code>ast.Node</code> 的确切位置（请注意，<code>ast.Node</code> 使用了一个压缩了的位置信息 <code>token.Pos</code>。要获取更多的信息，它需要通过 <code>token.FileSet.Position()</code> 函数来获取一个 <code>token.Position</code>，其包含更多的信息）</p>
<p>让我们继续。如果通过 <code>stdin</code> 传递源文件，那么这更加有趣。<code>config.modified</code> 字段是一个易于测试的 <code>io.Reader</code>，但实际上我们传递的是 <code>stdin</code>。我们如何检测是否需要从 <code>stdin</code> 读取呢？</p>
<p>我们询问用户是否想通过 <code>stdin</code> 传递内容。这种情况下，工具用户需要传递 <code>--modified</code> 标志（这是一个<strong>布尔</strong>标志）。如果用户了传递它，我们只需将 <code>stdin</code> 分配给 <code>c.modified</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">flagModified = flag.Bool(<span class="string">"modified"</span>, <span class="constant">false</span>,</div><div class="line">    <span class="string">"read an archive of modified files from standard input"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> *flagModified {</div><div class="line">    cfg.modified = os.Stdin</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果再次检查上面的 <code>config.parse()</code> 函数，您将发现我们检查是否已分配了 <code>.modified</code> 字段。因为 <code>stdin</code> 是一个任意的数据流，我们需要能够根据给定的协议进行解析。在这种情况下，我们假定存档包含以下内容：</p>
<ul>
<li>文件名，后接一行新行</li>
<li>文件大小（十进制），后接一行新行</li>
<li>文件的内容</li>
<li>因为我们知道文件大小，可以无障碍地解析文件内容。任何超出给定文件大小的部分，我们仅仅停止解析。</li>
</ul>
<p>此方法也被其他几个工具所使用（如 <code>guru</code>、<code>gogetdoc</code> 等），对编辑器来说非常有用。 因为这样可以让编辑器传递修改后的文件内容，而不会保存到文件系统中。因此命名为 <code>modified</code>。</p>
<p>现在我们有了自己的节点，让我们继续 “搜索结构体” 这一步：</p>
<p><img src="gomodifytags-118.jpg" alt=""></p>
<p>在 <code>main</code> 函数中，我们将使用从上一步解析得到的 <code>ast.Node</code> 调用 <code>findSelection()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// ... parse file and get ast.Node</span></div><div class="line"></div><div class="line">    start, end, err := cfg.findSelection(node)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// continue rewriting the node with the start&end position</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>cfg.findSelection()</code> 函数根据配置返回结构体的开始位置和结束位置以告知我们如何选择一个结构体。它迭代给定节点，然后返回开始位置/结束位置（如上配置部分中所述）：</p>
<p><img src="gomodifytags-001.jpg" alt="查找步骤遍历所有节点，直到找到一个 *ast.StructType，并返回该文件的开始位置和结束位置"></p>
<p>但是怎么做呢？记住有三种模式。分别是<strong>行选择</strong>、<strong>偏移量</strong>和<strong>结构体名称</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// findSelection returns the start and end position of the fields that are</span></div><div class="line"><span class="comment">// suspect to change. It depends on the line, struct or offset selection.</span></div><div class="line"><span class="keyword">func</span> (c *config) findSelection(node ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    <span class="keyword">if</span> c.line != <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> c.lineSelection(node)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> c.offset !=<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> c.offsetSelection(node)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> c.structName != <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> c.structSelection(node)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, errors.New(<span class="string">"-line, -offset or -struct is not passed"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>行选择</strong>是最简单的部分。这里我们只返回标志值本身。因此如果用户传入 <code>--line 3,50</code> 标志，函数将返回<code>(3, 50, nil)</code>。 它所做的就是拆分标志值并将其转换为整数（同样执行验证）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) lineSelection(file ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    splitted := strings.Split(c.line, <span class="string">","</span>)</div><div class="line"></div><div class="line">    start, err := strconv.Atoi(splitted<span class="number">[0</span>])</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, err</div><div class="line">    }</div><div class="line"></div><div class="line">    end := start</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(splitted) ==<span class="number"> 2</span> {</div><div class="line">        end, err = strconv.Atoi(splitted<span class="number">[1</span>])</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, err</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> start &gt; end {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, errors.New(<span class="string">"wrong range. start line cannot be larger than end line"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> start, end, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当您选中一组行并高亮它们时，编辑器将使用此模式。</p>
<p><strong>偏移量</strong>和<strong>结构体名称</strong>选择需要做更多的工作。 对于这些，我们首先需要收集所有给定的结构体，以便可以计算偏移位置或搜索结构体名称。为此，我们首先要有一个收集所有结构体的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// collectStructs collects and maps structType nodes to their positions</span></div><div class="line"><span class="keyword">func</span> collectStructs(node ast.Node) <span class="keyword">map</span>[token.Pos]*structType {</div><div class="line">    structs := <span class="built_in">make</span>(<span class="keyword">map</span>[token.Pos]*structType,<span class="number"> 0</span>)</div><div class="line">    collectStructs := <span class="keyword">func</span>(n ast.Node) <span class="typename">bool</span> {</div><div class="line">        t, ok := n.(*ast.TypeSpec)</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> t.Type == <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        structName := t.Name.Name</div><div class="line"></div><div class="line">        x, ok := t.Type.(*ast.StructType)</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        structs[x.Pos()] = &structType{</div><div class="line">            name: structName,</div><div class="line">            node: x,</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line">    ast.Inspect(node, collectStructs)</div><div class="line">    <span class="keyword">return</span> structs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们使用 <code>ast.Inspect()</code> 函数逐步遍历 AST 并搜索结构体。<br>我们首先搜索 <code>*ast.TypeSpec</code>，以便我们可以获得结构体名称。搜索 <code>*ast.StructType</code> 时给定的是结构体本身，而不是它的名字。 这就是为什么我们有一个自定义的 structType 类型，它保存了名称和结构体节点本身。这样在各个地方都很方便。 因为每个结构体的位置都是唯一的，并且在同一位置上不可能存在两个不同的结构体，因此我们使用位置作为 map 的键。</p>
<p>现在我们拥有了所有结构体，在最后可以返回一个结构体的起始位置和结束位置的偏移量和结构体名称模式。 对于偏移位置，我们检查偏移是否在给定的结构体之间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) offsetSelection(file ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    structs := collectStructs(file)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> encStruct *ast.StructType</div><div class="line">    <span class="keyword">for</span> _, st := <span class="keyword">range</span> structs {</div><div class="line">        structBegin := c.fset.Position(st.node.Pos()).Offset</div><div class="line">        structEnd := c.fset.Position(st.node.End()).Offset</div><div class="line"></div><div class="line">        <span class="keyword">if</span> structBegin &lt;= c.offset && c.offset &lt;= structEnd {</div><div class="line">            encStruct = st.node</div><div class="line">            <span class="keyword">break</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> encStruct == <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, errors.New(<span class="string">"offset is not inside a struct"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// offset mode selects all fields</span></div><div class="line">    start := c.fset.Position(encStruct.Pos()).Line</div><div class="line">    end := c.fset.Position(encStruct.End()).Line</div><div class="line"></div><div class="line">    <span class="keyword">return</span> start, end, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们使用 <code>collectStructs()</code> 来收集所有结构体，之后在这里迭代。还得记得我们存储了用于解析文件的初始 <code>token.FileSet</code> 么？</p>
<p>现在可以用它来获取每个结构体节点的偏移信息（我们将其解码为一个 <code>token.Position</code>，它为我们提供了 <code>.Offset</code> 字段）。 我们所做的只是一个简单的检查和迭代，直到我们找到结构体（这里命名为 <code>encStruct</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, st := <span class="keyword">range</span> structs {</div><div class="line">    structBegin := c.fset.Position(st.node.Pos()).Offset</div><div class="line">    structEnd := c.fset.Position(st.node.End()).Offset</div><div class="line"></div><div class="line">    <span class="keyword">if</span> structBegin &lt;= c.offset && c.offset &lt;= structEnd {</div><div class="line">        encStruct = st.node</div><div class="line">        <span class="keyword">break</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了这些信息，我们可以提取找到的结构体的开始位置和结束位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start := c.fset.Position(encStruct.Pos()).Line</div><div class="line">end := c.fset.Position(encStruct.End()).Line</div></pre></td></tr></table></figure>

<p>该逻辑同样适用于结构体名称选择。 我们所做的只是尝试<strong>检查结构体名称</strong>，直到找到与给定名称一致的结构体，而不是检查偏移量是否在给定的结构体范围内：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) structSelection(file ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, st := <span class="keyword">range</span> structs {</div><div class="line">        <span class="keyword">if</span> st.name == c.structName {</div><div class="line">            encStruct = st.node</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在我们有了开始位置和结束位置，我们终于可以进行第三步了：修改结构体字段。</p>
<p><img src="gomodifytags-136.jpg" alt=""></p>
<p>在 <code>main</code> 函数中，我们将使用从上一步解析的节点来调用 <code>cfg.rewrite()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// ... find start and end position of the struct to be modified</span></div><div class="line"></div><div class="line"></div><div class="line">    rewrittenNode, errs := cfg.rewrite(node, start, end)</div><div class="line">    <span class="keyword">if</span> errs != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">if</span> _, ok := errs.(*rewriteErrors); !ok {</div><div class="line">            <span class="keyword">return</span> errs</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// continue outputting the rewritten node</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是该工具的核心。在 <code>rewrite</code> 函数中，我们将重写开始位置和结束位置之间的所有结构体字段。 在深入了解之前，我们可以看一下该函数的大概内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// rewrite rewrites the node for structs between the start and end</span></div><div class="line"><span class="comment">// positions and returns the rewritten node</span></div><div class="line"><span class="keyword">func</span> (c *config) rewrite(node ast.Node, start, end <span class="typename">int</span>) (ast.Node, error) {</div><div class="line">    errs := &rewriteErrors{errs: <span class="built_in">make</span>([]error,<span class="number"> 0</span>)}</div><div class="line"></div><div class="line">    rewriteFunc := <span class="keyword">func</span>(n ast.Node) <span class="typename">bool</span> {</div><div class="line">        <span class="comment">// rewrite the node ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errs.errs) ==<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> node, <span class="constant">nil</span></div><div class="line">    }</div><div class="line"></div><div class="line">    ast.Inspect(node, rewriteFunc)</div><div class="line">    <span class="keyword">return</span> node, errs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>正如你所看到的，我们再次使用 <code>ast.Inspect()</code> 来逐步处理给定节点的树。我们重写 <code>rewriteFunc</code> 函数中的每个字段的标签（更多内容在后面）。</p>
<p>因为传递给 <code>ast.Inspect()</code> 的函数不会返回错误，因此我们将创建一个错误映射（使用 errs 变量定义），之后在我们逐步遍历树并处理每个单独的字段时收集错误。现在让我们来谈谈 <code>rewriteFunc</code> 的内部原理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">rewriteFunc := <span class="keyword">func</span>(n ast.Node) <span class="typename">bool</span> {</div><div class="line">    x, ok := n.(*ast.StructType)</div><div class="line">    <span class="keyword">if</span> !ok {</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> x.Fields.List {</div><div class="line">        line := c.fset.Position(f.Pos()).Line</div><div class="line"></div><div class="line">        <span class="keyword">if</span> !(start &lt;= line && line &lt;= end) {</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> f.Tag == <span class="constant">nil</span> {</div><div class="line">            f.Tag = &ast.BasicLit{}</div><div class="line">        }</div><div class="line"></div><div class="line">        fieldName := <span class="string">""</span></div><div class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f.Names) !=<span class="number"> 0</span> {</div><div class="line">            fieldName = f.Names<span class="number">[0</span>].Name</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// anonymous field</span></div><div class="line">        <span class="keyword">if</span> f.Names == <span class="constant">nil</span> {</div><div class="line">            ident, ok := f.Type.(*ast.Ident)</div><div class="line">            <span class="keyword">if</span> !ok {</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            }</div><div class="line"></div><div class="line">            fieldName = ident.Name</div><div class="line">        }</div><div class="line"></div><div class="line">        res, err := c.process(fieldName, f.Tag.Value)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            errs.Append(fmt.Errorf(<span class="string">"%s:%d:%d:%s"</span>,</div><div class="line">                c.fset.Position(f.Pos()).Filename,</div><div class="line">                c.fset.Position(f.Pos()).Line,</div><div class="line">                c.fset.Position(f.Pos()).Column,</div><div class="line">                err))</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        }</div><div class="line"></div><div class="line">        f.Tag.Value = res</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>记住，AST 树中的<strong>每一个节点</strong>都会调用这个函数。因此，我们只寻找类型为 <code>*ast.StructType</code> 的节点。一旦我们拥有，就可以开始迭代结构体字段。</p>
<p>这里我们使用 <code>start</code> 和 <code>end</code> 变量。这定义了我们是否要修改该字段。如果字段位置位于 start-end 之间，我们将继续，否则我们将忽略：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> !(start &lt;= line && line &lt;= end) {</div><div class="line">    <span class="keyword">continue</span> <span class="comment">// skip processing the field</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来，我们检查是否存在标签。如果标签字段为空（也就是 nil），则初始化标签字段。这在有助于后面的 <code>cfg.process()</code> 函数避免 <code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> f.Tag == <span class="constant">nil</span> {</div><div class="line">    f.Tag = &ast.BasicLit{}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在让我先解释一下一个<strong>有趣</strong>的地方，然后再继续。<code>gomodifytags</code> 尝试获取字段的字段名称并处理它。然而，当它是一个匿名字段呢？：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Bar <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</div><div class="line">    Bar <span class="comment">//this is an anonymous field</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这种情况下，因为没有字段名称，我们尝试从类型名称中获取<strong>字段名称</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if there is a field name use it</span></div><div class="line">fieldName := <span class="string">""</span></div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f.Names) !=<span class="number"> 0</span> {</div><div class="line">    fieldName = f.Names<span class="number">[0</span>].Name</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// if there is no field name, get it from type's name</span></div><div class="line"><span class="keyword">if</span> f.Names == <span class="constant">nil</span> {</div><div class="line">    ident, ok := f.Type.(*ast.Ident)</div><div class="line">    <span class="keyword">if</span> !ok {</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fieldName = ident.Name</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦我们获得了字段名称和标签值，就可以开始处理该字段。<code>cfg.process()</code> 函数负责处理有字段名称和标签值（如果有的话）的字段。在它返回处理结果后（在我们的例子中是 struct tag 格式），我们使用它来覆盖现有的标签值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">res, err := c.process(fieldName, f.Tag.Value)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    errs.Append(fmt.Errorf(<span class="string">"%s:%d:%d:%s"</span>,</div><div class="line">        c.fset.Position(f.Pos()).Filename,</div><div class="line">        c.fset.Position(f.Pos()).Line,</div><div class="line">        c.fset.Position(f.Pos()).Column,</div><div class="line">        err))</div><div class="line">    <span class="keyword">continue</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// rewrite the field with the new result,i.e:​​​ js​on:"foo"</span></div><div class="line">f.Tag.Value = res</div></pre></td></tr></table></figure>

<p>实际上，如果你记得 <code>structtag</code>，它返回标签实例的 <code>String()</code> 表述。在我们返回标签的最终表述之前，我们根据需要使用 <code>structtag</code> 包的各种方法修改结构体。以下是一个简单的说明图示：</p>
<p><img src="gomodifytags-0013.jpg" alt="用 structtag 包修改每个字段"></p>
<p>例如，我们要扩展 <strong>process()</strong> 中的 <strong>removeTags()</strong> 函数。此功能使用以下配置来创建要删除的标签数组（键名称）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">flagRemoveTags = flag.String(<span class="string">"remove-tags"</span>, <span class="string">""</span>, <span class="string">"Remove tags for the comma separated list of keys"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> *flagRemoveTags != <span class="string">""</span> {</div><div class="line">    cfg.remove = strings.Split(*flagRemoveTags, <span class="string">","</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在 <code>removeTags()</code> 中，我们检查是否使用了 <code>--remove-tags</code>。如果有，我们将使用 <code>structtag</code> 的 <code>tags.Delete()</code> 方法来删除标签：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) removeTags(tags *structtag.Tags) *structtag.Tags {</div><div class="line">    <span class="keyword">if</span> c.remove == <span class="constant">nil</span> || <span class="built_in">len</span>(c.remove) ==<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> tags</div><div class="line">    }</div><div class="line"></div><div class="line">    tags.Delete(c.remove...)</div><div class="line">    <span class="keyword">return</span> tags</div><div class="line">}</div><div class="line"></div><div class="line">此逻辑同样适用于 <span class="string">`cfg.Process()`</span> 中的所有函数。</div><div class="line"></div><div class="line"></div><div class="line">&lt;hr/&gt;</div><div class="line"></div><div class="line">我们已经有了一个重写的节点，让我们来讨论最后一个话题。输出和格式化结果：</div><div class="line"></div><div class="line">![](gomodifytags<span class="number">-158</span>.jpg)</div><div class="line"></div><div class="line">在 main 函数中，我们将使用上一步重写的节点来调用 <span class="string">`cfg.format()`</span> 函数：</div></pre></td></tr></table></figure>

<p>go<br>func main() {<br>    // ... rewrite the node</p>
<pre><code><span class="keyword">out</span>, err := cfg<span class="variable">.format</span>(rewrittenNode, errs)
<span class="keyword">if</span> err != <span class="literal">nil</span> {
    <span class="keyword">return</span> err
}

fmt<span class="variable">.Println</span>(<span class="keyword">out</span>)
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">您需要注意的一件事是，我们输出到 <span class="keyword">*</span><span class="keyword">*</span>stdout<span class="keyword">*</span><span class="keyword">*</span>。这佯做有许多优点。首先，您只需运行工具就能查看到结果， 它不会改变任何东西，只是为了让工具用户立即看到结果。其次，<span class="keyword">*</span><span class="keyword">*</span>stdout<span class="keyword">*</span><span class="keyword">*</span> 是可组合的，可以重定向到任何地方，甚至可以用来覆盖原来的工具。</div><div class="line"></div><div class="line">现在我们来看看 `format()` 函数：</div></pre></td></tr></table></figure>

<p>go<br>func (c *config) format(file ast.Node, rwErrs error) (string, error) {<br>    switch c.output {<br>    case &quot;source&quot;:<br>        // return Go source code<br>    case &quot;json&quot;:<br>        // return a custom JSON output<br>    default:<br>        return &quot;&quot;, fmt.Errorf(&quot;unknown output mode: %s&quot;, c.output)<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们有<span class="keyword">*</span><span class="keyword">*</span>两种输出模式<span class="keyword">*</span><span class="keyword">*</span>。</div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>第一个<span class="keyword">*</span><span class="keyword">*</span>（source）以 Go 格式打印 ast.Node。这是默认选项，如果您在命令行使用它或只想看到文件中的更改，那么这非常适合您。</div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>第二个选项<span class="keyword">*</span><span class="keyword">*</span>（json）更为先进，其专为其他环境而设计（特别是编辑器）。它根据以下结构体对输出进行编码：</div></pre></td></tr></table></figure>

<p>go<br>type output struct {<br>    Start  int      <code>json:&quot;start&quot;</code><br>    End    int      <code>json:&quot;end&quot;</code><br>    Lines  []string <code>json:&quot;lines&quot;</code><br>    Errors []string <code>json:&quot;errors,omitempty&quot;</code><br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">对工具进行输入和最终结果输出（没有任何错误）大概示意图如下：</div><div class="line"></div><div class="line">![](gomodifytags-<span class="number">0014</span>.jpg)</div><div class="line"></div><div class="line">回到 <span class="escape">`f</span>ormat()<span class="escape">` </span>函数。如之前所述，有两种模式。<span class="escape">`s</span>ource<span class="escape">` </span>模式使用 <span class="escape">`g</span>o/format<span class="escape">` </span>包将 AST 格式化为 Go 源码。该软件包也被许多其他官方工具（如 gofmt）使用。以下是 source 模式的实现方式：</div></pre></td></tr></table></figure>

<p>go<br>var buf bytes.Buffer<br>err := format.Node(&amp;buf, c.fset, file)<br>if err != nil {<br>    return &quot;&quot;, err<br>}</p>
<p>if c.write {<br>    err = ioutil.WriteFile(c.file, buf.Bytes(), 0)<br>    if err != nil {<br>        return &quot;&quot;, err<br>    }<br>}</p>
<p>return buf.String(), nil</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">格式包接受 <span class="escape">`i</span>o.Writer<span class="escape">` </span>并对其进行格式化。这就是为什么我们创建一个中间缓冲区（<span class="escape">`v</span>ar buf bytes.Buffer<span class="escape">`）</span>的原因，当用户传入一个 <span class="escape">`-</span>write<span class="escape">` </span>标志时，我们可以使用它来覆盖文件。格式化后，我们返回缓冲区的字符串表示形式，其中包含格式化后的 Go 源代码。</div><div class="line"></div><div class="line"><span class="escape">`j</span>son<span class="escape">` </span>模式更有趣。因为我们返回的是一段源代码，因此我们需要准确地呈现它原本的格式，这也意味着要把注释包含进去。问题在于，当使用 <span class="escape">`f</span>ormat.Node()<span class="escape">` </span>打印单个结构体时，如果它们是有损的，则无法打印出 Go 注释。</div><div class="line"></div><div class="line">什么是有损注释（lossy comment）？看看这个例子：</div></pre></td></tr></table></figure>

<p>go<br>type example struct {<br>    foo int </p>
<pre><code><span class="comment">// this is a lossy comment</span>

bar <span class="keyword">int</span> 
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">每个字段都是 <span class="escape">`*</span>ast.Field<span class="escape">` </span>类型。此结构体有一个 <span class="escape">`*</span>ast.Field.Comment<span class="escape">` </span>字段，其包含某字段的注释。</div><div class="line"></div><div class="line">但是，在上面的例子中，它属于谁？属于 <span class="escape">`f</span>oo<span class="escape">` </span>还是 <span class="escape">`b</span>ar<span class="escape">`？</span></div><div class="line"></div><div class="line"><span class="label">因为不可能确定，这些注释被称为有损注释。如果现在使用 `format.Node()` 函数打印上面的结构体，就会出现问题。 当你打印它时，你可能会得到（https:</span>//play.golang.org/p/peHsswF4JQ）：</div></pre></td></tr></table></figure>

<p>go<br>type example struct {<br>    foo int</p>
<pre><code>bar <span class="keyword">int</span>
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">问题在于有损注释是 `<span class="keyword">*</span>ast.File` 的<span class="keyword">*</span><span class="keyword">*</span>一部分<span class="keyword">*</span><span class="keyword">*</span>，<span class="keyword">*</span><span class="keyword">*</span>它与树分开<span class="keyword">*</span><span class="keyword">*</span>。只有打印整个文件时才能打印出来。 所以解决方法是打印整个文件，然后删除掉我们要在 JSON 输出中返回的指定行：</div></pre></td></tr></table></figure>

<p>go<br>var buf bytes.Buffer<br>err := format.Node(&amp;buf, c.fset, file)<br>if err != nil {<br>    return &quot;&quot;, err<br>}</p>
<p>var lines []string<br>scanner := bufio.NewScanner(bytes.NewBufferString(buf.String()))<br>for scanner.Scan() {<br>    lines = append(lines, scanner.Text())<br>}</p>
<p>if c.start &gt; len(lines) {<br>    return &quot;&quot;, errors.New(&quot;line selection is invalid&quot;)<br>}</p>
<p>out := &amp;output{<br>    Start: c.start,<br>    End:   c.end,<br>    Lines: lines[c.start-1 : c.end], // cut out lines<br>}</p>
<p>o, err := json.MarshalIndent(out, &quot;&quot;, &quot;  &quot;)<br>if err != nil {<br>    return &quot;&quot;, err<br>}</p>
<p>return string(o), nil<br>```</p>
<p>这样做确保我们可以打印所有注释。</p>
<hr>

<p>这就是全部内容！</p>
<p>我们成功完成了我们的工具，以下是我们在整个指南中实施的完整步骤图：</p>
<p><img src="gomodifytags-175.jpg" alt=""></p>
<p>回顾一下我们做了什么：</p>
<ul>
<li>我们通过 CLI 标志检索配置</li>
<li>我们通过 <code>go/parser</code> 包解析文件来获取一个 <code>ast.Node</code>。</li>
<li>在解析文件之后，我们搜索 获取相应的结构体来获取开始位置和结束位置，这样我们可以知道需要修改哪些字段</li>
<li>一旦我们有了开始位置和结束位置，我们再次遍历 <code>ast.Node</code>，重写开始位置和结束位置之间的每个字段（通过使用 structtag 包）</li>
<li>之后，我们将格式化重写的节点，为编辑器输出 Go 源代码或自定义的 JSON</li>
</ul>
<p>在创建此工具后，我收到了很多友好的评论，评论者们提到了这个工具如何简化他们的日常工作。正如您所看到，尽管看起来它很容易制作，但在整个指南中，我们已经针对许多特殊的情况做了特别处理。</p>
<p>gomodifytags 成功应用于以下编辑器和插件已经有几个月了，使得数以千计的开发人员提升了工作效率：</p>
<ul>
<li>vim-go</li>
<li>atom</li>
<li>vscode</li>
<li>acme</li>
</ul>
<p>如果您对原始源代码感兴趣，可以在这里找到：</p>
<p><a href="https://github.com/fatih/gomodifytags" target="_blank" rel="external">https://github.com/fatih/gomodifytags</a><br>我还在 Gophercon 2017 上发表了一个演讲，如果您感兴趣，可点击下面的 youtube 链接观看：</p>
<p><a href="https://www.youtube.com/embed/T4AIQ4RHp-c?version=3&amp;rel=1&amp;fs=1&amp;autohide=2&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;wmode=transparent" target="_blank" rel="external">https://www.youtube.com/embed/T4AIQ4RHp-c?version=3&amp;rel=1&amp;fs=1&amp;autohide=2&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;wmode=transparent</a></p>
<p>谢谢您阅读此文。希望这个指南能启发您从头创建一个新的 Go 工具。</p>

      
    </div>
    <footer class="article-footer">
	
<div class="bdsharebuttonbox"><a title="分享到新浪微博" class="bds_tsina" href="#" data-cmd="tsina"></a><a title="分享到微信" class="bds_weixin" href="#" data-cmd="weixin"></a><a title="分享到QQ空间" class="bds_qzone" href="#" data-cmd="qzone"></a><a title="分享到印象笔记" class="bds_evernotecn" href="#" data-cmd="evernotecn"></a><a title="分享到有道云笔记" class="bds_youdao" href="#" data-cmd="youdao"></a><a title="分享到百度云收藏" class="bds_bdysc" href="#" data-cmd="bdysc"></a><a class="bds_more" href="#" data-cmd="more"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
      

	  

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/13/A-Million-WebSockets-and-Go/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [转][译]百万级WebSockets和Go语言
        
      </div>
    </a>
  
  
    <a href="/2017/12/07/Three-Machine-Learning-for-Go/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用Go 机器学习库来进行数据分析 3 (平均感知器)</div>
    </a>
  
</nav>

  
</article>


<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<section id="comments">
  <div id="gitalk-container"></div>  
  <script type="text/javascript">
    var gitalkOpts = {
    id: '2017/12/12/The-ultimate-guide-to-writing-a-Go-tool/',
    owner: 'smallnest',
    repo: 'gitalk',
    title: '[转][译]Go 终极指南：编写一个 Go 工具',
    body: 'http://colobu.com/2017/12/12/The-ultimate-guide-to-writing-a-Go-tool/',
    clientID: 'bc02724130ed5b7ee275',
    clientSecret: '68cb0bae2f93a8b88b09e0eb9b08c844b06a9047',
    admin: ['smallnest'],
    distractionFreeMode: false
  };

  const gitalk = new Gitalk(gitalkOpts)
  gitalk.render('gitalk-container')
	</script>
  <noscript> 为正常使用评论功能请激活JavaScript</noscript>
</section>  


</section>
        
          <aside id="sidebar">
  
      <div class="widget-wrap">
    <h3 class="widget-title">原创图书</h3>
    <div class="widget">
      <a href="/ScalaCollectionsCookbook/">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook.jpg">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook_tw.png">
      </a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DOTNET/">DOTNET</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">92</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理/">管理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高并发编程/">高并发编程</a><span class="category-list-count">20</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 16.67px;">Android</a><a href="/tags/ApacheBench/" style="font-size: 11.67px;">ApacheBench</a><a href="/tags/Bower/" style="font-size: 10.00px;">Bower</a><a href="/tags/C/" style="font-size: 10.00px;">C#</a><a href="/tags/CDN/" style="font-size: 10.00px;">CDN</a><a href="/tags/CQRS/" style="font-size: 10.00px;">CQRS</a><a href="/tags/CRC/" style="font-size: 10.00px;">CRC</a><a href="/tags/CSS/" style="font-size: 11.67px;">CSS</a><a href="/tags/CompletableFuture/" style="font-size: 10.00px;">CompletableFuture</a><a href="/tags/Comsat/" style="font-size: 10.00px;">Comsat</a><a href="/tags/Curator/" style="font-size: 20.00px;">Curator</a><a href="/tags/DSL/" style="font-size: 10.00px;">DSL</a><a href="/tags/Disruptor/" style="font-size: 10.00px;">Disruptor</a><a href="/tags/Docker/" style="font-size: 11.67px;">Docker</a><a href="/tags/Ember/" style="font-size: 11.67px;">Ember</a><a href="/tags/FastJson/" style="font-size: 10.00px;">FastJson</a><a href="/tags/Fiber/" style="font-size: 10.00px;">Fiber</a><a href="/tags/GAE/" style="font-size: 10.00px;">GAE</a><a href="/tags/GC/" style="font-size: 13.33px;">GC</a><a href="/tags/Gnuplot/" style="font-size: 10.00px;">Gnuplot</a><a href="/tags/Go/" style="font-size: 13.33px;">Go</a><a href="/tags/Gradle/" style="font-size: 10.00px;">Gradle</a><a href="/tags/Grunt/" style="font-size: 10.00px;">Grunt</a><a href="/tags/Gulp/" style="font-size: 10.00px;">Gulp</a><a href="/tags/Hadoop/" style="font-size: 10.00px;">Hadoop</a><a href="/tags/Hazelcast/" style="font-size: 10.00px;">Hazelcast</a><a href="/tags/Ignite/" style="font-size: 10.00px;">Ignite</a><a href="/tags/JVM/" style="font-size: 10.00px;">JVM</a><a href="/tags/Java/" style="font-size: 18.33px;">Java</a><a href="/tags/Kafka/" style="font-size: 20.00px;">Kafka</a><a href="/tags/Lambda/" style="font-size: 15.00px;">Lambda</a><a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a><a href="/tags/LongAdder/" style="font-size: 10.00px;">LongAdder</a><a href="/tags/MathJax/" style="font-size: 10.00px;">MathJax</a><a href="/tags/Maven/" style="font-size: 11.67px;">Maven</a><a href="/tags/Memcached/" style="font-size: 10.00px;">Memcached</a><a href="/tags/Metrics/" style="font-size: 10.00px;">Metrics</a><a href="/tags/Mongo/" style="font-size: 13.33px;">Mongo</a><a href="/tags/Netty/" style="font-size: 16.67px;">Netty</a><a href="/tags/Nginx/" style="font-size: 10.00px;">Nginx</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/31/benchmark-2018-spring-of-popular-rpc-frameworks/">流行的rpc框架benchmark 2018新春版</a>
          </li>
        
          <li>
            <a href="/2018/01/10/use-binary-package-in-go/">使用二进制形式发布go package</a>
          </li>
        
          <li>
            <a href="/2018/01/09/xtrabackup-full-increament-backup/">[转]Xtrabackup全量备份/增量备份脚本</a>
          </li>
        
          <li>
            <a href="/2017/12/29/best-practices-for-writing-high-performance-Go-code/">[转]编写高性能的Go代码的最佳实践</a>
          </li>
        
          <li>
            <a href="/2017/12/28/top-golang-articles-of-2017/">年终盘点！2017年超有价值的Golang文章</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
			 
            <a href="http://old.colobu.com" target="_blank">以前的博客</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="http://stackshare.io" target="_blank">技术栈</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="http://weekly.manong.io/issues/" target="_blank">码农周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.tuicool.com/mags" target="_blank">编程狂人周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.importnew.com/" target="_blank">importnew</a>
			
          </li>
        
          <li>
			 
            <a href="http://ifeve.com/" target="_blank">并发编程网</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="http://github.com" target="_blank">github</a>
			
          </li>
        
          <li>
			 
            <a href="http://stackoverflow.com/" target="_blank">stackoverflow</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.javacodegeeks.com/" target="_blank">javacodegeeks</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.infoq.com/" target="_blank">infoq</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.dzone.com/links/index.html" target="_blank">dzone</a>
			
          </li>
        
          <li>
			 
            <a href="https://oj.leetcode.com/problems/" target="_blank">leetcode</a>
			
          </li>
        
          <li>
			 
            <a href="http://tutorials.jenkov.com" target="_blank">jenkov</a>
			
          </li>
        
      </ul>
    </div>
  </div>

  
      

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 smallnest<br>
	  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/smallnest" class="mobile-nav-link">github</a>
  
    <a href="/goasm" class="mobile-nav-link">Go汇编示例</a>
  
    <a href="/ScalaCollectionsCookbook" class="mobile-nav-link">Scala集合技术手册</a>
  
    <a href="/techreview" class="mobile-nav-link">技术快报</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    
<script src="//cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script>
<script src="//cdn.bootcss.com/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>


<script src="/js/script.js" type="text/javascript"></script>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.6.0-beta.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div id="totop" style="position:fixed;bottom:150px;right:10px;cursor: pointer;z-index: 2000;">
	<a title="返回顶部"><img src="/images/scrollup.png"/></a>
</div>
<script src="/js/totop.js" type="text/javascript"></script>



<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-142561-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e085d87993250aab11f3e0c15f1c2785";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </div>
</body>
</html>