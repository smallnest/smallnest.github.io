<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  
  <title>sqlx: 一个优秀的rust异步SQL库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的sqlx库，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。">
<meta property="og:type" content="article">
<meta property="og:title" content="sqlx: 一个优秀的rust异步SQL库">
<meta property="og:url" content="https://colobu.com/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/">
<meta property="og:site_name" content="鸟窝">
<meta property="og:description" content="上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的sqlx库，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sqlx: 一个优秀的rust异步SQL库">
<meta name="twitter:description" content="上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的sqlx库，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。">

  
  <link rel="alternative" href="/atom.xml" title="鸟窝" type="application/atom+xml">
  
  
  <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <link href="//cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.min.css" rel="stylesheet">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/css/jquery.fancybox.min.css"
    media="screen" type="text/css">
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" media="screen"
    type="text/css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap" class="animated bounceInLeft">
        <a href="/" id="logo">鸟窝</a>
      </h1>
      
        <!-- <h2 id="subtitle-wrap" class="animated bounceInLeft"> -->
        <h2 id="subtitle-wrap">
          <!-- <a href="/" id="subtitle">大道至简 Simplicity is the ultimate form of sophistication</a> -->
          <a href="https://item.jd.com/14283252.html" target="_blank" style="color: #e32d40;text-decoration: none;"><b>《深入理解Go并发编程》新书发售中。一书在手，并发无忧</b></a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class="fa fa-home">&nbsp;</i>首页</a>
          
          
          
            <a class="main-nav-link" href="/archives"><i class="fa fa-folder-o">&nbsp;</i>归档</a>
          
          
          
            <a class="main-nav-link" href="https://github.com/smallnest"><i class="fa fa-github">&nbsp;</i>github</a>
          
          
          
            <div class="dropdown main-nav-link"><a class="main-nav-link" href="#"><i class="fa fa-bars">&nbsp;</i>网站群</a>
              <div class="dropdown-content">
          
            
              <a href="/goasm"><i class="fa fa-language"></i>&nbsp;Go汇编示例</a>
            
                
          
            
              <a href="https://gowebexamples.com"><i class="fa fa-external-link"></i>&nbsp;Go Web开发示例</a>
            
                
          
            
              <a href="http://go-database-sql.org"><i class="fa fa-external-link"></i>&nbsp;Go 数据库开发教程</a>
            
                
          
            
              <a href="https://colobu.com/gotips/"><i class="fa fa-external-link"></i>&nbsp;Go 语言编程技巧</a>
            
                
          
            
              <hr>
            
                
          
            
              <a href="/perf-book"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust高性能编程指南</a>
            
                
          
            
              <a href="/rust100"><i class="fa fa-brands fa-rust"></i>&nbsp;100个练习题学习Rust</a>
            
                
          
            
              <a href="https://github.com/rustcc/Rust_Atomics_and_Locks"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust原子操作和锁</a>
            
                
          
            
              <a href="https://rustx-labs.github.io/effective-rust-cn/"><i class="fa fa-brands fa-rust"></i>&nbsp;高效Rust编程</a>
            
                
          
            
              <a href="https://rustwiki.org/zh-CN/book/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust程序设计语言</a>
            
                
          
            
              <a href="https://nomicon.purewhite.io/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust死灵书</a>
            
                
          
            
              <a href="https://rustwiki.org/zh-CN/reference/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust参考手册</a>
            
                
          
            
              <a href="https://zjp-cn.github.io/tlborm/translation_statement.html"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust宏小册</a>
            
                
          
            
              <a href="https://huangjj27.github.io/async-book/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust异步编程书</a>
            
                
          
            
              <a href="https://rustwiki.org/zh-CN/rust-by-example/hello.html"><i class="fa fa-brands fa-rust"></i>&nbsp;通过例子学Rust</a>
            
                
          
            
              <a href="https://rust-chinese-translation.github.io/api-guidelines/"><i class="fa fa-brands fa-rust"></i>&nbsp;Rust API 编写指南</a>
            
                
          
            
              <a href="https://google.github.io/comprehensive-rust/zh-CN/"><i class="fa fa-brands fa-rust"></i>&nbsp;全面Rust课程</a>
            
                
          
            
              <hr>
            
                
          
            
              <a href="http://rpcx.io"><i class="fa undefined"></i>&nbsp;RPCX官网</a>
            
                
          
            
              <a href="http://cn.doc.rpcx.io"><i class="fa undefined"></i>&nbsp;RPC开发指南</a>
            
                
          
          </div>
        </div>
          
          
          
            <a class="main-nav-link" href="/ScalaCollectionsCookbook"><i class="fa fa-solid fa-book">&nbsp;</i>Scala集合技术手册</a>
          
          
          
            <a class="main-nav-link" href="/about"><i class="fa fa-lemon-o">&nbsp;</i>关于</a>
          
          


      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="https://www.google.com/search" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" id="search-word" name="q" maxlength="20" class="search-form-input" placeholder="Search">
          <input type=hidden name=ie value="utf-8">
          <input type=hidden name=oe value="utf-8">
          <input type=hidden name=hl value="zh-CN">
          <input type="submit" id="search-submit" value="" class="search-form-submit">
        </form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-sqlx-an-async-pure-Rust-SQL-crate" class="article article-type-post" itemscope
  itemprop="blogPost">
  <div class="article-meta">
    <a href="/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/" class="article-date">
  <time datetime="2024-05-12T02:42:26.000Z" itemprop="datePublished">2024年05月12日</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/rust/">rust</a>
  </div>

    
  <div class="article-author"> by smallnest</div>

  </div>
  <div class="article-inner">
    
    
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      sqlx: 一个优秀的rust异步SQL库
	  
    </h1>
  

    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
      
      <script>function show_answer(btn, x) { if (btn.value === "显示答案") { btn.value = "隐藏答案" } else { btn.value = "显示答案" } var as = document.getElementById(x); if (as.style.display === "none") { as.style.display = "block" } else { as.style.display = "none" } }</script>
      <p>上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的<a href="https://github.com/launchbadge/sqlx" target="_blank" rel="external">sqlx库</a>，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。</p>
<a id="more"></a>
<h2 id="概览">概览</h2>
<p>sqlx是一个为Rust语言提供的功能齐全的数据库访问和查询构建器库。它支持多种数据库,包括PostgreSQL、MySQL、SQLite等。sqlx的设计目标是成为Rust中最直观、高效且类型安全的数据库客户端。</p>
<ul>
<li><strong>真正的异步</strong>。从头开始使用 async/await 构建，以实现最大的并发性。</li>
<li><strong>编译时检查查询</strong>（如果你需要的话）。请注意，sqlx 不是 ORM。</li>
<li><strong>与数据库无关</strong>。支持 PostgreSQL、MySQL、MariaDB、SQLite。</li>
<li><strong>纯 Rust</strong>。Postgres 和 MySQL/MariaDB 驱动程序是使用零不安全的代码以纯 Rust 编写的。</li>
<li><strong>与运行时无关</strong>。在不同的运行时（async-std/tokio/actix）和 TLS 后端（native-tls，rustls）上运行。</li>
</ul>
<blockquote>
<ul>
<li>SQLite 驱动程序使用 libsqlite3 C 库。</li>
<li>sqlx 除非启用了 sqlite 功能，否则会使用 #![forbid(unsafe_code)]。SQLite 驱动程序通过 libsqlite3-sys 直接调用 SQLite3 API，这需要使用不安全的代码。</li>
</ul>
</blockquote>
<p>另外，它还有以下特性：</p>
<ul>
<li>跨平台。作为原生的 Rust 代码，sqlx 可以在任何支持 Rust 的平台上编译。</li>
<li>内建的连接池功能，使用 <code>sqlx::Pool</code>。</li>
<li>行流式处理。数据从数据库异步读取并按需解码。</li>
<li>自动的语句准备和缓存。当使用高级查询 API（<code>sqlx::query</code>）时，语句将按连接进行准备和缓存。</li>
<li>简单的（未准备）查询执行，包括将结果获取到与高级 API 使用的相同 Row 类型。支持批量执行并返回所有语句的结果。</li>
<li>传输层安全性（TLS）在支持的平台（MySQL、MariaDB 和 PostgreSQL）上可用。</li>
<li>使用 <code>LISTEN</code> 和 <code>NOTIFY</code> 以支持 PostgreSQL 异步通知。</li>
<li>支持保存点的嵌套事务。</li>
<li>任何数据库驱动程序，允许在运行时更改数据库驱动程序。<code>AnyPool</code> 根据 URL 方案连接到指定的驱动程序。</li>
</ul>
<p>sqlx 支持编译时检查的查询。然而，它并不是通过提供一个 Rust API 或 DSL（特定领域语言）来构建查询来实现这一点的。相反，它提供了宏，这些宏接受常规的 SQL 作为输入，并确保其对于您的数据库是有效的。其工作原理是，sqlx 在编译时连接到您的开发数据库，让数据库本身验证（并返回一些有关）您的 SQL 查询的信息。这有一些可能令人惊讶的含义：</p>
<ul>
<li>由于 sqlx 不需要解析 SQL 字符串本身，因此可以使用开发数据库接受的任何语法（包括数据库扩展添加的内容）</li>
<li>由于数据库允许您检索的查询信息量不同，从查询宏获得的 SQL 验证的程度取决于数据库。</li>
</ul>
<p>它不是一个ORM库，你如果想使用ORM库，可以参考<a href="https://crates.io/crates/ormx" target="_blank" rel="external">ormx</a>和<a href="https://github.com/SeaQL/sea-orm" target="_blank" rel="external">SeaORM</a>。</p>
<h2 id="安装">安装</h2>
<p>sqlx支持多种异步运行时，你可以通过选择不同的特性来使用不同的异步运行时。目前支持的异步运行时有<code>async-std</code>, <code>tokio</code>和 <code>actix</code>(其实是tokio的别名)。还支持TLS的连接：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># Cargo.toml</div><div class="line">[dependencies]</div><div class="line"># P挑选下面的一行引入sqlx:</div><div class="line"></div><div class="line"># tokio (no TLS)</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span> ] }</div><div class="line"># tokio + native-tls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span>, <span class="string">"tls-native-tls"</span> ] }</div><div class="line"># tokio + rustls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span>, <span class="string">"tls-rustls"</span> ] }</div><div class="line"></div><div class="line"># async-std (no TLS)</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span> ] }</div><div class="line"># async-std + native-tls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span>, <span class="string">"tls-native-tls"</span> ] }</div><div class="line"># async-std + rustls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span>, <span class="string">"tls-rustls"</span> ] }</div></pre></td></tr></table></figure>

<p>如果你引入了多个异步运行时，默认首选<code>tokio</code>。</p>
<p>同时你也需要引入所需的数据库特性:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"postgres"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"mysql"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"sqlite"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"any"</span> ] }</div></pre></td></tr></table></figure>

<p>以及一些其他的关于数据类型的特性等，比如<code>chrono</code>、<code>uuid</code>、<code>time</code>、<code>bstr</code>、<code>bigdecimal</code>、<code>rust_decimal</code>、<code>ipnetwork</code>等。</p>
<p><code>derive</code>支持derive类型的宏，如<code>FromRow</code>, <code>Type</code>, <code>Encode</code>, <code>Decode</code>.</p>
<p><code>macros</code> 增加了对 query*! 宏的支持，该宏允许进行编译时检查的查询。</p>
<p>一个简单的sqlx示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span> <span class="comment">// 异步运行时</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="comment">// 使用一个数据库的连接池</span></div><div class="line">    <span class="comment">// 不同的数据库选择不同的连接池构建器</span></div><div class="line">    <span class="keyword">let</span> pool = MySqlPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .connect(<span class="string">"mysql://root:password@localhost/test"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一个简单的查询</span></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT ？"</span>)</div><div class="line">        .bind(<span class="number">150_i64</span>)</div><div class="line">        .fetch_one(&pool).await?;</div><div class="line"></div><div class="line">    assert_eq!(row.<span class="number">0</span>, <span class="number">150</span>);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="连接数据库">连接数据库</h2>
<p>sqlx支持多种不同的方式来连接数据库。最常见和推荐的是使用连接池。</p>
<h3 id="建立连接池">建立连接池</h3>
<p>连接池可以显著提高应用程序的性能和并发能力。通过重用连接,减少了建立新连接的开销。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个最大5个连接的PostgreSQL连接池。<code>PgPoolOptions</code>提供了各种配置选项。</p>
<p>比如你可以不通过dsn字符串，而是通过方法进行用户名和密码设置：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> conn = PgConnectOptions::new()</div><div class="line">    .host(<span class="string">"secret-host"</span>)</div><div class="line">    .port(<span class="number">2525</span>)</div><div class="line">    .username(<span class="string">"secret-user"</span>)</div><div class="line">    .password(<span class="string">"secret-password"</span>)</div><div class="line">    .ssl_mode(PgSslMode::Require)</div><div class="line">    .connect()</div><div class="line">    .await?;</div></pre></td></tr></table></figure>

<p>甚至可以在解析dsn字符串后再修改特定的参数，如下面的mysql示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::{Connection, ConnectOptions};</div><div class="line"><span class="keyword">use</span> sqlx::mysql::{MySqlConnectOptions, MySqlConnection, MySqlPool, MySqlSslMode};</div><div class="line"></div><div class="line"><span class="comment">// dsn string</span></div><div class="line"><span class="keyword">let</span> conn = MySqlConnection::connect(<span class="string">"mysql://root:password@localhost/db"</span>).await?;</div><div class="line"></div><div class="line"><span class="comment">// 手工构造</span></div><div class="line"><span class="keyword">let</span> conn = MySqlConnectOptions::new()</div><div class="line">    .host(<span class="string">"localhost"</span>)</div><div class="line">    .username(<span class="string">"root"</span>)</div><div class="line">    .password(<span class="string">"password"</span>)</div><div class="line">    .database(<span class="string">"db"</span>)</div><div class="line">    .connect().await?;</div><div class="line"></div><div class="line"><span class="comment">// 从dsn字符串解析Options</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> opts: MySqlConnectOptions = <span class="string">"mysql://root:password@localhost/db"</span>.parse()?;</div><div class="line"></div><div class="line"><span class="comment">// 修改参数</span></div><div class="line">opts.log_statements(log::LevelFilter::Trace);</div><div class="line"></div><div class="line"><span class="comment">// 创建连接池</span></div><div class="line"><span class="keyword">let</span> pool = MySqlPool::connect_with(&opts).await?;</div></pre></td></tr></table></figure>

<h3 id="单个连接">单个连接</h3>
<p>有时您可能只需要一个简单的单连接,而不需要连接池。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgConnOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> conn = PgConnOptions::new()</div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="查询">查询</h2>
<p>在 SQL 中，查询可以分为预编译（参数化）或未预编译（简单）的。预编译查询会缓存其查询计划，使用二进制通信模式（降低带宽和更快的解码速度），并利用参数来避免 SQL 注入。未预编译的查询是简单的，并且仅用于无法使用预编译语句的情况，例如各种数据库命令（如 <code>PRAGMA</code>、<code>SET</code> 或 <code>BEGIN</code>）。</p>
<p>sqlx 支持使用这两种类型的查询进行所有操作。在 sqlx 中，一个 <code>&amp;str</code> 被当作未预编译的查询来处理，而 <code>Query</code> 或 <code>QueryAs</code> 结构体被当作预编译的查询来处理。</p>
<blockquote>
<p>在其他语言中，预编译就是 prepared statement，未预编译就是 unprepared statement。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 底层执行</span></div><div class="line">conn.execute(<span class="string">"BEGIN"</span>).await?; <span class="comment">// 未预编译，简单查询</span></div><div class="line">conn.execute(sqlx::query(<span class="string">"DELETE FROM table"</span>)).await?; <span class="comment">// 预编译，此连接会缓存查询</span></div></pre></td></tr></table></figure>

<p>我们应该尽可能使用高级查询接口。为了使这更加容易，这些类型上有终结器（finalizers），这样就不需要使用执行器（executor）来包装它们。<br>换句话说，sqlx 提供了高级查询接口，这些接口使得与数据库的交互更加简洁和直观。这些接口被设计为可以独立工作，而不需要显式地创建一个执行器对象来执行查询。终结器（在这里可能指的是一些内部机制或方法）确保了这些高级接口在使用后可以正确地清理和关闭相关资源，从而简化了开发者的工作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqlx::query(<span class="string">"DELETE FROM table"</span>).execute(&<span class="keyword">mut</span> conn).await?;</div><div class="line">sqlx::query(<span class="string">"DELETE FROM table"</span>).execute(&pool).await?;</div></pre></td></tr></table></figure>

<p>在 sqlx 中，执行查询（execute）的终结器会返回受影响的行数（如果有的话），并丢弃所有接收到的结果。此外，还提供了 <code>fetch</code>、<code>fetch_one</code>、<code>fetch_optional</code> 和 <code>fetch_all</code> 方法来接收结果。</p>
<p><code>sqlx::query</code> 返回的 <code>Query</code> 类型, 它会从数据库中返回 <code>Row&lt;&#39;conn&gt;</code>。可以使用 <code>row.get()</code> 方法通过索引或名称访问列值。由于 <code>Row</code> 保持了对连接的不可变借用，因此一次只能存在一个 <code>Row</code>。</p>
<p><code>fetch</code> 查询的终结器返回一个类似流的类型，该类型会遍历结果集中的行。你可以通过迭代这个流来访问每一行数据。这通常用于处理查询结果集中有多行数据的情况。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 提供 `try_next`</span></div><div class="line"><span class="keyword">use</span> futures::TryStreamExt;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rows = sqlx::query(<span class="string">"SELECT * FROM users WHERE email = ?"</span>)</div><div class="line">    .bind(email)</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">let</span> Some(row) = rows.try_next().await? {</div><div class="line">    <span class="comment">// 将row映射到用户定义的领域类型</span></div><div class="line">    <span class="keyword">let</span> email: &<span class="keyword">str</span> = row.try_get(<span class="string">"email"</span>)?;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了将row映射到领域类型，可以使用以下两种模式之一：</p>
<ol>
<li>手工映射</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stream = sqlx::query(<span class="string">"SELECT * FROM users"</span>)</div><div class="line">    .map(|row: PgRow| {</div><div class="line">        <span class="comment">// 映射row到用户定义的领域类型</span></div><div class="line">    })</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>query_as</code>和<code>bind</code>方法</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(sqlx::FromRow)]</span></div><div class="line"><span class="keyword">struct</span> User { name: String, id: <span class="keyword">i64</span> }</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stream = sqlx::query_as::&lt;<span class="number">_</span>, User&gt;(<span class="string">"SELECT * FROM users WHERE email = ? OR name = ?"</span>)</div><div class="line">    .bind(user_email)</div><div class="line">    .bind(user_name)</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div></pre></td></tr></table></figure>

<p>除了使用类似流的类型来遍历结果集之外(<code>fetch</code>)，我们还可以使用 <code>fetch_one</code> 或 <code>fetch_optional</code> 来从数据库中请求一个必需的或可选的结果。</p>
<ul>
<li><code>fetch_one</code>: 这个方法会尝试从结果集中获取第一行数据。如果结果集为空（即没有数据），那么 <code>fetch_one</code> 通常会返回一个错误。这个方法适用于你期望查询结果只有一行数据的情况。</li>
<li><code>fetch_optional</code>: 这个方法类似于 <code>fetch_one</code>，但它返回一个可选的结果（<code>Option&lt;Row&gt;</code> 或 <code>Option&lt;T&gt;</code>，如果使用了类型映射）。如果结果集为空，它将返回 <code>None</code> 而不是错误。这使得它在处理可能返回零行或多行数据的查询时更加灵活，但你又只关心第一行数据（如果存在）的情况下特别有用。</li>
</ul>
<p>使用这两个方法可以帮助你更直接地处理那些只返回单个结果（或可能不返回结果）的查询</p>
<h3 id="原生查询和参数化查询">原生查询和参数化查询</h3>
<p>sqlx支持执行原生SQL查询,也支持使用绑定参数进行参数化查询,后者有助于防止SQL注入攻击。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="comment">// 原生查询</span></div><div class="line">    <span class="keyword">let</span> name: String = sqlx::query_scalar(<span class="string">"SELECT name FROM users WHERE id = 1"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 参数化查询 </span></div><div class="line">    <span class="keyword">let</span> count: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT COUNT(*) FROM users WHERE email LIKE $1"</span>)</div><div class="line">        .bind(<span class="string">"%@example.com"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="流式查询">流式查询</h3>
<p>sqlx支持流式查询，这意味着你可以在查询结果返回时立即处理它们，而不需要等待整个结果集加载完毕。这对于处理大量数据或需要实时处理数据的情况非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rows = sqlx::query(<span class="string">"SELECT id, name FROM users"</span>)</div><div class="line">        .fetch(&pool);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">let</span> Some(row) = rows.try_next().await? {</div><div class="line">        <span class="keyword">let</span> id: <span class="keyword">i32</span> = row.try_get(<span class="number">0</span>)?;</div><div class="line">        <span class="keyword">let</span> name: &<span class="keyword">str</span> = row.try_get(<span class="number">1</span>)?;</div><div class="line">        println!(<span class="string">"{} {}"</span>, id, name);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="查询结果映射到Rust数据结构">查询结果映射到Rust数据结构</h3>
<p>最常见的查询方式是将结果映射到一个Rust数据结构,比如结构体或元组结构体。sqlx会自动将数据库列映射到结构体字段。</p>
<p>比如下面这个例子是查询一个用户的信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(FromRow)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    email: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> user = sqlx::query_as::&lt;<span class="number">_</span>, User&gt;(<span class="string">"SELECT id, name, email FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(<span class="number">42</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, user);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>又比如下面这个例子查询一组书籍的信息:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(FromRow)]</span></div><div class="line"><span class="keyword">struct</span> Book {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    title: String,</div><div class="line">    author: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> books = sqlx::query_as::&lt;<span class="number">_</span>, Book&gt;(<span class="string">"SELECT * FROM books"</span>)</div><div class="line">        .fetch_all(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> books {</div><div class="line">        println!(<span class="string">"{} - {} ({})"</span>, book.id, book.title, book.author);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="执行语句">执行语句</h2>
<p>除了查询,sqlx还支持执行其他SQL语句,如INSERT、UPDATE和DELETE等。它提供了多种执行这些语句的方法,包括支持事务。</p>
<h3 id="执行语句-1">执行语句</h3>
<p>最简单的执行语句方式是使用<code>execute</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> inserted_rows = sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2)"</span>)</div><div class="line">        .bind(<span class="string">"User1"</span>).bind(<span class="string">"user1@example.com"</span>)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Inserted {} rows"</span>, inserted_rows);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面这个例子是插入一行数据到<code>users</code>表中，并打印出插入的行数。</p>
<blockquote>
<p>不要被<code>sqlx::query</code>这个名字所误导,它不仅仅用于查询,还可以用于执行其他SQL语句。</p>
</blockquote>
<p>下面是一个插入/更新/删除数据的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    email: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 插入新用户</span></div><div class="line">    <span class="keyword">let</span> user = User { id: <span class="number">0</span>, name: <span class="string">"NewUser"</span>.into(), email: <span class="string">"new@example.com"</span>.into() };</div><div class="line">    <span class="keyword">let</span> id = sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(&user.name).bind(&user.email)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    println!(<span class="string">"Inserted user with id: {}"</span>, id);</div><div class="line"></div><div class="line">    <span class="comment">// 更新用户</span></div><div class="line">    <span class="keyword">let</span> updated_rows = sqlx::query(<span class="string">"UPDATE users SET email=$1 WHERE id=$2"</span>)</div><div class="line">        .bind(<span class="string">"updated@example.com"</span>).bind(id)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Updated {} rows"</span>, updated_rows);</div><div class="line"></div><div class="line">    <span class="comment">// 删除用户</span></div><div class="line">    <span class="keyword">let</span> deleted_rows = sqlx::query(<span class="string">"DELETE FROM users WHERE id=$1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Deleted {} rows"</span>, deleted_rows);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="事务">事务</h3>
<p>sqlx支持事务,你可以使用<code>transaction</code>方法来执行一个事务。<br>要执行多个语句作为一个原子事务,您可以使用<code>begin</code>、<code>commit</code>和<code>rollback</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tx = pool.begin().await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"UPDATE users SET email=$1 WHERE id=$2"</span>)</div><div class="line">        .bind(<span class="string">"new@email.com"</span>).bind(<span class="number">42</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> tx)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"DELETE FROM users WHERE id=$1"</span>)</div><div class="line">        .bind(<span class="number">43</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> tx)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    tx.commit().await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的示例首先开始一个新事务,然后执行两个语句,最后提交事务。如果中间任何一步失败,可以调用<code>rollback</code>回滚整个事务。</p>
<p>面是一个使用sqlx中事务和回滚(rollback)的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::Error;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 开始一个事务</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> transaction = pool.begin().await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一些操作</span></div><div class="line">    sqlx::query(<span class="string">"UPDATE accounts SET balance = balance - $1 WHERE id = $2"</span>)</div><div class="line">        .bind(<span class="number">100.0</span>) <span class="comment">// 从账号中扣除100元</span></div><div class="line">        .bind(<span class="number">1</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> transaction)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"UPDATE accounts SET balance = balance + $1 WHERE id = $2"</span>)</div><div class="line">        .bind(<span class="number">100.0</span>) <span class="comment">// 将100元转账到另一个账号</span></div><div class="line">        .bind(<span class="number">2</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> transaction)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟一个错误情况</span></div><div class="line">    <span class="keyword">if</span> should_rollback() {</div><div class="line">        <span class="comment">// 回滚事务</span></div><div class="line">        transaction.rollback().await?;</div><div class="line">        println!(<span class="string">"Transaction rolled back"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 提交事务</span></div><div class="line">        transaction.commit().await?;</div><div class="line">        println!(<span class="string">"Transaction committed"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">should_rollback</span></span>() -&gt; <span class="keyword">bool</span> {</div><div class="line">    <span class="comment">// 一些条件判断，决定是否需要回滚</span></div><div class="line">    <span class="comment">// 这里为了演示，我们随机返回true或false</span></div><div class="line">    rand::thread_rng().gen_bool(<span class="number">0.5</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们首先使用<code>pool.begin()</code>开始一个新的事务。然后,我们执行两个查询,分别从一个账户扣除100元,并将这100元转账到另一个账户。<br>接下来,我们调用<code>should_rollback()</code>函数来模拟一个错误情况。如果<code>should_rollback()</code>返回true,我们就调用<code>transaction.rollback().await?</code>来回滚整个事务。否则,我们调用<code>transaction.commit().await?</code>来提交事务。</p>
<p>在真实情况下,您可能会在遇到某些异常或错误时触发回滚,例如:</p>
<ul>
<li>违反了某些业务规则或数据完整性约束</li>
<li>发生了意外的异常或错误</li>
<li>用户取消或中断了操作</li>
<li>出于某些原因,整个事务需要被回滚</li>
</ul>
<p>通过使用事务和回滚,您可以确保数据库中的更改要么全部成功,要么完全回滚,从而保持数据的一致性和完整性。这对于处理敏感操作或需要多个步骤的复杂操作非常重要。</p>
<h2 id="连接池和并发">连接池和并发</h2>
<p>sqlx内置了连接池支持,这使得它天生就支持高效的并发查询。通过连接池,可以避免为每个查询创建新连接的开销。</p>
<h3 id="连接池管理">连接池管理</h3>
<p>sqlx中的连接池由<code>PgPool</code>之类的类型表示。您可以直接创建一个连接池实例,也可以使用<code>PgPoolOptions</code>来定制配置:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">    .max_connections(<span class="number">10</span>)</div><div class="line">    .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">    .await?;</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个最大连接数为10的PostgreSQL连接池。<code>PgPoolOptions</code>提供了各种配置选项,如最大连接数、最小连接数、连接超时等。</p>
<h3 id="并发查询">并发查询</h3>
<p>由于sqlx内置了连接池,因此并发查询变得非常简单。你只需要在多个异步任务中并行执行查询即可:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> std::time::Instant;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line">    <span class="keyword">let</span> tasks = (<span class="number">0</span>..<span class="number">10</span>)</div><div class="line">        .map(|<span class="number">_</span>| {</div><div class="line">            <span class="keyword">let</span> pool = pool.clone();</div><div class="line">            tokio::spawn(async move { <span class="comment">// 并发</span></div><div class="line">                <span class="keyword">let</span> now = Instant::now();</div><div class="line">                <span class="keyword">let</span> <span class="number">_</span> = sqlx::query(<span class="string">"SELECT pg_sleep(1)"</span>).execute(&pool).await;</div><div class="line">                println!(<span class="string">"Task completed in {:?}"</span>, now.elapsed());</div><div class="line">            })</div><div class="line">        })</div><div class="line">        .collect::&lt;Vec&lt;<span class="number">_</span>&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks {</div><div class="line">        task.await?;</div><div class="line">    }</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个包含10个任务的并发查询。每个任务都会执行一个简单的查询,然后打印出执行时间。通过并发查询,您可以同时执行多个查询,从而提高查询效率。</p>
<p>下面是一个更实际的示例,模拟了并发处理多个Web请求的场景:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgRow};</div><div class="line"><span class="keyword">use</span> std::io;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> requests = vec![</div><div class="line">        <span class="string">"SELECT * FROM users WHERE id = $1"</span>,</div><div class="line">        <span class="string">"SELECT * FROM products WHERE category = $1"</span>,</div><div class="line">        <span class="string">"SELECT * FROM orders WHERE user_id = $1"</span>,</div><div class="line">    ];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> request <span class="keyword">in</span> requests {</div><div class="line">        <span class="keyword">let</span> rows = sqlx::query(request)</div><div class="line">            .bind(<span class="number">42</span>)</div><div class="line">            .fetch_all(&pool)</div><div class="line">            .await?;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows {</div><div class="line">            print_row(row);</div><div class="line">        }</div><div class="line"></div><div class="line">        println!();</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_row</span></span>(row: PgRow) {</div><div class="line">    <span class="keyword">let</span> cols = row.columns();</div><div class="line">    <span class="keyword">let</span> values: Vec&lt;&<span class="keyword">str</span>&gt; = row.get_refs(cols).into_iter().map(|v| v.unwrap()).collect();</div><div class="line">    println!(<span class="string">"{}"</span>, values.join(<span class="string">", "</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们模拟了处理多个Web请求的场景。我们定义了一个包含多个查询的请求列表,然后并发执行这些查询。每个查询都会返回一组行数据,我们将这些行数据打印出来。通过并发查询,我们可以同时处理多个请求,从而提高系统的性能和效率。</p>
<h2 id="JSON支持">JSON支持</h2>
<p>现代数据库广泛支持 JSON 数据类型,sqlx也为此提供了非常好的支持。您可以方便地查询JSON类型以及将查询结果映射为 JSON。</p>
<h3 id="查询_JSON_类型">查询 JSON 类型</h3>
<p>在数据库中,JSON 类型通常被存储为文本。sqlx允许你直接查询和处理 JSON 数据:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> json_data: serde_json::Value = sqlx::query(r#<span class="string">"</span></div><div class="line">        SELECT '[{"id<span class="string">": 1, "</span>name<span class="string">": "</span>Product <span class="number">1</span><span class="string">"}, {"</span>id<span class="string">": 2, "</span>name<span class="string">": "</span>Product <span class="number">2</span><span class="string">"}]'::json</span></div><div class="line">    "#)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, json_data);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子查询了一个JSON数组,并将其直接映射为 <code>serde_json::Value</code>。</p>
<h3 id="将查询结果映射为JSON">将查询结果映射为JSON</h3>
<p>您还可以将常规的查询结果映射为JSON格式。这对于构建API或与前端交互非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> serde::{Serialize, Deserialize};</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Deserialize, Serialize)]</span></div><div class="line"><span class="keyword">struct</span> Product {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    price: <span class="keyword">f64</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> products: Vec&lt;Product&gt; = sqlx::query_as(</div><div class="line">        <span class="string">"SELECT id, name, price FROM products"</span></div><div class="line">    )</div><div class="line">    .fetch_all(&pool)</div><div class="line">    .await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> json = serde_json::to_string(&products)?;</div><div class="line">    println!(<span class="string">"{}"</span>, json);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子查询了产品列表,并使用<code>serde_json</code>将其序列化为JSON格式。</p>
<h3 id="使用_PostgreSQL_的_JSON_类型">使用 PostgreSQL 的 JSON 类型</h3>
<p>这是一个更全面的示例,展示了如何在 PostgreSQL 中使用 JSON 类型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> serde::{Deserialize, Serialize};</div><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::types::JsonValue;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Serialize, Deserialize)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    profile: JsonValue,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 插入用户及其JSON配置文件</span></div><div class="line">    <span class="keyword">let</span> profile = serde_json::json!({</div><div class="line">        <span class="string">"bio"</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">        <span class="string">"interests"</span>: [<span class="string">"coding"</span>, <span class="string">"reading"</span>]</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> user = User {</div><div class="line">        id: <span class="number">0</span>,</div><div class="line">        name: <span class="string">"NewUser"</span>.into(),</div><div class="line">        profile: profile.into(),</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> id = sqlx::query(<span class="string">"INSERT INTO users (name, profile) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(&user.name)</div><div class="line">        .bind(&user.profile)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 查询并打印用户及其配置文件</span></div><div class="line">    <span class="keyword">let</span> user: User = sqlx::query_as(<span class="string">"SELECT id, name, profile FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, user);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们首先使用<code>serde_json</code>创建了一个JSON 值,作为用户配置文件。然后,我们将这个JSON 值 插入到数据库中。最后,我们查询用户并将配置文件作为 <code>JsonValue</code> 类型获取。</p>
<h2 id="通知和监听">通知和监听</h2>
<p>sqlx提供了在数据库中监听通知(<code>NOTIFY/LISTEN</code>)的功能,这使得构建基于事件的、实时应用程序成为可能。</p>
<p><strong>数据库通知</strong><br>数据库通知是一种机制,允许应用程序在数据库中发生某些事件时接收通知。这种功能在构建基于事件的系统(如聊天应用程序或实时仪表板)时非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 在数据库中触发通知</div><div class="line">NOTIFY channel_name, 'hello';</div></pre></td></tr></table></figure>

<p><strong>使用监听器</strong><br>sqlx通过<code>DatabaseNotification</code>结构体来表示接收到的通知。您可以在应用程序中设置一个监听器,以接收并处理这些通知。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgListener;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> listener = PgListener::bind(<span class="string">"postgresql://localhost/"</span>).await?;</div><div class="line">    listener.listen(<span class="string">"channel_name"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> notification = listener.recv().await?;</div><div class="line">        println!(</div><div class="line">            <span class="string">"Received notification: {} ({})"</span>,</div><div class="line">            notification.payload, notification.payload_pretty(),</div><div class="line">        );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的示例创建了一个<code>PostgreSQL</code>监听器,并开始监听名为<code>channel_name</code>的通道。当接收到通知时,它会打印出通知的有效负载。</p>
<p>这是一个更完整的示例,展示了如何在PostgreSQL中设置通知并在应用程序中监听它们:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgListener};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line">    <span class="keyword">let</span> listener = PgListener::bind(<span class="string">"postgresql://localhost/"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个通知通道</span></div><div class="line">    sqlx::query(<span class="string">"LISTEN channel_name"</span>).execute(&pool).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 在另一个连接上触发通知</span></div><div class="line">    sqlx::query(<span class="string">"NOTIFY channel_name, 'hello'"</span>).execute(&pool).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 等待并处理通知</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Some(notification) = listener.recv().await? {</div><div class="line">        println!(<span class="string">"Received notification: {}"</span>, notification.payload);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们首先创建了一个PostgreSQL监听器,并在数据库中设置了一个名为<code>channel_name</code>的通知通道。然后,我们在另一个连接上触发了一个通知。最后,监听器接收到通知并打印出了它的有效负载。</p>
<h2 id="测试">测试</h2>
<p>编写测试对于任何健壮的软件系统都是必不可少的,sqlx也不例外。幸运的是,sqlx提供了多种方式来测试与数据库交互的代码。</p>
<h3 id="测试连接">测试连接</h3>
<p>最基本的测试是确保您的应用程序能够成功连接到数据库。您可以使用sqlx提供的<code>try_connect</code>函数进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_connection</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::try_connect(<span class="string">"postgres://postgres:@localhost"</span>).await.unwrap();</div><div class="line">    <span class="comment">// 执行一些操作来测试连接...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="测试查询">测试查询</h3>
<p>您还可以测试查询,以确保它们能够正确地执行并返回预期的结果。您可以使用<code>query</code>和<code>query_as</code>函数来测试查询:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_query</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await.unwrap();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT 1"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    assert_eq!(row.<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用内存数据库">使用内存数据库</h3>
<p>sqlx支持使用内存数据库进行测试,例如SQLite内存数据库。这种方式快速、轻量,非常适合单元测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_query</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = sqlx::SqlitePool::connect(<span class="string">":memory:"</span>).await.unwrap();</div><div class="line">    <span class="comment">// 执行测试...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于更全面的集成测试,您可以在测试用例中创建一个临时的测试数据库,执行所需的操作,然后在测试结束时清理该数据库。这种方式更接近真实的生产环境。</p>
<h3 id="使用mock数据库">使用mock数据库</h3>
<p>如<code>msql-srv</code>、<code>opensrv-clickhouse</code>、<code>opensrv-mysql</code>、</p>
<p>下面是一个使用集成测试数据库进行测试的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgRow};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_user_operations</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = create_test_pool().await;</div><div class="line"></div><div class="line">    <span class="comment">// 准备测试数据</span></div><div class="line">    sqlx::query(<span class="string">"CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT, email TEXT)"</span>)</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 插入新用户</span></div><div class="line">    <span class="keyword">let</span> name = <span class="string">"Test User"</span>.to_owned();</div><div class="line">    <span class="keyword">let</span> email = <span class="string">"test@example.com"</span>.to_owned();</div><div class="line">    <span class="keyword">let</span> id = insert_user(&pool, &name, &email).await;</div><div class="line"></div><div class="line">    <span class="comment">// 查询并验证用户数据</span></div><div class="line">    <span class="keyword">let</span> row: PgRow = sqlx::query_as(<span class="string">"SELECT id, name, email FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    assert_eq!(row.get::&lt;<span class="keyword">i32</span>, <span class="number">_</span>&gt;(<span class="number">0</span>), id);</div><div class="line">    assert_eq!(row.get::&lt;String, <span class="number">_</span>&gt;(<span class="number">1</span>), name);</div><div class="line">    assert_eq!(row.get::&lt;String, <span class="number">_</span>&gt;(<span class="number">2</span>), email);</div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">insert_user</span></span>(pool: &PgPool, name: &<span class="keyword">str</span>, email: &<span class="keyword">str</span>) -&gt; <span class="keyword">i32</span> {</div><div class="line">    sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(name)</div><div class="line">        .bind(email)</div><div class="line">        .fetch_one(pool)</div><div class="line">        .await</div><div class="line">        .unwrap()</div><div class="line">        .get(<span class="number">0</span>)</div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">create_test_pool</span></span>() -&gt; PgPool {</div><div class="line">    <span class="keyword">let</span> db_name = <span class="string">"test_database"</span>;</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(&format!(<span class="string">"postgres://postgres:@localhost/{}"</span>, db_name))</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 清理并重新创建测试数据库</span></div><div class="line">    sqlx::query(&format!(<span class="string">"DROP DATABASE IF EXISTS {}"</span>, db_name))</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line">    sqlx::query(&format!(<span class="string">"CREATE DATABASE {}"</span>, db_name))</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    pool</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们首先创建了一个专用的测试数据库。然后我们在这个数据库中创建了一个users表,并进行了插入、查询等操作,最后验证了查询结果。</p>
<h2 id="高级主题">高级主题</h2>
<p>除了基础功能外,sqlx还提供了一些高级功能,如自定义类型映射、编译时检查和性能分析等,可以进一步提高您的生产力和应用程序的性能。</p>
<h3 id="自定义类型映射">自定义类型映射</h3>
<p>sqlx允许您定义自定义的数据类型映射规则,将数据库中的数据类型映射到Rust中的类型。这对于处理一些特殊的数据类型或实现自定义的逻辑非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::types::Type;</div><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgTypeInfo, PgValueRef};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyType(String);</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Type&lt;PgTypeInfo&gt; <span class="keyword">for</span> MyType {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">type_info</span></span>() -&gt; PgTypeInfo {</div><div class="line">        PgTypeInfo::with_name(<span class="string">"mytype"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable_name</span></span>() -&gt; String {</div><div class="line">        <span class="string">"MyType"</span>.into()</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span>&lt;'r&gt; PgValueRef&lt;'r&gt; <span class="keyword">for</span> MyType {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_pg_value</span></span>(value: Option&lt;&'r [<span class="keyword">u8</span>]&gt;) -&gt; Option&lt;MyType&gt; {</div><div class="line">        value.map(|bytes| MyType(String::from_utf8_lossy(bytes).into_owned()))</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_pg_value</span></span>(&<span class="keyword">self</span>) -&gt; Option&lt;Vec&lt;<span class="keyword">u8</span>&gt;&gt; {</div><div class="line">        Some(<span class="keyword">self</span>.<span class="number">0</span>.as_bytes().to_vec())</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们定义了一个名为<code>MyType</code>的自定义数据类型,并实现了<code>Type</code>和<code>PgValueRef</code> trait。这样,我们就可以将数据库中的<code>mytype</code>类型映射到Rust中的<code>MyType</code>类型。</p>
<h3 id="编译时检查">编译时检查</h3>
<p>sqlx提供了一些宏和编译时检查功能,可以在编译时捕获一些错误,而不是在运行时才发现。这有助于提高代码质量和安全性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::query;</div><div class="line"></div><div class="line"><span class="preprocessor">#[rustfmt::skip]</span></div><div class="line"><span class="keyword">let</span> query = query!(</div><div class="line">    <span class="string">"</span></div><div class="line">    SELECT id, name, email</div><div class="line">    FROM users</div><div class="line">    WHERE id = ?</div><div class="line">    ",</div><div class="line">    <span class="number">42</span></div><div class="line">);</div></pre></td></tr></table></figure>

<p>上面的<code>query!</code>宏可以在编译时检查SQL语句的语法错误,并验证绑定参数的数量和类型。这样可以避免在运行时才发现这些问题。</p>
<p>类似的宏还有<code>query_as!</code>、<code>query_scalar!</code>、<code>query_file!</code>、<code>query_file!</code>、<code>query_file_scalar!</code>以及它们的变种<code>query_xxx_unchecked!</code>。</p>
<h3 id="执行时间">执行时间</h3>
<p>你可以通过计时来分析查询的性能,并根据结果进行优化。sqlx提供了一些工具来帮助您分析查询的性能,如<code>log_statements</code>、<code>log_slow_statements</code>等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::query;</div><div class="line"><span class="keyword">use</span> sqlx::postgres::PgQueryAs;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> query = query_as!(</div><div class="line">        User,</div><div class="line">        r#<span class="string">"</span></div><div class="line">        SELECT id, name, email</div><div class="line">        FROM users</div><div class="line">        WHERE id = $1</div><div class="line">        "#</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> time = std::time::Instant::now();</div><div class="line">        <span class="keyword">let</span> <span class="number">_u</span>sers: Vec&lt;User&gt; = query.bind(<span class="number">42</span>).fetch_all(&pool).await?;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> elapsed = time.elapsed();</div><div class="line">        println!(<span class="string">"Query attempt {attempt} took: {elapsed:?}"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="打印日志">打印日志</h3>
<p><code>ConnectOptions</code>提供了两个设置日志的方法：</p>
<ul>
<li>log_statements: 使用指定的级别打印执行语句</li>
<li>log_slow_statements: 使用指定的级别打印执行时间超过指定阈值的SQL语句。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .log_statements(log::LevelFilter::Debug) <span class="comment">// 记录所有SQL语句</span></div><div class="line">        .log_slow_statements(log::LevelFilter::Warn, std::time::Duration::from_millis(<span class="number">100</span>)) <span class="comment">// 记录执行时间超过100ms的慢查询</span></div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一些查询</span></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT 42"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"Result: {}"</span>, row.<span class="number">0</span>);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最佳实践和故障排除">最佳实践和故障排除</h2>
<p>再啰嗦几句。</p>
<p>在使用sqlx时,遵循一些最佳实践可以帮助您编写更加安全、高效和可维护的代码。此外,掌握一些常见错误和故障排除技巧也很有帮助。</p>
<h3 id="sqlx最佳实践">sqlx最佳实践</h3>
<ul>
<li>使用参数化查询: 始终使用带参数的查询,而不是字符串插值。这可以防止SQL注入攻击。</li>
<li>监控连接池指标: 监控连接池的指标,如活跃连接数、获取连接等待时间等,以确保连接池配置正确。</li>
<li>避免ORM: sqlx是一个查询构建器,而不是完整的对象关系映射(ORM)库。尽量避免在sqlx中复制ORM功能。</li>
<li>使用流式查询: 对于大型查询结果集,使用流式查询可以避免一次性加载所有数据到内存中。</li>
<li>利用编译时检查: 使用sqlx提供的query!和query_as!宏,可以在编译时捕获SQL语法错误和类型不匹配等问题。</li>
<li>测试覆盖: 为您的数据库交互代码编写单元测试和集成测试,以确保正确性和稳定性。</li>
</ul>
<h3 id="常见错误和故障排除">常见错误和故障排除</h3>
<ul>
<li>连接池耗尽: 如果出现&quot;连接池耗尽&quot;错误,可能是因为并发请求过多或连接池配置不当导致的。检查连接池指标并适当调整<code>max_connections</code>。</li>
<li>死锁: 在事务中执行多个查询时,可能会遇到死锁情况。确保正确使用事务,并实现重试逻辑。</li>
<li>类型不匹配: 如果遇到&quot;无法将PostgreSQL类型映射到Rust类型&quot;之类的错误,检查您的结构体字段类型是否与数据库列类型匹配。</li>
<li>SQL语法错误: 如果出现SQL语法错误,首先检查您是否使用了参数化查询。如果使用了query!宏,也可能是宏解析出现了问题。</li>
<li>查询性能差: 如果查询性能较差,可以使用sqlx提供的查询追踪功能分析查询执行情况,并优化慢查询。如果频繁创建连接，检查连接池配置是否合理，比如<code>min_connections</code>是否过小</li>
</ul>
<h3 id="生产就绪建议">生产就绪建议</h3>
<ul>
<li>启用日志记录: 在生产环境中合理启用sqlx的日志记录,以便更好地调试和监控应用程序。</li>
<li>监控指标: 监控数据库和连接池指标,如查询执行时间、错误率、连接池利用率等。</li>
<li>进行负载测试: 在部署之前,对您的应用程序进行全面的负载测试,以确保其能够在生产环境中良好运行。</li>
<li>实施安全最佳实践: 遵循安全最佳实践,如使用参数化查询、限制数据库权限、加密敏感数据等。</li>
<li>准备故障转移计划: 制定数据库故障转移计划,以确保应用程序在数据库出现故障时能够正常运行。</li>
<li>持续集成和交付: 将sqlx集成测试纳入您的持续集成和交付流程,以确保代码质量。</li>
</ul>
<h2 id="sqlx生态">sqlx生态</h2>
<p>有一些其他数据库的扩展和支持，比如<code>sqlx-rxqlite</code>、<code>sqlx-clickhouse-ext</code>。</p>
<p><code>sqlx-crud</code>提供常见的数据库操作的CRUD操作的derive宏:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"><span class="keyword">use</span> sqlx_crud::SqlxCrud;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug, FromRow, SqlxCrud)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    user_id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> Some(user) = User::by_id(&pool, <span class="number">42</span>) {</div><div class="line">    println!(<span class="string">"Found user user_id=42: {:?}"</span>, user);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sqlx-error</code>提供了对<code>sqlx::Error</code>的包装。</p>
<p>当然还有一些其他的库，不过当前关注度还不是很高。</p>

      
    </div>
    <footer class="article-footer">
      

      
      <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script> -->
      <section id="comments">
        <script src="https://utteranc.es/client.js"
                repo="smallnest/gitalk"
                issue-term="title"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
        <!-- <div id="gitalk-container"></div>
        <script type="text/javascript">
          var gitalkOpts = {
            id: '2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/',
            owner: 'smallnest',
            repo: 'gitalk',
            title: 'sqlx: 一个优秀的rust异步SQL库',
            body: 'https://colobu.com/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/',
            clientID: 'bc02724130ed5b7ee275',
            clientSecret: '68cb0bae2f93a8b88b09e0eb9b08c844b06a9047',
            admin: ['smallnest'],
            distractionFreeMode: false
          };

          const gitalk = new Gitalk(gitalkOpts)
          gitalk.render('gitalk-container')
        </script> -->
        <noscript> 为正常使用评论功能请激活JavaScript</noscript>
      </section>

      

    </footer>
  </div>
  
  
<nav id="article-nav">
  
    <a href="/2024/05/19/let-Rob-Pike-write-a-Red-Black-tree/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          让 Rob Pike 或者字节跳动的同学实现一个红黑树
        
      </div>
    </a>
  
  
    <a href="/2024/05/10/sqlx-a-brief-introduction/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">sqlx: 扩展标准sql库</div>
    </a>
  
</nav>

  
</article></section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title">访问者来源</h3>
  <div class="widget">
    <script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=Hf4EJSi2XvL6TMcuFSH51Qn6nf5nZ8qnjVBnWCQ4FGc"></script>
  </div>
</div>

<div class="widget-wrap">
  <h3 class="widget-title">微信公众号</h3>
  <div class="widget">
    <img width="100%" src="/images/widgets/gopatterns.jpg">
  </div>
</div>

<div class="widget-wrap">
  <h3 class="widget-title">极客时间专栏</h3>
  <div class="widget">
    <a href="https://time.geekbang.org/column/intro/100061801">
      <img width="100%" src="/images/widgets/geekbang.png">
    </a>
  </div>
</div>

<div class="widget-wrap">
    <h3 class="widget-title">出版图书</h3>
    <div class="widget">
      <a href="https://cpgo.colobu.com/">
        <img width="100%" src="/cpgolang/cpgo.png">
      </a>
    </div>
    <div class="widget">
      <a href="https://item.jd.com/14347716.html">
        <img width="100%" src="/100gomistakes/cover.png">
      </a>
    </div>
    <div class="widget">
      <a href="/ScalaCollectionsCookbook/">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook.jpg">
        <img width="100%" src="/ScalaCollectionsCookbook/scala_collections_cookbook_tw.png">
      </a>
    </div>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DOTNET/">DOTNET</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">283</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">64</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/rust/">rust</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">60</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理/">管理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高并发编程/">高并发编程</a><span class="category-list-count">20</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 15.71px;">Android</a><a href="/tags/ApacheBench/" style="font-size: 11.43px;">ApacheBench</a><a href="/tags/Bower/" style="font-size: 10.00px;">Bower</a><a href="/tags/C/" style="font-size: 10.00px;">C#</a><a href="/tags/CDN/" style="font-size: 10.00px;">CDN</a><a href="/tags/CQRS/" style="font-size: 10.00px;">CQRS</a><a href="/tags/CRC/" style="font-size: 10.00px;">CRC</a><a href="/tags/CSS/" style="font-size: 11.43px;">CSS</a><a href="/tags/CompletableFuture/" style="font-size: 10.00px;">CompletableFuture</a><a href="/tags/Comsat/" style="font-size: 10.00px;">Comsat</a><a href="/tags/Curator/" style="font-size: 18.57px;">Curator</a><a href="/tags/DSL/" style="font-size: 10.00px;">DSL</a><a href="/tags/Disruptor/" style="font-size: 10.00px;">Disruptor</a><a href="/tags/Docker/" style="font-size: 11.43px;">Docker</a><a href="/tags/Ember/" style="font-size: 11.43px;">Ember</a><a href="/tags/FastJson/" style="font-size: 10.00px;">FastJson</a><a href="/tags/Fiber/" style="font-size: 10.00px;">Fiber</a><a href="/tags/GAE/" style="font-size: 10.00px;">GAE</a><a href="/tags/GC/" style="font-size: 12.86px;">GC</a><a href="/tags/Gnuplot/" style="font-size: 10.00px;">Gnuplot</a><a href="/tags/Go/" style="font-size: 14.29px;">Go</a><a href="/tags/Gradle/" style="font-size: 10.00px;">Gradle</a><a href="/tags/Grunt/" style="font-size: 10.00px;">Grunt</a><a href="/tags/Gulp/" style="font-size: 10.00px;">Gulp</a><a href="/tags/Hadoop/" style="font-size: 10.00px;">Hadoop</a><a href="/tags/Hazelcast/" style="font-size: 10.00px;">Hazelcast</a><a href="/tags/IPFS/" style="font-size: 10.00px;">IPFS</a><a href="/tags/Ignite/" style="font-size: 10.00px;">Ignite</a><a href="/tags/JVM/" style="font-size: 10.00px;">JVM</a><a href="/tags/Java/" style="font-size: 17.14px;">Java</a><a href="/tags/Kafka/" style="font-size: 20.00px;">Kafka</a><a href="/tags/Lambda/" style="font-size: 14.29px;">Lambda</a><a href="/tags/Linux/" style="font-size: 12.86px;">Linux</a><a href="/tags/LongAdder/" style="font-size: 10.00px;">LongAdder</a><a href="/tags/MathJax/" style="font-size: 10.00px;">MathJax</a><a href="/tags/Maven/" style="font-size: 11.43px;">Maven</a><a href="/tags/Memcached/" style="font-size: 10.00px;">Memcached</a><a href="/tags/Metrics/" style="font-size: 10.00px;">Metrics</a><a href="/tags/Mongo/" style="font-size: 12.86px;">Mongo</a><a href="/tags/Netty/" style="font-size: 15.71px;">Netty</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/04/redka-redis-with-sqlite/">Redka - 父亲是Redis，母亲是SQLite</a>
          </li>
        
          <li>
            <a href="/2024/06/03/command-dispacher-pattern/">命令分发模式</a>
          </li>
        
          <li>
            <a href="/2024/05/22/parse-tcp-timestamp-in-Rust/">使用Rust捕获和解析网络包</a>
          </li>
        
          <li>
            <a href="/2024/05/20/implemenmt-pping-in-go/">使用Go语言实现 pping</a>
          </li>
        
          <li>
            <a href="/2024/05/19/let-Rob-Pike-write-a-Red-Black-tree/">让 Rob Pike 或者字节跳动的同学实现一个红黑树</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
			 
            <a href="http://stackshare.io" target="_blank">技术栈</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="https://toutiao.io/" target="_blank">开发者头条</a>
			
          </li>
        
          <li>
			 
            <a href="http://weekly.manong.io/issues/" target="_blank">码农周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.tuicool.com/mags" target="_blank">编程狂人周刊</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.importnew.com/" target="_blank">importnew</a>
			
          </li>
        
          <li>
			 
            <a href="http://ifeve.com/" target="_blank">并发编程网</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="http://github.com" target="_blank">github</a>
			
          </li>
        
          <li>
			 
            <a href="http://stackoverflow.com/" target="_blank">stackoverflow</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.javacodegeeks.com/" target="_blank">javacodegeeks</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.infoq.com/" target="_blank">infoq</a>
			
          </li>
        
          <li>
			 
            <a href="http://www.dzone.com/links/index.html" target="_blank">dzone</a>
			
          </li>
        
          <li>
			 
            <a href="https://oj.leetcode.com/problems/" target="_blank">leetcode</a>
			
          </li>
        
          <li>
			 
            <a href="http://tutorials.jenkov.com" target="_blank">jenkov</a>
			
          </li>
        
          <li>
			 
            <a href="https://howtodoinjava.com" target="_blank">HowToDoInJava</a>
			
          </li>
        
          <li>
			 
            <a href="https://java-design-patterns.com/patterns/" target="_blank">java design patterns</a>
			
          </li>
        
          <li>
			 
			&nbsp;
			
          </li>
        
          <li>
			 
            <a href="https://medium.com/netflix-techblog" target="_blank">Netflix技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://www.techiedelight.com" target="_blank">Techie Delight</a>
			
          </li>
        
          <li>
			 
            <a href="https://engineering.linkedin.com/blog" target="_blank">Linkedin技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://blogs.dropbox.com/tech/" target="_blank">Dropbox技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://code.fb.com" target="_blank">Facebook技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="http://jm.taobao.org" target="_blank">淘宝中间件团队</a>
			
          </li>
        
          <li>
			 
            <a href="https://tech.meituan.com" target="_blank">美团技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="http://blogs.360.cn" target="_blank">360技术博客</a>
			
          </li>
        
          <li>
			 
            <a href="https://xiaomi-info.github.io" target="_blank">小米信息部技术团队</a>
			
          </li>
        
      </ul>
    </div>
  </div>

  
      

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 smallnest<br>
	  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    
      <a href="/" class="mobile-nav-link"><i class="fa fa-home">&nbsp;</i>首页</a>
    
  
    
      <a href="/archives" class="mobile-nav-link"><i class="fa fa-folder-o">&nbsp;</i>归档</a>
    
  
    
      <a href="https://github.com/smallnest" class="mobile-nav-link"><i class="fa fa-github">&nbsp;</i>github</a>
    
  
    
      <a class="mobile-nav-link" href="#"><i class="fa fa-bars">&nbsp;</i>网站群</a>
    
      
            <a class="mobile-nav-link" href="/goasm">&nbsp;&nbsp;<i class="fa fa-language">&nbsp;</i>Go汇编示例</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://gowebexamples.com">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go Web开发示例</a>
          
          
    
      
            <a class="mobile-nav-link" href="http://go-database-sql.org">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go 数据库开发教程</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://colobu.com/gotips/">&nbsp;&nbsp;<i class="fa fa-external-link">&nbsp;</i>Go 语言编程技巧</a>
          
          
    
      
            
          
          
    
      
            <a class="mobile-nav-link" href="/perf-book">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust高性能编程指南</a>
          
          
    
      
            <a class="mobile-nav-link" href="/rust100">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>100个练习题学习Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://github.com/rustcc/Rust_Atomics_and_Locks">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust原子操作和锁</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustx-labs.github.io/effective-rust-cn/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>高效Rust编程</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustwiki.org/zh-CN/book/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust程序设计语言</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://nomicon.purewhite.io/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust死灵书</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustwiki.org/zh-CN/reference/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust参考手册</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://zjp-cn.github.io/tlborm/translation_statement.html">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust宏小册</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://huangjj27.github.io/async-book/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust异步编程书</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rustwiki.org/zh-CN/rust-by-example/hello.html">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>通过例子学Rust</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://rust-chinese-translation.github.io/api-guidelines/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>Rust API 编写指南</a>
          
          
    
      
            <a class="mobile-nav-link" href="https://google.github.io/comprehensive-rust/zh-CN/">&nbsp;&nbsp;<i class="fa fa-brands fa-rust">&nbsp;</i>全面Rust课程</a>
          
          
    
      
            
          
          
    
      
            <a class="mobile-nav-link" href="http://rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPCX官网</a>
          
          
    
      
            <a class="mobile-nav-link" href="http://cn.doc.rpcx.io">&nbsp;&nbsp;<i class="fa undefined">&nbsp;</i>RPC开发指南</a>
          
          
    
    
  
    
      <a href="/ScalaCollectionsCookbook" class="mobile-nav-link"><i class="fa fa-solid fa-book">&nbsp;</i>Scala集合技术手册</a>
    
  
    
      <a href="/about" class="mobile-nav-link"><i class="fa fa-lemon-o">&nbsp;</i>关于</a>
    
  
</nav>
    
<script src="//cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script>
<script src="//cdn.bootcss.com/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>


<script src="/js/script.js" type="text/javascript"></script>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.6.0-beta.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div id="totop" style="position:fixed;bottom:150px;right:10px;cursor: pointer;z-index: 2000;">
	<a title="返回顶部"><img src="/images/scrollup.png"/></a>
</div>
<script src="/js/totop.js" type="text/javascript"></script>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e085d87993250aab11f3e0c15f1c2785";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </div>
</body>
</html>