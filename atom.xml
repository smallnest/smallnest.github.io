<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2021-11-09T08:06:38.622Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Go并发编程一年回顾(2021)]]></title>
    <link href="https://colobu.com/2021/11/09/the-state-of-go-sync-2021/"/>
    <id>https://colobu.com/2021/11/09/the-state-of-go-sync-2021/</id>
    <published>2021-11-09T06:37:32.000Z</published>
    <updated>2021-11-09T08:04:48.742Z</updated>
    <content type="html"><![CDATA[<p>去年的时候我写了一篇<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/" target="_blank" rel="external">Go并发编程一年回顾</a>,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。</p>
<a id="more"></a>
<h2 id="TryLock终于要发布">TryLock终于要发布</h2>
<p>很久以来(可以追溯到2013年<a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">#6123</a>),就有人提议给Mutex增加TryLock的方法，被大佬们无情的拒绝了，断断续续，断断续续的一直有人提议需要这个方法，如今到了2021年，Go team大佬们终于松口了，增加了相应的方法(<a href="https://github.com/golang/go/issues/45435" target="_blank" rel="external">#45435</a>)。</p>
<p>一句话来说，Mutex增加了TryLock， 尝试获取锁, RWMutex 增加了 TryLock和TryRLock方法，尝试获取写锁和读锁。它们都返回bool类型。如果返回true,代表已经获取到了相应的锁，如果返回false,则表示没有获取到相应的锁。</p>
<p>本质上，要实现这些方法并不麻烦，接下来我们看看相应的实现(去除了race代码)。</p>
<p>首先是Mutex.TryLock:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&m.state,<span class="number"> 0</span>, mutexLocked) {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是利用aromic.CAS操作state字段，如果当前没有被锁或者没有等待锁的情况，就可以成功获取到锁。不会尝试spin和与等待者竞争。</p>
<p>不过这段代码的风格经常会被拿来吐槽吧，当然有一个理由就是这样写比较直观，大家学习代码风格和最佳实践的时候更可能这样去写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32(&m.state,<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>读写锁有些麻烦，因为它有读锁和写锁两种情况。</p>
<p>首先看RWMutex.TryLock(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (rw *RWMutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> !rw.w.TryLock() {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !atomic.CompareAndSwapInt32(&rw.readerCount,<span class="number"> 0</span>, -rwmutexMaxReaders) {</div><div class="line">        rw.w.Unlock()</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先底层的Mutex.TryLock,尝试获取w字段的锁,如果成功，需要检查当前的Reader, 如果没有reader,则成功, 如果此时不幸还有reader没有释放读锁，那么尝试Lock也是不成功的,返回false。注意返回之前一定要把rw.w的锁释放掉。<br>这里的风格问题前面已提到了。</p>
<p>接下来看RWMutex.TryRLock(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (rw *RWMutex) TryRLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		c := atomic.LoadInt32(&rw.readerCount)</div><div class="line">		<span class="keyword">if</span> c &lt;<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&rw.readerCount, c, c<span class="number">+1</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码首先检查readerCount,如果为负值，说明有writer，此时直接返回false。</p>
<p>如果没有writer, 则使用atomic.CAS把reader加1, 如果成功，返回。如果不成功，那么此时可能有其它reader加入，或者也可能有writer加入，因为不能判断是reader还是writer加入，那么就用一个for循环再重试。</p>
<p>如果是writer加入，那么下一次循环c可能就是负数，直接返回false,如果刚才是有reader加入，那么它再尝试加1就好了。</p>
<p>以上就是新增的代码，不是特别复杂。Go team不情愿的把这几个方法加上了, 同时有很贴心的提示(恐吓):</p>
<blockquote>
<p>Note that while correct uses of TryLock do exist, they are rare,<br>and use of TryLock is often a sign of a deeper problem<br> in a particular use of mutexes. </p>
</blockquote>
<h2 id="WaitGroup的字段变化">WaitGroup的字段变化</h2>
<p>先前，WaitGroup类型使用<code>[3]uint32</code>作为<code>state1</code>字段的类型，在64位和32位编译器情况下，这个字段的byte的意义是不同的，主要是为了对齐。虽然使用一个字段很&quot;睿智&quot;,但是阅读起来却很费劲，现在，Go team把它改成了两个字段，根据对齐规则，64位编译器会对齐相应字段，讲真的，我们不差那4个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></div><div class="line">	<span class="comment">// compilers only guarantee that 64-bit fields are 32-bit aligned.</span></div><div class="line">	<span class="comment">// For this reason on 32 bit architectures we need to check in state()</span></div><div class="line">	<span class="comment">// if state1 is aligned or not, and dynamically "swap" the field order if</span></div><div class="line">	<span class="comment">// needed.</span></div><div class="line">	state1 <span class="typename">uint64</span></div><div class="line">	state2 <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// state returns pointers to the state and sema fields stored within wg.state*.</span></div><div class="line"><span class="keyword">func</span> (wg *WaitGroup) state() (statep *<span class="typename">uint64</span>, semap *<span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">if</span> unsafe.Alignof(wg.state1) ==<span class="number"> 8</span> || <span class="typename">uintptr</span>(unsafe.Pointer(&wg.state1))<span class="number">%8</span> ==<span class="number"> 0</span> {</div><div class="line">		<span class="comment">// state1 is 64-bit aligned: nothing to do.</span></div><div class="line">		<span class="keyword">return</span> &wg.state1, &wg.state2</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="comment">// state1 is 32-bit aligned but not 64-bit aligned: this means that</span></div><div class="line">		<span class="comment">// (&state1)+4 is 64-bit aligned.</span></div><div class="line">		state := (*<span class="number">[3</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&wg.state1))</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&state<span class="number">[1</span>])), &state<span class="number">[0</span>]</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>64位对齐情况下state1和state2意义很明确，如果不是64位对齐，还得巧妙的转换一下。</p>
<h2 id="Pool中使用fastrandn替换fastrand">Pool中使用fastrandn替换fastrand</h2>
<p>Go运行时中提供了<code>fastrandn</code>方法，要比<code>fastrand() % n</code>快很多，相关的文章可以看下面中的注释中的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> fastrand() <span class="typename">uint32</span> {</div><div class="line">	mp := getg().m</div><div class="line">	<span class="comment">// Implement wyrand: https://github.com/wangyi-fudan/wyhash</span></div><div class="line">	<span class="keyword">if</span> goarch.IsAmd64|goarch.IsArm64|goarch.IsPpc64|</div><div class="line">		goarch.IsPpc64le|goarch.IsMips64|goarch.IsMips64le|</div><div class="line">		goarch.IsS390x|goarch.IsRiscv64 ==<span class="number"> 1</span> {</div><div class="line">		mp.fastrand +=<span class="number"> 0</span>xa0761d6478bd642f</div><div class="line">		hi, lo := math.Mul64(mp.fastrand, mp.fastrand<span class="number">^0</span>xe7037ed1a0b428db)</div><div class="line">		<span class="keyword">return</span> <span class="typename">uint32</span>(hi ^ lo)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Implement xorshift64+</span></div><div class="line">	t := (*<span class="number">[2</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&mp.fastrand))</div><div class="line">	s1, s0 := t<span class="number">[0</span>], t<span class="number">[1</span>]</div><div class="line">	s1 ^= s1 &lt;&lt;<span class="number"> 17</span></div><div class="line">	s1 = s1 ^ s0 ^ s1&gt;<span class="number">&gt;7</span> ^ s0&gt;<span class="number">&gt;16</span></div><div class="line">	t<span class="number">[0</span>], t<span class="number">[1</span>] = s0, s1</div><div class="line">	<span class="keyword">return</span> s0 + s1</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> fastrandn(n <span class="typename">uint32</span>) <span class="typename">uint32</span> {</div><div class="line">	<span class="comment">// This is similar to fastrand() % n, but faster.</span></div><div class="line">	<span class="comment">// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/</span></div><div class="line">	<span class="keyword">return</span> <span class="typename">uint32</span>(<span class="typename">uint64</span>(fastrand()) * <span class="typename">uint64</span>(n) &gt;&gt;<span class="number"> 32</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以sync.Pool中使用<code>fastrandn</code>做了一点点修改，用来提高性能。好卷啊，这一点点性能都来压榨,关键，这还是开启race才会执行的代码。</p>
<h2 id="sync-Value增加了Swap和CompareAndSwap两个便利方法">sync.Value增加了Swap和CompareAndSwap两个便利方法</h2>
<p>如果使用sync.Value,这两个方法的逻辑经常会用到，现在这两个方法已经添加到标准库中了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (v *Value) Swap(<span class="built_in">new</span> <span class="keyword">interface</span>{}) (old <span class="keyword">interface</span>{}) </div><div class="line"><span class="keyword">func</span> (v *Value) CompareAndSwap(old, <span class="built_in">new</span> <span class="keyword">interface</span>{}) (swapped <span class="typename">bool</span>)</div></pre></td></tr></table></figure>

<p>Go 1.18中虽然实现了泛型，但是一些库的修改有可能在将来的版本中实现了。在泛型推出来之后，atomic对类型的支持会有大大的加强，所以将来Value这个类型有可能退出历史舞台，很少被使用了。(参考Russ Cox的文章<a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>)</p>
<p>整体来说，Go的并发相关的库比较稳定，并没有大的变化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去年的时候我写了一篇<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/" target="_blank" rel="external">Go并发编程一年回顾</a>,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型系列：再简化，省略接口]]></title>
    <link href="https://colobu.com/2021/10/24/go-generic-eliding-interface/"/>
    <id>https://colobu.com/2021/10/24/go-generic-eliding-interface/</id>
    <published>2021-10-24T09:27:08.000Z</published>
    <updated>2021-10-28T04:19:25.403Z</updated>
    <content type="html"><![CDATA[<p>这是Go泛型系列文章。</p>
<p>其它Go泛型文章：</p>
<ul>
<li><a href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/" target="_blank" rel="external">Go泛型是怎么实现的?</a></li>
<li><a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a></li>
</ul>
<a id="more"></a>
<p>如果你一直关注Go泛型的设计和实现，一定知道Go泛型代码实现是通过类型参数(type parameter)实现的，当运行泛型代码时，类型参数(type parameter)由类型参数（type argument）替代。(很遗憾parameter和argument都被翻译成了中文参数)</p>
<p>类型参数(type parameter)也有类型，也就是描述这个参数类型行为的元数据，被成为约束(constraint)。最通用的约束就是内建的<code>any</code>类型，它代表任意的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Print[T any](s []T) {</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</div><div class="line">		fmt.Println(v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Go泛型设计中， 约束是通过接口类型来实现的(<code>interface</code>)。因为接口类型和约束的功能黑类似，就是限定type argument必须实现type parameter的约束(方法集)。当然，为了实现泛型的功能，除了方法集之外，Go还对用来当做约束的接口做了扩展，定义了类型集(<code>type set</code>)的概念,比如下面是约束代表一个type argument可以是int、int8、int16、int32或int64的类型，是并(<code>union</code>)的关系，所以使用<code>|</code>符号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span> | <span class="typename">int8</span> | <span class="typename">int16</span> | <span class="typename">int32</span> | <span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>更进一步，Go还定义了<code>~</code>的符号，代表只要底层类型都是某个特定类型就可以，所以上面的例子可以写的更通用一些:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span> | ~<span class="typename">int8</span> | ~<span class="typename">int16</span> | ~<span class="typename">int32</span> | ~<span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样<code>type MyInt int</code>定义的<code>MyInt</code>类型的实例也满足这个约束。</p>
<h2 id="constraints_包">constraints 包</h2>
<p>Go目前的实现新增加一个package,叫做<code>constraints</code>,用来定义内建的约束,比如常见的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span> | ~<span class="typename">int8</span> | ~<span class="typename">int16</span> | ~<span class="typename">int32</span> | ~<span class="typename">int64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">uint</span> | ~<span class="typename">uint8</span> | ~<span class="typename">uint16</span> | ~<span class="typename">uint32</span> | ~<span class="typename">uint64</span> | ~<span class="typename">uintptr</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</div><div class="line">	Signed | Unsigned</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">float32</span> | ~<span class="typename">float64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Complex <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">complex64</span> | ~<span class="typename">complex128</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> {</div><div class="line">	Integer | Float | ~<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至 Russ Cox、Ian Lance Taylor他们 提议和讨论为 slice、map、chan增加必要的约束，因为它们太常用了，标准库中都可以用到。(<a href="https://github.com/golang/go/discussions/47203" target="_blank" rel="external">#47203</a>、<a href="https://github.com/golang/go/discussions/47319" target="_blank" rel="external">#47319</a>、<a href="https://github.com/golang/go/discussions/47330" target="_blank" rel="external">47330#</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Slice[Elem any] <span class="keyword">interface</span> {</div><div class="line">	~[]Elem</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Map[Key comparable, Val any] <span class="keyword">interface</span> {</div><div class="line">	~<span class="keyword">map</span>[Key]Val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Chan[Elem any] <span class="keyword">interface</span> {</div><div class="line">	~<span class="keyword">chan</span> Elem</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>Rob Pike 最近新提交了一个issue,建议在Go 1.18中不要对标准库增加泛型的支持<a href="https://github.com/golang/go/issues/48918" target="_blank" rel="external">#48918</a>。离Go 1.18发布就四个月了，很多实现还在摸索之中，这是大师给出的一个很中肯的建议，建议相关的哭的改动先增加到扩展库中(<code>x/exp</code>),成熟后再加到标准库中，得到了很多Gopher的赞同。这是另外一个话题了。</p>
</blockquote>
<p>包<code>constraints</code>定义常用的约束可以很好的帮助我们开发，但是你有没有感觉有点异常？</p>
<h2 id="省略接口">省略接口</h2>
<p>是的，依照Go泛型规范，我们必须定义一个约束，然后才能在泛型类型和泛型方法中使用，和其它语言的泛型定义相比，你有没有觉得这一点有脱裤子放屁多此一举的味道？</p>
<p>你看上面的Slice、Map、Chan的定义，是不是很冗余？为什么我们不能直接在泛型类型和方法的定义中直接使用<code>~[]Elem</code>、<code>~map[Key]Val</code>、<code>~chan Elem</code>呢？</p>
<p>因此fzipp提议，对于一个非接口的类型，默认等价为一个约束<a href="https://github.com/golang/go/issues/48424" target="_blank" rel="external">#48424</a>，下面的公式很好的描述了这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[T nonInterfaceType] ≡ [T <span class="class"><span class="keyword">interface</span></span>{~nonInterfaceType}]</div></pre></td></tr></table></figure>

<p>在泛型的定义中，非接口类型<code>nonInterfaceType</code>等价于约束<code>interface{~nonInterfaceType}</code>, 比如<code>~int</code>等价于<code>interface{~int}</code>。这样我们就可以省略<code>constraints</code>包了。 这个提议北接收了，而且相关功能也加入到了go master分支中。</p>
<p>mattn的Go泛型例子中，将一个整形数组转换成一个chan的<a href="https://github.com/mattn/go-generics-example/blob/main/constraints-chan/main.go" target="_blank" rel="external">例子</a>(我稍微改动成更地道的Go的写法):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"constraints"</span></div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> makeChan[T constraints.Chan[E], E any](ctx context.Context, arr []E) T {</div><div class="line">	ch := <span class="built_in">make</span>(T)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> ch &lt;- v:</div><div class="line">			}</div><div class="line">			</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> makeChan(context.Background(), []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}) {</div><div class="line">		fmt.Println(v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里使用的是<code>constraints.Chan[E]</code>代表一个泛型的channel，现在可以用更简便的方法了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> makeChan[T <span class="keyword">chan</span> E, E any](ctx context.Context, arr []E) T {</div><div class="line">	ch := <span class="built_in">make</span>(T)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> ch &lt;- v:</div><div class="line">			}</div><div class="line">			</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接使用<code>chan E</code>就可以了，方不方便？</p>
<p><code>chan E</code> 隐式地代表<code>interface {chan E}</code>,使用起来更简捷，不需要额外的接口(约束)定义。</p>
<p>虽然Go 1.18的临近，感觉Go泛型的开发工作越来越重，甚至有一些还不明确的地方，祝福一下吧，希望它顺顺利利的推出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Go泛型系列文章。</p>
<p>其它Go泛型文章：</p>
<ul>
<li><a href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/" target="_blank" rel="external">Go泛型是怎么实现的?</a></li>
<li><a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a></li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]更快的时间解析]]></title>
    <link href="https://colobu.com/2021/10/10/faster-time-parsing/"/>
    <id>https://colobu.com/2021/10/10/faster-time-parsing/</id>
    <published>2021-10-10T08:17:51.000Z</published>
    <updated>2021-10-24T09:19:04.610Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://philpearl.github.io/post/perf_time/" target="_blank" rel="external">Faster time parsing</a>， 可以学习一下作者优化程序的方法。</p>
<a id="more"></a>
<p><img src="time.jpg" alt=""></p>
<p>在<a href="https://www.ravelin.com/careers" target="_blank" rel="external">Ravelin</a>，我们大量的数据都携带时间戳(timestamp)。大部分时间戳都以字符串形式存储在BigQuery中，而我们的大多数Go结构都使用Go time.Time类型表示时间。</p>
<p>很遗憾这就是我们的现实情况。我们真的有很多很多数据，所以我们真的有很多很多时间戳。一段时间以来，我总结出一个结论，随着时间的推移，我确信这个结论是正确的：</p>
<blockquote>
<p><strong>Friends don’t let friends represent time in databases as strings.</strong><br><strong>真心是哥们的话就不要在数据库把时间表示成字符串类型</strong></p>
</blockquote>
<p>不管咋地，自己的苦还得自己咽下去，既然我们已经这么设计了，我们还得坚持下去，但这不意味着我们破罐子破摔了，我们可以尽力而为。对于我来说，现在做得最好的方案就是找到一种比<a href="https://pkg.go.dev/time#Parse" target="_blank" rel="external">time.Parse</a>更快的方法解析 <strong>RFC3339</strong> 格式的时间戳。<br> If we write a dedicated parsing routine that just parses RFC3339 it should be faster than that.</p>
<p>事实证明这很容易。<strong>time.Parse</strong>有两个参数：一个描述要解析的数据格式(特殊字符串)，另一个是需要解析的数据字符串。format参数不只是选择合适的格式。format参数描述应如何解析数据。<strong>time.Parse</strong>不仅解析时间，还必须解析、理解和实现一种解析时间的描述。如果我们编写一个只是解析RFC3339的专用解析函数，它应该会比<strong>time.Parse</strong>更快。</p>
<p>但是在动手之前，让我们先写一个快速的基准测试，看看<strong>time.Parse</strong>有多快:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkParseRFC3339(b *testing.B) {</div><div class="line">	now := time.Now().UTC().Format(time.RFC3339Nano)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		<span class="keyword">if</span> _, err := time.Parse(time.RFC3339, now); err != <span class="constant">nil</span> {</div><div class="line">			b.Fatal(err)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面数据是测试的结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="property">name</span>             <span class="property">time</span>/op</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">150</span>ns ± <span class="number">1</span>%</div></pre></td></tr></table></figure>

<p>接下来我们开始写自己专用的 RFC3339 解析函数。它索然无味，而且也不漂亮，但是至少它可以工作。</p>
<p>(它真的很长且不漂亮，所以与其把它包含在这篇文章中，让大家滚动过去，不如这里有一个<a href="https://github.com/philpearl/avro/blob/master/time/parse.go" target="_blank" rel="external">链接</a>，指向最终版本，并应用下面讨论的所有优化。如果你想象一个很长的函数，调用<a href="https://pkg.go.dev/strconv#Atoi" target="_blank" rel="external">strconv.Atoi</a>的次数很多，你就会明白这一点)</p>
<p>我们使用基础测试代码测试新的解析函数，我们得到下面的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>   <span class="number">150</span>ns ± <span class="number">1</span>%    <span class="number">45</span>ns ± <span class="number">4</span>%  -<span class="number">70.15</span>%  (p=<span class="number">0.000</span> n=<span class="number">7</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>相比较而言，新的函数真的很快。完美，结束。</p>
<h2 id="等等，_还未结束">等等， 还未结束</h2>
<p>如果我们采样 <a href="https://hackernoon.com/go-the-complete-guide-to-profiling-your-code-h51r3waz" target="_blank" rel="external">CPU profile</a>,我们观察到很多时间都花费在调用<strong>strconv.Atoi</strong>上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; go test -run ^$ -bench BenchmarkParseRFC3339 -cpuprofile cpu.prof </div><div class="line">&gt; go tool pprof cpu.prof</div><div class="line"><span class="keyword">Type</span>: cpu</div><div class="line"><span class="typename">Time</span>: Oct <span class="number">1</span>, <span class="number">2021</span> at <span class="number">7</span>:<span class="number">19</span>pm (BST)</div><div class="line">Duration: <span class="number">1.22</span>s, Total samples = <span class="number">960</span>ms (<span class="number">78.50</span>%)</div><div class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">950</span>ms, <span class="number">98.96</span>% <span class="keyword">of</span> <span class="number">960</span>ms total</div><div class="line">Showing top <span class="number">10</span> nodes <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">24</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     <span class="number">380</span>ms <span class="number">39.58</span>% <span class="number">39.58</span>%      <span class="number">380</span>ms <span class="number">39.58</span>%  strconv.Atoi</div><div class="line">     <span class="number">370</span>ms <span class="number">38.54</span>% <span class="number">78.12</span>%      <span class="number">920</span>ms <span class="number">95.83</span>%  github.com/philpearl/blog/content/post.parseTime</div><div class="line">      <span class="number">60</span>ms  <span class="number">6.25</span>% <span class="number">84.38</span>%      <span class="number">170</span>ms <span class="number">17.71</span>%  <span class="typename">time</span>.Date</div></pre></td></tr></table></figure>

<p><strong>strconv.Atoi</strong>转换ASCII字符到整数类型。这是Go标准库的基础实现，所以它一定是经过了很好的编码和优化，所以我们不能优化它吗？</p>
<p>未必，我们的大部分数字正好有2个字节长，或者正好有4个字节长。我们可以编写数字解析函数，针对我们的特殊情况做优化，不需要任何令人讨厌的慢循环:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> atoi4(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	a, b, c, d := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[2</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[3</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> || c &lt;<span class="number"> 0</span> || c &gt;<span class="number"> 9</span> || d &lt;<span class="number"> 0</span> || d &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*1000</span> + b<span class="number">*100</span> + c<span class="number">*10</span> + d, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果再运行我们的基准测试，可以看到我们又做了一次更深入的性能提升。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">44.9</span>ns ± <span class="number">4</span>%  <span class="number">39.7</span>ns ± <span class="number">3</span>%  -<span class="number">11.51</span>%  (p=<span class="number">0.000</span> n=<span class="number">8</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>好了，我们现在不仅写了一个定制的时间解析器，而且还实现了定制的数字解析器。非常完美，结束。</p>
<h2 id="等等，_当然还未结束">等等， 当然还未结束</h2>
<p>啊哈，让我们在看一眼现在的CPU profile, 并且看一些汇编代码。在<strong>atoi2</strong>中有两个slice长度检查(下面绿色的汇编代码,调用panicIndex之前)，不是有一个<a href="https://go101.org/article/bounds-check-elimination.html" target="_blank" rel="external">边界检查的技巧</a>吗？</p>
<p><img src="lencheck.png" alt=""></p>
<p>以下是根据此技巧进行修正后的代码。函数开始处的<strong>_ = in[1]</strong>给了编译器充足的提示，这样我们在调用它的时候不用每次都检查是否溢出了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	_ = in<span class="number">[1</span>] <span class="comment">// This helps the compiler reduce the number of times it checks `in` is long enough</span></div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>虽然是一点小小的改变，但也带来明显的改变:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">39.7</span>ns ± <span class="number">3</span>%  <span class="number">38.4</span>ns ± <span class="number">2</span>%  -<span class="number">3.26</span>%  (p=<span class="number">0.001</span> n=<span class="number">8</span>+<span class="number">7</span>)</div></pre></td></tr></table></figure>

<p><strong>atoi2</strong>非常短。为什么它不被内联的？如果我们简化错误处理，是不是有效果？如果我们删除对<strong>fmt.Errorf</strong>的调用，并将其替换为一个简单的错误类型，这将降低<strong>atoi2</strong>函数的复杂性。这可能足以让Go编译器决定不作为单独的代码块而是直接在调用函数中内联这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> errNotNumber = errors.New(<span class="string">"not a valid number"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	_ = in<span class="number">[1</span>]</div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, errNotNumber</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是最终的形态，基准测试结果有了显著的提升。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">38.4</span>ns ± <span class="number">2</span>%  <span class="number">32.9</span>ns ± <span class="number">5</span>%  -<span class="number">14.39</span>%  (p=<span class="number">0.000</span> n=<span class="number">7</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>我们的优化故事真的就此结束了。为了优化120纳秒的时间我们做了大量的工作。必看120纳秒很小，加起来却对程序提升不少，这些优化将Ravelin的一些机器学习特征提取管道组件的运行时间减少了一个小时甚至更多。如我前面所说，我们真的有很多很多的数据和时间戳。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://philpearl.github.io/post/perf_time/" target="_blank" rel="external">Faster time parsing</a>， 可以学习一下作者优化程序的方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[强制更改Go标准库的实现]]></title>
    <link href="https://colobu.com/2021/10/06/replace-implementations-in-go-std-libs-at-runtime/"/>
    <id>https://colobu.com/2021/10/06/replace-implementations-in-go-std-libs-at-runtime/</id>
    <published>2021-10-06T03:51:16.000Z</published>
    <updated>2021-10-06T05:16:58.923Z</updated>
    <content type="html"><![CDATA[<p>Go标准库中有一些单例的实现，比如<code>log</code>包中默认的<code>Logger</code>、<code>net.DefaultResolver</code>, 这些对象提供了便利的方法，但是有的时候，我们需要做一些定制话的功能，需要更改这些对象，<br>甚至有的时候，我们需要更改标准库的特定方法，常规手段是不起作用的, 必须使用一些&quot;骇客&quot;的方式。</p>
<p>国庆北京连绵秋雨，整好我窝在家里，实现了一个原本想12月份实现的产品，在开发项目的过程中，也遇到了一些需要更改标准库默认行为的需求，所以在这方面做了一些探索，整理出这篇文章，以飨读者。<br><a id="more"></a></p>
<p>如果你想实现自己的一个日志库(事实上Go生态圈已经有很多很多的日志库了)，你可能想&quot;拦截&quot;标准库的默认的Log,这样你的代码，或者第三方代码中通过标准库<code>log</code>输出的日志都能通过你自己的日志库输入出来。</p>
<p>其实标准库<code>log</code>默认的Logger是这样定义的: <code>var std = New(os.Stderr, &quot;&quot;, LstdFlags)</code>, std实现了一个输出到<code>os.Stderr</code>的<code>Logger</code>。Go标准库中的Logger不是一个接口，所以本身你可能还不能做太多的定制化的改造，但是至少，你可以改变日志输出的目的地，比如从标准err输出改到日志文件中。这里<code>std</code>是未输出的变量，但是标准库提供了<code>func SetOutput(w io.Writer)</code>方法，用来更改输出目的地。</p>
<p>这样看来，日志库还好，至少还暴露了一个更改定制化的方法，但是有很多情况下，标准库并没有提供定制的方法，或者说不方便定制的方法。</p>
<p>这几天我在实现项目的时候，遇到了一台机器有多个IP的情况。</p>
<p>一台机器配置了多个IP并不罕见，当你在这台机器连接其它的TCP服务器时， 本地到底使用的是哪一个IP地址呢？如<a href="https://serverfault.com/questions/12285/when-ip-aliasing-how-does-the-os-determine-which-ip-address-will-be-used-as-sour" target="_blank" rel="external">serverfault</a>有人提出的问题，在默认的情况下，Linux会依照子网的分类，选择和服务器在相同的子网的本地地址，但是如果同一个子网中配置了多个IP地址，那么Linux会选择此子网的&quot;主&quot;IP地址作为本地Ip地址连接服务器。</p>
<p>在我这个项目中，会有很多的网络连接，比如连接mysql，连接clickhouse,连接第三方的HTTP API服务，连接Kafka、连接 Redis等。不幸的事，当使用第三方库比如go-sql-driver/mysql、go-redis时，Linux所选择的本地IP地址并不是我期望的本地IP地址，导致权限验证失败无法连接。</p>
<p>本质上，无论是<code>go-sql-driver/mysql</code>或者<code>go-redis</code>,都是基于<code>net.Dial</code>或者<code>net.DialContext</code>建立的TCP连接。<code>go-sql-driver/mysql</code> 提供了 <code>RegisterDialContext</code>用于定制化<code>Dial</code>,<code>go-redis</code>提供了<code>Dialer</code>字段用来定制，你如果想指定本地的IP地址，可以通过定制的<code>net.Dialer</code>来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   localAddrDialier := &net.Dialer{</div><div class="line">	LocalAddr: localAddr,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是一个不错的、传统的方法，唯一不爽的是，每种类型我都需要进行地址，访问mysql、访问redis、访问kafka、访问第三方库、访问服务器......, 有没有一劳永逸的方法呢？</p>
<p>有!</p>
<p><a href="https://github.com/bouk/monkey" target="_blank" rel="external">bouk/monkey</a>是一个相当相当&quot;骇客&quot;的技术，当过运行时动态将方法的实现替换成<code>JMP 新的函数</code>, 来实现在运行时替换方法。经常我们会在单元测试的时候用来&quot;Mock&quot;一些方法，非常的有效，这一次，我要尝试使用它替换所有的<code>net.Dialer.Dial</code>或者<code>net.Dialer.DialContext</code>方法，来实现强制指定本地地址。</p>
<p>当然，agiledragon基于它的原理实现了<a href="https://github.com/agiledragon/gomonkey" target="_blank" rel="external">agiledragon/gomonkey</a>以方便调用，不过目前不支持临时恢复原函数。曹春晖基于它实现了<a href="https://github.com/cch123/supermonkey" target="_blank" rel="external">cch123/supermonkey</a>,通过解析符号表得到函数指针，可以替换未输出的函数，可以说功能更强大了。本文中还是使用原始的bouk/monkey,因为对于我来说，功能足够了。</p>
<blockquote>
<p>不要使用<a href="https://github.com/bouk/monkey" target="_blank" rel="external">bouk/monkey</a>做恶。</p>
</blockquote>
<p>可以使用<a href="https://github.com/bouk/monkey" target="_blank" rel="external">bouk/monkey</a>替换标准库的<code>net.Dialer.Dial</code>或者<code>net.Dialer.DialContext</code>函数，在建立TCP连接的时候，使用本地IP地址。这样，无论是mysql的库、还是redis的库，或者其它的第三方库，只要基于<code>net.Dialer.Dial</code>或者<code>net.Dialer.DialContext</code>函数，就会使用我们替换的方法。</p>
<p>相关代码也非常简单，如下所示，注释已经加到代码中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 指定要使用的本地地址. // by https://colobu.com</span></div><div class="line">   localAddr := &net.TCPAddr{</div><div class="line">	IP:   net.ParseIP(localIP),</div><div class="line">	Port:<span class="number"> 0</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> d *net.Dialer</div><div class="line"></div><div class="line">   <span class="comment">// 替换Dialer.DialContext方法</span></div><div class="line">dialContextGuard = monkey.PatchInstanceMethod(reflect.TypeOf(d), <span class="string">"DialContext"</span>, <span class="keyword">func</span>(d *net.Dialer, ctx context.Context, network, address <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">       <span class="comment">// 临时恢复</span></div><div class="line">	dialContextGuard.Unpatch()</div><div class="line">	<span class="keyword">defer</span> dialContextGuard.Restore()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"tcp"</span> || network == <span class="string">"tcp4"</span> || network == <span class="string">"tcp6"</span> {</div><div class="line">		localAddrDialier := &net.Dialer{</div><div class="line">			LocalAddr: localAddr,</div><div class="line">		}</div><div class="line"></div><div class="line">           <span class="comment">// 使用指定本地地址的dialer</span></div><div class="line">		<span class="keyword">return</span> localAddrDialier.DialContext(ctx, network, address)</div><div class="line">	}</div><div class="line"></div><div class="line">       <span class="comment">// 其它情况，比如UDP、UnixDomain等，使用标准库的方法</span></div><div class="line">	<span class="keyword">return</span> d.DialContext(ctx, network, address)</div><div class="line">})</div><div class="line"></div><div class="line">   <span class="comment">// 替换Dail方法</span></div><div class="line">dialGuard = monkey.PatchInstanceMethod(reflect.TypeOf(d), <span class="string">"Dial"</span>, <span class="keyword">func</span>(d *net.Dialer, network, address <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">       <span class="comment">// 临时恢复</span></div><div class="line">	dialGuard.Unpatch()</div><div class="line">	<span class="keyword">defer</span> dialGuard.Restore()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"tcp"</span> || network == <span class="string">"tcp4"</span> || network == <span class="string">"tcp6"</span> {</div><div class="line">		localAddrDialier := &net.Dialer{</div><div class="line">			LocalAddr: localAddr,</div><div class="line">		}</div><div class="line"></div><div class="line">           <span class="comment">// 使用指定本地地址的dialer</span></div><div class="line">		<span class="keyword">return</span> localAddrDialier.Dial(network, address)</div><div class="line">	}</div><div class="line"></div><div class="line">       <span class="comment">// 其它情况，比如UDP、UnixDomain等，使用标准库的方法</span></div><div class="line">	<span class="keyword">return</span> d.Dial(network, address)</div><div class="line">})</div></pre></td></tr></table></figure>

<p>替换了这两个方法后，之后即使新建立<code>net.Dailer</code>对象，也是使用替换后的方法执行。</p>
<blockquote>
<p>这里并没有考虑并发定位情况，如果你的程序有并发的调用Dial或者DialContext,你需要加锁。</p>
</blockquote>
<p>这样，我们就一劳永逸的解决了指定本地IP地址创建TCP连接的问题，无需改动标准库的代码，无需逐个定制Dial方法。</p>
<p>同样的，你可以更改标准库的<code>net.DefaultResolver</code>, 这是标准库用来进行域名解析的实现，支持Go自己的解析实现和CGO方式查询。本身它是一个struct,而不是一个接口，所以虽然它是一个单例的对象，但是通常情况下你也没有多少定制化的可能。比如在调用<code>LookupIP</code>方法时,你想使用自己的一个协议返回IP列表，而不是查询本地文件或者DNS服务器，你基本是没有办法的。但是通过bouk/monkey，你可以更改<code>LookupIP</code>方法，这样你就可以定制了。</p>
<p>所以，bouk/monkey不仅仅可以用来在单元测试中mock对象和方法，还可以在应用运行中替换一些常规没有办法更改的函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go标准库中有一些单例的实现，比如<code>log</code>包中默认的<code>Logger</code>、<code>net.DefaultResolver</code>, 这些对象提供了便利的方法，但是有的时候，我们需要做一些定制话的功能，需要更改这些对象，<br>甚至有的时候，我们需要更改标准库的特定方法，常规手段是不起作用的, 必须使用一些&quot;骇客&quot;的方式。</p>
<p>国庆北京连绵秋雨，整好我窝在家里，实现了一个原本想12月份实现的产品，在开发项目的过程中，也遇到了一些需要更改标准库默认行为的需求，所以在这方面做了一些探索，整理出这篇文章，以飨读者。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/tags/Go/"/>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型是怎么实现的?]]></title>
    <link href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/"/>
    <id>https://colobu.com/2021/08/30/how-is-go-generic-implemented/</id>
    <published>2021-08-30T09:21:18.000Z</published>
    <updated>2021-10-06T03:29:34.356Z</updated>
    <content type="html"><![CDATA[<p>Go 1.17中你就可以使用泛型了，可以参考我3月份的文章:<a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a>, 编译的时候需要加<code>-gcflags=-G=3</code>参数，而当前master分支，默认已经支持泛型，不需要加<code>-G=3</code>参数了。</p>
<p>你可以通过下面的步骤尝试go最新分支:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get golang.org/dl/gotip</div><div class="line">gotip download</div></pre></td></tr></table></figure>

<p>编译代码的时候使用<code>gotip</code>替换<code>go</code>命令即可。</p>
<p>随着Go 1.17的发布，最近也涌现了很多的介绍Go泛型的文章，基本上都是简单介绍的文章。</p>
<p>最近Go泛型的变化是增加了两个操作符: <code>~</code>和<code>|</code>：</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<p>这些不是我想介绍的内容，今天我肝一篇介绍Go泛型实现原理的文章，介绍Go泛型实现的方案。</p>
<p>对于一个函数<code>func Echo[T any](t T){}</code>，Go编译器到底编译成了什么代码？</p>
<p>简单的说，当前Go泛型实现的方案和下图中的方案一样：</p>
<a id="more"></a>
<p><img src="stenciling.jpeg" alt=""></p>
<p>在国内的老破小小区的楼道中常见的一种高科技印刷技术，通过一个镂花模板，为每一种类型生成特化的类型，这个术语叫做<code>stenciling</code>。</p>
<p>但是如果再说多一点，那么就应该从 Taylor和Griesemer说起。</p>
<h2 id="Go泛型提案中关于泛型实现的介绍">Go泛型提案中关于泛型实现的介绍</h2>
<p>Go的泛型有别于其它语言的方案，在Go语言中泛型叫做<code>Type Parameter</code>(类型参数).</p>
<p>Taylor和Griesemer的提案<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md" target="_blank" rel="external">Type Parameters Proposal</a>更多的是泛型呈现形式和影响的思考,对具体的实现涉及甚少。</p>
<p>无论什么编程语言，<a href="https://research.swtch.com/generic" target="_blank" rel="external">根据Russ Cox的观察</a>，实现泛型至少要面对下面三条困境之一,那还是在2009年：</p>
<ul>
<li>拖累程序员:比如C语言，增加了程序员的负担，需要曲折的实现，但是不对增加语言的复杂性</li>
<li>拖累编译器: 比如C++编程语言，增加了编译器的负担，可能会产生很多冗余的代码，重复的代码还需要编译器斟酌删除，编译的文件可能非常大。Rust的泛型也属于这一类。</li>
<li>拖累执行时间:比如Java，将一些装箱成Object,进行类型擦除。虽然代码没啥冗余了，空间节省了，但是需要装箱拆箱操作，代码效率低。</li>
</ul>
<p>很显然, Go语言至简的设计哲学让它的泛型实现不会选择增加程序员的负担的道路，所以它会在第二和第三种方案中做选择。虽然提案中没有最终说明它选择了哪种方案，但是从实际编译的代码可以看出，它选择的是第二种方案。</p>
<h2 id="三个方案">三个方案</h2>
<p>Keith H. Randall, MIT的博士，现在在Google/Go team做泛型方面的开发，提出了Go泛型实现的三个方案：</p>
<h3 id="字典">字典</h3>
<p>在编译时生成一组实例化的字典，在实例话一个泛型函数的时候会使用字典进行蜡印(stencile)。</p>
<p>当为泛型函数生成代码的时候，会生成唯一的一块代码，并且会在参数列表中增加一个字典做参数，就像方法会把receiver当成一个参数传入。字典包含为类型参数实例化的类型信息。</p>
<p>字典在编译时生成，存放在只读的data section中。</p>
<p>当然字段可以当成第一个参数，或者最后一个参数，或者放入一个独占的寄存器。</p>
<p>当然这种方案还有依赖问题，比如字典递归的问题，更重要的是，它对性能可能有比较大的影响，比如一个实例化类型<code>int</code>, <code>x=y</code>可能通过寄存器复制就可以了，但是泛型必须通过<code>memmove</code>。</p>
<h3 id="蜡印(Stenciling)">蜡印(Stenciling)</h3>
<p>或者翻译成<code>用模板印</code>等。</p>
<p>就像下面的动图一样，同一个泛型函数，为每一个实例化的类型参数生成一套独立的代码，感觉和rust的泛型特化一样。<br><img src="stencile.gif" alt=""></p>
<p>这种方案和上面的字典方案正好相反。</p>
<p>比如下面一个泛型方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f[T1, T2 any](x <span class="typename">int</span>, y T1) T2 {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果有两个不同的类型实例化的调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="typename">float64</span> = f[<span class="typename">int</span>, <span class="typename">float64</span>]<span class="number">(7</span>,<span class="number"> 8.0</span>)</div><div class="line"><span class="keyword">var</span> b <span class="keyword">struct</span>{f <span class="typename">int</span>} = f[<span class="typename">complex128</span>, <span class="keyword">struct</span>{f <span class="typename">int</span>}]<span class="number">(3</span>,<span class="number"> 1</span><span class="number">+1</span>i)</div></pre></td></tr></table></figure>

<p>那么这个方案会生成两套代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f1(x <span class="typename">int</span>, y <span class="typename">int</span>) <span class="typename">float64</span> {</div><div class="line">    ... identical bodies ...</div><div class="line">}</div><div class="line"><span class="keyword">func</span> f2(x <span class="typename">int</span>, y <span class="typename">complex128</span>) <span class="keyword">struct</span>{f <span class="typename">int</span>} {</div><div class="line">    ... identical bodies ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为编译f时是不知道它的实例化类型的，只有在调用它时才知道它的实例化的类型，所以需要在调用时编译f。对于相同实例化类型的多个调用，同一个package下编译器可以识别出来是一样的，只生成一个代码就可以了，但是不同的package就不简单了，这些函数表标记为<code>DUPOK</code>,所以链接器会丢掉重复的函数实现。</p>
<p>这种策略需要更多的编译时间，因为需要编译泛型函数多次。因为对于同一个泛型函数，每种类型需要单独的一份编译的代码，如果类型非常多，编译的文件可能非常大，而且性能也比较差。</p>
<h3 id="混合方案（GC_Shape_Stenciling）">混合方案（GC Shape Stenciling）</h3>
<p>混合前面的两种方案。</p>
<p>对于实例类型的shape相同的情况，只生成一份代码，对于shape类型相同的类型，使用字典区分类型的不同行为。</p>
<p>这种方案介于前两者之间。</p>
<p>啥叫<code>shape</code>?</p>
<p>类型的shape是它对内存分配器/垃圾回收器呈现的方式，包括它的大小、所需的对齐方式、以及类型哪些部分包含指针。</p>
<p>每一个唯一的shape会产生一份代码，每份代码携带一个字典，包含了实例化类型的信息。</p>
<p>这种方案的问题是到底能带来多大的收益，它会变得有多慢，以及其它的一些问题。</p>
<p>从当前的反编译的代码看，当前Go采用的是第二种方案，尽管名称中已经带了<code>shape</code>、<code>dict</code>的标志，或许，Go的泛型方案还在进化之中，进化到第三种方案或者其它方案也不是没有可能。</p>
<p>接下来我们看一个例子，看看Go泛型的方案是怎么实现的。</p>
<h2 id="例子">例子</h2>
<p>下面是一个简单的例子，有一个泛型函数<code>func echo[T any](t T) string {return fmt.Sprintf(&quot;%v&quot;, t)}</code>,使用不同的几种实例化类型去调用它，并且使用shape一样的<code>int32</code>和<code>uint32</code>做为实例化类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> generic</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> echo[T any](t T) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v"</span>, t)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Test() {</div><div class="line">	echo<span class="number">(0</span>)</div><div class="line">	echo(<span class="typename">int32</span><span class="number">(0</span>))</div><div class="line">	echo(<span class="typename">uint32</span><span class="number">(0</span>))</div><div class="line">	echo(<span class="typename">uint64</span><span class="number">(0</span>))</div><div class="line">	echo(<span class="string">"hello"</span>)</div><div class="line">	echo(<span class="keyword">struct</span>{}{})</div><div class="line">	echo(time.Now())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>反编译后代码非常长，精简如下。编译的时候禁止优化和内联，否则实例化的代码内联后看不到效果了。</p>
<p>可以看到函数<code>echo</code>编译成了不同的函数：<code>&quot;&quot;.echo[.shape.int]</code>、<code>&quot;&quot;.echo[.shape.int32]</code>、<code>&quot;&quot;.echo[.shape.uint32]</code>、<code>&quot;&quot;.echo[.shape.uint64]</code>、<code>&quot;&quot;.echo[.shape.string]</code>、<code>&quot;&quot;.echo[.shape.struct{}]</code>、<code>&quot;&quot;.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }]</code>不同的函数，即使shape一样的类型(<code>int32</code>、<code>uint32</code>)。 调用这些函数时，是通过<code>&quot;&quot;..dict.echo[uint64]</code>这种方式调用的。</p>
<p>所以我谨慎怀疑，Go的泛型方式在逐步的向第三种方案进化。</p>
<figure class="highlight assemble"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"># command-line-arguments</div><div class="line"><span class="string">""</span>.Test STEXT <span class="keyword">size</span>=<span class="number">185</span> args=<span class="number">0</span>x0 locals=<span class="number">0</span>x48 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	TEXT	<span class="string">""</span>.Test(SB), ABIInternal, $<span class="number">72</span>-<span class="number">0</span></div><div class="line">	<span class="string">""</span>.Test STEXT <span class="keyword">size</span>=<span class="number">185</span> args=<span class="number">0</span>x0 locals=<span class="number">0</span>x48 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	TEXT	<span class="string">""</span>.Test(SB), ABIInternal, $<span class="number">72</span>-<span class="number">0</span></div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	CMPQ	SP, <span class="number">16</span>(R14)</div><div class="line">	<span class="number">0</span>x0004 <span class="number">00004</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">2</span></div><div class="line">	<span class="number">0</span>x0004 <span class="number">00004</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	JLS	<span class="number">175</span></div><div class="line">	<span class="number">0</span>x000a <span class="number">00010</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">1</span></div><div class="line">	<span class="number">0</span>x000a <span class="number">00010</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	SUBQ	$<span class="number">72</span>, SP</div><div class="line">	<span class="number">0</span>x000e <span class="number">00014</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	MOVQ	BP, <span class="number">64</span>(SP)</div><div class="line">	<span class="number">0</span>x0013 <span class="number">00019</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	LEAQ	<span class="number">64</span>(SP), BP</div><div class="line">	<span class="number">0</span>x0018 <span class="number">00024</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</div><div class="line">	<span class="number">0</span>x0018 <span class="number">00024</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	FUNCDATA	$<span class="number">1</span>, gclocals·<span class="number">54241</span>e171da8af6ae173d69da0236748(SB)</div><div class="line">	<span class="number">0</span>x0018 <span class="number">00024</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	LEAQ	<span class="string">""</span>..dict.echo[<span class="keyword">int</span>](SB), AX</div><div class="line">	<span class="number">0</span>x001f <span class="number">00031</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x0021 <span class="number">00033</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x0021 <span class="number">00033</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.<span class="keyword">int</span>](SB)</div><div class="line">	<span class="number">0</span>x0026 <span class="number">00038</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">14</span>)	LEAQ	<span class="string">""</span>..dict.echo[int32](SB), AX</div><div class="line">	<span class="number">0</span>x002d <span class="number">00045</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">14</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x002f <span class="number">00047</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">14</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.int32](SB)</div><div class="line">	<span class="number">0</span>x0034 <span class="number">00052</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	LEAQ	<span class="string">""</span>..dict.echo[uint32](SB), AX</div><div class="line">	<span class="number">0</span>x003b <span class="number">00059</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x003d <span class="number">00061</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	NOP</div><div class="line">	<span class="number">0</span>x0040 <span class="number">00064</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.uint32](SB)</div><div class="line">	<span class="number">0</span>x0045 <span class="number">00069</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">16</span>)	LEAQ	<span class="string">""</span>..dict.echo[uint64](SB), AX</div><div class="line">	<span class="number">0</span>x004c <span class="number">00076</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">16</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x004e <span class="number">00078</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">16</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.uint64](SB)</div><div class="line">	<span class="number">0</span>x0053 <span class="number">00083</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	LEAQ	<span class="string">""</span>..dict.echo[string](SB), AX</div><div class="line">	<span class="number">0</span>x005a <span class="number">00090</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	LEAQ	go.string.<span class="string">"hello"</span>(SB), BX</div><div class="line">	<span class="number">0</span>x0061 <span class="number">00097</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	MOVL	$<span class="number">5</span>, CX</div><div class="line">	<span class="number">0</span>x0066 <span class="number">00102</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.string](SB)</div><div class="line">	<span class="number">0</span>x006b <span class="number">00107</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">18</span>)	LEAQ	<span class="string">""</span>..dict.echo[struct{}](SB), AX</div><div class="line">	<span class="number">0</span>x0072 <span class="number">00114</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">18</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.struct{}](SB)</div><div class="line">	<span class="number">0</span>x0077 <span class="number">00119</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	<span class="keyword">CALL</span>	time.Now(SB)</div><div class="line">	<span class="number">0</span>x007c <span class="number">00124</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	AX, <span class="string">""</span>..autotmp_0+<span class="number">40</span>(SP)</div><div class="line">	<span class="number">0</span>x0081 <span class="number">00129</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	BX, <span class="string">""</span>..autotmp_0+<span class="number">48</span>(SP)</div><div class="line">	<span class="number">0</span>x0086 <span class="number">00134</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	CX, <span class="string">""</span>..autotmp_0+<span class="number">56</span>(SP)</div><div class="line">	<span class="number">0</span>x008b <span class="number">00139</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	CX, DI</div><div class="line">	<span class="number">0</span>x008e <span class="number">00142</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	BX, CX</div><div class="line">	<span class="number">0</span>x0091 <span class="number">00145</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	AX, BX</div><div class="line">	<span class="number">0</span>x0094 <span class="number">00148</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	LEAQ	<span class="string">""</span>..dict.echo[time.Time](SB), AX</div><div class="line">	<span class="number">0</span>x009b <span class="number">00155</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	NOP</div><div class="line">	<span class="number">0</span>x00a0 <span class="number">00160</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }](SB)</div><div class="line">	<span class="number">0</span>x00a5 <span class="number">00165</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	MOVQ	<span class="number">64</span>(SP), BP</div><div class="line">	<span class="number">0</span>x00aa <span class="number">00170</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	ADDQ	$<span class="number">72</span>, SP</div><div class="line">	<span class="number">0</span>x00ae <span class="number">00174</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	RET</div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	NOP</div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">1</span>, $-<span class="number">1</span></div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">2</span></div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	<span class="keyword">CALL</span>	<span class="keyword">runtime</span>.morestack_noctxt(SB)</div><div class="line">	<span class="number">0</span>x00b4 <span class="number">00180</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">1</span></div><div class="line">	<span class="number">0</span>x00b4 <span class="number">00180</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	JMP	<span class="number">0</span></div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.<span class="keyword">int</span>] STEXT dupok <span class="keyword">size</span>=<span class="number">268</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.<span class="keyword">int</span>](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c2 <span class="number">00194</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	DI, SI</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.int32] STEXT dupok <span class="keyword">size</span>=<span class="number">266</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.int32](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00bd <span class="number">00189</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVL	$<span class="number">1</span>, DI</div><div class="line">	<span class="number">0</span>x00c2 <span class="number">00194</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	DI, SI</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.uint32] STEXT dupok <span class="keyword">size</span>=<span class="number">266</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.uint32](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.uint64] STEXT dupok <span class="keyword">size</span>=<span class="number">268</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.uint64](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c2 <span class="number">00194</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	DI, SI</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.string] STEXT dupok <span class="keyword">size</span>=<span class="number">295</span> args=<span class="number">0</span>x18 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.string](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">24</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00d6 <span class="number">00214</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">2</span></div><div class="line">	<span class="number">0</span>x00d6 <span class="number">00214</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.struct{}] STEXT dupok <span class="keyword">size</span>=<span class="number">208</span> args=<span class="number">0</span>x8 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.struct{}](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">8</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x0093 <span class="number">00147</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x0093 <span class="number">00147</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line">	<span class="number">0</span>x00cb <span class="number">00203</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	JMP	<span class="number">0</span></div><div class="line">	.................</div><div class="line"><span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }] STEXT dupok <span class="keyword">size</span>=<span class="number">364</span> args=<span class="number">0</span>x20 locals=<span class="number">0</span>xa0 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }](SB), DUPOK|ABIInternal, $<span class="number">160</span>-<span class="number">32</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	CMPL	<span class="keyword">runtime</span>.writeBarrier(SB), $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00cc <span class="number">00204</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	JEQ	<span class="number">208</span></div><div class="line">	<span class="number">0</span>x00ce <span class="number">00206</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	JMP	<span class="number">214</span></div><div class="line">	<span class="number">0</span>x00d0 <span class="number">00208</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	AX, <span class="number">8</span>(CX)</div><div class="line">	<span class="number">0</span>x00d4 <span class="number">00212</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	JMP	<span class="number">221</span></div><div class="line">	<span class="number">0</span>x00d6 <span class="number">00214</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	<span class="keyword">runtime</span>.gcWriteBarrier(SB)</div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x0167 <span class="number">00359</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	JMP	<span class="number">0</span></div><div class="line">	</div><div class="line">...............</div><div class="line"><span class="string">""</span>.echo[.shape.string].stkobj SRODATA <span class="keyword">static</span> <span class="keyword">size</span>=<span class="number">32</span></div><div class="line">	.......</div><div class="line"><span class="string">""</span>.echo[.shape.string].arginfo1 SRODATA <span class="keyword">static</span> dupok <span class="keyword">size</span>=<span class="number">9</span></div><div class="line">	.......           ..........</div><div class="line"><span class="string">""</span>.echo[.shape.struct{}].stkobj SRODATA <span class="keyword">static</span> <span class="keyword">size</span>=<span class="number">32</span></div><div class="line">	.......</div><div class="line"><span class="string">""</span>.echo[.shape.struct{}].arginfo1 SRODATA <span class="keyword">static</span> dupok <span class="keyword">size</span>=<span class="number">5</span></div><div class="line">	.......</div><div class="line"><span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }].stkobj SRODATA <span class="keyword">static</span> <span class="keyword">size</span>=<span class="number">56</span></div><div class="line">	......</div><div class="line"><span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }].arginfo1 SRODATA <span class="keyword">static</span> dupok <span class="keyword">size</span>=<span class="number">11</span></div><div class="line">	<span class="number">0</span>x0000 <span class="number">00</span> <span class="number">08</span> fe <span class="number">08</span> <span class="number">08</span> <span class="number">10</span> <span class="number">08</span> <span class="number">18</span> <span class="number">08</span> fd ff                 ...........</div></pre></td></tr></table></figure>

<h2 id="泛型的性能">泛型的性能</h2>
<p>写一个简单的benchmark程序，没看到明显的性能变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> bench_test</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">    <span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkAdd_Generic(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		add(i, i)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkAdd_NonGeneric(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		addInt(i, i)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> add[T Addable](a, b T) T {</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> addInt(a, b <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(add<span class="number">(1</span>,<span class="number"> 2</span>))</div><div class="line">	fmt.Println(addInt<span class="number">(1</span>,<span class="number"> 2</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md</a></li>
<li><a href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#" target="_blank" rel="external">https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.17中你就可以使用泛型了，可以参考我3月份的文章:<a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a>, 编译的时候需要加<code>-gcflags=-G=3</code>参数，而当前master分支，默认已经支持泛型，不需要加<code>-G=3</code>参数了。</p>
<p>你可以通过下面的步骤尝试go最新分支:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get golang.org/dl/gotip</div><div class="line">gotip download</div></pre></td></tr></table></figure>

<p>编译代码的时候使用<code>gotip</code>替换<code>go</code>命令即可。</p>
<p>随着Go 1.17的发布，最近也涌现了很多的介绍Go泛型的文章，基本上都是简单介绍的文章。</p>
<p>最近Go泛型的变化是增加了两个操作符: <code>~</code>和<code>|</code>：</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<p>这些不是我想介绍的内容，今天我肝一篇介绍Go泛型实现原理的文章，介绍Go泛型实现的方案。</p>
<p>对于一个函数<code>func Echo[T any](t T){}</code>，Go编译器到底编译成了什么代码？</p>
<p>简单的说，当前Go泛型实现的方案和下图中的方案一样：</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2021年Go生态圈rpc框架benchmark]]></title>
    <link href="https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/"/>
    <id>https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/</id>
    <published>2021-08-01T11:08:17.000Z</published>
    <updated>2021-10-06T03:29:34.208Z</updated>
    <content type="html"><![CDATA[<p>有朋友问，每年年初的时候我会发布一个rpc的框架的大比拼，今年为啥没有了？<br><a id="more"></a></p>
<p>有几个原因，一是我去年下半年换了一份工作，熟悉新的业务耗费了很大精力，导致博客文章相对少了，开源的贡献也少了，二是rpcx我自己觉得性能已经很不错了没有想着进一步的优化，所以也没有做相应的benchmark比较。</p>
<p>前几个星期头条的同学推出他们的rpcx框架<a href="https://github.com/cloudwego/kitex" target="_blank" rel="external">kitex</a>,据说性能要比rpcx和grpc好很多，加上今年GopherChina2021大会上他们也分享了他们的netpoll的优化。</p>
<p>本来，我对自定义epoll一类的框架如evio、gnet是不感冒的，因为go本身的net库也是基于epoll实现的，只不过这类框架在处理epoll事件之后的处理和标准库是不一样的。在GopherChina大会上我也和小伙伴说，我担心的这类框架的&quot;长尾效应&quot;,也就是从客户端视角看，大大并发的情况下latency的长尾效应可能是一个很大的痛点。这个话题我一直想专门写一篇文章探讨一下，希望这个秋季能出一篇深度分析标准库和自定义epoll的文章。</p>
<p>当然，既然头条的同学测试kitex性能不错，那么我也就把kitex加入到我的<a href="https://github.com/rpcxio/rpcx-benchmark" target="_blank" rel="external">rpc benchmark项目</a>中了,并且在这个周末也对几种Go rpc框架做了benchmark对比,我想自己测试看看这些框架的性能表现。</p>
<p>当然，每次发表benchmark文章，我都会先声明，没有一个benchmark可以全面的反应这些框架的完整的性能的，更不用说完整的特性了。每个人在使用rpc框架时，面对的场景可能都不同，有些是CPU敏感的服务、有的是IO敏感的服务、有的是内存敏感的服务、有的是读数据库的服务、有的是提供缓存的服务、有些是写文件的服务，消息的长度有大有小、消息的编码格式也不尽相同，有的是同步调用，有的是异步调用，有些是同机房的调用，有些是跨机房的调用，有些用tcp，有些用udp,......,各种各样五花八门，所以没有一种benchmark可以涵盖所有的场景。这次我做的benchmark，也只是覆盖了其中的一种场景。但是幸运的是，这个项目提供了一个框架，可以根据你的场景自己定制，如果你感兴趣，你可以在这个项目的基础上做一些修改，以便和你的使用场景做匹配。</p>
<p>另外，性能只是比较rpc框架的一个方面，千万不要因为测试结果A框架比B框架好就拿去吹嘘，那是幼稚的表现。另外也不可能Go生态圈只有一个框架存在，目前Go生态圈至少有十几个框架存在，各有特色。我个人对于Go生态圈的微服务框架持开放态度，而且也会了解和学习其它框架的优点，让rpcx框架变得更好，我相信·其他开发者也是这么想的。</p>
<p>想比以前的测试，我把Dubbo、Motan、Tarsgo等rpc框架去掉了。我个人不认为这些框架真的适合Go生态群的开发。Go的设计哲学就是简单，这几种框架都需要复杂的配置。当然我知道这些框架原先是Java、C++语言的，只不过为了跨语言才port到Go生态圈，导致这些框架的使用非常的复杂，因为为了保持和主语言的框架的兼容。如果单纯的Go生态圈的使用的话，我还是建议挑选简单可依赖的纯Go生态圈的框架。</p>
<p>为了尽量保持一致的测试环境，所有的框架统一遵循下面的约定：</p>
<ul>
<li>分别测试并发数为100、200、500、1000、2000、5000的场景，测试单个服务在面对不同并发量的情况下的性能。</li>
<li>从客户端统计吞吐率和延迟(latency)</li>
<li>采用共享的client。创建一定数量的client作为client池。</li>
<li>所有的框架都是在“公平”的情况下测试。测试数据都是一致的，采用protobuf进行测试。虽然有比Protobuf性能更好的序列化框架，但是因为不具有通用性所以不考虑。</li>
<li>测试会进行预热。</li>
<li>避免<a href="http://highscalability.com/blog/2015/10/5/your-load-generator-is-probably-lying-to-you-take-the-red-pi.html" target="_blank" rel="external">coordinated omission</a>:测试统计的是等待时间+服务时间,而不是服务端服务时间</li>
<li>统计既包含平均值，也包含P99.9值。</li>
</ul>
<h2 id="测试环境">测试环境</h2>
<ul>
<li>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz,2颗</li>
<li>总物理核 8个， 开超线程逻辑核数为 32个</li>
<li>内存 128G</li>
<li>Go 1.16.6</li>
<li>各框架版本<ul>
<li>arpc: 1.1.5</li>
<li>go std rpc: 1.16.6</li>
<li>grpc: 1.39.0</li>
<li>kitex: 0.0.3</li>
<li>rpcx: 1.6.5</li>
</ul>
</li>
</ul>
<p>测试是在单机上进行的。 坏处就是测试是没有像实际情况一样经过实际网络，而是本机网络支持处理，好处就是我们可以刨去长距离或者不好的网络的影响，只关注于rpc框架的处理。</p>
<h2 id="测试步骤">测试步骤</h2>
<p>生成每个框架的服务端和客户端:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span>  <span class="number">9756450</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">50</span> arpc_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">12800584</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">51</span> gostd_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">12520016</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">52</span> grpc_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11240760</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">53</span> kitex_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11810350</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">54</span> rpcx_server</span></div><div class="line"></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span>  <span class="number">5021980</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">56</span> arpc_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11109233</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">57</span> gostd_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">12581237</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">58</span> grpc_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11559544</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">59</span> kitex_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">16065065</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">18</span><span class="symbol">:</span><span class="number">00</span> rpcx_client</span></div></pre></td></tr></table></figure>

<p>启动服务端:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./xxx_server <span class="operator">-d</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8972</span></div></pre></td></tr></table></figure>

<p>客户端测试(并发数100)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./xxx_client -c <span class="number">1000</span> -n <span class="number">10000000</span> <span class="operator">-s</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8973</span></div></pre></td></tr></table></figure>

<p>每个场景会发送一千万个请求，内容一个不大不小的protobuf编码的数据，服务端收到后会设置某个字段为<code>OK</code>,并返回。没有复杂的计算。</p>
<p>相对于简单的echo 字符串的服务，消息体适中，编码格式通用，业务处理简单，耗时很短吞吐率有保障。</p>
<h2 id="测试结果">测试结果</h2>
<p>当前对5种rpc框架做了测试，有些是普通的rpc服务，比如arpc、Go标准库中的rpc、有些是支持微服务治理的框架如kitex、rpcx，有些是有一些微服务治理的功能如grpc。测试的时候，并没有测试他们的微服务治理的功能，而是只是测试了他们简单的rpc调用。</p>
<p>实际测试是，发现kitex在并发数为2000的时候，客户端调用会有少量出错，并发数为5000时，会有10+%的调用出错。</p>
<h3 id="吞吐率_(越高越好)">吞吐率 (越高越好)</h3>
<p>也就是每秒完成的调用数。</p>
<p><img src="throughputs.png" alt=""></p>
<h3 id="延迟(平均耗时，越小越好)">延迟(平均耗时，越小越好)</h3>
<p>单位毫秒。</p>
<p><img src="latency.png" alt=""></p>
<h3 id="延迟(P99-9耗时，越小越好)">延迟(P99.9耗时，越小越好)</h3>
<p>单位毫秒。</p>
<p><img src="p99.png" alt=""></p>
<h3 id="原始测试数据">原始测试数据</h3>
<p><img src="data.png" alt=""></p>
<h2 id="简单总结">简单总结</h2>
<p>arpc表现亮眼，吞吐率和耗时表现都不错。它是一个类似go web编程风格的rpc框架，采用router和handler的方式实现服务，值的学习。</p>
<p>kitex在并发量小的时候吞吐率要比rpcx要好，随着并发量增多，吞吐率基本差不多，吞吐率在大一些，它的长尾效应很明显P99.9延迟很高，这符合我对自定义epoll框架的推测。如果有小伙伴有不同的想法，欢迎发送评论。</p>
<p>Go标准库rpc框架中规中矩。</p>
<p>rpcx框架表现优异，在各种并发量的情况下都领先，并且没有明显的长尾效应。</p>
<p>grpc本来也是很不错的框架，但是性能和这几位比起来，还稍差一些。</p>
<p>通过这次测试，我对rpcx当前的性能有了一个大致的了解，并且通过对其它rpc框架测试，又进一步优化了rpcx的性能。</p>
<blockquote>
<p>可能这个测试对于基于netpoll的kitex不&quot;公平&quot;，我的理解是自定义netpoll适合那种有巨量socket连接，并发量适中的场景。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>有朋友问，每年年初的时候我会发布一个rpc的框架的大比拼，今年为啥没有了？<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]更新Go内存模型]]></title>
    <link href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/"/>
    <id>https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/</id>
    <published>2021-07-13T09:53:00.000Z</published>
    <updated>2021-10-06T03:29:34.174Z</updated>
    <content type="html"><![CDATA[<p>这是Russ Cox的系列论文的第三篇，也是最后一篇: <a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>。</p>
<p>文章对 官方的Go内存模型做了一些补充和思考。</p>
<a id="more"></a>
<p><img src="gophers-racing.jpeg" alt=""></p>
<p>当前的Go语言内存模型是在2009年编写的，从那以后略有更新。很明显，至少有一些细节我们应该添加到当前的内存这个内存模型中，其中包括对竞态检测器的明确认可，以及关于sync/atomic中的API是如何同步程序的清晰声明。</p>
<p>这篇文章重申了Go的总体哲学和当前的内存模型，然后概述了我认为我们应该对Go内存模型进行的相对较小的调整。假定你已经了解了前两篇文章<a href="https://colobu.com/2021/06/30/hwmm/" target="_blank" rel="external">“硬件内存模型”</a>和<a href="https://colobu.com/2021/07/11/Programming-Language-Memory-Models/" target="_blank" rel="external">“编程语言内存模型”</a>中的背景知识。</p>
<p>我已经开启了一个<a href="https://golang.org/s/mm-discuss" target="_blank" rel="external">GitHub讨论项目</a>来收集对反馈。根据这些反馈，我打算在本月晚些时候准备一份正式的Go提案。使用GitHub讨论本身就是一个实验，我还会继续尝试<a href="https://research.swtch.com/proposals-discuss" target="_blank" rel="external">找到一个合理的方法来扩大这些重要变化的讨论</a>。</p>
<h2 id="Go_设计哲学">Go 设计哲学</h2>
<p>Go旨在成为构建实用、高效系统的编程环境。它的目标是为小型项目的轻量级开发语言，但也可以优雅地扩展到大型项目和大型工程团队。</p>
<p>Go鼓励在高层次上处理并发，特别是通过通信。第一句Go箴言(<a href="https://go-proverbs.github.io/" target="_blank" rel="external">Go proverb</a>)就是“不要通过共享内存来通信，而是通过通信共享内存。”另一个流行的谚语是“清晰胜于聪明。”换句话说，Go鼓励通过避免使用巧妙的代码来避免狡猾的bug。</p>
<p>Go的目标不仅仅是可以理解的程序，还包括可以理解的语言和可以理解的package API。复杂或巧妙的语言特征或API与这一目标相矛盾。正如Tony Hoare在1980年<a href="https://www.cs.fsu.edu/~engelen/courses/COP4610/hoare.pdf" target="_blank" rel="external">图灵奖演讲</a>中所说:</p>
<blockquote>
<p>I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.</p>
<p>我的结论是，构建软件设计有两种方法:一种方法是简单实现，以至于明显没有缺陷；另一种方法是异常复杂，以至于没有明显缺陷。</p>
</blockquote>
<p>第一种方法要困难得多。它需要同样的技巧、奉献、洞察力，甚至是灵感，就像发现构成复杂自然现象基础的简单物理定律一样。它还要求愿意接受受物理、逻辑和技术限制的目标，并在冲突的目标无法实现时接受妥协。</p>
<p>这与Go的设计API的理念非常吻合。我们通常在设计过程中花很长时间来确保一个应用编程接口是正确的，并努力将其简化为最基本、最有用的精华。</p>
<p>Go作为一个有用的编程环境的另一方面是为最常见编程错误有定义明确的语义，这有助于理解和调试。这个想法并不新鲜。再次引用Tony Hoare的话，这是来自他1972年的“软件质量”检查单:</p>
<blockquote>
<p>As well as being very simple to use, a software program must be very difficult to misuse; it must be kind to programming errors, giving clear indication of their occurrence, and never becoming unpredictable in its effects.</p>
<p>一个软件程序不仅使用起来非常简单，而且很难被误用；它必须友好对待编程错误，给出它们发生的明确指示，并且其影响永远不会变得不可预测。</p>
</blockquote>
<p>为有问题的程序定义良好的语义，这种常识并不像人们预期的那样普遍。在C/C++中，未定义的行为已经演变成一种编译器作者的全权委托，以越来越有趣的方式将有轻微问题的程序转换成有大问题的程序。Go不采用这种方法:不存在“未定义的行为”。特别是，像空指针取消引用、整数溢出和无意的无限循环这样的错误都在Go中定义了语义。</p>
<h2 id="当前的_Go内存模型">当前的 Go内存模型</h2>
<p>Go的内存模型始于以下建议，符合Go的总体哲学:</p>
<ul>
<li>修改由多个goroutines同时访问的数据的程序必须串行化这些访问。</li>
<li>为了实现串行访问, 需要使用channel操作或其他同步原语(如sync和sync/atomic包中的原语)来保护数据。</li>
<li>如果你必须阅读本文的其余部分才能理解你的程序的行为，那你太聪明了。</li>
<li>别自作聪明。</li>
</ul>
<p>这仍然是个好建议。该建议也与其他语言对DRF-SC的鼓励使用一致:同步以消除数据竞争，然后程序将表现得好像顺序一致，不需要理解内存模型的其余部分。</p>
<p>根据这个建议，Go内存模型定义了一个传统的基于happens-before对读写竞争的定义。像在Java和JavaScript中一样，在Go中的读操作可以观察到任何更早但尚未被覆盖的写操作，或者任何竞争的写操作；仅安排一个这样的写入会强制产生指定的结果。</p>
<p>然后，内存模型继续定义同步操作，这些操作建立交替执行的goroutine的happen-before关系。操作尽管稀松平常，但是还是带有一些Go特有的风格:</p>
<ul>
<li>如果package <strong>p</strong>引入了package <strong>q</strong>,那么<strong>q</strong>的init函数的执行完成一定happen-before <strong>p</strong>的所有init函数(之前)</li>
<li><strong>main.main</strong> 函数一定 happen after 所有的init函数完成(之后)</li>
<li>go语句创建一个goroutine一定happen before goroutine执行(之前)</li>
<li>往一个channel中send happen before 从这个channel receive这个数据完成(之前)</li>
<li>一个channel的close一定happen before 从这个channel receive到零值数据(这里指因为close而返回的零值数据)</li>
<li>从一个unbuffered channel的receive一定happen before 往这个channel send完成(之前)</li>
<li>从容量为C的channel receive第k个数据一定happen before第k+C次send完成(之前)</li>
<li>对于任意的<strong>sync.Mutex</strong>或者<strong>sync.RWMutex</strong>类型的变量l以及n &lt; m, 调用第n次l.UnLock()一定happen before 第m次的l.Lock()返回(之前)</li>
<li>once.Do(f)中的对f的单次调用一定happen before 任意次的对once.Do(f)调用返回(之前)</li>
</ul>
<p>值得注意的是，这个列表忽略了package sync中新加的API以及sync/atomic的API。</p>
<p>Go内存模型规范以一些不正确同步的例子结束。它没有包含错误编译的例子。</p>
<h2 id="对Go内存模型做的改变">对Go内存模型做的改变</h2>
<p>2009年，当我们着手编写Go的内存模型时，Java内存模型进行了新的修订，C/C++11内存模型正在定稿。一些人强烈鼓励我们采用C/C++11模型，并充分利用了其已经完成的所有工作。对我们来说这似乎很冒险。相反，我们决定采用一种更保守的方法来保证我们要做的，这一决定得到了随后十年详细描述Java/C/C++内存模型中非常狡猾问题的论文的证实。是的，定义足够充分的内存模型来指导程序员和编译器作者是很重要的，但是完全正式地定义一个正确的内存模型似乎仍然超出了最有才华的研究人员的能力范围。Go定义一个最小的需求就足够了。</p>
<p>下面这一部分列出了我认为我们应该做的调整。如前所述，我已经开启了一个<a href="https://golang.org/s/mm-discuss" target="_blank" rel="external">GitHub讨论项</a>来收集反馈。根据这些反馈，我计划在本月晚些时候准备一份正式的Go提案。</p>
<h3 id="文档化Go的整体方法">文档化Go的整体方法</h3>
<p>“不要聪明”的建议很重要，应该坚持下去，但我们也需要在深入研究happen before细节之前，对Go的整体方法更多的谈一谈。我看到过很多关于Go方法的不正确总结，比如宣称Go的模型是C/C++的“DRF-SC或Catch Fire”。 这种误会是可以理解的: Go内存模型规范没有说它的方法是什么，而且它是如此之短(材料又如此微妙)，以至于人们看到了他们期望看到的东西，而不是那里有什么或没有什么。</p>
<p>拟在Go内存模型规范中增加的文档大致如下:</p>
<blockquote>
<h2 id="概观">概观</h2>
<p>Go以与本语言其余部分几乎相同的方式处理其内存模型，旨在保持语义简单、可理解和有用。</p>
<p>数据竞争被定义为对存储器位置的写入与对同一位置的另一次读取或写入同时发生，除非所有访问都是由sync/atomic package提供的原子数据访问提供。如前所述，强烈建议程序员使用适当的同步来避免数据竞争。在没有数据竞争的情况下，Go程序表现得好像所有的gorouitine都被多路复用到一个处理器上。这个属性有时被称为DRF-SC:无数据竞争的程序以顺序一致的方式执行。</p>
<p>其他编程语言通常采用两种方法之一来处理包含数据竞争的程序。第一，以C和C++为例，带有数据竞争的程序是无效的:编译器可能会以任意令人惊讶的方式中断它们。第二，以Java和JavaScript为例，具有数据竞争的程序定义了语义，通过限制竞争的可能影响，使程序更加可靠和易于调试。Go的方法介于这两者之间。具有数据竞争的程序是无效的，因为语言实现可能会报告竞争并终止程序。但另一方面，具有数据竞争的程序定义了具有有限数量结果的语义，使得错误的程序更可靠，更容易调试。</p>
</blockquote>
<p>这些文字应该阐明Go和其他语言有什么不同，纠正读者先前的任何期望。</p>
<p>在“happen before”一节的最后，我们还应该澄清某些竞争仍然会导致内存损坏。当前它以下面的句子结束：</p>
<blockquote>
<p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p>
</blockquote>
<p>我们应该加上一点:</p>
<blockquote>
<p>请注意，这意味着多word数据结构上的竞争可能导致单次写入产生不一致值。当值依赖于内部(指针、长度)或(指针、类型)pair的一致性时，就像大多数Go实现中的接口、map、切片和字符串的情况一样，这种竞争又会导致内存损坏。</p>
</blockquote>
<p>这将更清楚地说明保证对具有数据竞争的程序的限制。</p>
<h3 id="文档化_sync库的happen_before">文档化 sync库的happen before</h3>
<p>自从Go内存模型发布以来，一些新的API已经被添加到sync包中。我们需要将它们添加到内存模型中(<a href="https://golang.org/issue/7948" target="_blank" rel="external">issue#7948</a>)。谢天谢地谢广坤，增加的内容看起来很简单。我相信它们应该如下：</p>
<ul>
<li>对于sync.Cond, <strong>Broadcast</strong> 和 <strong>Signal</strong> 一定happen before 它解锁的Wait方法调用完成(之前)</li>
<li>对于sync.Map, Load, LoadAndDelete 和 LoadOrStore 都是读操作， Delete、LoadAndDelete和 Store都是写操作。LoadOrStore当它的loaded返回false时是写操作。一个写操作happen before 能观察到这个写操作的读操作(之前)</li>
<li>对于sync.Pool,对Put(x)的调用一定happen before Get方法返回这个x(之前)。同样的，返回x的New方法一定happen before Get方法返回这个x(之前)</li>
<li>对于sync.EWaitGroup, Done方法的调用一定happen before 它解锁的Wait方法调用返回(之前)</li>
</ul>
<p>这些API的用户需要知道保证，以便有效地使用它们。因此，虽然我们应该将这些文字保留在内存模型中以供介绍，但我们也应该将其包含在package sync的文档注释中。这也将有助于为第三方同步原语树立一个榜样，说明记录由API建立的顺序保证的重要性。</p>
<h3 id="文档话_sync/atomic的happen_before">文档话 sync/atomic的happen before</h3>
<p>Atomic operations are missing from the memory model. We need to add them (issue #5045). I believe we should say:</p>
<p>内存模型中缺少原子操作的保证。我们需要添加它们(<a href="https://golang.org/issue/5045" target="_blank" rel="external">issue #5045</a>)。我认为我们应该说:</p>
<blockquote>
<p>sync/atomic package中的API统称为“原子操作”，可用于同步各种goroutine执行。如果原子操作A的效果被原子操作B观察到，那么A发生在B之前(happen before)。在一个程序中执行的所有原子操作表现得好像是以某种顺序一致的顺序执行的。</p>
</blockquote>
<p>这是Dmitri Vyukov在2013年提出的建议，也是我在2016年非正式承诺的。它还与Java的volatiles和C++的默认原子具有相同的语义。</p>
<p>就C/C++而言，同步原子只有两种选择:顺序一致或acquire/release(Relaxed原子不会创建happen before，因此没有同步效果). 对这两者的决策归结为，第一，能够推理出多个位置上原子操作的相对顺序有多重要，第二，顺序一致的原子与acquire/release原子相比要多昂贵(慢)。</p>
<p>首先要考虑的是，关于多个位置上原子操作的相对顺序的推理非常重要。在之前的一篇文章中，我举了一个使用两个原子变量实现的无锁快速路径的条件变量的<a href="https://research.swtch.com/plmm#cond" target="_blank" rel="external">例子</a>，这两个原子变量被使用acuqire/release原子打破了。这种模式反复出现。例如，sync.WaitGroup曾经的实现使用了一对<a href="https://go.googlesource.com/go/+/ee6e1a3ff77a41eff5a606a5aa8c46bf8b571a13/src/pkg/sync/waitgroup.go#54" target="_blank" rel="external">原子uint32值</a>：wg.counter和wg.waiters。<a href="https://go.googlesource.com/go/+/cf148f3d468f4d0648e7fc6d2858d2afdc37f70d/src/runtime/sema.go#134" target="_blank" rel="external">Go运行时中的信号量的实现</a>也依赖于两个独立的原子word，即信号量值*addr和相应的waiter count root.nwait。还有更多。在缺乏顺序一致的语义的情况下(也就是说，如果我们改为采用acquire/release语义)，人们仍然会像这样错误地编写代码；它会神秘地失败，而且只在特定的情况下。</p>
<p>根本的问题是，使用acuqire/release原子使无数据竞争的程序不会导致程序以顺序一致的方式运行，因为原子本身不会提供保证。也就是说，这样的程序不提供DRF-SC。这使得这种程序很难推理，因此很难正确编写。</p>
<p>关于第二个考虑，正如在之前的文章中提到的，硬件设计人员开始为顺序一致的原子提供直接支持。例如，ARMv8添加了ldar和stlr指令来实现顺序一致的原子，它们也是acquire/release原子的推荐实现。如果我们为sync/atomic采用acquire/release语义，那么写在ARMv8上的程序无论如何都会获得顺序一致性。这无疑会导致依赖更强顺序的程序意外地在更弱的平台上崩溃。，如果由于竞争窗口很小, acquire/release和结果一致的原子之间的差异在实践中很难观察到，这甚至可能发生在单个架构上。</p>
<p>这两种考虑都强烈建议我们应该采用顺序一致的原子而不是acquire/release原子:顺序一致的原子更有用，一些芯片已经完全缩小了这两个级别之间的差距。如果差距很大，想必其他人也会这么做。</p>
<p>同样的考虑，以及Go拥有小型、易于理解的API的总体哲学，所有这一切都反对将acuqire/release作为一套额外的并行API来提供。似乎最好只提供最容易理解的，最有用的，很难被误用的原子操作。</p>
<p>另一种可能性是提供原始屏障，而不是原子操作(当然，C++两者都提供)。屏障的缺点是使期望变得不那么清晰，并且在某种程度上更加局限于特定的体系结构。Hans Boehm文章<a href="http://www.hboehm.info/c++mm/ordering_integrated.html" target="_blank" rel="external">“Why atomics have integrated ordering constraints”</a>给出了提供原子而不是屏障的论点(他使用术语栅栏fence)。一般来说，原子比栅栏更容易理解，而且由于我们现在已经提供了原子操作，所以我们不能轻易移除它们。一个机制要比提供两个好。</p>
<h3 id="可能的改变：_为sync/atomic提供类型化的API">可能的改变： 为sync/atomic提供类型化的API</h3>
<p>上面的定义说，当一个特定的内存块必须由多个线程同时访问而没有其他同步时，消除争用的唯一方法是让所有的访问都使用原子。仅仅让一些访问使用原子是不够的。例如，与原子读或写并发的非原子写仍然是s数据竞争，与非原子读或写并发的原子写也是数据竞争。</p>
<p>因此，一个特定的值是否应该用atomic访问是该值的属性，而不是特定的访问。正因为如此，大多数语言将这些信息放在类型系统中，比如Java的volatile int和C++的atomic<int>。Go当前的API没有，这意味着正确的使用需要仔细标注结构或全局变量的哪些字段预计只能使用原子API来访问。</int></p>
<blockquote>
<p>译者按: uber提供了类似的库<a href="https://github.com/uber-go/atomic" target="_blank" rel="external">uber-go/atomic</a>。</p>
</blockquote>
<p>为了提高程序的正确性，我开始认为Go应该定义一组类型化的原子值，类似于当前的原子值。值:Bool、Int、Uint、Int32、Uint32、Int64、Uint64和Uintptr。像Value一样，它们也有CompareAndSwap、Load、Store和Swap方法。例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Int32 <span class="keyword">struct</span> { v <span class="typename">int32</span> }</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Add(delta <span class="typename">int32</span>) <span class="typename">int32</span> {</div><div class="line">	<span class="keyword">return</span> AddInt32(&i.v, delta)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) CompareAndSwap(old, <span class="built_in">new</span> <span class="typename">int32</span>) (swapped <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">return</span> CompareAndSwapInt32(&i.v, old, <span class="built_in">new</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Load() <span class="typename">int32</span> {</div><div class="line">	<span class="keyword">return</span> LoadInt32(&i.v)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Store(v <span class="typename">int32</span>) {</div><div class="line">	<span class="keyword">return</span> StoreInt32(&i.v, v)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Swap(<span class="built_in">new</span> <span class="typename">int32</span>) (old <span class="typename">int32</span>) {</div><div class="line">	<span class="keyword">return</span> SwapInt32(&i.v, <span class="built_in">new</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我将Bool包括在列表中，因为我们在Go标准库中多次用原子整数构造了原子Bool(在未暴露的API中)。显然是有需要的。</p>
<p>我们还可以利用即将到来的泛型支持，并为原子指针定义一个API，该API是类型化的，并且在其API中没有包不安全:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Pointer[T any] <span class="keyword">struct</span> { v *T }</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pointer[T]) CompareAndSwap(old, <span class="built_in">new</span> *T) (swapped <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">return</span> CompareAndSwapPointer(... lots of unsafe ...)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>(以此类推),你可能会想到不能使用泛型定义一个类型吗？我没有看到一个干净的方法使用泛型来实现atomic.Atomic[T]，避免我们引入Bool、Int等作为单独的类型。走走看吧。</p>
<h3 id="可能的改变:_增加非同步的atomic">可能的改变: 增加非同步的atomic</h3>
<p>所有其他现代编程语言都提供了一种方法来进行并发内存读写，这种方法不会使程序同步，但也不会使程序无效(不会算作数据竞争)。C、C++、Rust和Swift都有relaxed原子。Java有VarHandle的“普通”模式。JavaScript对共享内存缓冲区(唯一的共享内存)有非原子的访问权限。Go没有办法做到这一点。或许应该有，我不知道。</p>
<p>如果我们想添加非同步的原子读写，我们可以向类型化的原子添加UnsyncAdd、UnsyncCompareAndSwap、UnsyncLoad、UnsyncStore和 UnsyncSwap方法。将它们命名为“unsync”避免了一些“relaxed”名称的问题。首先，有些人用relaxed作为相对的比较，如“acquire/release是比顺序一致性更宽松的内存顺序。”你可以说这不是这个术语的恰当用法，但它确实发生了。其次，也是更重要的，这些操作的关键细节不是操作本身的内存排序，而是它们对程序其余部分的同步没有影响。对于不是内存模型专家的人来说，看到UnsyncLoad应该清楚没有同步，而RelaxedLoad可能不会。在人群中喵一眼Unsync也知道它是不安全的。</p>
<p>有了API，真正的问题是到底要不要添加这些。对提供非同步原子的争论是，它确实对某些数据结构中快速路径的性能有影响。我的总体印象是，它在非x86架构上最重要，尽管我没有数据来支持这一点。不提供不同步的原子可以被认为是对那些架构的惩罚。</p>
<p>反对提供非同步原子的一个可能的争论是，在x86上，忽略了潜在的编译器重组的影响，非同步原子与acquire/release原子是无法区分的。因此，他们可能会被滥用来编写只适用于x86的代码。反驳的理由是，这样的花招不会通过race检测器，它实现的是实际的内存模型，而不是x86内存模型。</p>
<p>由于缺乏证据，我们没有理由添加这个API。如果有人强烈认为我们应该添加它，那么证明这一点的方法是收集两方面的证据:(1)程序员需要编写的代码的普遍适用性，以及(2)使用非同步原子对广泛使用的系统产生的显著性能改进。(使用Go以外的语言的程序来显示这一点是很好的。)</p>
<h3 id="文档化对编译器优化的禁止项">文档化对编译器优化的禁止项</h3>
<p>当前的内存模型最后给出了无效程序的例子。由于内存模型是程序员和编译器作者之间的契约，我们应该添加无效编译器优化的例子。例如，我们可以添加:</p>
<h4 id="不正确的编译">不正确的编译</h4>
<p>Go内存模型和Go程序一样限制编译器优化。一些在单线程程序中有效的编译器优化在Go程序中是无效。特别是，编译器不能在无竞争程序中引入数据竞争。它不能允许单次读取观察到多个值。并且它不能允许一个写操作写入多个值。</p>
<p>Not introducing data races into race-free programs means not moving reads or writes out of conditional statements in which they appear. For example, a compiler must not invert the conditional in this program:</p>
<p>不在无竞争程序中引入数据竞争意味着不移动出现条件语句的读或写。例如，编译器不得反转该程序中的条件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"><span class="keyword">if</span> cond {</div><div class="line">	i = *p</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是说，编译器不能将程序重写为这个:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i := *p</div><div class="line"><span class="keyword">if</span> !cond {</div><div class="line">	i =<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果cond为false，另一个goroutine正在写*p，那么原始程序是无竞争的，但是重写的程序包含竞争。</p>
<p>不引入数据竞争也意味着不假设循环终止。例如，在这个程序中，编译器不能将对<em>p或</em>q访问移动到循环前面:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">n :=<span class="number"> 0</span></div><div class="line"><span class="keyword">for</span> e := list; e != <span class="constant">nil</span>; e = e.next {</div><div class="line">	n++</div><div class="line">}</div><div class="line">i := *p</div><div class="line">*q =<span class="number"> 1</span></div></pre></td></tr></table></figure>

<p>如果列表指向循环列表，那么原始程序永远不会访问<em>p或</em>q，但是重写的程序会。</p>
<p>不引入数据竞争也意味着不假设被调用的函数总是返回或者没有同步操作。例如，在这个程序中，编译器不能移动对<em>p或</em>q访问到函数调用之前:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f()</div><div class="line">i := *p</div><div class="line">*q =<span class="number"> 1</span></div></pre></td></tr></table></figure>

<p>如果调用从未返回，那么原始程序将不会再访问<em>p或</em>q，但是重写的程序会。如果调用包含同步操作，那么原始程序可以建立f和<em>p/</em>q的happen before关系，但是重写的程序就破坏了这个关系。</p>
<p>不允许单次读取观察多个值,意味着不从共享内存中重新加载局部变量。例如，在这个程序中，编译器不能扔掉(spill)i,并重新加载它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i := *p</div><div class="line"><span class="keyword">if</span> i &lt;<span class="number"> 0</span> || i &gt;= <span class="built_in">len</span>(funcs) {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"invalid function index"</span>)</div><div class="line">}</div><div class="line">... <span class="built_in">complex</span> code ...</div><div class="line"><span class="comment">// compiler must NOT reload i = *p here</span></div><div class="line">funcs[i]()</div></pre></td></tr></table></figure>

<p>如果复杂的代码需要许多寄存器，单线程程序的编译器可以在不保存副本的情况下丢弃i，然后在funcs<a href="">i</a>之前重新加载i = <em>p。Go编译器不能，因为</em>p的值可能已经更改。(相反，编译器可能会将i移动到栈上)。</p>
<p>不允许一次写操作写入多个值也意味着不使用在写入之前将本地变量作为临时存储写入的内存。例如，编译器不得在此程序中使用*p作为临时存储:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*p = i + *p<span class="number">/2</span></div></pre></td></tr></table></figure>

<p>也就是说，它绝不能把程序改写成这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p /=<span class="number"> 2</span></div><div class="line">*p += i</div></pre></td></tr></table></figure>

<p>如果i和<em>p开始等于2，则原始代码最终</em>p = 3，但是一个竞争线程只能从<em>p读取2或3。重写后的代码最终</em>p = 1，然后*p = 3，这也允许竞争线程读取1。</p>
<p>请注意，所有这些优化在C/C++编译器中都是允许的:与C/C++编译器共享后端的Go编译器必须注意禁用对Go无效的优化。</p>
<p>这些分类和示例涵盖了最常见的C/C++编译器优化，这些优化与为竞争数据访问定义的语义不兼容。他们明确规定Go和C/C++有不同的要求。</p>
<h2 id="结论">结论</h2>
<p>Go在其内存模型中保守的方法很好地服务了我们，应该继续下去。然而，有一些早该做的更改，包括定义sync和sync/package package中新API的同步行为。特别是atomic的内存模型应该被文档化，其以提供顺序一致的行为，这种行为创建了与它们左右的非原子代码同步的happen before关系。这与所有其他现代系统语言提供的默认原子相匹配。</p>
<p>也许更新中最独特的部分是清楚地声明具有数据竞争的程序可能会被停止以报告竞争，但是在其他方面具有明确定义的语义。这约束了程序员和编译器，它优先考虑并发程序的可调试性和正确性，而不是编译器编写者的便利性。</p>
<h2 id="感谢">感谢</h2>
<p>这一系列的帖子从我有幸在谷歌工作的一长串工程师的讨论和反馈中受益匪浅。我感谢他们。我对任何错误或不受欢迎的意见负全部责任。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Russ Cox的系列论文的第三篇，也是最后一篇: <a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>。</p>
<p>文章对 官方的Go内存模型做了一些补充和思考。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]编程语言内存模型]]></title>
    <link href="https://colobu.com/2021/07/11/Programming-Language-Memory-Models/"/>
    <id>https://colobu.com/2021/07/11/Programming-Language-Memory-Models/</id>
    <published>2021-07-11T12:53:32.000Z</published>
    <updated>2021-10-06T03:29:34.129Z</updated>
    <content type="html"><![CDATA[<p>这是Russ Cox的第二篇<a href="https://research.swtch.com/plmm" target="_blank" rel="external">Programming Language Memory Models</a>。</p>
<p>如果你已经阅读了前一篇<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">硬件内存模型</a>,以及如果有Java内存模型或者C++内存模型的经验，本文还好理解，如果你没有相关经验，可能阅读起来比较费劲，建议先阅读一下相关的材料。论文有些词句比较难以理解，本人才学疏浅，有翻译不当之处欢迎批评指正。</p>
<a id="more"></a>
<p>编程语言内存模型回答了并行程序可以依靠什么行为以便它们的线程之间可以共享内存的问题。例如，考虑下面这个类似C语言的程序，其中x和done都从零开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>程序试图通过变量x从线程1向线程2发送一条消息(x)，使用done作为信号，通知线程2消息已经准备好被接收。如果线程1和线程2都运行在自己的专用处理器上，并且都运行完成，那么这个程序是否保证能够按照预期完成并打印1？编程语言内存模型回答了这个问题，以及其它类似问题。</p>
<p>Although each programming language differs in the details, a few general answers are true of essentially all modern multithreaded languages, including C, C++, Go, Java, JavaScript, Rust, and Swift:</p>
<p>尽管每种编程语言在细节上有所不同，但是一些通用答案基本上适用于所有现代多线程语言，包括C、C++、Go、Java、JavaScript、Rust和Swift:</p>
<ul>
<li>首先，如果x和done是普通变量，那么线程2的循环可能永远不会停止。一种常见的编译器优化是在变量首次使用时将其加载到寄存器中，然后尽可能长时间地重用该寄存器，以便将来访问该变量。如果线程2在线程1执行之前将done复制到一个寄存器中，它可能会在整个循环中一直使用该寄存器，永远不会注意到线程1后来修改了done。</li>
<li>其次，即使线程2的循环会停止，也就是观察到done == 1，它仍然可能打印x的值为0。编译器通常会根据优化试探法甚至是生成代码时使用哈希表或其他中间数据结构的方式，对程序读写进行重新排序。线程1的编译代码可能在done赋值之后而不是之前写入x，或者线程2的编译代码也可能在循环前读取x。</li>
</ul>
<p>既然这个程序有并发问题，那么问题是如何修复它。</p>
<p>现代语言以原子变量(atomic variable)或原子操作(atomic operation)的形式提供特殊能力，允许程序同步其线程。如果我们使用一个原子变量实现done(或者用原子操作来操作它)，那么我们的程序保证会执行完成并打印1。使用原子变量或者原子操作会产生很多效果：</p>
<ul>
<li>线程1的编译代码必须确保对x的写入完成，并且在对done的写入可见之前对x的写入对其他线程可见。</li>
<li>线程2的编译代码必须在循环的每次迭代中(重新)读取done。</li>
<li>线程2的编译代码必须在读取done之后才读取x。</li>
<li>编译后的代码必须做任何必要的事情来禁用可能会重新引入这些问题的硬件优化</li>
<li></li>
</ul>
<p>使done原子化的最终结果是程序按照我们想要的方式运行，成功地将x的值从线程1传递到线程2。</p>
<p>在最初始的程序中，在编译器的代码重新排序之后，线程1可能会在线程2读取x的同时写x。这是data race问题。在修改后的程序中，原子变量done用于同步对x的访问:线程1现在不可能在线程2读取x的同时写入x。这个程序没有数据竞争。一般来说，现代语言保证了无数据竞争的程序总是以顺序一致（sequentially consistent）的方式执行，就好像来自不同线程的操作被随意地但没有重新排序地转移到单个处理器上一样。这是硬件内存模型的<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">DRF-SC属性</a>，在编程语言环境中采用。</p>
<p>另外，这些原子变量或原子操作更恰当应该称之为“同步原子”(synchronizing atomic)，在数据库的意义上，操作是原子的，允许同时进行读和写，就像以某种顺序按顺序运行一样:当使用原子时，普通变量上的竞争不是竞争。但更重要的是，atomic同步了程序的其余部分，提供了一种消除非原子数据竞争的方法。标准术语就是“atomic”，也就是这篇文章使用的属于。除非另有说明，请记住将“原子”理解为“同步原子”。</p>
<p>编程语言内存模型规定了程序员和编译器所需的额外细节，作为他们之间的约定。上面谈到的通用特征基本上适用于所有现代语言，但直到最近，事情才收敛到一点:在21世纪初，有明显更多的变种。即使在今天，各种语言在更多的排序问题上也有显著的差异，包括:</p>
<ul>
<li>原子变量们本身的排序保证是什么？</li>
<li>变量是否既可以原子访问，有可以非原子访问？</li>
<li>除了原子之外是否还有其它同步机制？</li>
<li>是否存在不同步的原子操作？</li>
<li>有数据竞争的程序有什么保证？</li>
</ul>
<p>在做了一些准备之后，这篇文章的剩余部分将探讨不同的语言如何回答这些相关的问题，以及它们解决这些问题之道。这篇文章介绍探索路上的许多错误初始设计，强调我们仍然在学习啥是有效的方案，啥是无效的方案</p>
<h2 id="硬件、Litmus_Tests、Happens_Before_和_DRF-SC">硬件、Litmus Tests、Happens Before 和 DRF-SC</h2>
<p>在我们了解任何特定语言的细节之前，我们需要记住<a href="https://colobu.com/2021/06/30/hwmm/" target="_blank" rel="external">硬件内存模型</a>的简要经验总结。</p>
<blockquote>
<p>不同的CPU体系架构允许不同数量的指令重新排序，因此在多个处理器上并行运行的代码可以根据体系架构的不同有不同的结果。黄金标准是<a href="https://colobu.com/2021/06/30/hwmm/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">顺序一致性</a>，即任何执行都必须表现得好像在不同处理器上执行的程序只是以某种顺序交替在单个处理器上执行。对于开发人员来说，这种模型更容易推理，但是今天没有重要的架构能够提供这种模型，因为提供较弱的并发保证能够足够的性能。</p>
</blockquote>
<p>很难对不同的内存模型做出完全通用的比较。反过来我们可以关注特定的测试用例，称为Litmus Test。如果两个内存模型通过Litmus Test有不同的行为，那么可以证明它们是不同的，并且通常可以帮助我们判断，至少对于那个测试用例，一个模型比另一个模型是弱还是强。例如，这是我们之前检查的程序的Litmus Test:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: <span class="keyword">Message</span> Passing</div><div class="line">Can this <span class="keyword">program</span> see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div><div class="line"><span class="keyword">On</span> sequentially consistent hardware: no.</div><div class="line"><span class="keyword">On</span> x86 (<span class="keyword">or</span> other TSO): no.</div><div class="line"><span class="keyword">On</span> ARM/POWER: yes!</div><div class="line"><span class="keyword">In</span> any modern compiled language using ordinary variables: yes!</div></pre></td></tr></table></figure>

<p>和前一篇文章一样，我们假设每个例子一开始所有共享变量都为零。rN这个名字表示私有存储，如寄存器或函数变量；像x和y这样的名称是共享(全局)变量。我们问在执行结束时，寄存器的特定设置是否存在可能。在回答硬件的litmus test时，我们假设没有编译器对线程中发生的事情进行重新排序:清单中的指令被直接翻译成汇编指令，交给处理器执行。</p>
<p>结果r1 = 1，r2 = 0代表原始程序的线程2完成了循环(这里简化了循环，而是简单的使用y进行赋值)，但随后打印0。这个结果在程序操作的任何顺序一致的交替执行中是不可能的。对于汇编语言版本，在x86上打印0是不可能的，尽管由于处理器本身的重新排序优化，在ARM和POWER等更宽松的架构上打印0是可能的。在现代语言中，编译期间可能发生的重新排序使得这种结果成为可能，不管底层硬件是什么。</p>
<p>正如我们前面提到的，今天的处理器不保证顺序一致性，而是保证一种称为<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">“无数据竞争的顺序一致性”或DRF-DRF(有时也写成SC-DRF)</a>的属性。一个保证DRF-SC的系统必须提供被称为同步指令的特定指令，它提供了一种协调不同处理器(相当于线程)的方法。程序使用这些指令在一个处理器上运行的代码和另一个处理器上运行的代码之间创建一种“happens before”的关系。</p>
<p>例如，这里描述了一个程序在两个线程上的短暂执行；像以前一样，假设每个处理器都有自己的专用处理器:</p>
<p><img src="mem-adve-4.png" alt=""></p>
<p>我们在之前的帖子里也看到了这个程序。线程1和线程2执行同步指令。在这个特定执行中，两条S(a)指令建立了从线程1到线程2的happens-before关系，因此线程1中的W(x)发生在线程2中的R(x)之前。</p>
<p>不同处理器上的两个事件，如果不是按照happens-before的顺序排序，可能会同时发生:确切的顺序搞不清楚。我们说它们同时执行。数据竞争（data race）是指对一个变量的写操作与对同一变量的读操作或写操作同时执行。提供DRF-SC的处理器保证没有数据竞争的程序行为就像它们在一个顺序一致的架构上运行一样。这是在现代处理器上编写正确的多线程汇编程序的基本保证。</p>
<p>正如我们前面所看到的，DRF-SC也是现代语言所采用的基本保证，使得用更高级别语言编写正确的多线程程序成为可能。</p>
<h2 id="编译器和优化">编译器和优化</h2>
<p>我们已经提到过几次，编译器可能会在生成最终可执行代码的过程中对输入程序中的操作重新排序。让我们仔细看看这个声明和其他可能导致问题的优化。</p>
<p>人们普遍认为，编译器几乎可以任意地对普通的内存读写进行重新排序，前提是重新排序不能改变观察到的单线程代码执行的效果。例如，考虑这个程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">w =</span> <span class="number">1</span></div><div class="line"><span class="variable">x =</span> <span class="number">2</span></div><div class="line"><span class="variable">r1 =</span> y</div><div class="line"><span class="variable">r2 =</span> z</div></pre></td></tr></table></figure>

<p>由于w、x、y和z都是不同的变量，这四个语句可以以编译器认为最好的任何顺序执行。</p>
<p>如上所述，如此自由地重新排序读写的能力使得普通编译程序的保证至少和ARM/POWER宽松内存模型一样弱，因为编译程序无法通过消息传递的litmus test。事实上，编译程序的保证更弱。</p>
<p>在上一篇硬件内存模型的文章中，我们将一致性（coherence）看作是ARM/POWER架构所能保证的一个例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Coherence</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">2</span>, <span class="variable">r3 =</span> <span class="number">2</span>, <span class="variable">r4 =</span> <span class="number">1</span>?</div><div class="line">(Can Thread <span class="number">3</span> see <span class="variable">x =</span> <span class="number">1</span> before <span class="variable">x =</span> <span class="number">2</span> while Thread <span class="number">4</span> sees the reverse?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">x =</span> <span class="number">2</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> x</div><div class="line">                              <span class="variable">r2 =</span> x         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div><div class="line">On ARM/POWER: no.</div><div class="line">In any modern compiled language using ordinary variables: yes!</div></pre></td></tr></table></figure>

<p>所有现代硬件都保证一致性，这也可以看作是对单个存储单元的操作的顺序一致性。在这个程序中，一个写操作必须覆盖另一个，并且整个系统必须就哪个是哪个达成一致。事实证明，由于编译过程中程序的重新排序，现代语言甚至不能提供一致性。</p>
<p>假设编译器对线程4中的两次读取进行了重新排序，然后指令按照以下顺序交替运行:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line">                                             // (reordered)</div><div class="line">(<span class="number">1</span>) <span class="variable">x =</span> <span class="number">1</span>                     (<span class="number">2</span>) <span class="variable">r1 =</span> x     (<span class="number">3</span>) <span class="variable">r4 =</span> x</div><div class="line">               (<span class="number">4</span>) <span class="variable">x =</span> <span class="number">2</span>      (<span class="number">5</span>) <span class="variable">r2 =</span> x     (<span class="number">6</span>) <span class="variable">r3 =</span> x</div></pre></td></tr></table></figure>

<p>结果r1 = 1，r2 = 2，r3 = 2，r4 = 1 在汇编程序中是不可能的，但在高级语言中是可能的。从这个意义上说，编程语言内存模型都比最宽松的硬件内存模型都弱。</p>
<p>但是有一些保证。每个人都同意需要提供DRF-SC，它不允许引入新的读或写的优化，即使这些优化在单线程代码中是有效的。</p>
<p>例如，考虑下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(c) {</div><div class="line">	x++;</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	... lots of code ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有一个if语句，在else中有很多代码，在if主体中只有一个x++。拥有更少的分支并彻底消除if体可能更快。如果我们编写代码有问题，我们可以在if之前运行了x++,然后在else中用x--进行调整。也就是说，编译器可能会考虑将该代码重写为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x++;</div><div class="line"><span class="keyword">if</span>(!c) {</div><div class="line">	x--;</div><div class="line">	... lots of code ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是安全的编译器优化吗？在单线程程序中，是的。在一个多线程程序中，当c为false时，x与另一个线程共享，答案是否: 优化会在x上引入一个原始程序中没有的数据</p>
<p>这个例子来源于Hans Boehm 2004年的论文<a href="https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf" target="_blank" rel="external">Threads Cannot Be Implemented As a Library</a>中的一个例子，它说明了语言不能对多线程执行的语义保持沉默。</p>
<p>编程语言内存模型试图精确回答这些问题，即哪些优化是允许的，哪些是不允许的。通过研究过去几十年来尝试编写这些模型的历史，我们可以了解哪些可行，哪些不可行，并了解事情的发展方向。</p>
<h2 id="原始的Java内存模型_(1996)">原始的Java内存模型 (1996)</h2>
<p>Java是第一个试图写下多线程程序保证的主流语言。它包括互斥体(mutex)，并定义了它们隐含的内存排序要求。它还包括“volatile”原子变量: volatile变量的所有读和写都需要直接在主内存中按程序顺序执行，使得对volatile变量的操作以顺序一致的方式进行。最后，Java制定了(或者至少试图制定)具有数据竞争的程序的行为。其中的一部分是为普通变量规定一种一致性的形式，我们将在下面详细讨论。不幸的是，在Java语言规范(1996)的第一版中，这种尝试至少有两个严重的缺陷。凭借后见之明和我们已经做好的准备，它们很容易解释。当时，它们远没有那么明显被发现。</p>
<h3 id="Atomic_需要同步">Atomic 需要同步</h3>
<p>第一个缺陷是volatile原子变量是不同步的，所以它们无助于消除程序其余部分的竞争。我们在上面看到的消息传递程序的Java版本是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> done;</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>因为done被声明为volatile，所以循环肯定会结束: 编译器不能将它缓存在寄存器中并导致无限循环。但是，程序不能保证打印1。编译器没有被禁止重新排序对x和done的访问，也没有被要求禁止硬件做同样的事情。</p>
<p>因为Java volatile是非同步原子，所以您不能使用它们来构建新的同步原语。从这个意义上说，最初的Java内存模型太弱了。</p>
<h3 id="一致性与编译器优化不兼容">一致性与编译器优化不兼容</h3>
<p>初的Java内存模型也太强了: 强制一致性 —— 一旦线程读取了内存位置的新值，它就不能再读取旧值——不允许基本的编译器优化。前面我们讨论了重新排序读操作会如何破坏一致性，但是你可能会想，好吧，不要重新排序读操作。这里有一个更微妙的方法，可以通过另一个优化来打破一致性:公共子表达式消除。考虑一下这个Java程序:</p>
<p>考虑一下这个Java程序:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p and q may or may not point at the same object.</span></div><div class="line"><span class="keyword">int</span> i = p.x;</div><div class="line"><span class="comment">// ... maybe another thread writes p.x at this point ...</span></div><div class="line"><span class="keyword">int</span> j = q.x;</div><div class="line"><span class="keyword">int</span> k = p.x;</div></pre></td></tr></table></figure>

<p>在这个程序中，公共子表达式消除(common subexpression elimination)会注意到p.x被计算了两次，并将最后一行优化为k = i。但是，如果p和q指向同一个对象，并且另一个线程在读入I和j之间向p.x写入，那么为k重用旧值i违反了一致性:读入i看到了旧值，读入j看到了新值，但是读入k重用i会再次看到旧值。不能优化掉冗余读取会阻碍大多数编译器，使生成的代码变慢。</p>
<p>硬件比编译器更容易提供一致性，因为硬件可以应用动态优化:它可以根据给定内存读写序列中涉及的确切地址来调整优化路径。相比之下，编译器只能应用静态优化:无论涉及什么地址和值，它们都必须提前写出正确的指令序列。在这个例子中，编译器不能根据p和q是否碰巧指向同一个对象来轻易改变发生的事情，至少在没有为这两种可能性写出代码的情况下不能，这导致了大量的时间和空间开销。编译器对内存位置之间可能存在的别名不完全了解意味着：实际上要实现一致性就需要放弃基本的优化。</p>
<p>Bill Pugh在他1999年的论文<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.17.7914&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">修复Java内存模型</a>中指出了这个问题和其他问题.</p>
<h2 id="新的Java内存模型_(2004)">新的Java内存模型 (2004)</h2>
<p>由于这些问题，并且因为最初的Java内存模型甚至对于专家来说都很难理解，Pugh和其他人开始努力为Java提供一个新的内存模型。该模型后来成为JSR-133，并在2004年发布的Java 5.0中被采用。规范参考是Jeremy Manson, Bill Pugh和Sarita Adve的<a href="http://rsim.cs.uiuc.edu/Pubs/popl05.pdf" target="_blank" rel="external">Java内存模型(2005)</a>，Jeremy Manson的博士论文中有更多细节。新模型遵循DRF-SC方法:保证无数据竞争的Java程序以顺序一致的方式执行。</p>
<h3 id="同步原子和其它操作">同步原子和其它操作</h3>
<p>正如我们前面看到的，要编写一个无数据竞争的程序，程序员需要同步操作，这些同步操作可以建立happens-before关系，以确保一个线程不会在另一个线程读取或写入非原子变量的同时写入该变量。在Java中，主要的同步操作有:</p>
<ul>
<li>线程的创建发生在(happen before)它的第一个动作之前</li>
<li>mutex m的unlock发生在m的后续lock之前</li>
<li>写volatile变量v发生在后续读取v之前</li>
<li></li>
</ul>
<p>“subsequent”(“后续”)`是什么意思？Java定义了所有锁、解锁和volatile变量访问的行为，就好像它们发生在一些顺序一致的中断中，给出了整个程序中所有这些操作的总顺序。“后续”是指总顺序中的较晚执行。也就是说:锁、解锁和volatile变量访问的总顺序定义了后续的含义，然后后续定义了特定执行创建了happen before关系，然后happend before关系定义了该特定执行是否有数据竞争。如果没有数据竞争，那么执行就会以顺序一致的方式进行。</p>
<p>事实上， volatile访问必须表现得好像在某种总排序中一样，这意味着在<a href="https://research.swtch.com/hwmm#x86" target="_blank" rel="external">存储缓冲区litmus test</a>中，不能出现r1 = 0和r2 = 0的结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Store Buffering</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">0</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): yes!</div><div class="line">On ARM/POWER: yes!</div><div class="line">On Java using volatiles: no.</div></pre></td></tr></table></figure>

<p>在Java中，对于volatile变量x和y，读取和写入不能被重新排序:一个写入必须排在第二位，第二个写入之后的读取必须看到第一个写入。如果我们没有顺序一致的要求——比如说，如果只要求volatile是一致的——两次读取可能会错过写入。</p>
<p>这里有一个重要但微妙的点:所有同步操作的总顺序与happen-before关系是分开的。在程序中的每个锁、解锁或volatile变量访问之间，在一个方向或另一个方向上不存在happen-before关系:从写入到观察写入的读取，您只获得了happen-before的关系。例如，不同互斥体的锁定和解锁之间没有happen-before关系。</p>
<h3 id="有数据竞争的程序的语义">有数据竞争的程序的语义</h3>
<p>DRF-SC只保证没有数据竞争的程序的顺序一致行为。新的Java内存模型和最初的一样，定义了有数据竞争的程序的行为，原因有很多:</p>
<ul>
<li>支持Java的一般安全（security）和安全保障（safety guarantee）。</li>
<li>让程序员更容易发现错误。</li>
<li>使攻击者更难利用问题，因为由于数据竞争的原因可能造成的损失更有限。</li>
<li>让程序员更清楚他们的程序是做什么的。</li>
</ul>
<p>新模型不再依赖于一致性，而是重新使用了happens-before关系(已经用来决定程序是否有竞争)来决定竞争读写的结果。</p>
<p>Java的具体规则是，对于word大小或更小的变量，对变量(或字段)x的读取必须看到对x的某一次写入所存储的值。如果读取r观察到对x的写入w，那么r不发生在w之前。这意味着r可以观察发生在r之前的所有写入，并且它可以观察与r竞争的写入。</p>
<p>使用happens-before，结合同步原子(volatile)就可以建立新的happen before关系，是对原始Java内存模型的重大改进。它为程序员提供了更多有用的保证，并使大量重要的编译器优化得到了明确的允许。这个模型至今仍然是Java的内存模型。也就是说，这仍然是不完全正确的:在试图定义竞争程序的语义时，使用before-before是有问题的。</p>
<h3 id="happen-before不排除语无伦次(incoherence)">happen-before不排除语无伦次(incoherence)</h3>
<p>定义程序语义的“happen-before”关系的第一个问题与一致性有关(有一次!).(以下例子摘自Jaroslav Ševčík 和 David Aspinall的论文<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.112.1790&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">《论Java内存模型中程序转换的有效性》(2007年)</a>)。)</p>
<p>这里有一个三线程的程序。让我们假设线程1和线程2已知在线程3开始之前完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2           // Thread 3</span></div><div class="line">lock(m1)              lock(m2)</div><div class="line">x = <span class="number">1</span>                 x = <span class="number">2</span></div><div class="line">unlock(m1)            unlock(m2)</div><div class="line">                                            lock(m1)</div><div class="line">                                            lock(m2)</div><div class="line">                                            r1 = x</div><div class="line">                                            r2 = x</div><div class="line">                                            unlock(m2)</div><div class="line">                                            unlock(m1)</div></pre></td></tr></table></figure>

<p>线程1在持有mutex m1时写入x = 1。线程2在持有 mutex m2时写入x = 2。这些是不同的mutex，所以两个写操作是竞争的。然而，只有线程3读取x，并且它是在获取两个mutex后读取的。对r1的读取可以是读也可以是写:两者都发生在它之前，并且都不会完全覆盖另一个。通过相同的参数，读入r2可以读或写。但是严格来说，Java内存模型中没有任何东西说两次读取必须一致：从技术上讲，r1和r2可以读取不同的x值。也就是说，这个程序可以以r1和r2持有不同的值结束。当然，没有真正的实现会产生不同的r1和r2。互斥意味着这两次读取之间没有写操作发生。他们必须得到相同的值。但是内存模型允许不同读取值的事实表明，从某种技术角度来说，它并没有精确地描述真实的Java实现。</p>
<p>情况变得更糟。如果我们在两个读数之间再加一个指令，x = r1，会怎么样:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Thread 1           // Thread 2           // Thread 3</div><div class="line"><span class="operator"><span class="keyword">lock</span>(m1)              <span class="keyword">lock</span>(m2)</span></div><div class="line">x = <span class="number">1</span>                 x = <span class="number">2</span></div><div class="line"><span class="keyword">unlock</span>(m1)            <span class="keyword">unlock</span>(m2)</div><div class="line">                                            <span class="keyword">lock</span>(m1)</div><div class="line">                                            <span class="keyword">lock</span>(m2)</div><div class="line">                                            r1 = x</div><div class="line">                                            x = r1   // !?</div><div class="line">                                            r2 = x</div><div class="line">                                            <span class="keyword">unlock</span>(m2)</div><div class="line">                                            <span class="keyword">unlock</span>(m1)</div></pre></td></tr></table></figure>

<p>很明显，r2 = x读数必须使用x = r1写的值，因此程序必须在r1和r2中获得相同的值。两个值r1和r2现在保证相等。</p>
<p>这两个程序之间的差异意味着我们在编译器方面有问题。看到r1 = x后跟着x = r1时编译器很可能想要删除第二个赋值，这“显然”是多余的。但这种“优化”将第二个程序(r1和r2的值必须相同)变成了第一个程序(从技术上讲，r1可能不同于r2)。因此，根据Java内存模型，这种优化在技术上是无效的:它改变了程序的含义。明确地说，这种优化不会改变在任何你能想象的真实JVM上执行的Java程序的意义。但不知何故，Java内存模型不允许这样做，这表明还有更多需要说的。</p>
<p>有关这个例子和其他例子的更多信息，请参见evík和Aspinall的论文。</p>
<h2 id="以前发生的事不排除无用性（acausality）">以前发生的事不排除无用性（acausality）</h2>
<p>最后一个例子证明是个简单的问题。这里有一个更难的问题。考虑这个litmus test，使用普通的(非volatile)Java变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Racy Out Of Thin Air Values</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">42</span>, r2 = <span class="number">42</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">r1 = x                r2 = y</div><div class="line">y = r1                x = r2</div><div class="line">(Obviously not!)</div></pre></td></tr></table></figure>

<p>这个程序中的所有变量都像往常一样从零开始，然后这个程序在一个线程中有效地运行y = x，在另一个线程中运行x = y。x和y最终能变成42吗？在现实生活中，显然不能。但为什么不呢？内存模型并没有否定这个结果。</p>
<p>假设“r1 = x”的读数是42。那么“y = r1”会将42写入y，然后竞争“r2 = y”会读取42，导致“x = r2”写入42到x，且write与原始“r1 = x”竞争(因此可被原始“r1 = x”观察到)，看起来证明原始假设是正确的。在这个例子中，42被称为无中生有的值，因为它看起来没有任何理由，但随后用循环逻辑证明了自己。如果内存在当前的0之前曾经持有42，而硬件错误地推测它仍然是42，会怎么样？这种猜测可能会成为一个自我实现的预言。(在Spectre和相关攻击显示出硬件是如何不断进步的之前，这个论点似乎更加牵强。即便如此，没有一种硬件是这样凭空创造值的。)</p>
<p>很明显，这个程序不能以r1和r2设置为42结束，但是happens-before本身并不能解释为什么不能这样做。这再次表明存在某种不完整性。新的Java内存模型花费了大量时间来解决这种不完整性，稍后将对此进行更详细的描述。</p>
<p>这个程序有一个竞争——x和y的读取与其他线程中的写入竞争——所以我们可能会继续认为它是一个不正确的程序。但是这里有一个没有数据竞争的版本:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Litmus <span class="keyword">Test</span>: Non-Racy <span class="keyword">Out</span> Of Thin Air Values</div><div class="line">Can this program see <span class="literal">r1</span> = <span class="number">42</span>, <span class="literal">r2</span> = <span class="number">42</span>?</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>           // Thread <span class="number">2</span></div><div class="line"><span class="literal">r1</span> = x                <span class="literal">r2</span> = y</div><div class="line">if (<span class="literal">r1</span> == <span class="number">42</span>)         if (<span class="literal">r2</span> == <span class="number">42</span>)</div><div class="line">    y = <span class="literal">r1</span>                x = <span class="literal">r2</span></div><div class="line">(Obviously <span class="keyword">not</span>!)</div></pre></td></tr></table></figure>

<p>由于x和y从零开始，任何顺序一致的执行都不执行写操作，所以这个程序没有写操作，所以没有竞争。不过，同样，仅happen-before并不排除这样的可能性，假设r1 = x看到竞争不是write，然后根据这个假设，两个条件最终都为真，x和y最终都是42。这是另一种无中生有的价值，但这一次是在没有竞争的程序中。任何保证DRF-SC的模型都必须保证这个程序只在末尾看到全零，然而happens-before并没有解释为什么。</p>
<p>Java内存模型花了很多我不想赘述的话来试图排除这些类型的假设。不幸的是，五年后，Sarita Adve and Hans Boehm对这个内存模型有这样的评价:</p>
<blockquote>
<p>Prohibiting such causality violations in a way that does not also prohibit other desired optimizations turned out to be surprisingly difficult. … After many proposals and five years of spirited debate, the current model was approved as the best compromise. … Unfortunately, this model is very complex, was known to have some surprising behaviors, and has recently been shown to have a bug.</p>
<p>以一种不妨碍其他期望的优化的方式来禁止这种因果关系冲突，结果令人惊讶地难以实现。……经过许多提议和五年的激烈辩论，目前的模式被认为是最好的折衷方案。……不幸的是，这个模型非常复杂，已知有一些令人惊讶的缺点，最近被证明有一个错误。</p>
</blockquote>
<p>(Adve 和 Boehm, <a href="https://cacm.acm.org/magazines/2010/8/96610-memory-models-a-case-for-rethinking-parallel-languages-and-hardware/fulltext" target="_blank" rel="external">“Memory Models: A Case For Rethinking Parallel Languages and Hardware,”</a> August 2010)</p>
<h2 id="C++11_内存模型_(2011)">C++11 内存模型 (2011)</h2>
<p>让我们把Java放在一边，研究C++。受Java新内存模型明显成功的启发，许多同样的人开始为C++定义一个类似的内存模型，最终在C++11中采用。与Java相比，C++在两个重要方面有所不同。首先，C++对具有数据竞争的程序不做任何保证，这似乎消除了对Java模型复杂性的需求。其次，C++提供了三种原子性:强同步(“顺序一致”)、弱同步(“acquire/release”,、coherence-only)和无同步(“relaxed”，用于隐藏竞争)。“relaxed”的原子性重新引入了Java关于定义什么是竞争程序的所有复杂性。结果是C++模型比Java更复杂，但对程序员的帮助更小。</p>
<p>C++11还定义了原子栅栏作为原子变量的替代，但是它们并不常用，我不打算讨论它们。</p>
<h3 id="DRF-SC_还是_着火(Catch_Fire）">DRF-SC 还是 着火(Catch Fire）</h3>
<p>与Java不同，C++没有给有竞争的程序任何保证。任何有竞争的程序都属于<a href="https://blog.regehr.org/archives/213" target="_blank" rel="external">“未定义的行为”</a>。允许在程序执行的最初几微秒内进行竞争访问，从而在几小时或几天后导致任意的错误行为。这通常被称为“DRF-SC或着火”:如果程序没有数据竞争，它以顺序一致的方式运行，如果有数据竞争，它可以做任何事情，包括着火。</p>
<p>关于DRF-SC或Catch Fire的论点的更详细的介绍，参见Boehm，<a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2176.html#undefined" target="_blank" rel="external">“内存模型原理”(2007)</a> 和Boehm和Adve，<a href="https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf" target="_blank" rel="external">“C++并发内存模型的基础”(2008)</a>。</p>
<p>简而言之，这中情况有四个正当理由:</p>
<p>Briefly, there are four common justifications for this position:</p>
<ul>
<li>C和C++已经充斥着未定义的行为，这是编译器优化横行的语言小角落，用户最好不要迟疑。多一个未定义行为又有多大的坏处？</li>
<li>现有的编译器和库编写时没有考虑线程，以任意方式破坏了有竞争的程序。找到并修复所有的问题太难了，或者这个争论没有了，尽管还不清楚那些不固定的编译器和库是如何应对宽松的原子的。</li>
<li>真正知道自己在做什么并希望避免未定义行为的程序员可以使用relaxed的原子。</li>
<li>不定义竞争语义允许实现检测和诊断竞争并停止执行。</li>
</ul>
<p>就我个人而言，最后一个理由是我认为唯一有说服力的，尽管我认为这个意思是说“允许使用竞争检测器”，而不是说“一个整数的竞争会使整个程序无效。”</p>
<p>这里有一个来自“内存模型原理”的例子，我认为它抓住了C++方法的本质以及它的问题。考虑这个程序，它引用了一个全局变量x。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> i = x;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (i &lt; <span class="number">2</span>) {</div><div class="line">	foo: ...</div><div class="line">	<span class="keyword">switch</span> (i) {</div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">		...;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">		...;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>据称，C++编译器可能会将i保存在寄存器中，但如果标签foo处的代码很复杂，则需要重用这些寄存器。而不是转移i当前的值到栈上， 编译器可能会决定在到达switch语句时，再次从全局x加载i。结果是，在if体中，i &lt; 2可能不再为真。如果编译器使用由i索引的表将开关编译成计算跳转，那么代码将从表的末尾索引并跳转到一个意外的地址，这可能非常糟糕。</p>
<p>从这个例子和其他类似的例子中，C++内存模型的作者得出结论，任何有竞争的访问都必须被允许对程序的未来执行造成无限的损害。我个人的结论是，在多线程程序中，编译器不应该认为它们可以通过重新执行初始化局部变量的内存读取来重新加载像i这样的局部变量。指望为单线程世界编写的现有C++编译器找到并修复像这样的代码生成问题可能是不切实际的，但是在新的语言中，我认为我们应该有更高的目标。</p>
<h3 id="题外话,_C/C++的未定义行为">题外话, C/C++的未定义行为</h3>
<p>另外，C和C++坚持编译器对程序中的错误行为进行任意的行为的能力导致了真正荒谬的结果。例如，考虑这个程序，这是2017在推特上讨论的话题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (*Function)();</div><div class="line"></div><div class="line"><span class="keyword">static</span> Function Do;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> EraseAll() {</div><div class="line">	<span class="keyword">return</span> system(<span class="string">"rm -rf slash"</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> NeverCalled() {</div><div class="line">	Do = EraseAll;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">	<span class="keyword">return</span> Do();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你是一个像Clang这样的现代C++编译器，你可能会想到这个程序如下：</p>
<ul>
<li>很明显，main函数中，Do要么为空，要么为EraseAll。</li>
<li>如果Do是Erasell，那么Do()与Erasell()相同。</li>
<li>如果Do 是null, 那么Do()是未定义行为。我可以随意实现，包括作为EraseAll()无条件实现。</li>
<li>因此，我可以将间接调用Do()优化为直接调用EraseAll()。</li>
<li>当我处理这里的时候，我可能直接内联EraseAll。</li>
</ul>
<p>最终结果是，Clang将程序优化为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main() {</div><div class="line">	<span class="keyword">return</span> system(<span class="string">"rm -rf slash"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你必须承认:前一个例子，局部变量i可能在if (i &lt; 2)体的中途突然停止小于2的可能性似乎并不合适。</p>
<p>本质上，现代C和C++编译器假设没有程序员敢尝试未定义的行为。一个程序员写一个有bug的程序？不可思议！</p>
<p>就像我说的，在新的语言中，我认为我们应该有更高的目标。</p>
<h3 id="Acquire/release_atomic">Acquire/release atomic</h3>
<p>C++采用了顺序一致的原子变量，很像(新的)Java的volatile变量(与C++ volatile没有关系)。在我们的消息传递示例中，我们可以将done声明为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atomic&lt;<span class="keyword">int</span>&gt; done;</div></pre></td></tr></table></figure>

<p>然后像使用普通变量一样使用done，就像在Java中一样。或者我们可以把一个普通的整型变量去掉。然后使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atomic_store(&done, <span class="number">1</span>);</div></pre></td></tr></table></figure>

<p>和：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(atomic_load(&<span class="keyword">done</span>) == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div></pre></td></tr></table></figure>

<p>去访问它。</p>
<p>无论哪种方式，完成的操作都参与原子操作的顺序一致的总顺序，并同步程序的其余部分。</p>
<p>C++还添加了较弱的原子，可以使用atomic_store_explicit和atomic_load_explicit以及附加的memory排序参数来访问这些原子。使用memory_order_seq_cst使显式调用等效于上面较短的调用。</p>
<p>较弱的原子称为acquire/release原子，一个release如果被后来的acquire观察到，那么就创建了一个happen-before的关系(从release到acquire)。这个术语意在唤起mutex:release就像unlock mutex，acquire就像lock同一个mutex。release之前执行的写入必须对后续acquire之后执行的读取可见，就像unlock mutex之前执行的写入必须对后来unlock mutex之后执行的读取可见一样。</p>
<p> The terminology is meant to evoke mutexes: release is like unlocking a mutex, and acquire is like locking that same mutex. The writes executed before the release must be visible to reads executed after the subsequent acquire, just as writes executed before unlocking a mutex must be visible to reads executed after later locking that same mutex.</p>
<p>为了使用较弱的原子，我们可以将消息传递示例改为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atomic_store(&done, <span class="number">1</span>, memory_order_release);</div></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(atomic_load(&done, memory_order_acquire) == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div></pre></td></tr></table></figure>

<p>它仍然是正确的。但不是所有的程序都会这样</p>
<p>回想一下，顺序一致的原子要求程序中所有原子的行为与执行的一些全局交替执行(全局顺序)一致。acquire/release原子不会。它们只需要对单个内存位置的操作进行顺序一致的交替执行。也就是说，它们只需要一致性。结果是，一个使用具有多个存储位置的acquire/release原子的程序可能会观察到无法用程序中所有acquire/release原子的顺序一致的交替来解释的执行，这可以说是违反了DRF-SC！</p>
<p>为了说明不同之处，这里再举一个存储缓冲区的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Store Buffering</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">0</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): yes!</div><div class="line">On ARM/POWER: yes!</div><div class="line">On Java (<span class="keyword">using</span> volatiles): no.</div><div class="line">On C++<span class="number">11</span> (sequentially consistent atomics): no.</div><div class="line">On C++<span class="number">11</span> (acquire/release atomics): yes!</div></pre></td></tr></table></figure>

<p>C++顺序一致的原子与Java的volatile相匹配。但是acquire-release原子在x的顺序和y的顺序之间没有强加任何关系。特别地，允许程序表现得好像r1 = y发生在y = 1之前，而同时r2 = x发生在x = 1之前，使得r1 = 0，r2 = 0与整个程序的顺序一致性相矛盾。为什么要引入这些较弱的获取/发布原子？可能是因为它们是x86上的普通内存操作。</p>
<p>请注意，对于观察特定写入的一组给定的特定读取，C++顺序一致原子和C++ acquire/release原子创建相同的happen-before关系。它们之间的区别在于，顺序一致的原子不允许观察特定写入的某些特定读取集，但acuqire/release原子允许这些特定读取集。一个这样的例子是导致存储缓冲测试出现r1 = 0，r2 = 0的结果。</p>
<p>acquire/release原子在实践中不如提供顺序一致性的原子有用。这里有一个例子。假设我们有一个新的同步原语，一个具有通知和等待两种方法的一次性条件变量。为了简单起见，只有一个线程会调用Notify，只有一个线程会调用Wait。我们想安排Notify在另一个线程还没有等待的时候是无锁的。我们可以用一对原子整数来实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Cond {</div><div class="line">	atomic&lt;<span class="keyword">int</span>&gt; done;</div><div class="line">	atomic&lt;<span class="keyword">int</span>&gt; waiting;</div><div class="line">	...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> Cond::notify() {</div><div class="line">	done = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (!waiting)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="comment">// ... wake up waiter ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Cond::wait() {</div><div class="line">	waiting = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(done)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="comment">// ... sleep ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码的重要部分是在检查waiting之前notify设置done为1, 为wait在检查done之前设置waiting为1,因此并发调用notify和wait不会导致notify立即返回并等待休眠。但是使用C++ acquire/release原子，它们可以。而且它们可能只需要很少的几率发生，使得这种错误很难重现和诊断。(更糟糕的是，在像64位ARM这样的一些架构上，实现acquire/release原子的最佳方式是顺序一致的原子，因此您可能会编写在64位ARM上运行良好的代码，但在移植到其他系统时才发现它是不正确的。)</p>
<p>基于这种理解，“acquire/release”对于这些原子来说是一个不幸的名字，因为顺序一致的原子做同样的acquire和release。不同之处在于顺序一致性的丧失。称这些为“一致性”原子可能更好。太迟了。</p>
<h3 id="Relaxed_atomic">Relaxed atomic</h3>
<p>C++并没有仅仅停留在连贯的获取/发布原子上。它还引入了非同步原子，称为relaxed原子。这些原子根本没有同步效果——它们没有创建先发生的边——并且它们根本没有排序保证。事实上，宽松原子读/写和普通读/写没有区别，除了宽松原子上的竞争不被认为是竞争，不能着火。</p>
<p>C++没有停止与仅仅提供一致性的acquire/release原子。它还引入了非同步原子，称为relaxed原子(memory_order_relaxed)。这些原子根本没有同步效果——它们没有创建happens-before关系——并且它们根本没有排序保证。事实上，relaxed原子读/写和普通读/写没有区别，除了relaxed原子上的竞争不被认为是竞争，不能着火。</p>
<p>修改后的Java内存模型的大部分复杂性来自于定义具有数据竞争的程序的行为。如果C++采用DRF-SC或Catch Fire——实际上不允许有数据竞争的程序——意味着我们可以扔掉前面看到的所有奇怪的例子，那么C++语言规范将比Java语言规范更简单，那就太好了。不幸运的是，包括releaxed的原子最终保留了所有这些关注，这意味着C++11规范最终并不比Java简单。</p>
<p>像Java的内存模型一样，C++11的内存模型最终也是不正确的。考虑之前的无数据竞争计划:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Non-Racy Out Of Thin Air Values</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">42</span>, r2 = <span class="number">42</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">r1 = x                r2 = y</div><div class="line"><span class="keyword">if</span> (r1 == <span class="number">42</span>)         <span class="keyword">if</span> (r2 == <span class="number">42</span>)</div><div class="line">    y = r1                x = r2</div><div class="line">(Obviously not!)</div><div class="line"></div><div class="line">C++<span class="number">11</span> (ordinary variables): no.</div><div class="line">C++<span class="number">11</span> (relaxed atomics): yes!</div></pre></td></tr></table></figure>

<p>Viktor Vafeiadis和其他人在他们的论文<a href="https://fzn.fr/readings/c11comp.pdf" target="_blank" rel="external">“Common Compiler Optimisations are Invalid in the C11 Memory Model and what we can do about it” (2015)</a>中表明，C++11规范保证当x和y是普通变量时，该程序必须以x和y设置为零结束。但是如果x和y是relaxed的原子，那么，严格来说，C++11规范不排除r1和r2最终都可能达到42。(惊喜！)</p>
<p>详情见论文，但在较高的层次上，C++11规范有一些正式规则，试图禁止无中生有的值，并结合了一些模糊的词语来阻止其他类型的有问题的值。这些正式的规则就是问题所在，因此C++14放弃了它们，只留下了模糊的词语。引用删除它们的基本原理，C++11公式证明是“既不充分的，因为它使人们基本上无法对内存顺序放松的程序进行推理，也严重有害，因为它可以说不允许在ARM和POWER等体系结构上对memory_order_relaxed的所有合理实现。”</p>
<p>综上所述，Java试图正式排除所有不合法的执行，但失败了。然后，借助Java的后知后觉，C++11试图正式地只排除一些不合法的执行，也失败了。C++14然后说什么都不正式。这不是正确的方向。</p>
<p>事实上，Mark Batty和其他人在2015年发表的一篇题为<a href="https://www.cl.cam.ac.uk/~jp622/the_problem_of_programming_language_concurrency_semantics.pdf" target="_blank" rel="external">“编程语言并发语义的问题”</a>的论文给出了这一发人深省的评估:</p>
<blockquote>
<p>Disturbingly, 40+ years after the first relaxed-memory hardware was introduced (the IBM 370/158MP), the field still does not have a credible proposal for the concurrency semantics of any general-purpose high-level language that includes high-performance shared-memory concurrency primitives.</p>
<p>令人不安的是，在引入第一个relaxed内存硬件(IBM 370/158MP)40多年后，该领域仍然没有一个可信的提案来描述任何包含高性能共享内存并发原语的通用高级语言的并发语义。</p>
</blockquote>
<p>甚至定义弱有序硬件的语义(忽略软件和编译器优化的复杂性)也不太顺利。张思卓等人在2018年发表的一篇名为<a href="https://arxiv.org/abs/1805.07886" target="_blank" rel="external">《构建弱记忆模型》</a>的论文讲述了最近发生的一些事情:</p>
<blockquote>
<p>Sarkar et al. published an operational model for POWER in 2011, and Mador-Haim et al. published an axiomatic model that was proven to match the operational model in 2012. However, in 2014, Alglave et al. showed that the original operational model, as well as the corresponding axiomatic model, ruled out a newly observed behavior on POWER machines. For another instance, in 2016, Flur et al. gave an operational model for ARM, with no corresponding axiomatic model. One year later, ARM released a revision in their ISA manual explicitly forbidding behaviors allowed by Flur&#39;s model, and this resulted in another proposed ARM memory model. Clearly, formalizing weak memory models empirically is error-prone and challenging.</p>
<p>Sarkar等人在2011年公布了POWER的运行模型，Mador-Haim等人在2012年公布了一个公理化模型，该模型被证明与运行模型相匹配。然而，在2014年，Alglave等人表明，最初的操作模型以及相应的公理模型排除了在POWER机器上新观察到的行为。再比如，2016年，Flur等人给出了一个ARM的操作模型，没有对应的公理模型。一年后，ARM在他们的ISA手册中发布了一个修订版，明确规定了Flur模型允许的行为，这导致了另一个提出的ARM内存模型。显然，根据经验形式化弱记忆模型是容易出错且具有挑战性的。</p>
</blockquote>
<p>在过去的十年里，致力于定义和形式化所有这些的研究人员非常聪明、有才华和坚持不懈，我并不想通过指出结果中的不足来贬低他们的努力和成就。我从这些简单的结论中得出结论，这个指定线程程序的确切行为的问题，即使没有竞争，也是难以置信的微妙和困难。如今，即使是最优秀、最聪明的研究人员似乎也无法理解这一点。即使不是，编程语言定义在日常开发人员可以理解的情况下效果最好，而不需要花费十年时间研究并发程序的语义。</p>
<h2 id="C,_Rust_和_Swift_的内存模型">C, Rust 和 Swift 的内存模型</h2>
<p>C11也采用了C++11内存模型，使其成为C/C++11内存模型。</p>
<p>2015年的<a href="https://doc.rust-lang.org/std/sync/atomic/" target="_blank" rel="external">Rust 1.0.0</a>和2020年的<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0282-atomics.md" target="_blank" rel="external">Swift 5.3</a>都整体采用了C/C++内存模型，拥有DRF-SC或Catch Fire以及所有的原子类型和原子栅栏。</p>
<p>毫不奇怪，这两种语言都采用了C/C++ 模型，因为它们建立在C/C++编译器工具链(LLVM)上，并强调与C/C++代码的紧密集成。</p>
<h3 id="硬件题外话：_有效的顺序一致性atomic">硬件题外话： 有效的顺序一致性atomic</h3>
<p>早期的多处理器体系结构有多种同步机制和内存模型，具有不同程度的可用性。在这种多样性中，不同同步抽象的效率取决于它们如何映射到架构所提供的内容。为了构造顺序一致的原子变量的抽象，有时唯一的选择是使用比严格必要的要多得多、贵得多的内存栅栏barriers，特别是在ARM和POWER上。</p>
<p>随着C、C++和Java都提供了这种顺序一致性同步原子的抽象，硬件设计者就应该让这种抽象变得高效。ARMv8架构(32位和64位)引入了ldar和stlr load和store指令，提供了直接的实现。在2017年的一次谈话中，赫伯·萨特声称，IBM已经批准了他的说法，他们希望未来的POWER实现对顺序一致的原子也有某种更有效的支持，这让程序员“更没有理由使用relaxed的原子。”我不知道是否发生了这种情况，尽管在2021年，POWER的相关性远不如ARMv8。</p>
<p>这种融合的效果是顺序一致的原子现在被很好地理解，并且可以在所有主要的硬件平台上有效地实现，这使得它们成为编程语言内存模型的一个很好的目标。</p>
<h2 id="JavaScript_内存模型_(2017)">JavaScript 内存模型 (2017)</h2>
<p>你可能会认为JavaScript，一种众所周知的单线程语言，不需要担心内存模型，当代码在多个处理器上并行运行时会发生什么。我当然有。但是你和我都错了。</p>
<p>JavaScript有web workers，它允许在另一个线程中运行代码。按照最初的设想，工作人员只通过显式的消息复制与主JavaScript线程进行通信。没有共享的可写内存，就没有必要考虑像数据竞争这样的问题。然而，ECMAScript 2017 (ES2017)增加了SharedArrayBuffer对象，它让主线程和工作线程共享一块可写内存。为什么要这样做？在提案的<a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf" target="_blank" rel="external">早期草稿</a>中，列出的第一个原因是将多线程C++代码编译成JavaScript。</p>
<p>当然，共享可写内存还需要定义同步的原子操作和内存模型。JavaScript在三个重要方面偏离了C++:</p>
<ul>
<li>首先，它将原子操作限制在顺序一致的原子上。其他原子可以被编译成顺序一致的原子，可能会损失效率，但不会损失正确性，只有一种原子可以简化系统的其余部分。</li>
<li>第二，JavaScript不采用“DRF-SC或着火。”相反，像Java一样，它仔细定义了竞争访问的可能结果。其原理与Java非常相似，尤其是安全性。允许竞争read返回任何值允许(可以说是鼓励)实现返回不相关的数据，这可能会导致运行时<a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/DISCUSSION.md#races-leaking-private-data-at-run-time" target="_blank" rel="external">私有数据的泄漏</a>。</li>
<li>第三，部分是因为JavaScript为竞争程序提供了语义，它定义了当原子和非原子操作在同一个内存位置使用时，以及当使用不同大小的访问访问同一个内存位置时会发生什么。</li>
</ul>
<p>精确定义racy程序的行为会导致relaxed内存语义的复杂性，以及如何禁止无中生有的读取和类似情况。除了这些与其他地方基本相同的挑战之外，ES2017定义还有两个有趣的错误，它们是由于与新的ARMv8原子指令的语义不匹配而引起的。这些例子改编自康拉德·瓦特等人2020年的论文<a href="https://www.cl.cam.ac.uk/~jp622/repairing_javascript.pdf" target="_blank" rel="external">“Repairing and Mechanising the JavaScript Relaxed Memory Model.”</a></p>
<p>正如我们在上一节中提到的，ARMv8增加了ldar和stlr指令，提供顺序一致的原子加载和存储。这些是针对C++的，它没有定义任何具有数据竞争的程序的行为。因此，毫不奇怪，这些指令在竞争程序中的行为与ES2017作者的期望不符，尤其是它不符合ES2017对竞争程序行为的要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: ES2017 racy reads on ARMv8</div><div class="line">Can <span class="keyword">this</span> program (using atomics) see r1 = <span class="number">0</span>, r2 = <span class="number">1</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                x = <span class="number">2</span> (non-atomic)</div><div class="line">                      r2 = x</div><div class="line">C++: yes (data race, can <span class="keyword">do</span> anything at all).</div><div class="line">Java: the program cannot be written.</div><div class="line">ARMv8 using ldar/stlr: yes.</div><div class="line">ES2017: no! (contradicting ARMv8)</div></pre></td></tr></table></figure>

<p>在这个程序中，所有的读和写都是顺序一致的原子，除了x = 2:线程1使用原子存储写x = 1，但是线程2使用非原子存储写x = 2。在C++中，这是一场数据竞争，所以所有的赌注都取消了。在Java中，这个程序是不能写的:x必须要么声明为volatile，要么不声明；它有时不能被原子访问。在ES2017中，内存模型不允许r1 = 0，r2 = 1。如果r1 = y读取0，线程1必须在线程2开始之前完成，在这种情况下，非原子x = 2似乎发生在x = 1之后并覆盖x = 1，导致原子r2 = x读取2。这个解释似乎完全合理，但这不是ARMv8处理器的工作方式。</p>
<p>事实证明，对于ARMv8指令的等效序列，对x的非原子写可以在对y的原子写之前重新排序，因此该程序实际上产生r1 = 0，r2 = 1。这在C++中不是问题，因为竞争意味着程序可以做任何事情，但对于ES2017来说，这是一个问题，它将竞争行为限制在一组不包括r1 = 0、r2 = 1的结果上</p>
<p>由于ES2017的明确目标是使用ARMv8指令来实现顺序一致的原子操作，Watt等人报告说，他们建议的修复(计划包含在标准的下一个修订版中)将削弱竞争行为约束，足以允许这种结果。(当时我不清楚“下一次修订”是指ES2020还是ES2021。)</p>
<p>Watt等人提出的修改还包括对第二个bug的修复，第一个bug是由Watt、Andreas Rossberg和Jean Pichon-pharabad提出的，其中一个无数据竞争的程序没有按照ES2017规范给出顺序一致的语义。该程序由下式给出:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Litmus Test: ES2017 data-race-free program</div><div class="line">Can this program (using atomics) see r1 = 1, r2 = 2?</div><div class="line"></div><div class="line">// Thread 1           // Thread 2</div><div class="line">x = 1                 x = 2</div><div class="line">                      r1 = x</div><div class="line">                      if (r1 == 1) {</div><div class="line">                          r2 = x // non-atomic</div><div class="line">                      }</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">C++: I'm not enough of a C++ expert to say for sure.</div><div class="line">Java: the program cannot be written.</div><div class="line">ES2017: yes! (violating DRF-SC).</div></pre></td></tr></table></figure>

<p>在这个程序中，所有的读和写都是顺序一致的原子，除了r2 = x，标记为。这个程序是无数据竞争的:非原子读取必须参与任何数据竞争，只有当r1 = 1时才执行，这证明线程1的x = 1发生在r1 = x之前，因此也发生在r2 = x之前。DRF-SC意味着程序必须以顺序一致的方式执行，因此r1 = 1，r2 = 2是不可能的，但ES2017规范允许这样做。</p>
<p>因此，ES2017程序行为规范同时太强(它不允许racy程序的真实ARMv8行为)和太弱(它允许无竞争程序的非顺序一致行为)。如前所述，这些错误已经改正。即便如此，这也再次提醒我们，精确地使用以前发生的事情来指定无数据竞争程序和活泼程序的语义是多么微妙，以及将语言内存模型与底层硬件内存模型相匹配是多么微妙。</p>
<p>令人鼓舞的是，至少到目前为止，除了顺序一致的原子之外，JavaScript避免了添加任何其他原子，并抵制了“DRF-SC或着火”结果是内存模型作为C/C++编译目标是有效的，但更接近于Java。</p>
<h2 id="结论">结论</h2>
<p>看看C、C++、Java、JavaScript、Rust和Swift，我们可以得出以下结论:</p>
<ul>
<li>它们都提供顺序一致的同步原子，用于协调并行程序的非原子部分。</li>
<li>它们的目的都是确保程序使用适当的同步来避免数据竞争，就像以顺序一致的方式执行一样。</li>
<li>Java和JavaScript避免了引入弱(acquire/release)同步原子，这似乎是为x86量身定制的。</li>
<li>它们都为程序提供了一种方式来执行“有意的”数据竞争，而不会使程序的其余部分无效。在C、C++、Rust和Swift中，这种机制是relaxed，非同步原子，一种特殊的内存访问形式。在Java和JavaScript中，这种机制就是普通的内存访问。</li>
<li>没有一种语言找到了正式禁止悖论的方法，比如无中生有的值，但是所有语言都非正式地禁止它们。</li>
</ul>
<p>与此同时，处理器制造商似乎已经接受了顺序一致同步原子的抽象对于高效实现非常重要，并开始这样做：ARMv8和RISC-V都提供了直接支持。</p>
<p>最后，真正大量的验证和形式分析工作已经进入了理解这些系统和精确陈述它们的行为。特别令人鼓舞的是，瓦特等人在2020年能够给出一个JavaScript重要子集的正式模型，并使用定理证明器来证明编译对ARM、POWER、RISC-V和x86-TSO的正确性。</p>
<p>在第一个Java内存模型问世25年后，经过许多人世纪的研究努力，我们可能开始能够形式化整个内存模型。也许，有一天，我们也会完全理解他们。</p>
<p>【本系列的下一篇文章，关于Go内存模型，计划在7月12日那一周发布。】</p>
<h2 id="感谢">感谢</h2>
<p>这一系列的帖子从我有幸在谷歌工作的一长串工程师的讨论和反馈中受益匪浅。我感谢他们。我对任何错误或不受欢迎的意见负全部责任。    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Russ Cox的第二篇<a href="https://research.swtch.com/plmm" target="_blank" rel="external">Programming Language Memory Models</a>。</p>
<p>如果你已经阅读了前一篇<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">硬件内存模型</a>,以及如果有Java内存模型或者C++内存模型的经验，本文还好理解，如果你没有相关经验，可能阅读起来比较费劲，建议先阅读一下相关的材料。论文有些词句比较难以理解，本人才学疏浅，有翻译不当之处欢迎批评指正。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go Module之未说的秘密]]></title>
    <link href="https://colobu.com/2021/07/04/dive-into-go-module-3/"/>
    <id>https://colobu.com/2021/07/04/dive-into-go-module-3/</id>
    <published>2021-07-04T07:22:37.000Z</published>
    <updated>2021-10-06T03:29:34.277Z</updated>
    <content type="html"><![CDATA[<p>正常情况下，我们的go.mod依赖库的版本都是符合<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0.0</a>的版本格式，或者<a href="https://golang.org/ref/mod#non-module-compat#glos-pseudo-version" target="_blank" rel="external">伪版本格式</a>。在前面的文章我没有特别提到一点的事，Go使用服务端提交的日期和commit id生成的伪版本号是符合语义化版本号2.0.0的，因为语义化版本号中规定pre-release以连接号<strong>-</strong>加一连串以逗号分隔的标识符组成，标识符以字母数字和连接号组成，所以你看到<code>-yyyyMMddhhmmss-comitid</code>包含两个连接号，这是正常的。</p>
<p>go要求依赖库要么不包含go.mod,要么依赖库中的go.mod定义的依赖库版本必须以语义化版本 2.0.0格式(或伪版本号)标志(其实更严格，除了<code>+incompatible</code>不能加meta字段)，因为这样我们你能够明确标识某个依赖库确切的版本，这样的版本号被称之为<a href="https://golang.org/ref/mod#glos-canonical-version" target="_blank" rel="external">canonical version</a>。</p>
<p>其实main module还可以定义non-canonical version，通过go get或者go mod tidy更新go.mod的时候，命令会尝试更新go.mod,尝试把non-canonical version转变为canonical version版本。</p>
<p>但是，到底有哪些non-canonical version呢？我还没看到官方文章介绍，本文尝试整理这些non-canonical version。</p>
<a id="more"></a>
<h3 id="只定义major或者major-minor">只定义major或者major.minor</h3>
<p>你可以不指定minor.patch或者patch,而是让go命令尝试去寻找最大的minor和patch,所以你可以在go.mod只定义vmajor或者vmajor.minor:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/B v1.<span class="number">2</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/C v1</div><div class="line">github.<span class="keyword">com</span>/panicthis/G/v2 v2</div></pre></td></tr></table></figure>

<p>运行<code>go mod tidy</code>它们会被转换成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/B v1.<span class="number">2.1</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/C v1.<span class="number">4.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/G/v2 v2.<span class="number">0.0</span></div></pre></td></tr></table></figure>

<p><code>go get</code>命令也一样，你也可以直接指定major，忽略minor和patch, 比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go get github.com/panicthis/B@v1.<span class="number">2</span></div><div class="line">go get github.com/panicthis/C@v1</div><div class="line">go get github.com/panicthis/G/v2@v2</div></pre></td></tr></table></figure>

<h3 id="latest,_upgrade_和_patch">latest, upgrade 和 patch</h3>
<p>有三个单词有特别的语义</p>
<ul>
<li>latest: 选择最高的release版本，如果没有release版本，则选择最高的pre-release版本，如果根本就没有打过tag,则选择最高的伪版本号的版本(默认分支的最后的提交版本)</li>
<li>upgrade: 类似latest,但是如果有比release更高的版本(比如pre-release),会选择更高的版本</li>
<li>patch: major和minor和当前的版本相同，只把patch升级到最高。当然如果没有当前的版本，则无从比较，则patch退化成latest语义</li>
</ul>
<p>比如下面的格式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/D latest</div><div class="line">github.<span class="keyword">com</span>/panicthis/E upgrade</div><div class="line">github.<span class="keyword">com</span>/panicthis/F patch</div></pre></td></tr></table></figure>

<p>使用go get命令也一样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/D@latest</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/E@upgrade</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/F@patch //因为没有本地版本，所以此命令在<span class="keyword">go</span> <span class="number">1.16</span>下可能出错</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@v1.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<h3 id="指定特定的commit_id">指定特定的commit id</h3>
<p>因为有时候proxy有缓存时间或者更新周期，如果你提交了一个新的commit,或者新打了一个tag,通过 <code>latest</code>不一定能拉取到最新的提交，这个时候你可以通过指定commit id的方式拉取。或者你就想测试某个特定的版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/H <span class="number">4</span>f7657a</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/H@<span class="number">4</span>f7657a</div></pre></td></tr></table></figure>

<p>甚至，你可以使用<code>HEAD</code>，作为你最新的commit id:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/H HEAD</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/H@HEAD</div></pre></td></tr></table></figure>

<h3 id="特定的分支">特定的分支</h3>
<p>你还可以拉取特定的分支</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/J master</div><div class="line">github.<span class="keyword">com</span>/panicthis/K feat-<span class="number">123</span></div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/J@master</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/K@feat-<span class="number">123</span></div></pre></td></tr></table></figure>

<p>≈</p>
<p>更有甚者，你可以使用<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>比较符，选取某个符合条件的最大的版本。</p>
<p>比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/stretchr/testify &gt;v1.<span class="number">7.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/F &gt;=v1.<span class="number">1.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/F &lt;v1.<span class="number">1.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/F &lt;=v1.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<p>运行go mod tidy它会转换成canonical version。</p>
<p>或者(注意命令行中需要使用转义符)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/stretchr/testify@\&gt;v1.<span class="number">7.0</span></div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@\&gt;=v1.<span class="number">1.0</span></div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@\&lt;v1.<span class="number">1.0</span></div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@\&lt;=v1.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<p>虽然我们可以在go.mod中使用non-canonical version，但是在提交和发布的时候，我们需要使用go mod tidy把它们转换成canonical version,让依赖库的版本对应一个确定的版本，否则<code>master</code>、<code>HEAD</code>在不同的人使用的时候可能会对应不同的版本。</p>
<h3 id="none">none</h3>
<p>还有一个特殊的字符可以作为non-canonical version,比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/stretchr/testify@none</div></pre></td></tr></table></figure>

<p>它会从go module中移出这个依赖。</p>
<h3 id="tip">tip</h3>
<p>有人提议支持go从开发分支上拉取最新的版本。 有几个单次可以候选，但是感觉从 hg/mercurial中借鉴来的<code>tip</code>很合适。go最新的开发版本也叫做<code>tip</code>。</p>
<p>这只是一个提议，未必最终支持。 <a href="https://github.com/golang/go/issues/42545" target="_blank" rel="external">#42545</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>正常情况下，我们的go.mod依赖库的版本都是符合<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0.0</a>的版本格式，或者<a href="https://golang.org/ref/mod#non-module-compat#glos-pseudo-version" target="_blank" rel="external">伪版本格式</a>。在前面的文章我没有特别提到一点的事，Go使用服务端提交的日期和commit id生成的伪版本号是符合语义化版本号2.0.0的，因为语义化版本号中规定pre-release以连接号<strong>-</strong>加一连串以逗号分隔的标识符组成，标识符以字母数字和连接号组成，所以你看到<code>-yyyyMMddhhmmss-comitid</code>包含两个连接号，这是正常的。</p>
<p>go要求依赖库要么不包含go.mod,要么依赖库中的go.mod定义的依赖库版本必须以语义化版本 2.0.0格式(或伪版本号)标志(其实更严格，除了<code>+incompatible</code>不能加meta字段)，因为这样我们你能够明确标识某个依赖库确切的版本，这样的版本号被称之为<a href="https://golang.org/ref/mod#glos-canonical-version" target="_blank" rel="external">canonical version</a>。</p>
<p>其实main module还可以定义non-canonical version，通过go get或者go mod tidy更新go.mod的时候，命令会尝试更新go.mod,尝试把non-canonical version转变为canonical version版本。</p>
<p>但是，到底有哪些non-canonical version呢？我还没看到官方文章介绍，本文尝试整理这些non-canonical version。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]硬件内存模型]]></title>
    <link href="https://colobu.com/2021/06/30/hwmm/"/>
    <id>https://colobu.com/2021/06/30/hwmm/</id>
    <published>2021-06-30T12:54:43.000Z</published>
    <updated>2021-10-06T03:29:34.375Z</updated>
    <content type="html"><![CDATA[<p>Russ Cox关于内存模型的系列文章之一。这是第一篇 <a href="https://research.swtch.com/hwmm" target="_blank" rel="external">Hardware Memory Models</a></p>
<a id="more"></a>
<h2 id="简介:_童话之终局">简介: 童话之终局</h2>
<p>很久以前，当每个人都写单线程程序的时候，让程序运行得更快最有效的方法之一是坐下来袖手旁观。下一代硬件和编译器的优化结果可以让程序像以前一样运行，只是速度会更快。在这个童话般的年代，有一个判断优化是否有效的简单测试方法:如果程序员不能区分合法程序的未优化执行结果和优化执行的结果之间的区别(除了速度的区别)，那么这个优化就是有效的。也就是说，有效的优化不会改变有效程序的行为。</p>
<p>几年前， 某个悲伤的日子，硬件工程师发现让单个处理器越来越快的魔法失效了。不过，他们发现了一个新的魔法，可以让他们创造出拥有越来越多处理器的计算机，操作系统使用线程抽象模型向程序员展示了这种硬件并行能力。这种新的魔法——多处理器以操作系统线程的形式提供并行能力——对硬件工程师来说效果更好，但它给编程语言设计者、编译器作者和程序员带来了严重的问题。</p>
<p>许多在单线程程序中不可见(因此有效)的硬件和编译器优化会在多线程程序中产生明显的结果变化。如果有效的优化没有改变有效程序的行为，那么这些优化应该被认为是无效的。或者现有程序必须被声明为无效的。到底是哪一个，怎么判断？</p>
<p>这里有一个类似C语言的简单示例程序。在这个程序和我们将要考虑的所有程序中，所有变量最初都设置为零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>如果线程1和线程2都运行在自己专用处理器上，都运行到完成，这个程序能打印 0 吗？</p>
<p>看情况(<code>It depends</code>)。这取决于硬件，也取决于编译器。在x86多处理器上, 如果逐行翻译成汇编的程序执行的话总是会打印1。但是在ARM或POWER多处理器上，如果逐行翻译成汇编的程序可以打印0。此外，无论底层硬件是什么，标准编译器优化都可能使该程序打印0或进入无限循环。</p>
<p>“看情况”(<code>It depends</code>)并不是一个圆满的结局。程序员需要一个明确的答案来判断一个程序是否在新的硬件和新的编译器上能够正确运行。硬件设计人员和编译器开发人员也需要一个明确的答案，说明在执行给定的程序时，硬件和编译后的代码可以有多精确。因为这里的主要问题是对存储在内存中数据更改的可见性和一致性，所以这个契约被称为内存一致性模型（<code>memory consistency model</code>）或仅仅是内存模型(<code>memory model</code>)。</p>
<p>最初，内存模型的目标是定义程序员编写汇编代码时硬件提供的保证。在该定义下，是不包含编译器的内容的。25年前，人们开始尝试写内存模型 ，用来定义高级编程语言(如Java或C++)对用该语言编写代码的程序员提供的保证。在模型中包含编译器会使得定义一个合理模型的工作更加复杂。</p>
<p>这是关于硬件内存模型和编程语言内存模型的两篇文章中的第一篇。我写这些文章的目的是先介绍一下背景，以便讨论我们可能想要对Go的内存模型进行的改变。但是，要了解Go当前状况，我们可能想去哪里，首先我们必须了解其他硬件内存模型和语言内存模型的现状，以及他们采取的道路。</p>
<p>还是那句话，这篇文章讲的是硬件。假设我们正在为多处理器计算机编写汇编语言。程序员为了写出正确的程序，需要从计算机硬件上得到什么保证？四十多年来，计算机科学家一直在寻找这个问题的好答案。</p>
<h2 id="顺序一致性">顺序一致性</h2>
<p>Leslie Lamport 1979年的论文<a href="https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/" target="_blank" rel="external">《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》</a>引入了顺序一致性的概念:</p>
<blockquote>
<p>The customary approach to designing and proving the correctness of multiprocess algorithms for such a computer assumes that the following condition is satisfied: the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program. A multiprocessor satisfying this condition will be called sequentially consistent.</p>
</blockquote>
<blockquote>
<p>为这种计算机设计和证明多处理算法正确性的通常方法假定满足下列条件:任何执行的结果都是相同的，就好像所有处理器的操作都是按某种顺序执行的，每个处理器的操作都是按程序指定的顺序出现的。满足这一条件的多处理器系统将被称为顺序一致的。</p>
</blockquote>
<p>今天，我们不仅讨论计算机硬件，还讨论保证顺序一致性的编程语言，当程序的唯一可能执行对应于某种线程操作交替成顺序执行时。顺序一致性通常被认为是理想的模型，是程序员最自然的工作模式。它允许您假设程序按照它们在页面上出现的顺序执行，并且单个线程的执行只是以某种顺序交替(<code>interleaving</code>)，而不是以其他方式排列。</p>
<p>人们可能会有理由质疑顺序一致性是否应该是理想的模型，但这超出了本文的范围。我只注意到，考虑到所有可能的线程交替(<code>interleaving</code>)依然存在，就像在1979年一样，即使过了四十几年，Leslie Lamport的“设计和证明多处理算法正确性的惯用方法”，依然没有什么能取代它。</p>
<p>之前我问这个程序能不能打印0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>为了让程序更容易分析，让我们去掉循环和打印，并询问读取共享变量的可能结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Message Passing</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div></pre></td></tr></table></figure>

<p>我们假设每个例子都是所有共享变量最初都被设置为零。因为我们试图确定硬件允许做什么，我们假设每个线程都在自己的专用处理器上执行，并且没有编译器来对线程中发生的事情进行重新排序:列表中的指令就是处理器执行的指令。rN这个名字表示一个线程本地寄存器，而不是一个共享变量，我们会问一个线程本地寄存器的值在执行结束时是否存在某种可能。</p>
<p>这种关于样本程序执行结果的问题被称为<code>litmus test</code>。因为它只有两个答案——这个结果可能还是不可能？——<code>litmus test</code>为我们提供了一种区分内存模型的清晰方法:如果一个模型支持特定的执行，而另一个不支持，那么这两个模型显然是不同的。不幸的是，正如我们将在后面看到的，一个特定的模型对一个特定的<code>litmus test</code>给出的答案往往令人惊讶。</p>
<p>If the execution of this litmus test is sequentially consistent, there are only six possible interleavings:</p>
<p>如果该<code>litmus test</code>的执行顺序一致，则只有六种可能的交替:</p>
<p><img src="mem-litmus.png" alt=""></p>
<p>因为没有交替执行的结果会产生<code>r1 = 1, r2 = 0</code>,所以这个结果是不允许的。也就是说，在顺序执行的硬件上，litmus test执行结果出现<code>r1 = 1, r2 = 0</code>是不可能的。</p>
<p>顺序一致性的一个很好的思维模型是想象所有处理器直接连接到同一个共享内存，它可以一次处理一个线程的读或写请求。 不涉及缓存，因此每次处理器需要读取或写入内存时，该请求都会转到共享内存。 一次使用一次的共享内存对所有内存访问的执行施加了顺序顺序：顺序一致性。 </p>
<p><img src="mem-sc.png" alt=""></p>
<p>(本文中三个内存模型图摘自 Maranget et al. <a href="A Tutorial Introduction to the ARM and POWER Relaxed Memory Models">“A Tutorial Introduction to the ARM and POWER Relaxed Memory Models.”</a>)</p>
<p>上图是顺序一致机器的模型，而不是构建机器的唯一方法。 实际上，可以使用多个共享内存模块和缓存来构建顺序一致的机器来帮助预测内存获取的结果，但顺序一致意味着机器的行为必须与该模型并无二致。 如果我们只是想了解顺序一致执行意味着什么，我们可以忽略所有这些可能的实现复杂性并只考虑这个模型。 </p>
<p>不幸的是，对于我们程序员，放弃严格的顺序一致性可以让硬件更快地执行程序，所以所有现代硬件在各方面都会偏离了顺序一致性。准确定义具体的硬件偏离是相当困难的。本文以当今广泛使用的硬件中的两种内存模型为例:<strong>x86</strong>、<strong>ARM和POWER处理器系列</strong>。</p>
<h2 id="x86_Total_Store_Order_(x86-TSO)">x86 Total Store Order (x86-TSO)</h2>
<p>现代x86系统的内存模型对应于以下硬件图:<br><img src="mem-tso.png" alt=""></p>
<p>所有处理器仍然连接到一个共享内存，但是每个处理器都将对该内存的写入(<code>write</code>)放入到本地写入队列中。处理器继续执行新指令，同时写操作(<code>write</code>)会更新到这个共享内存。一个处理器上的内存读取在查询主内存之前会查询本地写队列，但它看不到其他处理器上的写队列。其效果就是当前处理器比其他处理器会先看到自己的写操作。但是——这一点非常重要——所有处理器都保证写入(存储<code>store</code>)到共享内存的(总)顺序，所以给这个模型起了个名字:总存储有序，或<code>TSO</code>。当一个写操作到达共享内存时，任何处理器上的任何未来读操作都将看到它并使用该值(直到它被以后的写操作覆盖，或者可能被另一个处理器的缓冲写操作覆盖)。</p>
<p>写队列是一个标准的先进先出队列:内存写操作以与处理器执行相同的顺序应用于共享内存。因为写入顺序由写入队列保留，并且由于其他处理器会立即看到对共享内存的写入，所以我们之前考虑的通过<code>litmus test</code>的消息与之前具有相同的结果:<code>r1 = 1，r2 = 0</code>仍然是不可能的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Message Passing</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div><div class="line">On sequentially consistent hardware: no. </div><div class="line">On x86 (or other TSO): no.</div></pre></td></tr></table></figure>

<p>写队列保证线程1在y之前将x写入内存，关于内存写入顺序(总存储有序)的系统级协议保证线程2在读y的新值之前读x的新值。因此，<code>r1 = y</code>在<code>r2 = x</code>看不到新的x之前不可能看到新的y。存储顺序至关重要:线程1在写入y之前先写入x，因此线程2在看到x的写入之前不可能看到y的写入。</p>
<p>在这种情况下，顺序一致性和TSO模型是一致的，但是他们在其他litmus test的结果上并不一致。例如，这是区分两种型号的常用示例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Write Queue (also called Store Buffer)</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">0</span>, <span class="variable">r2 =</span> <span class="number">0</span>?</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>           // Thread <span class="number">2</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>                 <span class="variable">y =</span> <span class="number">1</span></div><div class="line"><span class="variable">r1 =</span> y                <span class="variable">r2 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): yes!</div></pre></td></tr></table></figure>

<p>在任何顺序一致的执行中，<code>x = 1</code>或<code>y = 1</code>必须首先发生，然后另一个线程中的读取必须能够观察到它(此赋值事件)，因此<code>r1 = 0，r2 = 0</code>是不可能的。但是在一个TSO系统中，线程1和线程2可能会将它们的写操作排队，然后在任何一个写操作进入内存之前从内存中读取，这样两个读操作都会看到零。</p>
<p>这个例子看起来可能是人为制造的，但是使用两个同步变量确实发生在众所周知的同步算法中，例如<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm" target="_blank" rel="external">德克尔算法</a>或<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm" target="_blank" rel="external">彼得森算法</a>，以及特定的方案。如果一个线程没有看到另一个线程的所有写操作，线程就可能会中断。</p>
<p>为了修复同步算法，我们需要依赖于更强的内存排序，非顺序一致的硬件提供了称为内存屏障(或栅栏)的显式指令，可用于控制排序。我们可以添加一个内存屏障，以确保每个线程在开始读取之前都会刷新其先前对内存的写入:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x =<span class="number"> 1</span>                 y =<span class="number"> 1</span></div><div class="line">barrier               barrier</div><div class="line">r1 = y                r2 = x</div></pre></td></tr></table></figure>

<p>加上正确的障碍，<code>r1 = 0，r2 = 0</code>也是不可能的，德克尔或彼得森的算法就可以正常工作了。内存屏障有很多种；具体细节因系统而异，不在本文讨论范围之内。关键是内存屏障的存在给了程序员或语言实现者一种在程序的关键时刻强制顺序一致行为的方法。</p>
<p>最后一个例子，说明为什么这种模式被称为总存储有序。在该模型中，读路径上有本地写队列，但没有缓存。一旦一个写操作到达主存储器，所有处理器不仅都认同该值存在，而且还认同它相对于来自其他处理器的写操作的先后顺序。考虑一下这个litmus test:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Independent Reads of Independent Writes (IRIW)</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">0</span>, <span class="variable">r3 =</span> <span class="number">1</span>, <span class="variable">r4 =</span> <span class="number">0</span>?</div><div class="line">(Can Threads <span class="number">3</span> <span class="constant">and</span> <span class="number">4</span> see x <span class="constant">and</span> y change <span class="keyword">in</span> different orders?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">y =</span> <span class="number">1</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> y</div><div class="line">                              <span class="variable">r2 =</span> y         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div></pre></td></tr></table></figure>

<p>如果线程3看到x先于y变化，那么线程4能看到y先于x变化吗？对于x86和其他TSO机器，答案是否定的:对主内存的所有存储(写入)都有一个总顺序，所有处理器都认同这个顺序，只是每个处理器在到达主内存之前都先知道自己的写入而已。</p>
<h2 id="x86-TSO_之路">x86-TSO 之路</h2>
<p>x86-TSO模型看起来相当整洁，但是这条道路充满了路障和错误的弯道。在20世纪90年代，第一批x86多处理器可用的手册几乎没有提到硬件提供的内存模型。</p>
<p>作为问题困扰的一个例子，Plan 9 是第一个在x86上运行的真正多处理器操作系统(没有全局内核锁)。1997年，在移植到多处理器 奔腾Pro的过程中，开发人员被写队列litmus test的不期望的行为所困扰。一小段同步代码假设<code>r1 = 0，r2 = 0</code>是不可能的，但它确实发生了。更糟糕的是，英特尔手册对内存模型的细节模糊不清。</p>
<p>针对邮件列表中提出的“使用锁最好保守一点，不要相信硬件设计师会做我们期望的事情”的建议，Plan 9的一名开发人员很好地<a href="https://web.archive.org/web/20091124045026/http://9fans.net/archive/1997/04/76" target="_blank" rel="external">解释了这个问题</a>:</p>
<blockquote>
<p>我当然同意。我们会在多处理器中遇到更宽松的顺序(relaxed ordering )。问题是，硬件设计者认为什么是保守的？在临界区的开头和结尾强制互锁对我来说似乎相当保守，但我显然不够富有想象力。奔腾Pro的手册在描述缓存和怎么使它们保持一致时非常详细，但似乎不在乎说任何关于执行或read顺序的细节。事实是，我们无法知道自己是否足够保守。</p>
</blockquote>
<p>在讨论过程中，英特尔的一名架构师对内存模型做了非正式的解释，指出理论上，即使是多处理器486和奔腾系统也可能产生<code>r1 = 0，r2 = 0</code>的结果，并且奔腾Pro只是具有更大的流水线和写队列，所以会更频繁地暴露了这种行为。</p>
<p>这位英特尔架构师还写道:</p>
<blockquote>
<p>Loosely speaking, this means the ordering of events originating from any one processor in the system, as observed by other processors, is always the same. However, different observers are allowed to disagree on the interleaving of events from two or more processors.<br>Future Intel processors will implement the same memory ordering model.</p>
<p>粗略地说，这意味着从系统中任何一个处理器产生的事件的顺序，正如其他处理器所观察到的，总是相同的。然而，允许不同的观察者对来自两个或更多处理器的事件的交替有不同的观察结果。<br>未来的英特尔处理器将采用相同的内存顺序模式。</p>
</blockquote>
<p>声称“允许不同的观察者对来自两个或更多处理器的事件的交替有不同的观察结果”是在说，IRIW litmus test的答案在x86上可以回答“是”，尽管在前面的部分我们看到x86回答“否”。这怎么可能呢？</p>
<p>答案似乎是，英特尔处理器实际上从未对这一litmus test做出“是”的回答，但当时英特尔架构人员不愿意为未来的处理器做出任何保证。体系结构手册中存在的少量文本几乎没有任何保证，使得很难针对它们进行编程。</p>
<p>Plan 9的讨论不是一个孤立的事件。从11月下旬开始，Linux内核开发人员在他们的邮件列表上<a href="https://lkml.org/lkml/1999/11/20/76" target="_blank" rel="external">讨论了100多条消息</a>。</p>
<p>在接下来的十年里，越来越多的人遇到了这些困难，为此，英特尔的一组架构师承担了为当前和未来的处理器写下有用的处理器行为保证的任务。第一个结果是2007年8月出版的<a href="http://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf" target="_blank" rel="external">Intel 64 Architecture Memory Ordering White Paper</a>，旨在为“软件作者提供对不同顺序的内存访问指令可能产生的结果的清晰理解”。同年晚些时候，AMD在<a href="https://courses.cs.washington.edu/courses/cse351/12wi/supp-docs/AMD%20Vol%201.pdf" target="_blank" rel="external">AMD64 Architecture Programmer&#39;s Manual revision 3.14</a>中发布了类似的描述。这些描述基于一个被称为“总锁序+因果一致性”(TLO+CC)的模型，故意弱于TSO。在公开访谈中，英特尔架构师表示，TLO+CC<a href="http://web.archive.org/web/20080512021617/http://blogs.sun.com/dave/entry/java_memory_model_concerns_on" target="_blank" rel="external">“像要求的那样强大，但并不足够强大。”</a>特别是，该模型保留了x86处理器在IRIW litmus test中回答“是”的权利。不幸的是，内存屏障的定义不够强大，不足以重建顺序一致的内存语义，即使每个指令之后都有一个屏障。更糟糕的是，研究人员观察到实际的英特尔x86硬件违反了TLO+CC模型。例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: n6 (Paul Loewenstein)</div><div class="line">Can this program <span class="operator"><span class="keyword">end</span> <span class="keyword">with</span> r1 = <span class="number">1</span>, r2 = <span class="number">0</span>, x = <span class="number">1</span>?</span></div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span></div><div class="line">x = <span class="number">1</span>          y = <span class="number">1</span></div><div class="line">r1 = x         x = <span class="number">2</span></div><div class="line">r2 = y</div><div class="line"><span class="keyword">On</span> sequentially <span class="keyword">consistent</span> hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 TLO+CC model (<span class="number">2007</span>): <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> actual x86 hardware: yes!</div><div class="line"><span class="keyword">On</span> x86 TSO model: yes! (Example <span class="keyword">from</span> x86-TSO paper.)</div></pre></td></tr></table></figure>

<p>2008年晚些时候对英特尔和AMD规范的修订保证了IRIW case的“不”，并加强了内存屏障，但仍允许不可预期的行为，这些行为似乎不会出现在任何合理的硬件上。例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: n5</div><div class="line">Can this program <span class="operator"><span class="keyword">end</span> <span class="keyword">with</span> r1 = <span class="number">2</span>, r2 = <span class="number">1</span>?</span></div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span></div><div class="line">x = <span class="number">1</span>          x = <span class="number">2</span></div><div class="line">r1 = x         r2 = x</div><div class="line"><span class="keyword">On</span> sequentially <span class="keyword">consistent</span> hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 specification (<span class="number">2008</span>): yes!</div><div class="line"><span class="keyword">On</span> actual x86 hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 TSO model: <span class="keyword">no</span>. (Example <span class="keyword">from</span> x86-TSO paper.)</div></pre></td></tr></table></figure>

<p>为了解决这些问题，欧文斯等人在<a href="https://research.swtch.com/sparcv8.pdf" target="_blank" rel="external">早期SPARCv8 TSO模型</a>的基础上提出了<a href="https://www.cl.cam.ac.uk/~pes20/weakmemory/x86tso-paper.tphols.pdf" target="_blank" rel="external">x86-TSO模型提案</a>。当时，他们声称“据我们所知，x86-TSO是可靠的，足够强大，可以在上面编程，并且大致符合供应商的意图。“几个月后，英特尔和AMD发布了广泛采用这一模式的的新手册。</p>
<p>似乎所有英特尔处理器从一开始就实现了x86-TSO，尽管英特尔花了十年时间才决定致力于此。回想起来，很明显，英特尔和AMD的设计师们正在努力解决如何编写一个能够为未来处理器优化留出空间的内存模型，同时仍然为编译器作者和汇编语言程序设计者提供有用的保证。“有多强就有多强，但没有多强”是一个艰难的平衡动作。</p>
<h2 id="ARM/POWER_Relaxed_Memory_Model">ARM/POWER Relaxed Memory Model</h2>
<p>现在让我们来看看一个更宽松的内存模型，在ARM和POWER处理器上找到的那个。在实现层面上，这两个系统在许多方面有所不同，但保证内存一致性的模型大致相似，比x86-TSO甚至x86-TLO+CC稍弱。</p>
<p>ARM和POWER系统的概念模型是，每个处理器从其自己的完整内存副本中读取和向其写入，每个写入独立地传播到其他处理器，随着写入的传播，允许重新排序。<br><img src="mem-weak.png" alt=""></p>
<p>这里没有总存储顺序。虽然没有描述，但是每个处理器都被允许推迟读取(<code>read</code>)，直到它等到它需要结果:读取(<code>read</code>)可以被延迟到稍后的写入(<code>write</code>)之后。在这个宽松的(<code>relaxed</code>)模型中，我们迄今为止所看到的每一个litmus test的答案都是“yes，这真的可能发生。”</p>
<p>对于通过litmus test的原始消息，单个处理器对写入的重新排序意味着线程1的写入可能不会被其他线程以相同的顺序观察到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Message Passing</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): no.</div><div class="line">On ARM/POWER: yes!</div></pre></td></tr></table></figure>

<p>在ARM/POWER模型中，我们可以想象线程1和线程2都有各自独立的内存副本，写操作以任何顺序在内存之间传播。如果线程1的内存在发送x的更新(<code>update</code>)之前向线程2发送y的更新，并且如果线程2在这两次更新之间执行，它将确实看到结果<code>r1 = 1，r2 = 0</code>。</p>
<p>该结果表明，ARM/POWER内存模型比TSO更弱:对硬件的要求更低。ARM/POWER模型仍然承认TSO所做的各种重组:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Store Buffering</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">0</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): yes!</div><div class="line">On ARM/POWER: yes!</div></pre></td></tr></table></figure>

<p>在ARM/POWER上，对x和y的写入(<code>write</code>)可能会写入本地存储器，但当读取发生在相反的线程上时，写入可能尚未传播开来。</p>
<p>下面是一个litmus test，它展示了x86拥有总存储顺序意味着什么:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Independent Reads of Independent Writes (IRIW)</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">0</span>, <span class="variable">r3 =</span> <span class="number">1</span>, <span class="variable">r4 =</span> <span class="number">0</span>?</div><div class="line">(Can Threads <span class="number">3</span> <span class="constant">and</span> <span class="number">4</span> see x <span class="constant">and</span> y change <span class="keyword">in</span> different orders?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">y =</span> <span class="number">1</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> y</div><div class="line">                              <span class="variable">r2 =</span> y         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div><div class="line">On ARM/POWER: yes!</div></pre></td></tr></table></figure>

<p>在ARM/POWER上，不同的线程可能以不同的顺序观察到不同的写操作。它们不能保证对到达主内存的总写入顺序达成一致的观察效果，因此线程3可以在y变化之前之前看到x的变化，而线程4可以在x变化之前看到y的变化。</p>
<p>作为另一个例子，ARM/POWER系统具有内存读取(负载 load)的可见缓冲或重新排序，如下面litmus test所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: <span class="operator"><span class="keyword">Load</span> Buffering</span></div><div class="line">Can this program see r1 = <span class="number">1</span>, r2 = <span class="number">1</span>?</div><div class="line">(Can <span class="keyword">each</span> thread<span class="string">'s read happen after the other thread'</span>s <span class="keyword">write</span>?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span></div><div class="line">r1 = x         r2 = y</div><div class="line">y = <span class="number">1</span>          x = <span class="number">1</span></div><div class="line"><span class="keyword">On</span> sequentially <span class="keyword">consistent</span> hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 (<span class="keyword">or</span> other TSO): <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> ARM/<span class="keyword">POWER</span>: yes!</div></pre></td></tr></table></figure>

<p>任何顺序一致的交替必须从线程1的<code>r1 = x</code>或线程2的<code>r2 = y</code>开始，该读取必须看到一个0，使得结果r1 = 1，r2 = 1不可能。然而，在ARM/POWER存储器模型中，处理器被允许延迟读取，直到指令流中稍后的写入之后，因此y = 1和x = 1在两次读取之前执行。</p>
<p>尽管ARM和POWER内存模型都允许这一结果，但Maranget等人(2012年)<a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf" target="_blank" rel="external">报告说</a>，只能在ARM系统上凭经验重现，而不能在POWER上复制。在这里，模型和真实度之间的差异开始发挥作用，就像我们在检查英特尔x86时一样:硬件实现比技术保证更强大的模型会鼓励对更强的行为的依赖，这意味着未来更弱的硬件将破坏程序，无论是否有效。</p>
<p>像TSO系统上一样，ARM和POWER也有内存屏障，我们可以在上面的例子中插入这些内存屏障，以强制顺序一致的行为。但显而易见的问题是，没有内存屏障的ARM/POWER是否完全排除了任何行为。任何litmus test的答案是否都是“no，那不可能发生？” 当我们专注于一个单一的内存位置时，它可以。</p>
<p>这里有一个litmus test，它可以测试即使在ARM和POWER上也不会发生的事情:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Coherence</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">2</span>, <span class="variable">r3 =</span> <span class="number">2</span>, <span class="variable">r4 =</span> <span class="number">1</span>?</div><div class="line">(Can Thread <span class="number">3</span> see <span class="variable">x =</span> <span class="number">1</span> before <span class="variable">x =</span> <span class="number">2</span> while Thread <span class="number">4</span> sees the reverse?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">x =</span> <span class="number">2</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> x</div><div class="line">                              <span class="variable">r2 =</span> x         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div><div class="line">On ARM/POWER: no.</div></pre></td></tr></table></figure>

<p>这个litmus test与前一个测试类似，但是现在两个线程都在写入单个变量x，而不是两个不同的变量x和y。线程1和2将冲突的值1和2都写入x，而线程3和线程4都读取x两次。如果线程3看到x = 1被x = 2覆盖，那么线程4能看到相反的情况吗？</p>
<p>答案是<strong>no</strong>的，即使在ARM/POWER上也是如此:系统中的线程必须就写入单个内存位置的总顺序达成一致。也就是说，线程必须同意哪些写入会覆盖其他写入。这个性质叫做相干性。如果没有一致性属性，处理器要么不同意内存的最终结果，要么报告内存位置从一个值翻转到另一个值，然后又回到第一个值。编写这样一个系统是非常困难的。</p>
<p>我故意忽略了ARM和POWER弱内存模型中的许多微妙之处。更多详细信息，请参阅彼得·苏厄尔关于<a href="https://www.cl.cam.ac.uk/~pes20/papers/topics.html#Power_and_ARM" target="_blank" rel="external">该主题</a>的论文。有两个要点要记住。首先，这里有令人难以置信的微妙之处，这是由有非常持久力、非常聪明的人进行了十多年学术研究的主题。我自己并不声称完全理解。这不是我们应该希望向普通程序设计人员解释的事情，也不是我们在调试普通程序时希望能够坚持的事情。第二，允许和观察到的结果之间的差距造成了不幸的未来惊喜。如果当前的硬件没有展现出所有允许的行为——尤其是当首先很难推理出什么是允许的时候！—那么不可避免地会编写一些程序，这些程序会偶然地依赖于实际硬件的更受限制的行为。如果一个新的芯片在行为上受到的限制更少，那么硬件内存模型在技术上允许破坏程序的新行为——也就是说，这个错误在技术上是你的错——这一事实并不能给你带来什么安慰。这不是写程序的方法。</p>
<h2 id="弱排序和无数据竞争的顺序一致性">弱排序和无数据竞争的顺序一致性</h2>
<p>到目前为止，我希望您确信硬件细节是复杂而微妙的，而不是您每次编写程序时都想解决的问题。 相反，它有助于识别“如果你遵循这些简单的规则，你的程序只会产生结果，就像通过一些顺序一致的执行的那样。” （我们仍在谈论硬件，所以我们仍在谈论交替独立的汇编指令。） </p>
<p>Sarita Adve and Mark Hill proposed exactly this approach in their 1990 paper “Weak Ordering – A New Definition”. They defined “weakly ordered” as follows.</p>
<p>Sarita Adve和Mark Hill在他们1990年的论文<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5567" target="_blank" rel="external">“Weak Ordering – A New Definition”</a>中正是提出了这种方法。他们把“弱有序”定义为如下。</p>
<blockquote>
<p>Let a synchronization model be a set of constraints on memory accesses that specify how and when synchronization needs to be done.</p>
<p>同步模型是对内存访问的一组约束，这些约束指定了何时以及如何进行同步。</p>
</blockquote>
<p>硬件相对于同步模型是弱有序的，当且仅当它在顺序上与遵守同步模型的所有软件一致时。</p>
<p>虽然他们的论文是关于捕捉当时的硬件设计(不是x86、ARM和POWER)，但将讨论提升到特定设计之上的想法使论文与今天的讨论依然相关。</p>
<p>我之前说过“有效的优化不会改变有效程序的行为。”这些规则定义了什么是有效的手段，然后任何硬件优化都必须让这些程序像在顺序一致的机器上一样工作。当然，有趣的细节是规则本身，定义程序有效的约束。</p>
<p>Adve和Hill提出了一种同步模型，他们称之为无数据竞争(data-race-free，DRF)。该模型假设硬件具有独立于普通内存读写的内存同步操作。普通的内存读写可以在同步操作之间重新排序，但不能在跨它们移动。(也就是说，同步操作也可用来做重新排序的内存屏障。)如果对于所有理想化的顺序一致的执行，从不同线程对同一位置的任何两个普通存储器访问要么都是读取，要么通过同步操作强制一个在另一个之前发生而分开执行，则程序被称为无数据竞争的。<br>我们来看一些例子，摘自Adve和Hill的论文(为了演示而重新绘制)。这里有一个线程执行变量x的写操作，然后读取同一个变量。<br><img src="mem-adve-1.png" alt=""><br>垂直箭头标记了单个线程内的执行顺序:先写后读。这个程序没有竞争，因为一切都在一个线程中。</p>
<p>相比之下，在这个双线程程序中有一个竞争:<br><img src="mem-adve-2.png" alt=""></p>
<p>这里线程2在不与线程1协调的情况下写入x。线程2的写入与线程1的写入和读取竞争。如果线程2读x而不是写x，程序在线程1写和线程2读之间只有一个竞争。每个竞争至少涉及一次写入:两次不协调的读取不会相互竞争。</p>
<p>为了避免竞争，我们必须添加同步操作，这将在共享一个同步变量的不同线程上的操作之间强制一个特定的顺序。如果同步S(a)(在变量a上同步，用虚线箭头标记)迫使线程2的写操作在线程1完成后发生，则竞争被消除-<br><img src="mem-adve-3.png" alt=""></p>
<p>现在线程2的写操作不能与线程1的操作同时发生。</p>
<p>如果线程2只是读取，我们只需要与线程1的写入同步。两次读取仍然可以同时进行:</p>
<p><img src="mem-adve-4.png" alt=""></p>
<p>线程可以按同步顺序排序，甚至可以使用中间线程。这个程序没有竞争:</p>
<p><img src="mem-adve-5.png" alt=""></p>
<p>另一方面，同步变量的使用本身并不能消除竞争:错误地使用它们是可能的。下面这个程序有一个竞争:<br><img src="mem-adve-6.png" alt=""></p>
<p>线程2的读取与其他线程中的写入完全同步——这肯定发生在两者之后——但是这两个写入本身并不同步。这个程序并不是data-race-free。</p>
<p>Adve和Hill将弱排序描述为“软件和硬件之间的契约”，具体来说，如果软件避免了数据竞争，那么硬件就好像是顺序一致的，这比我们在前面部分研究的模型更容易推理。但是硬件如何满足它的契约呢？</p>
<p>Adve和Hill给出了硬件“遵循DRF弱排序”的证明，这意味着它执行无数据竞争的程序，就好像是按照顺序一致的顺序一样，只要它满足一组特定的最低要求。我不打算详谈细节，但重点是在Adve和Hill的论文发表后，硬件设计师们有了一份由理论支持的手册:做这些事情，你就可以断言你的硬件将与data-race-free程序顺序一致。事实上，假设同步操作的适当实现，大多数宽松的硬件确实是这样做的，并且一直在继续这样做。Adve和Hill最初关注的是VAX，但x86、ARM和POWER肯定也能满足这些限制。这种系统保证无数据竞争程序的顺序一致性的观点通常被缩写为DRF-SC。</p>
<p>DRF-SC标志着硬件内存模型的一个转折点，为硬件设计者和软件作者提供了一个清晰的策略，至少是那些用汇编语言编写软件的人。正如我们将在下一篇文章中看到的，高级编程语言的内存模型问题没有一个整洁的答案。</p>
<blockquote>
<p>下一篇，关于编程语言内存模型，计划在7月5日那一周。然后专门计划在7月12日的那一周发布一篇关于Go内存模型的文章。</p>
</blockquote>
<h2 id="致谢">致谢</h2>
<p>这一系列的帖子从我有幸在谷歌共事的一长串工程师的讨论和反馈中受益匪浅。我感谢他们。我对任何错误或不受欢迎的意见承担全部责任。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Russ Cox关于内存模型的系列文章之一。这是第一篇 <a href="https://research.swtch.com/hwmm" target="_blank" rel="external">Hardware Memory Models</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go Module之讨厌的v2]]></title>
    <link href="https://colobu.com/2021/06/28/dive-into-go-module-2/"/>
    <id>https://colobu.com/2021/06/28/dive-into-go-module-2/</id>
    <published>2021-06-28T03:56:05.000Z</published>
    <updated>2021-10-06T03:29:34.276Z</updated>
    <content type="html"><![CDATA[<p>Go module不但遵循<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本规范 2.0.0</a>,而且还更进一步，对语义化版本中的major还还赋予了更深的意义。</p>
<a id="more"></a>
<p><img src="semver2.png" alt=""></p>
<ul>
<li>v0.X.X: 对于主版本号(major)是0的情况，隐含你当前的API还处于不稳定的状态，新的小版本可能不向下兼容</li>
<li>v1.X.X: 当前的API处于稳定状态，minor的增加只意味着新的feature的增加，API还是向下兼容的</li>
<li>v2.X.X: major的增加意味着API已经不向下兼容了</li>
</ul>
<blockquote>
<p><strong>问题</strong>： 你知道在go module中，哪些版本号隐含当前API是不稳定的？</p>
</blockquote>
<p>但是go module与众不同鹤立鸡群卓然不群的是，一旦你的major大于等于2, 你的module path必须加上v2后缀(如果tag是v3.X.X,那就是v3后缀，以此类推)。</p>
<p>而且，包引用路径也要加上v2，比如 <code>go.etcd.io/etcd/client/v3</code>。</p>
<p>这是一个怪异的写法，相当于在正常的易于理解的module path上加了一个狗屁膏药，以提示这个引入的库是哪个版本的？</p>
<p>为什么要加上这个v2、v2后缀的，肯定有一定的考虑。</p>
<p>最主要的，Go的开发者(这里指Russ Cox)在<a href="https://research.swtch.com/vgo-import" target="_blank" rel="external">import compatibility rule</a>指出:</p>
<blockquote>
<p>If an old package and a new package have the same import path,<br>the new package must be backwards compatible with the old package.</p>
</blockquote>
<p>也就是相同module path应该保证新的版本向下兼容。</p>
<p><img src="deps.png" alt=""></p>
<p>这种想法是好的。比如你在你的项目中可以使用同一个库的多个版本， v1版本处理以前遗留的逻辑，v2版本处理新的逻辑，v3版本试验未来的版本，同一套库的不同版本可以共存，并不会出现版本冲突的地方。</p>
<p>而且程序员看到这些module path,也很清楚的知道版本不兼容了，谁是更新的版本。</p>
<p>但是这种方式也是很有争议的，在实践中中也带来了很多问题，我在开发rpcx深受其害，又比如etcd,你可以看它的v3.4.X的版本，就是因为没有加上v3的后缀，导致go命令下载或者导入(get)这些package的时候根本就下载不了。</p>
<h2 id="vX后缀污染了package_path">vX后缀污染了package path</h2>
<p>本来正常的package path一般是仓库路径+package name,或者go module下 module path + package的方式，可是一旦版本大于等于2,就不得不加上一个后缀v2,v3等，将package path的含义改变了。</p>
<p>当然忍一忍我们还能接受，大不了闭着眼睛用呗，最痛苦的很多Go的初学者并不了解这种设置，不知道导入新的库的版本要加v2后缀，一脸茫然。</p>
<h2 id="v0,_v1和v2数据类型不兼容">v0, v1和v2数据类型不兼容</h2>
<p>在module path中增加了v2,v3等后缀后，也就以为着这些package都是不同的package，虽然它们中大部分的数据类型并没有做改变，还是向下兼容的，也不能直接赋值，还是需要强转一下。</p>
<p>比如你的项目依赖<code>Auth 1.0.0</code>, 也依赖<code>Auth 2.0.0</code>,那么即使<code>A.Config</code>在两个版本中没做任何改变，你也不能把<code>Auth.Config</code>赋值给<code>Auth/v2.Config</code>,而是需要在代码中加上强转的逻辑，两两互转。一旦发布了v3,那就得三三互转，很长的一个switch分支处理这种情况，如果发布v4，那么逻辑更复杂了。</p>
<h2 id="给第三方库的开发者带来了很大的负担">给第三方库的开发者带来了很大的负担</h2>
<p>虽然你觉得我也就发布v2,v3,v4等几个版本，版本路线很清晰，管理起来也不复杂，没什么大不了的。</p>
<p>但是，如果你的库是一个非常流行的库，很多开发者基于你的库开发了第三方的库的话，就非常痛苦了。</p>
<p>这意味着一旦你发布了一个新的版本，这些第三方的开发者就必须及时的更新他们的库，基于你的新的版本发布他们新的v2，v3版本。这就像病毒一样，初步扩展开来。给广大的开发者带来的很大的负担。</p>
<p>当然，见仁见智，这些情况可能你不会遇到，或者也不会给你带来困扰，所以它不是一个问题。而我，在开发rpcx，或者解答一些网友的问题的时候，深深被v2伤害到了,小小的心灵无法承受v2之重。</p>
<p>一些开源项目，为了避免版本号跳到v2,采用了其它的一些办法，比如protobuf-go, 正在做新的版本的重构，改动非常大，不和以前的版本兼容了，可以以前的版本都v1.X.X了，那怎么办呢？换module path名称。</p>
<ul>
<li>github.com/golang/protobuf: 支持先前的protobuf go,目前最高版本v1.5.2</li>
<li>google.golang.org/protobuf: 新版本的module path,目前最高版本v1.27.0，初始版本v1.20.0</li>
</ul>
<p>对于我开发的rpcx项目，因为在go module出来之前版本号已经发布到了v6.X.X。 我想回到从前，貌似回不去了。所以我采用了一个极端的做法，把tag重建，所有的版本号都定义在v1.X.X内。还好影响的用户比较少，所以也没有用户抱怨。</p>
<p>我这种做法比较极端，没造成用户抱怨的原因是我一直坚持go module和GOPATH并存的方式。发版的时候采用go module发版，master开发分支上采用GOPATH方式，绝大部分用户都使用master分支，或者自己fork了一个新的版本，所以造成的影响很小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go module不但遵循<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本规范 2.0.0</a>,而且还更进一步，对语义化版本中的major还还赋予了更深的意义。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go Module之go.mod文件解析]]></title>
    <link href="https://colobu.com/2021/06/28/dive-into-go-module-1/"/>
    <id>https://colobu.com/2021/06/28/dive-into-go-module-1/</id>
    <published>2021-06-28T00:04:01.000Z</published>
    <updated>2021-10-06T03:29:34.273Z</updated>
    <content type="html"><![CDATA[<p>昨天在GopherChina 2021大会上分享了《深入Go Module》，干货太多了，接下来的分几篇文章详细介绍下。</p>
<a id="more"></a>
<p>现在哪个新编程语言不都是提供库版本工具呢？Java、Python、nonjs、rust都有一套自己的库管理方法和库注册中心，不管它们的叫法如何。Go最初推出来的时候并没有一个库管理方式，而是采用<strong>GOPATH</strong>的方式，所有的项目都必须放在GOPATH下，不止一次有从其它语言比如Java转过过来的同学问我:&quot;为什么我在我的一个文件夹下建的项目没法编译呢？&quot;,那是因为他的文件夹没有建在GOPATH下，而等他想在GOPATH下建项目的时候，package path他又不知道该怎么写。</p>
<p>所以GO使用的GOPATH方式确实对新手来说是一件非常令人困惑的事。而随着Go生态圈的快速壮大，另一个经典的库管理的问题也出现了。就是我们项目中的依赖库经常出现API broken的情况，因为依赖的库相关接口改变了，导致我们的项目更新了依赖库后编译不过，我们不得不需要修改自己的代码以便适应依赖库的最新版本。更困难的是，如果多个依赖库分别依赖第三个依赖库的第三个版本，版本冲突就出现了。</p>
<p>依赖库冲突几乎每个编程语言都有这样的问题，甚至操作系统也有<a href="https://baike.baidu.com/item/DLL%E5%9C%B0%E7%8B%B1" target="_blank" rel="external">DLL地狱问题</a>,所以各种编程语言都尝试使用自己的方式解决依赖库版本的问题。</p>
<p>前面说了，Go最初是没有官方的库版本的方式的，都是靠第三方的工具实现，比如godep、glide、dep等,从2012年各种工具分别出现，大海淘沙，浮浮沉沉，最后也就有几个常用的工具大家在使用，dep是2017出现的一个版本，让人眼前一亮，而且也得到了Go官方的支持，项目也放在Golang组织之下<a href="https://github.com/golang/dep" target="_blank" rel="external">golang/dep</a>。</p>
<p>但是蜜月期没有多久，2018年Russ Cox经过深思熟虑以及一些早期的试验，决定go库版本的方式需要从头再来，深度集成go的各种工具(go get、go list等)，实现精巧的最小化版本选择算法，解决broken API共存等问题，所以dep就被废弃了，这件事还导致dep的作者相当的失望和数次争辩。</p>
<p>但是不管怎样，Go官方的库管理方式还是在2018年go 1.11中实验性的推出了，通过设置一个环境变量<code>GO111MODULE=on</code>就可以弃用，并且期望go 1.12正式退出，而环境变量<code>GO111MODULE=on</code>就可以去掉了。可是没有想到的是，go module推出后问题多多，现在每一个go的版本中都有对go module修改，导致这个特性一直没有最终完成，这也是我吐槽它的地方：都快三年了，一个feature都开发那么久，而且未来的go 1.17、go 1.18还有一些改变，同学们，还学的动吗？</p>
<p>go官方库管理方式叫做go module。 先前，我们的库都是以package来组织的，package以一个文件或者多个文件实现单一的功能，一个项目包含一个package或者多个package。Go module就是一组统一打版和发布的package的集合，在根文件下有go.mod文件定义module path和依赖库的版本，package以子文件夹的形式存在module中，对package path就是 module path +&quot;/&quot;+ package name的形式。</p>
<p>一般我们项目都是单module的形式，项目主文件夹下包含go.mod,子文件夹定义package，或者主文件夹也是一个package。但是一个项目也可以包含多个module,只不过这种方式不常用而已。</p>
<h2 id="go-mod">go.mod</h2>
<p>go module最重要的是go.mod文件的定义，它用来标记一个module和它的依赖库以及依赖库的版本。会放在module的主文件夹下，一般以<code>go.mod</code>命名。</p>
<p>一个go.mod内容类似下面的格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">module github.com/panicthis/modfile</div><div class="line"></div><div class="line"><span class="keyword">go</span><span class="number"> 1.16</span></div><div class="line"></div><div class="line">require (</div><div class="line">	github.com/cenk/backoff v2<span class="number">.2.1</span>+incompatible</div><div class="line">	github.com/coreos/bbolt v1<span class="number">.3.3</span></div><div class="line">	github.com/edwingeng/doublejump v0<span class="number">.0.0</span><span class="number">-20200330080233</span>-e4ea8bd1cbed</div><div class="line">	github.com/stretchr/objx v0<span class="number">.3.0</span> <span class="comment">// indirect</span></div><div class="line">	github.com/stretchr/testify v1<span class="number">.7.0</span></div><div class="line">	<span class="keyword">go</span>.etcd.io/bbolt v1<span class="number">.3.6</span> <span class="comment">// indirect</span></div><div class="line">	<span class="keyword">go</span>.etcd.io/etcd/client/v2 v2<span class="number">.305.0</span>-rc<span class="number">.1</span></div><div class="line">	<span class="keyword">go</span>.etcd.io/etcd/client/v3 v3<span class="number">.5.0</span>-rc<span class="number">.1</span></div><div class="line">	golang.org/x/net v0<span class="number">.0.0</span><span class="number">-20210610132358</span><span class="number">-84</span>b48f89b13b <span class="comment">// indirect</span></div><div class="line">	golang.org/x/sys v0<span class="number">.0.0</span><span class="number">-20210611083646</span>-a4fc73990273 <span class="comment">// indirect</span></div><div class="line">)</div><div class="line"></div><div class="line">exclude (</div><div class="line">	<span class="keyword">go</span>.etcd.io/etcd/client/v2 v2<span class="number">.305.0</span>-rc<span class="number">.0</span></div><div class="line">	<span class="keyword">go</span>.etcd.io/etcd/client/v3 v3<span class="number">.5.0</span>-rc<span class="number">.0</span></div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">retract (</div><div class="line">    v1<span class="number">.0.0</span> <span class="comment">// 废弃的版本，请使用v1.1.0</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>虽然是一个简单的文件，但是里面的乾坤不少，让我们依次介绍它们。</p>
<h3 id="语义化版本_2-0-0">语义化版本 2.0.0</h3>
<p>Go module遵循<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本规范 2.0.0</a>。语义化版本规范 2.0.0规定了版本号的格式，每个字段的意义以及版本号比较的规则等等。</p>
<p><img src="semver2.png" alt=""></p>
<p>如果你想为你的项目发版，你可以设置tag为上面的格式，比如<code>v1.3.0</code>、<code>v2.0.0-rc.1</code>等等。metadata中在Go版本比较时是不参与运算的，只是一个辅助信息。</p>
<h3 id="module_path">module path</h3>
<p>go.mod的第一行是module path, 一般采用仓库+module name的方式定义。这样我们获取一个module的时候，就可以到它的仓库中去查询，或者让go proxy到仓库中去查询。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">github</span>.<span class="title">com</span>/<span class="title">panicthis</span>/<span class="title">modfile</span></span></div></pre></td></tr></table></figure>

<p>如果你的版本已经大于等于2.0.0，按照Go的规范，你应该加上major的后缀，module path改成下面的方式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">github</span>.<span class="title">com</span>/<span class="title">panicthis</span>/<span class="title">modfile</span>/<span class="title">v2</span></span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">github</span>.<span class="title">com</span>/<span class="title">panicthis</span>/<span class="title">modfile</span>/<span class="title">v3</span></span></div></pre></td></tr></table></figure>

<p>而且引用代码的时候，也要加上<code>v2</code>、<code>v3</code>、<code>vx</code>后缀，以便和其它major版本进行区分。</p>
<p>这是一个很奇怪的约定，带来的好处是你一个项目中可以使用依赖库的不同的major版本，它们可以共存。</p>
<h3 id="go_directive">go directive</h3>
<p>第二行是go directive。格式是 <code>go 1.xx</code>,它并不是指你当前使用的Go版本，而是指名你的代码所需要的Go的最低版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="number">1.16</span></div></pre></td></tr></table></figure>

<p>因为Go的标准库也有所变化，一些新的API也被增加进来，如果你的代码用到了这些新的API,你可能需要指名它依赖的go版本。</p>
<p>这一行不是必须的，你可以不写。 </p>
<h3 id="require">require</h3>
<p>require段中列出了项目所需要的各个依赖库以及它们的版本，除了正规的<code>v1.3.0</code>这样的版本外，还有一些奇奇怪怪的版本和注释，那么它们又是什么意思呢？</p>
<p>正式的版本号我们就不需要介绍了，大家都懂:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/coreos/bbolt v1.<span class="number">3.3</span></div></pre></td></tr></table></figure>

<h4 id="伪版本号">伪版本号</h4>
<p><img src="version1.png" alt=""></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.com/edwingeng/doublejump v0.<span class="number">0.0</span>-<span class="number">20200330080233</span><span class="operator">-e</span>4ea8bd1cbed</div></pre></td></tr></table></figure>

<p>上面这个库中的版本号就是一个伪版本号<code>v0.0.0-20200330080233-e4ea8bd1cbed</code>,这是go module为它生成的一个类似符合语义化版本2.0.0版本，实际这个库并没有发布这个版本。</p>
<p>正式因为这个依赖库没有发布版本，而go module需要指定这个库的一个确定的版本，所以才创建的这样一个伪版本号。</p>
<p>go module的目的就是在go.mod中标记出这个项目所有的依赖以及它们确定的某个版本。</p>
<p>这里的<code>20200330080233</code>是这次提交的时间，格式是<code>yyyyMMddhhmmss</code>, 而<code>e4ea8bd1cbed</code>就是这个版本的commit id,通过这个字段，就可以确定这个库的特定的版本。</p>
<p>而前面的<code>v0.0.0</code>可能有多种生成方式，主要看你这个commit的base version:</p>
<ul>
<li>vX.0.0-yyyymmddhhmmss-abcdefabcdef: 如果没有base version,那么就是vX.0.0的形式</li>
<li>vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef： 如果base version是一个预发布的版本，比如vX.Y.Z-pre,那么它就用vX.Y.Z-pre.0的形式</li>
<li>vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef: 如果base version是一个正式发布的版本，那么它就patch号加1，如vX.Y.(Z+1)-0</li>
</ul>
<h3 id="indirect注释">indirect注释</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">go</span>.etcd.io/bbolt v1<span class="number">.3.6</span> <span class="comment">// indirect</span></div><div class="line">golang.org/x/net v0<span class="number">.0.0</span><span class="number">-20210610132358</span><span class="number">-84</span>b48f89b13b <span class="comment">// indirect</span></div><div class="line">golang.org/x/sys v0<span class="number">.0.0</span><span class="number">-20210611083646</span>-a4fc73990273 <span class="comment">// indirect</span></div></pre></td></tr></table></figure>

<p>有些库后面加了<code>indirect</code>后缀，这又是什么意思的。</p>
<p>如果用一句话总结，间接的使用了这个库，但是又没有被列到某个go.mod中，当然这句话也不算太准确，更精确的说法是下面的情况之一就会对这个库加indirect后缀：</p>
<ul>
<li>当前项目依赖A,但是A的go.mod遗漏了B, 那么就会在当前项目的go.mod中补充B, 加indirect注释</li>
<li>当前项目依赖A,但是A没有go.mod,同样就会在当前项目的go.mod中补充B, 加indirect注释</li>
<li>当前项目依赖A,A又依赖B,当对A降级的时候，降级的A不再依赖B,这个时候B就标记indirect注释</li>
</ul>
<h3 id="incompatible">incompatible</h3>
<p>有些库后面加了incompatible后缀，但是你如果看这些项目，它们只是发布了v2.2.1的tag,并没有<code>+incompatible</code>后缀。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/cenk/backoff v2.<span class="number">2.1</span>+incompatible</div></pre></td></tr></table></figure>

<p>这些库采用了go.mod的管理，但是不幸的是，虽然这些库的版major版本已经大于等于2了，但是他们的module path中依然没有添加v2、v3这样的后缀。</p>
<p>所以gho module把它们标记为<code>incompatible</code>的，虽然可以引用，但是实际它们是不符合规范的。</p>
<h3 id="exclude">exclude</h3>
<p>如果你想在你的项目中跳过某个依赖库的某个版本，你就可以使用这个段。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exclude (</div><div class="line">	<span class="keyword">go</span>.etcd.io/etcd/client/v2 v2.<span class="number">305.0</span>-rc.<span class="number">0</span></div><div class="line">	<span class="keyword">go</span>.etcd.io/etcd/client/v3 v3.<span class="number">5.0</span>-rc.<span class="number">0</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>这样，Go在版本选择的时候，就会主动跳过这些版本，比如你使用<code>go get -u ......</code>或者<code>go get github.com/xxx/xxx@latest</code>等命令时，会执行version query的动作，这些版本不在考虑的范围之内。</p>
<h3 id="replace">replace</h3>
<p>replace也是常用的一个手段，用来解决一些错误的依赖库的引用或者调试依赖库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">replace github.<span class="keyword">com</span>/coreos/bbolt =&gt; <span class="keyword">go</span>.etcd.io/bbolt v1.<span class="number">3.3</span></div><div class="line">replace github.<span class="keyword">com</span>/panicthis/A v1.<span class="number">1.0</span> =&gt; github.<span class="keyword">com</span>/panicthis/R v1.<span class="number">8.0</span></div><div class="line">replace github.<span class="keyword">com</span>/coreos/bbolt =&gt; ../R</div></pre></td></tr></table></figure>

<p>比如etcd v3.3.x的版本中错误的使用了<code>github.com/coreos/bbolt</code>作为bbolt的module path,其实这个库在它自己的go.mod中声明的module path是<code>go.etcd.io/bbolt</code>，又比如etcd使用的grpc版本有问题，你也可以通过replace替换成所需的grpc版本。</p>
<p>甚至你觉得某个依赖库有问题，自己fork到本地做修改，想调试一下，你也可以替换成本地的文件夹。</p>
<p>replace可以替换某个库的所有版本到另一个库的特定版本，也可以替换某个库的特定版本到另一个库的特定版本。</p>
<h3 id="retract">retract</h3>
<p>retract是go 1.16中新增加的内容，借用学术界期刊撤稿的术语，宣布撤回库的某个版本。</p>
<p>如果你误发布了某个版本，或者事后发现某个版本不成熟，那么你可以推一个新的版本，在新的版本中，声明前面的某个版本被撤回，提示大家都不要用了。</p>
<p>撤回的版本tag依然还存在，go proxy也存在这个版本，所以你如果强制使用，还是可以使用的，否则这些版本就会被跳过。</p>
<p>和exclude的区别是retract是这个库的owner定义的， 而exclude是库的使用者在自己的go.mod中定义的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天在GopherChina 2021大会上分享了《深入Go Module》，干货太多了，接下来的分几篇文章详细介绍下。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wio terminal 掌机开发板试用报告]]></title>
    <link href="https://colobu.com/2021/06/06/tribal-report-of-wio-terminal/"/>
    <id>https://colobu.com/2021/06/06/tribal-report-of-wio-terminal/</id>
    <published>2021-06-06T08:35:41.000Z</published>
    <updated>2021-10-06T03:29:34.565Z</updated>
    <content type="html"><![CDATA[<p>周五收到一款<a href="https://www.seeedstudio.com/Wio-Terminal.html" target="_blank" rel="external">矽递科技</a>的arduino开发板wio terminal，与Arduino和MicroPython兼容，基于ATSAMD51的微控制器,具有Realtek RTL8720DN支持的的无线连接，还带有一个240X320的彩色液晶屏，可以做为树莓派的显示器，很方便了。 话说矽递科技是一家专注物联网硬件解决方案的高新技术企业，全球前三的开源硬件供应商，牛逼了，以至于这款产品的英文资料比中文资料还丰富。</p>
<p>对于硬件相关的领域，我还是一个小白，但是对于物联网或者硬件相关的创客产品，我是非常感兴趣的，这不，拿到这款产品，周末在家就和小朋友一起研究起来。</p>
<p>我给自己的设置的第一个目标就是能写一个hello world的程序，在这款wio terminal显示出来。</p>
<a id="more"></a>
<h2 id="开箱">开箱</h2>
<p>这款开发板相当的小巧，包装盒和一副扑克牌差不多大小，拆开包装，包含一个wio ternimal掌机，一个数据线、说明书和贴纸,还额外赠送一个5-way的按钮。</p>
<table><tr><td><img src="box.jpg" width="100%"></td><td><img src="wio.jpg" width="100%"></td><td><img src="wio2.jpg" width="100%"></td></tr></table>

<p>打开开关，默认的程序是个类似超级玛丽的小游戏,因为我已经上传了新的程序，这个默认的程序没有拍照截图。</p>
<table><tr><td><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/9d0ce51a71ce6a79dfa2a98d65a0f0bd/1/0/102991299-nnew-8.png" width="100%"></td><td><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/9d0ce51a71ce6a79dfa2a98d65a0f0bd/1/0/102991299-nnew-2.jpg" width="100%"></td><td><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/9d0ce51a71ce6a79dfa2a98d65a0f0bd/1/0/102991299-nnew-3.jpg" width="100%"></td></tr><tr><td><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/9d0ce51a71ce6a79dfa2a98d65a0f0bd/1/0/102991299-nnew-4.jpg" width="100%"></td><td><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/9d0ce51a71ce6a79dfa2a98d65a0f0bd/1/0/102991299-nnew-5.jpg" width="100%"></td><td><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/9d0ce51a71ce6a79dfa2a98d65a0f0bd/1/0/102991299-nnew-6.jpg" width="100%"></td></tr></table>

<h2 id="开发环境搭建">开发环境搭建</h2>
<p>作为一个小白，我需要从最基础的开发知识入手开始学习，那么第一步就是看官方的入门资料: <a href="https://wiki.seeedstudio.com/cn/Wio-Terminal-Getting-Started/" target="_blank" rel="external">Wio Terminal入门教程</a>,这个网页包含了这个产品的技术指标和开发入门。</p>
<p>根据这篇文章的指导，下载Arduino IDE工具，打开Blink示例,编译上传，你就可以看到蓝色呼吸灯以一秒的间隔闪亮。</p>
<p>注意安装好Arduino IDE之后，需要在<strong>File（文件）</strong> &gt; <strong>Preference（偏好设置）</strong>菜单中最下面的<strong>Additional Boards Manager URLs</strong>中输入<code>https://files.seeedstudio.com/arduino/package_seeeduino_boards_index.json</code>,</p>
<p><img src="arduinoide-config.png" alt=""></p>
<p>点击 <strong>Tools（工具）</strong> &gt; <strong>Board（开发板</strong>）&gt; <strong>Boards Manager...</strong> ，在搜索栏中搜索关键字<strong>Wio Terminal</strong>后，点击并安装它。</p>
<p><img src="arduinoide-config2.png" alt=""></p>
<p>然后就能在开发版中选择<strong>seeedunio wio terminal</strong>开发板了。</p>
<p>端口根据实际情况选择，我在windows操作系统中中端口是<strong>COM5</strong>,你如果不确定，可以通过关闭打开wio terminal看看哪个端口有变化，有变化的就是wio terminal对应的端口。</p>
<p>在开发程序的时候，可能会依赖额外的库，你需要把这些库加入进来，比如LCD的库、绘图库等等。</p>
<p>官方英文版有详细的介绍，但是中文版没有，所以学习还是从英文资料入手。</p>
<h2 id="官方demo">官方demo</h2>
<p>在进入我的第一个hello world程序之前，我想运行一下官方的demo程序，熟悉一下编译、上传的流程。</p>
<p>我选定的是<a href="https://wiki.seeedstudio.com/Wio-Terminal-Displaying-Gyro/" target="_blank" rel="external">陀螺仪的演示程序</a>。</p>
<p>它在wio terminal屏幕上画出三轴的角度，你可以通过转动wio terminal看曲线的变化。</p>
<p><img src="https://files.seeedstudio.com/wiki/Wio-Terminal/img/C0279.2019-11-28%2018_25_43.gif" alt=""></p>
<p>我和我们家的小朋友一起学习的，中间他还帮了我我一个大忙。小朋友通过拍打放置wio terminal的桌子来观察曲线的变化，突然想到是不是可以通过它实现一个地震检测仪，应该比张衡的那个更精准吧。</p>
<p>这个程序按照教程的指导一步步走下来即可，它需要Seeed_Arduino_Linechart库来画折线图、通过Seeed_Arduino_LIS3DHTR库来访问陀螺仪。</p>
<p>在arduino ide中点击上传，就可以把这个程序编译上传了。</p>
<h2 id="使用tinygo">使用tinygo</h2>
<p><a href="https://tinygo.org/" target="_blank" rel="external">tinygo</a>是一个以Go语言编译嵌入式程序的编译器。因为我最近几年偏重Go语言开发，所以我想尝试使用Go语言写一个hello world的程序。</p>
<p>按照tinygo官方的文档, tinygo已经支持了<a href="https://tinygo.org/docs/reference/microcontrollers/wioterminal/" target="_blank" rel="external">Seeed Wio Terminal</a>。 太cool了，可以使用Go语言写一些程序了。</p>
<p>于是我写了一个hello world的简单程序:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(<span class="string">"Hello world!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用命令<code>tinygo flash -target=wioterminal hello.go</code>去上传。</p>
<p>wio termnial两眼一黑，居然死了。重新关开机，windows显示未知的设备!!!</p>
<p>赶快抢救，尝试按钮滑动两次的方式，一直没有效果。网上赶快搜资料，找不到解决办法。</p>
<p>我有点感觉我手贱了。</p>
<p>我放弃了，准备改天问问客服，有没有抢救办法。</p>
<p>我家小朋友不死心，来回的开、关、开、开、关.......</p>
<p>突然小朋友喊到，『好了！！！』。我过去一看，windows已经识别出来这个设备了，赶快把陀螺仪的程序刷上去，果然好了。</p>
<p>我决定放弃尝试tinygo了，还是乖乖使用arduino ide进行开发好了。</p>
<h2 id="第一个程序:_hello_world">第一个程序: hello world</h2>
<p>切回到arduino ide之后，我决定还是按照官方的教程，去写第一个hello world程序。</p>
<p>一个外国小哥做了很多的视频教程，youtube上有，b站上也能搜到，不过是英文的。 中文字幕官方也上传了一些，貌似比较少。</p>
<p>反正我是写第一个hello world程序，找一个简单的视频看看就理解了。</p>
<p>这个程序将屏幕背景设置为红色，并且在屏幕中央显示 <code>hello smallnest!</code>字体(中文字体我还没研究)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>"TFT_eSPI.h"</span></div><div class="line">TFT_eSPI tft;</div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> LCD_BACKLIGHT (72Ul) <span class="comment">// Control Pin of LCD</span></span></div><div class="line"> </div><div class="line"><span class="keyword">void</span> setup() {</div><div class="line">  <span class="comment">// put your setup code here, to run once:</span></div><div class="line"> </div><div class="line">    tft.begin();</div><div class="line">    tft.setRotation(<span class="number">3</span>);</div><div class="line">    tft.fillScreen(TFT_RED);</div><div class="line"> </div><div class="line">    tft.setTextColor(TFT_BLACK);</div><div class="line">    tft.setTextSize(<span class="number">3</span>);</div><div class="line">    tft.drawString(<span class="string">"hello smallnest!"</span>,<span class="number">25</span>,<span class="number">120</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">void</span> loop() {</div><div class="line">  <span class="comment">// put your main code here, to run repeatedly:</span></div><div class="line"> </div><div class="line">}</div></pre></td></tr></table></figure>

<p>程序首先初始化屏幕，将背景设置成红色。</p>
<p>然后设置字体的颜色为黑色，大小为3,最大为7。</p>
<p>最后画出字符串。</p>
<p>编译上传，最后屏幕显示如下：</p>
<p><img src="hello.jpg" alt=""></p>
<p>第一个程序成功了。休息一下，改天进一步研究。</p>
<h2 id="如何购买">如何购买</h2>
<p>以下是这款产品的介绍，你可以在<a href="https://item.taobao.com/item.htm?spm=a1z10.1-c-s.w137712-11046001449.7.25cf6e6aW14NL6&amp;id=614341863391" target="_blank" rel="external">淘宝官方店</a>进行购买，价格279元。</p>
<p style="margin-top: 1.12em; margin-bottom: 1.12em; padding: 0px; font-family: tahoma, arial, 宋体, sans-serif; font-size: 14px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i4/2540467004/O1CN016yu3gK21bselPYkQx_!!2540467004.png" data-spm-anchor-id="2013.1.0.i1.36dc3c04h6HNvI" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i2/2540467004/O1CN01TApUBl21bsefdIpNb_!!2540467004.png" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i1/2540467004/O1CN01X4eLee21bsekItD72_!!2540467004.png" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i4/2540467004/O1CN017quXFC21bsem4BhQB_!!2540467004.png" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i4/2540467004/O1CN01s4SWoh21bsekcpQQE_!!2540467004.png" class="" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i2/2540467004/O1CN01PPNHjl21bsehfdXXl_!!2540467004.png" class="" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i1/2540467004/O1CN01UsYYp621bseZwBQbv_!!2540467004.png" class="" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i2/2540467004/O1CN01IM7nvv21bseiZvSte_!!2540467004.png" class="" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i1/2540467004/O1CN01xfwodH21bsenAAs4u_!!2540467004.png" class="" style="border: 0px; vertical-align: top; max-width: 750px;"><img align="absmiddle" src="https://img.alicdn.com/imgextra/i1/2540467004/O1CN01QSl5Jj21bseedwBPe_!!2540467004.png" class="" style="border: 0px; vertical-align: top; max-width: 750px;"></p>]]></content>
    <summary type="html">
    <![CDATA[<p>周五收到一款<a href="https://www.seeedstudio.com/Wio-Terminal.html" target="_blank" rel="external">矽递科技</a>的arduino开发板wio terminal，与Arduino和MicroPython兼容，基于ATSAMD51的微控制器,具有Realtek RTL8720DN支持的的无线连接，还带有一个240X320的彩色液晶屏，可以做为树莓派的显示器，很方便了。 话说矽递科技是一家专注物联网硬件解决方案的高新技术企业，全球前三的开源硬件供应商，牛逼了，以至于这款产品的英文资料比中文资料还丰富。</p>
<p>对于硬件相关的领域，我还是一个小白，但是对于物联网或者硬件相关的创客产品，我是非常感兴趣的，这不，拿到这款产品，周末在家就和小朋友一起研究起来。</p>
<p>我给自己的设置的第一个目标就是能写一个hello world的程序，在这款wio terminal显示出来。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现无限缓存的channel]]></title>
    <link href="https://colobu.com/2021/05/11/unbounded-channel-in-go/"/>
    <id>https://colobu.com/2021/05/11/unbounded-channel-in-go/</id>
    <published>2021-05-11T04:30:10.000Z</published>
    <updated>2021-10-06T03:29:34.648Z</updated>
    <content type="html"><![CDATA[<p>Go语言的channel有两种类型，一种是无缓存的channel，一种是有缓存的buffer，这两种类型的channel大家都比较熟悉了，但是对于有缓存的channel,它的缓存长度在创建channel的时候就已经确定了，中间不能扩缩容，这导致在一些场景下使用有问题，或者说不太适合特定的场景。</p>
<a id="more"></a>
<p>我为什么突然谈起这个无限缓存的channel呢？主要是我最近在review公司一位同事的代码时，我的某种设计思路出现了一个问题，如果使用无限缓存的channel的话，我的问题就会迎刃而解了。</p>
<p>这位同事的设计大概是这样子的：</p>
<ol>
<li>一个dispatcher包含一个channel, 里面存放待处理的url</li>
<li>一堆worker从channel中读取任务，下载解析网页，并提取其中链接，再把链接放入到dispatcher.channel中</li>
</ol>
<p>这位同事为了解决并发的问题，不得不使用了比较复杂的sync.Mutex和sync.Cond，并且定义了一堆并发的方法处理逻辑，这里我想谈谈我的错误想法。</p>
<p>我review这段代码的时候想，如果每个 worker启动一个goroutine,处理url，然后把链接再放入到channel中即可，不用复杂的 Mutex+Cond等，但是我犯了一个错误，那就是如果当前channel已经满了，那么这些worker都不能把解析的结果放入到channel中，都被&quot;阻塞&quot;住了，并且也没有可用的worker从channel中消费url。</p>
<p>当然，你可以说可以创建一个buffer非常大的channel，避免被塞满，但是,第一,buffer非常大的channel占用的内存也非常大，第二，多大合适？关键你不能保证channel不会满。</p>
<p>如果有一个无限缓存长度的buffer就好了。</p>
<p>2017年，有同学向Go官方提出这么一个需求(<a href="https://github.com/golang/go/issues/20352" target="_blank" rel="external">#20352</a>),希望能够提供一个无限容量的buffer，经过冗长的讨论，Go不会为这个&quot;稀有&quot;的场景提供一种实现，并且建议大家实现这样的一个库，通过第三库的方式处理这种场景，而且Griesemer提供了一个思路，通过ringbuffer实现缓存来实现这样的channel。</p>
<p>网上有两种实现<a href="https://stackoverflow.com/questions/41906146/why-go-channels-limit-the-buffer-size" target="_blank" rel="external">Why Go channels limit the buffer size</a>和<a href="https://medium.com/capital-one-tech/building-an-unbounded-channel-in-go-789e175cd2cd" target="_blank" rel="external">Building an Unbounded Channel in Go</a>,这两种实现也比较类似，我在第一种实现的基础上，封装了一个库: <a href="https://github.com/smallnest/chanx" target="_blank" rel="external">chanx</a>,来提供通用的无限缓存的channel。</p>
<p><a href="https://github.com/smallnest/chanx" target="_blank" rel="external">chanx</a>, 你可以star这个库，放入到你的代码库中，说不定哪一天它就可能帮你解燃眉之急。并且我已经准备好了泛型的设计，一旦Go泛型可用，我就会把它改成泛型的实现。</p>
<p>缓存无限的channel拥有下面的特性：</p>
<ol>
<li><strong>不会阻塞write</strong>。 它总是能处理write的数据，或者放入到待读取的channel中，或者放入到缓存中</li>
<li><strong>无数据时read会被阻塞</strong>。当没有可读的数据时，从channel中读取的goroutine会被阻塞</li>
<li><strong>读写都是通过channel操作</strong>。 内部的缓存不会暴露出来</li>
<li><strong>能够查询当前待读取的数据数量</strong>。因为缓存中可能也有待处理的数据，所以需要返回len(buffer)+len(chan)</li>
<li><strong>关闭channel后，还未读取的channel还是能够被读取，读取完之后才能发现channel已经完毕</strong>。这和正常的channel的逻辑是一样的，这种情况叫&quot;drain&quot;未读的数据</li>
</ol>
<p>因为我们不能修改内部的channel结构，也不能重载 chan &lt;- 和 &lt;- chan 操作符,所以我们只能通过两个channel的方式封装一个数据结构,来提供读写。</p>
<p>这个数据结构为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> UnboundedChan <span class="keyword">struct</span> {</div><div class="line">	In     <span class="keyword">chan</span>&lt;- T <span class="comment">// channel for write</span></div><div class="line">	Out    &lt;-<span class="keyword">chan</span> T <span class="comment">// channel for read</span></div><div class="line">	buffer []T      <span class="comment">// buffer</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中<code>In</code>这个channel用来写入数据，而<code>Out</code>这个channel用来读取数据。你可以close In这个channel,等所有的数据都读取完后，Out channel也会被自动关闭。 用户是不能自己关闭<code>Out</code>这个channel的，你也关闭不了，因为它是<code>&lt;-chan</code>类型的。</p>
<p>你可以通过<code>Len</code>方法得到所有待读取的数据的长度，也可以通过<code>BufLen</code>只获取缓存中的数据的长度，不包含外发<code>Out</code> channel中数据的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Len returns len of Out plus len of buffer.</span></div><div class="line"><span class="keyword">func</span> (c UnboundedChan) Len() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(c.buffer) + <span class="built_in">len</span>(c.Out)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// BufLen returns len of the buffer.</span></div><div class="line"><span class="keyword">func</span> (c UnboundedChan) BufLen() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(c.buffer)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>那么重点来了，主要的逻辑的实现如下，我在代码中加了注释，通过注释和代码你就可以很好的理解整个的实现逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewUnboundedChan(initCapacity <span class="typename">int</span>) UnboundedChan {</div><div class="line"></div><div class="line">    <span class="comment">// 创建三个字段和无限缓存的chan类型</span></div><div class="line">	in := <span class="built_in">make</span>(<span class="keyword">chan</span> T, initCapacity)</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> T, initCapacity)</div><div class="line">	ch := UnboundedChan{In: in, Out: out, buffer: <span class="built_in">make</span>([]T,<span class="number"> 0</span>, initCapacity)}</div><div class="line"></div><div class="line">    <span class="comment">// 通过一个goroutine,不断地从in中读取出来数据，放入到out或者buffer中</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out) <span class="comment">// in关闭，数据读取完后也把out关闭</span></div><div class="line">	loop:</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			val, ok := &lt;-in </div><div class="line">			<span class="keyword">if</span> !ok { <span class="comment">// 如果in已经被closed, 退出loop</span></div><div class="line">				<span class="keyword">break</span> loop</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="comment">// 否则尝试把从in中读取出来的数据放入到out中</span></div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> out &lt;- val: <span class="comment">//放入成功，说明out刚才还没有满，buffer中也没有额外的数据待处理，所以回到loop开始</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">			<span class="keyword">default</span>:</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="comment">// 如果out已经满了，需要把数据放入到缓存中</span></div><div class="line">			ch.buffer = <span class="built_in">append</span>(ch.buffer, val)</div><div class="line"></div><div class="line">            <span class="comment">// 处理缓存，一直尝试把缓存中的数据放入到out,直到缓存中没有数据了,</span></div><div class="line">            <span class="comment">// 为了避免阻塞住in channel,还要尝试从in中读取数据，因为这个时候out是满的，所以就直接把数据放入到缓存中</span></div><div class="line">			<span class="keyword">for</span> <span class="built_in">len</span>(ch.buffer) &gt;<span class="number"> 0</span> {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> val, ok := &lt;-in: <span class="comment">// 从in读取数据，放入到缓存中，如果in被closed, 退出loop</span></div><div class="line">					<span class="keyword">if</span> !ok { </div><div class="line">						<span class="keyword">break</span> loop</div><div class="line">					}</div><div class="line">					ch.buffer = <span class="built_in">append</span>(ch.buffer, val)</div><div class="line"></div><div class="line">				<span class="keyword">case</span> out &lt;- ch.buffer<span class="number">[0</span>]: <span class="comment">// 把缓存中最老的数据放入到out中，并移出第一个元素</span></div><div class="line">					ch.buffer = ch.buffer<span class="number">[1</span>:]</div><div class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(ch.buffer) ==<span class="number"> 0</span> { <span class="comment">// 避免内存泄露. 如果缓存处理完了，恢复成原始的状态</span></div><div class="line">						ch.buffer = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, initCapacity)</div><div class="line">					}</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="comment">// in被关闭，退出loop后，buffer中可能还有未处理的数据，需要把它们塞入到out中</span></div><div class="line">        <span class="comment">// 这个逻辑叫做"drain"。</span></div><div class="line">        <span class="comment">// 这一段逻辑处理完后，就可以把out关闭掉了</span></div><div class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(ch.buffer) &gt;<span class="number"> 0</span> {</div><div class="line">			out &lt;- ch.buffer<span class="number">[0</span>]</div><div class="line">			ch.buffer = ch.buffer<span class="number">[1</span>:]</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这一段的逻辑还是很清晰的，就是细节需要注意，它也是学习channel使用的一个很好的素材。</p>
<h2 id="5月13日更新">5月13日更新</h2>
<p>今天正好出差，在高铁上漫长的5个多小时没有事情做，所以我拿起笔记本干了两件事情，其中之一就是对这个无限缓存的channel做了优化。</p>
<p>本身这个无限缓存的channel的设计非常简洁，唯一有一点我不太满意的是它的buffer不能重用, 这和<code>ch.buffer = ch.buffer[1:]</code>的处理有关系,有时候明明底层的数组很大，但是还不得不重新生成新的数据，导致堆分配频次比较多。</p>
<p>依照Go三巨头之一的设计，底层buffer最好采用ringbuffer的实现方式，如果buffer满了应该能<a href="https://github.com/golang/go/issues/20352#issuecomment-365494616" target="_blank" rel="external">自动扩容</a>:</p>
<blockquote>
<p>Such a library should do well in cases of very fast, &quot;bursty&quot; messages. A large enough buffered channel should be able to absorb bursts while a fast dedicated goroutine drains the channel into a ring buffer from which the messages are delivered at a slower pace to the final consumer of the messages. That ring buffer will need to be efficiently implemented, and will need to be able to grow efficiently (irrespective of size) and that will require some careful engineering. Better to leave that code to a library that can be tuned as needed than baking it into the runtime (and then possibly being at the mercy of release cycles).</p>
</blockquote>
<p>所以我又实现了一个<a href="https://github.com/smallnest/chanx/blob/main/ringbuffer.go" target="_blank" rel="external">ringbuffer</a>,这个ringbuffer比较简单，原因在这里我们不需要考虑并发的问题，这个ringbuffer只会在一个goroutine使用，所以它的实现就非常的简单了，需要注意&quot;读追上写&quot;，以及&quot;写满&quot;这两个边界问题就好了。通过使用ringbuffer，上面的实现就可以更改为下面的代码，可以进一步减少写爆发(burst)的时候分配过多的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewUnboundedChan(initCapacity <span class="typename">int</span>) UnboundedChan {</div><div class="line">	in := <span class="built_in">make</span>(<span class="keyword">chan</span> T, initCapacity)</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> T, initCapacity)</div><div class="line">	ch := UnboundedChan{In: in, Out: out, buffer: NewRingBuffer(initCapacity)}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</div><div class="line">	loop:</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			val, ok := &lt;-in</div><div class="line">			<span class="keyword">if</span> !ok { <span class="comment">// in is closed</span></div><div class="line">				<span class="keyword">break</span> loop</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="comment">// out is not full</span></div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> out &lt;- val:</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			<span class="keyword">default</span>:</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="comment">// out is full</span></div><div class="line">			ch.buffer.Write(val)</div><div class="line">			<span class="keyword">for</span> !ch.buffer.IsEmpty() {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> val, ok := &lt;-in:</div><div class="line">					<span class="keyword">if</span> !ok { <span class="comment">// in is closed</span></div><div class="line">						<span class="keyword">break</span> loop</div><div class="line">					}</div><div class="line">					ch.buffer.Write(val)</div><div class="line"></div><div class="line">				<span class="keyword">case</span> out &lt;- ch.buffer.Peek():</div><div class="line">					ch.buffer.Pop()</div><div class="line">					<span class="keyword">if</span> ch.buffer.IsEmpty() && ch.buffer.size &gt; ch.buffer.initialSize { <span class="comment">// after burst</span></div><div class="line">						ch.buffer.Reset()</div><div class="line">					}</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="comment">// drain</span></div><div class="line">		<span class="keyword">for</span> !ch.buffer.IsEmpty() {</div><div class="line">			out &lt;- ch.buffer.Pop()</div><div class="line">		}</div><div class="line"></div><div class="line">		ch.buffer.Reset()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Go语言的channel有两种类型，一种是无缓存的channel，一种是有缓存的buffer，这两种类型的channel大家都比较熟悉了，但是对于有缓存的channel,它的缓存长度在创建channel的时候就已经确定了，中间不能扩缩容，这导致在一些场景下使用有问题，或者说不太适合特定的场景。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go sync.Once的三重门]]></title>
    <link href="https://colobu.com/2021/05/05/triple-gates-of-sync-Once/"/>
    <id>https://colobu.com/2021/05/05/triple-gates-of-sync-Once/</id>
    <published>2021-05-05T06:44:53.000Z</published>
    <updated>2021-10-06T03:29:34.645Z</updated>
    <content type="html"><![CDATA[<p>我在极客时间开设的专栏<a href="https://time.geekbang.org/column/intro/100061801" target="_blank" rel="external">Go 并发编程实战课</a>中，详细介绍了<code>sync.Once</code>并发原语的实现，对于使用这个原语来说，内容已经足够了，但是还是有些同学愿意深入挖掘更深层的设计，并且提出了一些疑问，所以我再专门写一篇文章, 作为这么专栏的补充吧。</p>
<a id="more"></a>
<p><img src="antelope-canyon.jpg" alt=""></p>
<h2 id="一、为什么不能直接使用一个flag+原子操作简单实现？">一、为什么不能直接使用一个flag+原子操作简单实现？</h2>
<p>虽然文章中我介绍了为什么不能简单的使用一个flag+atomic实现，但是还是有一些同学询问，我就再解答一下。事实上不光国内的一些读者有这个疑问,国外也有一些读者问这个问题，以至于Russ Cox后来在sync.Once的源代码中专门加了一段注释，说明为什么flag+atomic简单实现有问题。</p>
<blockquote>
<p>Note: Here is an incorrect implementation of Do:</p>
<p>   if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {<br>     f()<br>   }</p>
<p>Do guarantees that when it returns, f has finished.<br>This implementation would not implement that guarantee:<br>given two simultaneous calls, the winner of the cas would<br>call f, and the second would return immediately, without<br>waiting for the first&#39;s call to f to complete.<br>This is why the slow path falls back to a mutex, and why<br>the atomic.StoreUint32 must be delayed until after f returns.</p>
</blockquote>
<p>如果你看了这段注释还不理解，那么没关系，我们详细说道说道。</p>
<p>首先，我们看看flag+atomic的简单实现是什么样子的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> wrong</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"sync/atomic"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> {</div><div class="line">	done <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Once) Do(f <span class="keyword">func</span>()) {</div><div class="line">	<span class="keyword">if</span> !atomic.CompareAndSwapUint32(&o.done,<span class="number"> 0</span>,<span class="number"> 1</span>) {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	f()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>关键在于并发的goroutine在调用<code>Do</code>方法时，当<code>Do</code>方法返回时，我们期望的是初始化函数<code>f</code>要执行完毕，但是这个实现第一个goroutine在使用f初始化时，后续并发的goroutine会立即返回，尽管f还没有执行完。</p>
<p>这带来的一个问题就是：后续的goroutine在使用这些未初始化的资源的时候，会出现意想不到的问题，比如panic,或者资源未初始化，这不是我们期望的。</p>
<p>所以不能这么简单的实现。</p>
<p>所以在使用<code>sync.Once</code>初始化一次资源的时候，请规规矩矩的使用标准库的<code>sync.Once</code>就好了，不要再想着做什么优化。 </p>
<p>如果你只是设置一个标志，而没有初始化的资源的操作，也就是你只需要done字段，不需要初始化方法f的话，你倒是可以这样使用。</p>
<h2 id="二、为什么使用Mutex？">二、为什么使用Mutex？</h2>
<p>最终，标准库的<code>sync.Once</code>实现方式如下，也是比较简单的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> {</div><div class="line">	done <span class="typename">uint32</span></div><div class="line">	m    Mutex</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (o *Once) Do(f <span class="keyword">func</span>()) {</div><div class="line">	<span class="keyword">if</span> atomic.LoadUint32(&o.done) ==<span class="number"> 0</span> {</div><div class="line">		o.doSlow(f)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Once) doSlow(f <span class="keyword">func</span>()) {</div><div class="line">	o.m.Lock()</div><div class="line">	<span class="keyword">defer</span> o.m.Unlock()</div><div class="line">	<span class="keyword">if</span> o.done ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&o.done,<span class="number"> 1</span>)</div><div class="line">		f()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有的同学不太理解为什么要使用Mutex。</p>
<p>使用Mutex并不会影响这个数据结构的性能。因为Mutex的逻辑(也就是doSlow方法)只会在初始化时并发的情况下发生，一旦初始化完成，后续的goroutine在调用<code>Do</code>方法时并不会请求锁。</p>
<p>所以，使用Mutex主要处理并发初始化的问题。</p>
<p>假设Once对象的Do方法还没有被初次调用。这个时候有goroutine <code>g2</code>和goroutine <code>g3</code>同时调用Do方法。碰巧，<code>g2</code>和<code>g3</code>可能原子读取done变量会等于0,所以这两个goroutine可能都会同时进入doSlow方法(可能在同一个CPU上，也可能在不同的cpu上)。</p>
<p>这个时候我们就需要Mutex限制只允许一个goroutine并发执行，也就是将并行变成了串行。假设<code>g2</code>运气好先执行，那么它就会进行初始化，并且执行完毕后把o.done设置为1,再释放锁。</p>
<p>锁释放后，<code>g3</code>开始执行，这个时候还还会执行<code>double checking</code>,再一次检查done字段。这一步是必须的，因为不双检查的话，它又会执行f一次。这里正确地使用了双检查，发现done已经被设置成了1,所以不需要初始化了，就直接返回。</p>
<p>如果一个goroutine在双检查的时候如果发现done=0,说明还没有goroutine执行过初始化，这种重担压在了自己的身上，就像<code>g2</code>一样，它就会执行初始化函数f。</p>
<p>所以，这里使用了Mutex,保护并发的初始化。</p>
<p>到了这一步基本上很少有同学有疑问了，但是好学爱钻研的网友还是提出了非常有趣的问题。</p>
<h2 id="三、为什么乱序执行没影响？">三、为什么乱序执行没影响？</h2>
<p>我们知道，现代的CPU都是支持乱序执行的。那么最后两行<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>和<code>f()</code>如果乱序了怎么办，那不也是还是没有初始化完毕就把<code>done</code>设置为1了吗？</p>
<p>而且有些人，包括Russ Cox review这段代码的时候也提出，<code>defer atomic.StoreUint32(&amp;o.done, 1)</code> (源代码和此有所不同)能不能改成<code>o.done=1</code>。</p>
<p>Go的标准库的代码质量是非常高的，而且都经过大神的仔细review,所以这样设计肯定是有它的用处的。</p>
<p>首先，第15行的<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>可以确保执行完第16行的f才将done设置为1。</p>
<p>虽然Go内存模型并没有定义atomic的happen before关系，也没有定义像C++的atomic的六种memory ordering模型。有一个悠久的仍然open的issue讨论atomic的内存模型的问题(<a href="https://github.com/golang/go/issues/5045" target="_blank" rel="external">issue#5045</a>),但是目前对atomic的内存模型保持模糊的定义。不同的CPU架构可能很难形成一个统一的定义。</p>
<p>对于x86架构，<a href="https://stackoverflow.com/questions/55787091/does-golang-atomic-load-have-a-acquire-semantics" target="_blank" rel="external">stackoverflow</a>有一段描述 atomic的Load和Store的原子性和会不会重排：</p>
<blockquote>
<p>On strongly ordered architectures like x86/amd64, acquire load and release store are just regular loads and stores. To make them atomic you need to ensure the memory is aligned to the operand size (automatic in Go), and that the compiler doesn&#39;t re-order them in incompatible ways, or optimize them away (e.g. reuse a value in a register instead of reading it from memory.)</p>
</blockquote>
<p>但是对于arm等架构，需要使用内存屏障(Memory barrier)技术保证memory ordering。</p>
<p>Ian Lance Taylor曾经在论坛中说:</p>
<blockquote>
<p>In C++ memory model terms I believe that the sync/atomic Load<br>operations are memory_order_acquire, and I believe that the<br>sync/atomic Store operations are memory_order_release. It&#39;s possible<br>that if we ever document it we will go for stronger memory ordering,<br>but I believe that these operations must at least carry those guarantees.</p>
<p>I&#39;m somewhat less certain of the memory order guarantees of the Swap,<br>CompareAndSwap, and Add functions. I guess that Swap and<br>CompareAndSwap are probably at least memory_order_acq_rel, but Add may<br>be memory_order_relaxed.</p>
</blockquote>
<p>Russ Cox曾经回答过问题,他把go的atomic 操作定位sequential consistency的，这是一个更严格的memory ordering。它们之前的读写保证再Load/Store,不会重排在Load/Store之后， 它们之后的读写操作也不会重排在Load/Store之前，所以建立了一个内存屏障(Memory barrier)。</p>
<blockquote>
<p>rsc<br>2019年7月16日上午9:12:01</p>
<p>Although there&#39;s been no official resolution to the issue, I think the actual path forward is what I posted a while back: &quot;Go&#39;s atomics guarantee sequential consistency among the atomic variables (behave like C/C++&#39;s seqconst atomics), and that you shouldn&#39;t mix atomic and non-atomic accesses for a given memory word.&quot;</p>
</blockquote>
<p>至少目前，我们可以按照他们的解答进行理解。</p>
<p>这样的话，Go可以保证第15行<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>肯定会在第16行<code>f()</code>之后执行，这样就不会出现未初始化完成就将done设置为1的问题。</p>
<p>另一个问题，第14行为什么不使用atomic?</p>
<p>因为Mutex的happend before关系， <code>g2</code>设置o.done=1之后才释放锁，这个时候<code>g3</code>才获取到锁，所以当<code>g3</code>获取到锁之后，o.done肯定就已经是1了，所以这个时候访问o.done肯定得到1的结果，不会在<code>g2</code>设置o.done=1 <code>g3</code>看不到o.done=1这个write。</p>
<p>第6行没有Mutex等的保护，所以通过atomic可以保证在o.done设置为1之后能看到这个设置的结果，避免总是落入到doSlow逻辑中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我在极客时间开设的专栏<a href="https://time.geekbang.org/column/intro/100061801" target="_blank" rel="external">Go 并发编程实战课</a>中，详细介绍了<code>sync.Once</code>并发原语的实现，对于使用这个原语来说，内容已经足够了，但是还是有些同学愿意深入挖掘更深层的设计，并且提出了一些疑问，所以我再专门写一篇文章, 作为这么专栏的补充吧。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻轻松松打印网页并生成pdf文档]]></title>
    <link href="https://colobu.com/2021/05/05/generate-pdf-for-a-web-page-by-using-chromedp/"/>
    <id>https://colobu.com/2021/05/05/generate-pdf-for-a-web-page-by-using-chromedp/</id>
    <published>2021-05-05T02:07:02.000Z</published>
    <updated>2021-10-06T03:29:34.293Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/chromedp/chromedp" target="_blank" rel="external">chromedp</a>是一个更快更简单的支持<a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="external">Chrome DevTools Protocol</a>协议的Go库，它是目前最流行的headless浏览器库之一，你可以使用它做很多只能通过浏览器才能执行的任务，比如网页截屏、网页渲染测试、下载视频、模拟登录等，今天我介绍它的一个有用而且很简单的功能：为一个网页生成一个pdf格式的截屏,更多的例子你可以查看官方示例<a href="https://github.com/chromedp/examples" target="_blank" rel="external">chromedp/examples</a>。</p>
<a id="more"></a>
<p>首先有一点，你需要安装chrome，这样chromedp库才能通过cdp协议调用chrome执行任务(动作)。</p>
<h2 id="为网页生成pdf">为网页生成pdf</h2>
<p>首先，你需要引入chromedp库：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get -u github.com/chromedp/chromedp</div></pre></td></tr></table></figure>

<p>然后，你就可以通过<code>chromedp.Run</code>执行一系列的动作，比如我们这个例子就是先导航到某个页面，然后将页面生成为pdf:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成任务列表</span></div><div class="line"><span class="keyword">func</span> printToPDF(urlstr <span class="typename">string</span>, res *[]<span class="typename">byte</span>) chromedp.Tasks {</div><div class="line">	<span class="keyword">return</span> chromedp.Tasks{</div><div class="line">		chromedp.Navigate(urlstr), <span class="comment">// 浏览指定的页面</span></div><div class="line">		chromedp.ActionFunc(<span class="keyword">func</span>(ctx context.Context) error {</div><div class="line">			buf, _, err := page.PrintToPDF().WithPrintBackground(<span class="constant">true</span>).Do(ctx) <span class="comment">// 通过cdp执行PrintToPDF</span></div><div class="line">			<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			}</div><div class="line">			*res = buf</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}),</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>ActionFunc</code>是一个便利的方法，用来执行一个函数作为Action,就像标准库http.Handler和http.HandleFunc的关系。因为这里我们要执行的逻辑比较简单，所以就通过一个函数实现就可以了。</p>
<p><code>page.PrintToPDF()</code>是定义要执行输出pdf的一些参数,你可以额外设置一些参数，这些参数包括：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PrintToPDFParams <span class="keyword">struct</span> {</div><div class="line">	Landscape               <span class="typename">bool</span>                   <span class="string">`json:"landscape,omitempty"`</span>               <span class="comment">// 横向打印. 默认false.</span></div><div class="line">	DisplayHeaderFooter     <span class="typename">bool</span>                   <span class="string">`json:"displayHeaderFooter,omitempty"`</span>     <span class="comment">// 打印header和footer. 默认false.</span></div><div class="line">	PrintBackground         <span class="typename">bool</span>                   <span class="string">`json:"printBackground,omitempty"`</span>         <span class="comment">// 打印背景图.  默认false.</span></div><div class="line">	Scale                   <span class="typename">float64</span>                <span class="string">`json:"scale,omitempty"`</span>                   <span class="comment">// 放缩因子. 默认为1.</span></div><div class="line">	PaperWidth              <span class="typename">float64</span>                <span class="string">`json:"paperWidth,omitempty"`</span>              <span class="comment">// 页面宽度(英寸). 默认8.5英寸（美国Letter标准尺寸，和A4纸差不太多）.</span></div><div class="line">	PaperHeight             <span class="typename">float64</span>                <span class="string">`json:"paperHeight,omitempty"`</span>             <span class="comment">// 页面高度(英寸). 默认11英寸(Letter标准尺寸).</span></div><div class="line">	MarginTop               <span class="typename">float64</span>                <span class="string">`json:"marginTop"`</span>                         <span class="comment">// 上边距(英寸). 默认1cm (大约0.4 英寸).</span></div><div class="line">	MarginBottom            <span class="typename">float64</span>                <span class="string">`json:"marginBottom"`</span>                      <span class="comment">// 底边距(英寸). 默认1cm (大约0.4 英寸).</span></div><div class="line">	MarginLeft              <span class="typename">float64</span>                <span class="string">`json:"marginLeft"`</span>                        <span class="comment">// 左边距(英寸). 默认1cm (大约0.4 英寸).</span></div><div class="line">	MarginRight             <span class="typename">float64</span>                <span class="string">`json:"marginRight"`</span>                       <span class="comment">// 右边距(英寸). 默认1cm (大约0.4 英寸).</span></div><div class="line">	PageRanges              <span class="typename">string</span>                 <span class="string">`json:"pageRanges,omitempty"`</span>              <span class="comment">// 要打印的页码, 比如, '1-5, 8, 11-13'.默认为空，全打印.</span></div><div class="line">	IgnoreInvalidPageRanges <span class="typename">bool</span>                   <span class="string">`json:"ignoreInvalidPageRanges,omitempty"`</span> <span class="comment">// 是否要忽略非法的页码范围. 默认false.</span></div><div class="line">	HeaderTemplate          <span class="typename">string</span>                 <span class="string">`json:"headerTemplate,omitempty"`</span>          <span class="comment">// HTML模板head. </span></div><div class="line">	FooterTemplate          <span class="typename">string</span>                 <span class="string">`json:"footerTemplate,omitempty"`</span>          <span class="comment">// HTML模板footer.</span></div><div class="line">	PreferCSSPageSize       <span class="typename">bool</span>                   <span class="string">`json:"preferCSSPageSize,omitempty"`</span>       <span class="comment">// 是否首选css定义的页面大小？默认false,将自动适应.</span></div><div class="line">	TransferMode            PrintToPDFTransferMode <span class="string">`json:"transferMode,omitempty"`</span>            <span class="comment">// 返回stream</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们的例子不做额外的设置，只调整了打印背景图参数，当然你为了打印出漂亮的pdf话，可以调整这里的参数，更适合阅读和打印。</p>
<p><code>Do</code>通过cdp协议执行打印并返回结果。</p>
<p>主要逻辑就完成了，下一步就是执行这些任务了。</p>
<p>首先要创建一个chromedp的Context:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx, cancel <span class="value">:= chromedp.<span class="function">NewContext</span>(context.<span class="function">Background</span>())</span></div></pre></td></tr></table></figure>

<p>然后调用chromedp.Run执行任务就可以了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err := chromedp.Run(ctx, printToPDF(<span class="string">`https://colobu.com/`</span>, &buf)); err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后把pdf写入到文件中，完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err := ioutil.WriteFile(<span class="string">"colobu.pdf"</span>, buf,<span class="number"> 0644</span>); err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>生成的pdf效果如下：<br><img src="colobu-pdf.png" alt=""></p>
<p>完整的代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/chromedp/cdproto/page"</span></div><div class="line">	<span class="string">"github.com/chromedp/chromedp"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 创建 context</span></div><div class="line">	ctx, cancel := chromedp.NewContext(context.Background())</div><div class="line">	<span class="keyword">defer</span> cancel()</div><div class="line"></div><div class="line">	<span class="comment">// 生成pdf</span></div><div class="line">	<span class="keyword">var</span> buf []<span class="typename">byte</span></div><div class="line">	<span class="keyword">if</span> err := chromedp.Run(ctx, printToPDF(<span class="string">`https://colobu.com/`</span>, &buf)); err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := ioutil.WriteFile(<span class="string">"colobu.pdf"</span>, buf,<span class="number"> 0644</span>); err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 生成任务列表</span></div><div class="line"><span class="keyword">func</span> printToPDF(urlstr <span class="typename">string</span>, res *[]<span class="typename">byte</span>) chromedp.Tasks {</div><div class="line">	<span class="keyword">return</span> chromedp.Tasks{</div><div class="line">		chromedp.Navigate(urlstr), <span class="comment">// 浏览指定的页面</span></div><div class="line">		chromedp.ActionFunc(<span class="keyword">func</span>(ctx context.Context) error {</div><div class="line">			buf, _, err := page.PrintToPDF().WithPrintBackground(<span class="constant">false</span>).Do(ctx) <span class="comment">// 通过cdp执行PrintToPDF</span></div><div class="line">			<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span> err</div><div class="line">			}</div><div class="line">			*res = buf</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}),</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="生成漂亮的图表">生成漂亮的图表</h2>
<p><a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="external">echarts</a>是我厂(百度)贡献的一个非常知名的图表库，可以通过js为网页生成巨漂亮的图表，用来数据展示。Go语言虽然有一些&quot;玩具&quot;类的图表库，但是并没有一个真正拿的出手的图标库，所以有人就利用echarts，生成一个网页，把数据展示出来，这个库是<a href="https://github.com/go-echarts/go-echarts" target="_blank" rel="external">go-echarts</a>。</p>
<p>但是，毕竟这是曲折的方式，最终生成的数据是一个网页。</p>
<p>既然刚才我们通过chromedp可以生成pdf,那么是不是也可以截图，将go-echarts生成的图表截图成一个Go的Image对象？让我们试一试。</p>
<p>首先，我们先利用go-echarts生成一个图表，并把它保存成一个html网页:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> generateEcharts() {</div><div class="line">	bar := charts.NewBar()</div><div class="line">	<span class="comment">// set some global options like Title/Legend/ToolTip or anything else</span></div><div class="line">	bar.SetGlobalOptions(charts.WithTitleOpts(opts.Title{</div><div class="line">		Title:    <span class="string">"生成一个漂亮的bar图表"</span>,</div><div class="line">		Subtitle: <span class="string">"我要得到它的灵魂"</span>,</div><div class="line">	}))</div><div class="line"></div><div class="line">	<span class="comment">// Put data into instance</span></div><div class="line">	bar.SetXAxis([]<span class="typename">string</span>{<span class="string">"Mon"</span>, <span class="string">"Tue"</span>, <span class="string">"Wed"</span>, <span class="string">"Thu"</span>, <span class="string">"Fri"</span>, <span class="string">"Sat"</span>, <span class="string">"Sun"</span>}).</div><div class="line">		AddSeries(<span class="string">"Category A"</span>, generateBarItems()).</div><div class="line">		AddSeries(<span class="string">"Category B"</span>, generateBarItems())</div><div class="line">	<span class="comment">// Where the magic happens</span></div><div class="line">	f, _ := os.Create(<span class="string">"bar.html"</span>)</div><div class="line">	bar.Render(f)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> generateBarItems() []opts.BarData {</div><div class="line">	items := <span class="built_in">make</span>([]opts.BarData,<span class="number"> 0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 7</span>; i++ {</div><div class="line">		items = <span class="built_in">append</span>(items, opts.BarData{Value: rand.Intn<span class="number">(300</span>)})</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> items</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下一步就是chromedp的工作了，浏览这个本地网页，并进行截图:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成echarts网页</span></div><div class="line">generateEcharts()</div><div class="line"></div><div class="line"><span class="comment">// 创建chromedp context</span></div><div class="line">ctx, cancel := chromedp.NewContext(</div><div class="line">	context.Background(),</div><div class="line">	chromedp.WithDebugf(log.Printf),</div><div class="line">)</div><div class="line"><span class="keyword">defer</span> cancel()</div><div class="line"></div><div class="line"><span class="comment">// 定义tasks</span></div><div class="line">elementScreenshot := <span class="keyword">func</span>(urlstr, sel <span class="typename">string</span>, res *[]<span class="typename">byte</span>) chromedp.Tasks {</div><div class="line">	<span class="keyword">return</span> chromedp.Tasks{</div><div class="line">		chromedp.Navigate(urlstr),</div><div class="line">		chromedp.Screenshot(sel, res, chromedp.NodeVisible),</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 生成截图</span></div><div class="line"><span class="keyword">var</span> buf []<span class="typename">byte</span></div><div class="line">barFile, _ := filepath.Abs(<span class="string">"./bar.html"</span>)</div><div class="line"><span class="keyword">if</span> err := chromedp.Run(ctx, elementScreenshot(<span class="string">`file://`</span>+barFile, <span class="string">`canvas`</span>, &buf)); err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 将截图写入到文件中</span></div><div class="line"><span class="keyword">if</span> err := ioutil.WriteFile(<span class="string">"bar.png"</span>, buf,<span class="number"> 0</span>o644); err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最终，生成一个截图。你可以把这个截图生成Image对象，或者把它保存到一个文件中。这里我们不进行额外的处理了，所以把它保存到文件中。生成的文件如下:</p>
<p><img src="bar.png" alt=""></p>
<p>当然，利用chromedp的打印和截图功能还能做很多事，比如转换epub电子书成pdf格式，grafana截图报警等等。</p>
<p>更多的，你可以利用chromedp干很多很多事，这依赖你的想象力，或者你可以搜一下一些网友的分享，比如<a href="https://studygolang.com/topics/12596" target="_blank" rel="external">Golang爬虫终极杀器——Chromedp让你成为二维码登陆终结者</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/chromedp/chromedp" target="_blank" rel="external">chromedp</a>是一个更快更简单的支持<a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="external">Chrome DevTools Protocol</a>协议的Go库，它是目前最流行的headless浏览器库之一，你可以使用它做很多只能通过浏览器才能执行的任务，比如网页截屏、网页渲染测试、下载视频、模拟登录等，今天我介绍它的一个有用而且很简单的功能：为一个网页生成一个pdf格式的截屏,更多的例子你可以查看官方示例<a href="https://github.com/chromedp/examples" target="_blank" rel="external">chromedp/examples</a>。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]strace的10个命令]]></title>
    <link href="https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/"/>
    <id>https://colobu.com/2021/04/30/strace-commands-for-troubleshooting-and-debugging-linux/</id>
    <published>2021-04-30T10:34:01.000Z</published>
    <updated>2021-10-06T03:29:34.504Z</updated>
    <content type="html"><![CDATA[<p>strace是一个在类Unix操作系统如Linux上做debugging和trouble shooting的超级好用的工具。它可以捕获和记录进程的所有系统调用，以及这个进程接收的所有信号。</p>
<p>原文: <a href="https://www.tecmint.com/strace-commands-for-troubleshooting-and-debugging-linux/#:~:text=strace%20is%20a%20powerful%20command,signals%20received%20by%20the%20process." target="_blank" rel="external">10 Strace Commands for Troubleshooting and Debugging Linux Processes</a></p>
<a id="more"></a>
<p>如果你的操作系统还没有安装strace，你可以运行下面的命令进行安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> apt install strace	<span class="comment">#Debian/Ubuntu </span></div><div class="line"><span class="comment"># yum install strace		#RHEL/CentOS</span></div><div class="line"><span class="comment"># dnf install strace		#Fedora 22+</span></div></pre></td></tr></table></figure>

<p>如果一个程序崩溃或以一种出乎意料的方式运行，您可以通过它的系统调用来获得在执行过程中到底发生了什么的线索。我们将在后面看到，系统调用可以分为不同的事件：与进程管理相关的事件、以文件为参数的事件、涉及网络、内存映射、信号、IPC以及与文件描述符相关的系统调用。</p>
<p>可以使用strace运行程序/命令，也可以使用<code>-p</code>选项将PID传递给它，如下面示例所示。</p>
<h2 id="追踪Linux系统调用">追踪Linux系统调用</h2>
<p>你可以通过运行下面的命令，追踪<code>df</code>命令的系统调用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ strace df -h</div><div class="line">execve(<span class="string">"/bin/df"</span>, [<span class="string">"df"</span>, <span class="string">"-h"</span>], [/* <span class="number">50</span> vars */]) = <span class="number">0</span></div><div class="line">brk(NULL)                               = <span class="number">0</span>x136e000</div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7f82f78fd000</div><div class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">147662</span>, ...}) = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">147662</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f82f78d8000</div><div class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line"><span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0"</span>..., <span class="number">832</span>) = <span class="number">832</span></div><div class="line">fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1868984</span>, ...}) = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">3971488</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f82f7310000</div><div class="line">...</div></pre></td></tr></table></figure>

<p>从上面的输出结果，我们可以看到几种类型的系统调用，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="literal">open</span>(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>open: 系统调用的类型</li>
<li>(“/etc/ld.so.cache”, O_RDONLY|O_CLOEXEC) : 系统调用的参数</li>
<li>3: 系统调用的返回结果</li>
</ul>
<p>下面是df命令执行的时候write系统调用信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">mmap(NULL, <span class="number">26258</span>, PROT_READ, MAP_SHARED, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f82f78f5000</div><div class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></div><div class="line">fstat(<span class="number">1</span>, {st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">136</span>, <span class="number">1</span>), ...}) = <span class="number">0</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"Filesystem      Size  Used Avail"</span>..., <span class="number">49</span>Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">) = <span class="number">49</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"udev            3.9G     0  3.9G"</span>..., <span class="number">43</span>udev            <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /dev</div><div class="line">) = <span class="number">43</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           788M  9.6M  779M"</span>..., <span class="number">43</span>tmpfs           <span class="number">788</span>M  <span class="number">9.6</span>M  <span class="number">779</span>M   <span class="number">2</span>% /run</div><div class="line">) = <span class="number">43</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"/dev/sda10      324G  252G   56G"</span>..., <span class="number">40</span>/dev/sda10      <span class="number">324</span>G  <span class="number">252</span>G   <span class="number">56</span>G  <span class="number">82</span>% /</div><div class="line">) = <span class="number">40</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           3.9G  104M  3.8G"</span>..., <span class="number">47</span>tmpfs           <span class="number">3.9</span>G  <span class="number">104</span>M  <span class="number">3.8</span>G   <span class="number">3</span>% /dev/shm</div><div class="line">) = <span class="number">47</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           5.0M  4.0K  5.0M"</span>..., <span class="number">48</span>tmpfs           <span class="number">5.0</span>M  <span class="number">4.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</div><div class="line">) = <span class="number">48</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           3.9G     0  3.9G"</span>..., <span class="number">53</span>tmpfs           <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /sys/fs/cgroup</div><div class="line">) = <span class="number">53</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"cgmfs           100K     0  100K"</span>..., <span class="number">56</span>cgmfs           <span class="number">100</span>K     <span class="number">0</span>  <span class="number">100</span>K   <span class="number">0</span>% /run/cgmanager/fs</div><div class="line">) = <span class="number">56</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           788M   36K  788M"</span>..., <span class="number">53</span>tmpfs           <span class="number">788</span>M   <span class="number">36</span>K  <span class="number">788</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></div><div class="line">) = <span class="number">53</span></div><div class="line">close(<span class="number">1</span>)                                = <span class="number">0</span></div><div class="line">close(<span class="number">2</span>)                                = <span class="number">0</span></div><div class="line"><span class="keyword">exit</span>_group(<span class="number">0</span>)                           = ?</div><div class="line">+++ exited with <span class="number">0</span> +++</div></pre></td></tr></table></figure>

<h2 id="根据进程PID进行追踪">根据进程PID进行追踪</h2>
<p>如果一个进程已经在运行，你可以通过它的pid进行追踪，它会显示追踪后这个进程的系统调用，使用<code>CTRL+C</code>退出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -p <span class="number">3569</span></div><div class="line">strace: Process <span class="number">3569</span> attached</div><div class="line">restart_syscall(&lt;... resuming interrupted poll ...&gt;) = <span class="number">1</span></div><div class="line">recvmsg(<span class="number">4</span>, {msg_name(<span class="number">0</span>)=NULL, msg_iov(<span class="number">1</span>)=[{<span class="string">"U\2\24\300!\247\330\0\3\24\4\0\20\0\0\0\0\0\0\24\24\24\24\24\0\0\3\37%\2\0\0"</span>, <span class="number">4096</span>}], msg_controllen=<span class="number">0</span>, msg_flags=<span class="number">0</span>}, <span class="number">0</span>) = <span class="number">32</span></div><div class="line">recvmsg(<span class="number">4</span>, <span class="number">0</span>x7ffee4dbf870, <span class="number">0</span>)           = -<span class="number">1</span> EAGAIN (Resource temporarily unavailable)</div><div class="line">recvmsg(<span class="number">4</span>, <span class="number">0</span>x7ffee4dbf850, <span class="number">0</span>)           = -<span class="number">1</span> EAGAIN (Resource temporarily unavailable)</div><div class="line">poll([{fd=<span class="number">3</span>, events=POLLIN}, {fd=<span class="number">4</span>, events=POLLIN}, {fd=<span class="number">5</span>, events=POLLIN}, {fd=<span class="number">10</span>, events=POLLIN}, {fd=<span class="number">30</span>, events=POLLIN}, {fd=<span class="number">31</span>, events=POLLIN}], <span class="number">6</span>, -<span class="number">1</span>) = <span class="number">1</span> ([{fd=<span class="number">31</span>, revents=POLLIN}])</div><div class="line"><span class="built_in">read</span>(<span class="number">31</span>, <span class="string">"\372"</span>, <span class="number">1</span>)                     = <span class="number">1</span></div><div class="line">recvmsg(<span class="number">4</span>, <span class="number">0</span>x7ffee4dbf850, <span class="number">0</span>)           = -<span class="number">1</span> EAGAIN (Resource temporarily unavailable)</div><div class="line">poll([{fd=<span class="number">3</span>, events=POLLIN}, {fd=<span class="number">4</span>, events=POLLIN}, {fd=<span class="number">5</span>, events=POLLIN}, {fd=<span class="number">10</span>, events=POLLIN}, {fd=<span class="number">30</span>, events=POLLIN}, {fd=<span class="number">31</span>, events=POLLIN}], <span class="number">6</span>, <span class="number">0</span>) = <span class="number">1</span> ([{fd=<span class="number">31</span>, revents=POLLIN}])</div><div class="line"><span class="built_in">read</span>(<span class="number">31</span>, <span class="string">"\372"</span>, <span class="number">1</span>)                     = <span class="number">1</span></div><div class="line">recvmsg(<span class="number">4</span>, <span class="number">0</span>x7ffee4dbf850, <span class="number">0</span>)           = -<span class="number">1</span> EAGAIN (Resource temporarily unavailable)</div><div class="line">poll([{fd=<span class="number">3</span>, events=POLLIN}, {fd=<span class="number">4</span>, events=POLLIN}, {fd=<span class="number">5</span>, events=POLLIN}, {fd=<span class="number">10</span>, events=POLLIN}, {fd=<span class="number">30</span>, events=POLLIN}, {fd=<span class="number">31</span>, events=POLLIN}], <span class="number">6</span>, <span class="number">0</span>) = <span class="number">0</span> (Timeout)</div><div class="line">mprotect(<span class="number">0</span>x207faa20000, <span class="number">8192</span>, PROT_READ|PROT_WRITE) = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0</span>x207faa20000, <span class="number">8192</span>, PROT_READ|PROT_EXEC) = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0</span>x207faa21000, <span class="number">4096</span>, PROT_READ|PROT_WRITE) = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0</span>x207faa21000, <span class="number">4096</span>, PROT_READ|PROT_EXEC) = <span class="number">0</span></div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="得到进程的汇总信息">得到进程的汇总信息</h2>
<p>使用<code>-c</code>参数，可以得到追踪的每一种系统调用的耗时、次数和失败数，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -c -p <span class="number">3569</span></div><div class="line"></div><div class="line">strace: Process <span class="number">3569</span> attached</div><div class="line"></div><div class="line">^Cstrace: Process <span class="number">3569</span> detached</div><div class="line">% time     seconds  usecs/call     calls    errors syscall</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line"> <span class="number">99.73</span>    <span class="number">0.016000</span>           <span class="number">8</span>      <span class="number">1971</span>           poll</div><div class="line">  <span class="number">0.16</span>    <span class="number">0.000025</span>           <span class="number">0</span>       <span class="number">509</span>        <span class="number">75</span> futex</div><div class="line">  <span class="number">0.06</span>    <span class="number">0.000010</span>           <span class="number">0</span>      <span class="number">1985</span>      <span class="number">1966</span> recvmsg</div><div class="line">  <span class="number">0.06</span>    <span class="number">0.000009</span>           <span class="number">0</span>      <span class="number">2336</span>           mprotect</div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>       <span class="number">478</span>           <span class="built_in">read</span></div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>        <span class="number">13</span>           write</div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>        <span class="number">29</span>           mmap</div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>         <span class="number">9</span>           munmap</div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>        <span class="number">18</span>           writev</div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>       <span class="number">351</span>           madvise</div><div class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>         <span class="number">1</span>           restart_syscall</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line"><span class="number">100.00</span>    <span class="number">0.016044</span>                  <span class="number">7700</span>      <span class="number">2041</span> total</div></pre></td></tr></table></figure>

<h2 id="打印指令指针">打印指令指针</h2>
<p><code>-i</code>可以显示每一次系统调用的时候的指令指针。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -i df -h</div><div class="line">[<span class="number">00007</span>f0d7534c777] execve(<span class="string">"/bin/df"</span>, [<span class="string">"df"</span>, <span class="string">"-h"</span>], [/* <span class="number">17</span> vars */]) = <span class="number">0</span></div><div class="line">[<span class="number">00007</span>faf9cafa4b9] brk(NULL)            = <span class="number">0</span>x12f0000</div><div class="line">[<span class="number">00007</span>faf9cafb387] access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK) = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">[<span class="number">00007</span>faf9cafb47a] mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7faf9<span class="built_in">cd</span>03000</div><div class="line">[<span class="number">00007</span>faf9cafb387] access(<span class="string">"/etc/ld.so.preload"</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">[<span class="number">00007</span>faf9cafb327] open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">[<span class="number">00007</span>faf9cafb2b4] fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">147662</span>, ...}) = <span class="number">0</span></div><div class="line">[<span class="number">00007</span>faf9cafb47a] mmap(NULL, <span class="number">147662</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7faf9ccde000</div><div class="line">[<span class="number">00007</span>faf9cafb427] close(<span class="number">3</span>)             = <span class="number">0</span></div><div class="line">[<span class="number">00007</span>faf9cafb387] access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK) = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">[<span class="number">00007</span>faf9cafb327] open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">[<span class="number">00007</span>faf9cafb347] <span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0"</span>..., <span class="number">832</span>) = <span class="number">832</span></div><div class="line">[<span class="number">00007</span>faf9cafb2b4] fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1868984</span>, ...}) = <span class="number">0</span></div><div class="line">[<span class="number">00007</span>faf9cafb47a] mmap(NULL, <span class="number">3971488</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7faf9c716000</div><div class="line">[<span class="number">00007</span>faf9cafb517] mprotect(<span class="number">0</span>x7faf9c8d6000, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="显示每一次调用的时间">显示每一次调用的时间</h2>
<p><code>-t</code>参数可以显示时间戳。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -t df -h</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> execve(<span class="string">"/bin/df"</span>, [<span class="string">"df"</span>, <span class="string">"-h"</span>], [/* <span class="number">17</span> vars */]) = <span class="number">0</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> brk(NULL)                      = <span class="number">0</span>x234c000</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK) = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7f8c7f1d9000</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> access(<span class="string">"/etc/ld.so.preload"</span>, R_OK) = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">147662</span>, ...}) = <span class="number">0</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> mmap(NULL, <span class="number">147662</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f8c7f1b4000</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> close(<span class="number">3</span>)                       = <span class="number">0</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK) = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> <span class="built_in">read</span>(<span class="number">3</span>, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0"</span>..., <span class="number">832</span>) = <span class="number">832</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1868984</span>, ...}) = <span class="number">0</span></div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> mmap(NULL, <span class="number">3971488</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f8c7ebec000</div><div class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">25</span> mprotect(<span class="number">0</span>x7f8c7edac000, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="显示系统调用的耗时">显示系统调用的耗时</h2>
<p><code>-T</code>参数可以显示系统调用的耗时时间。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -T df -h</div><div class="line"></div><div class="line">execve(<span class="string">"/bin/df"</span>, [<span class="string">"df"</span>, <span class="string">"-h"</span>], [/* <span class="number">17</span> vars */]) = <span class="number">0</span> &lt;<span class="number">0.000287</span>&gt;</div><div class="line">brk(NULL)                               = <span class="number">0</span>xeca000 &lt;<span class="number">0.000035</span>&gt;</div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -<span class="number">1</span> ENOENT (No such file or directory) &lt;<span class="number">0.000028</span>&gt;</div><div class="line">mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7f9aff2b1000 &lt;<span class="number">0.000020</span>&gt;</div><div class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -<span class="number">1</span> ENOENT (No such file or directory) &lt;<span class="number">0.000019</span>&gt;</div><div class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span> &lt;<span class="number">0.000022</span>&gt;</div><div class="line">fstat(<span class="number">3</span>, {st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">147662</span>, ...}) = <span class="number">0</span> &lt;<span class="number">0.000015</span>&gt;</div><div class="line">mmap(NULL, <span class="number">147662</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7f9aff28c000 &lt;<span class="number">0.000019</span>&gt;</div><div class="line">close(<span class="number">3</span>)                                = <span class="number">0</span> &lt;<span class="number">0.000014</span>&gt;</div><div class="line">...</div></pre></td></tr></table></figure>

<h2 id="只追踪特定的系统调用">只追踪特定的系统调用</h2>
<p>下面的命令中,<code>trace=write</code>是使用一个特定的表达式做筛选，只追踪特定的系统调用。表达式可以是signal, abbrev, verbose, raw, read 和 write等几种类型。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace <span class="operator">-e</span> trace=write df -h</div><div class="line"></div><div class="line">write(<span class="number">1</span>, <span class="string">"Filesystem      Size  Used Avail"</span>..., <span class="number">49</span>Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">) = <span class="number">49</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"udev            3.9G     0  3.9G"</span>..., <span class="number">43</span>udev            <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /dev</div><div class="line">) = <span class="number">43</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           788M  9.6M  779M"</span>..., <span class="number">43</span>tmpfs           <span class="number">788</span>M  <span class="number">9.6</span>M  <span class="number">779</span>M   <span class="number">2</span>% /run</div><div class="line">) = <span class="number">43</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"/dev/sda10      324G  252G   56G"</span>..., <span class="number">40</span>/dev/sda10      <span class="number">324</span>G  <span class="number">252</span>G   <span class="number">56</span>G  <span class="number">82</span>% /</div><div class="line">) = <span class="number">40</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           3.9G  104M  3.8G"</span>..., <span class="number">47</span>tmpfs           <span class="number">3.9</span>G  <span class="number">104</span>M  <span class="number">3.8</span>G   <span class="number">3</span>% /dev/shm</div><div class="line">) = <span class="number">47</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           5.0M  4.0K  5.0M"</span>..., <span class="number">48</span>tmpfs           <span class="number">5.0</span>M  <span class="number">4.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</div><div class="line">) = <span class="number">48</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           3.9G     0  3.9G"</span>..., <span class="number">53</span>tmpfs           <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /sys/fs/cgroup</div><div class="line">) = <span class="number">53</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"cgmfs           100K     0  100K"</span>..., <span class="number">56</span>cgmfs           <span class="number">100</span>K     <span class="number">0</span>  <span class="number">100</span>K   <span class="number">0</span>% /run/cgmanager/fs</div><div class="line">) = <span class="number">56</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"tmpfs           788M   28K  788M"</span>..., <span class="number">53</span>tmpfs           <span class="number">788</span>M   <span class="number">28</span>K  <span class="number">788</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></div><div class="line">) = <span class="number">53</span></div><div class="line">+++ exited with <span class="number">0</span> +++</div></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace <span class="operator">-e</span> trace=open,close df -h</div><div class="line">$ <span class="built_in">sudo</span> strace <span class="operator">-e</span> trace=open,close,<span class="built_in">read</span>,write df -h</div><div class="line">$ <span class="built_in">sudo</span> strace <span class="operator">-e</span> trace=all df -h</div></pre></td></tr></table></figure>

<h2 id="基于特定条件的系统调用">基于特定条件的系统调用</h2>
<p>可以针对特定类型进行追踪(process、file、memory、network、signal)等等。</p>
<p>针对进行管理的追踪:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -q <span class="operator">-e</span> trace=process df -h	</div><div class="line"></div><div class="line">execve(<span class="string">"/bin/df"</span>, [<span class="string">"df"</span>, <span class="string">"-h"</span>], [/* <span class="number">17</span> vars */]) = <span class="number">0</span></div><div class="line">arch_prctl(ARCH_SET_FS, <span class="number">0</span>x7fe2222ff700) = <span class="number">0</span></div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">udev            <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /dev</div><div class="line">tmpfs           <span class="number">788</span>M  <span class="number">9.6</span>M  <span class="number">779</span>M   <span class="number">2</span>% /run</div><div class="line">/dev/sda10      <span class="number">324</span>G  <span class="number">252</span>G   <span class="number">56</span>G  <span class="number">82</span>% /</div><div class="line">tmpfs           <span class="number">3.9</span>G  <span class="number">104</span>M  <span class="number">3.8</span>G   <span class="number">3</span>% /dev/shm</div><div class="line">tmpfs           <span class="number">5.0</span>M  <span class="number">4.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</div><div class="line">tmpfs           <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /sys/fs/cgroup</div><div class="line">cgmfs           <span class="number">100</span>K     <span class="number">0</span>  <span class="number">100</span>K   <span class="number">0</span>% /run/cgmanager/fs</div><div class="line">tmpfs           <span class="number">788</span>M   <span class="number">28</span>K  <span class="number">788</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></div><div class="line"><span class="keyword">exit</span>_group(<span class="number">0</span>)                           = ?</div><div class="line">+++ exited with <span class="number">0</span> +++</div></pre></td></tr></table></figure>

<p>针对文件系统调用的追踪：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -q  <span class="operator">-e</span> trace=file df -h</div><div class="line"></div><div class="line">execve(<span class="string">"/bin/df"</span>, [<span class="string">"df"</span>, <span class="string">"-h"</span>], [/* <span class="number">17</span> vars */]) = <span class="number">0</span></div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -<span class="number">1</span> ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">open(<span class="string">"/usr/lib/locale/locale-archive"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">open(<span class="string">"/usr/share/locale/locale.alias"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">...</div></pre></td></tr></table></figure>

<p>针对内存的追踪:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -q <span class="operator">-e</span> trace=memory df -h	</div><div class="line"></div><div class="line">brk(NULL)                               = <span class="number">0</span>x77a000</div><div class="line">mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4658000</div><div class="line">mmap(NULL, <span class="number">147662</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4633000</div><div class="line">mmap(NULL, <span class="number">3971488</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f406b000</div><div class="line">mprotect(<span class="number">0</span>x7fe8f422b000, <span class="number">2097152</span>, PROT_NONE) = <span class="number">0</span></div><div class="line">mmap(<span class="number">0</span>x7fe8f442b000, <span class="number">24576</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>x1c0000) = <span class="number">0</span>x7fe8f442b000</div><div class="line">mmap(<span class="number">0</span>x7fe8f4431000, <span class="number">14752</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4431000</div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4632000</div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4631000</div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4630000</div><div class="line">mprotect(<span class="number">0</span>x7fe8f442b000, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0</span>x616000, <span class="number">4096</span>, PROT_READ)     = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0</span>x7fe8f465a000, <span class="number">4096</span>, PROT_READ) = <span class="number">0</span></div><div class="line">munmap(<span class="number">0</span>x7fe8f4633000, <span class="number">147662</span>)          = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">2981280</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f3d93000</div><div class="line">brk(NULL)                               = <span class="number">0</span>x77a000</div><div class="line">brk(<span class="number">0</span>x79b000)                           = <span class="number">0</span>x79b000</div><div class="line">mmap(NULL, <span class="number">619</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4657000</div><div class="line">mmap(NULL, <span class="number">26258</span>, PROT_READ, MAP_SHARED, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0</span>x7fe8f4650000</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">udev            <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /dev</div><div class="line">tmpfs           <span class="number">788</span>M  <span class="number">9.6</span>M  <span class="number">779</span>M   <span class="number">2</span>% /run</div><div class="line">/dev/sda10      <span class="number">324</span>G  <span class="number">252</span>G   <span class="number">56</span>G  <span class="number">82</span>% /</div><div class="line">tmpfs           <span class="number">3.9</span>G  <span class="number">104</span>M  <span class="number">3.8</span>G   <span class="number">3</span>% /dev/shm</div><div class="line">tmpfs           <span class="number">5.0</span>M  <span class="number">4.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</div><div class="line">tmpfs           <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /sys/fs/cgroup</div><div class="line">cgmfs           <span class="number">100</span>K     <span class="number">0</span>  <span class="number">100</span>K   <span class="number">0</span>% /run/cgmanager/fs</div><div class="line">tmpfs           <span class="number">788</span>M   <span class="number">28</span>K  <span class="number">788</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></div><div class="line">+++ exited with <span class="number">0</span> +++</div></pre></td></tr></table></figure>

<p>以及针对网络和信号的追踪:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace <span class="operator">-e</span> trace=network df -h</div><div class="line">$ <span class="built_in">sudo</span> strace <span class="operator">-e</span> trace=signal df -h</div></pre></td></tr></table></figure>

<h2 id="将追踪结果写入到文件">将追踪结果写入到文件</h2>
<p><code>-o</code>参数将标准输出写入到文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> strace -o df_debug.txt df -h</div><div class="line"></div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">udev            <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /dev</div><div class="line">tmpfs           <span class="number">788</span>M  <span class="number">9.6</span>M  <span class="number">779</span>M   <span class="number">2</span>% /run</div><div class="line">/dev/sda10      <span class="number">324</span>G  <span class="number">252</span>G   <span class="number">56</span>G  <span class="number">82</span>% /</div><div class="line">tmpfs           <span class="number">3.9</span>G  <span class="number">104</span>M  <span class="number">3.8</span>G   <span class="number">3</span>% /dev/shm</div><div class="line">tmpfs           <span class="number">5.0</span>M  <span class="number">4.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</div><div class="line">tmpfs           <span class="number">3.9</span>G     <span class="number">0</span>  <span class="number">3.9</span>G   <span class="number">0</span>% /sys/fs/cgroup</div><div class="line">cgmfs           <span class="number">100</span>K     <span class="number">0</span>  <span class="number">100</span>K   <span class="number">0</span>% /run/cgmanager/fs</div><div class="line">tmpfs           <span class="number">788</span>M   <span class="number">28</span>K  <span class="number">788</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></div></pre></td></tr></table></figure>

<h2 id="显示strace的debug信息">显示strace的debug信息</h2>
<p><code>-d</code>可以显示strace的debug信息。</p>
<p>更多的信息参考<code>man strace</code>。</p>
<p>其它一些参考资料:</p>
<ul>
<li><a href="https://www.tecmint.com/command-line-tools-to-monitor-linux-performance/" target="_blank" rel="external">20 Command Line Tools to Monitor Linux Performance</a></li>
<li><a href="https://www.tecmint.com/command-line-tools-to-monitor-linux-performance/" target="_blank" rel="external">Sysdig – A Powerful System Monitoring and Troubleshooting Tool for Linux</a></li>
<li><a href="https://www.tecmint.com/trace-shell-script-execution-in-linux/" target="_blank" rel="external">How to Trace Execution of Commands in Shell Script with Shell Tracing</a></li>
<li><a href="https://www.tecmint.com/bcc-best-linux-performance-monitoring-tools/" target="_blank" rel="external">BCC – Dynamic Tracing Tools for Linux Performance Monitoring, Networking and More</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>strace是一个在类Unix操作系统如Linux上做debugging和trouble shooting的超级好用的工具。它可以捕获和记录进程的所有系统调用，以及这个进程接收的所有信号。</p>
<p>原文: <a href="https://www.tecmint.com/strace-commands-for-troubleshooting-and-debugging-linux/#:~:text=strace%20is%20a%20powerful%20command,signals%20received%20by%20the%20process." target="_blank" rel="external">10 Strace Commands for Troubleshooting and Debugging Linux Processes</a></p>
]]>
    
    </summary>
    
      <category term="工具" scheme="https://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rpcx支持websocket协议了!]]></title>
    <link href="https://colobu.com/2021/04/11/support-websocket-in-rpcx/"/>
    <id>https://colobu.com/2021/04/11/support-websocket-in-rpcx/</id>
    <published>2021-04-11T10:19:21.000Z</published>
    <updated>2021-10-06T03:29:34.504Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<p>当前， rpcx支持tcp、kcp、quic、unix domain、http、jsonrpc 2.0等传输协议，并没有考虑websocket的支持，原因在于考虑到微服务更多的是企业内部服务之间的通讯，不太可能暴露给浏览器，企业内部大多采用tcp的方式传输，或者udp族(kcp、quic)方式的传输，但是还是有用户提出希望能支持websocket。</p>
<p>我想websocket可能还是会有一些场景下使用，比如游戏开发，移动端核服务端的通讯等等，所以经过慎重考虑，我决定在 rpcx 1.6.2版本中增加对websocket的支持。</p>
<a id="more"></a>
<p>基于rpcx良好的架构设计，实现对websocket的支持并不难。</p>
<p>本来，rpcx对kcp、quic的支持也不复杂，原因在于rpcx的通讯采用的<code>net.Conn</code>的这样一个通用的接口，<code>listent.Accept</code>方法接受客户端的请求后返回一个<code>net.Conn</code>对象，后续请求的解析、处理，写回都是在这个通用接口上操作的，所以非常容易支持新的传输协议。</p>
<ul>
<li>kcp: 基于<a href="https://pkg.go.dev/github.com/xtaci/kcp-go" target="_blank" rel="external">xtaci/kcp-go</a>库</li>
<li>quic: 基于定制的<a href="https://github.com/smallnest/quick" target="_blank" rel="external">smallnest/quick</a>库，依赖<a href="https://github.com/lucas-clemente/quic-go" target="_blank" rel="external">uic-go</a>的实现。</li>
</ul>
<p>以前rpcx还支持其它的udp的扩展协议，比如</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/anacrolix/utp" target="_blank" rel="external">uTP</a></li>
<li><a href="https://github.com/u35s/rudp" target="_blank" rel="external">rudp</a></li>
</ul>
<p>因为这两个协议用的人很少，所以在rpcx 1.6中把这两个协议的支持去掉了。</p>
<p>所以，对于websocket来说，找到一个可信赖的、合适的websocket库，可以很容易的实现基于websocket传输的微服务框架。</p>
<p>目前Go生态圈常用的websocket库如下：</p>
<ul>
<li><a href="https://github.com/golang/net" target="_blank" rel="external">x/net/websocket</a></li>
<li><a href="https://pkg.go.dev/github.com/gorilla/websocket" target="_blank" rel="external">gorilla/websocket</a>: 老牌的gorilla框架提供的websocket库</li>
<li><a href="https://github.com/gobwas/ws" target="_blank" rel="external">gobwas/ws</a></li>
<li><a href="https://github.com/nhooyr/websocket" target="_blank" rel="external">nhooyr/websocket</a></li>
</ul>
<p>虽然像<code>gobwas/ws</code>性能优良、<code>gorilla/websocket</code>功能齐全，但是考虑到API的便利性，我还是决定使用Go官方的<code>x/net/websocket</code>库，一来有官方背书，值得信赖，二来rpcx使用websocket功能比较简单，就是期望能获得一个<code>net.Conn</code>对象，<code>x/net/websocket</code>库正好能满足需求。</p>
<h2 id="服务端">服务端</h2>
<p>如果服务端采用websocket协议，那么network应该写成<code>ws</code>或者<code>wss</code>,而不是<code>tcp</code>或者<code>quic</code>。</p>
<p>服务端会启动一个http server处理websocket请求。 默认的websocket path为 <code>share.DefaultRPCPath</code>,只要服务端核客户端保持一致即可。</p>
<p><code>ServeWS</code>会传入一个<code>*websocket.Conn</code>参数，它实现了<code>net.Conn</code>接口，所以后续的处理使用通用的<code>s.serveConn(conn)</code>即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> (s *Server) Serve(network, address <span class="typename">string</span>) (err error) {</div><div class="line">	......</div><div class="line"></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"ws"</span> || network == <span class="string">"wss"</span> {</div><div class="line">		s.serveByWS(ln, <span class="string">""</span>)</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	......</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *Server) serveByWS(ln net.Listener, rpcPath <span class="typename">string</span>) {</div><div class="line">	s.ln = ln</div><div class="line"></div><div class="line">	<span class="keyword">if</span> rpcPath == <span class="string">""</span> {</div><div class="line">		rpcPath = share.DefaultRPCPath</div><div class="line">	}</div><div class="line">	mux := http.NewServeMux()</div><div class="line">	mux.Handle(rpcPath, websocket.Handler(s.ServeWS))</div><div class="line">	srv := &http.Server{Handler: mux}</div><div class="line"></div><div class="line">	srv.Serve(ln)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *Server) ServeWS(conn *websocket.Conn) {</div><div class="line">	s.mu.Lock()</div><div class="line">	s.activeConn[conn] = <span class="keyword">struct</span>{}{}</div><div class="line">	s.mu.Unlock()</div><div class="line"></div><div class="line">	s.serveConn(conn)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>服务端的改造就如此简单，接下来看看如何部署一个服务端的websocket服务:</p>
<figure class="highlight go"><figcaption><span>server.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line">	s.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith), <span class="string">""</span>)</div><div class="line">	err := s.Serve(<span class="string">"ws"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="客户端">客户端</h2>
<p>客户端最重要的是要实现一个websocket协议的建连，如果实现了这个方法，客户端的改造基本就完成了。这个方法的实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> newDirectWSConn(c *Client, network, address <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">	<span class="keyword">if</span> c == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, errors.New(<span class="string">"empty client"</span>)</div><div class="line">	}</div><div class="line">	path := c.option.RPCPath</div><div class="line">	<span class="keyword">if</span> path == <span class="string">""</span> {</div><div class="line">		path = share.DefaultRPCPath</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> conn net.Conn</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	<span class="comment">// url := "ws://localhost:12345/ws"</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> url, origin <span class="typename">string</span></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"ws"</span> {</div><div class="line">		url = fmt.Sprintf(<span class="string">"ws://%s%s"</span>, address, path)</div><div class="line">		origin = fmt.Sprintf(<span class="string">"http://%s"</span>, address)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		url = fmt.Sprintf(<span class="string">"wss://%s%s"</span>, address, path)</div><div class="line">		origin = fmt.Sprintf(<span class="string">"https://%s"</span>, address)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> c.option.TLSConfig != <span class="constant">nil</span> {</div><div class="line">		config, err := websocket.NewConfig(url, origin)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">		}</div><div class="line">		config.TlsConfig = c.option.TLSConfig</div><div class="line">		conn, err = websocket.DialConfig(config)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		conn, err = websocket.Dial(url, <span class="string">""</span>, origin)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> conn, err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在建立连接的时候为<code>ws</code>和<code>wss</code>协议调用这个方法即可:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *Client) Connect(network, address <span class="typename">string</span>) error {</div><div class="line">	<span class="keyword">var</span> conn net.Conn</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> network {</div><div class="line">	<span class="keyword">case</span> <span class="string">"http"</span>:</div><div class="line">		conn, err = newDirectHTTPConn(c, network, address)</div><div class="line">	<span class="keyword">case</span> <span class="string">"ws"</span>, <span class="string">"wss"</span>:</div><div class="line">		conn, err = newDirectWSConn(c, network, address)</div><div class="line">	<span class="keyword">case</span> <span class="string">"kcp"</span>:</div><div class="line">		conn, err = newDirectKCPConn(c, network, address)</div><div class="line">    .......</div></pre></td></tr></table></figure>

<p>客户端改造完成后，我们写一个客户端调用改车把刚才启动的websocket服务:</p>
<figure class="highlight go"><figcaption><span>client.fo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	d, _ := client.NewPeer2PeerDiscovery(<span class="string">"ws@"</span>+*addr, <span class="string">""</span>)</div><div class="line">	opt := client.DefaultOption</div><div class="line">	opt.SerializeType = protocol.JSON</div><div class="line"></div><div class="line">	xclient := client.NewXClient(<span class="string">"Arith"</span>, client.Failtry, client.RandomSelect, d, opt)</div><div class="line">	<span class="keyword">defer</span> xclient.Close()</div><div class="line"></div><div class="line">	args := example.Args{</div><div class="line">		A:<span class="number"> 10</span>,</div><div class="line">		B:<span class="number"> 20</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	reply := &example.Reply{}</div><div class="line">	err := xclient.Call(context.Background(), <span class="string">"Mul"</span>, args, reply)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"%d * %d = %d"</span>, args.A, args.B, reply.C)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以你看到，对于一个新的传输协议来说，如果它的连接能够遵循<code>net.Conn</code>接口，rpcx支持它还是很容易的。</p>
<p>完整的使用websocket传输协议的例子: <a href="https://github.com/rpcxio/rpcx-examples/tree/master/websocket" target="_blank" rel="external">websocket example</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<!--more-->
<p>当前， rpcx支持tcp、kcp、quic、unix domain、http、jsonrpc 2.0等传输协议，并没有考虑websocket的支持，原因在于考虑到微服务更多的是企业内部服务之间的通讯，不太可能暴露给浏览器，企业内部大多采用tcp的方式传输，或者udp族(kcp、quic)方式的传输，但是还是有用户提出希望能支持websocket。</p>
<p>我想websocket可能还是会有一些场景下使用，比如游戏开发，移动端核服务端的通讯等等，所以经过慎重考虑，我决定在 rpcx 1.6.2版本中增加对websocket的支持。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 泛型尝鲜]]></title>
    <link href="https://colobu.com/2021/03/22/try-go-generic/"/>
    <id>https://colobu.com/2021/03/22/try-go-generic/</id>
    <published>2021-03-22T03:30:16.000Z</published>
    <updated>2021-10-06T03:29:34.647Z</updated>
    <content type="html"><![CDATA[<p>我在二月份的文章<a href="https://colobu.com/2021/02/20/merge-dev-typeparams-to-master-during-Go-1-17/" target="_blank" rel="external">利好！极大可能在go 1.17中就能尝试泛型</a>提到，虽然Go泛型会在Go 1.18中正式发布，但是因为各种原因，代码已经开始在master分支中实现，所以极大可能你会在今年9月份发布的Go 1.17中就能尝试使用Go泛型。</p>
<p>那么，现在，可以去掉&quot;可能&quot;这两个字了。在Go 1.17可以确定的说你能够尝试Go泛型编程了，尽管建议你还是在Go 1.18以及以后的版本才正式在产品中使用泛型。</p>
<a id="more"></a>
<p>即使是现在，你也可以通过自己编译master分支的方式，开始领略Go泛型的风采。</p>
<h2 id="安装">安装</h2>
<p>你可以通过下面的命令按照最新的master分支(Go项目中称之为tip):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go get golang.org/dl/gotip</div><div class="line">gotip download</div></pre></td></tr></table></figure>

<p>gotip命令会clone最新的master并进行编译，编译完之后，你就是可以使用<code>gotip</code>命令了。在需要<code>go</code>执行程序的时候，只需要换成<code>gotip</code>即可。</p>
<p>如果因为墙或者网络的原因，你不能执行上面的<code>gotip download</code>命令的话，你也可以直接git clone github上的go项目，执行src下的make.bash文件，也可以编译出go可执行程序。</p>
<p>甚至你也可以结合这两种方式，相信如果有些许的下载困难不会阻碍到你。</p>
<h2 id="运行泛型例子">运行泛型例子</h2>
<p>比如下面一个加法的泛型例子,定义了一个<code>Addable</code>的约束(constraint)，也就是可以执行加法的类型约束。<br>然后实现了一个泛型方法add, 参数有两个(a和b),类型是满足<code>Addable</code>约束的类型，然后返回相加的结果。</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span> {</div><div class="line">	<span class="keyword">type</span> <span class="typename">int</span>, <span class="typename">int8</span>, <span class="typename">int16</span>, <span class="typename">int32</span>, <span class="typename">int64</span>,</div><div class="line">		<span class="typename">uint</span>, <span class="typename">uint8</span>, <span class="typename">uint16</span>, <span class="typename">uint32</span>, <span class="typename">uint64</span>, <span class="typename">uintptr</span>,</div><div class="line">		<span class="typename">float32</span>, <span class="typename">float64</span>, <span class="typename">complex64</span>, <span class="typename">complex128</span>,</div><div class="line">		<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> add[T Addable](a, b T) T {</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Println(add<span class="number">(1</span><span class="number">,2</span>))</div><div class="line"></div><div class="line">    <span class="comment">// FIXME</span></div><div class="line">    <span class="comment">//fmt.Println(add("foo","bar"))</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行<code>gotip build -gcflags=-G=3 main.go</code>可以执行这个文件，返回结果3。</p>
<p>Go语言中两个字符串可以相加吗？</p>
<p>&quot;是的&quot;! 字符串相加相当于<code>concat</code>,把两个字符串连接起来，返回一个新的连接的字符串。按说，字符串也满足<code>Addable</code>约束，但是你如果把倒数第二行的注释去掉的话，这个程序是编译不过的。</p>
<p>原因在于Go的泛型还在开发之中，里面肯定还有大大小小的问题，所以即使Go 1.17发布了，必然还得存在一些不完善得地方，更何况现在里发布Go 1.17还早呢。</p>
<p>更多得例子可以参照Yasuhiro Matsumoto的<a href="https://github.com/mattn/go-generics-example" target="_blank" rel="external">mattn/go-generics-example</a>项目，他提供十几个泛型的例子，包括上面的add的例子。</p>
<p>如果你觉得好玩，不妨按照本文的安装方法，试试Go的泛型的功能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我在二月份的文章<a href="https://colobu.com/2021/02/20/merge-dev-typeparams-to-master-during-Go-1-17/" target="_blank" rel="external">利好！极大可能在go 1.17中就能尝试泛型</a>提到，虽然Go泛型会在Go 1.18中正式发布，但是因为各种原因，代码已经开始在master分支中实现，所以极大可能你会在今年9月份发布的Go 1.17中就能尝试使用Go泛型。</p>
<p>那么，现在，可以去掉&quot;可能&quot;这两个字了。在Go 1.17可以确定的说你能够尝试Go泛型编程了，尽管建议你还是在Go 1.18以及以后的版本才正式在产品中使用泛型。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go代码覆盖率工具介绍]]></title>
    <link href="https://colobu.com/2021/03/15/go-cover-introduction/"/>
    <id>https://colobu.com/2021/03/15/go-cover-introduction/</id>
    <published>2021-03-15T13:49:48.000Z</published>
    <updated>2021-10-06T03:29:34.297Z</updated>
    <content type="html"><![CDATA[<p>代码覆盖率是软件测试中的一种度量，描述程序中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p>
<a id="more"></a>
<div class="bilibili"><br>    <iframe width="95%" height="450" src="//player.bilibili.com/player.html?aid=929627497&bvid=BV1jK4y1U7cY&cid=310271674&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></div>


<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p><img src="5.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>代码覆盖率是软件测试中的一种度量，描述程序中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
