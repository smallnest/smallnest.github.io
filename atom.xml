<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2023-12-11T05:55:44.789Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Go单线程运行也会有并发问题]]></title>
    <link href="https://colobu.com/2023/12/11/concurrency-issues-of-the-single-thread-in-Go/"/>
    <id>https://colobu.com/2023/12/11/concurrency-issues-of-the-single-thread-in-Go/</id>
    <published>2023-12-11T05:37:51.000Z</published>
    <updated>2023-12-11T05:55:08.016Z</updated>
    <content type="html"><![CDATA[<p>一个Go大佬群中严肃的讨论了一个问题：Go程序单线程多goroutine访问一个map会遇到并发读写panic么？</p>
<a id="more"></a>
<p>答案是肯定的，因为出现了这个问题所以大家才在群中讨论。</p>
<p>为什么呢？因为单线程意味着并行单元只有一个(多线程也可能并行单元只有一个)，但是多goroutine意味着并发单元有多个，如果并发单元同时执行，即使是单线程，可能就会产生数据竞争的问题，除非这些goroutine是顺序执行的。</p>
<p>举一个例子哈：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestCounter() {</div><div class="line">    runtime.GOMAXPROCS<span class="number">(1</span>)</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> counter <span class="typename">int</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		i := i</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Printf(<span class="string">"start task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 10</span>_0000; j++ {</div><div class="line">				counter++</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"end task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">	fmt.Println(counter)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段测试代码是启动10个goroutine对计数器加一，每个goroutine负责加10万次。在我的MBP m1笔记本上，每次的结果都是100万，符合期望。如果你运行这段代码，会发现goroutine其实是一个一个串行执行的(9-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8，当然可能在你的机器上不是这样的)，如果是串行执行，不会有并发问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">start task<span class="comment">#9, counter: 0</span></div><div class="line">end task<span class="comment">#9, counter: 100000</span></div><div class="line">start task<span class="comment">#0, counter: 100000</span></div><div class="line">end task<span class="comment">#0, counter: 200000</span></div><div class="line">start task<span class="comment">#1, counter: 200000</span></div><div class="line">end task<span class="comment">#1, counter: 300000</span></div><div class="line">start task<span class="comment">#2, counter: 300000</span></div><div class="line">end task<span class="comment">#2, counter: 400000</span></div><div class="line">start task<span class="comment">#3, counter: 400000</span></div><div class="line">end task<span class="comment">#3, counter: 500000</span></div><div class="line">start task<span class="comment">#4, counter: 500000</span></div><div class="line">end task<span class="comment">#4, counter: 600000</span></div><div class="line">start task<span class="comment">#5, counter: 600000</span></div><div class="line">end task<span class="comment">#5, counter: 700000</span></div><div class="line">start task<span class="comment">#6, counter: 700000</span></div><div class="line">end task<span class="comment">#6, counter: 800000</span></div><div class="line">start task<span class="comment">#7, counter: 800000</span></div><div class="line">end task<span class="comment">#7, counter: 900000</span></div><div class="line">start task<span class="comment">#8, counter: 900000</span></div><div class="line">end task<span class="comment">#8, counter: 1000000</span></div><div class="line"><span class="number">1000000</span></div></pre></td></tr></table></figure>

<p>为了制造点紧张气氛，我将代码改写成下面这样子，将<code>counter++</code>三条指令明显写成三条语句，并在中间插入<code>runtime.Gosched()</code>,故意给其它goroutine的执行制造机会：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestCounter2() {</div><div class="line">    runtime.GOMAXPROCS<span class="number">(1</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> counter <span class="typename">int</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		i := i</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Printf(<span class="string">"start task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 10</span>_0000; j++ {</div><div class="line">				temp := counter</div><div class="line">				runtime.Gosched()</div><div class="line">				temp = temp +<span class="number"> 1</span></div><div class="line">				counter = temp</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"end task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">	fmt.Println(counter)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这段代码，你就会明显看到数据不一致的效果，即使是单个线程运行goroutine,也出现了数据竞争的问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">start task<span class="comment">#9, counter: 0</span></div><div class="line">start task<span class="comment">#0, counter: 0</span></div><div class="line">start task<span class="comment">#1, counter: 0</span></div><div class="line">start task<span class="comment">#2, counter: 0</span></div><div class="line">start task<span class="comment">#3, counter: 0</span></div><div class="line">start task<span class="comment">#4, counter: 0</span></div><div class="line">start task<span class="comment">#5, counter: 0</span></div><div class="line">start task<span class="comment">#6, counter: 0</span></div><div class="line">start task<span class="comment">#7, counter: 0</span></div><div class="line">start task<span class="comment">#8, counter: 0</span></div><div class="line">end task<span class="comment">#9, counter: 100000</span></div><div class="line">end task<span class="comment">#1, counter: 100000</span></div><div class="line">end task<span class="comment">#3, counter: 100000</span></div><div class="line">end task<span class="comment">#2, counter: 100000</span></div><div class="line">end task<span class="comment">#5, counter: 100000</span></div><div class="line">end task<span class="comment">#0, counter: 100000</span></div><div class="line">end task<span class="comment">#4, counter: 100000</span></div><div class="line">end task<span class="comment">#6, counter: 100000</span></div><div class="line">end task<span class="comment">#7, counter: 100000</span></div><div class="line">end task<span class="comment">#8, counter: 100000</span></div><div class="line"><span class="number">100000</span></div></pre></td></tr></table></figure>

<p>这个结果非常离谱，期望100万，最后只有10万。</p>
<p>因为单个线程运行多个goroutine会有数据竞争的问题，所以访问同一个map对象也有可能出现并发bug,比如下面的代码，10个goroutine并发的写同一个map:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestMap() {</div><div class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>)</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		i := i</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Printf(<span class="string">"start map task#%d, m: %v\n"</span>, i, <span class="built_in">len</span>(m))</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 10</span>_0000; j++ {</div><div class="line">				m[j] = i<span class="number">*10</span>_0000 + j</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"end map task#%d, m: %v\n"</span>, i, <span class="built_in">len</span>(m))</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大概率会出现panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">start <span class="keyword">map</span> task<span class="number">#9</span>, m:<span class="number"> 0</span></div><div class="line">start <span class="keyword">map</span> task<span class="number">#0</span>, m:<span class="number"> 49152</span></div><div class="line">fatal error: concurrent <span class="keyword">map</span> writes</div><div class="line"></div><div class="line">goroutine<span class="number"> 41</span> [running]:</div><div class="line">main.TestMap.func1()</div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:72</span><span class="number"> +0</span>xcc</div><div class="line">created by main.TestMap in goroutine<span class="number"> 1</span></div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:69</span><span class="number"> +0</span>x4c</div><div class="line"></div><div class="line">goroutine<span class="number"> 1</span> [semacquire]:</div><div class="line">sync.runtime_Semacquire<span class="number">(0</span>x140000021a0?)</div><div class="line">	/usr/local/<span class="keyword">go</span>/src/runtime/sema.<span class="keyword">go</span><span class="number">:62</span><span class="number"> +0</span>x2c</div><div class="line">sync.(*WaitGroup).Wait<span class="number">(0</span>x1400000e1d0)</div><div class="line">	/usr/local/<span class="keyword">go</span>/src/sync/waitgroup.<span class="keyword">go</span><span class="number">:116</span><span class="number"> +0</span>x74</div><div class="line">main.TestMap()</div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:79</span><span class="number"> +0</span>xb8</div><div class="line">main.main()</div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:15</span><span class="number"> +0</span>x2c</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>一个Go大佬群中严肃的讨论了一个问题：Go程序单线程多goroutine访问一个map会遇到并发读写panic么？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[这个限流库两个大bug存在了半年之久，没人发现？]]></title>
    <link href="https://colobu.com/2023/12/05/two-bugs-of-uber-ratelimit/"/>
    <id>https://colobu.com/2023/12/05/two-bugs-of-uber-ratelimit/</id>
    <published>2023-12-05T12:55:38.000Z</published>
    <updated>2023-12-11T05:37:05.070Z</updated>
    <content type="html"><![CDATA[<p>最近我的同事在使用<a href="https://github.com/uber-go/ratelimit" target="_blank" rel="external">uber-go/ratelimit</a>这个限流库的时候，遇到了两个大bug。这两个bug都是在这个库的最新版本(<code>v0.3.0</code>)中存在的,而这个版本从7月初发布都已经过半年了，都没人提bug，难道大家都没遇到过么？</p>
<a id="more"></a>
<p>我先前都是使用<a href="https://github.com/juju/ratelimit" target="_blank" rel="external">juju/ratelimit</a>这个限流库的，不过我不太喜欢这个库的复杂的“构造函数”，后来尝试了<a href="https://github.com/uber-go/ratelimit" target="_blank" rel="external">uber-go/ratelimit</a>这个库后，感觉SDK设计比较简单，而且使用起来也不错，就一直使用了。当时的版本是<code>v0.2.0</code>,而且我也不会设置它的<code>slack</code>参数，所以也相安无事。</p>
<p>最近我同事在做项目的时候，把这个库更新到最新的<code>v0.3.0</code>,发现在发包一段时间后，突然限流不起作用了，发包频率狂飙导致程序panic。<br>很容易通过下面一个单元测试复现这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestLimiter(t *testing.T) {</div><div class="line">	limiter := ratelimit.New<span class="number">(1</span>, ratelimit.Per(time.Second), ratelimit.WithSlack<span class="number">(1</span>))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 25</span>; i++ {</div><div class="line">		<span class="keyword">if</span> i ==<span class="number"> 1</span> {</div><div class="line">			time.Sleep<span class="number">(2</span> * time.Second)</div><div class="line">		}</div><div class="line">		limiter.Take()</div><div class="line"></div><div class="line">		fmt.Println(time.Now().Unix(), i) <span class="comment">// burst</span></div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个单元测试尝试在第二个周期中不调用限流器，让它有机会进入slack判断的逻辑。这个库的slack设计的本意是在rate的基础上留一点余地，不那么严格按照rate进行限流，不过因为<code>v0.3.0</code>代码的问题，导致slack的判断逻辑出现了问题:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (t *atomicInt64Limiter) Take() time.Time {</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		newTimeOfNextPermissionIssue <span class="typename">int64</span></div><div class="line">		now                          <span class="typename">int64</span></div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		now = t.clock.Now().UnixNano()</div><div class="line">		timeOfNextPermissionIssue := atomic.LoadInt64(&t.state)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> {</div><div class="line">		<span class="keyword">case</span> timeOfNextPermissionIssue ==<span class="number"> 0</span> || (t.maxSlack ==<span class="number"> 0</span> && now-timeOfNextPermissionIssue &gt; <span class="typename">int64</span>(t.perRequest)):</div><div class="line">			<span class="comment">// if this is our first call or t.maxSlack == 0 we need to shrink issue time to now</span></div><div class="line">			newTimeOfNextPermissionIssue = now</div><div class="line">		<span class="keyword">case</span> t.maxSlack &gt;<span class="number"> 0</span> && now-timeOfNextPermissionIssue &gt; <span class="typename">int64</span>(t.maxSlack):</div><div class="line">			<span class="comment">// a lot of nanoseconds passed since the last Take call</span></div><div class="line">			<span class="comment">// we will limit max accumulated time to maxSlack</span></div><div class="line">			newTimeOfNextPermissionIssue = now - <span class="typename">int64</span>(t.maxSlack)</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="comment">// calculate the time at which our permission was issued</span></div><div class="line">			newTimeOfNextPermissionIssue = timeOfNextPermissionIssue + <span class="typename">int64</span>(t.perRequest)</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt64(&t.state, timeOfNextPermissionIssue, newTimeOfNextPermissionIssue) {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	sleepDuration := time.Duration(newTimeOfNextPermissionIssue - now)</div><div class="line">	<span class="keyword">if</span> sleepDuration &gt;<span class="number"> 0</span> {</div><div class="line">		t.clock.Sleep(sleepDuration)</div><div class="line">		<span class="keyword">return</span> time.Unix<span class="number">(0</span>, newTimeOfNextPermissionIssue)</div><div class="line">	}</div><div class="line">	<span class="comment">// return now if we don't sleep as atomicLimiter does</span></div><div class="line">	<span class="keyword">return</span> time.Unix<span class="number">(0</span>, now)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦进入<code>case t.maxSlack &gt; 0 &amp;&amp; now-timeOfNextPermissionIssue &gt; int64(t.maxSlack):</code>这个分支，你会发现后续调用<code>Take</code>基本都会进入这个分支，程序不会阻塞，只要调用<code>Take</code>都不会阻塞。可以看到当设置slack&gt;0的时候才会进入这个分支，正好默认slack=10。这个bug也可以推算出来。<br>假设当前进入这个分支，当前时间是now1，那么这次Take就会把<code>newTimeOfNextPermissionIssue</code>设置为 <code>now1-int64(t.maxSlack)</code>。<br>接下来再调用Take,当前时间是now2,now2总是会比now1大一点，至少大几纳秒吧。<br>这个时候我们计算分支的条件<code>now-timeOfNextPermissionIssue &gt; int64(t.maxSlack)</code>，这个条件肯定是成立的，因为<code>now2-(now1-int64(t.maxSlack))</code> = <code>(now2-now1) + int64(t.maxSlack)</code> &gt; <code>int64(t.maxSlack)</code>。<br>导致后续的每次Take都会进入这个分支，不会阻塞，导致程序疯狂发包，最终导致panic。</p>
<p>周末的时候我给这个项目提了一个bug, 它的一个维护者进行了修复，不过这个项目主要开发者已经对这个<code>v0.3.0</code>的实现丧失了信心，因为这个实现已经出现过一次类似的bug,被他回滚后了，后来有被修复才合进来，现在有出现bug了。</p>
<p>不管作者修不修复，你一定要注意，使用这个库的<code>v0.3.0</code>一定小心，有可能踩到这个雷。</p>
<p>这个其中的一个大bug。</p>
<p>其实我们对slack的有无不是那么关心的，那么我们使用<code>ratelimit.WithoutSlack</code>这个选项，把slack设置为0，是不是就没问题了呢？</p>
<p>嗯，是的，不会再出现上面的bug,而且在我的mac笔记本上跑的单元测试也每问题，但是!但是!但是!又出现了另外一个bug。</p>
<p>我们把限流的速率修改为<code>5000</code>,结果在Linux测试机器上跑只能跑到接近<code>2000</code>,远远小于预期，那这还咋限流，流根本打不上去。</p>
<p>我的同事说把<code>ratelimit</code>版本降到<code>v0.2.0</code>,同时不要设置<code>slack=0</code>可以解决这个问题。</p>
<p>这就很奇怪了，经过一番排查，发现问题可能出在Go标准库的<code>time.Sleep</code>上。</p>
<p>我们使用<code>time.Sleep</code> 休眠50微秒的话，在Go 1.16之前，Linux机器上基本上实际会休眠80、90微秒，但是在Go 1.16之后，Linux机器上1毫秒，差距巨大，在Windows机器上，Go 1.16之前是1毫秒，之后是14毫秒，差距也是巨大的。我在苹果的MacPro M1的机器测试，就没有这个问题。</p>
<p>这个bug记录在<a href="https://github.com/golang/go/issues/44343" target="_blank" rel="external">issues#44343</a>, 自2021年2月提出来来，已经快三年了，这个bug还一直没有关闭，问题还一直存在着，看样子这个bug也不是那么容易找到根因和彻底解决。</p>
<p>所以如果你要使用<code>time.Sleep</code>,请记得在Linux环境下，它的精度也就在<strong>1ms</strong>左右。所以<code>ratelimit</code>库如果依赖它做5000的限流，如果不好好设计的话，达不到限流的效果。</p>
<p>总结一下，如果你使用<a href="https://github.com/uber-go/ratelimit" target="_blank" rel="external">uber-go/ratelimit</a>,一定记得：</p>
<ol>
<li>使用较老的版本<code>v0.2.0</code></li>
<li>不要设置<code>slack=0</code>, 默认或者设置一个非零的值</li>
</ol>
<p>其实我从<code>juju/ratelimit</code>切换到<code>uber-go/ratelimit</code>还有一个根本的原因。<code>juju/ratelimit</code>是基于令牌桶的限流，而<code>uber-go/ratelimit</code>基于漏桶的限流，或者说<code>uber-go/ratelimit</code>更像是整形(shaping)，更符合我们使用的场景，我们想匀速的发送数据包，不希望有Burst或者突然的速率变化，我们的场景更看中的是匀速。</p>
<p>当然你也可以使用<a href="https://github.com/juju/ratelimit" target="_blank" rel="external">juju/ratelimit</a>，这是Canonical公司贡献的一个限流库，版权是LGPL 3.0 + 对Go更合适的条款，这也是Canonical公司统一对它们的Go项目的授权。它是一个基于令牌的限流库，其实用起来也可以，不过已经4年没有代码更新了。<br>有一点我觉得不太爽的地方是它初始化就把桶填满了，导致的结果就是可能一开始使用这个桶获取令牌的速度超出你的预期，有可能导致一开始就发包速度很快，然后慢慢的才匀速，这个不是我想要的效果，但是我又每办法修改，所以我fork了这个项目<a href="https://github.com/smallnest/ratelimit" target="_blank" rel="external">smallnest/ratelimit</a>，可以在初始化限流器的时候，可以设置初始的令牌，比如将初始的令牌设置为零。</p>
<p>当前Go官方也提供了一个扩展库<a href="https://pkg.go.dev/golang.org/x/time/rate" target="_blank" rel="external">golang.org/x/time/rate</a>, 功能更强大，强大带来的负面效果就是使用起来比较复杂，复杂带来的效果就是可能带来一些的潜在的错误，不过在认真评估和测试后也是可以使用的。</p>
<p>还有一些关注度不是那么高的第三库，还包括一些使用滑动窗口实现的限流库，还有分布式的限流库，如果你想了解更多，请参考《深入理解Go并发编程》这本书，专门有一章详细介绍限流库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近我的同事在使用<a href="https://github.com/uber-go/ratelimit" target="_blank" rel="external">uber-go/ratelimit</a>这个限流库的时候，遇到了两个大bug。这两个bug都是在这个库的最新版本(<code>v0.3.0</code>)中存在的,而这个版本从7月初发布都已经过半年了，都没人提bug，难道大家都没遇到过么？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2023年 Go 并发库的变化综述]]></title>
    <link href="https://colobu.com/2023/12/03/status-og-so-sync-in-2023/"/>
    <id>https://colobu.com/2023/12/03/status-og-so-sync-in-2023/</id>
    <published>2023-12-03T05:39:09.000Z</published>
    <updated>2023-12-11T05:37:05.070Z</updated>
    <content type="html"><![CDATA[<p>2023年来， Go的并发库又有了一些变化，这篇文章是对这些变换的综述。小细节的变化，比如typo、文档变化等无关大局的变化就不介绍了。</p>
<a id="more"></a>
<h2 id="sync-Map">sync.Map</h2>
<p>Go 1.21.0 中增加了和Once相关的三个函数，便于Once的使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceFunc(f <span class="keyword">func</span>()) <span class="keyword">func</span>()</div><div class="line"><span class="keyword">func</span> OnceValue[T any](f <span class="keyword">func</span>() T) <span class="keyword">func</span>() T</div><div class="line"><span class="keyword">func</span> OnceValues[T1, T2 any](f <span class="keyword">func</span>() (T1, T2)) <span class="keyword">func</span>() (T1, T2)</div></pre></td></tr></table></figure>

<p>这三个函数的功能分别是：</p>
<ul>
<li>OnceFunc：返回一个函数<code>g</code>，多次调用这个函数<code>g</code>，只会执行一次<code>f</code>。 如果<code>f</code>执行时panic, 则后续调用这个函数<code>g</code>不会再执行<code>f</code>,但是每次调用都会panic。</li>
<li>OnceValue：返回一个函数<code>g</code>，多次调用这个函数<code>g</code>，只会执行一次<code>f</code>，函数<code>g</code>返回值类型是T。比上一个<code>g</code>多了一个返回值。panic原理同上。</li>
<li>OnceValues：返回一个函数<code>g</code>，多次调用这个函数<code>g</code>，只会执行一次<code>f</code>，函数<code>g</code>返回值类型是(T1, T2)。比上一个<code>g</code>又多了一个返回值。panic原理同上。</li>
</ul>
<p>当然理论上你还可以增加更多的函数，返回更多的返回值，因为Go没有Tuple类型，所以这里还不能简化函数<code>g</code>的返回值为Tuple类型。反正Go 1.21.0就只增加了这三个函数。</p>
<p>这个有什么好处呢？先前我们使用<code>sync.Once</code>的时候，比如初始化一个线程池，我们需要定义一个线程池的变量，每次访问线程池变量的时候，我需要调用一下<code>sync.Once.Do</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestOnce(t *testing.T) {</div><div class="line">	<span class="keyword">var</span> pool any</div><div class="line">	<span class="keyword">var</span> once sync.Once</div><div class="line">	<span class="keyword">var</span> initFn = <span class="keyword">func</span>() {</div><div class="line">		<span class="comment">// init pool</span></div><div class="line">		pool =<span class="number"> 1</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		once.Do(initFn)</div><div class="line">		t.Log(pool)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果使用<code>OnceValue</code>,就可以简化代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestOnceValue(t *testing.T) {</div><div class="line">	<span class="keyword">var</span> initPool = <span class="keyword">func</span>() any {</div><div class="line">		<span class="keyword">return</span><span class="number"> 1</span></div><div class="line">	}</div><div class="line">	<span class="keyword">var</span> poolGenerator = sync.OnceValue(initPool)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		t.Log(poolGenerator())</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>代码略微简化，获取单例的时候只需调用返回的函数<code>g</code>即可。</p>
<p>所以基本上，这三个函数只是对sync.Once做了封装，更方便使用。</p>
<h2 id="理解copyChecker">理解copyChecker</h2>
<p>我们知道， <code>sync.Cond</code>有两个字段<code>noCopy</code>和<code>checker</code>, <code>noCopy</code>通过<code>go vet</code>工具能够静态编译时检查出来，但是<code>checker</code>是在运行时检查的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	<span class="comment">// L is held while observing or changing the condition</span></div><div class="line">	L Locker</div><div class="line"></div><div class="line">	notify  notifyList</div><div class="line">	checker copyChecker</div><div class="line">}</div></pre></td></tr></table></figure>

<p>先前<code>copyChecker</code>的判断条件如下，虽然简单的三行，但是不容易理解:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *copyChecker) check() {</div><div class="line">	<span class="keyword">if</span> <span class="typename">uintptr</span>(*c) != <span class="typename">uintptr</span>(unsafe.Pointer(c)) &&</div><div class="line">		!atomic.CompareAndSwapUintptr((*<span class="typename">uintptr</span>)(c),<span class="number"> 0</span>, <span class="typename">uintptr</span>(unsafe.Pointer(c))) &&</div><div class="line">		<span class="typename">uintptr</span>(*c) != <span class="typename">uintptr</span>(unsafe.Pointer(c)) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sync.Cond is copied"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在加上了注释，解释了这三行的意义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *copyChecker) check() {</div><div class="line">	<span class="comment">// Check if c has been copied in three steps:</span></div><div class="line">	<span class="comment">// 1. The first comparison is the fast-path. If c has been initialized and not copied, this will return immediately. Otherwise, c is either not initialized, or has been copied.</span></div><div class="line">	<span class="comment">// 2. Ensure c is initialized. If the CAS succeeds, we're done. If it fails, c was either initialized concurrently and we simply lost the race, or c has been copied.</span></div><div class="line">	<span class="comment">// 3. Do step 1 again. Now that c is definitely initialized, if this fails, c was copied.</span></div><div class="line">	<span class="keyword">if</span> <span class="typename">uintptr</span>(*c) != <span class="typename">uintptr</span>(unsafe.Pointer(c)) &&</div><div class="line">		!atomic.CompareAndSwapUintptr((*<span class="typename">uintptr</span>)(c),<span class="number"> 0</span>, <span class="typename">uintptr</span>(unsafe.Pointer(c))) &&</div><div class="line">		<span class="typename">uintptr</span>(*c) != <span class="typename">uintptr</span>(unsafe.Pointer(c)) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sync.Cond is copied"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>主要逻辑在以下3步:</p>
<ul>
<li>第一步是一个快速检查,直接比较 <code>c</code> 指针和 <code>c</code> 本身的指针,如果不相等则表示已被复制。这是最快的检查路径。</li>
<li>第二步确保 <code>c</code> 已经被初始化。使用 CAS (CompareAndSwap)来初始化。如果CAS失败,说明<code>c</code> 已经在其他goroutine初始化,或者被复制了。</li>
<li>第三步再次执行第一步的检查。因为这时我们清楚的知道 <code>c</code> 已经初始化了,所以如果检查失败,就可以确认 <code>c</code> 被复制了。</li>
</ul>
<p>整个逻辑就是使用 CAS 配合两次指针检查,来确保判断的正确性。</p>
<p>总的来说，第一步快速检查是性能优化。第二步使用 CAS 确保初始化。第三步再次检查来确保判断。</p>
<h2 id="sync-Map_的一处优化">sync.Map 的一处优化</h2>
<p>先前， <code>sync.Map</code> 的 <code>Range</code> 函数的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Range(f <span class="keyword">func</span>(key, value any) <span class="typename">bool</span>) {</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> read.amended {</div><div class="line">			read = readOnly{m: m.dirty}</div><div class="line">			m.read.Store(&read)</div><div class="line">			m.dirty = <span class="constant">nil</span></div><div class="line">			m.misses =<span class="number"> 0</span></div><div class="line">	}</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中有一段代码：<code>m.read.Store(&amp;read)</code>,会导致<code>read</code>逃逸到堆上，通过下面的一个小技巧，避免了<code>read</code>的逃逸（通过一个新的变量）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Range(f <span class="keyword">func</span>(key, value any) <span class="typename">bool</span>) {</div><div class="line">    ...</div><div class="line">	<span class="keyword">if</span> read.amended {</div><div class="line">		read = readOnly{m: m.dirty}</div><div class="line">		copyRead := read</div><div class="line">		m.read.Store(&copyRead)</div><div class="line">		m.dirty = <span class="constant">nil</span></div><div class="line">		m.misses =<span class="number"> 0</span></div><div class="line">	}</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/issues/62404" target="_blank" rel="external">issue #62404</a>对这个问题进行了分析。</p>
<h2 id="sync-Once的实现中done使用atomic-Uint32替换">sync.Once的实现中done使用atomic.Uint32替换</h2>
<p>先前<code>sync.Once</code>的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> {</div><div class="line">	done <span class="typename">uint32</span></div><div class="line">	m    Mutex</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中字段<code>done</code>是一个<code>uint32</code>类型，用来表示<code>Once</code>是否已经执行过了。这个字段的类型是<code>uint32</code>，而不是<code>bool</code>，是因为<code>uint32</code>类型可以使用<code>atomic</code>包的原子操作，而<code>bool</code>类型不能。</p>
<p>现在<code>sync.Once</code>的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> {</div><div class="line">	done atomic.Uint32</div><div class="line">	m    Mutex</div><div class="line">}</div></pre></td></tr></table></figure>

<p>自从go 1.19提供了对基本类型的原子封装，Go标准库大量代码都被<code>atomic.XXX</code>类型锁替换。</p>
<p>我个人认为，目前这个修改相对于先前的实现，性能上在某些情况下可能会有性能的下降，我会专门写一篇文章进行探讨。</p>
<p>除了<code>sync.Once</code>，还有一批类型使用了<code>atomic.XXX</code>类型替换原来的使用方法，有必要可以进行替换么？</p>
<h2 id="sync-OnceFunc_初始实现的优化">sync.OnceFunc 初始实现的优化</h2>
<p>初始的<code>sync.OnceFunc</code>的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceFunc(f <span class="keyword">func</span>()) <span class="keyword">func</span>() {</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		once  Once</div><div class="line">		valid <span class="typename">bool</span></div><div class="line">		p     any</div><div class="line">	)</div><div class="line">	g := <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			p = <span class="built_in">recover</span>()</div><div class="line">			<span class="keyword">if</span> !valid {</div><div class="line">				<span class="built_in">panic</span>(p)</div><div class="line">			}</div><div class="line">		}()</div><div class="line">		f()</div><div class="line">		valid = <span class="constant">true</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>() {</div><div class="line">		once.Do(g)</div><div class="line">		<span class="keyword">if</span> !valid {</div><div class="line">			<span class="built_in">panic</span>(p)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>仔细看这段代码，你会发现，传递给<code>OnceFunc/OnceValue/OnceValues</code>的函数<code>f</code>，即使执行完一次，只要返回的<code>g</code>函数好活着没有被垃圾回收，这个<code>f</code>就一直存活。<br>这是没必要的，因为<code>f</code>只需要执行一次，执行完就可以被垃圾回收了。所以，这里可以对<code>f</code>进行一次优化，让<code>f</code>执行完就设置为<code>nil</code>，这样就可以被垃圾回收了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceFunc(f <span class="keyword">func</span>()) <span class="keyword">func</span>() {</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		once  Once</div><div class="line">		valid <span class="typename">bool</span></div><div class="line">		p     any</div><div class="line">	)</div><div class="line">	<span class="comment">// Construct the inner closure just once to reduce costs on the fast path.</span></div><div class="line">	g := <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			p = <span class="built_in">recover</span>()</div><div class="line">			<span class="keyword">if</span> !valid {</div><div class="line">				<span class="comment">// Re-panic immediately so on the first call the user gets a</span></div><div class="line">				<span class="comment">// complete stack trace into f.</span></div><div class="line">				<span class="built_in">panic</span>(p)</div><div class="line">			}</div><div class="line">		}()</div><div class="line">		f()</div><div class="line">		f = <span class="constant">nil</span>      <span class="comment">// Do not keep f alive after invoking it.</span></div><div class="line">		valid = <span class="constant">true</span> <span class="comment">// Set only if f does not panic.</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>() {</div><div class="line">		once.Do(g)</div><div class="line">		<span class="keyword">if</span> !valid {</div><div class="line">			<span class="built_in">panic</span>(p)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="context">context</h2>
<p>我们知道，在 Go 1.20中， 新增加了一个<code>WithCancelCause</code>方法(<code>func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)</code>)，我们在<code>cancel</code>的时候可以把cancel的原因传递给<code>WithCancelCause</code>产生的Context，这样可以通过<code>context.Cause</code>方法获取到<code>cancel</code>的原因。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ctx, cancel := context.WithCancelCause(parent)</div><div class="line">cancel(myError)</div><div class="line">ctx.Err() <span class="comment">// 返回 context.Canceled</span></div><div class="line">context.Cause(ctx) <span class="comment">// 返回 myError</span></div></pre></td></tr></table></figure>

<p>当然这个实现只进行了一半，因为超时相关的Context也需要增加这个功能，所以在Go 1.21.0中又新增了两个相关的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)</div><div class="line"><span class="keyword">func</span> WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)</div></pre></td></tr></table></figure>

<p>这两个和<code>WithCancelCause</code>还不太一样，不是利用返回的cancel函数传递原因，而是直接在函数参数中传递原因。</p>
<p>Go 1.21.0 还增加了一个<code>AfterFunc</code>函数，这个函数和<code>time.AfterFunc</code>类似，但是返回的是一个<code>Context</code>，这个<code>Context</code>在超时后会自动取消，这个函数的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> AfterFunc(ctx Context, f <span class="keyword">func</span>()) (stop <span class="keyword">func</span>() <span class="typename">bool</span>)</div></pre></td></tr></table></figure>

<p>指定的<code>Context</code>在在done(超时或者取消)，如果context已经done,那么<code>f</code>立即被调用。<br>返回的<code>stop</code>函数用来停止<code>f</code>的调用，如果<code>stop</code>被调用并且返回true，<code>f</code>不会被调用。</p>
<p>这是一个辅助函数，但是难以理解，估计这个函数不会被广泛的使用。</p>
<p>其他一些小性能的优化比如<code>type emptyCtx int</code>替换成<code>type emptyCtx struct{}</code>等等就不用提了。</p>
<p>增加了一个<code>func WithoutCancel(parent Context) Context</code>, 当parent被取消时，不会波及到这个函数返回的Context。</p>
<h2 id="Coroutines_for_Go">Coroutines for Go</h2>
<p>在今年7月，Russ Coxx写了一篇巨论： <a href="https://research.swtch.com/coro" target="_blank" rel="external">Coroutines for Go</a>。</p>
<p>个人不看好在Go标准库实现这个东西，我感觉Rob Pike也不会同意，但是这个东西社区如果去实现一个库，我觉得还是有可能的，返回如果大家不看好，社区的库自然会消亡。</p>
<p>否则，渐渐的Go迷失了它的初心: 简单好用。</p>
<p>社区的一些协程库：</p>
<ul>
<li><a href="https://github.com/stealthrocket/coroutine" target="_blank" rel="external">coroutine</a></li>
<li><a href="https://github.com/solarlune/routine" target="_blank" rel="external">routine</a></li>
<li><a href="https://github.com/SolarLune/gocoro" target="_blank" rel="external">gocoro</a></li>
</ul>
<p>你在go.dev还能搜到一些，这里就不赘述了。</p>
<h2 id="golang-org/x/sync_没有明显改动">golang.org/x/sync 没有明显改动</h2>
<p><code>errgroup</code>支持使用<code>withCancelCause</code>设置cause。<br><code>singleflight</code>的panicError增加Unwrap方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2023年来， Go的并发库又有了一些变化，这篇文章是对这些变换的综述。小细节的变化，比如typo、文档变化等无关大局的变化就不介绍了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TOP 20 Go最佳实践]]></title>
    <link href="https://colobu.com/2023/11/17/golang-quick-reference-top-20-best-coding-practices/"/>
    <id>https://colobu.com/2023/11/17/golang-quick-reference-top-20-best-coding-practices/</id>
    <published>2023-11-17T00:05:39.000Z</published>
    <updated>2023-12-11T05:37:05.060Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://medium.com/@golangda/golang-quick-reference-top-20-best-coding-practices-c0cea6a43f20" target="_blank" rel="external">Golang Best Practices (Top 20)</a></p>
<a id="more"></a>
<h2 id="简介">简介</h2>
<p>在本教程中，我们将探讨Golang中的前20个最佳编码实践。这将帮助你编写有效的Go代码。</p>
<h2 id="#20:_使用适当的缩进">#20: 使用适当的缩进</h2>
<p>良好的缩进使你的代码易读。一致地使用制表符或空格（最好是制表符），并遵循Go的缩进标准。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">        fmt.Println(<span class="string">"Hello, World!"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行<code>gofmt</code>以根据Go标准自动格式化（缩进）你的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gofmt -w your_file.go</div></pre></td></tr></table></figure>

<h2 id="#19:_正确导入包">#19: 正确导入包</h2>
<p>仅导入你需要的包，并格式化导入部分以将标准库包、第三方包和你自己的包分组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math/rand"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<h2 id="#18:_使用描述性的变量和函数名">#18: 使用描述性的变量和函数名</h2>
<ol>
<li>有意义的名称：使用传达变量目的的名称。</li>
<li>驼峰命名法：以小写字母开头，并在名称中的每个后续单词的首字母大写。</li>
<li>短名称：对于生命周期短、范围小的变量，可以使用简洁的名称。</li>
<li>不要使用缩写：避免使用难以理解的缩写和首字母缩写，而使用描述性名称。</li>
<li>一致性：在整个代码库中保持命名一致性。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 使用有意义的名称声明变量</span></div><div class="line">    userName := <span class="string">"John Doe"</span>   <span class="comment">// 驼峰命名法：以小写字母开头，并在名称中的每个后续单词的首字母大写。</span></div><div class="line">    itemCount :=<span class="number"> 10</span>         <span class="comment">// 短名称：短小而简洁，适用于生命周期短、范围小的变量。</span></div><div class="line">    isReady := <span class="constant">true</span>         <span class="comment">// 不使用缩写：避免使用缩写。</span></div><div class="line"></div><div class="line">    <span class="comment">// 显示变量值</span></div><div class="line">    fmt.Println(<span class="string">"User Name:"</span>, userName)</div><div class="line">    fmt.Println(<span class="string">"Item Count:"</span>, itemCount)</div><div class="line">    fmt.Println(<span class="string">"Is Ready:"</span>, isReady)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 对于包级别的变量使用mixedCase</span></div><div class="line"><span class="keyword">var</span> exportedVariable <span class="typename">int</span> =<span class="number"> 42</span></div><div class="line"></div><div class="line"><span class="comment">// 函数名应该具有描述性</span></div><div class="line"><span class="keyword">func</span> calculateSumOfNumbers(a, b <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">}</div></pre></td></tr></table></figure>

<p>// 保持代码库中的命名一致性。</p>
<h2 id="#17:_限制行长度">#17: 限制行长度</h2>
<p>尽可能保持代码行长度在80个字符以下，以提高可读性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    result := calculateHypotenuse<span class="number">(3</span>,<span class="number"> 4</span>)</div><div class="line">    fmt.Println(<span class="string">"Hypotenuse:"</span>, result)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> calculateHypotenuse(a, b <span class="typename">float64</span>) <span class="typename">float64</span> {</div><div class="line">    <span class="keyword">return</span> math.Sqrt(a*a + b*b)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#16:_使用常量代替魔术值">#16: 使用常量代替魔术值</h2>
<p>避免在代码中使用魔术值，即散布在代码中的硬编码数字或字符串，缺乏上下文，使其难以理解目的。为其定义常量，以使代码更易维护。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 定义最大重试次数的常量</span></div><div class="line">    MaxRetries =<span class="number"> 3</span></div><div class="line"></div><div class="line">    <span class="comment">// 定义默认超时时间（秒）的常量</span></div><div class="line">    DefaultTimeout =<span class="number"> 30</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    retries :=<span class="number"> 0</span></div><div class="line">    timeout := DefaultTimeout</div><div class="line"></div><div class="line">    <span class="keyword">for</span> retries &lt; MaxRetries {</div><div class="line">        fmt.Printf(<span class="string">"Attempting operation (Retry %d) with timeout: %d seconds\n"</span>, retries<span class="number">+1</span>, timeout)</div><div class="line">        </div><div class="line">        <span class="comment">// ... 在此处添加你的代码逻辑 ...</span></div><div class="line"></div><div class="line">        retries++</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#15:_错误处理">#15: 错误处理</h2>
<p>Go鼓励开发者显式处理错误，有以下原因：</p>
<ul>
<li><strong>安全性</strong>：错误处理确保意外问题不会导致程序突然崩溃。</li>
<li><strong>清晰性</strong>：显式的错误处理使代码更易读，有助于确定错误可能发生的位置。</li>
<li><strong>调试</strong>：处理错误为调试和故障排除提供了有价值的信息。</li>
</ul>
<p>让我们创建一个简单的程序，它读取一个文件并正确处理错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 打开一个文件</span></div><div class="line">    file, err := os.Open(<span class="string">"example.txt"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="comment">// 处理错误</span></div><div class="line">        fmt.Println(<span class="string">"Error opening the file:"</span>, err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    <span class="keyword">defer</span> file.Close() <span class="comment">// 当完成时关闭文件</span></div><div class="line"></div><div class="line">    <span class="comment">// 从文件中读取</span></div><div class="line">    buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line">    _, err = file.Read(buffer)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="comment">// 处理错误</span></div><div class="line">        fmt.Println(<span class="string">"Error reading the file:"</span>, err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印文件内容</span></div><div class="line">    fmt.Println(<span class="string">"File content:"</span>, <span class="typename">string</span>(buffer))</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#14:_避免使用全局变量">#14: 避免使用全局变量</h2>
<p>最小化使用全局变量。全局变量可能导致不可预测的行为，使调试变得困难，并阻碍代码重用。它们还可能在程序的不同部分之间引入不必要的依赖关系。相反，通过函数参数和返回值传递数据。</p>
<p>让我们编写一个简单的Go程序来说明避免使用全局变量的概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 在main函数中声明并初始化变量</span></div><div class="line">    message := <span class="string">"Hello, Go!"</span></div><div class="line"></div><div class="line">    <span class="comment">// 调用使用局部变量的函数</span></div><div class="line">    printMessage(message)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// printMessage是一个带参数的函数</span></div><div class="line"><span class="keyword">func</span> printMessage(msg <span class="typename">string</span>) {</div><div class="line">    fmt.Println(msg)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#13:_使用结构体处理复杂数据">#13: 使用结构体处理复杂数据</h2>
<p>使用结构体将相关的数据字段和方法组合在一起。它们允许你将相关变量组合在一起，使你的代码更有组织性和可读性。</p>
<p>以下是一个完整的演示在Go中使用结构体的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义一个名为Person的结构体，表示一个人的信息。</span></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</div><div class="line">    FirstName <span class="typename">string</span> <span class="comment">// 人的名字</span></div><div class="line">    LastName  <span class="typename">string</span> <span class="comment">// 人的姓氏</span></div><div class="line">    Age       <span class="typename">int</span>    <span class="comment">// 人的年龄</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 创建一个Person结构体的实例并初始化其字段。</span></div><div class="line">    person := Person{</div><div class="line">        FirstName: <span class="string">"John"</span>,</div><div class="line">        LastName:  <span class="string">"Doe"</span>,</div><div class="line">        Age:      <span class="number"> 30</span>,</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 访问并打印结构体字段的值。</span></div><div class="line">    fmt.Println(<span class="string">"First Name:"</span>, person.FirstName) <span class="comment">// 打印名字</span></div><div class="line">    fmt.Println(<span class="string">"Last Name:"</span>, person.LastName)   <span class="comment">// 打印姓氏</span></div><div class="line">    fmt.Println(<span class="string">"Age:"</span>, person.Age)             <span class="comment">// 打印年龄</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#12:_为你的代码添加注释">#12: 为你的代码添加注释</h2>
<p>添加注释以解释代码的功能，特别是对于复杂或不明显的部分。</p>
<p><strong>单行注释</strong><br>单行注释以<code>//</code>开头。用于解释特定行的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 这是一条单行注释</span></div><div class="line">    fmt.Println(<span class="string">"Hello, World!"</span>) <span class="comment">// 打印问候语</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>多行注释</strong><br>多行注释在<code>/* */</code>中。用于较长的解释或跨多行的注释。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">/*</span></div><div class="line">        这是一条多行注释。</div><div class="line">        它可以跨越多行。</div><div class="line">    */</div><div class="line">    fmt.Println(<span class="string">"Hello, World!"</span>) <span class="comment">// 打印问候语</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>函数注释</strong><br>为函数添加注释，明确其用途、参数和返回值。使用 <code>godoc</code> 风格的函数注释可以使代码更易读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// greetUser 通过用户名向用户表示问候。</span></div><div class="line"><span class="comment">// 参数：</span></div><div class="line"><span class="comment">//   name (string): 要问候的用户的名字。</span></div><div class="line"><span class="comment">// 返回：</span></div><div class="line"><span class="comment">//   string: 问候消息。</span></div><div class="line"><span class="keyword">func</span> greetUser(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">"!"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    userName := <span class="string">"Alice"</span></div><div class="line">    greeting := greetUser(userName)</div><div class="line">    fmt.Println(greeting)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>包注释</strong><br>在 Go 文件的顶部添加注释，描述包的用途。使用相同的 godoc 风格。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// 这是我们 Go 程序的主要包。</span></div><div class="line"><span class="comment">// 它包含入口点（main）函数。</span></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#11:_使用_goroutines_进行并发操作">#11: 使用 goroutines 进行并发操作</h2>
<p>高效地利用 <code>goroutine</code> 进行并发操作。<code>goroutine</code> 是 Go 中轻量级的、并发的执行线程。它们使您能够在没有传统线程开销的情况下并发运行函数。这使您能够编写高度并发和高效的程序。</p>
<p>让我们通过一个简单的例子来演示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 并发运行的函数</span></div><div class="line"><span class="keyword">func</span> printNumbers() {</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 1</span>; i &lt;=<span class="number"> 5</span>; i++ {</div><div class="line">        fmt.Printf(<span class="string">"%d "</span>, i)</div><div class="line">        time.Sleep<span class="number">(100</span> * time.Millisecond)</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 运行在主 goroutine 中的函数</span></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 启动 goroutine</span></div><div class="line">    <span class="keyword">go</span> printNumbers()</div><div class="line"></div><div class="line">    <span class="comment">// 继续执行主函数</span></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 2</span>; i++ {</div><div class="line">        fmt.Println(<span class="string">"Hello"</span>)</div><div class="line">        time.Sleep<span class="number">(200</span> * time.Millisecond)</div><div class="line">    }</div><div class="line">    <span class="comment">// 在退出之前确保 goroutine 完成</span></div><div class="line">    time.Sleep<span class="number">(1</span> * time.Second)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#10:_使用_Recover_处理_panic">#10: 使用 Recover 处理 panic</h2>
<p>使用 <code>recover</code> 函数优雅的处理 <code>panic</code>，并防止程序崩溃。在 Go 中，<code>panic</code> 是意外的运行时错误，可能导致程序崩溃。然而，Go 提供了一种称为 <code>recover</code> 的机制来优雅的处理 <code>panic</code>。</p>
<p>让我们通过一个简单的例子来演示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// 可能会 panic 的函数</span></div><div class="line"><span class="keyword">func</span> riskyOperation() {</div><div class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="constant">nil</span> {</div><div class="line">            <span class="comment">// 从 panic 中恢复并 gracefully 处理它</span></div><div class="line">            fmt.Println(<span class="string">"Recovered from panic:"</span>, r)</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="comment">// 模拟 panic 条件</span></div><div class="line">    <span class="built_in">panic</span>(<span class="string">"Oops! Something went wrong."</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Println(<span class="string">"Start of the program."</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 在一个能从 panic 中恢复的函数中调用 riskyOperation</span></div><div class="line">    riskyOperation()</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"End of the program."</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#9:_避免使用_init_函数">#9: 避免使用 init 函数</h2>
<p>避免使用 <code>init</code> 函数，除非必要，因为它可能使代码更难理解和维护。</p>
<p>一个更好的方法是将初始化逻辑移到常规函数中，您可以从主函数中显式调用它，通常更易于控制，增强代码的可读性，并简化测试。</p>
<p>以下是演示避免使用 <code>init</code> 函数的简单 Go 程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// InitializeConfig 初始化配置。</span></div><div class="line"><span class="keyword">func</span> InitializeConfig() {</div><div class="line">    <span class="comment">// 在这里初始化配置参数。</span></div><div class="line">    fmt.Println(<span class="string">"Initializing configuration..."</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// InitializeDatabase 初始化数据库连接。</span></div><div class="line"><span class="keyword">func</span> InitializeDatabase() {</div><div class="line">    <span class="comment">// 在这里初始化数据库连接。</span></div><div class="line">    fmt.Println(<span class="string">"Initializing database..."</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 显式调用初始化函数。</span></div><div class="line">    InitializeConfig()</div><div class="line">    InitializeDatabase()</div><div class="line"></div><div class="line">    <span class="comment">// 主程序逻辑在这里。</span></div><div class="line">    fmt.Println(<span class="string">"Main program logic..."</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#8:_使用_defer_进行资源清理">#8: 使用 defer 进行资源清理</h2>
<p><code>defer</code> 允许你延迟执行函数，直到包围它的函数返回。它通常用于执行诸如关闭文件、解锁互斥锁或释放其他资源等任务。</p>
<p>这确保即使在出现错误的情况下，清理操作也会被执行。</p>
<p>让我们创建一个简单的程序，从文件中读取数据，并使用 defer 确保文件在发生任何错误时都能正确关闭：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 打开文件（将 "example.txt" 替换为你的文件名）</span></div><div class="line">	file, err := os.Open(<span class="string">"example.txt"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error opening the file:"</span>, err)</div><div class="line">		<span class="keyword">return</span> <span class="comment">// 出现错误时退出程序</span></div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> file.Close() <span class="comment">// 确保函数退出时文件被关闭</span></div><div class="line"></div><div class="line">	<span class="comment">// 读取并打印文件的内容</span></div><div class="line">	data := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 100</span>)</div><div class="line">	n, err := file.Read(data)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error reading the file:"</span>, err)</div><div class="line">		<span class="keyword">return</span> <span class="comment">// 出现错误时退出程序</span></div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"Read %d bytes: %s\n"</span>, n, data[:n])</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#7:_推荐使用复合字面值而非构造函数">#7: 推荐使用复合字面值而非构造函数</h2>
<p>使用复合字面值来创建结构体的实例，而不是使用构造函数。</p>
<p><strong>为什么使用复合字面值？</strong><br>复合字面值提供了几个优势：</p>
<ul>
<li>简洁性</li>
<li>可读性</li>
<li>灵活性</li>
</ul>
<p>让我们通过一个简单的例子来演示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义一个表示个人信息的结构体类型</span></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</div><div class="line">	FirstName <span class="typename">string</span> <span class="comment">// 个人的名字</span></div><div class="line">	LastName  <span class="typename">string</span> <span class="comment">// 个人的姓氏</span></div><div class="line">	Age       <span class="typename">int</span>    <span class="comment">// 个人的年龄</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 使用复合字面值创建一个 Person 实例</span></div><div class="line">	person := Person{</div><div class="line">		FirstName: <span class="string">"John"</span>, <span class="comment">// 初始化 FirstName 字段</span></div><div class="line">		LastName:  <span class="string">"Doe"</span>,  <span class="comment">// 初始化 LastName 字段</span></div><div class="line">		Age:      <span class="number"> 30</span>,     <span class="comment">// 初始化 Age 字段</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 打印个人信息</span></div><div class="line">	fmt.Println(<span class="string">"个人详情："</span>)</div><div class="line">	fmt.Println(<span class="string">"名字："</span>, person.FirstName) <span class="comment">// 访问并打印名字字段</span></div><div class="line">	fmt.Println(<span class="string">"姓氏："</span>, person.LastName)  <span class="comment">// 访问并打印姓氏字段</span></div><div class="line">	fmt.Println(<span class="string">"年龄："</span>, person.Age)        <span class="comment">// 访问并打印年龄字段</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#6:_减少函数参数">#6: 减少函数参数</h2>
<p>在Go中，编写干净高效的代码是至关重要的。其中一种方法是减少函数参数的数量，这可以导致更易维护和可读的代码。</p>
<p>让我们通过一个简单的例子来探讨这个概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// Option 结构体用于保存配置选项</span></div><div class="line"><span class="keyword">type</span> Option <span class="keyword">struct</span> {</div><div class="line">    Port    <span class="typename">int</span></div><div class="line">    Timeout <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ServerConfig 是一个接受 Option 结构体的函数</span></div><div class="line"><span class="keyword">func</span> ServerConfig(opt Option) {</div><div class="line">    fmt.Printf(<span class="string">"服务器配置 - 端口：%d，超时：%d 秒\n"</span>, opt.Port, opt.Timeout)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 创建一个具有默认值的 Option 结构体</span></div><div class="line">    defaultConfig := Option{</div><div class="line">        Port:   <span class="number"> 8080</span>,</div><div class="line">        Timeout:<span class="number"> 30</span>,</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 使用默认选项配置服务器</span></div><div class="line">    ServerConfig(defaultConfig)</div><div class="line"></div><div class="line">    <span class="comment">// 使用新的 Option 结构体修改端口</span></div><div class="line">    customConfig := Option{</div><div class="line">        Port:<span class="number"> 9090</span>,</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 使用自定义端口值和默认超时配置服务器</span></div><div class="line">    ServerConfig(customConfig)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个Option结构体，用于保存服务器的配置参数。与将多个参数传递给<code>ServerConfig</code>函数不同，我们使用一个单独的<code>Option</code>结构体，使得代码更易于维护和扩展。这种方法在处理具有大量配置参数的函数时特别有用。</p>
<h2 id="#5:_使用显式返回值而不是具名返回值以提高清晰度">#5: 使用显式返回值而不是具名返回值以提高清晰度</h2>
<p>在Go中，通常使用具名返回值，但它们有时会使代码不够清晰，尤其是在较大的代码库中。</p>
<p>让我们通过一个简单的例子来看看它们之间的区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// namedReturn 演示具名返回值。</span></div><div class="line"><span class="keyword">func</span> namedReturn(x, y <span class="typename">int</span>) (result <span class="typename">int</span>) {</div><div class="line">    result = x + y</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// explicitReturn 演示显式返回值。</span></div><div class="line"><span class="keyword">func</span> explicitReturn(x, y <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 具名返回值</span></div><div class="line">    sum1 := namedReturn<span class="number">(3</span>,<span class="number"> 5</span>)</div><div class="line">    fmt.Println(<span class="string">"具名返回值:"</span>, sum1)</div><div class="line"></div><div class="line">    <span class="comment">// 显式返回值</span></div><div class="line">    sum2 := explicitReturn<span class="number">(3</span>,<span class="number"> 5</span>)</div><div class="line">    fmt.Println(<span class="string">"显式返回值:"</span>, sum2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的示例程序中，我们有两个函数，<code>namedReturn</code> 和 <code>explicitReturn</code>。它们的区别如下：</p>
<p><code>namedReturn</code> 使用了具名返回值 <code>result</code>。虽然清楚函数返回的是什么，但在更复杂的函数中可能不够直观。<br><code>explicitReturn</code> 直接返回结果。这更简单、更明确。</p>
<h2 id="#4:_保持函数复杂性最小化">#4: 保持函数复杂性最小化</h2>
<p>函数复杂性指的是函数代码中的错综复杂度、嵌套和分支程度。保持函数复杂性的低水平使得你的代码更易读、更易维护，且更不容易出错。</p>
<p>让我们通过一个简单的例子来探讨这个概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// CalculateSum 返回两个数字的和。</span></div><div class="line"><span class="keyword">func</span> CalculateSum(a, b <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// PrintSum 打印两个数字的和。</span></div><div class="line"><span class="keyword">func</span> PrintSum() {</div><div class="line">	x :=<span class="number"> 5</span></div><div class="line">	y :=<span class="number"> 3</span></div><div class="line">	sum := CalculateSum(x, y)</div><div class="line">	fmt.Printf(<span class="string">"%d 和 %d 的和是 %d\n"</span>, x, y, sum)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 调用 PrintSum 函数来演示最小函数复杂性。</span></div><div class="line">	PrintSum()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的示例程序中：</p>
<ol>
<li>我们定义了两个函数，<code>CalculateSum</code> 和 <code>PrintSum</code>，各自负责特定的任务。</li>
<li><code>CalculateSum</code> 是一个简单的函数，用于计算两个数字的和。</li>
<li><code>PrintSum</code> 利用 <code>CalculateSum</code> 计算并打印出 <strong>5</strong> 和 <strong>3</strong> 的和。</li>
<li>通过保持函数简洁并专注于单一任务，我们保持了较低的函数复杂性，提高了代码的可读性和可维护性。</li>
</ol>
<h2 id="#3:_避免变量的屏蔽">#3: 避免变量的屏蔽</h2>
<p>变量的屏蔽(<code>shadowing</code>)发生在在更小的作用域内声明了一个同名的新变量，这可能导致意外的行为。它隐藏了同名的外部变量，在该作用域内无法访问。避免在嵌套作用域内屏蔽变量，以防止混淆。</p>
<p>让我们看一个示例程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 声明并初始化一个外部变量 'x'，其值为 10。</span></div><div class="line">    x :=<span class="number"> 10</span></div><div class="line">    fmt.Println(<span class="string">"外部 x:"</span>, x)</div><div class="line"></div><div class="line">    <span class="comment">// 进入一个内部作用域，其中新变量 'x' 屏蔽了外部的 'x'。</span></div><div class="line">    <span class="keyword">if</span> <span class="constant">true</span> {</div><div class="line">        x :=<span class="number"> 5</span> <span class="comment">// 屏蔽发生在这里</span></div><div class="line">        fmt.Println(<span class="string">"内部 x:"</span>, x) <span class="comment">// 打印内部的 'x'，其值为 5。</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 外部的 'x' 保持不变且仍然可访问。</span></div><div class="line">    fmt.Println(<span class="string">"内部作用域后的外部 x:"</span>, x) <span class="comment">// 打印外部的 'x'，其值为 10。</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="#2:_使用接口进行抽象">#2: 使用接口进行抽象</h2>
<p><strong>抽象</strong><br>抽象是 Go 语言中的一个基本概念，允许我们定义行为而不指定实现细节。</p>
<p><strong>接口</strong><br>在 Go 中，接口是一组方法签名。</p>
<blockquote>
<p>在泛型功能增加后，接口的是一组方法签名和类型约束，也就是一组类型的集合。不过这里介绍的还是原始的接口功能，所以上面的描述也每问题。</p>
</blockquote>
<p>任何实现接口所有方法的类型都会隐式满足该接口。</p>
<p>这使我们能够编写能够与不同类型一起工作的代码，只要它们遵循相同的接口。</p>
<p>下面是 Go 中的一个示例程序，演示了使用接口进行抽象的概念：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义 Shape 接口</span></div><div class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> {</div><div class="line">    Area() <span class="typename">float64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 矩形结构体</span></div><div class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> {</div><div class="line">    Width  <span class="typename">float64</span></div><div class="line">    Height <span class="typename">float64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 圆形结构体</span></div><div class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> {</div><div class="line">    Radius <span class="typename">float64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 为矩形实现 Area 方法</span></div><div class="line"><span class="keyword">func</span> (r Rectangle) Area() <span class="typename">float64</span> {</div><div class="line">    <span class="keyword">return</span> r.Width * r.Height</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 为圆形实现 Area 方法</span></div><div class="line"><span class="keyword">func</span> (c Circle) Area() <span class="typename">float64</span> {</div><div class="line">    <span class="keyword">return</span> math.Pi * c.Radius * c.Radius</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 打印任意 Shape 的面积的函数</span></div><div class="line"><span class="keyword">func</span> PrintArea(s Shape) {</div><div class="line">    fmt.Printf(<span class="string">"面积: %.2f\n"</span>, s.Area())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    rectangle := Rectangle{Width:<span class="number"> 5</span>, Height:<span class="number"> 3</span>}</div><div class="line">    circle := Circle{Radius:<span class="number"> 2.5</span>}</div><div class="line"></div><div class="line">    <span class="comment">// 在矩形和圆形上调用 PrintArea，它们都实现了 Shape 接口</span></div><div class="line">    PrintArea(rectangle) <span class="comment">// 打印矩形的面积</span></div><div class="line">    PrintArea(circle)    <span class="comment">// 打印圆形的面积</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个单一的程序中，我们定义了 Shape 接口，创建了两个结构体 <code>Rectangle</code> 和 <code>Circle</code>，它们都实现了 <code>Area()</code> 方法，并使用 <code>PrintArea</code> 函数来打印满足 <code>Shape</code> 接口的任何形状的面积。</p>
<p>这演示了在 Go 中如何使用接口进行抽象，以使用一个共同的接口处理不同类型。</p>
<h2 id="#1:_避免混淆库包和可执行文件">#1: 避免混淆库包和可执行文件</h2>
<p>在 Go 语言中，保持库包和可执行文件之间清晰的分离是至关重要的，以确保代码清晰和可维护。</p>
<p>以下是演示库和可执行文件分离的示例项目结构：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myproject/</div><div class="line">    ├── main.go</div><div class="line">    ├── myutils/</div><div class="line">       └── myutils.go</div></pre></td></tr></table></figure>

<p>myutils/myutils.go:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> myutils</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// 导出的打印消息的函数</span></div><div class="line"><span class="keyword">func</span> PrintMessage(message <span class="typename">string</span>) {</div><div class="line">    fmt.Println(<span class="string">"来自 myutils 的消息:"</span>, message)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>main.go:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"myproject/myutils"</span> <span class="comment">// 导入自定义包</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    message := <span class="string">"你好，Golang！"</span></div><div class="line"></div><div class="line">    <span class="comment">// 调用自定义包 myutils 中的导出函数</span></div><div class="line">    myutils.PrintMessage(message)</div><div class="line"></div><div class="line">    <span class="comment">// 演示主程序逻辑</span></div><div class="line">    fmt.Println(<span class="string">"来自 main 的消息:"</span>, message)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的示例中，我们有两个独立的文件：<code>myutils.go</code> 和 <code>main.go</code>。<br><code>myutils.go</code> 定义了一个名为 <code>myutils</code> 的自定义包。它包含一个打印消息的导出函数 <code>PrintMessage</code>。<br><code>main.go</code> 是可执行文件，使用相对路径（<code>&quot;myproject/myutils&quot;</code>）导入了自定义包 <code>myutils</code>。<br><code>main.go</code> 中的 main 函数调用 <code>myutils</code> 包中的 <code>PrintMessage</code> 函数并打印一条消息。这种关注点分离使代码保持有序和可维护。</p>
<p><em>快乐编码！</em></p>
<p>点个赞吧，表示对原作者的支持。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://medium.com/@golangda/golang-quick-reference-top-20-best-coding-practices-c0cea6a43f20" target="_blank" rel="external">Golang Best Practices (Top 20)</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust并发编程番外篇: Mutex内部实现]]></title>
    <link href="https://colobu.com/2023/11/05/inside-rust-mutex/"/>
    <id>https://colobu.com/2023/11/05/inside-rust-mutex/</id>
    <published>2023-11-05T12:59:46.000Z</published>
    <updated>2023-12-11T05:37:05.068Z</updated>
    <content type="html"><![CDATA[<p>Mutex是最常用的一种同步原语，它提供了互斥锁的功能,多线程可以互斥访问共享数据以及通过锁保护临界区。Rust标准库提供了Mutex的实现，接下来我们看看它是怎么实现的。</p>
<a id="more"></a>
<h2 id="Mutex的定义">Mutex的定义</h2>
<p><code>Mutex</code>包含三个字段。</p>
<p>一个是内部实现的锁(<code>sys::Mutex</code>)，根据不同的操作系统，可能选择不同的实现。<br>一个是<code>poison</code>，用来标记锁是否被破坏，是否中毒了。<br>最后一个是<code>data</code>，用来存储被保护的数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> Mutex&lt;T: ?Sized&gt; {</div><div class="line">    inner: sys::Mutex,</div><div class="line">    poison: poison::Flag,</div><div class="line">    data: UnsafeCell&lt;T&gt;,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; {</div><div class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(t: T) -&gt; Mutex&lt;T&gt; {</div><div class="line">        Mutex { inner: sys::Mutex::new(), poison: poison::Flag::new(), data: UnsafeCell::new(t) }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外一个关联的数据结构是<code>MutexGuard</code>, 它是<code>Mutex</code>的一个智能指针，用来管理锁的生命周期。它实现了<code>Deref</code>和<code>Drop</code>，所以可以通过<code>*</code>来访问被保护的数据，当<code>MutexGuard</code>离开作用域时，会自动释放锁。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```rust</div><div class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> MutexGuard&lt;'a, T: ?Sized + 'a&gt; {</div><div class="line">    lock: &'a Mutex&lt;T&gt;,</div><div class="line">    poison: poison::Guard,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当请求锁时，调用内部的<code>sys::Mutex</code>上锁，并且返回一个<code>MutexGuard</code>，其实严格的说，返回一个<code>LockResult</code>，它是一个<code>Result</code>，当锁中毒时，返回<code>Err</code>，否则返回<code>Ok</code>，<code>Ok</code>中包含了<code>MutexGuard</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">```rust</div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&<span class="keyword">self</span>) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {</div><div class="line">        <span class="keyword">unsafe</span> {</div><div class="line">            <span class="keyword">self</span>.inner.lock();</div><div class="line">            MutexGuard::new(<span class="keyword">self</span>)</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">pub</span> <span class="keyword">type</span> <span class="title">LockResult</span>&lt;Guard&gt; = Result&lt;Guard, PoisonError&lt;Guard&gt;&gt;;</div></pre></td></tr></table></figure>

<p><code>poison</code>如果你不太了解，可以看看<a href="https://nomicon.purewhite.io/poisoning.html" target="_blank" rel="external">这篇文章</a>，我们不进一步介绍它了。<br><code>MutexGuard</code>功能已经介绍了, 接下来我们看看它的实现:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span>&lt;T: ?Sized&gt; Deref <span class="keyword">for</span> MutexGuard&lt;'_, T&gt; {</div><div class="line">    <span class="keyword">type</span> <span class="title">Target</span> = T;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&<span class="keyword">self</span>) -&gt; &T {</div><div class="line">        <span class="keyword">unsafe</span> { &*<span class="keyword">self</span>.lock.data.get() }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span>&lt;T: ?Sized&gt; DerefMut <span class="keyword">for</span> MutexGuard&lt;'_, T&gt; {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &<span class="keyword">mut</span> T {</div><div class="line">        <span class="keyword">unsafe</span> { &<span class="keyword">mut</span> *<span class="keyword">self</span>.lock.data.get() }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>MutexGuard</code>的解引用返回被保护的数据，返回的是一个引用和可变引用。</p>
<p>当<code>MutexGuard</code>离开作用域时，会自动释放锁，它的实现如下,可以看到它调用了<code>self.lock.inner.unlock()</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span>&lt;T: ?Sized&gt; Drop <span class="keyword">for</span> MutexGuard&lt;'_, T&gt; {</div><div class="line">    <span class="preprocessor">#[inline]</span></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&<span class="keyword">mut</span> <span class="keyword">self</span>) {</div><div class="line">        <span class="keyword">unsafe</span> {</div><div class="line">            <span class="keyword">self</span>.lock.poison.done(&<span class="keyword">self</span>.poison);</div><div class="line">            <span class="keyword">self</span>.lock.inner.unlock();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>try_lock</code>调用<code>inner</code>的<code>try_lock</code>,每什么好说的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">try_lock</span></span>(&<span class="keyword">self</span>) -&gt; TryLockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {</div><div class="line">    <span class="keyword">unsafe</span> {</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.inner.try_lock() {</div><div class="line">            Ok(MutexGuard::new(<span class="keyword">self</span>)?)</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Err(TryLockError::WouldBlock)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前rust还提供了一个不稳定的方法<code>unlock</code>，主动的立即释放锁,其实就是调用了<code>drop(guard)</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unlock</span></span>(guard: MutexGuard&lt;'_, T&gt;) {</div><div class="line">        drop(guard);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>那么看起来，锁的主要逻辑是<code>inner</code>实现的，接下来我们看看<code>inner</code>的实现。  </p>
<p><code>inner</code>的类型是<code>sys::Mutex</code>,它位于<a href="https://github.com/rust-lang/rust/blob/8acf40bd546258a70953187c950ea56d1a8f5bf2/library/std/src/sys/mod.rs" target="_blank" rel="external">library/std/src/sys/mod.rs</a>,根据操作系统的不同，有不同的实现，我们主要看linux(unix)的实现。</p>
<p>unix的实现位于<a href="https://github.com/rust-lang/rust/blob/8acf40bd546258a70953187c950ea56d1a8f5bf2/library/std/src/sys/unix/locks/futex_mutex.rs" target="_blank" rel="external">/library/std/src/sys/unix/locks</a>, 根据具体的操作系统，也有两种实现方案，我们主要看linux的实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="preprocessor">#[cfg(any(</span></div><div class="line">        target_os = "linux",</div><div class="line">        target_os = "android",</div><div class="line">        all(target_os = "emscripten", target_feature = "atomics"),</div><div class="line">        target_os = "freebsd",</div><div class="line">        target_os = "openbsd",</div><div class="line">        target_os = "dragonfly",</div><div class="line">    ))] {</div><div class="line">        <span class="keyword">mod</span> futex_mutex;</div><div class="line">        <span class="keyword">mod</span> futex_rwlock;</div><div class="line">        <span class="keyword">mod</span> futex_condvar;</div><div class="line">        <span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="keyword">use</span> futex_mutex::Mutex;</div><div class="line">        <span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="keyword">use</span> futex_rwlock::RwLock;</div><div class="line">        <span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="keyword">use</span> futex_condvar::Condvar;</div><div class="line">    } ...</div></pre></td></tr></table></figure>

<p>它有两种实现<code>futex_mutex</code>和<code>pthread_mutex.rs</code>, Linux操作系统下，使用的是<code>futex_mutex</code>。</p>
<p><code>futex_mutex</code>会使用Linux操作系统的<code>futex_wait</code>和<code>futex_wake</code>系统调用。<br>它只包含一个<code>futex</code>字段，它是一个<code>AtomicU32</code>，用来表示锁的状态，它有三种状态:</p>
<ul>
<li>0: 未加锁状态·</li>
<li>1: 加锁，且没有其它线程等待</li>
<li>2: 加锁，且有其它线程等待(竞争)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> crate::sync::atomic::{</div><div class="line">    AtomicU32,</div><div class="line">    Ordering::{Acquire, Relaxed, Release},</div><div class="line">};</div><div class="line"><span class="keyword">use</span> crate::sys::futex::{futex_wait, futex_wake};</div><div class="line"></div><div class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> Mutex {</div><div class="line">    futex: AtomicU32,</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>new</code>创建一个未加锁的Muext, 而<code>try_lock</code>会尝试将<code>futex</code>从0改为1，如果成功，表示加锁成功，否则失败。<br>注意这里使用了 <code>Acquire</code>和<code>Relaxed</code> Ordering，交换成功新值内存可见(<code>Acquire</code>)，失败无所谓了(<code>Relaxed</code>):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span> Mutex {</div><div class="line">    <span class="preprocessor">#[inline]</span></div><div class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Self {</div><div class="line">        Self { futex: AtomicU32::new(<span class="number">0</span>) }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="preprocessor">#[inline]</span></div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">try_lock</span></span>(&<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> {</div><div class="line">        <span class="keyword">self</span>.futex.compare_exchange(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed).is_ok()</div><div class="line">    }</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line">接下来是重头戏`lock`:</div></pre></td></tr></table></figure>

<p>rust<br>impl Mutex {<br>    ...</p>
<pre><code><span class="preprocessor">#[inline]</span>
<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lock</span></span>(&amp;<span class="keyword">self</span>) {
    <span class="keyword">if</span> <span class="keyword">self</span>.futex.compare_exchange(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed).is_err() {
        <span class="keyword">self</span>.lock_contended(); <span class="comment">// 如果第一次抢不到锁，进入锁竞争场景的处理</span>
    }
}

<span class="preprocessor">#[cold]</span>
<span class="function"><span class="keyword">fn</span> <span class="title">lock_contended</span></span>(&amp;<span class="keyword">self</span>) {
    <span class="comment">// 获取锁的状态</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> state = <span class="keyword">self</span>.spin();

    <span class="comment">// 如果未加速，去抢!</span>
    <span class="keyword">if</span> state == <span class="number">0</span> {
        <span class="keyword">match</span> <span class="keyword">self</span>.futex.compare_exchange(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed) {
            Ok(<span class="number">_</span>) =&gt; <span class="keyword">return</span>, <span class="comment">// 抢成功，返回</span>
            Err(s) =&gt; state = s, <span class="comment">// 失败，把当前的状态赋值给state</span>
        }
    }

    <span class="keyword">loop</span> {
        <span class="comment">// 运气来了，在多个人抢一个未加锁的锁时，你，命中天子抢到了锁，并且把锁状态从0改为2</span>
        <span class="keyword">if</span> state != <span class="number">2</span> &amp;&amp; <span class="keyword">self</span>.futex.swap(<span class="number">2</span>, Acquire) == <span class="number">0</span> {
            <span class="comment">// 成功把锁的状态从0改成了2，获取了锁，返回</span>
            <span class="keyword">return</span>;
        }

        <span class="comment">// 等待锁状态变化，如果锁状态不是2，就不等了</span>
        futex_wait(&amp;<span class="keyword">self</span>.futex, <span class="number">2</span>, None);

        <span class="comment">// 别的线程释放了锁，spin检查锁的状态，再集中精力继续抢</span>
        state = <span class="keyword">self</span>.spin();
    }
}

<span class="function"><span class="keyword">fn</span> <span class="title">spin</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">u32</span> {
    <span class="keyword">let</span> <span class="keyword">mut</span> spin = <span class="number">100</span>;
    <span class="keyword">loop</span> {
        <span class="comment">// 获取当前锁的状态， 可能是0,1,2三种状态</span>
        <span class="keyword">let</span> state = <span class="keyword">self</span>.futex.load(Relaxed);

        <span class="comment">// 如果是未加锁，或者是有其它线程等待，则返回</span>
        <span class="comment">// 如果spin次数用完了，也返回</span>
        <span class="keyword">if</span> state != <span class="number">1</span> || spin == <span class="number">0</span> {
            <span class="keyword">return</span> state;
        }

        crate::hint::spin_loop();
        spin -= <span class="number">1</span>;
    }
}
...
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">总得来说，抢锁的线程通过spin,避免上下文切换，能够提高性能。如果spin次数用完了，就进入等待状态，等待其它线程释放锁，然后再抢。</div><div class="line"></div><div class="line">剩下一个方法就是解锁了。解锁比较简单，就是把锁的状态从1或者2改为0，如果原来是2，表示还有其它线程等待，就唤醒一个。</div></pre></td></tr></table></figure>

<p>rust<br>impl Mutex {<br>    ...<br>    pub unsafe fn unlock(&amp;self) {<br>        if self.futex.swap(0, Release) == 2 {<br>            // 如果还有等待的线程，就唤醒一个<br>            self.wake();<br>        }<br>    }</p>
<pre><code><span class="comment">#[cold]</span>
fn wake(&amp;self) {
    futex_wake(&amp;self.futex);
}
<span class="keyword">...</span>
</code></pre><p>}<br><code>`</code></p>
<p>可以看到，Rust的Mutex的实现还是比较简单的，它的核心是利用操作系统的<code>futex</code>相关方法，加一个<code>AtomicU32</code>标志来实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mutex是最常用的一种同步原语，它提供了互斥锁的功能,多线程可以互斥访问共享数据以及通过锁保护临界区。Rust标准库提供了Mutex的实现，接下来我们看看它是怎么实现的。</p>
]]>
    
    </summary>
    
      <category term="Rust" scheme="https://colobu.com/categories/Rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iptables 以及 Go操作库]]></title>
    <link href="https://colobu.com/2023/10/30/iptables-and-operations-in-Go/"/>
    <id>https://colobu.com/2023/10/30/iptables-and-operations-in-Go/</id>
    <published>2023-10-30T13:32:06.000Z</published>
    <updated>2023-12-11T05:37:05.068Z</updated>
    <content type="html"><![CDATA[<p><code>iptables</code> 是 Linux 系统中的一个非常强大的防火墙工具，它可以用于过滤、修改、重定向和处理网络数据包。iptables 是基于 Netfilter 框架的，Netfilter 是 Linux 内核的一部分，它提供了在内核级别处理网络数据包的能力。</p>
<a id="more"></a>
<p><img src="Netfilter-packet-flow.png" alt=""></p>
<p>iptables 的主要功能包括：</p>
<ol>
<li>数据包过滤：iptables 可以根据各种条件（如源 IP 地址、目的 IP 地址、协议类型、端口号等）来决定是否允许数据包通过。这是实现防火墙的基本功能。</li>
<li>网络地址转换（NAT）：iptables 可以修改数据包的源 IP 地址或目的 IP 地址，这是实现网络地址转换（NAT）的基本功能。</li>
<li>数据包重定向和修改：iptables 可以将数据包重定向到其a他的 IP 地址或端口，或者修改数据包的其他属性。</li>
</ol>
<p>iptables 的规则是基于表和链的。表是规则的集合，链是表中的一个部分，它代表了数据包处理的一个阶段。iptables 有五个预定义的表：<code>filter</code>（用于数据包过滤）、<code>nat</code>（用于网络地址转换）、<code>mangle</code>（用于数据包修改）、<code>raw</code>（用于配置不进行连接跟踪的数据包）和<code>security</code>（用于强制访问控制）。iptables 是一个非常复杂和强大的工具，它需要深入的网络知识和 Linux 系统知识才能有效地使用。然而，对于网络管理员和系统管理员来说，学习和掌握 iptables 是非常有价值的，因为它可以提供非常强大和灵活的网络控制能力。</p>
<h2 id="数据包过滤">数据包过滤</h2>
<p>iptables 的数据包过滤功能是通过 filter 表来实现的，这是 iptables 的默认表。filter 表有三个内置的链：INPUT、FORWARD 和 OUTPUT。</p>
<ul>
<li>INPUT 链用于处理到达本机的数据包。</li>
<li>FORWARD 链用于处理经过本机转发的数据包。</li>
<li>OUTPUT 链用于处理本机发送的数据包。</li>
</ul>
<p>你可以在这些链上添加规则来过滤数据包。每个规则都有一个匹配条件和一个目标（动作）。当一个数据包满足匹配条件时，就会执行相应的目标。</p>
<p>以下是一些基本的例子：</p>
<ol>
<li>阻止来自特定 IP 地址的数据包：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT <span class="operator">-s</span> <span class="number">192.168</span>.<span class="number">1.100</span> -j DROP</div></pre></td></tr></table></figure>


<p>  这个命令在 INPUT 链上添加了一个规则，该规则会匹配所有源 IP 地址为 192.168.1.100 的数据包，并将它们丢弃（DROP）。</p>
<ol start="2">
<li>只允许来自特定端口的数据包：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT -p tcp --dport <span class="number">22</span> -j ACCEPT</div><div class="line">iptables -A INPUT -p tcp -j DROP</div></pre></td></tr></table></figure>


<p>  这两个命令在 INPUT 链上添加了两个规则。第一个规则会匹配所有目的端口为 22 的 TCP 数据包，并将它们接受（ACCEPT）。第二个规则会匹配所有 TCP 数据包，并将它们丢弃（DROP）。因为 iptables 的规则是按顺序处理的，所以这两个规则的效果是只允许来自端口 22 的数据包，其他的 TCP 数据包都会被丢弃。</p>
<ol start="3">
<li>阻止所有的数据包：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iptables -P INPUT DROP</div><div class="line">iptables -P FORWARD DROP</div><div class="line">iptables -P OUTPUT DROP</div></pre></td></tr></table></figure>



<p>这三个命令将 INPUT、FORWARD 和 OUTPUT 链的默认策略（P）设置为 DROP。这意味着所有的数据包都会被丢弃，除非有规则明确允许它们。</p>
<p>你需要 root 权限才能运行 <code>iptables</code> 命令。</p>
<h2 id="网络地址转换">网络地址转换</h2>
<p>iptables 的网络地址转换（NAT）功能是通过 nat 表来实现的。nat 表有三个内置的链：PREROUTING、POSTROUTING 和 OUTPUT。</p>
<ul>
<li>PREROUTING 链用于处理到达本机之前的数据包。</li>
<li>POSTROUTING 链用于处理离开本机之后的数据包。</li>
<li>OUTPUT 链用于处理本机生成的数据包。</li>
</ul>
<p>以下是一些基本的例子：</p>
<ol>
<li>端口转发：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -p tcp --dport <span class="number">80</span> -j REDIRECT --to-port <span class="number">8080</span></div></pre></td></tr></table></figure>


<p>  这个命令在 PREROUTING 链上添加了一个规则，该规则会匹配所有目的端口为 80 的 TCP 数据包，并将它们重定向（REDIRECT）到端口 8080。这是实现端口转发的一种方法。</p>
<ol start="2">
<li>源 NAT（SNAT）：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source <span class="number">192.168</span>.<span class="number">1.100</span></div></pre></td></tr></table></figure>


<p>  这个命令在 POSTROUTING 链上添加了一个规则，该规则会匹配所有出口接口为 eth0 的数据包，并将它们的源 IP 地址改为 192.168.1.100。这是实现源 NAT（SNAT）的一种方法，通常用于在私有网络中访问公共网络。</p>
<ol start="3">
<li>目的 NAT（DNAT）：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -p tcp --dport <span class="number">80</span> -j DNAT --to-destination <span class="number">192.168</span>.<span class="number">1.100</span>:<span class="number">8080</span></div></pre></td></tr></table></figure>


<p>  这个命令在 PREROUTING 链上添加了一个规则，该规则会匹配所有目的端口为 80 的 TCP 数据包，并将它们的目的 IP 地址和端口改为 192.168.1.100:8080。这是实现目的 NAT（DNAT）的一种方法，通常用于实现负载均衡和端口转发。</p>
<h2 id="数据包重定向和修改">数据包重定向和修改</h2>
<p>iptables 的数据包重定向和修改功能主要是通过 <code>nat</code> 表和 <code>mangle</code> 表来实现的。</p>
<ol>
<li>数据包重定向：数据包重定向主要是通过 nat 表的 REDIRECT 目标来实现的。REDIRECT 目标会将数据包的目的 IP 地址和/或目的端口改为新的值。以下是一个例子：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -p tcp --dport <span class="number">80</span> -j REDIRECT --to-port <span class="number">8080</span></div></pre></td></tr></table></figure>


<p>  这个命令在 PREROUTING 链上添加了一个规则，该规则会匹配所有目的端口为 80 的 TCP 数据包，并将它们重定向到端口 8080。</p>
<ol start="2">
<li>数据包修改：数据包修改主要是通过 mangle 表来实现的。mangle 表可以用于修改数据包的各种属性，如 TOS（服务类型）、TTL（生存时间）等。以下是一个例子：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t mangle -A PREROUTING -p tcp --dport <span class="number">80</span> -j TOS --set-tos Minimize-Delay</div></pre></td></tr></table></figure>



<p>这个命令在 PREROUTING 链上添加了一个规则，该规则会匹配所有目的端口为 80 的 TCP 数据包，并将它们的 TOS 设置为 Minimize-Delay。</p>
<h2 id="配置不进行连接跟踪">配置不进行连接跟踪</h2>
<p>raw 表在 iptables 中主要用于配置不进行连接跟踪的数据包。连接跟踪（connection tracking）是 Netfilter（iptables 的底层框架）的一个功能，它可以跟踪网络连接的状态，并根据状态来匹配数据包。</p>
<p>raw 表有两个内置的链：PREROUTING 和 OUTPUT。</p>
<ul>
<li>PREROUTING 链用于处理到达本机之前的数据包。</li>
<li>OUTPUT 链用于处理本机生成的数据包。</li>
</ul>
<p>在 raw 表中，你可以使用 NOTRACK 目标来指定不进行连接跟踪的数据包。以下是一个例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t raw -A PREROUTING -p tcp --dport <span class="number">80</span> -j NOTRACK</div></pre></td></tr></table></figure>

<p>这个命令在 PREROUTING 链上添加了一个规则，该规则会匹配所有目的端口为 80 的 TCP 数据包，并将它们标记为不进行连接跟踪。</p>
<p>请注意，NOTRACK 目标在较新的 Linux 系统中已经被 CT 目标替代，你可以使用 CT 目标的 --notrack 选项来达到同样的效果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t raw -A PREROUTING -p tcp --dport <span class="number">80</span> -j CT --notrack</div></pre></td></tr></table></figure>

<h2 id="安全">安全</h2>
<p>security 表在 iptables 中主要用于配置强制访问控制（Mandatory Access Control，MAC）的安全策略。这个表通常与 SELinux（Security-Enhanced Linux）等安全模块一起使用。</p>
<p>security 表有三个内置的链：INPUT、OUTPUT 和 FORWARD。</p>
<ul>
<li>INPUT 链用于处理到达本机的数据包。</li>
<li>OUTPUT 链用于处理本机发送的数据包。</li>
<li>FORWARD 链用于处理经过本机转发的数据包。</li>
</ul>
<p>在 security 表中，你可以使用 SECMARK 和 CONNSECMARK 目标来设置数据包的安全标记（secmark）。以下是一个例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t security -A OUTPUT -p tcp --dport <span class="number">22</span> -j SECMARK --selctx system_u:object_r:sshd_port_t:s0</div></pre></td></tr></table></figure>

<p>这个命令在 OUTPUT 链上添加了一个规则，该规则会匹配所有目的端口为 22 的 TCP 数据包，并将它们的安全标记设置为 system_u:object_r:sshd_port_t:s0。</p>
<p>请注意，security 表的使用通常需要深入的 SELinux 知识，而且它只在启用了 SELinux 的系统中有效。</p>
<p>同样，你需要 root 权限才能运行 iptables 命令。如果你在运行命令时遇到权限问题，你可以使用 sudo 命令来获取 root 权限。</p>
<h2 id="iptables_在_k8s_中的应用">iptables 在 k8s 中的应用</h2>
<p>在 Kubernetes（K8s）中，iptables 主要用于实现服务发现和负载均衡。</p>
<p>Kubernetes 使用 iptables 的 NAT 表来将到达服务的 IP 地址和端口的数据包重定向到后端 Pod 的 IP 地址和端口。这是通过在 PREROUTING 和 OUTPUT 链上添加 DNAT 规则来实现的。</p>
<p>例如，假设你有一个服务，它的 IP 地址是 10.0.0.1，端口是 80，并且它有两个后端 Pod，它们的 IP 地址分别是 172.17.0.2 和 172.17.0.3。Kubernetes 可能会添加如下的 iptables 规则：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -p tcp <span class="operator">-d</span> <span class="number">10.0</span>.<span class="number">0.1</span> --dport <span class="number">80</span> -j DNAT --to-destination <span class="number">172.17</span>.<span class="number">0.2</span>:<span class="number">80</span></div><div class="line">iptables -t nat -A PREROUTING -p tcp <span class="operator">-d</span> <span class="number">10.0</span>.<span class="number">0.1</span> --dport <span class="number">80</span> -j DNAT --to-destination <span class="number">172.17</span>.<span class="number">0.3</span>:<span class="number">80</span></div></pre></td></tr></table></figure>

<p>这些规则会将到达 10.0.0.1:80 的 TCP 数据包重定向到 172.17.0.2:80 或 172.17.0.3:80。</p>
<p>此外，Kubernetes 还使用 iptables 的 filter 表来实现网络策略。网络策略可以用于控制 Pod 之间的网络通信。这是通过在 FORWARD 链上添加 ACCEPT 或 DROP 规则来实现的。</p>
<p>请注意，Kubernetes 的 iptables 规则是由 kube-proxy 组件自动管理的，通常不需要手动修改。在较新的 Kubernetes 版本中，你还可以选择使用 IPVS 或 eBPF 来替代 iptables。</p>
<h2 id="使用Go操作库配置iptables">使用Go操作库配置iptables</h2>
<p>虽然你可以直接使用 iptables 命令来配置 iptables，但是有时候我们还是需要程序化操作iptables，实现动态的调整iptables规则，这里给你介绍一个Go库: <a href="https://github.com/coreos/go-iptables" target="_blank" rel="external">go-iptables</a>, 它是由coreos公司出品，它对 iptables命令做了封装，可以在程序中调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/coreos/go-iptables/iptables"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	tables, err := iptables.New()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	chains, err := tables.ListChains(<span class="string">"nat"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, chain := <span class="keyword">range</span> chains {</div><div class="line">		fmt.Println(<span class="string">"chain:"</span>, chain)</div><div class="line">		rules, err := tables.List(<span class="string">"nat"</span>, chain)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> rules {</div><div class="line">			fmt.Println(<span class="string">"rule:"</span>, r)</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	err = tables.Insert(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>,<span class="number"> 1</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"80"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8080"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	err = tables.Append(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"81"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8081"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	ok, err := tables.Exists(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"80"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8080"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(<span class="string">"exist:"</span>, ok)</div><div class="line">	ok, err = tables.Exists(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"90"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8090"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(<span class="string">"exist:"</span>, ok)</div><div class="line"></div><div class="line">	err = tables.Delete(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"80"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8080"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	ok, err = tables.Exists(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"80"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8080"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(<span class="string">"exist:"</span>, ok)</div><div class="line"></div><div class="line">	err = tables.ClearChain(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	ok, err = tables.Exists(<span class="string">"nat"</span>, <span class="string">"PREROUTING"</span>, <span class="string">"-p"</span>, <span class="string">"udp"</span>, <span class="string">"--dport"</span>, <span class="string">"80"</span>, <span class="string">"-j"</span>, <span class="string">"REDIRECT"</span>, <span class="string">"--to-ports"</span>, <span class="string">"8008"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(<span class="string">"exist:"</span>, ok)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，它提供了增删改查的方法，可以方便的操作iptables。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>iptables</code> 是 Linux 系统中的一个非常强大的防火墙工具，它可以用于过滤、修改、重定向和处理网络数据包。iptables 是基于 Netfilter 框架的，Netfilter 是 Linux 内核的一部分，它提供了在内核级别处理网络数据包的能力。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[像Redis作者那样，使用Go实现一个聊天服务器，不到100行代码]]></title>
    <link href="https://colobu.com/2023/10/29/implement-a-small-chat-server-like-antirez-in-100-lines/"/>
    <id>https://colobu.com/2023/10/29/implement-a-small-chat-server-like-antirez-in-100-lines/</id>
    <published>2023-10-29T13:14:57.000Z</published>
    <updated>2023-12-11T05:37:05.068Z</updated>
    <content type="html"><![CDATA[<p>昨天Redis的作者 antirez (Salvatore Sanfilippo) 昨天创建一个新的演示项目：<a href="https://github.com/smallnest/smallchat" target="_blank" rel="external">smallchat</a>，用了200行C语言代码实现了一个聊天室。我看了一下，觉得很有意思，于是就用Go语言实现了一下，代码不到100行，功能和antirez的实现一样。</p>
<a id="more"></a>
<p>antirez 三年前停止写代码，专心写他的科幻小说《Wohpe》，今天看起来他有回到编程的状态了。关于这个小项目的背景是：</p>
<blockquote>
<p>昨天我正在与几个前端开发者朋友闲聊,他们距离系统编程有些远。我们回忆起了过去的IRC时光。不可避免地,我说:编写一个非常简单的IRC服务器每个人都应该做一次。这样程序中有非常有趣的部分。一个进程进行多路复用,维护客户端状态,可以用不同的方式实现等等。</p>
<p>然后讨论继续,我想,我会给你们展示一个极简的C语言例子。但是你能编写出啥样的最小聊天服务器呢?要真正做到极简,我们不应该需要任何特殊的客户端，即使不是很完美,它应该可以用<code>telnet</code>或<code>nc</code>(netcat)作为客户端连接。服务器的主要功能只是接收一些聊天信息并发送给所有其他客户端,这有时称为<strong>扇出</strong>操作。这还需要一个合适的<code>readline()</code>函数,然后是缓冲等等。我们想要更简单的:利用内核缓冲区,假装我们每次都从客户端收到一个完整的行(这个假设在实际中通常是正确的,所以这个假设没啥问题)。</p>
<p>好吧,有了这些技巧,我们可以用只有200行代码实现一个聊天室,用户甚至可以设置昵称(当然,不计空格和注释)。由于我将这个小程序作为示例编写给我的朋友,我决定也把它推到Github上。</p>
</blockquote>
<p>嗯，挺有趣的事情，我也很羡慕 antirez 有时间聊一聊编程中的一些趣事和想法。</p>
<p>这也不免让我想起上大学的时候，大家还沉迷于在终端中使用telnet连接BBS服务器，或者玩mud的游戏，窗外还飘着《Yesterday Once More》的旋律。那时候的互联网刚刚开始。</p>
<p>嗯，然后这个无聊的下午，我就想使用Go实现antirez的这个程序，我也不知道目的是啥，就纯粹想玩一玩，练一练手，最终用了不到100行代码实现了一个聊天服务器，功能和antirez的实现一样。</p>
<p>这个代码我也放到了github上: <a href="https://github.com/smallnest/smallchat" target="_blank" rel="external">smallnest/smallchat</a>。</p>
<p>我们不妨看看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	maxClients =<span class="number"> 1000</span></div><div class="line">	maxNickLen =<span class="number"> 32</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	serverPort = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"server port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> {</div><div class="line">	conn net.Conn</div><div class="line">	nick <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> ChatState <span class="keyword">struct</span> {</div><div class="line">	listener net.Listener</div><div class="line"></div><div class="line">	clientsLock sync.RWMutex</div><div class="line">	clients     <span class="keyword">map</span>[net.Conn]*Client</div><div class="line">	numClients  <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> chatState = &ChatState{</div><div class="line">	clients: <span class="built_in">make</span>(<span class="keyword">map</span>[net.Conn]*Client),</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> initChat() {</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	chatState.listener, err = net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">":%d"</span>, *serverPort))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"listen error:"</span>, err)</div><div class="line">		os.Exit<span class="number">(1</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleClient(client *Client) {</div><div class="line">	<span class="comment">// 发送欢迎信息</span></div><div class="line">	welcomeMsg := <span class="string">"Welcome Simple Chat! Use /nick to change nick name.\n"</span></div><div class="line">	client.conn.Write([]<span class="typename">byte</span>(welcomeMsg))</div><div class="line"></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 256</span>)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		n, err := client.conn.Read(buf)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Printf(<span class="string">"client left: %s\n"</span>, client.conn.RemoteAddr())</div><div class="line">			chatState.clientsLock.Lock()</div><div class="line">			<span class="built_in">delete</span>(chatState.clients, client.conn)</div><div class="line">			chatState.numClients--</div><div class="line">			chatState.clientsLock.Unlock()</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		msg := <span class="typename">string</span>(buf[:n])</div><div class="line">		msg = strings.TrimSpace(msg)</div><div class="line">		<span class="keyword">if</span> msg<span class="number">[0</span>] == <span class="string">'/'</span> {</div><div class="line">			<span class="comment">// 处理命令</span></div><div class="line">			parts := strings.SplitN(msg, <span class="string">" "</span>,<span class="number"> 2</span>)</div><div class="line">			cmd := parts<span class="number">[0</span>]</div><div class="line">			<span class="keyword">if</span> cmd == <span class="string">"/nick"</span> && <span class="built_in">len</span>(parts) &gt;<span class="number"> 1</span> {</div><div class="line">				client.nick = parts<span class="number">[1</span>]</div><div class="line">			}</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		fmt.Printf(<span class="string">"%s: %s\n"</span>, client.nick, msg)</div><div class="line"></div><div class="line">		<span class="comment">// 将消息转发给其他客户端</span></div><div class="line">		chatState.clientsLock.RLock()</div><div class="line">		<span class="keyword">for</span> conn, cl := <span class="keyword">range</span> chatState.clients {</div><div class="line">			<span class="keyword">if</span> cl != client {</div><div class="line">				conn.Write([]<span class="typename">byte</span>(client.nick + <span class="string">": "</span> + msg))</div><div class="line">			}</div><div class="line">		}</div><div class="line">		chatState.clientsLock.RUnlock()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	initChat()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		conn, err := chatState.listener.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Println(<span class="string">"accept error:"</span>, err)</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		client := &Client{conn: conn}</div><div class="line">		client.nick = fmt.Sprintf(<span class="string">"user%d"</span>, conn.RemoteAddr().(*net.TCPAddr).Port)</div><div class="line"></div><div class="line">		chatState.clientsLock.Lock()</div><div class="line">		chatState.clients[conn] = client</div><div class="line">		chatState.numClients++</div><div class="line">		chatState.clientsLock.Unlock()</div><div class="line"></div><div class="line">		<span class="keyword">go</span> handleClient(client)</div><div class="line"></div><div class="line">		fmt.Printf(<span class="string">"new client: %s\n"</span>, conn.RemoteAddr())</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先我们从<code>main</code>函数说起。</p>
<p><code>main</code>函数中我们首先调用<code>initChat</code>函数，这个函数中我们使用<code>net.Listen</code>创建了一个<code>net.Listener</code>，然后使用<code>Accept</code>方法接收客户端的连接。<code>Accept</code>方法返回一个<code>net.Conn</code>，这个<code>net.Conn</code>代表了一个客户端的连接，我们可以使用<code>Read</code>和<code>Write</code>方法读写数据。</p>
<p>为了跟踪每一个用户，我们定义了一个<code>Client</code>结构体，其中包含了一个<code>net.Conn</code>和一个<code>nick</code>字段，<code>nick</code>字段代表了用户的昵称。</p>
<p>我们使用一个<code>ChatState</code>结构体来保存聊天室的状态，其中包含了一个<code>net.Listener</code>和一个<code>clients</code>字段，<code>clients</code>字段是一个<code>map[net.Conn]*Client</code>，用来保存所有的客户端连接。<code>ChatState</code>还包含了一个<code>clientsLock</code>字段，这个字段是一个<code>sync.RWMutex</code>，用来保护<code>clients</code>字段，因为<code>clients</code>字段会被多个goroutine访问。</p>
<p><code>main</code>函数中我们使用一个<code>for</code>循环来接收客户端的连接，然后调用<code>handleClient</code>函数来处理客户端的连接。</p>
<p>接下来就是<code>handleClient</code>函数了，这个函数中我们首先发送一个欢迎信息给客户端，然后使用一个<code>for</code>循环来读取客户端发送的消息，如果客户端断开连接，我们就从<code>clients</code>中删除这个客户端，然后退出循环。</p>
<p>我们假定用户的输入不超过256字节，然后我们使用<code>strings.TrimSpace</code>函数去掉消息前后的空格，然后判断消息是否以<code>/</code>开头。</p>
<p>如果客户端发送的消息以<code>/</code>开头，我们就认为这是一个命令，我们只处理<code>/nick</code>命令，这个命令用来设置客户端的昵称。</p>
<p>如果客户端发送的消息不是以<code>/</code>开头，我们就认为这是一个聊天消息，我们将这个消息转发给所有的客户端。</p>
<p><code>handleClient</code>函数中我们使用了<code>chatState.clientsLock</code>来保护<code>clients</code>字段，因为<code>clients</code>字段会被多个goroutine访问。</p>
<p>这就是一个可工作的聊天服务器了，我们可以使用<code>telnet</code>或<code>nc</code>来连接这个服务器，然后就可以跟其他用户聊天了。登录进去后你可以使用<code>/nick</code>命令进行改名。</p>
<p>当然这只是一个玩具，没有任何的安全性检查，也没有任何的错误处理，但是它可以工作，而且代码很简单。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天Redis的作者 antirez (Salvatore Sanfilippo) 昨天创建一个新的演示项目：<a href="https://github.com/smallnest/smallchat" target="_blank" rel="external">smallchat</a>，用了200行C语言代码实现了一个聊天室。我看了一下，觉得很有意思，于是就用Go语言实现了一下，代码不到100行，功能和antirez的实现一样。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Go语言中实现Unix风格的进程管道？]]></title>
    <link href="https://colobu.com/2023/10/22/how-to-use-pipe-in-Go-exec-Command/"/>
    <id>https://colobu.com/2023/10/22/how-to-use-pipe-in-Go-exec-Command/</id>
    <published>2023-10-22T15:20:47.000Z</published>
    <updated>2023-12-11T05:37:05.060Z</updated>
    <content type="html"><![CDATA[<p>今天看到包云岗老师的一条微博：<br><a id="more"></a><br><img src="weibo.png" alt=""></p>
<p>这个一小时就在Unix中实现了管道的系统调用的出处来自于《Unix传奇》一书，这本书是我读过的最好的一本关于Unix历史的书籍，里面介绍了很多大神的光辉事迹，Ken Thompson是Unix的创始人之一，他还是Go语言的三巨头之一。<br><img src="pipe.jpg" alt=""></p>
<p>那么，在Go语言中，如何实现进程的管道呢？</p>
<p>在Go语言中，你可以使用<code>exec</code>包来启动一个进程。主要的函数是<code>Command</code>函数，它返回一个<code>Cmd</code>类型，该类型代表一个正在准备运行的命令。</p>
<p>以下是一个简单的例子，演示如何启动一个进程并执行命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 创建一个 Cmd 结构体，代表要执行的命令</span></div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-l"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 执行命令并等待完成</span></div><div class="line">	err := cmd.Run()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error executing command:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 获取命令的标准输出</span></div><div class="line">	output, err := cmd.Output()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error getting command output:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 打印输出结果</span></div><div class="line">	fmt.Println(<span class="string">"Command Output:"</span>)</div><div class="line">	fmt.Println(<span class="typename">string</span>(output))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>exec.Command(&quot;ls&quot;, &quot;-l&quot;)</code> 创建了一个表示运行<code>ls -l</code>命令的<code>Cmd</code>结构体。然后，<code>cmd.Run()</code>执行该命令，并等待它完成。最后，使用<code>cmd.Output()</code>获取命令的标准输出。<br>请注意，<code>cmd.Run()</code>会等待命令完成，而<code>cmd.Start()</code>可以用于启动但不等待命令完成。你还可以使用<code>cmd.Wait()</code>显式等待命令完成。</p>
<p>如果要实现进程的管道处理，我们可以这样实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 创建一个 Cmd 结构体，代表第一个命令：echo Hello</span></div><div class="line">	cmd1 := exec.Command(<span class="string">"echo"</span>, <span class="string">"Hello"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 创建第二个命令：grep Hello，并设置其标准输入为第一个命令的标准输出</span></div><div class="line">	cmd2 := exec.Command(<span class="string">"grep"</span>, <span class="string">"Hello"</span>)</div><div class="line">	cmd2.Stdin, _ = cmd1.StdoutPipe()</div><div class="line"></div><div class="line">	<span class="comment">// 获取第二个命令的标准输出</span></div><div class="line">	cmd2Output, _ := cmd2.Output()</div><div class="line"></div><div class="line">	<span class="comment">// 执行第一个命令并等待完成</span></div><div class="line">	<span class="keyword">if</span> err := cmd1.Run(); err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error running command 1:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 执行第二个命令并等待完成</span></div><div class="line">	<span class="keyword">if</span> err := cmd2.Run(); err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error running command 2:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 打印最终结果</span></div><div class="line">	fmt.Println(<span class="string">"Final Output:"</span>)</div><div class="line">	fmt.Println(<span class="typename">string</span>(cmd2Output))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，cmd1 代表 echo Hello 命令，cmd2 代表 grep Hello 命令。通过将 cmd2 的标准输入连接到 cmd1 的标准输出，实现了管道的效果。</p>
<p>更简单的，你可以使用下面的方式实现Unix风格管道的使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 创建一个 Cmd 结构体，代表整个命令：echo Hello | grep Hello</span></div><div class="line">	cmd := exec.Command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo Hello | grep Hello"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 获取命令的标准输出</span></div><div class="line">	output, err := cmd.Output()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error executing command:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 打印输出结果</span></div><div class="line">	fmt.Println(<span class="string">"Command Output:"</span>)</div><div class="line">	fmt.Println(<span class="typename">string</span>(output))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>exec.Command</code> 使用了 <code>sh -c</code> 来在shell中运行整个命令字符串 &quot;echo Hello | grep Hello&quot;。这样就实现了 <code>echo Hello | grep Hello</code> 的效果。</p>
<p><code>sh -c</code> 是指在shell中执行给定的命令字符串的选项。在这个上下文中，<code>sh</code> 是shell的可执行文件，<code>-c</code> 是一个选项，表示后面跟着要执行的命令字符串。</p>
<ul>
<li><code>sh</code>：这是shell的可执行文件的名称。在大多数Unix-like系统中，<code>sh</code> 通常是指 Bourne Shell 或其兼容版本，例如 <code>Bash</code>。<code>sh</code> 是一个命令解释器，负责执行用户提供的命令。</li>
<li><code>-c</code>：这是 <code>sh</code> 的一个选项，表示后面会跟着一个要执行的命令字符串。</li>
</ul>
<p>所以，当你运行 <code>sh -c &quot;echo Hello | grep Hello&quot;</code> 时，它告诉shell执行后面的命令字符串。在这个例子中，命令字符串是 &quot;echo Hello | grep Hello&quot;，它包含了一个管道，将 <code>echo Hello</code> 的输出传递给 <code>grep Hello</code>。</p>
<p>总结起来，<code>sh -c</code> 是一个在shell中执行命令字符串的机制，允许你在一个命令中组合多个子命令，包括管道和其他shell特性。</p>
<p>请注意，这种方法依赖于使用shell来解释命令字符串，因此可能不够安全，特别是如果输入包含用户提供的数据。确保你能够信任并控制传递给 sh -c 的字符串。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天看到包云岗老师的一条微博：<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust并发编程5 - 基本并发原语]]></title>
    <link href="https://colobu.com/2023/10/22/concurrency-programming-via-rust-ch05/"/>
    <id>https://colobu.com/2023/10/22/concurrency-programming-via-rust-ch05/</id>
    <published>2023-10-22T14:40:50.000Z</published>
    <updated>2023-12-11T05:37:05.058Z</updated>
    <content type="html"><![CDATA[<p>同步是多线程程序中的一个重要概念。在多线程环境下,多个线程可能同时访问某个共享资源,这就可能导致数据竞争或者数据不一致的问题。为了保证数据安全,需要进行同步操作。</p>
<p>常见的同步需求包括:</p>
<ul>
<li>互斥:线程在使用共享资源时,同一时刻只允许一个线程访问共享资源,在一个线程使用时,其他线程需要等待,不能同时访问,需要互斥访问。</li>
<li>限制同时访问线程数:对某些共享资源,可能需要限制同一时刻访问的线程数。</li>
<li>线程间通信:一个线程需要基于另一个线程的处理结果才能继续执行,需要线程间通信。</li>
<li>有序访问:对共享资源的访问需要按某种顺序进行。</li>
</ul>
<a id="more"></a>
<p><img src="ch05.png" alt=""></p>
<p>为了实现这些同步需求,就需要使用同步原语。常见的同步原语有互斥锁、信号量、条件变量等。</p>
<p>互斥锁可以保证同一时刻只有一个线程可以访问共享资源。信号量可以限制同时访问的线程数。条件变量可以实现线程间的通信和协调。这些同步原语的使用可以避免同步问题,帮助我们正确有效地处理多线程之间的同步需求。</p>
<h2 id="Arc">Arc</h2>
<blockquote>
<p><code>Arc</code>已改放在前一章的，这一章补上。我这里介绍的时候分类不一定精确，只是方便给大家介绍各种库和并发原语，不用追求分类的准确性。</p>
</blockquote>
<p>Rust的Arc代表<code>原子引用计数</code>（Atomic Reference Counting），是一种用于多线程环境的智能指针。它允许在多个地方共享数据，同时确保线程安全性。Arc的全称是<code>std::sync::Arc</code>，属于标准库的一部分。</p>
<p>在Rust中，通常情况下，变量是被所有权管理的，但有时候我们需要在多个地方共享数据。这就是<code>Arc</code>的用武之地。它通过在堆上分配内存，并使用引用计数来跟踪数据的所有者数量，确保在不需要的时候正确地释放资源。</p>
<p>下面是一个简单的例子，演示了如何使用<code>Arc</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::Arc;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的整数</span></div><div class="line">    <span class="keyword">let</span> data = Arc::new(<span class="number">46</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建两个线程，共享对data的引用</span></div><div class="line">    <span class="keyword">let</span> thread1 = {</div><div class="line">        <span class="keyword">let</span> data = Arc::clone(&data);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 在线程中使用data</span></div><div class="line">            println!(<span class="string">"Thread 1: {}"</span>, data);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> thread2 = {</div><div class="line">        <span class="keyword">let</span> data = Arc::clone(&data);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 在另一个线程中使用data</span></div><div class="line">            println!(<span class="string">"Thread 2: {}"</span>, data);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 等待两个线程完成</span></div><div class="line">    thread1.join().unwrap();</div><div class="line">    thread2.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Arc（原子引用计数）和Rc（引用计数）都是Rust中用于多所有权的智能指针，但它们有一些关键的区别。</p>
<ul>
<li>线程安全性：<ul>
<li><code>Arc</code> 是线程安全的，可以安全地在多线程环境中共享。它使用原子操作来更新引用计数，确保并发访问时的线程安全性。</li>
<li><code>Rc</code> 不是线程安全的。它只适用于单线程环境，因为它的引用计数操作不是原子的，可能导致在多线程中的竞态条件和不安全行为。</li>
</ul>
</li>
<li>性能开销：<ul>
<li>由于Arc使用原子操作来更新引用计数，相对于Rc，Arc的性能开销更大。原子操作通常比非原子操作更昂贵。</li>
<li>Rc在单线程环境中性能更好，因为它不需要进行原子操作。</li>
</ul>
</li>
<li>可变性：<ul>
<li><code>Arc</code> 不能用于可变数据。如果需要在多线程环境中共享可变数据，通常会使用Mutex、RwLock等同步原语和<code>Arc</code>。</li>
<li><code>Rc</code> 也不能用于可变数据，因为它无法提供并发访问的安全性。</li>
</ul>
</li>
<li>引用计数减少时的行为：<ul>
<li>当Arc 的引用计数减少为零时，由于它是原子的，它会正确地释放底层资源（比如堆上的数据）。</li>
<li>Rc 在单线程中引用计数减少为零时会正确释放资源，但在多线程中可能存在问题，因为它没有考虑并发情况。</li>
</ul>
</li>
</ul>
<p>总之你记住在多线程的情况下使用<code>Arc</code>，单线程的情况下使用<code>Rc</code>就好了。</p>
<p>当你需要在多线程环境中共享可变数据时，常常会结合使用<code>Arc</code>和<code>Mutex</code>。<code>Mutex</code>（互斥锁）用于确保在任意时刻只有一个线程能够访问被锁定的数据。下面是一个简单的例子，演示了如何使用<code>Arc</code>和<code>Mutex</code>来在多线程中共享可变数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc, Mutex};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁，确保只有一个线程能够访问计数器</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Arc</code>和 <code>RefCell</code> 结合使用的场景通常发生在多线程中需要共享可变状态，但又不需要互斥锁的场合。<code>RefCell</code>允许在运行时进行借用检查，因此在单线程环境下使用时，它不会像 <code>Mutex</code> 那样引入锁的开销。</p>
<p>以下是一个使用 <code>Arc</code> 和 <code>RefCell</code> 的简单例子，演示了在多线程环境中共享可变状态,注意这个例子只是用来演示，我们并不期望num的最终结果和上面的例子一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc};</div><div class="line"><span class="keyword">use</span> std::cell::RefCell;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RefCell::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 使用RefCell获取可变引用，确保运行时借用检查</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.borrow_mut();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.borrow());</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="互斥锁_Mutex">互斥锁 Mutex</h2>
<p>互斥锁历史悠久，在很多编程语言中都有实现。</p>
<p><code>Mutex</code> 是 Rust 中的互斥锁，用于解决多线程并发访问共享数据时可能出现的竞态条件。Mutex 提供了一种机制，只有拥有锁的线程才能访问被锁定的数据，其他线程必须等待锁的释放。</p>
<h3 id="Lock">Lock</h3>
<p>在标准库中，Mutex 位于 <code>std::sync</code> 模块下。下面是一个简单的例子，演示了如何使用 Mutex：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁，确保只有一个线程能够访问计数器</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，counter 是一个 <code>Mutex</code> 保护(且包装)的可变整数，然后使用 <code>Arc</code> 来多线程共享。在每个线程中，通过 <code>counter.lock().unwrap()</code> 获取锁，确保一次只有一个线程能够修改计数器的值。这样可以确保在并发情况下不会发生竞态条件。</p>
<p>需要注意的是，<code>lock</code> 方法返回一个 <code>MutexGuard</code>，它是一个智能指针，实现了 <code>Deref</code> 和 <code>Drop</code> trait。当 <code>MutexGuard</code> 被销毁时，会自动释放锁，确保在任何情况下都能正确释放锁。</p>
<p>这里注意三个知识点：</p>
<ul>
<li>为了跨线程支持，一般<code>Mutex</code>会和<code>Arc</code>组合使用,这样<code>Mutex</code>对象在每个线程中都能安全访问</li>
<li><code>lock</code>方法返回实现了 <code>Deref</code> trait的<code>MutexGuard</code>对象，所以它会自动解引用，你可以直接调用被保护对象上的方法</li>
<li><code>MutexGuard</code>还实现了<code>Drop</code>, 所以锁会自动解锁，一般你不需要主动调用<code>drop</code>去解锁</li>
</ul>
<p>目前nightly版本的rust提供了一个实验性的方法<code>unlock</code>,功能和<code>drop</code>一样，也是释放互斥锁。</p>
<h3 id="try_lock">try_lock</h3>
<p>Mutex 的 <code>try_lock</code> 方法尝试获取锁，如果锁已经被其他线程持有，则立即返回 <code>Err</code> 而不是阻塞线程。这对于在尝试获取锁时避免线程阻塞很有用。</p>
<p>以下是一个使用 <code>try_lock</code> 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 尝试获取锁，如果获取失败就继续尝试或者放弃</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> Ok(<span class="keyword">mut</span> num) = counter.try_lock() {</div><div class="line">                *num += <span class="number">1</span>;</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                println!(<span class="string">"Thread failed to acquire lock."</span>);</div><div class="line">            }</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>try_lock</code> 方法被用于尝试获取锁。如果获取成功，线程就可以修改计数器的值，否则它会打印一条消息表示没有获取到锁。</p>
<p>需要注意的是，<code>try_lock</code> 方法返回一个 <code>Result</code>，如果获取锁成功，返回 <code>Ok</code> 包含 <code>MutexGuard</code>，否则返回 <code>Err</code>。这使得你可以根据获取锁的结果执行不同的逻辑。</p>
<h3 id="Poisoning">Poisoning</h3>
<p>在 Rust 中，<code>poisoning</code> 是一种用于处理线程 <code>panic</code> 导致的不可恢复的状态的机制。这个概念通常与 <code>Mutex</code> 和 <code>RwLock</code> 相关。<br>当一个线程在持有锁的情况下 <code>panic</code> 时，这就会导致锁进入一种不一致的状态，因为锁的内部状态可能已经被修改，而没有机会进行清理。为了避免这种情况，Rust 的标准库使用 <code>poisoning</code> 机制(形象的比喻)。<br>具体来说，在 <code>Mutex</code> 和 <code>RwLock</code> 中，当一个线程在持有锁的时候 <code>panic</code>，锁就会被标记为 <code>poisoned</code>。此后任何线程尝试获取这个锁时，都会得到一个 <code>PoisonError</code>，它包含一个标识锁是否被 <code>poisoned</code> 的标志。这样，线程可以检测到之前的 <code>panic</code>，并进行相应的处理。</p>
<p><code>Mutex</code> 通过在 <code>LockResult</code> 中包装 <code>PoisonError</code> 来表示这种情况。具体来说，<code>LockResult</code> 的 <code>Err</code> 分支是一个 <code>PoisonError</code>，其中包含一个 <code>MutexGuard</code>。你可以通过 <code>into_inner</code> 方法来获取 <code>MutexGuard</code>，然后继续操作。</p>
<p>以下是一个简单的例子，演示了锁的 &quot;poisoning&quot;，以及如何处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc, LockResult, PoisonError};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁</span></div><div class="line">            <span class="keyword">let</span> result: LockResult&lt;<span class="number">_</span>&gt; = counter.lock();</div><div class="line">            </div><div class="line">            <span class="comment">// 尝试获取锁，如果获取失败就打印错误信息</span></div><div class="line">            <span class="keyword">match</span> result {</div><div class="line">                Ok(<span class="keyword">mut</span> num) =&gt; {</div><div class="line">                    *num += <span class="number">1</span>;</div><div class="line">                    <span class="comment">// 模拟 panic</span></div><div class="line">                    <span class="keyword">if</span> *num == <span class="number">3</span> {</div><div class="line">                        panic!(<span class="string">"Simulated panic!"</span>);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                Err(poisoned) =&gt; {</div><div class="line">                    <span class="comment">// 锁被 "poisoned"，处理错误</span></div><div class="line">                    println!(<span class="string">"Thread encountered a poisoned lock: {:?}"</span>, poisoned);</div><div class="line"></div><div class="line">                    <span class="comment">// 获取 MutexGuard，继续操作</span></div><div class="line">                    <span class="keyword">let</span> <span class="keyword">mut</span> num = poisoned.into_inner();</div><div class="line">                    *num += <span class="number">1</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，当计数器的值达到3时，一个线程故意引发了 panic，其他线程在尝试获取锁时就会得到一个 <code>PoisonError</code>。在错误处理分支，我们打印错误信息，然后使用 <code>into_inner</code> 方法获取 <code>MutexGuard</code>，以确保锁被正确释放。这样其他线程就能够继续正常地使用锁。</p>
<h3 id="更快的释放互斥锁">更快的释放互斥锁</h3>
<p>前面说了，因为<code>MutexGuard</code>实现了<code>Drop</code>了，所以锁可以自动释放，可是如果锁的scope太大，我们想尽快的释放，该怎么办呢？</p>
<p>第一种方式你可以通过创建一个新的内部的作用域(<code>scope</code>)来达到类似手动释放 Mutex 的效果。在新的作用域中，<code>MutexGuard</code> 将在离开作用域时自动释放锁。这是通过作用域的离开而触发的 <code>Drop</code> trait 的实现。：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 进入一个新的作用域!!!!!!!!!!!!!!</span></div><div class="line">            {</div><div class="line">                <span class="comment">// 获取锁</span></div><div class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">                *num += <span class="number">1</span>;</div><div class="line">                <span class="comment">// MutexGuard 在这个作用域结束时自动释放锁</span></div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 在这里，锁已经被释放</span></div><div class="line">            <span class="comment">// 这里可以进行其他操作</span></div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第二种方法就是主动<code>drop</code>或者<code>unlock</code>,以下是一个演示手动释放 Mutex 的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Mutex, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来增加计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 手动释放锁!!!!!!!!</span></div><div class="line">            drop(num);</div><div class="line">        });</div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 打印最终的计数器值</span></div><div class="line">    println!(<span class="string">"Final count: {}"</span>, *counter.lock().unwrap());</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Mutex</code>是可重入锁吗？ 应该不是，但是官方文档把它标记为<a href="https://github.com/rust-lang/rust/issues/32260" target="_blank" rel="external">未定义的行为</a>，所以不要试图在同一个线程中获取两次锁, 如果你想使用可重入锁，请使用我将来要介绍的第三方并发库。同样需要注意的是读写锁<code>RWMutex</code>。</p>
<h2 id="读写锁_RWMutex">读写锁 RWMutex</h2>
<p><code>RWMutex</code> 是 Rust 中的读写锁（Read-Write Lock），允许多个线程同时获取共享数据的读取访问权限，但在写入时会排他。这意味着多个线程可以同时读取数据，但只有一个线程能够写入数据，且写入时不允许其他线程读取或写入。</p>
<p>读写锁一般使用在下面的场景中：</p>
<ul>
<li><strong>读多写少的情况</strong>： 当多个线程需要同时读取共享数据而写入操作较少时，使用 RWMutex 可以提高并发性能。多个线程可以同时获取读取锁，而写入操作会排他进行。</li>
<li><strong>只读访问和写入访问不冲突的情况</strong>： 如果在程序的逻辑中，读取操作和写入操作是独立的，没有冲突，那么使用 RWMutex 可以更好地利用并发性能。</li>
<li><strong>资源分配和释放阶段</strong>： 当需要在一段时间内只允许读取，然后在另一段时间内只允许写入时，RWMutex 可以提供更灵活的控制</li>
</ul>
<p>以下是使用 <code>RWMutex</code>的例子 ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{RwLock, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程来读取计数器的值</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> read_handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取读取锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Reader {}: {}"</span>, thread::current().id(), *num);</div><div class="line">        });</div><div class="line">        read_handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程来写入计数器的值</span></div><div class="line">    <span class="keyword">let</span> write_handle = thread::spawn(move || {</div><div class="line">        <span class="comment">// 获取写入锁</span></div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">        *num += <span class="number">1</span>;</div><div class="line">        println!(<span class="string">"Writer {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有读取线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> read_handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待写入线程完成</span></div><div class="line">    write_handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的使用和互斥锁类似，只不过需要调用<code>read()</code>方法获得读锁，使用<code>write()</code>方法获得写锁。</p>
<p>读写锁有以下的性质:</p>
<ul>
<li>多个线程可以同时获取读锁,实现并发读</li>
<li>只有一个线程可以获取写锁,写时会独占锁</li>
<li>如果已经获取了读锁,则不能获取写锁,防止数据竞争</li>
<li>如果已经获取了写锁,则不能再获取读锁或写锁,写独占时防止并发读写</li>
</ul>
<p>如果一个线程已经持有读锁，而另一个线程请求写锁，它必须等待读锁被释放。这确保在写入操作进行时，没有其他线程能够同时持有读锁。写锁确保了对共享数据的写入操作是独占的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{RwLock, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程持有读锁</span></div><div class="line">    <span class="keyword">let</span> read_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取读锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Reader {}: {}"</span>, thread::current().id(), *num);</div><div class="line"></div><div class="line">            <span class="comment">// 休眠模拟读取操作</span></div><div class="line">            thread::sleep(std::time::Duration::from_secs(<span class="number">10</span>));</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程请求写锁</span></div><div class="line">    <span class="keyword">let</span> write_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 休眠一小段时间，确保读锁已经被获取</span></div><div class="line">            thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</div><div class="line"></div><div class="line">            <span class="comment">// 尝试获取写锁</span></div><div class="line">            <span class="comment">// 注意：这里会等待读锁被释放</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">            println!(<span class="string">"Writer {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 等待读取线程和写入线程完成</span></div><div class="line">    read_handle.join().unwrap();</div><div class="line">    write_handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>更进一步，在写锁请求后，再有新的读锁请求进来，它是在等待写锁释放？还是直接获得读锁？答案是等待写锁释放，看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line"><span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">// 创建一个线程持有读锁</span></div><div class="line"><span class="keyword">let</span> read_handle = {</div><div class="line">    <span class="keyword">let</span> counter = counter.clone();</div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="comment">// 获取读锁</span></div><div class="line">        <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">        println!(<span class="string">"Reader#1: {}"</span>, *num);</div><div class="line"></div><div class="line">        <span class="comment">// 休眠模拟读取操作</span></div><div class="line">        thread::sleep(std::time::Duration::from_secs(<span class="number">10</span>));</div><div class="line">    })</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 创建一个线程请求写锁</span></div><div class="line"><span class="keyword">let</span> write_handle = {</div><div class="line">    <span class="keyword">let</span> counter = counter.clone();</div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="comment">// 休眠一小段时间，确保读锁已经被获取</span></div><div class="line">        thread::sleep(std::time::Duration::from_secs(<span class="number">1</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 尝试获取写锁</span></div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">        *num += <span class="number">1</span>;</div><div class="line">        println!(<span class="string">"Writer : Incremented counter to {}"</span>,  *num);</div><div class="line">    })</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 创建一个线程请求读锁</span></div><div class="line"><span class="keyword">let</span> read_handle_2 = {</div><div class="line">    <span class="keyword">let</span> counter = counter.clone();</div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="comment">// 休眠一小段时间，确保写锁已经被获取</span></div><div class="line">        thread::sleep(std::time::Duration::from_secs(<span class="number">2</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 尝试获取读锁</span></div><div class="line">        <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">        println!(<span class="string">"Reader#2: {}"</span>, *num);</div><div class="line">    })</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 等待读取线程和写入线程完成</span></div><div class="line">read_handle.join().unwrap();</div><div class="line">write_handle.join().unwrap();</div><div class="line">read_handle_2.join().unwrap();</div></pre></td></tr></table></figure>

<p>死锁是一种并发编程中的常见问题，可能发生在 RwLock 使用不当的情况下。一个典型的死锁场景是，一个线程在持有读锁的情况下尝试获取写锁，而其他线程持有写锁并尝试获取读锁，导致彼此相互等待。</p>
<p>以下是一个简单的例子，演示了可能导致 RwLock 死锁的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{RwLock, Arc};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个可共享的可变整数，使用RwLock包装</span></div><div class="line">    <span class="keyword">let</span> counter = Arc::new(RwLock::new(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程持有读锁，尝试获取写锁</span></div><div class="line">    <span class="keyword">let</span> read_and_write_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取读锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Reader {}: {}"</span>, thread::current().id(), *num);</div><div class="line"></div><div class="line">            <span class="comment">// 尝试获取写锁，这会导致死锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">            println!(<span class="string">"Reader {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个线程持有写锁，尝试获取读锁</span></div><div class="line">    <span class="keyword">let</span> write_and_read_handle = {</div><div class="line">        <span class="keyword">let</span> counter = Arc::clone(&counter);</div><div class="line">        thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取写锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.write().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">            println!(<span class="string">"Writer {}: Incremented counter to {}"</span>, thread::current().id(), *num);</div><div class="line"></div><div class="line">            <span class="comment">// 尝试获取读锁，这会导致死锁</span></div><div class="line">            <span class="keyword">let</span> num = counter.read().unwrap();</div><div class="line">            println!(<span class="string">"Writer {}: {}"</span>, thread::current().id(), *num);</div><div class="line">        })</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    read_and_write_handle.join().unwrap();</div><div class="line">    write_and_read_handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和Mutex一样,RwLock在panic时也会变为中毒状态。但是请注意,只有在RwLock被独占式写入锁住时发生panic,它才会中毒。如果在任意reader中发生panic,该锁则不会中毒。</p>
<p>原因是:</p>
<ul>
<li>RwLock允许多个reader同时获取读锁,读是非独占的。</li>
<li>如果任一个reader panic,其他读者依然持有读锁,所以不能将状态标记为中毒。</li>
<li>只有当前线程独占式拥有写锁时发生panic,由于没有其他线程持有锁,这时可以安全地将状态标记为中毒。</li>
</ul>
<p>所以综上,RwLock只会在独占式写入时发生panic时中毒。而reader panic不会导致中毒。这是由RwLock读写锁语义决定的。</p>
<p>这种机制可以避免不必要的中毒,因为非独占的读锁之间不会互相影响,其中任一个锁持有者panic不应影响其他读者。只有独占写锁需要特殊处理。</p>
<h2 id="一次初始化_Once">一次初始化 Once</h2>
<p><code>std::sync::Once</code> 是 Rust 中的一种并发原语，用于确保某个操作在整个程序生命周期内只执行一次。<code>Once</code> 主要用于在多线程环境中执行初始化代码，确保该代码只被执行一次，即使有多个线程同时尝试执行它。</p>
<p>以下是使用<code>Once</code>的一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Once, ONCE_INIT};</div><div class="line"></div><div class="line"><span class="keyword">static</span> INIT: Once = ONCE_INIT;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 通过 call_once 方法确保某个操作只执行一次</span></div><div class="line">    INIT.call_once(|| {</div><div class="line">        <span class="comment">// 这里放置需要执行一次的初始化代码</span></div><div class="line">        println!(<span class="string">"Initialization code executed!"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 之后再调用 call_once，初始化代码不会再次执行</span></div><div class="line">    INIT.call_once(|| {</div><div class="line">        println!(<span class="string">"This won't be printed."</span>);</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用场景:</p>
<ul>
<li><strong>全局初始化</strong>： 在程序启动时执行一些全局初始化操作，例如初始化全局变量、加载配置等。</li>
<li><strong>懒加载</strong>： 在需要时进行一次性初始化，例如懒加载全局配置。</li>
<li><strong>单例模式</strong>： 通过 <code>Once</code> 可以实现线程安全的单例模式，确保某个对象在整个程序生命周期内只被初始化一次。</li>
</ul>
<p>下面这个例子是带返回值的例子，实现懒加载全局配置的场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Once, ONCE_INIT};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">mut</span> GLOBAL_CONFIG: Option&lt;String&gt; = None;</div><div class="line"><span class="keyword">static</span> INIT: Once = ONCE_INIT;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init_global_config</span></span>() {</div><div class="line">    <span class="keyword">unsafe</span> {</div><div class="line">        GLOBAL_CONFIG = Some(<span class="string">"Initialized global configuration"</span>.to_string());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_global_config</span></span>() -&gt; &'static <span class="keyword">str</span> {</div><div class="line">    INIT.call_once(|| init_global_config());</div><div class="line">    <span class="keyword">unsafe</span> {</div><div class="line">        GLOBAL_CONFIG.as_ref().unwrap()</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    println!(<span class="string">"{}"</span>, get_global_config());</div><div class="line">    println!(<span class="string">"{}"</span>, get_global_config()); <span class="comment">// 不会重新初始化，只会输出一次</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，get_global_config 函数通过 Once 确保 init_global_config 函数只会被调用一次，从而实现了全局配置的懒加载。</p>
<p>上一章我们还介绍了<code>OnceCell</code>和<code>OnceLock</code>,它们都是同一族的单次初始化的并发原语，主要区别是:</p>
<ul>
<li><code>Once</code> 是用于确保某个操作在整个程序生命周期内只执行一次的原语。它适用于全局初始化、懒加载和单例模式等场景。</li>
<li><code>OnceCell</code> 是一个针对某种数据类型进行包装的懒加载容器，可以在需要时执行一次性初始化，并在之后提供对初始化值的访问。</li>
<li><code>OnceLock</code> 是一个可用于线程安全的懒加载的原语，类似于 <code>OnceCell</code>，但是更简单，只能存储 Copy 类型的数据。</li>
</ul>
<p><code>OnceCell</code>不是线程安全的，而<code>OnceLock</code>是线程安全的，但是<code>OnceLock</code>只能存储Copy类型的数据，而<code>OnceCell</code>可以存储任意类型的数据。</p>
<p>还有一个被广泛使用的第三方库<code>once_cell</code>,它提供了线程安全和非线程安全的两种类型的<code>OnceCell</code>, 比如下面就是一个线程安全的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> once_cell::sync::OnceCell;</div><div class="line"></div><div class="line"><span class="keyword">static</span> CELL: OnceCell&lt;String&gt; = OnceCell::new();</div><div class="line">assert!(CELL.get().is_none());</div><div class="line"></div><div class="line">std::thread::spawn(|| {</div><div class="line">    <span class="keyword">let</span> value: &String = CELL.get_or_init(|| {</div><div class="line">        <span class="string">"Hello, World!"</span>.to_string()</div><div class="line">    });</div><div class="line">    assert_eq!(value, <span class="string">"Hello, World!"</span>);</div><div class="line">}).join().unwrap();</div><div class="line"></div><div class="line"><span class="keyword">let</span> value: Option&lt;&String&gt; = CELL.get();</div><div class="line">assert!(value.is_some());</div><div class="line">assert_eq!(value.unwrap().as_str(), <span class="string">"Hello, World!"</span>);</div></pre></td></tr></table></figure>

<h2 id="屏障/栅栏_Barrier">屏障/栅栏 Barrier</h2>
<p>Barrier 是 Rust 标准库中的一种并发原语，用于在多个线程之间创建一个同步点。它允许多个线程在某个点上等待，直到所有线程都到达该点，然后它们可以同时继续执行。</p>
<p>下面是一个使用<code>Barrier</code>的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc, Barrier};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个 Barrier，指定参与同步的线程数量</span></div><div class="line">    <span class="keyword">let</span> barrier = Arc::new(Barrier::new(<span class="number">3</span>)); <span class="comment">// 在这个例子中，有 3 个线程参与同步</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">        <span class="keyword">let</span> barrier = Arc::clone(&barrier);</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 模拟一些工作</span></div><div class="line">            println!(<span class="string">"Thread {} working"</span>, id);</div><div class="line">            thread::sleep(std::time::Duration::from_secs(id <span class="keyword">as</span> <span class="keyword">u64</span>));</div><div class="line"></div><div class="line">            <span class="comment">// 线程到达同步点</span></div><div class="line">            barrier.wait();</div><div class="line"></div><div class="line">            <span class="comment">// 执行同步后的操作</span></div><div class="line">            println!(<span class="string">"Thread {} resumed"</span>, id);</div><div class="line">        });</div><div class="line"></div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个 <code>Barrier</code>，并指定了参与同步的线程数量为 3。然后，创建了三个线程，每个线程模拟一些工作，然后调用 <code>barrier.wait()</code> 来等待其他线程。当所有线程都调用了 wait 后，它们同时继续执行。</p>
<p>使用场景</p>
<ul>
<li><strong>并行计算</strong>： 当需要确保多个线程在某个点上同步，以便执行某些计算或任务时，可以使用 <code>Barrier</code>。</li>
<li><strong>迭代步骤同步</strong>： 在一些算法中，可能需要多个步骤，每个步骤的结果都依赖于其他步骤的完成。<code>Barrier</code> 可以用于确保所有线程完成当前步骤后再继续下一步。</li>
<li><strong>协同工作的阶段</strong>： 在多阶段的任务中，可以使用 Barrier 来同步各个阶段。</li>
</ul>
<p><code>Barrier</code> 的灵活性使得它在协调多个线程的执行流程时非常有用。</p>
<p>那么，Barrier可以循环使用吗？<br>一旦所有线程都通过 wait 方法达到同步点后，Barrier 就被重置，可以再次使用。这种重置操作是自动的。</p>
<p>当所有线程都调用 wait 方法后，Barrier 的内部状态会被重置，下一次调用 wait 方法时，线程会重新被阻塞，直到所有线程再次到达同步点。这样，Barrier 可以被循环使用，用于多轮的同步。</p>
<p>以下是一个简单的示例，演示了 Barrier 的循环使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> barrier = Arc::new(Barrier::new(<span class="number">10</span>));</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {</div><div class="line">    <span class="keyword">let</span> barrier = barrier.clone();</div><div class="line">    handles.push(thread::spawn(move || {</div><div class="line">        println!(<span class="string">"before wait1"</span>);</div><div class="line">        <span class="keyword">let</span> dur = rand::thread_rng().gen_range(<span class="number">100</span>..<span class="number">1000</span>);</div><div class="line">        thread::sleep(std::time::Duration::from_millis(dur));</div><div class="line"></div><div class="line">        <span class="comment">//step1</span></div><div class="line">        barrier.wait();</div><div class="line">        println!(<span class="string">"after wait1"</span>);</div><div class="line">        thread::sleep(time::Duration::from_secs(<span class="number">1</span>));</div><div class="line"></div><div class="line">        <span class="comment">//step2</span></div><div class="line">        barrier.wait();</div><div class="line">        println!(<span class="string">"after wait2"</span>);</div><div class="line">    }));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">    handle.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="条件变量_Condvar">条件变量 Condvar</h2>
<p><code>Condvar</code> 是 Rust 标准库中的条件变量（Condition Variable），用于在多线程之间进行线程间的协调和通信。条件变量允许线程等待某个特定的条件成立，当条件满足时，线程可以被唤醒并继续执行。</p>
<p>以下是 Condvar 的一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::{Arc, Mutex, Condvar};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个 Mutex 和 Condvar，用于共享状态和线程协调</span></div><div class="line">    <span class="keyword">let</span> mutex = Arc::new(Mutex::new(<span class="keyword">false</span>));</div><div class="line">    <span class="keyword">let</span> condvar = Arc::new(Condvar::new());</div><div class="line"></div><div class="line">    <span class="comment">// 创建多个线程</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = vec![];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> id <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">        <span class="keyword">let</span> mutex = Arc::clone(&mutex);</div><div class="line">        <span class="keyword">let</span> condvar = Arc::clone(&condvar);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(move || {</div><div class="line">            <span class="comment">// 获取 Mutex 锁</span></div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> guard = mutex.lock().unwrap();</div><div class="line"></div><div class="line">            <span class="comment">// 线程等待条件变量为 true</span></div><div class="line">            <span class="keyword">while</span> !*guard {</div><div class="line">                guard = condvar.wait(guard).unwrap();</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 条件满足后执行的操作</span></div><div class="line">            println!(<span class="string">"Thread {} woke up"</span>, id);</div><div class="line">        });</div><div class="line"></div><div class="line">        handles.push(handle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 模拟条件满足后唤醒等待的线程</span></div><div class="line">    thread::sleep(std::time::Duration::from_secs(<span class="number">2</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 修改条件，并唤醒等待的线程</span></div><div class="line">    {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> guard = mutex.lock().unwrap();</div><div class="line">        *guard = <span class="keyword">true</span>;</div><div class="line">        condvar.notify_all();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {</div><div class="line">        handle.join().unwrap();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个 <code>Mutex</code> 和 <code>Condvar</code>，其中 <code>Mutex</code> 用于保护共享状态（条件），而 <code>Condvar</code> 用于等待和唤醒线程。多个线程在 <code>Mutex</code> 上加锁后，通过 <code>condvar.wait()</code> 方法等待条件满足，然后在主线程中修改条件，并通过 <code>condvar.notify_all()</code> 唤醒所有等待的线程。</p>
<p>使用场景</p>
<ul>
<li><strong>线程间同步</strong>： <code>Condvar</code> 可以用于线程之间的同步，使得线程能够等待某个条件的成立而不是轮询检查。</li>
<li><strong>生产者-消费者模型</strong>： 在多线程环境中，生产者线程可以通过条件变量通知消费者线程有新的数据产生。</li>
<li><strong>线程池</strong>： 在线程池中，任务线程可以等待条件变量，等待新的任务到达时被唤醒执行。</li>
</ul>
<p>需要注意的是，使用 <code>Condvar</code> 时，通常需要配合 <code>Mutex</code> 使用，以确保在等待和修改条件时的线程安全性。</p>
<p><code>Condvar</code> 可以通过调用 <code>notify_one()</code> 方法来发出信号。当 <code>notify_one()</code> 方法被调用时，<code>Condvar</code> 会随机选择一个正在等待信号的线程，并释放该线程。<br><code>Condvar</code> 也可以通过调用 <code>notify_all()</code> 方法来发出信号。当 <code>notify_all()</code> 方法被调用时，<code>Condvar</code> 会释放所有正在等待信号的线程。</p>
<h2 id="LazyCell_和_LazyLock">LazyCell 和 LazyLock</h2>
<p>我们介绍了<code>OnceCell</code>和<code>OnceLock</code>,我们再介绍两个类似的用于懒加载的并发原语<code>LazyCell</code>和<code>LazyLock</code>。</p>
<p>Rust 中的 LazyCell 和 LazyLock 都是用于懒惰初始化对象的工具。LazyCell 用于懒惰初始化值，LazyLock 用于懒惰初始化资源。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>初始化时机</th>
<th>线程安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>LazyCell</td>
<td>懒惰初始化值</td>
<td>第一次访问</td>
<td>否</td>
</tr>
<tr>
<td>LazyLock</td>
<td>懒惰初始化资源</td>
<td>第一次获取锁</td>
<td>是</td>
</tr>
<tr>
<td>OnceCell</td>
<td>懒惰初始化单例值</td>
<td>第一次调用</td>
<td>get_or_init() 方法</td>
<td>否</td>
</tr>
<tr>
<td>OnceLock</td>
<td>懒惰初始化互斥锁</td>
<td>第一次调用</td>
<td>lock() 方法</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="Exclusive">Exclusive</h2>
<p>Rust 中的 <code>Exclusive</code> 是一个用于保证某个资源只被一个线程访问的工具。<code>Exclusive</code> 可以通过导入 <code>std::sync::Exclusive</code> 来使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> exclusive = Exclusive::new(<span class="number">92</span>);</div><div class="line">println!(<span class="string">"ready"</span>);</div><div class="line">std::thread::spawn(move || {</div><div class="line">    <span class="keyword">let</span> counter = exclusive.get_mut();</div><div class="line">    println!(<span class="string">"{}"</span>, *counter);</div><div class="line">    *counter = <span class="number">100</span>;</div><div class="line">}).join().unwrap();</div></pre></td></tr></table></figure>

<p>和Mutex有什么区别？<code>Exclusive</code> 仅提供对底层值的<strong>可变</strong>访问，也称为对底层值的独占访问。它<strong>不提供</strong>对底层值的不可变或共享访问。</p>
<p>虽然这可能看起来不太有用，但它允许 <code>Exclusive</code> 无条件地实现 <code>Sync</code>。事实上，<code>Sync</code> 的安全要求是，对于 <code>Exclusive</code> 而言，它必须可以安全地跨线程共享，也就是说，&amp;Exclusive 跨越线程边界时必须是安全的。出于设计考虑，&amp;Exclusive 没有任何 API，使其无用，因此无害，因此内存安全。</p>
<p>这个类型还是一个nightly的实验性特性，所以我们不妨等它稳定后在学习和使用。</p>
<h2 id="mpsc">mpsc</h2>
<p><code>mpsc</code> 是 Rust 标准库中的一个模块，提供了多生产者、单消费者（Multiple Producers, Single Consumer）的消息传递通道。mpsc 是 multiple-producer, single-consumer 的缩写。<br>这个模块基于channel的基于消息传递的通讯，具体定义了三个类型：</p>
<ul>
<li><code>Sender</code>：发送者，用于异步发送消息。</li>
<li><code>SyncSender</code>：同步发送者，用于同步发送消息。</li>
<li><code>Receiver</code>：接收者，用于从同步channel或异步channel中接收消息，只能有一个线程访问。</li>
</ul>
<p><code>Sender</code> 或 <code>SyncSender</code> 用于向 <code>Receiver</code> 发送数据。两种 sender 都是可clone的(多生产者),这样多个线程就可以同时向一个 receiver(单消费者)发送。</p>
<p>这些通道有两种类型:</p>
<ul>
<li>异步的,无限缓冲区的通道。<code>channel</code> 函数将返回一个  <code>(Sender, Receiver)</code> 元组,其中所有发送将是异步的(永不阻塞)。该通道在概念上具有无限的缓冲区。</li>
<li>同步的,有界的通道。<code>sync_channel</code> 函数将返回一个 <code>(SyncSender, Receiver)</code> 元组,待发送消息的存储区是一个固定大小的预分配缓冲区。所有发送将是同步的,通过阻塞直到有空闲的缓冲区空间。注意绑定大小为 0 也是允许的,这将使通道变成一个“约定”通道,每个发送方原子地将一条消息交给接收方。</li>
</ul>
<p>使用场景</p>
<ul>
<li><strong>并发消息传递</strong>： 适用于多个线程（生产者）向一个线程（消费者）发送消息的场景。</li>
<li><strong>任务协调</strong>： 用于协调多个并发任务的执行流程。</li>
</ul>
<p>每当看到rust的mpsc,我总是和Go的channel作比较，事实上rust的channel使用起来也非常的简单。</p>
<p>一个简单的channel例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</div><div class="line"></div><div class="line"><span class="comment">// Create a simple streaming channel</span></div><div class="line"><span class="keyword">let</span> (tx, rx) = channel();</div><div class="line">thread::spawn(move|| {</div><div class="line">    tx.send(<span class="number">10</span>).unwrap();</div><div class="line">});</div><div class="line">assert_eq!(rx.recv().unwrap(), <span class="number">10</span>);</div></pre></td></tr></table></figure>

<p>一个多生产者单消费者的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</div><div class="line"></div><div class="line"><span class="comment">// Create a shared channel that can be sent along from many threads</span></div><div class="line"><span class="comment">// where tx is the sending half (tx for transmission), and rx is the receiving</span></div><div class="line"><span class="comment">// half (rx for receiving).</span></div><div class="line"><span class="keyword">let</span> (tx, rx) = channel();</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {</div><div class="line">    <span class="keyword">let</span> tx = tx.clone();</div><div class="line">    thread::spawn(move|| {</div><div class="line">        tx.send(i).unwrap();</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {</div><div class="line">    <span class="keyword">let</span> j = rx.recv().unwrap();</div><div class="line">    assert!(<span class="number">0</span> &lt;= j && j &lt; <span class="number">10</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一个同步channel的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::mpsc::sync_channel;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="keyword">let</span> (tx, rx) = sync_channel(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</div><div class="line">    <span class="comment">// It would be the same without thread and clone here</span></div><div class="line">    <span class="comment">// since there will still be one `tx` left.</span></div><div class="line">    <span class="keyword">let</span> tx = tx.clone();</div><div class="line">    <span class="comment">// cloned tx dropped within thread</span></div><div class="line">    thread::spawn(move || tx.send(<span class="string">"ok"</span>).unwrap());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Drop the last sender to stop `rx` waiting for message.</span></div><div class="line"><span class="comment">// The program will not complete if we comment this out.</span></div><div class="line"><span class="comment">// **All** `tx` needs to be dropped for `rx` to have `Err`.</span></div><div class="line">drop(tx);</div><div class="line"></div><div class="line"><span class="comment">// Unbounded receiver waiting for all senders to complete.</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">let</span> Ok(msg) = rx.recv() {</div><div class="line">    println!(<span class="string">"{msg}"</span>);</div><div class="line">}</div><div class="line"></div><div class="line">println!(<span class="string">"completed"</span>);</div></pre></td></tr></table></figure>

<p>发送端释放的情况下，receiver会收到error:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::mpsc::channel;</div><div class="line"></div><div class="line"><span class="comment">// The call to recv() will return an error because the channel has already</span></div><div class="line"><span class="comment">// hung up (or been deallocated)</span></div><div class="line"><span class="keyword">let</span> (tx, rx) = channel::&lt;<span class="keyword">i32</span>&gt;();</div><div class="line">drop(tx);</div><div class="line">assert!(rx.recv().is_err());</div></pre></td></tr></table></figure>

<p>在 Rust 标准库中，目前没有提供原生的 <code>MPMC</code>（Multiple Producers, Multiple Consumers）通道。<code>std::sync::mpsc</code> 模块提供的是单一消费者的通道，主要是出于设计和性能的考虑。</p>
<p>设计上，MPSC 通道的实现相对较简单，可以更容易地满足特定的性能需求，并且在很多情况下是足够的。同时，MPSC 通道的使用场景更为常见，例如在线程池中有一个任务队列，多个生产者将任务推送到队列中，而单个消费者负责执行这些任务。</p>
<p>未来我会在专门的章节中介绍更多的第三方库提供的channel以及类似的同步原语，如<code>oneshot</code>、<code>broadcaster</code>、<code>mpmc</code>等。</p>
<p>依照这个<a href="https://crates.io/crates/mpmc" target="_blank" rel="external">mpmc</a>的介绍，以前的rust标准库应该是实现了<code>mpmc</code>,这个库就是从老的标准库中抽取出来的。</p>
<h2 id="信号量_Semaphore">信号量 Semaphore</h2>
<p>标准库中没有Semaphore的实现，单这个是在是非常通用的一个并发原语，理论上也应该在这里介绍。</p>
<p>但是这一章内容也非常多了，而且我也会在tokio中介绍信号两，在一个专门的特殊并发原语(第十四章或者更多)，所以不在这个章节专门介绍了。</p>
<p>这个章节还是偏重标准库的并发原语的介绍。</p>
<h2 id="原子操作_atomic">原子操作 atomic</h2>
<p>Rust 中的原子操作（Atomic Operation）是一种特殊的操作，可以在多线程环境中以原子方式进行，即不会被其他线程的操作打断。原子操作可以保证数据的线程安全性，避免数据竞争。</p>
<p>在 Rust 中，<code>std::sync::atomic</code> 模块提供了一系列用于原子操作的类型和函数。原子操作是一种特殊的操作，可以在多线程环境中安全地执行，而不需要使用额外的锁。</p>
<p>atomic 可以用于各种场景，例如：</p>
<ul>
<li>保证某个值的一致性。</li>
<li>防止多个线程同时修改某个值。</li>
<li>实现互斥锁。</li>
</ul>
<p>目前Rust原子类型遵循与<a href="https://en.cppreference.com/w/cpp/atomic" target="_blank" rel="external">C++20 atomic</a>相同的规则,具体来说就是<code>atomic_ref</code>。基本上,创建Rust原子类型的一个共享引用,相当于在C++中创建一个<code>atomic_ref</code>;当共享引用的生命周期结束时,<code>atomic_ref</code>也会被销毁。(一个被独占拥有或者位于可变引用后面的Rust原子类型,并不对应C++中的“原子对象”,因为它可以通过非原子操作被访问。)</p>
<p>这个模块为一些基本类型定义了原子版本,包括<code>AtomicBool</code>、<code>AtomicIsize</code>、<code>AtomicUsize</code>、<code>AtomicI8</code>、<code>AtomicU16</code>等。原子类型提供的操作在正确使用时可以在线程间同步更新。<br><img src="05/atomic.png" alt=""></p>
<p>每个方法都带有一个<a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html" target="_blank" rel="external">Ordering</a>参数,表示该操作的内存屏障的强度。这些排序与<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="external">C++20原子排序</a>相同。更多信息请参阅<a href="https://doc.rust-lang.org/nomicon/atomics.html" target="_blank" rel="external">nomicon</a>。</p>
<p>原子变量在线程间安全共享(实现了Sync),但它本身不提供共享机制,遵循Rust的线程模型。共享一个原子变量最常见的方式是把它放到一个<code>Arc</code>中(一个原子引用计数的共享指针)。</p>
<p>原子类型可以存储在静态变量中,使用像<code>AtomicBool::new</code>这样的常量初始化器初始化。原子静态变量通常用于懒惰的全局初始化。</p>
<p>我们已经说了，这个模块为一些基本类型定义了原子版本，包括<code>AtomicBool</code>、<code>AtomicIsize</code>、<code>AtomicUsize</code>、<code>AtomicI8</code>、<code>AtomicU16</code>等，其实每一种类似的方法都比较类似的，所以我们以<code>AtomicI64</code>介绍。<br>可以通过<code>pub const fn new(v: i64) -&gt; AtomicI64</code>得到一个<code>AtomicI64</code>对象， <code>AtomicI64</code>定义了一些方法，用于对原子变量进行操作，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// i64 和 AtomicI64的转换，以及一组对象之间的转换</span></div><div class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_ptr</span></span>&lt;'a&gt;(ptr: *<span class="keyword">mut</span> <span class="keyword">i64</span>) -&gt; &'a AtomicI64</div><div class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_ptr</span></span>(&<span class="keyword">self</span>) -&gt; *<span class="keyword">mut</span> <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut</span></span>(&<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &<span class="keyword">mut</span> <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_mut</span></span>(v: &<span class="keyword">mut</span> <span class="keyword">i64</span>) -&gt; &<span class="keyword">mut</span> AtomicI64</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_mut_slice</span></span>(this: &<span class="keyword">mut</span> [AtomicI64]) -&gt; &<span class="keyword">mut</span> [<span class="keyword">i64</span>]</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">from_mut_slice</span></span>(v: &<span class="keyword">mut</span> [<span class="keyword">i64</span>]) -&gt; &<span class="keyword">mut</span> [AtomicI64]</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">into_inner</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">i64</span></div><div class="line"></div><div class="line"><span class="comment">// 原子操作</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>(&<span class="keyword">self</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">store</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering)</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">swap</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compare_and_swap</span></span>(&<span class="keyword">self</span>, current: <span class="keyword">i64</span>, new: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span> <span class="comment">//   弃用</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compare_exchange</span></span>(</div><div class="line">    &<span class="keyword">self</span>,</div><div class="line">    current: <span class="keyword">i64</span>,</div><div class="line">    new: <span class="keyword">i64</span>,</div><div class="line">    success: Ordering,</div><div class="line">    failure: Ordering</div><div class="line">) -&gt; Result&lt;<span class="keyword">i64</span>, <span class="keyword">i64</span>&gt;</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compare_exchange_weak</span></span>(</div><div class="line">    &<span class="keyword">self</span>,</div><div class="line">    current: <span class="keyword">i64</span>,</div><div class="line">    new: <span class="keyword">i64</span>,</div><div class="line">    success: Ordering,</div><div class="line">    failure: Ordering</div><div class="line">) -&gt; Result&lt;<span class="keyword">i64</span>, <span class="keyword">i64</span>&gt;</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_add</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_sub</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_and</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_nand</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_or</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_xor</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_update</span></span>&lt;F&gt;(</div><div class="line">    &<span class="keyword">self</span>,</div><div class="line">    set_order: Ordering,</div><div class="line">    fetch_order: Ordering,</div><div class="line">    f: F</div><div class="line">) -&gt; Result&lt;<span class="keyword">i64</span>, <span class="keyword">i64</span>&gt;</div><div class="line">where</div><div class="line">    F: FnMut(<span class="keyword">i64</span>) -&gt; Option&lt;<span class="keyword">i64</span>&gt;,</div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_max</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fetch_min</span></span>(&<span class="keyword">self</span>, val: <span class="keyword">i64</span>, order: Ordering) -&gt; <span class="keyword">i64</span></div></pre></td></tr></table></figure>

<p>如果你有一点原子操作的基础，就不难理解这些原子操作以及它们的变种了:</p>
<ul>
<li><code>store</code>:原子写入</li>
<li><code>load</code>:原子读取</li>
<li><code>swap</code>:原子交换</li>
<li><code>compare_and_swap</code>:原子比较并交换</li>
<li><code>fetch_add</code>:原子加法后返回旧值</li>
</ul>
<p>下面这个例子演示了<code>AtomicI64</code>的基本原子操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicI64, Ordering};</div><div class="line"></div><div class="line"><span class="keyword">let</span> atomic_num = AtomicI64::new(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 原子加载</span></div><div class="line"><span class="keyword">let</span> num = atomic_num.load(Ordering::Relaxed);</div><div class="line"></div><div class="line"><span class="comment">// 原子加法并返回旧值 </span></div><div class="line"><span class="keyword">let</span> old = atomic_num.fetch_add(<span class="number">10</span>, Ordering::SeqCst);</div><div class="line"></div><div class="line"><span class="comment">// 原子比较并交换  </span></div><div class="line">atomic_num.compare_and_swap(old, <span class="number">100</span>, Ordering::SeqCst);</div><div class="line"></div><div class="line"><span class="comment">// 原子交换  </span></div><div class="line"><span class="keyword">let</span> swapped = atomic_num.swap(<span class="number">200</span>, Ordering::Release);</div><div class="line"></div><div class="line"><span class="comment">// 原子存储</span></div><div class="line">atomic_num.store(<span class="number">1000</span>, Ordering::Relaxed);</div></pre></td></tr></table></figure>

<p>上面示例了:</p>
<ul>
<li>load: 原子加载</li>
<li>fetch_add: 原子加法并返回旧值</li>
<li>compare_and_swap: 原子比较并交换</li>
<li>swap: 原子交换</li>
<li>store: 原子存储</li>
</ul>
<p>这些原子操作都可以确保线程安全,不会出现数据竞争。</p>
<p>不同的<code>Ordering</code>表示内存序不同强度的屏障,可以根据需要选择。</p>
<p><code>AtomicI64</code>提供了丰富的原子操作,可以实现无锁的并发算法和数据结构</p>
<h3 id="原子操作的_Ordering">原子操作的 Ordering</h3>
<p>在 Rust 中，<code>Ordering</code> 枚举用于指定原子操作时的内存屏障（memory ordering）。这与 C++ 的内存模型中的原子操作顺序性有一些相似之处，但也有一些不同之处。下面是 Ordering 的三个主要成员以及它们与 C++ 中的内存顺序的对应关系：</p>
<ol>
<li><strong>Ordering::Relaxed</strong><ul>
<li><strong>Rust（Ordering::Relaxed）</strong>： 最轻量级的内存屏障，没有对执行顺序进行强制排序。允许编译器和处理器在原子操作周围进行指令重排。\</li>
<li><strong>C++（memory_order_relaxed</strong>）： 具有相似的语义，允许编译器和处理器在原子操作周围进行轻量级的指令重排。</li>
</ul>
</li>
<li><strong>Ordering::Acquire</strong><ul>
<li><strong>Rust（Ordering::Acquire）</strong>： 插入一个获取内存屏障，防止后续的读操作被重排序到当前操作之前。确保当前操作之前的所有读取操作都在当前操作之前执行。</li>
<li><strong>C++（memory_order_acquire）</strong>： 在 C++ 中，memory_order_acquire 表示获取操作，确保当前操作之前的读取操作都在当前操作之前执行。</li>
</ul>
</li>
<li><strong>Ordering::Release</strong><ul>
<li><strong>Rust（Ordering::Release）</strong>： 插入一个释放内存屏障，防止之前的写操作被重排序到当前操作之后。确保当前操作之后的所有写操作都在当前操作之后执行。</li>
<li><strong>C++（memory_order_release）</strong>： 在 C++ 中，memory_order_release 表示释放操作，确保之前的写操作都在当前操作之后执行。</li>
</ul>
</li>
<li><strong>Ordering::AcqRel</strong><ul>
<li><strong>Rust（Ordering::AcqRel）</strong>： 插入一个获取释放内存屏障，既确保当前操作之前的所有读取操作都在当前操作之前执行，又确保之前的所有写操作都在当前操作之后执行。这种内存屏障提供了一种平衡，适用于某些获取和释放操作交替进行的场景。</li>
<li><strong>C++（memory_order_acq_rel）</strong>： 也表示获取释放操作，它是获取和释放的组合。确保当前操作之前的所有读取操作都在当前操作之前执行，同时确保之前的所有写操作都在当前操作之后执行。</li>
</ul>
</li>
<li><strong>Ordering::SeqCst</strong><ul>
<li><strong>Rust（Ordering::SeqCst</strong>）： 插入一个全序内存屏障，保证所有线程都能看到一致的操作顺序。是最强的内存顺序，用于实现全局同步。</li>
<li><strong>C++（memory_order_seq_cst）</strong>： 在 C++ 中，memory_order_seq_cst 也表示全序操作，保证所有线程都能看到一致的操作顺序。是 C++ 中的最强的内存顺序。</li>
</ul>
</li>
</ol>
<p>合理选择Ordering可以最大程度提高性能,同时保证需要的内存序约束。</p>
<p>但是如何合理的选择，这就依赖开发者的基本账功了，使用原子操作时需要小心，确保正确地选择适当的 Ordering，以及避免竞态条件和数据竞争。</p>
<p>像Go语言，直接使用了<code>Ordering::SeqCst</code>作为它的默认的内存屏障，开发者使用起来就没有心智负担了，但是你如果想更精细化的使用<code>Ordering</code>,请确保你一定清晰的了解你的代码逻辑和Ordering的意义。</p>
<h3 id="Ordering::Relaxed">Ordering::Relaxed</h3>
<p><code>Ordering::Relaxed</code> 是最轻量级的内存顺序，允许编译器和处理器在原子操作周围进行指令重排，不提供强制的执行顺序。这通常在对程序执行的顺序没有严格要求时使用，以获得更高的性能。</p>
<p>以下是一个简单的例子，演示了 Ordering::Relaxed 的用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 这里可能会有指令重排，因为使用了 Ordering::Relaxed</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::Relaxed);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，检查布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 这里可能会有指令重排，因为使用了 Ordering::Relaxed</span></div><div class="line">        <span class="keyword">let</span> value = atomic_bool.load(Ordering::Relaxed);</div><div class="line">        println!(<span class="string">"Received value: {}"</span>, value);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Ordering::Acquire">Ordering::Acquire</h3>
<p><code>Ordering::Acquire</code> 在 Rust 中表示插入一个获取内存屏障，确保当前操作之前的所有读取操作都在当前操作之前执行。这个内存顺序常常用于同步共享数据，以确保线程能够正确地观察到之前的写入操作。</p>
<p>以下是一个使用 <code>Ordering::Acquire</code> 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::Release);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::Acquire) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 Acquire 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Ordering::Release">Ordering::Release</h3>
<p><code>Ordering::Release</code> 在 Rust 中表示插入一个释放内存屏障，确保之前的所有写入操作都在当前操作之后执行。这个内存顺序通常用于同步共享数据，以确保之前的写入操作对其他线程可见。</p>
<p>以下是一个使用 <code>Ordering::Release</code> 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::Release);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::Acquire) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 Release 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程使用 <code>store</code> 方法将布尔值设置为 <code>true</code>，而消费者线程使用 <code>load</code> 方法等待并读取布尔值的状态。由于使用了 <code>Ordering::Release</code>，在生产者线程设置布尔值之后，会插入释放内存屏障，确保之前的所有写入操作都在当前操作之后执行。这确保了消费者线程能够正确地观察到生产者线程的写入操作。</p>
<h3 id="Ordering::AcqRel">Ordering::AcqRel</h3>
<p><code>Ordering::AcqRel</code> 在 Rust 中表示插入一个获取释放内存屏障，即同时包含获取和释放操作。它确保当前操作之前的所有读取操作都在当前操作之前执行，并确保之前的所有写入操作都在当前操作之后执行。这个内存顺序通常用于同步共享数据，同时提供了一些平衡，适用于需要同时执行获取和释放操作的场景。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::AcqRel);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::AcqRel) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 AcqRel 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程使用 store 方法将布尔值设置为 true，而消费者线程使用 load 方法等待并读取布尔值的状态。由于使用了 Ordering::AcqRel，在生产者线程设置布尔值之后，会插入获取释放内存屏障，确保之前的所有读取操作都在当前操作之前执行，同时确保之前的所有写入操作都在当前操作之后执行。这确保了消费者线程能够正确地观察到生产者线程的写入操作。</p>
<h3 id="Ordering::SeqCst">Ordering::SeqCst</h3>
<p><code>Ordering::SeqCst</code> 在 Rust 中表示插入一个全序内存屏障，保证所有线程都能看到一致的操作顺序。这是最强的内存顺序，通常用于实现全局同步。</p>
<p>以下是一个使用 Ordering::SeqCst 的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::atomic::{AtomicBool, Ordering};</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 创建一个原子布尔值</span></div><div class="line">    <span class="keyword">let</span> atomic_bool = AtomicBool::new(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个生产者线程，设置布尔值为 true</span></div><div class="line">    <span class="keyword">let</span> producer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 设置布尔值为 true</span></div><div class="line">        atomic_bool.store(<span class="keyword">true</span>, Ordering::SeqCst);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个消费者线程，读取布尔值的状态</span></div><div class="line">    <span class="keyword">let</span> consumer_thread = thread::spawn(move || {</div><div class="line">        <span class="comment">// 等待直到读取到布尔值为 true</span></div><div class="line">        <span class="keyword">while</span> !atomic_bool.load(Ordering::SeqCst) {</div><div class="line">            <span class="comment">// 这里可能进行自旋，直到获取到 SeqCst 顺序的布尔值</span></div><div class="line">            <span class="comment">// 注意：在实际应用中，可以使用更高级的同步原语而不是自旋</span></div><div class="line">        }</div><div class="line"></div><div class="line">        println!(<span class="string">"Received value: true"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程完成</span></div><div class="line">    producer_thread.join().unwrap();</div><div class="line">    consumer_thread.join().unwrap();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程使用 <code>store</code> 方法将布尔值设置为 true，而消费者线程使用 <code>load</code> 方法等待并读取布尔值的状态。由于使用了 <code>Ordering::SeqCst</code>，在生产者线程设置布尔值之后，会插入全序内存屏障，确保所有线程都能看到一致的操作顺序。这确保了消费者线程能够正确地观察到生产者线程的写入操作。<code>SeqCst</code> 是最强的内存顺序，提供了最高级别的同步保证。</p>
<p>在Rust中,<code>Ordering::Acquire</code>内存顺序通常与<code>Ordering::Release</code>配合使用。</p>
<p><code>Ordering::Acquire</code>和<code>Ordering::Release</code>之间形成<code>happens-before</code>关系,可以实现不同线程之间的同步。</p>
<p>其典型用法是:</p>
<ul>
<li>当一个线程使用Ordering::Release写一个变量时,这给写操作建立一个释放屏障。</li>
<li>其他线程使用Ordering::Acquire读这个变量时,这给读操作建立一个获取屏障。</li>
<li>获取屏障确保读操作必须发生在释放屏障之后。</li>
</ul>
<p>这样就可以实现:</p>
<ul>
<li>写线程确保写发生在之前的任何读之前</li>
<li>读线程可以看到最新的写入值</li>
</ul>
<p>此外, <code>Ordering::AcqRel</code>也经常被用来同时具有两者的语义。</p>
<p>如果用<code>happens-before</code>描述这五种内存顺序，那么:</p>
<ul>
<li>Relaxed: 没有happens-before关系</li>
<li>Release: 对于给定的写操作A,该释放操作happens-before读操作B,当B读取的是A写入的最新值。和<code>Acquire</code>配套使用。</li>
<li>Acquire: 对于给定的读操作A,该获取操作happens-after写操作B,当A读取的是B写入的最新值。和<code>Release</code>配套使用。</li>
<li>AcqRel: 同时满足Acquire和Release的happens-before关系。</li>
<li>SeqCst: 所有的SeqCst操作之间都存在happens-before关系,形成一个全序。</li>
</ul>
<p><code>happens-before</code>关系表示对给定两个操作A和B:</p>
<ul>
<li>如果<code>A happens-before B</code>,那么A对所有线程可见,必须先于B执行。</li>
<li>如果没有<code>happens-before</code>关系,则A和B之间可能存在重排序和可见性问题。</li>
</ul>
<p><code>Release</code>建立写之前的<code>happens-before</code>关系,<code>Acquire</code>建立读之后的关系。两者搭配可以实现写入对其他线程可见。、<br><code>SeqCst</code>强制一个全序,所有操作都是有序的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>同步是多线程程序中的一个重要概念。在多线程环境下,多个线程可能同时访问某个共享资源,这就可能导致数据竞争或者数据不一致的问题。为了保证数据安全,需要进行同步操作。</p>
<p>常见的同步需求包括:</p>
<ul>
<li>互斥:线程在使用共享资源时,同一时刻只允许一个线程访问共享资源,在一个线程使用时,其他线程需要等待,不能同时访问,需要互斥访问。</li>
<li>限制同时访问线程数:对某些共享资源,可能需要限制同一时刻访问的线程数。</li>
<li>线程间通信:一个线程需要基于另一个线程的处理结果才能继续执行,需要线程间通信。</li>
<li>有序访问:对共享资源的访问需要按某种顺序进行。</li>
</ul>
]]>
    
    </summary>
    
      <category term="Rust" scheme="https://colobu.com/categories/Rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不看就落后了，Go 1.22 中更好的http router]]></title>
    <link href="https://colobu.com/2023/10/19/better-http-server-routing-in-go-112/"/>
    <id>https://colobu.com/2023/10/19/better-http-server-routing-in-go-112/</id>
    <published>2023-10-19T14:45:18.000Z</published>
    <updated>2023-12-11T05:37:05.056Z</updated>
    <content type="html"><![CDATA[<p>很多人为了使用Go web中更好的路由，会使用第三方的库 <code>httprouter</code>、<code>gorilla/mux</code>等。在明年的春节左右发布的Go 1.22中，Go官方终于对标准库中的<code>http.ServeMux</code>下手了，对它的功能进行了优化，终于可以抛弃第三方库了。</p>
<p>一个令人兴奋的<a href="https://github.com/golang/go/issues/61410" target="_blank" rel="external">提案</a>预计将在Go 1.22中实现—— 增强标准库<code>net/http</code>包中默认HTTP服务多路复用器的模式匹配能力。</p>
<a id="more"></a>
<p>现有的多路复用器（<code>http.ServeMux</code>）提供了基本的路径匹配，但除此之外没有太多。这导致了一堆的第三方库实现了更强大的功能。</p>
<p>Go 1.22中的新多路复用器将通过提供高级匹配能力来显著弥合与第三方库的差距。在这篇短文中，我将快速介绍新的多路复用器（<code>mux</code>）。我还将给出REST服务器的示例，并比较新的标准库<code>mux</code>与<code>gorilla/mux</code>的性能。</p>
<h2 id="使用新的mux">使用新的mux</h2>
<p>如果你曾经在Go中使用过第三方 mux/router（比如<code>gorilla/mux</code>），那么使用新的标准mux将是简单而熟悉的。从阅读它的文档开始——它简短丝滑。</p>
<p>让我们来看几个基本用法示例。我们的第一个示例演示了mux的一些新模式匹配功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">  <span class="string">"fmt"</span></div><div class="line">  <span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">  mux := http.NewServeMux()</div><div class="line">  mux.HandleFunc(<span class="string">"GET /path/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprint(w, <span class="string">"got path\n"</span>)</div><div class="line">  })</div><div class="line"></div><div class="line">  mux.HandleFunc(<span class="string">"/task/{id}/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    id := r.PathValue(<span class="string">"id"</span>)</div><div class="line">    fmt.Fprintf(w, <span class="string">"handling task with id=%v\n"</span>, id)</div><div class="line">  })</div><div class="line"></div><div class="line">  http.ListenAndServe(<span class="string">"localhost:8090"</span>, mux)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>经验丰富的Go程序员会立即注意到两个新功能：</p>
<ul>
<li>在第一个处理程序中，HTTP method（在本例中为<code>GET</code>）被明确指定为模式的一部分。这意味着该处理程序将只触发以<code>/path/</code>开头的路径的<code>GET</code>请求，而不触发其他HTTP method。</li>
<li>在第二个处理程序中，第二个路径组件 - <code>{id}</code>中有一个通配符，这是以前不支持的。通配符将匹配单个路径组件，然后处理程序可以通过请求的<code>PathValue</code>方法访问匹配的值。</li>
</ul>
<p>由于Go 1.22尚未发布，你可以使用<code>gotip</code>运行此示例。请参阅完整的<a href="https://github.com/eliben/code-for-blog/tree/master/2023/http-newmux-samples" target="_blank" rel="external">代码示例</a>以及运行此程序的完整说明。让我们来试试这个服务器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gotip run sample.go</div></pre></td></tr></table></figure>

<p>在一个单独的终端中，我们可以发出一些curl调用来测试它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ curl localhost:<span class="number">8090</span>/what/</div><div class="line"><span class="number">404</span> page not found</div><div class="line"></div><div class="line">$ curl localhost:<span class="number">8090</span>/path/</div><div class="line">got path</div><div class="line"></div><div class="line">$ curl -X POST localhost:<span class="number">8090</span>/path/</div><div class="line">Method Not Allowed</div><div class="line"></div><div class="line">$ curl localhost:<span class="number">8090</span>/task/f0<span class="built_in">cd</span>2e/</div><div class="line">handling task with id=f0<span class="built_in">cd</span>2e</div></pre></td></tr></table></figure>

<p>请注意，服务器如何拒绝对<code>/path/</code>的POST请求，同时允许（curl的默认值）<code>GET</code>请求。还要注意，当请求匹配时，<code>id</code>通配符是如何被分配一个值的。我再次鼓励您查看新<a href="https://pkg.go.dev/net/http@master#ServeMux" target="_blank" rel="external">ServeMux</a>的文档。您将了解其他功能，如将尾随路径与带有<code>{id}</code>的通配符匹配，路径以<code>{$}</code>结尾的严格匹配以及其他规则。</p>
<p>提案中特别注意不同模式之间的潜在冲突。请考虑此设置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mux := http.NewServeMux()</div><div class="line">mux.HandleFunc(<span class="string">"/task/{id}/status/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">        id := r.PathValue(<span class="string">"id"</span>)</div><div class="line">        fmt.Fprintf(w, <span class="string">"handling task status with id=%v\n"</span>, id)</div><div class="line">})</div><div class="line">mux.HandleFunc(<span class="string">"/task/0/{action}/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">        action := r.PathValue(<span class="string">"action"</span>)</div><div class="line">        fmt.Fprintf(w, <span class="string">"handling task 0 with action=%v\n"</span>, action)</div><div class="line">})</div></pre></td></tr></table></figure>

<p>假设服务器收到<code>/task/0/status/</code>的请求——它应该转到哪个处理程序？两者都匹配！因此，新的<code>ServeMux</code>文档仔细地描述了模式的优先级规则以及潜在的冲突。如果发生冲突，注册会panic。事实上，对于上面的例子，我们得到了如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">panic: pattern <span class="string">"/task/0/{action}/"</span> (registered at sample-conflict.go:<span class="number">14</span>) conflicts with pattern <span class="string">"/task/{id}/status/"</span> (registered at sample-conflict.go:<span class="number">10</span>):</div><div class="line">/task/<span class="number">0</span>/{action}/ and /task/{id}/status/ both match some paths, like <span class="string">"/task/0/status/"</span>.</div><div class="line">But neither is more specific than the other.</div><div class="line">/task/<span class="number">0</span>/{action}/ matches <span class="string">"/task/0/action/"</span>, but /task/{id}/status/ doesn<span class="string">'t.</span></div><div class="line">/task/{id}/status/ matches "/task/id/status/", but /task/0/{action}/ doesn't.</div></pre></td></tr></table></figure>

<p>该信息详细且有用。如果我们在复杂的注册方案中遇到冲突（尤其是当模式在源代码中的多个位置注册时），这些细节会非常有用。</p>
<h2 id="用新的mux实现服务器">用新的mux实现服务器</h2>
<p><code>REST Servers in Go series</code>的REST服务器使用几种不同的方法为Go中的任务/待办事项列表应用程序实现了一个简单的服务器。<a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-1-standard-library/" target="_blank" rel="external">第1部分</a>从标准库开始，<a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-2-using-a-router-package/" target="_blank" rel="external">第2部分</a>使用<code>gorilla/mux</code>路由器重新实现了相同的服务器。</p>
<p>现在是再次实现它的好时机，但有了Go 1.22的增强<code>mux</code>；将该解决方案与使用<code>gorilla/mux</code>的解决方案进行比较将特别有趣。</p>
<p>此项目的完整代码可在<a href="https://github.com/eliben/code-for-blog/tree/master/2021/go-rest-servers/stdlib-newmux" target="_blank" rel="external">此处</a>获得。让我们看看几个有代表性的代码示例，从<a href="https://eli.thegreenplace.net/2023/better-http-server-routing-in-go-122/#footnote-1" target="_blank" rel="external">模式注册</a>开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mux := http.NewServeMux()</div><div class="line">server := NewTaskServer()</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"POST /task/"</span>, server.createTaskHandler)</div><div class="line">mux.HandleFunc(<span class="string">"GET /task/"</span>, server.getAllTasksHandler)</div><div class="line">mux.HandleFunc(<span class="string">"DELETE /task/"</span>, server.deleteAllTasksHandler)</div><div class="line">mux.HandleFunc(<span class="string">"GET /task/{id}/"</span>, server.getTaskHandler)</div><div class="line">mux.HandleFunc(<span class="string">"DELETE /task/{id}/"</span>, server.deleteTaskHandler)</div><div class="line">mux.HandleFunc(<span class="string">"GET /tag/{tag}/"</span>, server.tagHandler)</div><div class="line">mux.HandleFunc(<span class="string">"GET /due/{year}/{month}/{day}/"</span>, server.dueHandler)</div></pre></td></tr></table></figure>

<p>就像在<code>gorilla/mux</code>示例中一样，这里我们使用特定的HTTP method将请求（具有相同路径）路由到不同的处理程序；使用旧的<code>http.ServeMux</code>这样的匹配器就必须转到同一个处理程序，然后由该处理程序根据该方法决定要做什么。</p>
<p>让我们看看其中一个处理程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (ts *taskServer) getTaskHandler(w http.ResponseWriter, req *http.Request) {</div><div class="line">  log.Printf(<span class="string">"handling get task at %s\n"</span>, req.URL.Path)</div><div class="line"></div><div class="line">  id, err := strconv.Atoi(req.PathValue(<span class="string">"id"</span>))</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, <span class="string">"invalid id"</span>, http.StatusBadRequest)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  }</div><div class="line"></div><div class="line">  task, err := ts.store.GetTask(id)</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    http.Error(w, err.Error(), http.StatusNotFound)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  }</div><div class="line"></div><div class="line">  renderJSON(w, task)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它从<code>req.PathValue(&quot;id&quot;)</code>中提取ID值。类似于Gorilla方法；然而，由于我们没有正则表达式指定<code>{id}</code>只匹配整数，因此我们必须注意<code>strconv.Atoi</code>返回的错误。</p>
<p>总之，最终结果与第2部分中使用<code>gorilla/mux</code>的解决方案非常相似。与普通的标准库方法相比，处理程序的方式要好得多，因为mux现在可以进行更复杂的路由，而不会将许多路由决策留给处理程序本身。</p>
<h2 id="结论">结论</h2>
<p>“我应该使用哪个router库？”一直是Go初学者的常见问题。我相信在Go 1.22发布后，这个问题的常见答案会发生变化，因为许多人会发现新的标准库 mux足以满足他们的需求，而无需求助于第三方软件包。</p>
<p>其他人会坚持熟悉的第三方库，这完全没关系。像<code>gorilla/mux</code>这样的路由器仍然提供比标准库更多的功能；除此之外，许多Go程序员选择了像Gin这样的轻量级框架，它提供了一个路由器，但也提供了用于构建web后端的额外工具。</p>
<p>总而言之，这对所有Go用户来说无疑是一个积极的变化。无论人们是使用第三方软件包还是坚持使用标准库，让标准库更有能力对整个社区来说都是一个积极的方面。</p>
<p>翻译自<a href="https://eli.thegreenplace.net/2023/better-http-server-routing-in-go-122/" target="_blank" rel="external">Better HTTP server routing in Go 1.22</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很多人为了使用Go web中更好的路由，会使用第三方的库 <code>httprouter</code>、<code>gorilla/mux</code>等。在明年的春节左右发布的Go 1.22中，Go官方终于对标准库中的<code>http.ServeMux</code>下手了，对它的功能进行了优化，终于可以抛弃第三方库了。</p>
<p>一个令人兴奋的<a href="https://github.com/golang/go/issues/61410" target="_blank" rel="external">提案</a>预计将在Go 1.22中实现—— 增强标准库<code>net/http</code>包中默认HTTP服务多路复用器的模式匹配能力。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust并发编程4 - 容器类并发原语]]></title>
    <link href="https://colobu.com/2023/10/15/concurrency-programming-via-rust-ch04/"/>
    <id>https://colobu.com/2023/10/15/concurrency-programming-via-rust-ch04/</id>
    <published>2023-10-15T10:35:03.000Z</published>
    <updated>2023-12-11T05:37:05.056Z</updated>
    <content type="html"><![CDATA[<p>Rust 在并发编程方面有一些强大的原语，让你能够写出安全且高效的并发代码。最显著的原语之一是 ownership system，它允许你在没有锁的情况下管理内存访问。此外，Rust 还提供了一些并发编程的工具和标准库,比如线程、线程池、消息通讯(mpsc等)、原子操作等，不过这一章我们不介绍这些工具和库，它们会专门的分章节去讲。这一章我们专门讲一些保证在线程间共享的一些方式和库。</p>
<p>并发原语内容较多，分成两章，这一章介绍<code>Cow</code>、<code>beef::Cow</code>、<code>Box</code>、 <code>Cell</code>、<code>RefCell</code>、<code>OnceCell</code>、<code>LazyCell</code>、<code>LazyLock</code> 和 <code>Rc</code>。 我把它们称之为容器类并发原语，主要基于它们的行为，它们主要是对普通数据进行包装，以便提供其他更丰富的功能。</p>
<a id="more"></a>
<p><img src="ch04.png" alt=""></p>
<h2 id="Cow">Cow</h2>
<p>Cow不是🐄，而是<code>clone-on-write</code>或者<code>copy-on-write</code>的缩写。</p>
<p>Cow(Copy-on-write) 是一种优化内存和提高性能的技术,通常应用在资源共享的场景。</p>
<p>其基本思想是,当有多个调用者(callers)同时请求相同的资源时,都会共享同一份资源,直到有调用者试图修改资源内容时,系统才会真正复制一份副本出来给该调用者,而其他调用者仍然使用原来的资源。</p>
<p>Rust中的String和Vec等类型就利用了Cow。例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s1 = String::from(<span class="string">"hello"</span>);</div><div class="line"><span class="keyword">let</span> s2 = s1; <span class="comment">// s1和s2共享同一份内存</span></div><div class="line"></div><div class="line">s2.push_str(<span class="string">" world"</span>); <span class="comment">// s2会进行写操作,于是系统复制一份新的内存给s2</span></div></pre></td></tr></table></figure>

<p>这样可以避免大量未修改的字符串、向量等的重复分配和复制,提高内存利用率和性能。</p>
<p>cow的优点是:</p>
<ul>
<li>内存利用率高,只有进行写时才复制</li>
<li>读取性能高,多个调用者共享同一资源</li>
</ul>
<p>缺点是:</p>
<ul>
<li>写时需要复制,有一定性能损失</li>
<li>实现较复杂</li>
</ul>
<p>需要根据实际场景权衡使用。但对于存在大量相同或相似资源的共享情况,使用cow可以带来显著性能提升。</p>
<p>标准库中<code>std::borrow::Cow</code> 类型是一个智能指针，提供了写时克隆（clone-on-write）的功能：它可以封装并提供对借用数据的不可变访问，当需要进行修改或获取所有权时，它可以惰性地克隆数据。</p>
<p>Cow 实现了<code>Deref</code>，这意味着你可以直接在其封装的数据上调用不可变方法。如果需要进行改变，则 <code>to_mut</code> 将获取到一个对拥有的值的可变引用，必要时进行克隆。</p>
<p>下面的代码将<code>origin</code>字符串包装成一个<code>cow</code>, 你可以把它borrowed成一个<code>&amp;str</code>,其实也可以直接在<code>cow</code>调用<code>&amp;str</code>方法，因为<code>Cow</code>实现了<code>Deref</code>，可以自动解引用，比如直接调用<code>len</code>和<code>into</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> origin = <span class="string">"hello world"</span>;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> cow = Cow::from(origin);</div><div class="line">assert_eq!(cow, <span class="string">"hello world"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Cow can be borrowed as a str</span></div><div class="line"><span class="keyword">let</span> s: &<span class="keyword">str</span> = &cow;</div><div class="line">assert_eq!(s, <span class="string">"hello world"</span>);</div><div class="line"></div><div class="line">assert_eq!(s.len(), cow.len());</div><div class="line"></div><div class="line"><span class="comment">// Cow can be converted to a String</span></div><div class="line"><span class="keyword">let</span> s: String = cow.into();</div><div class="line">assert_eq!(s, <span class="string">"HELLO WORLD"</span>);</div></pre></td></tr></table></figure>

<p>接下来我们已一个写时clone的例子。下面这个例子将字符串中的字符全部改成大写字母：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Cow can be borrowed as a mut str</span></div><div class="line"><span class="keyword">let</span> s: &<span class="keyword">mut</span> <span class="keyword">str</span> = cow.to_mut();</div><div class="line">s.make_ascii_uppercase();</div><div class="line">assert_eq!(s, <span class="string">"HELLO WORLD"</span>);</div><div class="line">assert_eq!(origin, <span class="string">"hello world"</span>);</div></pre></td></tr></table></figure>

<p>这里使用<code>to_mut</code>得到一个可变引用，一旦s有修改，它会从原始数据中clone一份，在克隆的数据上进行修改。</p>
<p>所以如果你想在某些数据上实现<code>copy-on-write</code>/<code>clone-on-write</code>的功能，可以考虑使用<code>std::borrow::Cow</code>。</p>
<p>更进一步，<code>beef</code>库提供了一个更快，更紧凑的<code>Cow</code>类型,它的使用方法和标准库的<code>Cow</code>使用方法类似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">beef_cow</span></span>() {</div><div class="line">    <span class="keyword">let</span> borrowed: beef::Cow&lt;<span class="keyword">str</span>&gt; = beef::Cow::borrowed(<span class="string">"Hello"</span>);</div><div class="line">    <span class="keyword">let</span> owned: beef::Cow&lt;<span class="keyword">str</span>&gt; = beef::Cow::owned(String::from(<span class="string">"World"</span>));</div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = beef::Cow::from(<span class="string">"Hello"</span>);</div><div class="line"></div><div class="line">    assert_eq!(format!(<span class="string">"{} {}!"</span>, borrowed, owned), <span class="string">"Hello World!"</span>,);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> WORD: usize = size_of::&lt;usize&gt;();</div><div class="line"></div><div class="line">    assert_eq!(size_of::&lt;std::borrow::Cow&lt;<span class="keyword">str</span>&gt;&gt;(), <span class="number">3</span> * WORD);</div><div class="line">    assert_eq!(size_of::&lt;beef::Cow&lt;<span class="keyword">str</span>&gt;&gt;(), <span class="number">3</span> * WORD);</div><div class="line">    assert_eq!(size_of::&lt;beef::lean::Cow&lt;<span class="keyword">str</span>&gt;&gt;(), <span class="number">2</span> * WORD);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子的上半部分演示了生成<code>beef::Cow</code>的三种方法<code>Cow::borrowed</code>、<code>Cow::from</code>、<code>Cow::owned</code>，标准库<code>Cow</code>也有这三个方法，它们的区别是：</p>
<ul>
<li><code>borrowed</code>: 借用已有资源</li>
<li><code>from</code>: 从已有资源复制创建Owned</li>
<li><code>owned</code>: 自己提供资源内容</li>
</ul>
<p>这个例子下半部分对比了标准库<code>Cow</code>和<code>beef::Cow</code>以及更紧凑的<code>beef::lean::Cow</code>所占内存的大小。可以看到对于数据是<code>str</code>类型的Cow，现在的标准库的<code>Cow</code>占三个WORD, 和beef::Cow相当,而进一步压缩的beef::lean::Cow只占了两个Word。</p>
<p><code>cow-utils</code>针对字符串的Cow做了优化，性能更好。</p>
<h2 id="Box">Box</h2>
<p><code>Box&lt;T&gt;</code>，通常简称为<code>box</code>，提供了在 Rust 中最简单的堆分配形式。<code>Box</code> 为这个分配提供了所有权，并在超出作用域时释放其内容。<code>Box</code> 还确保它们不会分配超过 <code>isize::MAX</code> 字节的内存。</p>
<p>它的使用很简单，下面的例子就是把值<code>val</code>从栈上移动到堆上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> val: <span class="keyword">u8</span> = <span class="number">5</span>;</div><div class="line"><span class="keyword">let</span> boxed: Box&lt;<span class="keyword">u8</span>&gt; = Box::new(val);</div></pre></td></tr></table></figure>

<p>那么怎么反其道而行之呢？下面的例子就是通过解引用把值从堆上移动到栈上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> boxed: Box&lt;<span class="keyword">u8</span>&gt; = Box::new(<span class="number">5</span>);</div><div class="line"><span class="keyword">let</span> val: <span class="keyword">u8</span> = *boxed;</div></pre></td></tr></table></figure>

<p>如果我们要定义一个递归的数据结构，比如链表，下面的方式是不行的，因为List的大小不固定，我们不知道该分配给它多少内存：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(Debug)]</span></div><div class="line"><span class="keyword">enum</span> <span class="title">List</span>&lt;T&gt; {</div><div class="line">    Cons(T, List&lt;T&gt;),</div><div class="line">    Nil,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个时候就可以使用<code>Box</code>了:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(Debug)]</span></div><div class="line"><span class="keyword">enum</span> <span class="title">List</span>&lt;T&gt; {</div><div class="line">    Cons(T, Box&lt;List&lt;T&gt;&gt;),</div><div class="line">    Nil,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">let</span> list: List&lt;<span class="keyword">i32</span>&gt; = List::Cons(<span class="number">1</span>, Box::new(List::Cons(<span class="number">2</span>, Box::new(List::Nil))));</div><div class="line">println!(<span class="string">"{list:?}"</span>);</div></pre></td></tr></table></figure>

<p>目前Rust还提供一个实验性的类型<code>ThinBox</code>, 它是一个瘦指针，不管内部元素的类型是啥：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">thin_box_example</span></span>() {</div><div class="line">    <span class="keyword">use</span> std::mem::{size_of, size_of_val};</div><div class="line">    <span class="keyword">let</span> size_of_ptr = size_of::&lt;*<span class="keyword">const</span> ()&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> box_five = Box::new(<span class="number">5</span>);</div><div class="line">    <span class="keyword">let</span> box_slice = Box::&lt;[<span class="keyword">i32</span>]&gt;::new_zeroed_slice(<span class="number">5</span>);</div><div class="line">    assert_eq!(size_of_ptr, size_of_val(&box_five));</div><div class="line">    assert_eq!(size_of_ptr * <span class="number">2</span>, size_of_val(&box_slice));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">let</span> five = ThinBox::new(<span class="number">5</span>);</div><div class="line">    <span class="keyword">let</span> thin_slice = ThinBox::&lt;[<span class="keyword">i32</span>]&gt;::new_unsize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</div><div class="line">    assert_eq!(size_of_ptr, size_of_val(&five));</div><div class="line">    assert_eq!(size_of_ptr, size_of_val(&thin_slice));</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Cell、RefCell、OnceCell、LazyCell_和_LazyLock">Cell、RefCell、OnceCell、LazyCell 和 LazyLock</h2>
<p><code>Cell</code>和<code>RefCell</code>是Rust中用于内部可变性(interior mutability)的两个重要类型。</p>
<p><code>Cell</code>和<code>RefCell</code>都是可共享的可变容器。可共享的可变容器的存在是为了以受控的方式允许可变性，即使存在别名引用。Cell<t> 和 RefCell<t> 都允许在单线程环境下以这种方式进行。然而，无论是 Cell<t> 还是 RefCell<t> 都不是线程安全的（它们没有实现 Sync）。</t></t></t></t></p>
<h3 id="Cell">Cell</h3>
<p><code>Cell&lt;T&gt;</code>允许在不违反借用规则的前提下,修改其包含的值:</p>
<ul>
<li><code>Cell</code>中的值不再拥有所有权,只能通过<code>get</code>和<code>set</code>方法访问。</li>
<li><code>set</code>方法可以在不获取可变引用的情况下修改<code>Cell</code>的值。</li>
<li>适用于简单的单值容器，如整数或字符。</li>
</ul>
<p>下面这个例子创建了一个Cell, 赋值给变量<code>x</code>,注意x是不可变的，但是我们能够通过<code>set</code>方法修改它的值，并且即使存在对x的引用y时也可以修改它的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::cell::Cell;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = Cell::new(<span class="number">42</span>);</div><div class="line"><span class="keyword">let</span> y = &x;</div><div class="line"></div><div class="line">x.set(<span class="number">10</span>); <span class="comment">// 可以修改</span></div><div class="line"></div><div class="line">println!(<span class="string">"y: {:?}"</span>, y.get());  <span class="comment">// 输出 y: 10</span></div></pre></td></tr></table></figure>

<h3 id="RefCell">RefCell</h3>
<p><code>RefCell&lt;T&gt;</code> 提供了更灵活的内部可变性，允许在运行时检查借用规则,通过运行时借用检查来实现:</p>
<ul>
<li>通过<code>borrow</code>和<code>borrow_mut</code>方法进行不可变和可变借用。</li>
<li>借用必须在作用域结束前归还,否则会panic。</li>
<li>适用于包含多个字段的容器。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::cell::RefCell;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = RefCell::new(<span class="number">42</span>);</div><div class="line"></div><div class="line">{</div><div class="line">    <span class="keyword">let</span> y = x.borrow();</div><div class="line">    <span class="comment">// 在这个作用域内，只能获得不可变引用</span></div><div class="line">    println!(<span class="string">"y: {:?}"</span>, *y.borrow());</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> z = x.borrow_mut();</div><div class="line">    <span class="comment">// 在这个作用域内，可以获得可变引用</span></div><div class="line">    *z = <span class="number">10</span>;</div><div class="line">}</div><div class="line"></div><div class="line">println!(<span class="string">"x: {:?}"</span>, x.borrow().deref());</div></pre></td></tr></table></figure>

<p>如果你开启了<code>#![feature(cell_update)]</code>, 你还可以更新它:<code>c.update(|x| x + 1);</code>。</p>
<h3 id="OnceCell">OnceCell</h3>
<p><code>OnceCell</code> 是 Rust 标准库中的一个类型，用于提供一次性写入的单元格。它允许在运行时将值放入单元格，但只允许一次。一旦值被写入，进一步的写入尝试将被忽略。</p>
<p>主要特点和用途：</p>
<ul>
<li>一次性写入：<code>OnceCell</code> 确保其内部值只能被写入一次。一旦值被写入，后续的写入操作将被忽略。</li>
<li>懒初始化：<code>OnceCell</code> 支持懒初始化，这意味着它只有在需要时才会进行初始化。这在需要在运行时确定何时初始化值的情况下很有用。</li>
<li>线程安全：<code>OnceCell</code> 提供了线程安全的一次性写入。在多线程环境中，它确保只有一个线程能够成功写入值，而其他线程的写入尝试将被忽略。</li>
</ul>
<p>下面这个例子演示了<code>OnceCell</code>使用方法，还未初始化的时候，获取的它的值是None, 一旦初始化为<code>Hello, World!</code>,它的值就固定下来了:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">once_cell_example</span></span>() {</div><div class="line">    <span class="keyword">let</span> cell = OnceCell::new();</div><div class="line">    assert!(cell.get().is_none()); <span class="comment">// true</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> value: &String = cell.get_or_init(|| <span class="string">"Hello, World!"</span>.to_string());</div><div class="line">    assert_eq!(value, <span class="string">"Hello, World!"</span>);</div><div class="line">    assert!(cell.get().is_some()); <span class="comment">//true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="LazyCell、LazyLock">LazyCell、LazyLock</h3>
<p>有时候我们想实现懒(惰性)初始化的效果，当然<code>lazy_static</code>库可以实现这个效果，但是Rust标准库也提供了一个功能，不过目前还处于不稳定的状态，你需要设置<code>#![feature(lazy_cell)]</code>使能它。</p>
<p>下面是一个使用它的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#![feature(lazy_cell)]</div><div class="line"></div><div class="line"><span class="keyword">use</span> std::cell::LazyCell;</div><div class="line"></div><div class="line"><span class="keyword">let</span> lazy: LazyCell&lt;<span class="keyword">i32</span>&gt; = LazyCell::new(|| {</div><div class="line">    println!(<span class="string">"initializing"</span>);</div><div class="line">    <span class="number">46</span></div><div class="line">});</div><div class="line">println!(<span class="string">"ready"</span>);</div><div class="line">println!(<span class="string">"{}"</span>, *lazy); <span class="comment">// 46</span></div><div class="line">println!(<span class="string">"{}"</span>, *lazy); <span class="comment">// 46</span></div></pre></td></tr></table></figure>

<p>注意它是懒初始化的，也就是你在第一次访问它的时候它才会调用初始化函数进行初始化。</p>
<p>但是它不是线程安全的，如果想使用线程安全的版本，你可以使用<code>std::sync::LazyLock</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::collections::HashMap;</div><div class="line"></div><div class="line"><span class="keyword">use</span> std::sync::LazyLock;</div><div class="line"></div><div class="line"><span class="keyword">static</span> HASHMAP: LazyLock&lt;HashMap&lt;<span class="keyword">i32</span>, String&gt;&gt; = LazyLock::new(|| {</div><div class="line">    println!(<span class="string">"initializing"</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m = HashMap::new();</div><div class="line">    m.insert(<span class="number">13</span>, <span class="string">"Spica"</span>.to_string());</div><div class="line">    m.insert(<span class="number">74</span>, <span class="string">"Hoyten"</span>.to_string());</div><div class="line">    m</div><div class="line">});</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    println!(<span class="string">"ready"</span>);</div><div class="line">    std::thread::spawn(|| {</div><div class="line">        println!(<span class="string">"{:?}"</span>, HASHMAP.get(&<span class="number">13</span>));</div><div class="line">    }).join().unwrap();</div><div class="line">    println!(<span class="string">"{:?}"</span>, HASHMAP.get(&<span class="number">74</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="rc">rc</h2>
<p><code>Rc</code> 是 Rust 标准库中的一个智能指针类型，全名是 std::rc::Rc，代表 &quot;reference counting&quot;。它用于在多个地方共享相同数据时，通过引用计数来进行所有权管理。</p>
<ul>
<li><code>Rc</code> 使用引用计数来追踪指向数据的引用数量。当引用计数降为零时，数据会被自动释放。</li>
<li><code>Rc</code>允许多个 Rc 指针共享相同的数据，而无需担心所有权的转移。</li>
<li><code>Rc</code> 内部存储的数据是不可变的。如果需要可变性，可以使用 RefCell 或 Mutex 等内部可变性的机制。</li>
<li><code>Rc</code> 在处理循环引用时需要额外注意，因为循环引用会导致引用计数无法降为零，从而导致内存泄漏。为了解决这个问题，可以使用 Weak 类型。</li>
</ul>
<p>下面这个例子演示了<code>Rc</code>的基本使用方法，通过<code>clone</code>我们可以获得新的共享引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::rc::Rc;</div><div class="line"></div><div class="line"><span class="keyword">let</span> data = Rc::new(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> reference1 = Rc::clone(&data);</div><div class="line"><span class="keyword">let</span> reference2 = Rc::clone(&data);</div><div class="line"></div><div class="line"><span class="comment">// data 的引用计数现在为 3</span></div><div class="line"></div><div class="line"><span class="comment">// 当 reference1 和 reference2 被丢弃时，引用计数减少</span></div></pre></td></tr></table></figure>

<p>注意<code>Rc</code> 允许在多个地方共享不可变数据，通过引用计数来管理所有权。</p>
<p>如果还想修改数据，那么就可以使用上一节的<code>Cell</code>相关类型, 比如下面的例子，我们使用<code>Rc&lt;RefCell&lt;HashMap&gt;&gt;</code>类型来实现这个需求：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">rc_refcell_example</span></span>() {</div><div class="line">    <span class="keyword">let</span> shared_map: Rc&lt;RefCell&lt;<span class="number">_</span>&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));</div><div class="line">    {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map: RefMut&lt;<span class="number">_</span>&gt; = shared_map.borrow_mut();</div><div class="line">        map.insert(<span class="string">"africa"</span>, <span class="number">92388</span>);</div><div class="line">        map.insert(<span class="string">"kyoto"</span>, <span class="number">11837</span>);</div><div class="line">        map.insert(<span class="string">"piccadilly"</span>, <span class="number">11826</span>);</div><div class="line">        map.insert(<span class="string">"marbles"</span>, <span class="number">38</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">let</span> total: <span class="keyword">i32</span> = shared_map.borrow().values().sum();</div><div class="line">    println!(<span class="string">"{total}"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样我们就针对不可变类型<code>Rc</code>实现了数据的可变性。</p>
<p>注意<code>Rc</code>不是线程安全的，针对上面的里面，如果想实现线程安全的类型，你可以使用<code>Arc</code>,不过这个类型我们放在下一章进行再介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Rust 在并发编程方面有一些强大的原语，让你能够写出安全且高效的并发代码。最显著的原语之一是 ownership system，它允许你在没有锁的情况下管理内存访问。此外，Rust 还提供了一些并发编程的工具和标准库,比如线程、线程池、消息通讯(mpsc等)、原子操作等，不过这一章我们不介绍这些工具和库，它们会专门的分章节去讲。这一章我们专门讲一些保证在线程间共享的一些方式和库。</p>
<p>并发原语内容较多，分成两章，这一章介绍<code>Cow</code>、<code>beef::Cow</code>、<code>Box</code>、 <code>Cell</code>、<code>RefCell</code>、<code>OnceCell</code>、<code>LazyCell</code>、<code>LazyLock</code> 和 <code>Rc</code>。 我把它们称之为容器类并发原语，主要基于它们的行为，它们主要是对普通数据进行包装，以便提供其他更丰富的功能。</p>
]]>
    
    </summary>
    
      <category term="Rust" scheme="https://colobu.com/categories/Rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用rust重写: 和Go版本mping比较]]></title>
    <link href="https://colobu.com/2023/10/09/mping-write-by-rust/"/>
    <id>https://colobu.com/2023/10/09/mping-write-by-rust/</id>
    <published>2023-10-09T00:30:12.000Z</published>
    <updated>2023-12-11T05:37:05.070Z</updated>
    <content type="html"><![CDATA[<p>上个月我使用go实现了一个探测多目标的高频探测程序<a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a>, 并且在后续的开发中支持了硬件时间戳和软件时间戳，提供更精准的时延。</p>
<a id="more"></a>
<blockquote>
<p>好吧，公众号的文章忘记贴仓库地址了： <a href="https://github.com/smallnest/mping-rs" target="_blank" rel="external">smallnest/mping-rs</a></p>
</blockquote>
<p>“用Rust 重写”正在以传销般的方式席卷整个开发领域，这一次，我也准备使用rust重写它，当然我也不是为了重写而写，重新的目的有四：</p>
<ul>
<li>评估使用rust开发工具的难度</li>
<li>评估rust生态圈尤其是底层socket的编程的成熟度</li>
<li>评估rust程序的性能</li>
<li>积累一些rust底层网络编程的经验</li>
</ul>
<p>Go版本的mping功能如下：</p>
<ul>
<li>支持对多目标IP的探测</li>
<li>支持对网段的探测</li>
<li>支持对域名的探测</li>
<li>支持高频探测，支持限流</li>
<li>支持设置TOS、payload长度等选项</li>
<li>支持最大探测数量</li>
<li>支持每秒打印统计数据</li>
<li>支持时延</li>
<li>支持比特跳变检查</li>
<li>支持软硬件时间戳</li>
</ul>
<p><img src="design.png" alt=""></p>
<p>我先前对mping这个工具的实现进行了拆解介绍<a href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/" target="_blank" rel="external">mping: 使用新的icmp库实现探测和压测工具</a>, 我把实现分成了四个模块：</p>
<ul>
<li>主程序入口： 处理各种参数，比如网段信息转换成IP列表等，限流等</li>
<li>发送 goroutine: 负责发送ICMP探测包</li>
<li>接收 goroutine: 负责接收ICMP echo reply包</li>
<li>统计打印 goroutine: 负责统计打印每一秒的丢包率和时延，这里创新性的实现了bucket数据结构进行统计分析</li>
</ul>
<p>这个代码架构还是很清晰的，结合Go成熟的raw socket的库，实现了一个高效的探测和压测集一身的ping工具。</p>
<p>所以我在使用rust实现的时候也是采用这种架构，以下是在动手之前以及在开发中的技术考量:</p>
<ul>
<li><strong>程序入口</strong>： 使用<code>structopt</code>库而不是<code>clap</code>解析命令行参数。<br>structopt利用Rust的属性宏来简化命令行参数解析。它允许直接在struct定义中添加属性,来自动生成解析命令行参数所需的clap参数定义。这样可以跳过手动定义clap::Arg的过程,使命令行参数的定义更加简洁。<br>structopt的主要特性包括:<ul>
<li>基于struct和字段属性自动生成clap参数定义</li>
<li>支持子命令,可以在struct中嵌套定义子命令</li>
<li>支持各种参数类型,如布尔类型、字符串、整数等</li>
<li>支持参数默认值、帮助信息等</li>
<li>简单的错误处理</li>
<li>支持完整的clap功能,可以直接获取clap::App对象进行自定义</li>
</ul>
</li>
</ul>
<p>对于mping这个工具来说，并不需要强大的命令行交互能力，我们只需要能把命令行的参数解析成对应类型的变量即可，所以<code>structopt</code>和很合适。</p>
<ul>
<li><p><strong>使用线程代替goroutine</strong>: 通常情况下rust的并发单元是线程，所以这里发送、接收、统计模块分别启动三个线程来处理。<br>当然事实上接收线程使用了主线程，而没有生成新的线程。<br>这里就有一个抉择，要不要使用async/await异步方式？<br>理论上这个程序是I/O密集型类型的程序，但是由于我们只需要一两个socket + 三个线程就可以完成，并没有成百上千的I/O并发单元争抢CPU,所以使用普通的线程就可以了。进一步，我们就不需要头痛该选择哪一个异步运行时库了。</p>
</li>
<li><p><strong>网络库的抉择</strong>: 该使用哪一个库呢？标准库、tokio、socket2、nix、libc？<br>我们要实现的mping不是一个普通的TCP/UDP Client/Server 点对点的网络程序，也不是像web服务器这样的&amp;层网络应用服务器，它是要能够收发ICMP 包，并且支持要单个socket发送和接收成百上千个目标地址的网络程序，而且也能够设置TOS、TTL等网络选项，所以综合考虑采用socket2, 它虽然不是标准库，但是相对于标准库，提供了更多的设置选项，更底层的控制。如果写标准的TCP/UDP，可能选择tokio就好了。nix、libc更底层，但是缺乏相关的文档和范例，如果使用它们怕调入了坑中爬不上来。<br>当然使用socket2也遇到了一个棘手的问题，就是对软硬件时间戳的设置和解析，搜索网上也没有可以参考的示例，询问AI (chatgpt3.5, claude, bard)给的答案都是胡说八道，最后在chatgpt4.0以及Go版本的实现的基础上终于实现出来了。</p>
</li>
</ul>
<p>那么接下来我们看看代码的实现，然后再简单(粗糙)比较Rust和Go版本 mping工具的差异。 rust版本的完整代码在github上: <a href="https://github.com/smallnest/mping-rs" target="_blank" rel="external">smallnest/mping-rs</a>。</p>
<ul>
<li><strong>包的解析</strong>: 有一个很好库<a href="https://crates.io/crates/pnet" target="_blank" rel="external">pnet</a>。<br>pnet支持各种网络包的处理，它还提供了其它一些网络处理的功能，我使用的它的子包<code>pnet_packet</code>,因为我需要处理IPv4、ICMP的包，包括发送的时候以及接收的时候。</li>
</ul>
<h2 id="程序入口">程序入口</h2>
<p>最重要的使用<code>structopt</code>定义命令行参数的结构体<code>Opt</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(Debug, StructOpt)]</span></div><div class="line"><span class="preprocessor">#[structopt(</span></div><div class="line">    name = "mping",</div><div class="line">    version = "0.1.4",</div><div class="line">    about = "A multi-targets ping tool, which supports 10,000 packets/second."</div><div class="line">)]</div><div class="line"><span class="keyword">struct</span> Opt {</div><div class="line">    <span class="preprocessor">#[structopt(</span></div><div class="line">        short = "w",</div><div class="line">        long = "timeout",</div><div class="line">        default_value = "1",</div><div class="line">        help = "timeout in seconds"</div><div class="line">    )]</div><div class="line">    timeout: <span class="keyword">u64</span>,</div><div class="line"></div><div class="line">    <span class="preprocessor">#[structopt(short = "t", long = "ttl", default_value = "64", help = "time to live")]</span></div><div class="line">    ttl: <span class="keyword">u32</span>,</div><div class="line"></div><div class="line">    <span class="preprocessor">#[structopt(short = "z", long = "tos", help = "type of service")]</span></div><div class="line">    tos: Option&lt;<span class="keyword">u32</span>&gt;,</div><div class="line"></div><div class="line">    ....</div><div class="line">}</div></pre></td></tr></table></figure>

<p>还有一个重要的逻辑就是解析多目标地址，我们需要把<code>8.8.8.8/30,8.8.4.4,github.com</code>这个目标解析成要探测的目标地址列表:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_ips</span></span>(input: &<span class="keyword">str</span>) -&gt; Vec&lt;IpAddr&gt; {</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ips = Vec::new();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> input.split(<span class="string">','</span>) {</div><div class="line">        <span class="keyword">match</span> s.parse::&lt;IpNetwork&gt;() {</div><div class="line">            Ok(network) =&gt; {</div><div class="line">                <span class="keyword">for</span> ip <span class="keyword">in</span> network.iter() {</div><div class="line">                    ips.push(ip);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            Err(<span class="number">_</span>) =&gt; {</div><div class="line">                <span class="keyword">if</span> <span class="keyword">let</span> Ok(ip) = s.parse::&lt;IpAddr&gt;() {</div><div class="line">                    ips.push(ip);</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> Ok(addrs) = (s, <span class="number">0</span>).to_socket_addrs() {</div><div class="line">                    <span class="keyword">for</span> addr <span class="keyword">in</span> addrs {</div><div class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> IpAddr::V4(ipv4) = addr.ip() {</div><div class="line">                            ips.push(IpAddr::V4(ipv4));</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ips</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后把主要的处理好的参数组织起来，交给<code>ping</code>函数处理:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> popt = mping::ping::PingOption {</div><div class="line">    timeout,</div><div class="line">    ttl: opt.ttl,</div><div class="line">    tos: opt.tos,</div><div class="line">    ident: pid,</div><div class="line">    len: opt.size,</div><div class="line">    rate: opt.rate,</div><div class="line">    delay: opt.delay,</div><div class="line">    count: opt.count,</div><div class="line">};</div><div class="line">mping::ping::ping(ip_addrs, popt)?;</div></pre></td></tr></table></figure>

<p><code>mping::ping::ping</code>会实现发送、接收、定时统计的功能。</p>
<h2 id="发送逻辑">发送逻辑</h2>
<p>首先创建一个raw socket并设置它的选项：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">thread::spawn(move || {</div><div class="line">    <span class="keyword">let</span> socket = Socket::new(Domain::IPV4, Type::RAW, Some(Protocol::ICMPV4)).unwrap();</div><div class="line">    socket.set_ttl(popt.ttl).unwrap();</div><div class="line">    socket.set_write_timeout(Some(popt.timeout)).unwrap();</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Some(tos_value) = popt.tos  {</div><div class="line">        socket.set_tos(tos_value).unwrap();</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来创建几种payload,用来检查链路中有没有比特跳变和改包行为。<br>然后创建了一个限流器，让发送端按照指定的速率均匀的发包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> zero_payload = vec![<span class="number">0</span>; popt.len];</div><div class="line"><span class="keyword">let</span> one_payload = vec![<span class="number">1</span>; popt.len];</div><div class="line"><span class="keyword">let</span> fivea_payload = vec![<span class="number">0x5A</span>; popt.len];</div><div class="line"></div><div class="line"><span class="keyword">let</span> payloads: [&[<span class="keyword">u8</span>]; <span class="number">4</span>] = [&rand_payload, &zero_payload, &one_payload, &fivea_payload];</div><div class="line"></div><div class="line"><span class="keyword">let</span> limiter = SyncLimiter::full(popt.rate, Duration::from_millis(<span class="number">1000</span>));</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> seq = <span class="number">1u16</span>;</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> sent_count = <span class="number">0</span>;</div></pre></td></tr></table></figure>

<p>接下来准备要发送的ICMP echo request包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> buf = vec![<span class="number">0</span>; <span class="number">8</span> + payload.len()]; <span class="comment">// 8 bytes of header, then payload</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> packet = echo_request::MutableEchoRequestPacket::new(&<span class="keyword">mut</span> buf[..]).unwrap();</div><div class="line">packet.set_icmp_type(icmp::IcmpTypes::EchoRequest);</div><div class="line">packet.set_identifier(pid);</div><div class="line">packet.set_sequence_number(seq);</div><div class="line">...</div></pre></td></tr></table></figure>

<p>然后对每个目标地址都发送一次,注意这里我们只使用了一个raw socket:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> &addrs {</div><div class="line">    <span class="keyword">let</span> dest = SocketAddr::new(*ip, <span class="number">0</span>);</div><div class="line">    <span class="keyword">let</span> data = send_buckets.lock().unwrap();</div><div class="line">    data.add(...);</div><div class="line">    drop(data);</div><div class="line"></div><div class="line">    <span class="keyword">match</span> socket.send_to(&buf, &dest.into()) {</div><div class="line">        Ok(<span class="number">_</span>) =&gt; {}</div><div class="line">        Err(e) =&gt; {</div><div class="line">            error!(<span class="string">"Error in send: {:?}"</span>, e);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是发送端的主要的逻辑。它的目的就是不停的发包，发包。</p>
<h2 id="接收逻辑">接收逻辑</h2>
<p>通过<code>try_clone</code>获得读取数据的socket, 赋值给变量<code>socket2</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> socket2 = socket.try_clone().expect(<span class="string">"Failed to clone socket"</span>);</div></pre></td></tr></table></figure>

<p>然后,我们在一个死循环中读取数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> buffer: [<span class="keyword">u8</span>; <span class="number">2048</span>] = [<span class="number">0</span>; <span class="number">2048</span>];</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> size = <span class="keyword">match</span> socket2.read(&<span class="keyword">mut</span> buffer) {</div><div class="line">            Ok(n) =&gt; n,</div><div class="line">            Err(e) =&gt; {</div><div class="line">                <span class="keyword">if</span> <span class="keyword">let</span> Some(err_code) = e.raw_os_error() {</div><div class="line">                    <span class="keyword">if</span> err_code == <span class="number">11</span> {</div><div class="line">                        <span class="comment">// { code: 11, kind: WouldBlock, message: "Resource temporarily unavailable" }</span></div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                error!(<span class="string">"Error in read: {:?}"</span>, &e);</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">let</span> buf = &buffer[..size];</div><div class="line"></div><div class="line">        ...</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>我们重点看看<code>...</code>省略的那部分，这段省略的逻辑主要是解析出ICMP echo reply的数据，检查数据是否正确，然后扔到统计数据的bucket中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buf = &buffer[..size];</div><div class="line"></div><div class="line"><span class="keyword">let</span> ipv4_packet = Ipv4Packet::new(buf).unwrap();</div><div class="line"><span class="keyword">let</span> icmp_packet = pnet_packet::icmp::IcmpPacket::new(ipv4_packet.payload()).unwrap();</div><div class="line"></div><div class="line"><span class="keyword">if</span> icmp_packet.get_icmp_type() != IcmpTypes::EchoReply</div><div class="line">    || icmp_packet.get_icmp_code() != echo_reply::IcmpCodes::NoCode</div><div class="line">{</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 获得ICMP echo reply对象</span></div><div class="line"><span class="keyword">let</span> echo_reply = <span class="keyword">match</span> icmp::echo_reply::EchoReplyPacket::new(icmp_packet.packet()) {</div><div class="line">    Some(echo_reply) =&gt; echo_reply,</div><div class="line">    None =&gt; {</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 一般使用进程的id做identifier。我们检查回包是不是和pid一致</span></div><div class="line"><span class="keyword">if</span> echo_reply.get_identifier() != pid {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 检查有没有改包</span></div><div class="line"><span class="keyword">if</span> payloads[echo_reply.get_sequence_number() <span class="keyword">as</span> usize % payloads.len()][<span class="number">16</span>..]</div><div class="line">    != echo_reply.payload()[<span class="number">16</span>..]</div><div class="line">{</div><div class="line">    warn!(</div><div class="line">        <span class="string">"bitflip detected! seq={:?},"</span>,</div><div class="line">        echo_reply.get_sequence_number()</div><div class="line">    );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 准备统计数据</span></div><div class="line"><span class="keyword">let</span> payload = echo_reply.payload();</div><div class="line"><span class="keyword">let</span> ts_bytes = &payload[..<span class="number">16</span>];</div><div class="line"><span class="keyword">let</span> txts = u128::from_be_bytes(ts_bytes.try_into().unwrap());</div><div class="line"><span class="keyword">let</span> dest_ip = ipv4_packet.get_source();</div><div class="line"></div><div class="line"><span class="keyword">let</span> now = SystemTime::now();</div><div class="line"><span class="keyword">let</span> since_the_epoch = now.duration_since(UNIX_EPOCH).unwrap();</div><div class="line"><span class="keyword">let</span> timestamp = since_the_epoch.as_nanos();</div><div class="line"></div><div class="line"><span class="comment">// 把返回结果加入到统计数据的bucket中</span></div><div class="line"><span class="keyword">let</span> buckets = read_buckets.lock().unwrap();</div><div class="line">buckets.add_reply(</div><div class="line">    txts / <span class="number">1_000_000_000</span>,</div><div class="line">    Result {</div><div class="line">        ...</div><div class="line">    },</div><div class="line">);</div></pre></td></tr></table></figure>

<p>这样，接收数据的逻辑也完成。它的主要工作就是不停的收包，收包，然后把统计信息扔给统计模块进行统计输出。</p>
<h2 id="统计逻辑">统计逻辑</h2>
<p>统计模块中定义了<code>Buckets</code>,代表当前还未处理的一批篮子(bucket)。因为发送万数据我们还需要留出缓冲时间(delay)等待回包，所以我们会保留最近一段时间的篮子，让回包有足够的时间翻入到相应的篮子中。<br>因为我们是按照秒进行统计的，每个篮子代表一秒内发送的包以及它相应的回包信息。我们只需每秒定时的把最久的篮子摘取掉，把它的统计数据输出出来就好了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(Default)]</span></div><div class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> Buckets {</div><div class="line">    <span class="keyword">pub</span> buckets: Mutex&lt;BinaryHeap&lt;Bucket&gt;&gt;,</div><div class="line">    <span class="keyword">pub</span> map: Mutex&lt;HashMap&lt;u128, Bucket&gt;&gt;,</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>buckets</code>实现了一个最小堆，这样我们就方便的弹出最久的那个篮子。<code>map</code>保存每一个篮子，方便我们查找和更新，它的主键是时间戳(以秒为单位)。</p>
<p>接下来它要实现<code>add</code>、<code>add_reply</code>、<code>pop</code>、<code>last</code>等方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span> Buckets {</div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Buckets {</div><div class="line">        Buckets {</div><div class="line">            buckets: Mutex::new(BinaryHeap::new()),</div><div class="line">            map: Mutex::new(HashMap::new()),</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&<span class="keyword">self</span>, key: u128, value: Result) {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = <span class="keyword">self</span>.map.lock().unwrap();</div><div class="line">        map.entry(key).or_insert_with(|| {</div><div class="line">            <span class="keyword">let</span> bucket = Bucket {</div><div class="line">                key,</div><div class="line">                value: RwLock::new(HashMap::new()),</div><div class="line">            };</div><div class="line">            <span class="keyword">self</span>.buckets.lock().unwrap().push(bucket.clone());</div><div class="line">            bucket</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="keyword">let</span> bucket = map.get(&key).unwrap();</div><div class="line">        bucket.add(value);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_reply</span></span>(&<span class="keyword">self</span>, key: u128, result: Result) {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = <span class="keyword">self</span>.map.lock().unwrap();</div><div class="line"></div><div class="line">        map.entry(key).or_insert_with(|| {</div><div class="line">            <span class="keyword">self</span>.buckets.lock().unwrap().push(Bucket::new(key));</div><div class="line">            Bucket::new(key)</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="keyword">let</span> bucket = map.get(&key).unwrap();</div><div class="line">        bucket.add_reply(result);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&<span class="keyword">self</span>) -&gt; Option&lt;Bucket&gt; {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buckets = <span class="keyword">self</span>.buckets.lock().unwrap();</div><div class="line">        <span class="keyword">let</span> bucket = buckets.pop()?;</div><div class="line">        <span class="keyword">let</span> bucket = <span class="keyword">self</span>.map.lock().unwrap().remove(&bucket.key).unwrap();</div><div class="line">        Some(bucket)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">last</span></span>(&<span class="keyword">self</span>) -&gt; Option&lt;Bucket&gt; {</div><div class="line">        <span class="keyword">let</span> buckets = <span class="keyword">self</span>.buckets.lock().unwrap();</div><div class="line">        buckets.peek().cloned()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>add</code>方法主要是发送模块使用，在发送一个数据后，根据发送时间戳，放入到对应的篮子中。<br><code>add_reply</code>方法主要是接收模块使用，在接收一个数据后，更新它的时延，并标记此seq已经接收到数据了。<br><code>pop</code>和<code>last</code>方便统计的时候使用。因为定时器需要定时的检查最后的篮子存不存在，应不应该进行统计。</p>
<p><code>Bucket</code>代表一个篮子，对应每一秒的统计数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> Bucket {</div><div class="line">    <span class="keyword">pub</span> key: u128,</div><div class="line">    <span class="keyword">pub</span> value: RwLock&lt;HashMap&lt;String, Result&gt;&gt;,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Clone <span class="keyword">for</span> Bucket {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&<span class="keyword">self</span>) -&gt; Self {</div><div class="line">        <span class="keyword">let</span> value = <span class="keyword">self</span>.value.read().unwrap().clone();</div><div class="line"></div><div class="line">        Bucket {</div><div class="line">            key: <span class="keyword">self</span>.key,</div><div class="line">            value: RwLock::new(value),</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>key</code>使用时间戳(截短到秒)， value值代表每一个seq对应的请求和响应数据。<br>它的方法就不赘述了，就是和Buckets的方法对应，<code>add</code>和<code>add_reply</code>用来增加和更新统计数据。</p>
<p>以上<code>Buckets</code>和<code>Bucket</code>是数据结构，定义好这个数据结构后，就可以方便的统计了。</p>
<p>统计模块使用定时器每秒进行统计:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> ticker = Ticker::new(<span class="number">0</span>.., Duration::from_secs(<span class="number">1</span>));</div><div class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> ticker {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>...</code>中的逻辑主要是检查最久的Bucket，如果是已经处理的Bucket,那么就丢弃，如果是要待处理的数据，那么进行统计和输出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buckets = buckets.lock().unwrap();</div><div class="line"><span class="keyword">let</span> bucket = buckets.last(); <span class="comment">// 得到最久的篮子</span></div><div class="line"><span class="keyword">if</span> bucket.is_none() {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 检查篮子是否已经处理过了</span></div><div class="line"><span class="keyword">let</span> bucket = bucket.unwrap();</div><div class="line"><span class="keyword">if</span> bucket.key &lt;= last_key {</div><div class="line">    buckets.pop();</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> bucket.key</div><div class="line">    &lt;= SystemTime::now()</div><div class="line">        .duration_since(UNIX_EPOCH)</div><div class="line">        .unwrap()</div><div class="line">        .as_nanos()</div><div class="line">        - delay</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Some(pop) = buckets.pop() {</div><div class="line">        <span class="keyword">if</span> pop.key &lt; bucket.key {</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        last_key = pop.key;</div><div class="line"></div><div class="line">        <span class="comment">// 统计结果</span></div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> target_results = BTreeMap::new();</div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// 打印统计结果</span></div><div class="line">        </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上就是统计模块的逻辑。只要定义好合适的数据结构，我们的统计分析就很容易实现了。</p>
<h2 id="软硬件时间戳">软硬件时间戳</h2>
<p>在写本文的初稿的时候，我还没有为mping-rs实现软硬件的时间戳， 原因是缺乏相应的资料。在网上搜了n次之后，也每找到有用的资料和范例，虽然nix和libc也一些些代码，但是缺乏相应的文档或者示例。</p>
<p>在咨询了chatgpt3.5、claude.ai、bard等AI助手后，它们给出的例子都是胡说八道的，这也说明网上资料比较少，它们还没有正确的推理，不过在挣扎了一天后，通过chatgpt4.0和Go版本的mping,终于实现了软硬件的时间戳，chatgpt能给出80%正确的代码，再结合我在Go版本中实现的经验，最终实现的这个软硬件时间戳版本可以正常运行了。因为网上缺乏相应的资料，你如果对这一块感兴趣，可以参考实现。</p>
<p>这个版本和Go版本的略有不同，Go版本的mping对于低版本的内核，不支持<code>SO_TIMESTAMPING</code>的话，会退化使用<code>SO_TIMESTAMPNS</code>,而mping-rs会使用<code>SO_TIMESTAMP</code>,这并没有啥特殊的设计，两者都可以，知识从Out-Of-Bound控制数据中读取的数据结构略有不同。</p>
<p>我以接收数据的时候为例，介绍如何把返回的数据包进入网卡后设计的硬件时间戳获取出来。对于发送的时候，包进入本地socket的缓存，你的应用层的调用就返回了，这个时候还没有进入内核的协议栈的处理，你想一想你怎么获取协议栈设置的软件时间戳甚至网卡驱动设置的硬件时间戳？</p>
<p>要读取软硬件时间戳，你需要<code>setsockopt</code>把相应的参数设置上。<br>比较新的Linux内核版本支持<code>SO_TIMESTAMPING</code>选项，你设置这个选项的时候需要设置一堆的flags,指定要不要把发送和接收的软硬件时间戳的flag加上，把CMSG和TSONLY flag设置上，这就我们就能从控制信息中获取到时间戳了。如果你同时设置软硬件时间戳，它会尽量返回硬件时间戳，如果你的机器不支持硬件时间戳，那么它返回软件时间戳，再如果你的机器软件时间戳都不支持，那它没有时间戳可返回。</p>
<p>以下逻辑就是设置这些参数，先尝试设置<code>SO_TIMESTAMPING</code>选项,不成功的话再尝试设置<code>SO_TIMESTAMP选项</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> enable = SOF_TIMESTAMPING_SOFTWARE</div><div class="line">    | SOF_TIMESTAMPING_TX_SOFTWARE</div><div class="line">    | SOF_TIMESTAMPING_RX_SOFTWARE</div><div class="line">    | SOF_TIMESTAMPING_SYS_HARDWARE</div><div class="line">    | SOF_TIMESTAMPING_TX_HARDWARE</div><div class="line">    | SOF_TIMESTAMPING_RX_HARDWARE</div><div class="line">    | SOF_TIMESTAMPING_RAW_HARDWARE</div><div class="line">    | SOF_TIMESTAMPING_OPT_CMSG</div><div class="line">    | SOF_TIMESTAMPING_OPT_TSONLY;</div><div class="line"><span class="keyword">let</span> ret = <span class="keyword">unsafe</span> {</div><div class="line">    setsockopt(</div><div class="line">        socket2.as_raw_fd(),</div><div class="line">        SOL_SOCKET,</div><div class="line">        SO_TIMESTAMPING,</div><div class="line">        &enable <span class="keyword">as</span> *<span class="keyword">const</span> <span class="number">_</span> <span class="keyword">as</span> *<span class="keyword">const</span> c_void,</div><div class="line">        mem::size_of_val(&enable) <span class="keyword">as</span> <span class="keyword">u32</span>,</div><div class="line">    )</div><div class="line">};</div><div class="line"><span class="keyword">if</span> ret == -<span class="number">1</span> {</div><div class="line">    warn!(<span class="string">"Failed to set read SO_TIMESTAMPING"</span>);</div><div class="line">    <span class="keyword">let</span> enable: c_int = <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> ret = <span class="keyword">unsafe</span> {</div><div class="line">        setsockopt(</div><div class="line">            socket2.as_raw_fd(),</div><div class="line">            SOL_SOCKET,</div><div class="line">            SO_TIMESTAMP,</div><div class="line">            &enable <span class="keyword">as</span> *<span class="keyword">const</span> <span class="number">_</span> <span class="keyword">as</span> *<span class="keyword">const</span> c_void,</div><div class="line">            std::mem::size_of_val(&enable) <span class="keyword">as</span> <span class="keyword">u32</span>,</div><div class="line">        )</div><div class="line">    };</div><div class="line">    <span class="keyword">if</span> ret == -<span class="number">1</span> {</div><div class="line">        warn!(<span class="string">"Failed to set SO_TIMESTAMP"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为我们需要读取控制信息， socket2库提供的Socket不支持相应额度读取，官方仓库中也有issue提到这个需求，但是没人实现，所以我们需要使用<code>libc</code>的<code>recvmsg</code>方法实现。 Go语言开发者(Gopher)应该庆幸Rob Pike这些大师在设计Go标准库的经验和能力，Go标准库早就支持方便的读取OOB控制数据了。</p>
<p>而使用libc的系统调用读取OOB数据还比较麻烦，首先我们要准备一些数据,最终组成一个<code>msghdr</code>变量，这是<code>recvmsg</code>系统调用所必须的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> buffer: [<span class="keyword">u8</span>; <span class="number">2048</span>] = [<span class="number">0</span>; <span class="number">2048</span>];</div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> control_buf = [<span class="number">0</span>; <span class="number">1024</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> iovec = iovec {</div><div class="line">    iov_base: buffer.as_mut_ptr() <span class="keyword">as</span> *<span class="keyword">mut</span> c_void,</div><div class="line">    iov_len: buffer.len(),</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> msghdr = msghdr {</div><div class="line">    msg_name: std::ptr::null_mut(),</div><div class="line">    msg_namelen: <span class="number">0</span>,</div><div class="line">    msg_iov: &<span class="keyword">mut</span> iovec,</div><div class="line">    msg_iovlen: <span class="number">1</span>,</div><div class="line">    msg_control: control_buf.as_mut_ptr() <span class="keyword">as</span> *<span class="keyword">mut</span> c_void,</div><div class="line">    msg_controllen: control_buf.len(),</div><div class="line">    msg_flags: <span class="number">0</span>,</div><div class="line">};</div></pre></td></tr></table></figure>

<p>然后我们改造一下读取的逻辑，换成<code>recvmsg</code>系统调用:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> nbytes = <span class="keyword">unsafe</span> { recvmsg(socket2.as_raw_fd(), &<span class="keyword">mut</span> msghdr, <span class="number">0</span>) };</div><div class="line">        <span class="keyword">if</span> nbytes == -<span class="number">1</span> {</div><div class="line">            <span class="keyword">let</span> err = Error::last_os_error();</div><div class="line">            <span class="keyword">if</span> err.kind() == ErrorKind::WouldBlock {</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            error!(<span class="string">"Failed torr receive message"</span>);</div><div class="line">            <span class="keyword">return</span> Err(Error::new(ErrorKind::Other, <span class="string">"Failed to receive message"</span>).into());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">let</span> buf = &buffer[..nbytes <span class="keyword">as</span> usize];</div><div class="line"></div><div class="line">        <span class="keyword">let</span> ipv4_packet = Ipv4Packet::new(buf).unwrap();</div><div class="line">        <span class="keyword">let</span> icmp_packet = pnet_packet::icmp::IcmpPacket::new(ipv4_packet.payload()).unwrap();</div><div class="line">        ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>和先前的代码逻辑比较，这一块改动并不大，主要是替换成<code>recvmsg</code>。后面的ICMP的处理都是一样的。</p>
<p>但是这里我们通过<code>msghdr</code>这个变量，就可以得到控制信息<code>msg_control</code>,长度是<code>msg_controllen</code>。<br>接下来我们处理控制信息，从里面把时间戳的控制信息解析出来，我把它抽取成了一个函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_timestamp</span></span>(msghdr: &<span class="keyword">mut</span> msghdr) -&gt; Option&lt;SystemTime&gt; {</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cmsg: *<span class="keyword">mut</span> cmsghdr = <span class="keyword">unsafe</span> { libc::CMSG_FIRSTHDR(msghdr) };</div><div class="line"></div><div class="line">    <span class="keyword">while</span> !cmsg.is_null() {</div><div class="line">        <span class="keyword">if</span> <span class="keyword">unsafe</span> { (*cmsg).cmsg_level == SOL_SOCKET && (*cmsg).cmsg_type == SO_TIMESTAMP } {</div><div class="line">            <span class="keyword">let</span> tv: *<span class="keyword">mut</span> timeval = <span class="keyword">unsafe</span> { libc::CMSG_DATA(cmsg) } <span class="keyword">as</span> *<span class="keyword">mut</span> timeval;</div><div class="line">            <span class="keyword">let</span> timestamp = <span class="keyword">unsafe</span> { *tv };</div><div class="line">            <span class="keyword">return</span> Some(</div><div class="line">                SystemTime::UNIX_EPOCH</div><div class="line">                    + Duration::new(timestamp.tv_sec <span class="keyword">as</span> <span class="keyword">u64</span>, timestamp.tv_usec <span class="keyword">as</span> <span class="keyword">u32</span> * <span class="number">1000</span>),</div><div class="line">            );</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> <span class="keyword">unsafe</span> { (*cmsg).cmsg_level == SOL_SOCKET && (*cmsg).cmsg_type == SCM_TIMESTAMPING } {</div><div class="line">            <span class="keyword">let</span> tv: *<span class="keyword">mut</span> [timespec; <span class="number">3</span>] = <span class="keyword">unsafe</span> { libc::CMSG_DATA(cmsg) } <span class="keyword">as</span> *<span class="keyword">mut</span> [timespec; <span class="number">3</span>];</div><div class="line">            <span class="keyword">let</span> timestamps = <span class="keyword">unsafe</span> { *tv };</div><div class="line"></div><div class="line">            <span class="keyword">for</span> timestamp <span class="keyword">in</span> &timestamps {</div><div class="line">                <span class="keyword">if</span> timestamp.tv_sec != <span class="number">0</span> || timestamp.tv_nsec != <span class="number">0</span> {</div><div class="line">                    <span class="keyword">let</span> seconds = Duration::from_secs(timestamp.tv_sec <span class="keyword">as</span> <span class="keyword">u64</span>);</div><div class="line">                    <span class="keyword">let</span> nanoseconds = Duration::from_nanos(timestamp.tv_nsec <span class="keyword">as</span> <span class="keyword">u64</span>);</div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> Some(duration) = seconds.checked_add(nanoseconds) {</div><div class="line">                        <span class="keyword">return</span> Some(SystemTime::UNIX_EPOCH + duration);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        cmsg = <span class="keyword">unsafe</span> { libc::CMSG_NXTHDR(msghdr, cmsg) };</div><div class="line">    }</div><div class="line"></div><div class="line">    None</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为控制信息中可能包含多条信息，我们需要遍历找出我们需要的控制信息。<br>对于设置了<code>SO_TIMESTAMPING</code>的场景，我们可以通过<code>(*cmsg).cmsg_level == SOL_SOCKET &amp;&amp; (*cmsg).cmsg_type == SCM_TIMESTAMPING</code>把控制信息筛选到，它的信息是包含三个timespec的数据，一般信息会放在第一个元素中，但是也可能放入第三个或者第二个，我们依次遍历这三个元素，找到第一个非零的元素即可。</p>
<p>对于设置了<code>SO_TIMESTAMP</code>的场景，我们可以通过<code>(*cmsg).cmsg_level == SOL_SOCKET &amp;&amp; (*cmsg).cmsg_type == SO_TIMESTAMP</code>筛选出来，它的值是一个类型为<code>timeval</code>的值，包含秒数和微秒数。</p>
<p>这样我们就获取了软硬件的时间戳。</p>
<p>Rust版本mping和Go版本的mping我并没有做性能上的详细对比。简单谈一下。</p>
<p><strong>二进制大小</strong><br>Rust版本的mping生成的二进制大小是<strong>7M</strong>，而Go版本的是<strong>3.3M</strong>。<br>对于Rust版本，我们可以在<code>Cargo.toml</code>中添加上下面的信息进行优化，剔除符号表等信息:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">[profile.release]</span></div><div class="line"><span class="setting">lto = <span class="value"><span class="keyword">true</span></span></span></div><div class="line"><span class="setting">strip = <span class="value"><span class="keyword">true</span> </span></span></div><div class="line"><span class="setting">opt-level = <span class="value"><span class="string">"z"</span> </span></span></div><div class="line"><span class="setting">codegen-units = <span class="value"><span class="number">1</span></span></span></div></pre></td></tr></table></figure>

<p>优化后的大小是Rust版本的大小是<strong>1.6M</strong>,Go版本大小是<strong>2.1M</strong>。</p>
<p>优化后的Rust版本的mping占优。</p>
<p><strong>CPU和内存</strong><br>都执行<code>sudo  ./mping  -r 100 8.8.8.8,8.8.4.4,github.com</code>的情况下(腾讯云的一个轻量级服务器，2个虚拟核)<br>Rust版本的mping探测下面的目标的CPU占用<strong>0.6%</strong>，内存忽略不记。<br>Go版本的mping探测下面的目标的CPU占用<strong>4.2%</strong>，内存忽略不记。</p>
<p>Rust版本的mping占优。</p>
<p><strong>时延</strong><br>探测8.8.8.8, 看时延：<code>sudo  ./mping  -r 100 8.8.8.8</code></p>
<p>Rust版本的波动比较大，从<code>163.58ms</code>到<code>166.82ms</code>都有。<br>Go版本的比较稳定，基本在<code>164.50ms</code>到<code>165.25ms</code>之间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上个月我使用go实现了一个探测多目标的高频探测程序<a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a>, 并且在后续的开发中支持了硬件时间戳和软件时间戳，提供更精准的时延。</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[何时以及如何高效的使用经典的bpf, 它能到来什么好处？]]></title>
    <link href="https://colobu.com/2023/09/27/when-and-how-to-use-classical-bpf/"/>
    <id>https://colobu.com/2023/09/27/when-and-how-to-use-classical-bpf/</id>
    <published>2023-09-27T05:17:17.000Z</published>
    <updated>2023-09-27T06:20:00.024Z</updated>
    <content type="html"><![CDATA[<p>Classical BPF(cBPF, 伯克利包过滤器)是一种用来过滤网络数据包的技术。它像一个钩子一样挂载在网络栈的关键路径上,可以在数据包<strong>进入</strong>协议栈之前,根据预设规则来过滤或处理网络数据包。</p>
<a id="more"></a>
<p>相比于一般的软件包过滤方案,Classical BPF有以下优点:</p>
<ul>
<li>效率高:因为它运行在内核空间,可以避免不必要的内核态和用户态切换,也省去多次数据复制的开销。</li>
<li>安全:它不能随意访问系统内存或修改数据包,只能根据规则过滤,不会引起安全隐患。</li>
<li>灵活:过滤规则可以动态更新,使包过滤功能更加灵活。</li>
</ul>
<p>Classical BPF通常应用于网络监控、防火墙、流量控制等场景。它为包过滤提供了一个高效、安全、灵活的解决方案。但功能较为受限,只能过滤包不能修改。</p>
<p>我在百度做了三年多的网络监控了，我们会使用各种各样的方式来监控整个百度的物理网络，这些监控方式不同于普通的TCP Server/Client或者 UDP程序，一般我们会采用raw socket的方式来做包的探测和网络监控，为了高效的使用raw socket,避免把内核协议层的所有包都复制到应用层，我们会使用cBPF对收到的包进行过滤，我们只从内核层复制特定类型的包到应用层， 比如只复制UDP协议目的端口在20000 ~ 21000的数据包。 </p>
<p>怎么做到呢？就是使用cBPF。</p>
<p>我在先前的文章<a href="https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/" target="_blank" rel="external">使用BPF, 将Go网络程序的吞吐提升8倍</a>举了一个使用cBPF的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">cc := conn.(*net.IPConn)</div><div class="line">cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">pconn := ipv4.NewPacketConn(conn)</div><div class="line"><span class="keyword">var</span> assembled []bpf.RawInstruction</div><div class="line"><span class="keyword">if</span> assembled, err = bpf.Assemble(filter); err != <span class="constant">nil</span> {</div><div class="line">	log.Print(err)</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div><div class="line">pconn.SetBPF(assembled)</div><div class="line">handleConn(conn)</div></pre></td></tr></table></figure>

<p>可以使用<code>ipv4.PacketConn</code>的<code>SetBPF</code>方法设置过滤器:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">// 加载目的端口</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val: <span class="typename">uint32</span>(*port), SkipFalse:<span class="number"> 1</span>}, <span class="comment">// 如果目的端口 != 8972，则跳过一行，到了最后一，包丢弃了instruction</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},                                      <span class="comment">// 返回 0xffff，接收包</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">//  返回0字节, 代表忽略这个包</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们根据IP协议进行简单的分析。这里我们没有做过多的兼容检查，因为我们自己知道我们处理的是IPv4的包，而且包中也没有Option选项:<br><img src="IPv4_Packet.png" alt=""></p>
<p>IP的头部20个字节，payload是UDP包：<br><img src="udp.jpg" alt=""></p>
<p>可以看到UDP的前两个字节是源端口， 接下来两个字节是目的端口。</p>
<p>所以从IP header开始，第22 ~ 24字节是目的端口，所以<code>bpf.LoadAbsolute{Off: 22, Size: 2},</code>就是把这两个字节读取出来，和我们的值进行比较，看看是不是我们期望的值。</p>
<p>那么如果想使用<code>cBPF</code>,就得会写<code>bpf.Instruction</code>, 你得熟悉各种协议，以及bpf的指令。<br>不想学啊！累，麻烦！易出错！不好调试!</p>
<p>没关系，我写了一个库，只要你会使用tcpdump/wireshark,会使用他们的过滤器写法，就能写出相应的指令来。</p>
<p>比如 <code>tcpdump -i any -nn -vvvv tcp port 8080</code>这样一个命令，它的过滤器是<code>tcp port 8080</code>, 你这个使用这个库的下面的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raws, err := ParseTcpdumpFitlerExpr(layers.LinkTypeIPv4, <span class="string">"tcp port 8080"</span>)</div></pre></td></tr></table></figure>

<p>调用这个函数你会得到编译好的指令<code>[]bpf.RawInstruction</code>，然后调用<code>pconn.SetBPF(raws)</code>就可以了。</p>
<p>如果，你想得到它的Go代码形式，你可以调用<code>s = CreateInstructionsFromExpr(layers.LinkTypeIPv4, &quot;dst host 8.8.8.8 and icmp&quot;)</code>,<br>它会过滤只保留目的IP地址是<code>8.8.8.8</code>并且是icmp的包，生成的指令如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filter = []bpf.Instruction {</div><div class="line">        	bpf.LoadConstant{Dst:<span class="number"> 0</span>,Val:<span class="number"> 0</span>},</div><div class="line">        	bpf.LoadAbsolute{Off:<span class="number"> 16</span>,Size:<span class="number"> 4</span>},</div><div class="line">        	bpf.JumpIf{Cond:<span class="number"> 1</span>,Val:<span class="number"> 134744072</span>,SkipTrue:<span class="number"> 3</span>} <span class="comment">//  134744072 = 0x8080808,</span></div><div class="line">        	bpf.LoadAbsolute{Off:<span class="number"> 9</span>,Size:<span class="number"> 1</span>},</div><div class="line">        	bpf.JumpIf{Cond:<span class="number"> 1</span>,Val:<span class="number"> 1</span>,SkipTrue:<span class="number"> 1</span>},</div><div class="line">        	bpf.RetConstant{Val:<span class="number"> 0</span>x1},</div><div class="line">        	bpf.RetConstant{Val:<span class="number"> 0</span>x0},</div><div class="line">        }</div></pre></td></tr></table></figure>

<p><code>bpf.LoadAbsolute{Off: 16,Size: 4},</code>是加载IP头中的目的IP地址，检查是不是等于<code>8.8.8.8</code>，如果是，则检查协议(odd:9)是不是ICMP(icmp的协议号是1)。</p>
<p>所以即使你不熟悉各种协议，根据tcpdump的过滤表达式也能生成编译好的bpf代码，或者得到Go语言的代码片段。</p>
<p>对了，这个库是<a href="https://github.com/smallnest/qianmo/blob/master/bpf.go" target="_blank" rel="external">阡陌</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Classical BPF(cBPF, 伯克利包过滤器)是一种用来过滤网络数据包的技术。它像一个钩子一样挂载在网络栈的关键路径上,可以在数据包<strong>进入</strong>协议栈之前,根据预设规则来过滤或处理网络数据包。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从头再读取 io.Reader: 覆水难收？]]></title>
    <link href="https://colobu.com/2023/09/24/reread-the-io-Reader/"/>
    <id>https://colobu.com/2023/09/24/reread-the-io-Reader/</id>
    <published>2023-09-24T14:17:38.000Z</published>
    <updated>2023-09-27T05:14:41.340Z</updated>
    <content type="html"><![CDATA[<p>前几天，我们百度的同学分享了Go标准库中一段好玩的好玩的代码， <code>net/http/response.go</code>中一段检查HTTP的headser中<code>Content-Length</code>未设置的情况下，对<code>http.Body</code>的有趣的处理。</p>
<a id="more"></a>
<p>我们知道<code>io.Reader</code>提供了<code>Read</code>方法，并没有将读取的数据再塞回去的方法，而且对于流式的Reader,也绝无可能将数据塞回去。就像覆水难收一样，泼出去的水，没办法收回来了。</p>
<p>如果我们想从Reader读取一部分字节，做一些处理(一般是做一些检查)，然后想再让调用者从头开始读取咋办？</p>
<p><code>net/http/response.go</code>中就有这么一段代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clone it, so we can modify r1 as needed.</span></div><div class="line">r1 := <span class="built_in">new</span>(Response)</div><div class="line">*r1 = *r</div><div class="line"><span class="keyword">if</span> r1.ContentLength ==<span class="number"> 0</span> && r1.Body != <span class="constant">nil</span> {</div><div class="line">	<span class="comment">// Is it actually 0 length? Or just unknown?</span></div><div class="line">	<span class="keyword">var</span> buf <span class="number">[1</span>]<span class="typename">byte</span></div><div class="line">	n, err := r1.Body.Read(buf[:])</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> && err != io.EOF {</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> n ==<span class="number"> 0</span> {</div><div class="line">		<span class="comment">// Reset it to a known zero reader, in case underlying one</span></div><div class="line">		<span class="comment">// is unhappy being read repeatedly.</span></div><div class="line">		r1.Body = NoBody</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		r1.ContentLength =<span class="number"> -1</span></div><div class="line">		r1.Body = <span class="keyword">struct</span> {</div><div class="line">			io.Reader</div><div class="line">			io.Closer</div><div class="line">		}{</div><div class="line">			io.MultiReader(bytes.NewReader(buf[<span class="number">:1</span>]), r.Body),</div><div class="line">			r.Body,</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码主要是针对响应(Response)对象做了一次克隆(Clone),目的是为了能够安全地修改响应对象,而不影响原始的响应对象。</p>
<p>具体来看:</p>
<ol>
<li>r1 := new(Response) 创建一个新的响应对象</li>
<li>r1 = r 让r1成为原始响应r的克隆</li>
<li>接下来判断如果响应内容长度r1.ContentLength == 0 且响应体r1.Body != nil</li>
<li>这说明内容长度标记为0,但实际上响应体不为空。这种情况下无法确定内容究竟是0长度还是长度未知。</li>
<li>所以读取1字节到buf,以判断响应体是否真是0长度。</li>
<li>如果读取到EOF,说明响应体确实长度为0,将Body重置为NoBody。</li>
<li>否则说明长度未知,将ContentLength设置为-1,并用MultiReader将已读取的1字节内容和原Body组合,作为新Body。</li>
<li>这样通过克隆的响应对象r1,可以安全地修改ContentLength和Body,而不影响原始响应对象r。</li>
</ol>
<p>这段代码通过克隆请求对象,巧妙地处理了内容长度标记为0但实际有内容的情况,避免了对原始响应对象的修改。</p>
<p>它先读取了1个字节，来判断Body是否为空，不为空在通过<code>io.MultiReader(bytes.NewReader(buf[:1]), r.Body),</code>把这一个字节和原来的io.Reader(<code>r.Body</code>)在捏合在一起，形成一个新的io.Reader。</p>
<p>通过<code>io.MultiReader</code>新建一个 io.Reader,就可以把已读取的字节和剩余未读取的字节组合起来，形成都未读取的Reader。</p>
<p>标准库<code>net/http/transfer.go</code>中也有一段相同的逻辑处理。</p>
<p>这让我想起了<a href="https://github.com/soheilhy/cmux" target="_blank" rel="external">soheilhy/cmux</a>, <a href="http://rpcx.io" target="_blank" rel="external">rpcx</a>最早使用它在一个端口上提供不同传输的协议。</p>
<p>cmux也是预先读取一部分数据，和预先配置的Matcher进行匹配，如果匹配成功，比如HTTP1.1协议，那么这个连接后续就按照HTTP1.1协议进行解析。那么预先读取的这些字节也得交给解析器从头开始解析，否则数据就缺失了，那么它是怎么实现的呢？</p>
<p>cmux使用老二另外一个方法，它创建了一个bufferedReader:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> bufferedReader <span class="keyword">struct</span> {</div><div class="line">	source     io.Reader</div><div class="line">	buffer     bytes.Buffer</div><div class="line">	bufferRead <span class="typename">int</span></div><div class="line">	bufferSize <span class="typename">int</span></div><div class="line">	sniffing   <span class="typename">bool</span></div><div class="line">	lastErr    error</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当连接开始在侦探和哪个Matcher匹配的时候， conn连接会把数据写入到这个buffer中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *bufferedReader) Read(p []<span class="typename">byte</span>) (<span class="typename">int</span>, error) {</div><div class="line">	<span class="keyword">if</span> s.bufferSize &gt; s.bufferRead { <span class="comment">// buffer中有未读的数据，先读取这个</span></div><div class="line">		bn := <span class="built_in">copy</span>(p, s.buffer.Bytes()[s.bufferRead:s.bufferSize])</div><div class="line">		s.bufferRead += bn</div><div class="line">		<span class="keyword">return</span> bn, s.lastErr</div><div class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> !s.sniffing && s.buffer.Cap() !=<span class="number"> 0</span> {</div><div class="line">		s.buffer = bytes.Buffer{}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 从原始的conn中读取</span></div><div class="line">	sn, sErr := s.source.Read(p)</div><div class="line">	<span class="keyword">if</span> sn &gt;<span class="number"> 0</span> && s.sniffing { <span class="comment">// 如果还在侦探状态，把读取的数据写入到buffer中</span></div><div class="line">		s.lastErr = sErr</div><div class="line">		<span class="keyword">if</span> wn, wErr := s.buffer.Write(p[:sn]); wErr != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> wn, wErr</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sn, sErr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦侦探完成(match一个协议)，那么就会把读取的指针置为最开始的地方，从头开始读取，根据上面的方法的逻辑，读取完buffer就从原始conn中读取，也不会再往buffer中写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *MuxConn) doneSniffing() {</div><div class="line">	m.buf.reset(<span class="constant">false</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *bufferedReader) reset(snif <span class="typename">bool</span>) {</div><div class="line">	s.sniffing = snif</div><div class="line">	s.bufferRead =<span class="number"> 0</span> <span class="comment">// 退回到原点，从最开始的数据开始读</span></div><div class="line">	s.bufferSize = s.buffer.Len() <span class="comment">// 已读取的数据</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过这种方式，也实现了预读取的功能。</p>
<p>看起来，在Go语言中，还真的能覆水再回收。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天，我们百度的同学分享了Go标准库中一段好玩的好玩的代码， <code>net/http/response.go</code>中一段检查HTTP的headser中<code>Content-Length</code>未设置的情况下，对<code>http.Body</code>的有趣的处理。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更精准的时延：使用软件时间戳和硬件时间戳]]></title>
    <link href="https://colobu.com/2023/09/24/precise-rtt-for-ping/"/>
    <id>https://colobu.com/2023/09/24/precise-rtt-for-ping/</id>
    <published>2023-09-24T07:05:41.000Z</published>
    <updated>2023-09-24T08:54:38.332Z</updated>
    <content type="html"><![CDATA[<p>在我上一篇文章<a href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/" target="_blank" rel="external">mping: 使用新的icmp库实现探测和压测工具</a>文章中，介绍了使用新的第三方库icmpx使用ping的功能,实现了mping这样一个高性能的探测和压测工具，并且还计算了往返时延指标(RTT, Round Trip Time)。</p>
<p>有时候，我们在做应用开发的时候，比如微服务调用的时候，也常常会计算程序的延时(latency)。</p>
<a id="more"></a>
<h2 id="网络时延">网络时延</h2>
<p>一般情况下，我们通过在应用层读取时间戳，计算两个时间戳的延时($t1 - t0$)，就可以得到时延，就足够了。通过观察这个数据，我们可以看到网络的时延情况(latency)和抖动(jitter)。但是有时候,我们想知道物理网络传输网络的时延是多少，比如北京A机房到B机房的时延，如果通过应用层的时间戳来计算，误差就太大了。为什么呢？</p>
<p>我们知道，当你的服务器和另外一个服务器通讯的时候，包(packet)其实经过了很漫长的链路，从你的应用程序写入本机的buffer,到本机协议栈的处理，网卡处理、网线、机房的各种网络设备、骨干网、再到对端机房、网卡、协议栈、应用程序，经过了很多很多的环节，如果还经过了云网络的话，会更复杂。其中应用层到网卡处理这一段时间，可能会因为CPU的处理能力、服务器负载、网络处理的能力，导致有比较大的耗时，如果在应用层计算网络两点之间的网络时延的话，不能正确得到两点之间的时延或者RTT。</p>
<p>一般来说，光信号在光纤中的传输速度大约为20万公里/秒，所以理论上每100公里的物理网络时延大约为0.5毫秒。但光信号在光纤上的传播时延会受到光纤材质、组件损耗、连接损耗等因素的影响,会比理论值稍大一些。另外在运营商实际网络中,还需要考虑路由器处理带来的转发时延的影响。</p>
<p>北京到广州的全程大约为2200公里。按照理论计算时延11毫秒， RTT的话需要来回的时延，所以是22毫秒，但是实际是，我使用我在北京的一个腾讯云的服务器ping广州的一台机器，时延大约38.9毫秒：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ubuntu@lab:~$ ping <span class="number">221.4</span>.<span class="number">66.66</span></div><div class="line">PING <span class="number">221.4</span>.<span class="number">66.66</span> (<span class="number">221.4</span>.<span class="number">66.66</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">251</span> time=<span class="number">38.8</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div></pre></td></tr></table></figure>

<p>这个指标对于物理网络建设以及准备使用云设施的服务器来说，非常的重要，毕竟越短的时延会给我们带来更好的性能。同时如果更好的更准确的计算这个时延也很重要了。</p>
<h2 id="软件时间戳和硬件时间戳">软件时间戳和硬件时间戳</h2>
<p>我们可以通过软件时间戳或者硬件时间戳，更精确的计算包的进入发送和接收的时间戳，去掉应用层或者协议栈层带来的误差。</p>
<p>如果硬件和驱动程序支持,网卡会在发送和接收数据包时,使用硬件计数器向数据包的时间戳字段写入一个高精度时间戳。</p>
<p>如果硬件不支持，Linux也实现实现一个软件的时间戳，协议栈处理收到和发出的包时写入一个高精度时间戳。</p>
<p><img src="timestamp.png" alt=""></p>
<ul>
<li><p>软件时间戳(Software Timestamp)<br>通过软件方式获取时间和写入数据包的时间戳。相比硬件时间戳,软件时间戳有以下特点:</p>
<ul>
<li>获取时间和写入时间戳的过程在软件层完成,不需要硬件支持。</li>
<li>时间精度较低,通常只能达到毫秒级。硬件时间戳可以达到微秒或纳秒级精度。</li>
<li>时间同步不够精确。受到软件运行开销、系统调度等因素影响。</li>
<li>对系统资源占用较大,会增加中断开销。</li>
<li>只能标记退出和进入协议栈的时间,不能精确标记发送和接收时刻。</li>
<li>不同设备之间时间同步困难,容易产生时间偏差。</li>
</ul>
</li>
<li><p>硬件时间戳(Hardware Timestamp)<br>通过硬件芯片中的计数器来获取时间和写入数据包时间戳。相比软件时间戳,硬件时间戳具有以下优点:</p>
<ul>
<li>时间精度高,可以达到纳秒或皮秒级,满足对实时性要求较高的场景。</li>
<li>时间捕获精确,可以准确标记数据包的发送时刻和接收时刻。</li>
<li>对系统资源占用少,减少了中断开销。</li>
<li>不同设备之间时间同步容易,通过协议如PTP实现同步精度高。</li>
<li>不受软件运行开销等影响,时间戳更准确。</li>
</ul>
</li>
</ul>
<p>可以通过 <code>ethtool -T &lt;网络接口名&gt;</code>来查看机器对软硬件时间戳的支持情况。比如下面这台机器软硬件时间戳都不支持<br><img src="ethtool1.png" alt=""></p>
<p>下面这台机器只支持软件时间戳：<br><img src="ethtool2.png" alt=""></p>
<p>下面这台机器支持软硬件时间戳：<br><img src="ethtool3.png" alt=""></p>
<h2 id="使用软硬件时间戳">使用软硬件时间戳</h2>
<p>Linux内核对软硬件时间戳的支持是渐进的。</p>
<p>软件时间戳(Software Timestamping)自2.6内核开始支持,通过调用clock_gettime()等时间系统调用可以获取software timestamp，timestamp精度可以达到纳秒级。但软件时间戳易受到系统调度、中断等影响,精度较差。</p>
<p>硬件时间戳(Hardware Timestamping)自3.5内核开始引入PTP硬件时间戳支持,主要应用于高精度时间同步，能够直接读取网络卡、FPGA等硬件计数器的值作为时间戳，精度可以达到纳秒甚至皮秒级。但需要硬件支持,且对驱动和读数有一定要求。</p>
<p>接下来我对mping工具进行改造，让它：</p>
<ul>
<li>如果client支持硬件时间戳，那么则使用硬件时间戳</li>
<li>如果client不支持硬件时间戳，退而求其次，使用软件时间戳</li>
<li>如果client软硬件时间戳都不支持，那么则使用应用程序的时间戳</li>
</ul>
<p>接下来我边讲解代码的同时，边讲解如何使用软硬件时间戳的。</p>
<p>因为需要对socket进行底层的设置和读写，所以使用icmpx这个库已经不合适了，我把原来的mping项目转换回<code>conn, err := net.ListenPacket(&quot;ip4:icmp&quot;, &quot;0.0.0.0&quot;)</code>的形式，这样我们就可以得到socket的文件描述符进行开启软硬件时间戳的设置，并且可以读取这些时间戳了。</p>
<h3 id="创建连接">创建连接</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> openConn() (*net.IPConn, error) {</div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:icmp"</span>, <span class="string">"0.0.0.0"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line"></div><div class="line">	ipconn := conn.(*net.IPConn)</div><div class="line">	f, err := ipconn.File()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> f.Close()</div><div class="line"></div><div class="line">	fd := <span class="typename">int</span>(f.Fd())</div><div class="line"></div><div class="line">	flags := unix.SOF_TIMESTAMPING_SYS_HARDWARE | unix.SOF_TIMESTAMPING_RAW_HARDWARE | unix.SOF_TIMESTAMPING_SOFTWARE | unix.SOF_TIMESTAMPING_RX_HARDWARE | unix.SOF_TIMESTAMPING_RX_SOFTWARE |</div><div class="line">		unix.SOF_TIMESTAMPING_TX_HARDWARE | unix.SOF_TIMESTAMPING_TX_SOFTWARE |</div><div class="line">		unix.SOF_TIMESTAMPING_OPT_CMSG | unix.SOF_TIMESTAMPING_OPT_TSONLY</div><div class="line">	<span class="keyword">if</span> err := syscall.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_TIMESTAMPING, flags); err != <span class="constant">nil</span> {</div><div class="line">		supportTxTimestamping = <span class="constant">false</span></div><div class="line">		supportRxTimestamping = <span class="constant">false</span></div><div class="line">		<span class="keyword">if</span> err := syscall.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_TIMESTAMPNS,<span class="number"> 1</span>); err == <span class="constant">nil</span> {</div><div class="line">			supportRxTimestamping = <span class="constant">true</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">return</span> ipconn, <span class="constant">nil</span></div><div class="line">	}</div><div class="line">	timeout := syscall.Timeval{Sec:<span class="number"> 1</span>, Usec:<span class="number"> 0</span>}</div><div class="line">	<span class="keyword">if</span> err := syscall.SetsockoptTimeval(fd, unix.SOL_SOCKET, unix.SO_RCVTIMEO, &timeout); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err := syscall.SetsockoptTimeval(fd, unix.SOL_SOCKET, unix.SO_SNDTIMEO, &timeout); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ipconn, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>首先我们要先创建一个icmp conn对象，通过<code>net.ListenPacket(&quot;ip4:icmp&quot;, &quot;0.0.0.0&quot;)</code>即可获得。</li>
<li>然后得到它的文件描述符(通过<code>File.Fd</code>方法)，也有通过<code>Control</code>方法得到socket的文件描述符的:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connFd <span class="typename">int</span></div><div class="line">err = conn.Control(<span class="keyword">func</span>(fd <span class="typename">uintptr</span>) {</div><div class="line">    connFd = <span class="typename">int</span>(fd) </div><div class="line">})</div></pre></td></tr></table></figure>

<p>两种方法都可以。</p>
<ul>
<li>接下来我们通过<code>SetsockoptInt</code>设置读取软硬件时间戳。 软硬件的标志都设置上，发送和接收的时间戳都设置上。你可以想想，发送的软硬件时间戳我们咋获取？应用程序把外放数据写入到缓冲区就返回了，那个时候它是得不到软硬件时间戳的。通过设置<code>SOF_TIMESTAMPING_OPT_CMSG</code>,可以在在网卡发送外发数据时，把软件或者硬件的时间戳写如到MSG_ERRQUEUE，你可以后续读取到这个时间戳。</li>
</ul>
<p>这里不会主动帮你开启硬件时间戳。如果你的硬件支持，但是没有开启的话，你可以手动开始硬件时间戳。</p>
<p>这里如果当前的操作系统不支持<code>SO_TIMESTAMPING</code>的话，那么尝试设置<code>SO_TIMESTAMPNS</code>, SO_TIMESTAMPNS自2.6以来就开始支持了。</p>
<h3 id="发送时读取发送的时间戳">发送时读取发送的时间戳</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">         ......</div><div class="line">_, err = conn.WriteTo(data, target)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div><div class="line"></div><div class="line">rs := &Result{</div><div class="line">	txts:   ts,</div><div class="line">	target: target.IP.String(),</div><div class="line">	seq:    seq,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> supportTxTimestamping {</div><div class="line">	<span class="keyword">if</span> txts, err := getTxTs(fd); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">if</span> strings.HasPrefix(err.Error(), <span class="string">"resource temporarily unavailable"</span>) {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"failed to get TX timestamp: %s"</span>, err)</div><div class="line">		rs.txts = txts</div><div class="line">	}</div><div class="line">}</div><div class="line">         ......</div><div class="line"></div><div class="line">         <span class="keyword">func</span> getTxTs(socketFd <span class="typename">int</span>) (<span class="typename">int64</span>, error) {</div><div class="line">             pktBuf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line">             oob := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line">             _, oobn, _, _, err := syscall.Recvmsg(socketFd, pktBuf, oob, syscall.MSG_ERRQUEUE)</div><div class="line">             <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                 <span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">             }</div><div class="line">             <span class="keyword">return</span> getTsFromOOB(oob, oobn)</div><div class="line">         }</div></pre></td></tr></table></figure>

<p>每写完一个数据包，则尝试从这个socket中读取发送时的软硬件时间戳，通过<code>Recvmsg</code>系统调用从<code>MSG_ERRQUEUE</code>获取。</p>
<h3 id="接收时读取软硬件时间戳">接收时读取软硬件时间戳</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  ......</div><div class="line">  _ = conn.SetReadDeadline(time.Now().Add<span class="number">(10</span> * time.Millisecond))</div><div class="line">n, oobn, _, ra, err := conn.ReadMsgIP(pktBuf, oob)</div><div class="line"></div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> rxts <span class="typename">int64</span></div><div class="line"><span class="keyword">if</span> supportRxTimestamping {</div><div class="line">	<span class="keyword">if</span> rxts, err = getTsFromOOB(oob, oobn); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get RX timestamp: %s"</span>, err)</div><div class="line">	}</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	rxts = time.Now().UnixNano()</div><div class="line">}</div><div class="line">      ......</div></pre></td></tr></table></figure>

<p><code>conn.ReadMsgIP</code>会返回Out-Of-Band的数据，接收时的软件或者硬件时间戳就写入到这里面，我们通过<code>getTsFromOOB</code>方法解析:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> getTsFromOOB(oob []<span class="typename">byte</span>, oobn <span class="typename">int</span>) (<span class="typename">int64</span>, error) {</div><div class="line">	cms, err := syscall.ParseSocketControlMessage(oob[:oobn])</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> _, cm := <span class="keyword">range</span> cms {</div><div class="line">		<span class="keyword">if</span> cm.Header.Level == syscall.SOL_SOCKET && cm.Header.Type == syscall.SO_TIMESTAMPING {</div><div class="line">			<span class="keyword">var</span> t unix.ScmTimestamping</div><div class="line">			<span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(cm.Data), binary.LittleEndian, &t); err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(t.Ts); i++ {</div><div class="line">				<span class="keyword">if</span> t.Ts[i].Nano() &gt;<span class="number"> 0</span> {</div><div class="line">					<span class="keyword">return</span> t.Ts[i].Nano(), <span class="constant">nil</span></div><div class="line">				}</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">return</span><span class="number"> 0</span>, ErrStampNotFund</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> cm.Header.Level == syscall.SOL_SOCKET && cm.Header.Type == syscall.SCM_TIMESTAMPNS {</div><div class="line">			<span class="keyword">var</span> t unix.Timespec</div><div class="line">			<span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(cm.Data), binary.LittleEndian, &t); err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> t.Nano(), <span class="constant">nil</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span>, ErrStampNotFund</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果是时间戳的数据, Level是SOL_SOCKET, Type是SO_TIMESTAMPING或者老版本的SCM_TIMESTAMPNS。</p>
<p>我们需要一个<code>unix.ScmTimestamping</code>数据类型反序列这个数据，它包含长度是3的一个数据。一般软件时间戳放入到第一个元素中，硬件时间戳放入到第三个，但是至少会有一个元素包含时间戳，我们依次遍历，看看哪一个时间戳设置了就用哪一个。</p>
<p>这个mping的例子演示了使用软硬件时间戳精确计算时延的例子，使用软硬件时间戳还可以实现更精确的时间服务PTP。 mping的代码可以从<a href="https://github.com/smallnest/mping/blob/master/ping.go" target="_blank" rel="external">github</a>上获取到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我上一篇文章<a href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/" target="_blank" rel="external">mping: 使用新的icmp库实现探测和压测工具</a>文章中，介绍了使用新的第三方库icmpx使用ping的功能,实现了mping这样一个高性能的探测和压测工具，并且还计算了往返时延指标(RTT, Round Trip Time)。</p>
<p>有时候，我们在做应用开发的时候，比如微服务调用的时候，也常常会计算程序的延时(latency)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PGO: 为你的Go程序提效5%]]></title>
    <link href="https://colobu.com/2023/09/13/pgo/"/>
    <id>https://colobu.com/2023/09/13/pgo/</id>
    <published>2023-09-13T13:52:13.000Z</published>
    <updated>2023-09-27T05:14:41.339Z</updated>
    <content type="html"><![CDATA[<p>PGO （基于profile指导的优化） 在Go 1.20 中还属于预览状态， 在Go 1.21中已经生产可用了， 未来 PGO 还有很宏伟的<a href="https://github.com/golang/go/issues/62463#issuecomment-1709485195" target="_blank" rel="external">目标</a>，但是现在已经可以很好的帮助我们提高程序的性能呢，根据程序的不同，可能会带来2% ~ 7%的提升，不要小看这个提升，如果你是在大厂做优化的专家，可以这样计算: “我厂大概有 10万Go实例，每个实例平均占用16个核，通过我们的优化，程序性能平均提升5%, 大约节省9万个核，每年为公司节省数亿元的成本”。</p>
<p>最近看到两篇关于PGO的文章：<a href="https://landontclipp.github.io/blog/2023/08/25/profile-guided-optimizations-in-go/#viewing-the-assembly" target="_blank" rel="external">Profile Guided Optimizations in Go</a> 和 Go官方的博客 <a href="https://go.dev/blog/pgo" target="_blank" rel="external">Profile-guided optimization in Go 1.21</a>。相比较而言， Go官方这篇文章简单明了，而且把·细节也交代的明明白白，所以我就把这篇文章翻译过来，我感觉我自己写也没有官方这篇写的明白，翻译过来就好了。</p>
<p>以下是译文：<br><a id="more"></a></p>
<p>2023年初,Go 1.20发布了基于profile指导的优化(PGO)的预览版本,供用户进行测试。在解决了预览版本中已知的限制,并借助社区反馈和贡献进行了进一步锤炼后,Go 1.21中的PGO功能已准备好用于广泛的生产环境!有关完整文档,请参阅<a href="https://go.dev/doc/pgo" target="_blank" rel="external">用户指南</a>。</p>
<p>下面我们将通过一个示例来演示如何使用PGO提高应用程序的性能。在深入示例之前,什么是“基于profile指导的优化”?</p>
<p>当你构建一个Go二进制文件时,Go编译器会执行优化,试图生成性能最佳的二进制文件。例如,常量传播(<code>constant propagation</code>)可以在编译时计算常量表达式的值,避免了运行时的计算开销。逃逸分析(<code>Escape analysis</code>)可以避免为局部作用域的对象分配堆内存,从而避免GC的开销。内联(<code>Inlining</code>)会将简单函数的函数体拷贝到调用者中,这通常可以在调用者中启用进一步的优化(例如额外的常量传播或更好的逃逸分析)。去虚拟化(<code>Devirtualization</code>)会将接口值上的间接调用(如果可以静态确定其类型)转换为对具体方法的直接调用(这通常可以内联该调用)。</p>
<p>Go在每个版本中都在提升优化,但这并非易事。一些优化是可调的,但是编译器不能对每项优化都“turn it up to 11” (英语典故，形容把某事物调到极限状态或者超出常规限度),因为过于激进的优化实际上可能会损害性能或者导致过长的构建时间。其他优化需要编译器对函数中的“常见路径”和“非常见路径”做出判断。编译器必须根据静态启发式方法进行最佳猜测,因为它无法知道运行时哪些分支更常见。</p>
<p>或者编译器可以做到吗?</p>
<p>没有关于代码在生产环境中的使用方式的确定信息,编译器只能对包的源代码进行操作。但是我们确实有一个工具来评估生产行为: profile (剖析，又叫性能分析,后面我们保持英文不翻译）。如果我们向编译器提供一个profile,它可以做出更明智的决定:更积极地优化使用最频繁的函数,或更准确地选择常见情况。</p>
<p>使用应用程序行为的profile进行编译器优化称为基于profile指导的优化 (PGO)(也称为性能分析引导优化、反馈导向优化(FDO))。</p>
<h2 id="示例">示例</h2>
<p>好的,让我们构建一个将Markdown转换为HTML的服务:用户将Markdown源上传到/render,它会返回HTML转换结果。我们可以使用<code>gitlab.com/golang-commonmark/markdown</code>来轻松实现这一功能。</p>
<h3 id="搭建">搭建</h3>
<p>创建一个文件夹并执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go mod init example.com/markdown</div><div class="line">$ go get gitlab.com/golang-commonmark/markdown@bf3e522c626a</div></pre></td></tr></table></figure>

<p>创建 main.go 文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"bytes"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    _ <span class="string">"net/http/pprof"</span></div><div class="line"></div><div class="line">    <span class="string">"gitlab.com/golang-commonmark/markdown"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> render(w http.ResponseWriter, r *http.Request) {</div><div class="line">    <span class="keyword">if</span> r.Method != <span class="string">"POST"</span> {</div><div class="line">        http.Error(w, <span class="string">"Only POST allowed"</span>, http.StatusMethodNotAllowed)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    src, err := io.ReadAll(r.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"error reading body: %v"</span>, err)</div><div class="line">        http.Error(w, <span class="string">"Internal Server Error"</span>, http.StatusInternalServerError)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    md := markdown.New(</div><div class="line">        markdown.XHTMLOutput(<span class="constant">true</span>),</div><div class="line">        markdown.Typographer(<span class="constant">true</span>),</div><div class="line">        markdown.Linkify(<span class="constant">true</span>),</div><div class="line">        markdown.Tables(<span class="constant">true</span>),</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="keyword">var</span> buf bytes.Buffer</div><div class="line">    <span class="keyword">if</span> err := md.Render(&buf, src); err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"error converting markdown: %v"</span>, err)</div><div class="line">        http.Error(w, <span class="string">"Malformed markdown"</span>, http.StatusBadRequest)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> _, err := io.Copy(w, &buf); err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"error writing response: %v"</span>, err)</div><div class="line">        http.Error(w, <span class="string">"Internal Server Error"</span>, http.StatusInternalServerError)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    http.HandleFunc(<span class="string">"/render"</span>, render)</div><div class="line">    log.Printf(<span class="string">"Serving on port 8080..."</span>)</div><div class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>构建并运行这个服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go build -o markdown.nopgo.exe</div><div class="line">$ ./markdown.nopgo.exe</div><div class="line"><span class="number">2023</span>/<span class="number">08</span>/<span class="number">23</span> <span class="number">03</span>:<span class="number">55</span>:<span class="number">51</span> Serving on port <span class="number">8080</span>...</div></pre></td></tr></table></figure>

<p>好的,我们可以从另一个终端发送一些Markdown过来试试。我们可以使用Go项目中的<code>README.md</code>作为示例文档:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl -o README.md -L <span class="string">"https://raw.githubusercontent.com/golang/go/c16c2c49e2fa98ae551fc6335215fadd62d33542/README.md"</span></div><div class="line">$ curl --data-binary @README.md http://localhost:<span class="number">8080</span>/render</div><div class="line">&lt;h1&gt;The Go Programming Language&lt;/h1&gt;</div><div class="line">&lt;p&gt;Go is an open <span class="built_in">source</span> programming language that makes it easy to build simple,</div><div class="line">reliable, and efficient software.&lt;/p&gt;</div><div class="line">...</div></pre></td></tr></table></figure>

<h3 id="获取profile">获取profile</h3>
<p>既然我们已经有了一个工作的服务,让我们收集一个profile并用PGO重新构建,看看是否可以获得更好的性能。</p>
<p>在main.go中,我们导入了<code>net/http/pprof</code>,它会自动在服务器上添加一个<code>/debug/pprof/profile</code>地址来获取CPU profile。</p>
<p>通常你想要从生产环境中收集profile,这样编译器可以获得生产环境中的代表性行为视图。由于这个示例没有“生产”环境,我创建了一个简单的程序来在收集profile时生成压测负载。获取并启动负载生成器(确保服务器仍在运行!):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go run github.com/prattmic/markdown-pgo/load@latest</div></pre></td></tr></table></figure>

<p>在负载生成器运行时,从服务器下载一个性能分析:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -o cpu.pprof <span class="string">"http://localhost:8080/debug/pprof/profile?seconds=30"</span></div></pre></td></tr></table></figure>

<p>一旦profile下载完成,终止负载生成器和服务器。</p>
<h3 id="使用profile">使用profile</h3>
<p>Go工具链如果在main包目录中找到名为default.pgo的概要文件，就会自动启用PGO。或者, 在go build中使用<code>-pgo</code>标志接受一个文件路径作为PGO要使用的profile路径。</p>
<p>我们建议将profile文件提交到你的仓库中。将profile文件与源代码一起存储可以确保用户只需获取仓库(通过版本控制系统或go get)就可以自动访问profile文件,并且可以保证构建是可重现的。</p>
<p>让我们构建它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mv cpu.pprof <span class="keyword">default</span>.pgo</div><div class="line">$ <span class="keyword">go</span> build -o markdown.withpgo.exe</div></pre></td></tr></table></figure>

<p>我们可以通过go version检查PGO是否在构建中被启用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go version -m markdown.withpgo.exe</div><div class="line">./markdown.withpgo.exe: go1.<span class="number">21.0</span></div><div class="line">...</div><div class="line">        build   -pgo=/tmp/pgo121/default.pgo</div></pre></td></tr></table></figure>

<h3 id="评估">评估</h3>
<p>我们将使用负载生成器的Go基准测试版本来评估PGO对性能的影响。</p>
<p>首先,我们为没有使用PGO优化的服务器进行基准测试。启动那个服务器:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./markdown.nopgo.exe</div></pre></td></tr></table></figure>

<p>在服务运行时，执行几次基准测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/prattmic/markdown-pgo@latest</div><div class="line">$ go test github.com/prattmic/markdown-pgo/load -bench=. -count=<span class="number">40</span> -source $(<span class="built_in">pwd</span>)/README.md &gt; nopgo.txt</div></pre></td></tr></table></figure>

<p>一旦完成,终止原始服务器并启动带PGO的版本:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./markdown.withpgo.exe</div></pre></td></tr></table></figure>

<p>在服务运行时，也执行同样次数的基准测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/prattmic/markdown-pgo/load -bench=. -count=<span class="number">40</span> -source $(<span class="built_in">pwd</span>)/README.md &gt; withpgo.txt</div></pre></td></tr></table></figure>

<p>一旦完成，比较两次的测试结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ go install golang.org/x/perf/cmd/benchstat@latest</div><div class="line">$ benchstat nopgo.txt withpgo.txt</div><div class="line">goos: linux</div><div class="line">goarch: amd64</div><div class="line">pkg: github.com/prattmic/markdown-pgo/load</div><div class="line">cpu: Intel(R) Xeon(R) W-<span class="number">2135</span> CPU @ <span class="number">3.70</span>GHz</div><div class="line">        │  nopgo.txt  │            withpgo.txt             │</div><div class="line">        │   sec/op    │   sec/op     vs base               │</div><div class="line">Load-<span class="number">12</span>   <span class="number">374.5</span>µ ± <span class="number">1</span>%   <span class="number">360.2</span>µ ± <span class="number">0</span>%  -<span class="number">3.83</span>% (p=<span class="number">0.000</span> n=<span class="number">40</span>)</div></pre></td></tr></table></figure>

<p>新的版本大约快了3.8%! 在Go 1.21中,启用PGO后,工作负载的CPU使用率通常可以提高2%到7%。profile文件其实包含了大量关于应用程序行为的信息,Go 1.21只是开始利用这些信息进行有限的几项优化。随着编译器的更多部分利用PGO,未来的版本将继续改进性能。</p>
<h2 id="后续步骤">后续步骤</h2>
<p>在这个示例中,收集profile文件后,我们使用与原始构建完全相同的源代码重新构建了服务器。在实际场景中,代码都在不断开发。所以我们可能会从运行上周代码的生产环境收集profile文件,并用它来构建今天的源代码。这完全没问题!Go中的PGO可以毫无问题地处理源代码的细微变更。当然,随着时间推移,源代码会越来越不相同,所以定期更新profile文件仍然很重要。</p>
<p>关于使用PGO的更多信息、最佳实践和需要注意的警告,请参阅<a href="https://go.dev/doc/pgo" target="_blank" rel="external">基于profile指导的优化用户指南</a>。如果您好奇咋优化的,请继续阅读!</p>
<h2 id="原理剖析">原理剖析</h2>
<p>为了更好地理解是什么让这个应用程序变得更快，让我们深入了解一下性能是如何改进的。我们将查看两种不同的PGO驱动的优化。</p>
<h3 id="内联">内联</h3>
<p>为了观察内联优化的改进，让我们分别分析这个Markdown应用程序在使用PGO和不使用PGO时的情况。</p>
<p>我将使用一种称为差异性分析的技术进行比较，其中我们收集两个不同的性能分析数据（一个使用PGO，一个不使用PGO），然后进行比较。对于差异性分析，重要的是两个profile数据代表了相同数量的工作量，而不是相同数量的时间。因此，我已经调整了服务器以自动收集性能分析数据，还调整了负载生成器以发送固定数量的请求，然后退出服务器。</p>
<p>我已经对服务器进行了更改，依然收集到的profile数据,代码可以在<a href="https://github.com/prattmic/markdown-pgo找到。负载生成器使用了参数`-count=300000" target="_blank" rel="external">https://github.com/prattmic/markdown-pgo找到。负载生成器使用了参数`-count=300000</a> -quit`来运行。</p>
<p>作为一个快速的一致性检查，让我们来看一下处理所有 300,000 个请求所需的总CPU时间：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -top cpu.nopgo.pprof | grep <span class="string">"Total samples"</span></div><div class="line">Duration: <span class="number">116.92</span>s, Total samples = <span class="number">118.73</span>s (<span class="number">101.55</span>%)</div><div class="line">$ go tool pprof -top cpu.withpgo.pprof | grep <span class="string">"Total samples"</span></div><div class="line">Duration: <span class="number">113.91</span>s, Total samples = <span class="number">115.03</span>s (<span class="number">100.99</span>%)</div></pre></td></tr></table></figure>

<p>CPU时间从约118秒下降到约115秒，下降了约3%。这与我们的基准测试结果一致，这是这些profile数据具有代表性的一个好现象。</p>
<p>现在我们可以打开一个差异性分析数据来寻找节省的部分：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -diff_base cpu.nopgo.pprof cpu.withpgo.pprof</div><div class="line">File: markdown.profile.withpgo.exe</div><div class="line">Type: cpu</div><div class="line">Time: Aug <span class="number">28</span>, <span class="number">2023</span> at <span class="number">10</span>:<span class="number">26</span>pm (EDT)</div><div class="line">Duration: <span class="number">230.82</span>s, Total samples = <span class="number">118.73</span>s (<span class="number">51.44</span>%)</div><div class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top -cum</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">0.10</span>s, <span class="number">0.084</span>% of <span class="number">118.73</span>s total</div><div class="line">Dropped <span class="number">268</span> nodes (cum &lt;= <span class="number">0.59</span>s)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">668</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">    -<span class="number">0.03</span>s <span class="number">0.025</span>% <span class="number">0.025</span>%     -<span class="number">2.56</span>s  <span class="number">2.16</span>%  gitlab.com/golang-commonmark/markdown.ruleLinkify</div><div class="line">     <span class="number">0.04</span>s <span class="number">0.034</span>% <span class="number">0.0084</span>%     -<span class="number">2.19</span>s  <span class="number">1.84</span>%  net/http.(*conn).serve</div><div class="line">     <span class="number">0.02</span>s <span class="number">0.017</span>% <span class="number">0.025</span>%     -<span class="number">1.82</span>s  <span class="number">1.53</span>%  gitlab.com/golang-commonmark/markdown.(*Markdown).Render</div><div class="line">     <span class="number">0.02</span>s <span class="number">0.017</span>% <span class="number">0.042</span>%     -<span class="number">1.80</span>s  <span class="number">1.52</span>%  gitlab.com/golang-commonmark/markdown.(*Markdown).Parse</div><div class="line">    -<span class="number">0.03</span>s <span class="number">0.025</span>% <span class="number">0.017</span>%     -<span class="number">1.71</span>s  <span class="number">1.44</span>%  runtime.mallocgc</div><div class="line">    -<span class="number">0.07</span>s <span class="number">0.059</span>% <span class="number">0.042</span>%     -<span class="number">1.62</span>s  <span class="number">1.36</span>%  net/http.(*ServeMux).ServeHTTP</div><div class="line">     <span class="number">0.04</span>s <span class="number">0.034</span>% <span class="number">0.0084</span>%     -<span class="number">1.58</span>s  <span class="number">1.33</span>%  net/http.serverHandler.ServeHTTP</div><div class="line">    -<span class="number">0.01</span>s <span class="number">0.0084</span>% <span class="number">0.017</span>%     -<span class="number">1.57</span>s  <span class="number">1.32</span>%  main.render</div><div class="line">     <span class="number">0.01</span>s <span class="number">0.0084</span>% <span class="number">0.0084</span>%     -<span class="number">1.56</span>s  <span class="number">1.31</span>%  net/http.HandlerFunc.ServeHTTP</div><div class="line">    -<span class="number">0.09</span>s <span class="number">0.076</span>% <span class="number">0.084</span>%     -<span class="number">1.25</span>s  <span class="number">1.05</span>%  runtime.newobject</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">1.41</span>s, <span class="number">1.19</span>% of <span class="number">118.73</span>s total</div><div class="line">Dropped <span class="number">268</span> nodes (cum &lt;= <span class="number">0.59</span>s)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">668</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">    -<span class="number">0.46</span>s  <span class="number">0.39</span>%  <span class="number">0.39</span>%     -<span class="number">0.91</span>s  <span class="number">0.77</span>%  runtime.scanobject</div><div class="line">    -<span class="number">0.40</span>s  <span class="number">0.34</span>%  <span class="number">0.72</span>%     -<span class="number">0.40</span>s  <span class="number">0.34</span>%  runtime.nextFreeFast (inline)</div><div class="line">     <span class="number">0.36</span>s   <span class="number">0.3</span>%  <span class="number">0.42</span>%      <span class="number">0.36</span>s   <span class="number">0.3</span>%  gitlab.com/golang-commonmark/markdown.performReplacements</div><div class="line">    -<span class="number">0.35</span>s  <span class="number">0.29</span>%  <span class="number">0.72</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%  runtime.writeHeapBits.flush</div><div class="line">     <span class="number">0.32</span>s  <span class="number">0.27</span>%  <span class="number">0.45</span>%      <span class="number">0.67</span>s  <span class="number">0.56</span>%  gitlab.com/golang-commonmark/markdown.ruleReplacements</div><div class="line">    -<span class="number">0.31</span>s  <span class="number">0.26</span>%  <span class="number">0.71</span>%     -<span class="number">0.29</span>s  <span class="number">0.24</span>%  runtime.writeHeapBits.write</div><div class="line">    -<span class="number">0.30</span>s  <span class="number">0.25</span>%  <span class="number">0.96</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%  runtime.deductAssistCredit</div><div class="line">     <span class="number">0.29</span>s  <span class="number">0.24</span>%  <span class="number">0.72</span>%      <span class="number">0.10</span>s <span class="number">0.084</span>%  gitlab.com/golang-commonmark/markdown.ruleText</div><div class="line">    -<span class="number">0.29</span>s  <span class="number">0.24</span>%  <span class="number">0.96</span>%     -<span class="number">0.29</span>s  <span class="number">0.24</span>%  runtime.(*mspan).base (inline)</div><div class="line">    -<span class="number">0.27</span>s  <span class="number">0.23</span>%  <span class="number">1.19</span>%     -<span class="number">0.42</span>s  <span class="number">0.35</span>%  bytes.(*Buffer).WriteRune</div></pre></td></tr></table></figure>

<p>当指定 pprof -diff_base 时，pprof 中显示的值是两个配置文件之间的差异。因此，例如，使用 PGO 的 runtime.scanobject 的 CPU 使用时间比没有使用的少 0.46 秒。另一方面，gitlab.com/golang-commonmark/markdown.performReplacements 的 CPU 使用时间多了 0.36 秒。在差异性配置文件中，我们通常想要看绝对值（flat 和 cum 列），因为百分比没有意义。</p>
<p>top -cum 显示了累积变化最大的顶级差异。也就是说，一个函数及其所有传递调用者的 CPU 差异。这通常会显示我们程序调用图中最外层的帧，例如 main 或另一个 goroutine 入口点。在这里，我们可以看到大部分节省来自处理 HTTP 请求的 ruleLinkify 部分。</p>
<p>top 显示仅限于函数本身变化的顶级差异。这通常会显示我们程序调用图中的内部帧，这里正在进行大部分实际的工作。在这里我们可以看到，个别节省主要来自 runtime 函数。</p>
<p>都是些啥，让我们挑几个看看它们的调用栈:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">pprof) peek scanobject$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.86</span>s <span class="number">94.51</span>% |   runtime.gcDrain</div><div class="line">                                            -<span class="number">0.09</span>s  <span class="number">9.89</span>% |   runtime.gcDrainN</div><div class="line">                                             <span class="number">0.04</span>s  <span class="number">4.40</span>% |   runtime.markrootSpans</div><div class="line">    -<span class="number">0.46</span>s  <span class="number">0.39</span>%  <span class="number">0.39</span>%     -<span class="number">0.91</span>s  <span class="number">0.77</span>%                | runtime.scanobject</div><div class="line">                                            -<span class="number">0.19</span>s <span class="number">20.88</span>% |   runtime.greyobject</div><div class="line">                                            -<span class="number">0.13</span>s <span class="number">14.29</span>% |   runtime.heapBits.nextFast (inline)</div><div class="line">                                            -<span class="number">0.08</span>s  <span class="number">8.79</span>% |   runtime.heapBits.next</div><div class="line">                                            -<span class="number">0.08</span>s  <span class="number">8.79</span>% |   runtime.spanOfUnchecked (inline)</div><div class="line">                                             <span class="number">0.04</span>s  <span class="number">4.40</span>% |   runtime.heapBitsForAddr</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.10</span>% |   runtime.findObject</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek gcDrain$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                               -<span class="number">1</span>s   <span class="number">100</span>% |   runtime.gcBgMarkWorker.func2</div><div class="line">     <span class="number">0.15</span>s  <span class="number">0.13</span>%  <span class="number">0.13</span>%        -<span class="number">1</span>s  <span class="number">0.84</span>%                | runtime.gcDrain</div><div class="line">                                            -<span class="number">0.86</span>s <span class="number">86.00</span>% |   runtime.scanobject</div><div class="line">                                            -<span class="number">0.18</span>s <span class="number">18.00</span>% |   runtime.(*gcWork).balance</div><div class="line">                                            -<span class="number">0.11</span>s <span class="number">11.00</span>% |   runtime.(*gcWork).tryGet</div><div class="line">                                             <span class="number">0.09</span>s  <span class="number">9.00</span>% |   runtime.pollWork</div><div class="line">                                            -<span class="number">0.03</span>s  <span class="number">3.00</span>% |   runtime.(*gcWork).tryGetFast (inline)</div><div class="line">                                            -<span class="number">0.03</span>s  <span class="number">3.00</span>% |   runtime.markroot</div><div class="line">                                            -<span class="number">0.02</span>s  <span class="number">2.00</span>% |   runtime.wbBufFlush</div><div class="line">                                             <span class="number">0.01</span>s  <span class="number">1.00</span>% |   runtime/internal/atomic.(*Bool).Load (inline)</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.00</span>% |   runtime.gcFlushBgCredit</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.00</span>% |   runtime/internal/atomic.(*Int64).Add (inline)</div><div class="line">----------------------------------------------------------+-------------</div></pre></td></tr></table></figure>

<p>所以 runtime.scanobject 最终来自 runtime.gcBgMarkWorker。Go GC 指南告诉我们，runtime.gcBgMarkWorker 是垃圾收集器的一部分，所以 runtime.scanobject 的节省必定是 GC 的节省。那么 nextFreeFast 和其他的运行时函数呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">(pprof) peek nextFreeFast$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.40</span>s   <span class="number">100</span>% |   runtime.mallocgc (inline)</div><div class="line">    -<span class="number">0.40</span>s  <span class="number">0.34</span>%  <span class="number">0.34</span>%     -<span class="number">0.40</span>s  <span class="number">0.34</span>%                | runtime.nextFreeFast</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek writeHeapBits</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.37</span>s   <span class="number">100</span>% |   runtime.heapBitsSetType</div><div class="line">                                                 <span class="number">0</span>     <span class="number">0</span>% |   runtime.(*mspan).initHeapBits</div><div class="line">    -<span class="number">0.35</span>s  <span class="number">0.29</span>%  <span class="number">0.29</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%                | runtime.writeHeapBits.flush</div><div class="line">                                            -<span class="number">0.02</span>s  <span class="number">5.41</span>% |   runtime.arenaIndex (inline)</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.29</span>s   <span class="number">100</span>% |   runtime.heapBitsSetType</div><div class="line">    -<span class="number">0.31</span>s  <span class="number">0.26</span>%  <span class="number">0.56</span>%     -<span class="number">0.29</span>s  <span class="number">0.24</span>%                | runtime.writeHeapBits.write</div><div class="line">                                             <span class="number">0.02</span>s  <span class="number">6.90</span>% |   runtime.arenaIndex (inline)</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek heapBitsSetType$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.82</span>s   <span class="number">100</span>% |   runtime.mallocgc</div><div class="line">    -<span class="number">0.12</span>s   <span class="number">0.1</span>%   <span class="number">0.1</span>%     -<span class="number">0.82</span>s  <span class="number">0.69</span>%                | runtime.heapBitsSetType</div><div class="line">                                            -<span class="number">0.37</span>s <span class="number">45.12</span>% |   runtime.writeHeapBits.flush</div><div class="line">                                            -<span class="number">0.29</span>s <span class="number">35.37</span>% |   runtime.writeHeapBits.write</div><div class="line">                                            -<span class="number">0.03</span>s  <span class="number">3.66</span>% |   runtime.readUintptr (inline)</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.22</span>% |   runtime.writeHeapBitsForAddr (inline)</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek deductAssistCredit$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.37</span>s   <span class="number">100</span>% |   runtime.mallocgc</div><div class="line">    -<span class="number">0.30</span>s  <span class="number">0.25</span>%  <span class="number">0.25</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%                | runtime.deductAssistCredit</div><div class="line">                                            -<span class="number">0.07</span>s <span class="number">18.92</span>% |   runtime.gcAssistAlloc</div><div class="line">----------------------------------------------------------+-------------</div></pre></td></tr></table></figure>

<p>看起来 nextFreeFast 和前10名中的其他一些最终来自 runtime.mallocgc，GC指南告诉我们这是内存分配器。</p>
<p>GC和分配器的成本降低表明我们总体上分配的较少。让我们看看heap profile文件以获取更深入的了解：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -sample_index=alloc_objects -diff_base heap.nopgo.pprof heap.withpgo.pprof</div><div class="line">File: markdown.profile.withpgo.exe</div><div class="line">Type: alloc_objects</div><div class="line">Time: Aug <span class="number">28</span>, <span class="number">2023</span> at <span class="number">10</span>:<span class="number">28</span>pm (EDT)</div><div class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">12044903</span>, <span class="number">8.29</span>% of <span class="number">145309950</span> total</div><div class="line">Dropped <span class="number">60</span> nodes (cum &lt;= <span class="number">726549</span>)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">58</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">  -<span class="number">4974135</span>  <span class="number">3.42</span>%  <span class="number">3.42</span>%   -<span class="number">4974135</span>  <span class="number">3.42</span>%  gitlab.com/golang-commonmark/mdurl.Parse</div><div class="line">  -<span class="number">4249044</span>  <span class="number">2.92</span>%  <span class="number">6.35</span>%   -<span class="number">4249044</span>  <span class="number">2.92</span>%  gitlab.com/golang-commonmark/mdurl.(*URL).String</div><div class="line">   -<span class="number">901135</span>  <span class="number">0.62</span>%  <span class="number">6.97</span>%    -<span class="number">977596</span>  <span class="number">0.67</span>%  gitlab.com/golang-commonmark/puny.mapLabels</div><div class="line">   -<span class="number">653998</span>  <span class="number">0.45</span>%  <span class="number">7.42</span>%    -<span class="number">482491</span>  <span class="number">0.33</span>%  gitlab.com/golang-commonmark/markdown.(*StateInline).PushPending</div><div class="line">   -<span class="number">557073</span>  <span class="number">0.38</span>%  <span class="number">7.80</span>%    -<span class="number">557073</span>  <span class="number">0.38</span>%  gitlab.com/golang-commonmark/linkify.Links</div><div class="line">   -<span class="number">557073</span>  <span class="number">0.38</span>%  <span class="number">8.18</span>%    -<span class="number">557073</span>  <span class="number">0.38</span>%  strings.genSplit</div><div class="line">   -<span class="number">436919</span>   <span class="number">0.3</span>%  <span class="number">8.48</span>%    -<span class="number">232152</span>  <span class="number">0.16</span>%  gitlab.com/golang-commonmark/markdown.(*StateBlock).Lines</div><div class="line">   -<span class="number">408617</span>  <span class="number">0.28</span>%  <span class="number">8.77</span>%    -<span class="number">408617</span>  <span class="number">0.28</span>%  net/textproto.readMIMEHeader</div><div class="line">    <span class="number">401432</span>  <span class="number">0.28</span>%  <span class="number">8.49</span>%     <span class="number">499610</span>  <span class="number">0.34</span>%  bytes.(*Buffer).grow</div><div class="line">    <span class="number">291659</span>   <span class="number">0.2</span>%  <span class="number">8.29</span>%     <span class="number">291659</span>   <span class="number">0.2</span>%  bytes.(*Buffer).String (inline)</div></pre></td></tr></table></figure>

<p><code>-sample_index=alloc_objects</code> 选项为我们显示了分配的数量，而不考虑大小。这很有用，因为我们正在调查 CPU 使用率的降低，这往往更与分配的数量而不是大小相关。这里有相当多的减少，但让我们关注最大的减少，也就是 <code>mdurl.Parse</code>。</p>
<p>作为参考，让我们看一下这个函数在没有 PGO 的情况下的总分配数量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -sample_index=alloc_objects -top heap.nopgo.pprof | grep mdurl.Parse</div><div class="line">   <span class="number">4974135</span>  <span class="number">3.42</span>% <span class="number">68.60</span>%    <span class="number">4974135</span>  <span class="number">3.42</span>%  gitlab.com/golang-commonmark/mdurl.Parse</div></pre></td></tr></table></figure>

<p>在此之前的总数是<strong>4974135</strong>，这意味着 <code>mdurl.Parse</code> 已经消除了100%的分配！</p>
<p>回到另一个profile文件中(带pgo优化的)，让我们收集更多的上下文信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(pprof) peek mdurl.Parse</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">12257184</span>, <span class="number">8.44</span>% of <span class="number">145309950</span> total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                          -<span class="number">2956806</span> <span class="number">59.44</span>% |   gitlab.com/golang-commonmark/markdown.normalizeLink</div><div class="line">                                          -<span class="number">2017329</span> <span class="number">40.56</span>% |   gitlab.com/golang-commonmark/markdown.normalizeLinkText</div><div class="line">  -<span class="number">4974135</span>  <span class="number">3.42</span>%  <span class="number">3.42</span>%   -<span class="number">4974135</span>  <span class="number">3.42</span>%                | gitlab.com/golang-commonmark/mdurl.Parse</div><div class="line">----------------------------------------------------------+-------------</div></pre></td></tr></table></figure>

<p>调用 mdurl.Parse 的是来自 markdown.normalizeLink 和 markdown.normalizeLinkText。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(pprof) list mdurl.Parse</div><div class="line">Total:<span class="number"> 145309950</span></div><div class="line">ROUTINE ======================== gitlab.com/golang-commonmark/mdurl.Parse in /usr/local/google/home/mpratt/<span class="keyword">go</span>/pkg/mod/gitlab.com/golang-commonmark/mdurl@v0<span class="number">.0.0</span><span class="number">-20191124015652</span><span class="number">-932350d1</span>cb84/parse</div><div class="line">.<span class="keyword">go</span></div><div class="line"> <span class="number"> -4974135</span>  <span class="number"> -4974135</span> (flat, cum) <span class="number"> 3.42</span>% of Total</div><div class="line">         .          .    <span class="number"> 60</span>:<span class="keyword">func</span> Parse(rawurl <span class="typename">string</span>) (*URL, error) {</div><div class="line">         .          .    <span class="number"> 61</span>:   n, err := findScheme(rawurl)</div><div class="line">         .          .    <span class="number"> 62</span>:   <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">         .          .    <span class="number"> 63</span>:           <span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">         .          .    <span class="number"> 64</span>:   }</div><div class="line">         .          .    <span class="number"> 65</span>:</div><div class="line"> <span class="number"> -4974135</span>  <span class="number"> -4974135</span>    <span class="number"> 66</span>:   <span class="keyword">var</span> url URL</div><div class="line">         .          .    <span class="number"> 67</span>:   rest := rawurl</div><div class="line">         .          .    <span class="number"> 68</span>:   hostless := <span class="constant">false</span></div><div class="line">         .          .    <span class="number"> 69</span>:   <span class="keyword">if</span> n &gt;<span class="number"> 0</span> {</div><div class="line">         .          .    <span class="number"> 70</span>:           url.RawScheme = rest[:n]</div><div class="line">         .          .    <span class="number"> 71</span>:           url.Scheme, rest = strings.ToLower(rest[:n]), rest[n<span class="number">+1</span>:]</div></pre></td></tr></table></figure>

<p>这些函数和调用者的完整源代码可以在以下位置找到：</p>
<ul>
<li><a href="https://gitlab.com/golang-commonmark/mdurl/-/blob/bd573caec3d827ead19e40b1f141a3802d956710/parse.go#L60" target="_blank" rel="external">mdurl.Parse</a></li>
<li><a href="https://gitlab.com/golang-commonmark/markdown/-/blob/fd7971701a0cab12e9347109a4c889f5c0a1a479/util.go#L53" target="_blank" rel="external">markdown.normalizeLink</a></li>
<li><a href="https://gitlab.com/golang-commonmark/markdown/-/blob/fd7971701a0cab12e9347109a4c889f5c0a1a479/util.go#L68" target="_blank" rel="external">markdown.normalizeLinkText</a></li>
</ul>
<p>所以这里发生了什么优化？在非 PGO 构建中，<code>mdurl.Parse</code> 被认为太大，不符合内联的条件。然而，因为我们的 PGO profile文件表明调用这个函数的操作是热点，所以编译器确实将它们内联了。我们可以从profile文件中的“(inline)”注解看到这一点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -top cpu.nopgo.pprof | grep mdurl.Parse</div><div class="line">     <span class="number">0.36</span>s   <span class="number">0.3</span>% <span class="number">63.76</span>%      <span class="number">2.75</span>s  <span class="number">2.32</span>%  gitlab.com/golang-commonmark/mdurl.Parse</div><div class="line">$ go tool pprof -top cpu.withpgo.pprof | grep mdurl.Parse</div><div class="line">     <span class="number">0.55</span>s  <span class="number">0.48</span>% <span class="number">58.12</span>%      <span class="number">2.03</span>s  <span class="number">1.76</span>%  gitlab.com/golang-commonmark/mdurl.Parse (inline)</div></pre></td></tr></table></figure>

<p><code>mdurl.Parse</code> 在第 66 行创建了一个 URL 作为本地变量（<code>var url URL</code>），然后在第 145 行返回该变量的指针（<code>return &amp;url, nil</code>）。通常这需要将变量分配在堆上，因为对它的引用在函数返回之后仍然存在。然而，一旦 <code>mdurl.Parse</code> 被内联到 <code>markdown.normalizeLink</code> 中，编译器就可以观察到该变量并没有逃逸到 <code>normalizeLink</code> 之外，这允许编译器将其分配在栈上。<code>markdown.normalizeLinkText</code> 与 <code>markdown.normalizeLink</code> 类似。</p>
<p>配置文件中显示的第二大减小，来自 <code>mdurl.(*URL).String</code>，这是一个在内联之后消除了逃逸的类似案例。</p>
<p>在这些情况下，我们通过减少堆分配来提高性能。PGO 和编译器优化的部分威力在于，对分配的影响并不直接是由编译器的 PGO 实现。PGO 做的唯一改变就是允许将这些<strong>热点函数</strong>调用内联。所有对逃逸分析和堆分配的影响都是在构建时的标准优化。优化的逃逸行为是内联的引起的延伸效应，但这并非是唯一的效应。许多优化也可以利用内联。例如，当一些输入是常量时，常量传播可能能够在内联之后简化函数中的代码。</p>
<h3 id="去虚拟化">去虚拟化</h3>
<p>除了我们在上面的示例中看到的内联，PGO还可以驱动接口调用的有条件的去虚拟化。</p>
<p>在进行PGO驱动去虚拟化之前，让我们先步后并定义一下一般的“去虚拟化”。假设你的代码大概长这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f, _ := os.Open(<span class="string">"foo.txt"</span>)</div><div class="line"><span class="keyword">var</span> r io.Reader = f</div><div class="line">r.Read(b)</div></pre></td></tr></table></figure>

<p>这里我们对 <code>io.Reader</code> 接口方法 <code>Read</code> 进行了调用。由于接口可以有多个实现，因此编译器会生成一个间接函数调用，也就是说，它会在运行时从接口值中的类型查找正确的方法来调用。间接调用与直接调用相比有一点额外的运行时开销，但更重要的是，它们排除了一些编译器优化。例如，编译器无法对间接调用进行逃逸分析，因为它不知道具体的方法实现。</p>
<p>但是在上面的示例中，我们确实知道具体的方法实现。它一定是 <code>os.(*File).Read</code>，因为 <code>*os.File</code> 是唯一可能被赋值给 <code>r</code> 的类型。在这种情况下，编译器会进行去虚拟化，将间接调用 <code>io.Reader.Read</code> 替换为直接调用 <code>os.(*File).Read</code>，从而允许其他优化。</p>
<p>（你可能在想，“那段代码没用，为什么会有人这么写？”这是个好问题，但请注意，上面的代码可能是内联的结果。假设 f 被传入一个接受 <code>io.Reader</code> 参数的函数。一旦函数被内联，现在 io.Reader 就变成了具体的。）</p>
<p>PGO 驱动的去虚拟化将这个概念扩展到了具体类型在静态上未知，但分析可以显示，例如，<code>io.Reader.Read</code> 调用大多数时候是针对 <code>os.(*File).Read</code> 的情况。在这种情况下，PGO 可以将 <code>r.Read(b)</code> 替换为类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> f, ok := r.(*os.File); ok {</div><div class="line">    f.Read(b)</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    r.Read(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是说，我们添加了一个针对最可能出现的实体类型的运行时检查，如果是的话，我们使用具体的调用，否则就回退到标准的间接调用。这里的优点是，常见的路径（使用 *os.File）可以被内联并应用额外的优化，但我们仍然保留了一个回退路径，因为配置文件并不能保证这种情况总是出现。</p>
<p>在我们对 markdown 服务器的分析中，我们没有看到 PGO 驱动的去虚拟化的优化，但我们也看到了优化最大的地方。PGO（以及大多数编译器优化）通常从许多不同地方的非常小的改进中获得其利益的累计，所以可能发生的事情比我们看到的还要多。</p>
<p>内联和去虚拟化是 Go 1.21 中可用的两种 PGO 驱动优化，但正如我们已经看到的，它们常常触发额外的优化。此外，Go 的未来版本将继续通过附加优化来改善 PGO。</p>
<p>未来可期。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>PGO （基于profile指导的优化） 在Go 1.20 中还属于预览状态， 在Go 1.21中已经生产可用了， 未来 PGO 还有很宏伟的<a href="https://github.com/golang/go/issues/62463#issuecomment-1709485195" target="_blank" rel="external">目标</a>，但是现在已经可以很好的帮助我们提高程序的性能呢，根据程序的不同，可能会带来2% ~ 7%的提升，不要小看这个提升，如果你是在大厂做优化的专家，可以这样计算: “我厂大概有 10万Go实例，每个实例平均占用16个核，通过我们的优化，程序性能平均提升5%, 大约节省9万个核，每年为公司节省数亿元的成本”。</p>
<p>最近看到两篇关于PGO的文章：<a href="https://landontclipp.github.io/blog/2023/08/25/profile-guided-optimizations-in-go/#viewing-the-assembly" target="_blank" rel="external">Profile Guided Optimizations in Go</a> 和 Go官方的博客 <a href="https://go.dev/blog/pgo" target="_blank" rel="external">Profile-guided optimization in Go 1.21</a>。相比较而言， Go官方这篇文章简单明了，而且把·细节也交代的明明白白，所以我就把这篇文章翻译过来，我感觉我自己写也没有官方这篇写的明白，翻译过来就好了。</p>
<p>以下是译文：<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Linux tracepoints、perf 和 eBPF 跟踪包的旅程]]></title>
    <link href="https://colobu.com/2023/09/11/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/"/>
    <id>https://colobu.com/2023/09/11/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/</id>
    <published>2023-09-11T14:09:17.000Z</published>
    <updated>2023-09-24T07:01:49.818Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.yadutaf.fr/2017/07/28/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/" target="_blank" rel="external">Tracing a packet journey using Linux tracepoints, perf and eBPF</a></p>
<p>很久以来我一直在寻找一个底层的Linux网络调试工具。<br>我一直在寻找一个低级的Linux网络调试工具已经有一段时间了。Linux 允许使用虚拟接口(virtual interface)和网络命名空间(network namespace)的组合来构建直接在主机上运行的复杂网络。当出现问题时，故障排除相当乏味。如果这是 L3 路由问题，mtr则很有可能会有所帮助。但是，如果这是一个较低层的问题，我通常会手动检查每个接口/网桥/网络命名空间/iptables并启动几个tcpdump，以尝试了解正在发生的事情。如果您事先不了解网络设置，这可能感觉像走迷宫。</p>
<a id="more"></a>
<p>我需要的是一个工具，可以告诉我 “嘿，哥们，我已经看到了你的数据包：它已经这样消失了，在这个接口上，在这个网络命名空间中”。</p>
<p>基本上，我需要的是在L2上的mtr。</p>
<p>没有这样的工具？让我们白手起家建一个！</p>
<p>在这篇文章的最后，我们将有一个简单易用的底层数据包跟踪器。如果您 ping 本地 Docker 容器，它将显示如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div></pre></td></tr></table></figure>

<h2 id="追踪救援_(Tracing_to_the_rescue)">追踪救援 (Tracing to the rescue)</h2>
<p>走出迷宫的一种方法是探索。这就是你走出迷宫时所做的。另一种走出迷宫的方法是改变你的观点，从上帝的视角，观察那些知道这条路的人所走的路。</p>
<p>在 Linux 术语中，这意味着转向内核视角，其中网络命名空间只是标签，而不是“容器”1。在内核中，数据包、接口等是普通的可观察对象。</p>
<p>在这篇文章中，我将重点介绍 2 个跟踪工具： perf 和 eBPF。</p>
<h2 id="介绍_perf_和_eBPF">介绍 perf 和 eBPF</h2>
<p>perf是 Linux 上每个性能相关分析的基准工具。它是在与 Linux 内核相同的源代码树中开发的，必须针对您将用于跟踪的内核进行专门编译。它可以跟踪内核以及用户程序。它还可以通过采样或使用跟踪点来工作。可以将其视为比strace的巨大超集，且开销要低得多的。本文我们只以非常简单的方式使用它。如果您想了解更多有关 perf 的知识 ，我强烈建议您访问 Brendan Gregg 的<a href="http://www.brendangregg.com/perf.html" target="_blank" rel="external">博客</a>。</p>
<p>eBPF 是 Linux 内核相对最近才添加的功能。顾名思义,这是BPF字节码(即“伯克利数据包过滤器”,用于在BSD家族系统上过滤数据包)的扩展版本。在 Linux上,如果满足一些安全标准,它也可以用来在运行时内核中安全地运行与平台无关的代码。例如,在程序运行之前会验证内存访问,并且必须能证明该程序会在受限的时间内结束。即使程序本身是安全的并且总是会终止,如果内核无法证明这一点,该程序也会被拒绝。</p>
<p>这样的程序可以用作QOS的网络分类器,非常底层的网络和过滤可以使用eXpress数据平面(XDP),这些程序作为跟踪代理以及许多其他场景。跟踪探针可以附加到<code>/proc/kallsyms</code>中的任意函数或任何跟踪点。在这篇文章中,我将重点介绍附加到跟踪点(tracepoint)的跟踪代理。</p>
<p>有关附加到内核函数的跟踪探针的示例或作为更详细的介绍,请阅读我之前关于eBPF的<a href="https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/" target="_blank" rel="external">文章</a>。</p>
<h2 id="实验室设置">实验室设置</h2>
<p>对于这篇文章,我们需要perf和一些用于eBPF的工具。由于我不是手写汇编代码的忠实拥趸,所以这里我将使用<a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc</a>。这是一个强大且灵活的工具,允许你用受限的C语言编写内核探针,并在用户空间用Python进行检测。对于生产环境来说可能过重,但对于开发非常完美!</p>
<p>在这里我重述在Ubuntu 17.04(Zesty)上的安装说明,这是我笔记本电脑所使用的操作系统。从其他发行版到“perf”的说明不应该有太大的差异,而特定的bcc安装说明可以在<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md" target="_blank" rel="external">github</a>上找到。</p>
<blockquote>
<p>注意:将eBPF附加到跟踪点至少需要Linux内核版本高于4.7。</p>
</blockquote>
<p>安装 perf:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 安装</div><div class="line"><span class="built_in">sudo</span> apt install linux-tools-generic</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line">perf</div></pre></td></tr></table></figure>

<p>如果看到错误信息,很可能是你的内核最近更新了但是操作系统还没有重启。</p>
<p>安装 bcc:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装原来</span></div><div class="line"><span class="built_in">sudo</span> apt install bison build-essential cmake flex git libedit-dev python zlib1g-dev libelf-dev libllvm4.<span class="number">0</span> llvm-dev libclang-dev luajit luajit-<span class="number">5.1</span>-dev</div><div class="line"></div><div class="line"><span class="comment"># 获取bcc源代码</span></div><div class="line">git clone https://github.com/iovisor/bcc.git</div><div class="line"></div><div class="line"><span class="comment"># 编译并安装</span></div><div class="line">mkdir bcc/build</div><div class="line"><span class="built_in">cd</span> bcc/build</div><div class="line">cmake .. -DCMAKE_INSTALL_PREFIX=/usr</div><div class="line">make</div><div class="line"><span class="built_in">sudo</span> make install</div></pre></td></tr></table></figure>

<h2 id="寻找好的跟踪点,也就是“用_perf_手动跟踪数据包的旅程”">寻找好的跟踪点,也就是“用 perf 手动跟踪数据包的旅程”</h2>
<p>有多种方法可以找到好的跟踪点。在这篇文章的早期版本中,我从 veth 驱动的代码开始,并从那里追踪函数调用来找到要跟踪的函数。虽然它确实导致了可以接受的结果,但我无法捕获所有的包。的确,所有数据包共同经过的路径都在未导出的(内联或静态)方法中。这就是我意识到 Linux 有跟踪点并决定重写这篇文章及相关代码使用跟踪点而不是函数。这很令人沮丧,但对我来说也更有趣。</p>
<p>我废话太多了，言归正传。</p>
<p>我们的目标是跟踪数据包所经历的路径。根据它们所经过的接口, 它们经过的跟踪点可能会有所不同(剧透:它们确实不同)。</p>
<p>为了找到合适的跟踪点,我在使用 perf trace时 ping了2个内部目的IP和2个外部的目的IP：</p>
<ul>
<li>localhost,IP 为 127.0.0.1</li>
<li>一个“无辜的” Docker 容器,IP 为 172.17.0.2</li>
<li>通过 USB 共享网络的我的手机,IP 为 192.168.42.129</li>
<li>通过 WiFi 的我的手机,IP 为 192.168.43.1</li>
</ul>
<p><code>perf trace</code> 是 perf 命令的一个子命令,默认情况下会产生类似于strace的输出(开销更小)。我们可以轻松地调整它,隐藏系统调用本身,只打印“net”类别的事件。例如,跟踪ping一个IP为172.17.0.2的Docker容器看起来像这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> perf trace --no-syscalls --event <span class="string">'net:*'</span> ping <span class="number">172.17</span>.<span class="number">0.2</span> -c1 &gt; /dev/null</div><div class="line">     <span class="number">0.000</span> net:net_dev_queue:dev=docker0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.008</span> net:net_dev_start_xmit:dev=docker0 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988700 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">0</span> len=<span class="number">98</span> data_len=<span class="number">0</span> network_offset=<span class="number">14</span> transport_offset_valid=<span class="number">1</span> transport_offset=<span class="number">34</span> tx_flags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_segs=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.014</span> net:net_dev_queue:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.016</span> net:net_dev_start_xmit:dev=veth79215ff queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988700 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">0</span> len=<span class="number">98</span> data_len=<span class="number">0</span> network_offset=<span class="number">14</span> transport_offset_valid=<span class="number">1</span> transport_offset=<span class="number">34</span> tx_flags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_segs=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.020</span> net:netif_rx:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.022</span> net:net_dev_xmit:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span> rc=<span class="number">0</span>)</div><div class="line">     <span class="number">0.024</span> net:net_dev_xmit:dev=docker0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span> rc=<span class="number">0</span>)</div><div class="line">     <span class="number">0.027</span> net:netif_receive_skb:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.044</span> net:net_dev_queue:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.046</span> net:net_dev_start_xmit:dev=eth0 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988b00 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">0</span> len=<span class="number">98</span> data_len=<span class="number">0</span> network_offset=<span class="number">14</span> transport_offset_valid=<span class="number">1</span> transport_offset=<span class="number">34</span> tx_flags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_segs=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.048</span> net:netif_rx:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.050</span> net:net_dev_xmit:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">98</span> rc=<span class="number">0</span>)</div><div class="line">     <span class="number">0.053</span> net:netif_receive_skb:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.060</span> net:netif_receive_skb_entry:dev=docker0 napi_id=<span class="number">0</span>x3 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988b00 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">2</span> <span class="built_in">hash</span>=<span class="number">0</span>x00000000 l4_<span class="built_in">hash</span>=<span class="number">0</span> len=<span class="number">84</span> data_len=<span class="number">0</span> truesize=<span class="number">768</span> mac_header_valid=<span class="number">1</span> mac_header=-<span class="number">14</span> nr_frags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.061</span> net:netif_receive_skb:dev=docker0 skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">84</span>)</div></pre></td></tr></table></figure>

<p>仅保留事件名称和 skbaddr，这看起来更具可读性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">net_dev_queue           dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_start_xmit      dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_queue           dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_start_xmit      dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">netif_rx                dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_xmit            dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_xmit            dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">netif_receive_skb       dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line"></div><div class="line">net_dev_queue           dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">net_dev_start_xmit      dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_rx                dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">net_dev_xmit            dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_receive_skb       dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_receive_skb_entry dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_receive_skb       dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988b00</div></pre></td></tr></table></figure>

<p>这里有几点需要说明。最明显的是<code>skbaddr</code>在中间发生了变化,但其他时候保持不变, 这是发生中echo reply数据包作为对该echo request(ping)的回复生成时。在其他时间,同一网络数据包在接口之间移动,希望没有复制。复制是昂贵的...</p>
<p>另一个有趣的点是,我们明确看到数据包经过docker0网桥,然后是veth的主机端,在我的例子中是veth79215ff,最后是veth的容器端,假装是eth0。我们还没有看到网络命名空间,但它已经给出了很好的概览。</p>
<p>最后,在看到eth0上的数据包之后,我们按相反顺序看到了跟踪点。这不是响应,而是传输的最终目的路径。</p>
<p>通过在4种目标场景中重复类似的过程,我们可以选择最合适的跟踪点来跟踪数据包的旅程。我选择了其中的4个:</p>
<ul>
<li><code>net_dev_queue</code></li>
<li><code>netif_receive_skb_entry</code></li>
<li><code>netif_rx</code></li>
<li><code>napi_gro_receive_entry</code></li>
</ul>
<p>采用这4个跟踪点将按顺序为我提供跟踪事件,没有重复,节省了一些去重工作。仍然是一个非常好的选择。</p>
<p>我们可以轻松地对这个选择进行双重检查,像这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> perf trace --no-syscalls           \</div><div class="line">  --event <span class="string">'net:net_dev_queue'</span>           \</div><div class="line">  --event <span class="string">'net:netif_receive_skb_entry'</span> \</div><div class="line">  --event <span class="string">'net:netif_rx'</span>                \</div><div class="line">  --event <span class="string">'net:napi_gro_receive_entry'</span>  \</div><div class="line">  ping <span class="number">172.17</span>.<span class="number">0.2</span> -c1 &gt; /dev/null</div><div class="line">     <span class="number">0.000</span> net:net_dev_queue:dev=docker0 skbaddr=<span class="number">0</span>xffff8e847720a900 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.010</span> net:net_dev_queue:dev=veth7781d5c skbaddr=<span class="number">0</span>xffff8e847720a900 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.014</span> net:netif_rx:dev=eth0 skbaddr=<span class="number">0</span>xffff8e847720a900 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.034</span> net:net_dev_queue:dev=eth0 skbaddr=<span class="number">0</span>xffff8e849cb8<span class="built_in">cd</span>00 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.036</span> net:netif_rx:dev=veth7781d5c skbaddr=<span class="number">0</span>xffff8e849cb8<span class="built_in">cd</span>00 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.045</span> net:netif_receive_skb_entry:dev=docker0 napi_id=<span class="number">0</span>x1 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff8e849cb8<span class="built_in">cd</span>00 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">2</span> <span class="built_in">hash</span>=<span class="number">0</span>x00000000 l4_<span class="built_in">hash</span>=<span class="number">0</span> len=<span class="number">84</span> data_len=<span class="number">0</span> truesize=<span class="number">768</span> mac_header_valid=<span class="number">1</span> mac_header=-<span class="number">14</span> nr_frags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div></pre></td></tr></table></figure>

<p>任务完成!</p>
<p>如果你想更进一步,探索可用网络跟踪点的列表,你可以使用 perf list:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> perf list <span class="string">'net:*'</span></div></pre></td></tr></table></figure>

<p>这应该会返回一个像<code>net:netif_rx</code>这样的跟踪点名称列表。冒号前的部分(&#39;net&#39;)是事件类别;冒号后的是该类别中的事件名称。</p>
<h2 id="使用eBPF_/_bcc编写自定义跟踪器">使用eBPF / bcc编写自定义跟踪器</h2>
<p>对大多数情况来说,这已经远远超出需求了。如果你读这篇文章是为了学习如何在Linux系统上跟踪数据包的旅程,你已经获取了所有需要的信息。但是,如果你想更深入地研究,运行自定义过滤器,跟踪更多的数据,如数据包经过的网络命名空间或源和目的IP,请继续跟我走。</p>
<p>从Linux内核4.7开始,可以将eBPF程序附加到内核跟踪点上。在此之前,构建此跟踪器的唯一替代方法是将探针附加到导出的内核符号上。尽管这种方法可行,但它有一些缺点:</p>
<ul>
<li>内核内部API不稳定。跟踪点是稳定的(尽管数据结构不一定是...)。</li>
<li>出于性能考虑,大多数网络内部函数是内联的或静态的。它们都不能被探测。</li>
<li>找到所有这些函数的潜在调用点很麻烦,有时在这一阶段不可用所需的所有数据。</li>
</ul>
<p>本文的早期版本尝试使用kprobes,它们更易于使用,但结果却是不完整的。</p>
<p>现在，让我们坦诚一点，通过跟踪点访问数据要比使用它们的 kprobe 对应物要繁琐得多。虽然我尽量保持这篇文章尽可能易懂，但您可能希望从我<a href="https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/" target="_blank" rel="external">先前的一篇文章</a>开始。</p>
<p>撇开这个声明，让我们从一个简单的 Hello World 程序开始介绍。在这个 Hello World 示例中，每当我们选择的 4 个跟踪点之一被触发时（net_dev_queue、netif_receive_skb_entry、netif_rx 和 napi_gro_receive_entry），我们将建立一个事件。为了在这个阶段保持简单，我们将发送程序的 comm，即一个 16 个字符的字符串，基本上是程序的名称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bcc/proto.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/sched.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Event structure</span></div><div class="line"><span class="keyword">struct</span> route_evt_t {</div><div class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN];</div><div class="line">};</div><div class="line">BPF_PERF_OUTPUT(route_evt);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> do_trace(<span class="keyword">void</span>* ctx, <span class="keyword">struct</span> sk_buff* skb)</div><div class="line">{</div><div class="line">    <span class="comment">// Built event for userland</span></div><div class="line">    <span class="keyword">struct</span> route_evt_t evt = {};</div><div class="line">    bpf_get_current_comm(evt.comm, TASK_COMM_LEN);</div><div class="line"></div><div class="line">    <span class="comment">// Send event to userland</span></div><div class="line">    route_evt.perf_submit(ctx, &evt, <span class="keyword">sizeof</span>(evt));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * Attach to Kernel Tracepoints</div><div class="line">  */</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, netif_rx) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, net_dev_queue) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, napi_gro_receive_entry) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, netif_receive_skb_entry) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个代码片段会连接到“net”类别的 4 个跟踪点，加载<code>skbaddr</code>字段，并将其传递给通用部分，目前通用部分仅加载程序名称。如果您想知道这个 <code>args-&gt;skbaddr</code> 是从哪里来的（我很高兴您这样想），<code>args</code> 结构是由 <code>bcc</code> 为您生成的，每当您使用 TRACEPOINT_PROBE 定义一个跟踪点时，它都会为您生成。由于它是即时生成的，没有简单的方法来查看它的定义，但是有更好的方法。我们可以直接查看来自内核的数据源。幸运的是，每个跟踪点都有一个 <code>/sys/kernel/debug/tracing/events</code> 条目。例如，对于 net:netif_rx，您可以只运行命令 <code>cat /sys/kernel/debug/tracing/events/net/netif_rx/format</code>，这应该会输出类似于以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">name: netif_rx</div><div class="line">ID: <span class="number">1183</span></div><div class="line">format:</div><div class="line">	field:unsigned short common_<span class="built_in">type</span>;         offset:<span class="number">0</span>; size:<span class="number">2</span>; signed:<span class="number">0</span>;</div><div class="line">	field:unsigned char common_flags;         offset:<span class="number">2</span>; size:<span class="number">1</span>; signed:<span class="number">0</span>;</div><div class="line">	field:unsigned char common_preempt_count; offset:<span class="number">3</span>; size:<span class="number">1</span>; signed:<span class="number">0</span>;</div><div class="line">	field:int common_pid;                     offset:<span class="number">4</span>; size:<span class="number">4</span>; signed:<span class="number">1</span>;</div><div class="line"></div><div class="line">	field:void * skbaddr;         offset:<span class="number">8</span>;  size:<span class="number">8</span>; signed:<span class="number">0</span>;</div><div class="line">	field:unsigned int len;       offset:<span class="number">16</span>; size:<span class="number">4</span>; signed:<span class="number">0</span>;</div><div class="line">	field:__data_loc char[] name; offset:<span class="number">20</span>; size:<span class="number">4</span>; signed:<span class="number">1</span>;</div><div class="line"></div><div class="line">print fmt: <span class="string">"dev=%s skbaddr=%p len=%u"</span>, __get_str(name), REC-&gt;skbaddr, REC-&gt;len</div></pre></td></tr></table></figure>

<p>您可能会注意到记录末尾的打印 fmt 行。这正是 <code>perf trace</code> 用来生成其输出的内容。</p>
<p>有了底层基础代码，并且你已了解了它，我们可以将其包装在一个 Python 脚本中，以显示 eBPF 探针发送的每个事件的一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> inet_ntop</div><div class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</div><div class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> ct</div><div class="line"></div><div class="line">bpf_text = <span class="string">'''&lt;SEE CODE SNIPPET ABOVE&gt;'''</span></div><div class="line"></div><div class="line">TASK_COMM_LEN = <span class="number">16</span> <span class="comment"># linux/sched.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteEvt</span><span class="params">(ct.Structure)</span>:</span></div><div class="line">    _fields_ = [</div><div class="line">        (<span class="string">"comm"</span>,    ct.c_char * TASK_COMM_LEN),</div><div class="line">    ]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">event_printer</span><span class="params">(cpu, data, size)</span>:</span></div><div class="line">    <span class="comment"># Decode event</span></div><div class="line">    event = ct.cast(data, ct.POINTER(RouteEvt)).contents</div><div class="line"></div><div class="line">    <span class="comment"># Print event</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"Just got a packet from %s"</span> % (event.comm)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    b = BPF(text=bpf_text)</div><div class="line">    b[<span class="string">"route_evt"</span>].open_perf_buffer(event_printer)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        b.kprobe_poll()</div></pre></td></tr></table></figure>

<p>您现在可以测试它了。您需要以 root 权限运行。</p>
<blockquote>
<p>请注意：在这个阶段我们没有对包进行筛选。即使是网络使用很低情况也可能会让你的终端刷屏</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$&gt; <span class="built_in">sudo</span> python ./tracepkt.py</div><div class="line">...</div><div class="line">Just got a packet from ping6</div><div class="line">Just got a packet from ping6</div><div class="line">Just got a packet from ping</div><div class="line">Just got a packet from irq/<span class="number">46</span>-iwlwifi</div><div class="line">...</div></pre></td></tr></table></figure>

<p>在这种情况下，您可以看到我正在使用 ping 和 ping6，WiFi 驱动程序刚刚接收了一些数据包。在这种情况下，这是echo reply。</p>
<p>现在让我们开始添加一些有用的数据/筛选条件。</p>
<p>在本文中，我不会重点关注性能。这将更好地展示 eBPF 的功能和限制。要使它（明显）更快，我们可以使用数据包大小作为筛选，假设没有设置“奇怪的” IP 选项。使用这个示例程序会减慢您的网络流量。</p>
<blockquote>
<p>请注意：为了限制此帖子的长度，我将在此处专注于 C/eBPF 部分。我会在帖子末尾放置完整源代码的链接。</p>
</blockquote>
<h2 id="添加网络接口信息">添加网络接口信息</h2>
<p>首先，您可以安全地删除“comm”资源、加载和 sched.h 标头。在这里它没有真正用处，抱歉。</p>
<p>然后，您可以包含 <code>net/inet_sock.h</code>，以便我们有必要的声明，并向事件结构中添加 <code>char ifname[IFNAMSIZ];</code>。</p>
<p>现在，我们将从设备结构中加载设备名称。这很有趣，因为这是一个实际有用的信息，并且在可管理的范围内演示了加载任何数据的技术：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 得到设备指针</span></div><div class="line"><span class="keyword">struct</span> net_device *dev;</div><div class="line">bpf_probe_read(&dev, <span class="keyword">sizeof</span>(skb-&gt;dev), ((<span class="keyword">char</span>*)skb) + offsetof(typeof(*skb), dev));</div><div class="line"></div><div class="line"><span class="comment">// 加载网络接口名称</span></div><div class="line">bpf_probe_read(&evt.ifname, IFNAMSIZ, dev-&gt;name);</div></pre></td></tr></table></figure>

<p>您可以测试它，它可以正常工作。但不要忘记在 Python 部分添加相关的代码 :)</p>
<p>好的，它是如何工作的呢？为了加载接口名称，我们需要接口设备结构。我将从最后一个语句开始解释，因为它最容易理解，前一个实际上只是更复杂的版本。它使用 bpf_probe_read 从 dev-&gt;name 读取长度为 IFNAMSIZ 的数据，并将其复制到 evt.ifname。第一行遵循完全相同的逻辑。它将 <code>skb-&gt;dev</code> 指针的值加载到 <code>dev</code> 中。不幸的是，我没有找到另一种在没有 <code>offsetof / typeof</code> 花招的情况下加载字段地址的方法。</p>
<p>作为提醒，eBPF 的目标是允许对内核进行安全脚本化。这意味着禁止随机内存访问。所有内存访问必须经过验证。除非您访问的内存位于堆栈上，否则需要使用 bpf_probe_read 读取访问器。这使得代码阅读/编写起来很繁琐，但也使其更安全。bpf_probe_read 在内核中的 bpf_trace.c 中定义。其中有一些有趣的部分：</p>
<ol>
<li>它类似于 memcpy。请注意复制对性能的成本。</li>
<li>如果出现错误，它将返回一个初始化为 0 的缓冲区并返回一个错误。它不会崩溃或停止程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> member_read(destination, source_struct, source_member)                 \</span></div><div class="line"> <span class="keyword">do</span>{                                                                          \</div><div class="line">   bpf_probe_read(                                                            \</div><div class="line">     destination,                                                             \</div><div class="line">     <span class="keyword">sizeof</span>(source_struct-&gt;source_member),                                    \</div><div class="line">     ((<span class="keyword">char</span>*)source_struct) + offsetof(typeof(*source_struct), source_member) \</div><div class="line">   );                                                                         \</div><div class="line"> } <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>

<p>这使得我们可以编写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">member_read(&dev, skb, dev);</div></pre></td></tr></table></figure>

<p>好极了!</p>
<h2 id="添加网络命名空间_ID">添加网络命名空间 ID</h2>
<p>这可能是最有价值的信息。就其本身而言，它是所有这些努力的正当理由。不幸的是，这也是最难加载的。</p>
<p>命名空间标识符可以从以下两个地方加载：</p>
<ul>
<li>socket&#39;sk&#39; 结构</li>
<li>设备 &#39;dev&#39; 结构</li>
</ul>
<p>最初，我使用套接字结构，因为这是我在编写 <a href="https://github.com/iovisor/bcc/blob/master/tools/solisten.py" target="_blank" rel="external">solisten.py</a> 时使用的结构。不过，不知为何，一旦数据包跨越命名空间边界，命名空间标识符就不再可读。该字段全为0，这是一个明显的无效内存访问的指示器（请记住 bpf_probe_read 在出现错误时的工作原理），并且破坏了整个目的。</p>
<p>幸运的是，设备方法有效。可以将其看作是询问数据包在哪个接口上以及接口属于哪个命名空间的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> net* net;</div><div class="line"></div><div class="line"><span class="comment">// Get netns id. Equivalent to: evt.netns = dev-&gt;nd_net.net-&gt;ns.inum</span></div><div class="line">possible_net_t *skc_net = &dev-&gt;nd_net;</div><div class="line">member_read(&net, skc_net, net);</div><div class="line"><span class="keyword">struct</span> ns_common* ns = member_address(net, ns);</div><div class="line">member_read(&evt.netns, ns, inum);</div></pre></td></tr></table></figure>

<p>使用以下附加宏以提高可读性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> member_address(source_struct, source_member) \</span></div><div class="line">({                                                   \</div><div class="line">  <span class="keyword">void</span>* __ret;                                       \</div><div class="line">  __ret = (<span class="keyword">void</span>*) (((<span class="keyword">char</span>*)source_struct) + offsetof(typeof(*source_struct), source_member)); \</div><div class="line">  __ret;                                             \</div><div class="line">})</div></pre></td></tr></table></figure>

<p>将这些部分组合在一起，然后... 完成！</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$&gt; <span class="built_in">sudo</span> python ./tracepkt.py</div><div class="line">[  <span class="number">4026531957</span>]          docker0</div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6</div><div class="line">[  <span class="number">4026532258</span>]             eth0</div><div class="line">[  <span class="number">4026532258</span>]             eth0</div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6</div><div class="line">[  <span class="number">4026531957</span>]          docker0</div></pre></td></tr></table></figure>

<p>如果您向 Docker 容器发送 ping，您应该会看到这个。数据包通过本地的 docker0 桥接器传递，然后移动到 veth 对，跨越了网络命名空间边界，回复沿着完全相反的路径返回。</p>
<p>回复这确实是一个棘手的问题！</p>
<h2 id="更进一步：只跟踪request_reply_和_echo_reply_数据包">更进一步：只跟踪request reply 和 echo reply 数据包</h2>
<p>作为奖励，我们还将加载数据包的 IP 地址。无论如何，我们都必须读取 IP 标头。我将在这里坚持使用 IPv4，但相同的逻辑适用于IPv6。</p>
<p>坏消息是，没有什么是真正简单的。请记住，我们正在处理内核，在网络路径中。某些数据包尚未打开。这意味着某些标头偏移仍未初始化。我们将不得不计算它的所有，从 MAC 标头到 IP 标头，最后到 ICMP 标头。</p>
<p>让我们先轻轻松松地加载 MAC 标头地址，并推导出 IP 标头地址。我们不会加载 MAC 标头本身，而是假设它的长度为 14 字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Compute MAC header address</span></div><div class="line"><span class="keyword">char</span>* head;</div><div class="line">u16 mac_header;</div><div class="line"></div><div class="line">member_read(&head,       skb, head);</div><div class="line">member_read(&mac_header, skb, mac_header);</div><div class="line"></div><div class="line"><span class="comment">// Compute IP Header address</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAC_HEADER_SIZE 14;</span></div><div class="line"><span class="keyword">char</span>* ip_header_address = head + mac_header + MAC_HEADER_SIZE;</div></pre></td></tr></table></figure>

<p>这基本上意味着 IP 标头从 <code>skb-&gt;head + skb-&gt;mac_header + MAC_HEADER_SIZE;</code> 开始。</p>
<p>现在，我们可以解码 IP 标头中的 IP 版本，即第一个字节的前 4 位，确保它是 IPv4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载ip的版本</span></div><div class="line">u8 ip_version;</div><div class="line">bpf_probe_read(&ip_version, <span class="keyword">sizeof</span>(u8), ip_header_address);</div><div class="line">ip_version = ip_version &gt;&gt; <span class="number">4</span> & <span class="number">0xf</span>;</div><div class="line"></div><div class="line"><span class="comment">// 过滤 IPv4 packets</span></div><div class="line"><span class="keyword">if</span> (ip_version != <span class="number">4</span>) {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，我们加载完整的 IP 标头，提取 IP 地址以使 Python 信息更有用，确保下一个标头是 ICMP，并推导出 ICMP 标头偏移量。下面是所有这些操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Load IP Header</span></div><div class="line"><span class="keyword">struct</span> iphdr iphdr;</div><div class="line">bpf_probe_read(&iphdr, <span class="keyword">sizeof</span>(iphdr), ip_header_address);</div><div class="line"></div><div class="line"><span class="comment">// Load protocol and address</span></div><div class="line">u8 icmp_offset_from_ip_header = iphdr.ihl * <span class="number">4</span>;</div><div class="line">evt.saddr[<span class="number">0</span>] = iphdr.saddr;</div><div class="line">evt.daddr[<span class="number">0</span>] = iphdr.daddr;</div><div class="line"></div><div class="line"><span class="comment">// Filter ICMP packets</span></div><div class="line"><span class="keyword">if</span> (iphdr.protocol != IPPROTO_ICMP) {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后，我们可以加载 ICMP 标头本身，确保这是一个echo request of reply，并从中加载 id 和 seq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Compute ICMP header address and load ICMP header</span></div><div class="line"><span class="keyword">char</span>* icmp_header_address = ip_header_address + icmp_offset_from_ip_header;</div><div class="line"><span class="keyword">struct</span> icmphdr icmphdr;</div><div class="line">bpf_probe_read(&icmphdr, <span class="keyword">sizeof</span>(icmphdr), icmp_header_address);</div><div class="line"></div><div class="line"><span class="comment">// Filter ICMP echo request and echo reply</span></div><div class="line"><span class="keyword">if</span> (icmphdr.type != ICMP_ECHO && icmphdr.type != ICMP_ECHOREPLY) {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Get ICMP info</span></div><div class="line">evt.icmptype = icmphdr.type;</div><div class="line">evt.icmpid   = icmphdr.un.echo.id;</div><div class="line">evt.icmpseq  = icmphdr.un.echo.sequence;</div><div class="line"></div><div class="line"><span class="comment">// Fix endian</span></div><div class="line">evt.icmpid  = be16_to_cpu(evt.icmpid);</div><div class="line">evt.icmpseq = be16_to_cpu(evt.icmpseq);</div></pre></td></tr></table></figure>

<p>这就是全部内容！</p>
<p>如果您想从特定 ping 实例中过滤 ICMP，您可以假定 evt.icmpid 是 Linux 的 ping 的 PID。</p>
<h2 id="是时候展示了！">是时候展示了！</h2>
<p>启动程序，然后在另一个终端中运行一些 &quot;ping&quot; 命令，观察结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 localhost</span></div><div class="line">[  <span class="number">4026531957</span>]               lo request <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]               lo request <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]               lo   reply <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]               lo   reply <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div></pre></td></tr></table></figure>

<p>一个 ICMP echo request由进程 20212 发送（Linux 的 ping 中的 ICMP id）通过回环接口发送，传递到完全相同的回环接口，其中生成并发送回一个echo reply。回环接口既是发出接口也是接收接口。</p>
<p>那么 WiFi 网关呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 192.168.43.1</span></div><div class="line">[  <span class="number">4026531957</span>]           wlp2s0 request <span class="comment">#20710.001 192.168.43.191 -&gt; 192.168.43.1</span></div><div class="line">[  <span class="number">4026531957</span>]           wlp2s0   reply <span class="comment">#20710.001 192.168.43.1 -&gt; 192.168.43.191</span></div></pre></td></tr></table></figure>

<p>在这种情况下，echo request和echo reply通过 WiFi 接口进行。很容易。</p>
<p>稍微不相关的一点是，还记得当我们只打印拥有数据包的进程的“comm”时吗？在这种情况下，echo request将属于 ping 进程，而reply将属于 WiFi 驱动程序，因为在 Linux 视角下，WiFi 驱动程序是生成回复的进程。</p>
<p>最后一个，也是我个人最喜欢的，ping 一个 Docker 容器。这不是因为 Docker，而是因为它最好地展示了 eBPF 的强大之处。它允许构建了一个类似于 &quot;x-ray&quot; 的工具，用于分析 ping。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div></pre></td></tr></table></figure>

<p>经过一些处理，现在看起来如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       Host netns           | Container netns</div><div class="line">+---------------------------+-----------------+</div><div class="line">| docker0 ---&gt; veth0e65931 ---&gt; eth0          |</div><div class="line">+---------------------------+-----------------+</div></pre></td></tr></table></figure>

<h2 id="最后的话">最后的话</h2>
<p>eBPF/bcc使我们能够编写一系列新的工具，用于深度故障排除、跟踪和追踪先前无法通过内核补丁到达的地方的问题。跟踪点也非常方便，因为它们为我们提供了有趣的位置的良好提示，消除了繁琐阅读内核代码的需要，并可以放置在从 kprobe 中无法访问的代码部分，例如内联或静态函数。</p>
<p>要进一步深入，我们可以添加 IPv6 支持。这很容易做到，我将把它作为读者的练习留下。理想情况下，我希望能够衡量性能的影响。但是这篇帖子已经非常长了。通过跟踪路由和 iptables 决策以及 ARP 数据包，改进这个工具可能会很有趣。所有这些将使这个工具成为像我这样的人的完美“X光”数据包跟踪器，有时需要应对复杂的Linux网络设置。</p>
<p>正如承诺的那样，您可以在Github上查看完整的代码（带有IPv6支持）：<a href="https://github.com/yadutaf/tracepkt" target="_blank" rel="external">https://github.com/yadutaf/tracepkt</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://blog.yadutaf.fr/2017/07/28/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/" target="_blank" rel="external">Tracing a packet journey using Linux tracepoints, perf and eBPF</a></p>
<p>很久以来我一直在寻找一个底层的Linux网络调试工具。<br>我一直在寻找一个低级的Linux网络调试工具已经有一段时间了。Linux 允许使用虚拟接口(virtual interface)和网络命名空间(network namespace)的组合来构建直接在主机上运行的复杂网络。当出现问题时，故障排除相当乏味。如果这是 L3 路由问题，mtr则很有可能会有所帮助。但是，如果这是一个较低层的问题，我通常会手动检查每个接口/网桥/网络命名空间/iptables并启动几个tcpdump，以尝试了解正在发生的事情。如果您事先不了解网络设置，这可能感觉像走迷宫。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mping: 使用新的icmp库实现探测和压测工具]]></title>
    <link href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/"/>
    <id>https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/</id>
    <published>2023-09-10T14:02:15.000Z</published>
    <updated>2023-09-24T07:01:49.816Z</updated>
    <content type="html"><![CDATA[<p>项目地址： <a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a></p>
<p>最近在网络探测的分析中，需要做一个使用ICMP协议进行压测的工具， ping或者fping多多少少都不满足需求，所以需要自己写一个。</p>
<p>使用<a href="https://pkg.go.dev/golang.org/x/net/icmp" target="_blank" rel="external">golang.org/x/net/icmp</a>很容易的实现基于ICMP的工具， <a href="https://github.com/go-ping/ping" target="_blank" rel="external">go-ping</a>就算了，既缺乏维护性能也不佳。所以我最初使用Go官方扩展库实现了这个工具，不过这几天我看到Matt Layher刚推出一个新的ICMP库：<a href="https://github.com/mdlayher/icmpx" target="_blank" rel="external">mdlayher/icmpx</a>， 我决定尝试一下。Matt Layher 是Go网络编程的专家，写了好几个网络相关的库，所以我对他的库还是蛮有信心的。</p>
<a id="more"></a>
<p>而且我在使用这个库的过程中，给他提了一个需求，希望能增加设置TOS的功能，他当天就给加上了，少有的活跃和友善的开源作者。</p>
<p>这个库的使用也非常简单，<code>ReadFrom</code>用来读，<code>WriteTo</code>用来发， <code>Close</code>用来关闭， <code>SetTOS</code>是我提的一个需求，可以设置TOS值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IPv4Conn</div><div class="line">    <span class="keyword">func</span> ListenIPv4(ifi *net.Interface, cfg IPv4Config) (*IPv4Conn, error)</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) Close() error</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) ReadFrom(ctx context.Context) (*icmp.Message, netip.Addr, error)</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) SetTOS(tos <span class="typename">int</span>) error</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) WriteTo(ctx context.Context, msg *icmp.Message, dst netip.Addr) error</div></pre></td></tr></table></figure>

<p>当然它还有对应的IPv6版本，功能类似，我们就不介绍了，本文只介绍IPv4的功能。</p>
<p>先前我在我的网站和公众号发表过一篇文章<a href="https://colobu.com/2023/04/26/write-the-ping-tool-in-Go/" target="_blank" rel="external">使用Go实现ping工具</a>,介绍了几种实现ping的方式，这一次，我使用另外一个方法，使用一个新的ICMP库，实现一个真正落地使用的工具。</p>
<p>我把这个工具的实现分为四个部分：</p>
<ul>
<li>主程序：  程序的入口，主要解析各种参数</li>
<li>发送函数：发送ICMP数据</li>
<li>接收函数：接收ICMP回包</li>
<li>统计输出：输出每个周期的丢包率和时延</li>
</ul>
<p>接下来我分别介绍。这个程序的代码在 <a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a></p>
<h2 id="主程序入口">主程序入口</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	count        = pflag.IntP(<span class="string">"count"</span>, <span class="string">"c"</span>,<span class="number"> 0</span>, <span class="string">"count, 0 means non-setting"</span>)</div><div class="line">	tos          = pflag.IntP(<span class="string">"tos"</span>, <span class="string">"z"</span>,<span class="number"> 0</span>, <span class="string">"tos, 0 means non-setting"</span>)</div><div class="line">	packetSize   = pflag.IntP(<span class="string">"size"</span>, <span class="string">"s"</span>,<span class="number"> 64</span>, <span class="string">"packet size"</span>)</div><div class="line">	timeout      = pflag.DurationP(<span class="string">"timeout"</span>, <span class="string">"t"</span>, time.Second, <span class="string">"timeout"</span>)</div><div class="line">	rate         = pflag.IntP(<span class="string">"rate"</span>, <span class="string">"r"</span>,<span class="number"> 100</span>, <span class="string">"rate, 100 means 100 packets per second for each target"</span>)</div><div class="line">	delay        = pflag.IntP(<span class="string">"delay"</span>, <span class="string">"d"</span>,<span class="number"> 3</span>, <span class="string">"delay seconds"</span>)</div><div class="line">	bitflipCheck = pflag.BoolP(<span class="string">"bitflip"</span>, <span class="string">""</span>, <span class="constant">false</span>, <span class="string">"check bitflip"</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>它包含几个参数，使用 <code>github.com/spf13/pflag</code>进行解析。之所以不使用标准库的<code>flag</code>解析， 是因为<code>pflag</code>更强大，支持短参数和长参数，支持将参数放在最后面，更符合Linux ping/traceroute的参数样式。</p>
<ul>
<li>count: 你可以持续进行探测，也可以使用<code>-c</code>指定发多少包后退出。</li>
<li>tos: 可以指定网络的优先级，针对不同的优先级进行探测和压测。</li>
<li>size: 指定包的大小。这里的包大小其实指的是payload, 不包含ICMP、IP以及以上的包头</li>
<li>timeout: 指定发送数据的超时时间</li>
<li>rate: 发包的频率， 也就是 pps (packet/second)</li>
<li>delay: 最大延迟时间，超过这个时间的包就丢弃了</li>
<li>bitflip: 检查经过的物理链路中是否有改包的行为。 芯片的老化、bug、或者电磁辐射等等有可能把链路中的一个或者几个比特位进行修改，网络和服务器可能能通过CRC检查到，但是由于CRC的缺陷也可能检查不到，导致落盘的数据是错误的。从业屙屎多年来我也经历过几起。</li>
</ul>
<p>这是参数的设置，也你也可以把它当做一个需求，想一想程序该怎么实现。</p>
<p>这个程序还需要一个参数，也就是要探测的目的地址。</p>
<p>mping支持同时探测多个目的地址。目的地址可以是域名，也可以是网段，比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> ./mping -r <span class="number">100</span> <span class="number">8.8</span>.<span class="number">8.8</span>/<span class="number">30</span>,<span class="number">8.8</span>.<span class="number">4.4</span>,github.com</div></pre></td></tr></table></figure>

<p>因为我们使用了底层的socket编程方式，所以需要 root 用户才能执行这个程序， 或者 root用户使用 <code>setcap cap_net_raw=+ep ./mping</code> 设置权限后， 普通用户也能执行。</p>
<p>具体的参数检查和处理我就不赘述了，比较简单，大家可以看项目中的源代码。总是我们会把目的地址拆解成一组具体的 IP地址，放在变量<code>targetAddrs []string</code>中。</p>
<p>接下来我们看看是怎么收发包的。</p>
<h2 id="发包">发包</h2>
<p>因为icmpx这个包它要求传入一个网络接口，这是有点讨厌的地方，我们不得不使用<a href="https://github.com/smallnest/qianmo" target="_blank" rel="external">qianmo</a>库获得一个网络接口。这例其实是有点小缺陷的，如果你所在的探测服务器有多个IP地址，每个地址有不同的路由，这里找到的网络接口可能不是你想要的。更好的解决办法根据目的地址，找到本地对应的IP和网络接口。但是如果目的地址有多个，使用不同的网络接口的话，处理起来有很麻烦，所以这里我们从简处理了。</p>
<p>找到网络接口后就可以创建 <code>icmpx.IPv4Conn</code>对象了，创建好后我们可以设置TOS值，本文就省略了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   addrs := qianmo.NonLoopbackAddrs()</div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(addrs) ==<span class="number"> 0</span> {</div><div class="line">	<span class="keyword">return</span> errors.New(<span class="string">"no non-loopback address"</span>)</div><div class="line">}</div><div class="line"></div><div class="line">iface, err := qianmo.InterfaceByIP(addrs<span class="number">[0</span>])</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get interface by ip: %w"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line">conn, err := icmpx.ListenIPv4(iface, icmpx.IPv4Config{</div><div class="line">	Filter: icmpx.IPv4AllowOnly(ipv4.ICMPTypeEchoReply),</div><div class="line">})</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line"><span class="keyword">go</span> send(conn) <span class="comment">// 发包</span></div><div class="line"><span class="keyword">go</span> printStat() <span class="comment">// 定期统计输出</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> read(conn) <span class="comment">// 读包</span></div></pre></td></tr></table></figure>

<p>这个<code>icmpx.IPv4Conn</code>我们既用它发包，也用来收包。</p>
<p>注意在创建IPv4Conn的时候我们增加了一个filter,我们只接收<code>ipv4.ICMPTypeEchoReply</code>回包。 在网络环境中，服务器总是有一些ICMP包的干扰，通过这个filter,我们可以筛选出我们所关注的ICMP包。</p>
<p>最主要的发送逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> send(conn *icmpx.IPv4Conn) {</div><div class="line">	<span class="keyword">defer</span> connOnce.Do(<span class="keyword">func</span>() { conn.Close() })</div><div class="line"></div><div class="line">    <span class="comment">// 限流器，按照我们需要的速率发送</span></div><div class="line">	limiter := ratelimit.New(*rate, ratelimit.Per(time.Second))</div><div class="line"></div><div class="line">	...... <span class="comment">// 准备发送的数据</span></div><div class="line"></div><div class="line">	sentPackets :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		seq++ <span class="comment">// 用来将发送的包和回来的包匹配</span></div><div class="line">		ts := time.Now().UnixNano()</div><div class="line">		binary.LittleEndian.PutUint64(data[<span class="built_in">len</span>(msgPrefix):], <span class="typename">uint64</span>(ts)) <span class="comment">// 把发送时的时间戳放入payload, 以便计算时延</span></div><div class="line"></div><div class="line">        <span class="comment">// 发送的icmp包</span></div><div class="line">		req := &icmp.Message{</div><div class="line">			Type: ipv4.ICMPTypeEcho,</div><div class="line">			Body: &icmp.Echo{</div><div class="line">				ID:   <span class="typename">int</span>(id),</div><div class="line">				Seq:  <span class="typename">int</span>(seq),</div><div class="line">				Data: data,</div><div class="line">			},</div><div class="line">		}</div><div class="line"></div><div class="line"></div><div class="line">		limiter.Take() <span class="comment">// 获取一个令牌，开始发包</span></div><div class="line">		<span class="keyword">for</span> _, target := <span class="keyword">range</span> targetAddrs { <span class="comment">//对每一个目标，都使用这个conn发送</span></div><div class="line">			key := ts / <span class="typename">int64</span>(time.Second)</div><div class="line">			stat.Add(key, &Result{ <span class="comment">// 统计发包</span></div><div class="line">				ts:     ts,</div><div class="line">				target: target,</div><div class="line">				seq:    seq,</div><div class="line">			})</div><div class="line"></div><div class="line">			ctx, cancel := context.WithTimeout(context.Background(), *timeout)</div><div class="line">			err := conn.WriteTo(ctx, req, netip.MustParseAddr(target)) <span class="comment">// 写入</span></div><div class="line">			cancel()</div><div class="line">			<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		......</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里有几个技巧：</p>
<ul>
<li>包payload我们加了前缀<code>smallnest</code>, 以便检查回包是否合法</li>
<li>ICMP Echo包中的id 一般我们设置为程序的进程号</li>
<li>ICMP Echo包中的seq我们递增，收到回包后我们可以把回包和发送的包做匹配</li>
<li>使用限流器控制发送的速率</li>
<li>发送的payload加上了发送的时间戳，收到回包后可以计算时延(latency)</li>
<li>发送的payload使用随机数据填充，收到包后检查数据，看看有没有改包行为</li>
</ul>
<p>发送使用了一个goroutine。</p>
<h2 id="接收">接收</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> read(conn *icmpx.IPv4Conn) error {</div><div class="line">	<span class="keyword">defer</span> connOnce.Do(<span class="keyword">func</span>() { conn.Close() })</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		ctx, cancel := context.WithTimeout(context.Background(), time.Second*time.Duration((*delay)))</div><div class="line">        <span class="comment">// 读取ICMP返回的包</span></div><div class="line">		msg, addr, err := conn.ReadFrom(ctx)</div><div class="line">		cancel()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}</div><div class="line">        </div><div class="line">        ......</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> pkt := msg.Body.(<span class="keyword">type</span>) {</div><div class="line">		<span class="keyword">case</span> *icmp.Echo:</div><div class="line">			<span class="keyword">if</span> <span class="typename">uint16</span>(pkt.ID) != id { <span class="comment">// 检查id</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(pkt.Data) &lt; <span class="built_in">len</span>(msgPrefix<span class="number">)+8</span> {</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> !bytes.HasPrefix(pkt.Data, msgPrefix) { <span class="comment">//检查前缀是否匹配</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			ts := <span class="typename">int64</span>(binary.LittleEndian.Uint64(pkt.Data[<span class="built_in">len</span>(msgPrefix):])) <span class="comment">// 获取时间戳</span></div><div class="line">			key := ts / <span class="typename">int64</span>(time.Second)</div><div class="line"></div><div class="line">			bitflip := <span class="constant">false</span></div><div class="line">			<span class="keyword">if</span> *bitflipCheck { <span class="comment">// 检查是否有改包</span></div><div class="line">				bitflip = !bytes.Equal(pkt.Data[<span class="built_in">len</span>(msgPrefix<span class="number">)+8</span>:], payload)</div><div class="line">			}</div><div class="line">			stat.Add(key, &Result{ <span class="comment">// 统计回包</span></div><div class="line">				ts:       ts,</div><div class="line">				target:   target,</div><div class="line">				latency:  time.Now().UnixNano() - ts,</div><div class="line">				received: <span class="constant">true</span>,</div><div class="line">				seq:      <span class="typename">uint16</span>(pkt.Seq),</div><div class="line">				bitflip:  bitflip,</div><div class="line">			})</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接收也很检查，就是收到包后各种检查，确保收到的包和发送包是匹配的。</p>
<p>可以看到，我们使用<code>icmpx</code>这个库的时候，相对Go官方的icmp库，处理起来相对就简单了。</p>
<h2 id="统计">统计</h2>
<p>最后一个部分就是统计了。我们收发包已经完成，那么我们希望每秒能在命令行中打印出每一秒的统计信息，包括发送了多少包，丢弃了多少包，丢包率是多少，时延是多少。</p>
<p>我们的统计方法是这样子的：</p>
<ul>
<li>每个周期(1秒)的数据放入一个篮子中(Bucket)</li>
<li>每一秒检查前面 delay 秒的bucket,统计这个篮子内的发包丢包情况</li>
<li>篮子中的数据使用map对象保存， key是 target-seq, 收到的回包数据会覆盖发包数据，如果没有被覆盖，那么检查请求的包就知道丢包了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> printStat() {</div><div class="line">	delayInSeconds := <span class="typename">int64</span>(*delay) <span class="comment">// 5s</span></div><div class="line">	ticker := time.NewTicker(time.Second)</div><div class="line">	<span class="keyword">var</span> lastKey <span class="typename">int64</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> ticker.C {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> bucket.Key &lt;= time.Now().UnixNano()/<span class="typename">int64</span>(time.Second)-delayInSeconds {</div><div class="line">			pop := stat.Pop().(*Bucket)</div><div class="line">			......</div><div class="line"></div><div class="line">			targetResult := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]*TargetResult)</div><div class="line"></div><div class="line">			<span class="keyword">for</span> _, r := <span class="keyword">range</span> pop.Value {</div><div class="line">				target := r.target</div><div class="line"></div><div class="line">				tr := targetResult[target]</div><div class="line">				<span class="keyword">if</span> tr == <span class="constant">nil</span> {</div><div class="line">					tr = &TargetResult{}</div><div class="line">					targetResult[target] = tr</div><div class="line">				}</div><div class="line"></div><div class="line">				tr.latency += r.latency <span class="comment">// 把时延加在一起，输出的时候算平均值</span></div><div class="line"></div><div class="line">				<span class="keyword">if</span> r.received { <span class="comment">// 如果是回包，回包数加一</span></div><div class="line">					tr.received++ </div><div class="line">				} <span class="keyword">else</span> { <span class="comment">// 否则丢包数加一</span></div><div class="line">					tr.loss++</div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> *bitflipCheck && r.bitflip { <span class="comment">// 改包的数</span></div><div class="line">					tr.bitflipCount++</div><div class="line">				}</div><div class="line"></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> target, tr := <span class="keyword">range</span> targetResult {</div><div class="line">				......</div><div class="line"></div><div class="line">				<span class="keyword">if</span> *bitflipCheck {</div><div class="line">					...... <span class="comment">// 输出统计信息</span></div><div class="line">                    log.Printf(<span class="string">"%s: sent:%d, recv:%d,  loss rate: %.2f%%, latency: %v, bitflip: %d\n"</span>, target, total, tr.received, lossRate<span class="number">*100</span>, time.Duration(tr.latency/<span class="typename">int64</span>(tr.received)), tr.bitflipCount)</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">                    ...... <span class="comment">// 输出统计信息</span></div><div class="line">				}</div><div class="line">			}</div><div class="line"></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样，我们的mping工具就开发完成了，看看它的功能吧：<br><img src="mping.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目地址： <a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a></p>
<p>最近在网络探测的分析中，需要做一个使用ICMP协议进行压测的工具， ping或者fping多多少少都不满足需求，所以需要自己写一个。</p>
<p>使用<a href="https://pkg.go.dev/golang.org/x/net/icmp" target="_blank" rel="external">golang.org/x/net/icmp</a>很容易的实现基于ICMP的工具， <a href="https://github.com/go-ping/ping" target="_blank" rel="external">go-ping</a>就算了，既缺乏维护性能也不佳。所以我最初使用Go官方扩展库实现了这个工具，不过这几天我看到Matt Layher刚推出一个新的ICMP库：<a href="https://github.com/mdlayher/icmpx" target="_blank" rel="external">mdlayher/icmpx</a>， 我决定尝试一下。Matt Layher 是Go网络编程的专家，写了好几个网络相关的库，所以我对他的库还是蛮有信心的。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 1.21 中的泛型推断]]></title>
    <link href="https://colobu.com/2023/08/18/go1-21-generics/"/>
    <id>https://colobu.com/2023/08/18/go1-21-generics/</id>
    <published>2023-08-18T00:50:46.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://encore.dev/blog/go1.21-generics" target="_blank" rel="external">understanding Go 1.21 generics type inference</a></p>
<p>Go 1.21 已经发布了，带来了一系列的改进，例如更好的泛型类型推断（本文的内容）;新的内置函数<code>min`</code>,<code>max</code>和<code>clear`</code>;以及标准库中的几个新软件包（<code>maps`</code>,<code>slices`</code>,<code>cmp`</code>,<code>log/slog</code>和<code>testing/slogtest`</code>)。在<a href="https://golang.org/doc/go1.21" target="_blank" rel="external">这里</a>阅读完整的发行说明。</p>
<p>至少对我们Encore来说，特别感兴趣的是对泛型类型推断的改进，因为它会影响Encore的静态分析的工作方式。但是，我们认为发行说明很难理解，因此本文通过更多解释和示例介绍这次的变更。</p>
<p>我们也刚刚发布了支持 Go 1.21 的 Encore v1.24，所以这是尝试这些新变化的好方法。</p>
<a id="more"></a>
<h2 id="部分实例化的泛型函数">部分实例化的泛型函数</h2>
<p>来自 Go 1.21 发行说明：</p>
<blockquote>
<p>现在可以使用本身（可能部分实例化）泛型函数的参数调用（可能部分实例化的泛型）函数。编译器将尝试推断被调用方缺少的类型参数（as before），对于每个未完全实例化的泛型函数的参数，将尝试推断其缺少的类型参数（new）。典型的用例是对在容器上运行的泛型函数的调用（例如<code>slices.IndexFunc</code>），其中函数参数也可以是泛型的，并且被调用函数的类型参数及其参数是从容器类型推断出来的。</p>
</blockquote>
<p>啥意思？</p>
<p>考虑一个函数，该函数需要传入一个值并报告它是否为零值：。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> IsZero[T comparable](a T) <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>在 Go 1.21 之前，将这样的函数作为参数传递给另一个（泛型或非泛型）函数需要你显式指定类型参数，即使从上下文中很明显能看出类型。<br>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Any reports whether fn returns true for any number in the slice.</span></div><div class="line"><span class="keyword">func</span> Any(numbers []<span class="typename">int</span>, fn <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> numbers {</div><div class="line">		<span class="keyword">if</span> fn(v) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>fn处理numbers,只要有一个是true,Any就返回true</p>
</blockquote>
<p>使用Go 1.21，您现在就可以这些写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numbers := []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line"></div><div class="line"><span class="comment">// Go 1.21</span></div><div class="line">anyZeroes := Any(numbers, IsZero)</div><div class="line"></div><div class="line"><span class="comment">// Go 1.21之前，你不得不这样写</span></div><div class="line">anyZeroes := Any(numbers, IsZero[<span class="typename">int</span>])</div></pre></td></tr></table></figure>

<p>如发行说明所示，这也适用于泛型函数。所以你也可以写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Go 1.21</span></div><div class="line">firstZeroIndex := slices.IndexFunc(numbers, IsZero)</div><div class="line"></div><div class="line"><span class="comment">// Go 1.21之前，你不得不这样写</span></div><div class="line">firstZeroIndex := slices.IndexFunc(numbers, IsZero[<span class="typename">int</span>])</div></pre></td></tr></table></figure>

<p>Go 1.21可以从类型<code>numbers</code>推断<code>IsZero</code>是<code>IsZero[int]</code> ,即使<code>slices.IndexFunc</code>是一个泛型函数。</p>
<p>发行说明中在同一段落继续讲到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">更一般地说，如果可以从赋值推断类型参数，则在将泛型函数分配给变量或作为结果值返回时，现在可以在没有显式实例化的情况下使用泛型函数。</div></pre></td></tr></table></figure>

<p>这意味着以下内容现在有效（在 Go 1.21 之前，您需要显式指定类型参数）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IsZero 被推断为 IsZero[string]，因为根据类型func(a string) bool可以推断出</span></div><div class="line"><span class="keyword">var</span> isZeroString <span class="keyword">func</span>(a <span class="typename">string</span>) <span class="typename">bool</span> = IsZero</div><div class="line"></div><div class="line"><span class="keyword">func</span> IsNilPointerFactory[T any] <span class="keyword">func</span>() <span class="keyword">func</span>(val *T) <span class="typename">bool</span> {</div><div class="line">  <span class="comment">// IsZero 是 IsZero[*T]， 因为根据返回值func(val *T) bool可以推断出来</span></div><div class="line">  <span class="keyword">return</span> IsZero</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="接口赋值推断">接口赋值推断</h2>
<p>Go 1.21 还改进了泛型接口类型的类型推断。从发行说明：</p>
<blockquote>
<p>类型推断现在还会在将值分配给接口时考虑方法：方法签名中使用的类型参数的类型参数可以从匹配方法的相应参数类型推断出来。</p>
</blockquote>
<p>这是啥意思呢？请考虑以下泛型接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RandomElementer[T any] <span class="keyword">interface</span> {</div><div class="line">    <span class="comment">// 返回一个随机的元素，如果集合为空，返回(zero, false)</span></div><div class="line">	RandomElement() (T, <span class="typename">bool</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后考虑一个泛型的帮助程序函数，该函数调用某个集合，但如果集合为空，则会panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 必须返回一个元素，如果集合为空,则panic</span></div><div class="line"><span class="keyword">func</span> MustRandom[T any](collection RandomElementer[T]) T {</div><div class="line">	val, ok := collection.RandomElement()</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"collection is empty"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> val</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在 Go 1.21 中，现在可以调用接口类型，并且接口类型将从参数中推断出来。考虑以下两种类型，一种泛型的，一种不是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyList 泛型集合.</span></div><div class="line"><span class="keyword">type</span> MyList[T any] []T</div><div class="line"><span class="keyword">func</span> (l MyList[T]) RandomElement() (T, <span class="typename">bool</span>) { <span class="comment">/* ... */</span> }</div><div class="line"></div><div class="line"><span class="comment">// IPSet 代表一个IP集合，非泛型的</span></div><div class="line"><span class="keyword">type</span> IPSet <span class="keyword">map</span>[netip.Addr]<span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> (s IPSet) RandomElement() (netip.Addr, <span class="typename">bool</span>) { <span class="comment">/* ... */</span> }</div></pre></td></tr></table></figure>

<p>这些现在（Go1.21）可以像这样使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">randomInt := MustRandom(MyList[<span class="typename">int</span>]{})</div><div class="line">randomIP := MustRandom(IPSet{})</div><div class="line"></div><div class="line"><span class="comment">// Go 1.20或者以前，你不得不写成如下的方式</span></div><div class="line">randomInt := MustRandom[<span class="typename">int</span>](MyList[<span class="typename">int</span>]{})</div><div class="line">randomIP := MustRandom[netip.Addr](IPSet{})</div></pre></td></tr></table></figure>

<p>优秀！继续前进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同样，由于类型参数必须实现其相应约束的所有方法，因此类型参数和约束的方法匹配，这可能导致推断其他类型参数。</div></pre></td></tr></table></figure>

<p>这基本上意味着上述类型推断也扩展到采用额外类型的函数。 例如，<code>MustRandom</code>签名可以重写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> MustRandom[R RandomElementer[T], T any](collection R) T</div></pre></td></tr></table></figure>

<p>当调用<code>MustRandom(IPSet{})</code>时,Go 1.21 在调用时正确推断<code>R</code>和<code>T</code>。</p>
<h2 id="非类型化常量的类型推断">非类型化常量的类型推断</h2>
<blockquote>
<p>如果将多个不同类型的非类型化常量参数（如非类型化 int 和非类型化浮点常量）传递给具有相同（未另行指定）类型参数类型的参数，这不会报错，类型推断现在使用与具有非类型化常量操作数的运算符相同的方法确定类型。此更改使从非类型常量参数推断的类型与常量表达式的类型一致</p>
</blockquote>
<p>Go 具有非类型常量的概念，并且表达式的类型<code>a+b</code>是从常量值<code>a</code>和<code>b</code>推断出来的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x =<span class="number"> 1</span> +<span class="number"> 2</span>   <span class="comment">// x 是int</span></div><div class="line"><span class="keyword">var</span> y =<span class="number"> 1</span> +<span class="number"> 2.5</span> <span class="comment">// y 是 float64</span></div></pre></td></tr></table></figure>

<p>现在考虑编写一个行为类似于内置运算符<code>+</code>的泛型函数<code>Add</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Add[T <span class="typename">int</span> | <span class="typename">float64</span>](a, b T) T {</div><div class="line">  <span class="keyword">return</span> a + b</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在 Go 1.21 中，这与您所期望的完全一样工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = Add<span class="number">(1</span>,<span class="number"> 2</span>)   <span class="comment">// x 是 int</span></div><div class="line"><span class="keyword">var</span> y = Add<span class="number">(1</span>,<span class="number"> 2.5</span>) <span class="comment">// y 是 float64</span></div></pre></td></tr></table></figure>

<p>在 Go 1.20 中，相同的代码无法编译，因为类型推断将分别考虑每个参数。它将推断 1的类型是int, 然后无法与2.5的类型float64统一，从而导致错误“default type float64 of 2.5 does not match inferred type int for T”。</p>
<h2 id="总结">总结</h2>
<p>这就是 Go 1.21 中对泛型类型推断的更改程度。希望这些示例有助于使更改更易于理解;反正经过摸索我更容易理解了，家人们如果理解了请在页面一键三连。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://encore.dev/blog/go1.21-generics" target="_blank" rel="external">understanding Go 1.21 generics type inference</a></p>
<p>Go 1.21 已经发布了，带来了一系列的改进，例如更好的泛型类型推断（本文的内容）;新的内置函数<code>min`</code>,<code>max</code>和<code>clear`</code>;以及标准库中的几个新软件包（<code>maps`</code>,<code>slices`</code>,<code>cmp`</code>,<code>log/slog</code>和<code>testing/slogtest`</code>)。在<a href="https://golang.org/doc/go1.21" target="_blank" rel="external">这里</a>阅读完整的发行说明。</p>
<p>至少对我们Encore来说，特别感兴趣的是对泛型类型推断的改进，因为它会影响Encore的静态分析的工作方式。但是，我们认为发行说明很难理解，因此本文通过更多解释和示例介绍这次的变更。</p>
<p>我们也刚刚发布了支持 Go 1.21 的 Encore v1.24，所以这是尝试这些新变化的好方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真实世界的Go设计模式 - 对象池模式]]></title>
    <link href="https://colobu.com/2023/08/08/go-design-pattern-pool/"/>
    <id>https://colobu.com/2023/08/08/go-design-pattern-pool/</id>
    <published>2023-08-07T16:27:13.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p><strong>对象池</strong>（object pool pattern）是一种设计模式。一个<strong>对象池</strong>包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。<br><a id="more"></a></p>
<p>若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p>
<p>另外，利用对象池，我们可以重用对象，减少对象的分配，对于垃圾回收的编程语言，也是一种提高性能的手段。</p>
<p>sync.Pool是Go标准库sync包中的一个非常有用的结构,它可以用来管理和重用临时对象,以减少对象频繁分配和回收的开销。</p>
<p>sync.Pool的主要特点包括:</p>
<ul>
<li>Pool维护一个可存储和共享临时对象的集合,这些对象无需频繁地申请和回收内存。</li>
<li>Pool通过New字段指定一个函数,用来生成新对象放入pool中。</li>
<li>通过Get方法可以从pool中获得一个可重用对象,使用后调用Put方法将其放回pool。</li>
<li>对象在不再需要时不会立即销毁,而是被保留在Pool中以便后续重用。</li>
<li>Pool会根据需求自动调整对象个数,会定期GC不再使用的对象。</li>
<li>每个P都有一个本地pool,goroutine优先从本地pool获取和放回对象。</li>
</ul>
<p>通过重用对象,可以减少内存分配和垃圾回收的开销,特别适合用于管理许多临时对象的场景,如处理大量并发请求时的缓冲、连接等。</p>
<p>比如net/rpc包就使用了链表来管理常用的Response、Request等对象的重用。</p>
<p>Go标准库database/sql包实现了一个连接池,可以重用数据库连接。使用DB.Conn()获取连接对象,操作完成后调用conn.Close()将其放回池中。该连接池默认最大空闲连接数2,可以通过SetMaxIdleConns进行调整。</p>
<p><a href="https://github.com/fatih/pool" target="_blank" rel="external">fatih/pool</a> 也是一个常用的网络连接池。</p>
<p>还有一类是goroutine pool,也又叫做worker pool的，这类的库就很多的，而且还有人源源不断的造轮子。比如常用的比如：</p>
<ul>
<li><p><a href="https://github.com/Jeffail/tunny" target="_blank" rel="external">Jeffail/tunny</a></p>
</li>
<li><p><a href="https://github.com/panjf2000/ants" target="_blank" rel="external">panjf2000/ants</a></p>
</li>
<li><p><a href="https://github.com/ivpusic/grpool" target="_blank" rel="external">ivpusic/grpool</a></p>
</li>
<li><p><a href="https://github.com/alitto/pond" target="_blank" rel="external">alitto/pond</a></p>
</li>
</ul>
<p>因为使用channel + goroutine很容易实现goroutine pool,所以也有很多关注度不高的轮子，都是作者针对自己的需求定制和改造的。使用也很方便。</p>
<p>Go标准库还有一个实验性的包<code>arena</code>,本来就在Go 1.20中就要推出的，但是在实现的过程中发现有问题，就一直没有暴露出来。<a href="https://github.com/golang/go/issues/51317" target="_blank" rel="external">proposal: arena: new package providing memory arenas </a>这个提案详细介绍了内容。你也可以把它看成是一个内存池，从其中产生的对象不会被垃圾回收掉，能够提升程序的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>对象池</strong>（object pool pattern）是一种设计模式。一个<strong>对象池</strong>包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
