<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2024-02-20T11:12:54.352Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[聊聊 Go 的边界检查消除技术]]></title>
    <link href="https://colobu.com/2024/02/19/bce/"/>
    <id>https://colobu.com/2024/02/19/bce/</id>
    <published>2024-02-19T14:47:39.000Z</published>
    <updated>2024-02-20T11:12:22.416Z</updated>
    <content type="html"><![CDATA[<p>在翻译的<a href="https://mp.weixin.qq.com/s/l6Tq_bVDmMpwZg_rPfi1DQ" target="_blank" rel="external">从慢速到SIMD</a>一文中， SourceGraph工程师其中的一个优化就是边界检查消除(BCE,bounds check elimination)技术，同时他也抛给了读者一个问题：</p>
<blockquote>
<p>为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</p>
</blockquote>
<p>本文第一部分先回答这个问题。 第二部分介绍更好的边界检查消除方法。 第三部分再全面梳理Go的边界检查消除技术。</p>
<a id="more"></a>
<h2 id="为啥在使用_a[i:i+4:i+4]_而不是_a[i:i+4]?">为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</h2>
<p>这篇文章发布到几个平台之后，很多Gopher都在问这个问题的答案，包括《100个Go语言典型错误》的作者也在twitter上询问,再比如<a href="https://news.ycombinator.com/item?id=39106972" target="_blank" rel="external">Hacker News</a>上的讨论，<a href="https://www.reddit.com/r/golang/comments/199u7np/from_slow_to_simd_a_go_optimization_story/" target="_blank" rel="external">reddit</a>。</p>
<p>当然，还每看过这篇文章的同学还不明白前因后果，这里我再简单介绍一下。SourceGraph工程师使用BCE做优化，他的代码如下，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotBCE(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slices must have equal lengths"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)<span class="number">%4</span> !=<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slice length must be multiple of 4"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		aTmp := a[i : i<span class="number">+4</span> : i<span class="number">+4</span>] <span class="comment">// &lt;--- 这里会做边界检查</span></div><div class="line">		bTmp := b[i : i<span class="number">+4</span> : i<span class="number">+4</span>] <span class="comment">// &lt;--- 这里会做边界检查</span></div><div class="line">		s0 := aTmp<span class="number">[0</span>] * bTmp<span class="number">[0</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		s1 := aTmp<span class="number">[1</span>] * bTmp<span class="number">[1</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		s2 := aTmp<span class="number">[2</span>] * bTmp<span class="number">[2</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		s3 := aTmp<span class="number">[3</span>] * bTmp<span class="number">[3</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意做边界检查的那两行，它们做了边界检查，新的slice的len和cap都是4,可以确保<code>aTemp[0]</code>、<code>aTemp[3]</code>、<code>bTemp[0]</code>、<code>bTemp[3]</code>不会越界,所以下面四行不用做边界检查了。不过边界检查少了很多的指令，可以提高性能。</p>
<p>我们怎么知道哪一行做了边界检查呢？可以使用下面的命令编译，会把做边界检查的行数打印出来。</p>
<p><img src="bce1.png" alt=""></p>
<p>可以看到结果和我们注释中的一样，只在第14、15行做了边界检查。</p>
<p>但是话锋一转，SourceGraph工程师突然问了一个问题：为啥这两行使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</p>
<p>难道<code>a[i:i+4]</code>会导致下面四行做边界检查吗？这个问题让很多人都很好奇，几个论坛上没有答案。我翻译的文章评论中也有小伙伴问这个问题。</p>
<p>首先，我们修改为<code>a[i:i+4]</code>，然后编译，看看结果:<br><img src="bce1.png" alt=""></p>
<p>没什么区别，还是在第14、15行做了边界检查，接下来四行做了边界检查消除，不一样么？</p>
<p>这个问题 <a href="https://go101.org/" target="_blank" rel="external">Go101 老貘</a> 在Twitter上提了一下，没有展开讲，购买了他的书的同学可以看看那一章：<br><img src="bce2.png" alt=""></p>
<p>接下来我从最开始的讨论讲起，那还得从2018年的秋天的一个提交讲起。</p>
<p>不想看历史的同学可以直接跳过去，结论就是：这样写不是为了边界检查消除，而是为了性能。</p>
<p>这是一次对<a href="https://go-review.googlesource.com/c/go/+/136935" target="_blank" rel="external">image/draw: optimize bounds checks in loops</a>做边界检查的优化:<br><img src="bce3.png" alt=""></p>
<p>其中有一行<code>s := spix[i : i+4 : i+4]</code>，Sebastien Binet提出一个疑问，为啥这里要设置cap? Brad Fitzpatrick就说那我移除好了，作者Ian Davis说我做了测试，感觉设置cap会给编译器提示，性能更好。大家就对这个奇怪的点展开了有趣的讨论，Ian Davis说如果改成<code>s := spix[i : i+4]</code>虽然对边界检查没有影响，但是性能会下降。Giovanni Bajo给出了正解:</p>
<blockquote>
<p>If you don&#39;t specify the cap, the compiler needs to calculate it computing newcap = oldcap - offset. If you specify it with the same value of len, it does less work.</p>
<p>翻译：如果你不指定cap，编译器需要计算新的<code>newcap = oldcap - offset</code>。如果你指定cap的值和len一样，编译器就可以少做点工作。</p>
</blockquote>
<p>Nigel Tao也指出，这行代码也可以使用<code>_ = spix[i+3]</code>代替。<br>最终这个讨论记录在<a href="https://github.com/golang/go/issues/27857" target="_blank" rel="external">#27857</a>。</p>
<p>回答SourceGraph工程师的问题：<strong>为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</strong></p>
<p>答案是为了更好的性能，而不是为了边界检查消除。</p>
<h2 id="更好的边界检查消除方法">更好的边界检查消除方法</h2>
<p>SourceGraph工程师的代码使用BCE做了优化，但是你还是看到，有两行代码还是做了边界检查，这是因为Go的BCE并不完美，有时候还是会做边界检查。</p>
<p>但是有没有办法全部消除代码的边界检查呢？老貘还是给出了一个解决方案。<br>我们先看看老貘的给出的例子(<code>f8z</code>我略有改动):<br><img src="bce4.png" alt=""></p>
<p>可以看到，Go的BCE还不是那么智能，<code>f8x</code>例子中<code>s[i+3]</code>、<code>s[i+2]</code>、s[i+1]不会越界，但是这三行还是做了边界检查。</p>
<p><code>f8y</code>例子中<code>s[3]</code>做了边界检查后，可以保证<code>s[2]</code>、<code>s[1]</code>、<code>s[0]</code>不会越界，所以这三行不用做边界检查。</p>
<p><code>f8z</code>例子中，每次循环我们都会检查s的长度是否大于4，如果大于4，<code>s[3]</code>、<code>s[2]</code>、<code>s[1]</code>、<code>s[0]</code>肯定不会越界，所以这四行不做边界检查，而且<code>s = s[4:]</code>也不会越界。这样这个实现就整体都不需要做边界检查了</p>
<p>所以SourceGraph工程师的代码可以改成下面这样:</p>
<p><img src="bce5.png" alt=""></p>
<h2 id="Go的边界检查消除技术">Go的边界检查消除技术</h2>
<p>老貘在Go101中有一章专门讲了<a href="https://go101.org/article/bounds-check-elimination.html" target="_blank" rel="external">这个问题</a>，感兴趣的同学可以直接阅读，或者购买他的电子书。</p>
<p>我想从Go实现边界检查消除的提议说起，这个提议是<a href="https://github.com/golang/go/issues/14808），由Alexandru Moșoi提出，他专门写了一篇文档[Bounds Checking Elimination](https://docs.google.com/document/d/1vdAEAjYdzjnPA9WDOQ1e4e05cYVMpqSxJYZT33Cqw2g/edit#heading=h.ywknbkyeha6d" target="_blank" rel="external">cmd/compile: unnecessary bounds checks are not removed #14808</a>。</p>
<p>当然BCE在Go的编译器中也一直做优化，原始的文档整理也不能全面反映现状，但是还是很有意义的，整理的BCE技术进行分类便于学习。我就整理翻译一下。</p>
<p>Go的边界检查有两个:索引<code>a[i]</code>和slice<code>a[i,j]</code>。Go编译器在访问这两种方式的时候会插入一些边界检查代码，但是大部分情况下是不需要的，冗余的，我们的目标就是在编译的时候去掉这些冗余的检查，这样能提供性能，检查二进制文件大小。通过<code>-gcflags=-B</code>可以禁止边界检查。</p>
<p>你可以通过<code>go build -gcflags=&quot;-d=ssa/check_bce&quot; xxx.go</code>查看哪些行进行了边界检查。</p>
<p>下面是一些进行边界检查消除的场景。</p>
<h3 id="重复检查">重复检查</h3>
<p>比如下面的代码中，重复的索引和切片访问就不做边界检查了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line">….</div><div class="line">_ = a[i] <span class="comment">// 边界检查</span></div><div class="line">_ = a[i] <span class="comment">// 重复访问，消除边界检查</span></div><div class="line">_ = a<span class="number">[2</span>*i<span class="number">+7</span>]  <span class="comment">// 边界检查</span></div><div class="line">_ = a<span class="number">[2</span>*i<span class="number">+7</span>]  <span class="comment">// 重复访问，消除边界检查</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line">….</div><div class="line">_ = a[:i]</div><div class="line">_ = a[:i] <span class="comment">// 重复访问，消除边界检查</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line">….</div><div class="line">_ = a[i:]</div><div class="line">_ = a[i:] <span class="comment">// 重复访问，消除边界检查</span></div></pre></td></tr></table></figure>

<h3 id="带掩码索引的恒定切片大小">带掩码索引的恒定切片大小</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a<span class="number">[17</span>]<span class="typename">int</span></div><div class="line">....</div><div class="line">_ = a[i<span class="number">&5</span>]   <span class="comment">// 0 &lt;= i&5 and i&5 &lt;= 5 &lt; 17 == len(a), 移除边界检查</span></div><div class="line">_ = a[i<span class="number">%5</span>]  <span class="comment">// 不能移除， 因为i可能是负数， 负数就越界了</span></div></pre></td></tr></table></figure>

<h3 id="常数索引">常数索引</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">....</div><div class="line"><span class="keyword">if</span><span class="number"> 5</span> &lt; <span class="built_in">len</span>(a) { _ = a<span class="number">[5</span>] }   <span class="comment">// 0 &lt;= 5 and 5 &lt; len(a), 移除边界检查</span></div></pre></td></tr></table></figure>

<p>这也是上一节我们完全消除边界检查的方式。</p>
<h3 id="常数索引和常数size">常数索引和常数size</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a<span class="number">[10</span>]<span class="typename">int</span></div><div class="line">....</div><div class="line">_ = a<span class="number">[5</span>]   <span class="comment">// 0 &lt;= 5 and 5 &lt; len(a) == 10,  移除边界检查</span></div></pre></td></tr></table></figure>

<h3 id="琐碎的边界检查">琐碎的边界检查</h3>
<p><code>a[i:j]</code> 会产生两个边界检查: <code>0 &lt;= i &lt;= j</code> 和 <code>0 &lt;= j &lt;= cap(a)</code>。有时候我们可以移除它们中的一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">a[i:<span class="built_in">len</span>(a)]  <span class="comment">// 第二个边界检查 0 &lt;= len(a) &lt;= cap(a) 移除了</span></div><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">a[:<span class="built_in">len</span>(a)&gt;<span class="number">&gt;1</span>] <span class="comment">// 第一个边界检查移除了 0 &lt;= 0 &lt;= len(a)&gt;&gt;1， 因为 len(a)&gt;&gt;1 &gt;= 0</span></div><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">a[:<span class="built_in">len</span>(b)] <span class="comment">// 第一个边界检查 0 &lt;= 0 &lt;= len(a) 移除了</span></div></pre></td></tr></table></figure>

<h3 id="基于循环变量的边界检查">基于循环变量的边界检查</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span>   </div><div class="line">…</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a {   <span class="comment">// 不适用于string</span></div><div class="line">  use a[i]  <span class="comment">// 移除, i 循环变量</span></div><div class="line">  use a[i:]  <span class="comment">// 移除</span></div><div class="line">  use a[:i]  <span class="comment">// 移除</span></div><div class="line">}</div><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span>   </div><div class="line">...</div><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i++ {   <span class="comment">// 也适用于string</span></div><div class="line">  use a[i]  <span class="comment">// 移除, i 循环变量</span></div><div class="line">  use a[i:]  <span class="comment">// 移除</span></div><div class="line">  use a[:i]  <span class="comment">// 移除</span></div><div class="line">}</div><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span>   </div><div class="line">…</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a {   <span class="comment">// 不适用于string</span></div><div class="line">  use a[:i<span class="number">+1</span>] <span class="comment">// 移除, i 循环变量</span></div><div class="line">  use a[i<span class="number">+1</span>:] <span class="comment">// 移除</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递减常量索引">递减常量索引</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">_ = a<span class="number">[3</span>] <span class="comment">// 一次边界检查</span></div><div class="line">use a<span class="number">[1</span>], a<span class="number">[2</span>], a<span class="number">[3</span>] <span class="comment">// 不需要边界检查</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line">a = a[<span class="number">:3</span>:<span class="built_in">len</span>(a)] <span class="comment">// 一次边界检查</span></div><div class="line">use a<span class="number">[0</span>], a<span class="number">[1</span>], a<span class="number">[2</span>] <span class="comment">// 不需要边界检查</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line">use a<span class="number">[3</span>], a<span class="number">[2</span>], a<span class="number">[1</span>] <span class="comment">// 一次边界检查</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) &gt;=<span class="number"> 3</span> {</div><div class="line">    use a<span class="number">[0</span>], a<span class="number">[1</span>], a<span class="number">[2</span>] <span class="comment">// 一次边界检查</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="不能移除的边界检查">不能移除的边界检查</h3>
<p>下面这个<code>k8x</code>中第一个<code>a[i]</code>中i可能为负数，所以不能移除，接下来的两个可以确保不越界，所以可以移除。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> k8x(a []<span class="typename">int</span>, i <span class="typename">int</span>, j <span class="typename">uint</span>) {</div><div class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) {</div><div class="line">		_ = a[i] <span class="comment">// 不能移除，因为i可能为负数</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> j &lt; <span class="typename">uint</span>(<span class="built_in">len</span>(a)) {</div><div class="line">		_ = a[j] <span class="comment">// 移除，因为 0 &lt;= j &lt; len(a)</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span><span class="number"> 0</span> &lt;= i && i &lt; <span class="built_in">len</span>(a) {</div><div class="line">		_ = a[i] <span class="comment">// 移除，因为 0 &lt;= i &lt; len(a)</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面这个<code>k8y</code>中<code>i+2</code>可能溢出，比如<code>i = math.MaxInt</code>, 所以不能移除。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> k8y(a []<span class="typename">int</span>, i <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span><span class="number"> 0</span> &lt;= i && i<span class="number">+2</span> &lt; <span class="built_in">len</span>(a) {</div><div class="line">		_ = a[i<span class="number">+2</span>] <span class="comment">// i+2 might overflow int</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>`</p>
<p>这个文档中有几处场景已经BCE已经完善了，我更正过来了，如上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在翻译的<a href="https://mp.weixin.qq.com/s/l6Tq_bVDmMpwZg_rPfi1DQ" target="_blank" rel="external">从慢速到SIMD</a>一文中， SourceGraph工程师其中的一个优化就是边界检查消除(BCE,bounds check elimination)技术，同时他也抛给了读者一个问题：</p>
<blockquote>
<p>为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</p>
</blockquote>
<p>本文第一部分先回答这个问题。 第二部分介绍更好的边界检查消除方法。 第三部分再全面梳理Go的边界检查消除技术。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些笔记工具工具以及memos介绍]]></title>
    <link href="https://colobu.com/2024/02/10/some-note-taking-tools-and-memos/"/>
    <id>https://colobu.com/2024/02/10/some-note-taking-tools-and-memos/</id>
    <published>2024-02-09T16:52:07.000Z</published>
    <updated>2024-02-20T11:11:43.123Z</updated>
    <content type="html"><![CDATA[<p>祝大家龙年大吉！</p>
<a id="more"></a>
<p>大家可能好奇我写书的时候是用什么工具？正好最近我画架构图的时候使用Excelidraw,也试用了几款其他的工具。而且这两天搭建了一个备忘录的工具，所以正好总结一下。</p>
<h2 id="写书工具">写书工具</h2>
<p>我在写书稿的时候曾经一度想使用Latex，因为它强大的排版功能几乎可以排版任何东西，而且拥有丰富的插件，输出的pdf效果也很好，但是考虑到交稿给编辑，扁编辑在审稿和校对的时候不方便，而且书稿出版社会使用自己的版式重新排版，虽然我一度整了一个Latex模板并尝试写电子书，但是最终也放弃了。</p>
<p>基本上，我写的书稿是使用Markdown的格式。Markdown的格式对于写作还是很方便的，而且不需要考虑太多的版面的问题，方便组织层次，插入图片和代码也都很方便，编译也容易导出到其他格式。</p>
<p>使用vscode 就可以编写Markdown的文本，后来我听说<a href="https://typora.io/" target="_blank" rel="external">Typora</a>，这是一个很好的Markdown编辑器，支持实时预览，而且支持导出PDF，网上都说使用方便，我也尝试了一下，也确实不错。不过自1.0版本后它开始收费了。</p>
<p>当然收费也无可厚非，毕竟开发者也需要生活，不能够纯用爱发电，对吧？ 但是我还是希望找到一个免费的工具，最终我找到了<a href="https://github.com/marktext/marktext" target="_blank" rel="external">MarkText</a>，这是一个开源的Markdown编辑器，支持实时预览，而且支持导出PDF，这是我最喜欢的一个Markdown编辑器。</p>
<p>所以我就使用MarkText平替Typora来写书稿，完成了《深入理解Go并发编程》的写作。</p>
<p>这个工具的作者还是中国的同学，非常的赞。不过目前代码活跃度不是那么高了，不过对我来说已经够用了，希望它后续能够支持插件，这样可以充分发挥网友的聪明才智，把功能丰富起来。</p>
<p><img src="marktext.png" alt=""></p>
<h2 id="笔记工具">笔记工具</h2>
<p>首先做笔记的工具很多，比如<a href="https://www.notion.so/product" target="_blank" rel="external">Notion</a>、<a href="https://keep.google.com/" target="_blank" rel="external">Google Keep</a>、<a href="https://www.yinxiang.com/" target="_blank" rel="external">Evernote（印象笔记）</a>、<a href="https://www.onenote.com/" target="_blank" rel="external">OneNote</a>、<a href="https://simplenote.com/" target="_blank" rel="external">Simplenote</a>、<a href="https://bear.app/" target="_blank" rel="external">Bear</a>、<a href="https://www.goodnotes.com/" target="_blank" rel="external">GoodNotes</a>、<a href="https://notability.com/" target="_blank" rel="external">Notability</a>等等，很多，但是很多都是收费的，而且基本是web服务，意味着你的数据都在别人的服务器上，不安全， 而且服务可用性也不可控。</p>
<p>所以我想找的是一个桌面工具，免费的，相应的笔记我通过git保存在github或者自建的git服务器上即可。</p>
<p>有两个工具值得推荐。</p>
<p>第一个是 <a href="https://obsidian.md/" target="_blank" rel="external">obsidian</a>, 这是一个免费的笔记工具，支持markdown格式，而且支持插件，可以自己写插件，而且支持本地存储，不需要联网，而且支持git，可以把笔记存储在github上.<br><img src="obsidian.png" alt=""></p>
<p>它具有以下有点：</p>
<ul>
<li>支持Markdown格式编写笔记,可读性强,也方便导出和跨平台使用。</li>
<li>采用文件系统来组织笔记,所有笔记以普通文本文件的形式存储在磁盘上,不依赖任何数据库。</li>
<li>建立笔记之间的双向链接,支持网络化思维,可以将笔记关联起来。</li>
<li>提供图形化界面,支持大纲预览、回链、未链接提醒等功能。</li>
<li>支持嵌入超链接、图片、Latex数学公式等。</li>
<li>插件丰富,支持中文分词、思维导图、时间管理等功能。</li>
<li>支持多种操作系统如Windows、Mac、Linux等。</li>
<li>提供移动版,可以在手机或平板上编辑和查看笔记。</li>
<li>支持团队协作,可搭建或加入专用服务器,实现知识共享。</li>
<li>个性化主题丰富,美观大方。</li>
</ul>
<p>第二个是 <a href="https://github.com/logseq/logseq" target="_blank" rel="external">logseq</a>,logseq是一个开源的网络化个人知识管理和协作工具,具有以下主要特点:<br><img src="logseq.webp" alt=""></p>
<ul>
<li>支持双向链接,所有块(页面和段落)之间可以相互引用,形成一个网络化的知识库。</li>
<li>基于Graph数据结构,支持视图分析、回链和未链接提示等功能。</li>
<li>页面和块支持无限嵌套,可以把知识点进行自由组合。</li>
<li>支持代码块、TeX数学公式等语法高亮。</li>
<li>可以创建Markdown和OrgMode多种格式的页面。</li>
<li>支持同时编辑,实时预览编辑内容。</li>
<li>支持跨平台编辑。</li>
<li>插件系统强大,可以扩展更多功能。</li>
<li>界面简洁优雅,支持日夜两种主题模式。</li>
</ul>
<p>我在Mac上安装Logseq后发现它的功能虽然强大，插件更丰富，但是弹出的对话框不能关闭，后台启动多个进程，占用资源比较大，反应迟钝，这可能是它基于Electron开发的原因，所以我最后卸载了。</p>
<p>其实这两个工具在我的日常生活中都没有使用，我就使用苹果的备忘录，便捷，在多个苹果设备上可以互通。不好的地方在于它过于简单了。</p>
<h2 id="画图工具">画图工具</h2>
<p>其实我之所以考察obsidian和logseq，是因为我最近在画几个技术相关的架构图或者插图。先前较多使用<a href="https://app.diagrams.net/" target="_blank" rel="external">draw.io</a>，这是一个免费的在线画图工具，支持多种图形，而且支持导出多种格式，而且支持保存到本地。不过看看到网上其他同学的架构图图画的都挺好，使用<a href="https://excalidraw.com/" target="_blank" rel="external">excalidraw</a>画的，有手工画图的风格，非常的漂亮，所以我尝试使用excalidraw画图。</p>
<p>excalidraw默认就配置了三种字体：手写、正常和代码字体。对于我们来说，我们希望对于中文，能够使用一款漂亮的字体做渲染，但是excalidraw官方的网站不支持，有些人通过浏览器插件等方式把其中的字体做替换来达到目的，过于麻烦。</p>
<p>我搜了一下网上的教程，说obsidian很好的支持了excalidraw插件，可以配置自己的字体作为第四种可选择的字体，这就非常好了。</p>
<p>你可以选择一款自己喜欢的字体，放在<code>Obsidian Vault/Excalidraw/font</code>中，我选择了“沐瑶随心手写体”，这是一款免费且好看的中文字体，然后在obsidian的设置中配置excalidraw插件，就可以选择这个字体了。<br><img src="excalidraw.png" alt=""></p>
<p>然后我就可以使用excalidraw画图了，可以看到<code>Font family</code>中多了一个字体选项，这就是我配置的字体。<br><img src="excalidraw2.png" alt=""></p>
<p>obsidian也支持了excalidraw的脚本，这极大的丰富了excalidraw的功能，可以画出更加复杂的图形。而且excalidraw插件也支持资源库，我上面图中的gopher就是使用的资源库中的资源。</p>
<p>现在看起来 obsidian + excalidraw插件可以很好的满足我的需求了。</p>
<h2 id="备忘录工具">备忘录工具</h2>
<p>前面提到，我基本使用苹果的备忘录，但是它的功能太简单了，而且不支持markdown格式，所以我想找一个支持markdown格式的备忘录工具，最好是web方式的，这样我在电脑、平板和手机上都可以自如的编写备忘录了。</p>
<p>经常我脑海中会蹦出一点火花，可能是一个新的项目想法，可能是一个新的技术点，可能是一个新的文章的思路，也可能是一本书的大纲，我书包中常备着一个小本子，当这些想法闪现的时候，我都会拿出本子记录下来。但是经常在一些时候，比如外出的时候，或者半夜有想法失眠的时候，本子不在身边，我生怕这些稍纵即逝的想法就这样消失了。所以如果有一个随时随地的备忘录工具就好了，不仅限于苹果系统。</p>
<p>其实上面笔记工具提到的google keep就挺好，但是有时候访问Google并不是那么方便，而且基于Goole历来的表现，说不定哪一天就把这个产品关闭了。<br>不过这个工具确实好， 支持代办列表、图片，甚至可以绘图。<br><img src="keep.png" alt=""></p>
<p>当然，类似的备忘录工具有很多，比如<a href="https://www.zhihu.com/question/21291418" target="_blank" rel="external">这篇知乎文章</a>介绍的。</p>
<p>这两天，我看到了一款非常简洁但是功能有很丰富的备忘录工具，支持自己搭建，我就自己搭建了一个。</p>
<p>这款备忘录工具就是<a href="https://github.com/usememos/memos" target="_blank" rel="external">memos</a>, 你可以访问它的示例网站进行试用，示例网站地址是: <a href="https://demo.usememos.com/" target="_blank" rel="external">https://demo.usememos.com/</a>。<br><img src="memos.png" alt=""></p>
<p><code>usememos/memos</code>是一个开源的轻量级便签服务,可以让用户轻松捕获和分享想法。它的主要特点包括:</p>
<ul>
<li>开源 - usememos在GitHub上以MIT许可证开源,代码公开透明。</li>
<li>轻量级 - 简单注册就可以使用,用户可以快速创建和组织便签。</li>
<li>多租户 - 支持多用户注册,每个用户都有自己的私有空间。也可以创建公共空间,共享便签。</li>
<li>Markdown支持 - 支持Markdown格式,可以格式化便签文本。</li>
<li>快速搜索 - 可以快速搜索并过滤便签。</li>
<li>分享和协作 - 可以分享便签链接到不同平台,也可以与其他人协作编辑。</li>
<li>多种主题 - 提供多种主题选择,用户可以自定义外观。</li>
<li>数据备份 - 数据可以导出为JSON文件,方便备份。</li>
<li>响应式设计 - 可以在移动设备和桌面端流畅使用。</li>
<li>简洁易用 - 界面简洁,使用非常容易上手。</li>
</ul>
<p>最重要的一点，你可以自己通过docker或者直接编译源码来搭建自己的备忘录服务，这样你的数据就不会存储在别人的服务器上，安全性更高。而且可以一键部署，安装简单。</p>
<p>不但安装简单，而且使用也非常简单，你可以在网站上注册一个账号，然后就可以使用了。<br>初始第一个用户是管理员，你可以设置是否允许其他用户注册等，控制这个应用你自己使用还是当成平台共享。</p>
<p>我在自己的服务器上部署了这个程序，并设置了相应的域名 <a href="https://memos.rpcx.io" target="_blank" rel="external">https://memos.rpcx.io</a> , 目前仅限于我自己使用。而且我手机上利用浏览器的功能，创建了一个桌面快捷键，直接点击桌面图标就可以进入，类似桌面APP的效果。</p>
<p>因为memos是开源的，我也进行了相应的修改，比如图标换成我微信的图标， 备忘录的字体也换成了“沐瑶随心手写体”，更有趣一些。汉化了一些不彻底的地方。</p>
<p><img src="memos2.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>祝大家龙年大吉！</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言中的Pinner.Pin]]></title>
    <link href="https://colobu.com/2024/02/02/Pinner-Pin/"/>
    <id>https://colobu.com/2024/02/02/Pinner-Pin/</id>
    <published>2024-02-02T07:56:36.000Z</published>
    <updated>2024-02-02T08:02:16.858Z</updated>
    <content type="html"><![CDATA[<p><a href="https://pkg.go.dev/runtime#Pinner" target="_blank" rel="external">runtime.Pinner</a> 是 Go 1.21.0 中引入的一个类型。</p>
<p><code>Pinner</code>是一组固定的 Go 对象。可以使用 <code>Pin</code> 方法来固定一个对象。<code>Pinner</code>固定的所有对象都可以使用 <code>Unpin</code> 方法解开固定。</p>
<a id="more"></a>
<h3 id="简介">简介</h3>
<p><code>Pinner.Pin</code> 是 Go 语言中用于防止对象被垃圾回收器回收的函数。它接受一个指针参数，并将该指针指向的内存区域标记为不可移动。这意味着，即使该对象不再被任何变量引用，它也不会被回收，直到调用 <code>Pinner.Unpin</code> 函数将其取消固定。</p>
<h3 id="使用场景">使用场景</h3>
<p><code>Pinner.Pin</code> 通常用于以下场景：</p>
<ul>
<li>在与 C 代码互操作时，需要将 Go 对象传递给 C 函数。</li>
<li>在需要确保对象在某个时间段内保持有效的场景中，例如，在进行 I/O 操作或计算密集型操作时。</li>
</ul>
<h3 id="示例">示例</h3>
<p>以下示例演示了如何使用 <code>Pinner.Pin</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"runtime"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 创建一个新的 `[]byte` 数组</span></div><div class="line">    data := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 10</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 将数组固定</span></div><div class="line">    p := runtime.Pinner.Pin(data)</div><div class="line"></div><div class="line">    <span class="comment">// 对数组进行一些操作</span></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> data {</div><div class="line">        data[i] = <span class="typename">byte</span>(i)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 取消固定数组</span></div><div class="line">    p.Unpin()</div><div class="line"></div><div class="line">    <span class="comment">// 打印数组内容</span></div><div class="line">    fmt.Println(data)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="注意事项">注意事项</h3>
<ul>
<li>只能对以下类型的对象调用 <code>Pinner.Pin</code> 函数：<ul>
<li>通过 <code>new</code> 函数创建的对象</li>
<li>复合字面量的地址</li>
<li>局部变量的地址</li>
</ul>
</li>
<li>如果对非法的对象调用 <code>Pinner.Pin</code> 函数，会导致程序崩溃。</li>
<li>在调用 <code>Pinner.Unpin</code> 函数之前，必须确保不再使用该对象，否则会导致程序运行时错误</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://pkg.go.dev/runtime#Pinner" target="_blank" rel="external">runtime.Pinner</a> 是 Go 1.21.0 中引入的一个类型。</p>
<p><code>Pinner</code>是一组固定的 Go 对象。可以使用 <code>Pin</code> 方法来固定一个对象。<code>Pinner</code>固定的所有对象都可以使用 <code>Unpin</code> 方法解开固定。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[十亿行的挑战]]></title>
    <link href="https://colobu.com/2024/01/30/one-billion-row-challenge/"/>
    <id>https://colobu.com/2024/01/30/one-billion-row-challenge/</id>
    <published>2024-01-30T14:40:26.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>国外的程序员休完他们的假期之后在玩什么？他们在玩十亿行的代码挑战。</p>
<a id="more"></a>
<p>工程师贡纳尔·莫林在元旦发起一个<a href="https://www.morling.dev/blog/one-billion-row-challenge/" target="_blank" rel="external">挑战</a>(1BRC),挑战从 1 月 1 日持续到 1 月 31 日。</p>
<p>如果你决定接受它，你的任务看似简单： <strong>编写一个 Java 程序，用于从文本文件中检索温度测量值并计算每个气象站的最小、平均值和最高温度。</strong><br>只有一点需要注意：文件有 <strong>1,000,000,000 行</strong>！（1 billion， 10亿行)。</p>
<p>这个文本文件结构简单，每行一个测量值, 气象站和它的测量温度：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">Hamburg</span>;<span class="number">12.0</span></div><div class="line"><span class="variable">Bulawayo</span>;<span class="number">8.9</span></div><div class="line"><span class="variable">Palembang</span>;<span class="number">38.8</span></div><div class="line"><span class="variable">St</span>. <span class="variable">John</span>'s;<span class="number">15.2</span></div><div class="line"><span class="variable">Cracow</span>;<span class="number">12.6</span></div><div class="line">...</div></pre></td></tr></table></figure>

<p>程序应打印出每个站的最小值、平均值和最大值，按字母顺序排列，如下所示：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{Abha=<span class="number">5.0</span>/<span class="number">18.0</span>/<span class="number">27.4</span>, Abidjan=<span class="number">15.7</span>/<span class="number">26.0</span>/<span class="number">34.1</span>, Abéché=<span class="number">12.1</span>/<span class="number">29.4</span>/<span class="number">35.6</span>, Accra=<span class="number">14.7</span>/<span class="number">26.4</span>/<span class="number">33.1</span>, Addis Ababa=<span class="number">2.1</span>/<span class="number">16.0</span>/<span class="number">24.3</span>, Adelaide=<span class="number">4.1</span>/<span class="number">17.3</span>/<span class="number">29.7</span>, <span class="keyword">...</span>}</div></pre></td></tr></table></figure>

<p>1BRC挑战的目标是为这项任务创建最快的实现， 在这样做的同时，探索现代 Java 的好处，并找出你可以将这个平台推向多远。 因此，使用所有的（虚拟）线程，利用 Vector API 和 SIMD，优化你的 GC，利用 AOT 编译，或者使用你能想到的任何其他技巧。</p>
<p>没想到莫林提出这个挑战后，一下子火了，在多个平台上都进行了热烈的讨论：<a href="https://news.ycombinator.com/item?id=38851337" target="_blank" rel="external">Hacker News</a>、<a href="https://lobste.rs/s/u2qcnf/one_billion_row_challenge" target="_blank" rel="external">lobste.rs</a>、<a href="https://old.reddit.com/r/programming/comments/18x0x0u/the_one_billion_row_challenge/" target="_blank" rel="external">Reddit</a>。</p>
<p>而且，实现也不再仅限于Java,其他编程语言甚至数据库都有<a href="https://github.com/gunnarmorling/1brc/discussions" target="_blank" rel="external">实现</a>。</p>
<p>在32 core AMD EPYC™ 7502P (Zen2), 128 GB RAM的服务器上，使用8个核，优化的Java程序在使用GraalVM native binary情况下已经跑到了1秒多。在我的Mac M2 mini上可以跑到16.42秒。</p>
<p>我们关注一下Go语言的实现。</p>
<p>一个简单的中规中矩的Go语言实现是<a href="https://github.com/mr-karan/1brc-go" target="_blank" rel="external">mr-karan/1brc-go</a>, 在我的Mac M2 mini机器可以跑到26.66秒。<br>作者专门写了一篇文章介绍优化的<a href="https://mrkaran.dev/posts/1brc/" target="_blank" rel="external">步骤</a>:</p>
<ul>
<li>使用生产者和消费者模式</li>
<li>批处理文本行</li>
<li>减少内存分配</li>
<li>成块读取文本</li>
</ul>
<p>另一个Go语言的实现是<a href="https://github.com/shraddhaag/1brc" target="_blank" rel="external">shraddhaag/1brc</a>, 他把他的优化步骤都在README中列出来了，在我的Mac M2 mini机器可以跑到23.73秒。</p>
<table>
<thead>
<tr>
<th>Attempt Number</th>
<th>Approach</th>
<th>Execution Time</th>
<th>Diff</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Naive Implementation: Read temperatures into a map of cities. Iterate serially over each key (city) in map to find min, max and average temperatures.</td>
<td>6:13.15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>Evaluate each city in map concurrently using goroutines.</td>
<td>4:32.80</td>
<td>-100.35</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/8bd5f437e8cc231e3ee18348b83f4dc694137546" target="_blank" rel="external">8bd5f43</a></td>
</tr>
<tr>
<td>2</td>
<td>Remove sorting float64 slices. Calculate min, max and average by iterating.</td>
<td>4:25.59</td>
<td>-7.21</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/830e5dfacff9fb7a41d12027e21399736bc34701" target="_blank" rel="external">830e5df</a></td>
</tr>
<tr>
<td>3</td>
<td>Decouple reading and processing of file content. A buffered goroutine is used to communicate between the two processes.</td>
<td>5:22.83</td>
<td>+57.24</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/2babf7dda72d92c72722b220b8b663e747075bd7" target="_blank" rel="external">2babf7d</a></td>
</tr>
<tr>
<td>4</td>
<td>Instead of sending each line to the channel, now sending 100 lines chunked together. Also, to minimise garbage collection, not freeing up memory when resetting a slice.</td>
<td>3:41.76</td>
<td>-161.07</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/b7b1781f58fd258a06940bd6c05eb404c8a14af6" target="_blank" rel="external">b7b1781</a></td>
</tr>
<tr>
<td>5</td>
<td>Read file in chunks of 100 MB instead of reading line by line.</td>
<td>3:32.62</td>
<td>-9.14</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/c26fea40019552a7e4fc1c864236f433b1b686f0" target="_blank" rel="external">c26fea4</a></td>
</tr>
<tr>
<td>6</td>
<td>Convert temperature from <code>string</code> to <code>int64</code>, process in <code>int64</code> and convert to <code>float64</code> at the end.</td>
<td>2:51.50</td>
<td>-41.14</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/7812da4d0be07dd4686d5f9b9df1e93b08cd0dd1" target="_blank" rel="external">7812da4</a></td>
</tr>
<tr>
<td>7</td>
<td>In the city &lt;&gt; temperatures map, replaced the value for each key (city) to preprocessed min, max, count and sum of all temperatures instead of storing all recorded temperatures for the city.</td>
<td>1:39.81</td>
<td>-71.79</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/e5213a836b17bec0a858474a11f07c902e724bba" target="_blank" rel="external">e5213a8</a></td>
</tr>
<tr>
<td>8</td>
<td>Use producer consumer pattern to read file in chunks and process the chunks in parallel.</td>
<td>1:43.82</td>
<td>+14.01</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/067f2a44c0d6b3bb7cc073639364f733bce09e3e" target="_blank" rel="external">067f2a4</a></td>
</tr>
<tr>
<td>9</td>
<td>Reduce memory allocation by processing each read chunk into a map. Result channel now can collate the smaller processed chunk maps.</td>
<td>0:28.544</td>
<td>-75.286</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/d4153ac7a841170a5ceee47d930e97738b5a19f6" target="_blank" rel="external">d4153ac</a></td>
</tr>
<tr>
<td>10</td>
<td>Avoid string concatenation overhead by not reading the decimal point when processing city temperature.</td>
<td>0:24.571</td>
<td>-3.973</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/90f2fe121f454f3f1b5cdaeaaebe639bb86d4578" target="_blank" rel="external">90f2fe1</a></td>
</tr>
<tr>
<td>11</td>
<td>Convert byte slice to string directly instead of using a <code>strings.Builder</code>.</td>
<td>0:18.910</td>
<td>-5.761</td>
</tr>
</tbody>
</table>
<p>然后我们再看一个已经merge到官方库的Go语言实现，在我的Mac M2 mini机器可以跑到17.79秒，相当不错了。<br>他的代码在<a href="https://github.com/gunnarmorling/1brc/tree/main/src/main/go/AlexanderYastrebov" target="_blank" rel="external">这里</a>,他也做了很多的优化，比如使用mmap。</p>
<p>这几个代码都是值得学习和研究的，我们不能说他们做了最好的优化，但是确实都是花了不少功夫的。</p>
<p>几个rust的实现也是值得学习的。在我的Mac M2 mini机器的跑分：</p>
<ul>
<li><a href="https://github.com/tumdum/1brc" target="_blank" rel="external">tumdum/1brc</a>: 18.72秒</li>
<li><a href="https://github.com/mtb0x1/1brc" target="_blank" rel="external">mtb0x1/1brc</a>: 18.93秒</li>
<li><a href="https://github.com/coriolinus/1brc" target="_blank" rel="external">coriolinus/1brc</a>：18.87秒</li>
<li><a href="https://github.com/thebracket/one_billion_rows" target="_blank" rel="external">thebracket/one_billion_rows</a>: 16.04秒， 使用了mmap</li>
<li><a href="https://github.com/arthurlm/one-brc-rs" target="_blank" rel="external">arthurlm/one-brc-rs</a>: 17.33秒</li>
</ul>
<p>一个C语言的实现：</p>
<ul>
<li><a href="https://github.com/dannyvankooten/1brc" target="_blank" rel="external">dannyvankooten/1brc</a>: 17.72秒</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>国外的程序员休完他们的假期之后在玩什么？他们在玩十亿行的代码挑战。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从慢速到SIMD: 一个Go优化的故事]]></title>
    <link href="https://colobu.com/2024/01/28/slow-to-simd/"/>
    <id>https://colobu.com/2024/01/28/slow-to-simd/</id>
    <published>2024-01-28T08:21:41.000Z</published>
    <updated>2024-02-02T07:54:29.800Z</updated>
    <content type="html"><![CDATA[<p>SourceGraph 的工程师 Camden Cheek 提供的一个利用SIMD进行Go性能优化的故事:<a href="https://sourcegraph.com/blog/slow-to-simd" target="_blank" rel="external">From slow to SIMD: A Go optimization story</a>。</p>
<a id="more"></a>
<p>这是一个关于某函数的故事，这个函数被大量调用，而且这些调用都在关键路径上。让我们来看看如何让它变快。</p>
<p>剧透一下，这个函数是一个点积函数。</p>
<blockquote>
<p>点积（Dot Product），也称为内积或数量积，是一种数学运算，通常用于计算两个向量之间的乘积。点积的结果是一个标量（即一个实数），而不是一个向量。</p>
<p>假设有两个向量：<br>$$\mathbf{a}=\begin{bmatrix}a_1\\a_2\\\vdots\\a_n\end{bmatrix}$$<br>$$\mathbf{b}=\begin{bmatrix}b_1\\b_2\\\vdots\\b_n\end{bmatrix}$$</p>
<p>那么，这两个向量的点积为：<br>$$\mathbf{a}\cdot\mathbf{b}=\sum_{i=1}^n a_ib_i=a_1b_1+a_2b_2+\cdots+a_nb_n$$</p>
</blockquote>
<h2 id="一些背景">一些背景</h2>
<p>在 Sourcegraph，我们正在开发一个名为 Cody 的 Code AI 工具。为了让 Cody 能够很好地回答问题，我们需要给它足够的上下文。我们做的一种方式是利用<a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="external">嵌入</a>(<code>embedding</code>)。</p>
<p>为了我们的目的，嵌入是文本块的向量表示。它们用某种方式构建，以便语义上相似的文本块具有更相似的向量。当 Cody 需要更多信息来回答查询时，我们在嵌入上运行相似性搜索，以获取一组相关的代码块，并将这些结果提供给 Cody，以提高结果的相关性。</p>
<p>和这篇文章相关的部分是<code>相似度度量</code>，它是一个函数，用于判断两个向量有多相似。对于相似性搜索，常见的度量是<a href="https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="external">余弦相似度</a>。然而，对于归一化向量（单位幅度的向量），点积产生的排名与余弦相似度是等价的。为了运行一次搜索，我们计算数据集中每个嵌入的点积，并保留前几个结果。由于我们在得到必要的上下文之前无法开始执行 LLM，因此优化这一步至关重要。</p>
<p>你可能会想：为什么不使用索引向量数据库？除了添加我们需要管理的另一个基础设施外，索引的构建会增加延迟并增加资源需求。此外，标准的最近邻索引只提供近似检索，这与更易于解释的穷举搜索相比，增加了另一层模糊性。鉴于这一点，我们决定在我们的手工解决方案中投入一点精力，看看我们能走多远。</p>
<h2 id="目标">目标</h2>
<p>下面的代码是一个计算两个向量点积的简单的Go函数实现。我的目标是刻画出我为优化这个函数所采取的方法，并分享我在这个过程中学到的一些工具。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotNaive(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a) && i &lt; <span class="built_in">len</span>(b); i++ {</div><div class="line">		sum += a[i] * b[i]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除非另有说明，否则所有基准都在 <code>Intel Xeon Platinum 8481C 2.70GHz CPU</code> 上运行。这是一个 <code>c3-highcpu-44</code> GCE VM。本博客文章中的代码都可以在<a href="https://github.com/camdencheek/simd_blog" target="_blank" rel="external">这里</a>找到。</p>
<h2 id="循环展开_(Loop_unrolling)">循环展开 (Loop unrolling)</h2>
<p>现代的CPU都有一个叫做<a href="https://chadaustin.me/2009/02/latency-vs-throughput/" target="_blank" rel="external">指令流水线</a>的东西，它可以同时运行多条指令，如果它们之间没有数据依赖的话。数据依赖只是意味着一个指令的输入取决于另一个指令的输出。</p>
<p>在我们的简单实现中，我们的循环迭代之间有数据依赖。实际上，每个迭代都有一个读/写对，这意味着一个迭代不能开始执行，直到前一个迭代完成。</p>
<p>一个常见的方法是在循环中展开一些迭代，这样我们就可以在没有数据依赖的情况下执行更多的指令。此外，它将固定的循环开销（增量和比较）分摊到多个操作中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotUnroll4(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		s0 := a[i] * b[i]</div><div class="line">		s1 := a[i<span class="number">+1</span>] * b[i<span class="number">+1</span>]</div><div class="line">		s2 := a[i<span class="number">+2</span>] * b[i<span class="number">+2</span>]</div><div class="line">		s3 := a[i<span class="number">+3</span>] * b[i<span class="number">+3</span>]</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我们的展开代码中，乘法指令的依赖关系被移除了，这使得CPU可以更好地利用流水线。这使我们的吞吐量比我们的简单实现提高了37%。<br><img src="slow-to-simd1.png" alt=""></p>
<p>注意，我们实际上可以通过调整我们展开的迭代次数来进一步提高性能。在基准机器上，8似乎是最佳的，但在我的笔记本电脑上，4的性能最好。然而，改进是与平台相关的，而且改进相当微小，所以在本文的其余部分，我将使用4个展开深度来提高可读性。</p>
<h2 id="边界检查消除_(Bounds-checking_elimination)">边界检查消除 (Bounds-checking elimination)</h2>
<p>为了防止越界的切片访问成为安全漏洞（如著名的 <a href="https://en.wikipedia.org/wiki/Heartbleed" target="_blank" rel="external">Heartbleed 漏洞</a>），go 编译器在每次读取之前插入检查。你可以在生成的汇编中<a href="https://go.godbolt.org/z/qT3M7nPGf" target="_blank" rel="external">查看</a>它（查找 runtime.panic）。</p>
<p>编译的代码看起来像我们写了这样的东西：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotUnroll4(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s0 := a[i] * b[i]</div><div class="line">        <span class="keyword">if</span> i<span class="number">+1</span> &gt;= <span class="built_in">cap</span>(a) || i<span class="number">+1</span> &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s1 := a[i<span class="number">+1</span>] * b[i<span class="number">+1</span>]</div><div class="line">        <span class="keyword">if</span> i<span class="number">+2</span> &gt;= <span class="built_in">cap</span>(a) || i<span class="number">+2</span> &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s2 := a[i<span class="number">+2</span>] * b[i<span class="number">+2</span>]</div><div class="line">        <span class="keyword">if</span> i<span class="number">+3</span> &gt;= <span class="built_in">cap</span>(a) || i<span class="number">+3</span> &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s3 := a[i<span class="number">+3</span>] * b[i<span class="number">+3</span>]</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在像这样的频繁调用循环(hot loop)中，即使是现代的分支预测，每次迭代的额外分支也会增加相当大的性能损失。这在我们的例子中尤其明显，因为插入的跳转限制了我们可以利用流水线的程度。</p>
<p>如果我们可以告诉编译器这些读取永远不会越界，它就不会插入这些运行时检查。这种技术被称为“边界检查消除”，相同的模式也适用于Go之外的语言。</p>
<p>理论上，我们应该能够在循环之外做所有的检查，编译器就能够确定所有的切片索引都是安全的。然而，我找不到正确的检查组合来说服编译器我所做的是安全的。我最终选择了断言长度相等的组合，并将所有的边界检查移到循环的顶部。这足以接近无边界检查版本的速度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotBCE(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slices must have equal lengths"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)<span class="number">%4</span> !=<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slice length must be multiple of 4"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		aTmp := a[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		bTmp := b[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		s0 := aTmp<span class="number">[0</span>] * bTmp<span class="number">[0</span>]</div><div class="line">		s1 := aTmp<span class="number">[1</span>] * bTmp<span class="number">[1</span>]</div><div class="line">		s2 := aTmp<span class="number">[2</span>] * bTmp<span class="number">[2</span>]</div><div class="line">		s3 := aTmp<span class="number">[3</span>] * bTmp<span class="number">[3</span>]</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个边界检查的最小化使我们的性能提高了 9%。但是始终未将检查降到零，没有什么值得一提的。<br><img src="slow-to-simd2.png" alt=""></p>
<p>这个技术对于内存安全的编程语言来说是非常有用的，比如Rust。</p>
<p>一个问题抛给读者： 为什么我们要像<code>a[i:i+4:i+4]</code>这样切片，而不是只是<code>a[i:i+4]</code>？</p>
<h2 id="量化_(Quantization)">量化 (Quantization)</h2>
<p>目前我们已经提高了单核的搜索的吞吐率50%以上，但现在我们遇到了一个新的瓶颈：内存使用。我们的向量是<strong>1536</strong>维的。用4字节的元素，这就是每个向量<strong>6KiB</strong>，我们每GiB代码生成大约一百万个向量。这很快就积累起来了。我们有一些客户带着一些大型的<code>monorepo</code>来找我们，我们想减少我们的内存使用，这样我们就可以更便宜地支持这些大型代码库。</p>
<p>一个可能的缓解措施是将向量移动到磁盘上，但是在搜索时从磁盘加载它们可能会增加显著的延迟，特别是在慢速磁盘上。相反，我们选择用<strong>int8</strong>量化我们的向量。</p>
<p>有很多方式可以压缩向量，但我们将讨论整数量化，这是相对简单但有效的。这个想法是通过将<strong>4字节</strong>的<code>float32</code>向量元素转换为<strong>1字节</strong>的<code>int8</code>来减少精度。</p>
<p>我不会深入讨论我们如何在<code>float32</code>和<code>int8</code>之间进行转换,因为这是一个相当深奥的<a href="https://huggingface.co/docs/optimum/concept_guides/quantization" target="_blank" rel="external">话题</a>,但可以说我们的函数现在看起来像下面这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotInt8BCE(a, b []<span class="typename">int8</span>) <span class="typename">int32</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slices must have equal lengths"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">	sum := <span class="typename">int32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		aTmp := a[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		bTmp := b[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		s0 := <span class="typename">int32</span>(aTmp<span class="number">[0</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[0</span>])</div><div class="line">		s1 := <span class="typename">int32</span>(aTmp<span class="number">[1</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[1</span>])</div><div class="line">		s2 := <span class="typename">int32</span>(aTmp<span class="number">[2</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[2</span>])</div><div class="line">		s3 := <span class="typename">int32</span>(aTmp<span class="number">[3</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[3</span>])</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个改变导致内存使用量减少了4倍，但牺牲了一些准确性（我们进行了仔细的测量，但这与本博客文章无关）。</p>
<p>不幸的是，这个改变导致我们的性能下降了。查看产生的汇编代码(<code>go tool compile -S</code>),我们可以看到一些<code>int8</code>到<code>int32</code>转换的指令，这可能解释了差异。我没有深入研究，因为我们在下一节中的所有性能改进都变得无关紧要了。</p>
<p><img src="slow-to-simd3.png" alt=""></p>
<h2 id="SIMD">SIMD</h2>
<p>到目前为止，速度提升还不错，但对于我们最大的客户来说，还不够。所以我们开始尝试一些更激进的方法。</p>
<p>我总是喜欢找借口来玩SIMD。而这个问题似乎正好对症下药。</p>
<p>对于还不熟悉SIMD的同学来说，SIMD代表“单指令多数据”(<code>Single Instruction Multiple Data</code>)。就像它说的那样，它允许你用一条指令在一堆数据上运行一个操作。举个例子，要对两个<code>int32</code>向量逐元素相加，我们可以用<code>ADD</code>指令一个一个地加起来，或者我们可以用<code>VPADDD</code>指令一次加上64对，延迟相同（取决于架构）。</p>
<p>但是我们还是有点问题。Go不像C或Rust那样暴露SIMD内部函数。我们有两个选择：用C写，然后用Cgo，或者用Go的汇编器手写。我尽量避免使用Cgo，因为有很多原因，这些原因都不是根本原因，但其中一个原因是Cgo会带来性能损失，而这个片段的性能是至关重要的。此外，用汇编写一些东西听起来很有趣，所以我就这么做了。</p>
<p>我想要这个这个算法可以输出到其他编程语言，所以我限制自己只使用AVX2指令，这些指令在大多数x86_64服务器CPU上都支持。我们可以使用运行时进行<a href="https://sourcegraph.com/github.com/sourcegraph/sourcegraph@3ac2170c6523dd074835919a1804f197cf86e451/-/blob/internal/embeddings/dot_amd64.go?L17-21" target="_blank" rel="external">检测</a>，在纯Go中回退到一个更慢的选项。</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line">TEXT ·DotAVX2(SB), <span class="preprocessor">NOSPLIT</span>, <span class="number">$0</span>-<span class="number">52</span></div><div class="line">	// Offsets based on slice header offsets.</div><div class="line">	// To check, use <span class="string">`GOARCH=amd64 go vet`</span></div><div class="line">	<span class="keyword">MOVQ</span> a_base+<span class="number">0</span>(FP), <span class="number">AX</span></div><div class="line">	<span class="keyword">MOVQ</span> b_base+<span class="number">24</span>(FP), <span class="number">BX</span></div><div class="line">	<span class="keyword">MOVQ</span> a_len+<span class="number">8</span>(FP), <span class="number">DX</span></div><div class="line">	XORQ <span class="literal">R8</span>, <span class="literal">R8</span> // return sum</div><div class="line">	// <span class="preprocessor">Zero</span> Y0, which will store <span class="number">8</span> packed <span class="number">32</span>-bit sums</div><div class="line">	<span class="keyword">VPXOR</span> Y0, Y0, Y0</div><div class="line">// <span class="keyword">In</span> blockloop, we calculate the dot product <span class="number">16</span> <span class="preprocessor">at</span> a time</div><div class="line"><span class="label">blockloop:</span></div><div class="line">	CMPQ <span class="number">DX</span>, <span class="number">$16</span></div><div class="line">	<span class="keyword">JB</span> reduce</div><div class="line">	// Sign-extend <span class="number">16</span> bytes <span class="keyword">into</span> <span class="number">16</span> int16s</div><div class="line">	<span class="keyword">VPMOVSXBW</span> (<span class="number">AX</span>), Y1</div><div class="line">	<span class="keyword">VPMOVSXBW</span> (<span class="number">BX</span>), Y2</div><div class="line">	// Multiply words vertically to form doubleword intermediates,</div><div class="line">	// then <span class="keyword">add</span> adjacent doublewords.</div><div class="line">	<span class="keyword">VPMADDWD</span> Y1, Y2, Y1</div><div class="line">	// <span class="keyword">Add</span> results to the running sum</div><div class="line">	<span class="keyword">VPADDD</span> Y0, Y1, Y0</div><div class="line">	ADDQ <span class="number">$16</span>, <span class="number">AX</span></div><div class="line">	ADDQ <span class="number">$16</span>, <span class="number">BX</span></div><div class="line">	SUBQ <span class="number">$16</span>, <span class="number">DX</span></div><div class="line">	<span class="keyword">JMP</span> blockloop</div><div class="line"><span class="label">reduce:</span></div><div class="line">	// X0 is the low <span class="built_in">bits</span> of Y0.</div><div class="line">	// Extract the high <span class="built_in">bits</span> <span class="keyword">into</span> X1, fold <span class="keyword">in</span> half, <span class="keyword">add</span>, repeat.</div><div class="line">	<span class="keyword">VEXTRACTI128</span> <span class="number">$1</span>, Y0, X1</div><div class="line">	<span class="keyword">VPADDD</span> X0, X1, X0</div><div class="line">	<span class="keyword">VPSRLDQ</span> <span class="number">$8</span>, X0, X1</div><div class="line">	<span class="keyword">VPADDD</span> X0, X1, X0</div><div class="line">	<span class="keyword">VPSRLDQ</span> <span class="number">$4</span>, X0, X1</div><div class="line">	<span class="keyword">VPADDD</span> X0, X1, X0</div><div class="line">	// Store the reduced sum</div><div class="line">	<span class="keyword">VMOVD</span> X0, <span class="literal">R8</span></div><div class="line"><span class="label">end:</span></div><div class="line">	MOVL <span class="literal">R8</span>, <span class="keyword">ret</span>+<span class="number">48</span>(FP)</div><div class="line">	<span class="keyword">VZEROALL</span></div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

<p>这个实现的核心循环依赖于三条主要指令：</p>
<ul>
<li><strong>VPMOVSXBW</strong>：将一个<code>int8</code>加载到一个<code>int16</code>向量中</li>
<li><strong>VPMADDWD</strong>：将两个<code>int16</code>向量逐个元素相乘,然后将相邻的两对模糊堆叠相加,生成一个 <code>int32</code> 向量。</li>
<li><strong>VPADDD</strong>：这将生成的 int32 向量累积到我们的运行总和</li>
</ul>
<p><code>VPMADDWD</code> 在这里是真正的主力军。通过将乘法和加法步骤合并为一个步骤，它不仅节省了指令，还帮助我们避免了溢出问题，同时将结果扩展为 <code>int32</code>。</p>
<p>让我们看看这给我们带来了什么。<br><img src="slow-to-simd4.png" alt=""></p>
<p>哇，这是我们之前最好表现的 530% 的增加！SIMD 胜利了 🚀。</p>
<p>现在，情况并非一帆风顺。在 Go 中手写汇编是有点奇怪的。它使用自定义的汇编器，这意味着它的汇编语言看起来与您通常在网上找到的汇编片段相比，会有略微不同而令人困惑。它有一些奇怪的怪癖，比如改变指令操作数的顺序或者使用不同的指令名称。在 Go 汇编器中，有些指令甚至没有名称，只能通过它们的二进制编码来使用。不得不说一句：我发现 sourcegraph.com 对于查找 Go 汇编示例非常有价值，可以供参考。</p>
<p>话虽如此，与 Cgo 相比，还是有一些不错的好处。调试仍然很好用，汇编可以逐步执行，并且可以使用 delve 检查寄存器。没有额外的构建步骤（不需要设置 C 工具链）。很容易设置一个纯 Go 的备用方案，所以跨编译仍然有效。常见问题被 go vet 捕捉到。</p>
<h2 id="SIMD_-_更大">SIMD ... 更大</h2>
<p>以前，我们限制自己只使用 <code>AVX2</code>，但如果不这样呢？<code>AVX-512</code> 的 <code>VNNI</code> 扩展添加了 <code>VPDPBUSD</code> 指令，该指令计算 <code>int8</code> 向量而不是 <code>int16</code> 的点积。这意味着我们可以在单个指令中处理四倍的元素，因为我们不必先转换为 int16，并且我们的向量宽度在 AVX-512 中加倍！</p>
<p>唯一的问题是该指令要求一个向量是有符号字节，另一个向量是无符号字节。而我们的两个向量都是有符号的。我们可以借鉴英特尔开发者指南中的技巧来解决这个问题。给定两个 int8 元素 <code>an</code> 和 <code>bn</code>，我们进行逐元素计算如下：<code>an * (bn + 128) - an * 128</code>。<code>an * 128</code> 项是将 <code>128</code> 加到 <code>bn</code> 以将其提升到 <code>u8</code> 范围的超出部分。我们单独跟踪这部分并在最后进行减法。该表达式中的每个操作都可以进行向量化处理。</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line"><span class="comment">// DotVNNI calculates the dot product of two slices using AVX512 VNNI</span></div><div class="line"><span class="comment">// instructions The slices must be of equal length and that length must be a</span></div><div class="line"><span class="comment">// multiple of 64.</span></div><div class="line">TEXT ·DotVNNI(SB), NOSPLIT, <span class="variable">$0</span>-<span class="number">52</span></div><div class="line">	<span class="comment">// Offsets based on slice header offsets.</span></div><div class="line">	<span class="comment">// To check, use `GOARCH=amd64 go vet`</span></div><div class="line">	MOVQ a_base+<span class="number">0</span>(FP), AX</div><div class="line">	MOVQ b_base+<span class="number">24</span>(FP), BX</div><div class="line">	MOVQ a_len+<span class="number">8</span>(FP), DX</div><div class="line">    ADDQ AX, DX <span class="comment">// end pointer</span></div><div class="line">	<span class="comment">// Zero our accumulators</span></div><div class="line">	VPXORQ Z0, Z0, Z0 <span class="comment">// positive</span></div><div class="line">	VPXORQ Z1, Z1, Z1 <span class="comment">// negative</span></div><div class="line">	<span class="comment">// Fill Z2 with 128</span></div><div class="line">	MOVD <span class="variable">$0</span>x80808080, R9</div><div class="line">	VPBROADCASTD R9, Z2</div><div class="line">blockloop:</div><div class="line">	CMPQ AX, DX</div><div class="line">	JE reduce</div><div class="line">	VMOVDQU8 (AX), Z3</div><div class="line">	VMOVDQU8 (BX), Z4</div><div class="line">	<span class="comment">// The VPDPBUSD instruction calculates of the dot product 4 columns at a</span></div><div class="line">	<span class="comment">// time, accumulating into an i32 vector. The problem is it expects one</span></div><div class="line">	<span class="comment">// vector to be unsigned bytes and one to be signed bytes. To make this</span></div><div class="line">	<span class="comment">// work, we make one of our vectors unsigned by adding 128 to each element.</span></div><div class="line">	<span class="comment">// This causes us to overshoot, so we keep track of the amount we need</span></div><div class="line">	<span class="comment">// to compensate by so we can subtract it from the sum at the end.</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Effectively, we are calculating SUM((Z3 + 128) · Z4) - 128 * SUM(Z4).</span></div><div class="line">	VPADDB Z3, Z2, Z3   <span class="comment">// add 128 to Z3, making it unsigned</span></div><div class="line">	VPDPBUSD Z4, Z3, Z0 <span class="comment">// Z0 += Z3 dot Z4</span></div><div class="line">	VPDPBUSD Z4, Z2, Z1 <span class="comment">// Z1 += broadcast(128) dot Z4</span></div><div class="line">	ADDQ <span class="variable">$6</span>4, AX</div><div class="line">	ADDQ <span class="variable">$6</span>4, BX</div><div class="line">	JMP blockloop</div><div class="line">reduce:</div><div class="line">    <span class="comment">// Subtract the overshoot from our calculated dot product</span></div><div class="line">	VPSUBD Z1, Z0, Z0 <span class="comment">// Z0 -= Z1</span></div><div class="line">    <span class="comment">// Sum Z0 horizontally. There is no horizontal sum instruction, so instead</span></div><div class="line">    <span class="comment">// we sum the upper and lower halves of Z0, fold it in half again, and</span></div><div class="line">    <span class="comment">// repeat until we are down to 1 element that contains the final sum.</span></div><div class="line">    VEXTRACTI64X4 <span class="variable">$1</span>, Z0, Y1</div><div class="line">    VPADDD Y0, Y1, Y0</div><div class="line">	VEXTRACTI128 <span class="variable">$1</span>, Y0, X1</div><div class="line">	VPADDD X0, X1, X0</div><div class="line">	VPSRLDQ <span class="variable">$8</span>, X0, X1</div><div class="line">	VPADDD X0, X1, X0</div><div class="line">	VPSRLDQ <span class="variable">$4</span>, X0, X1</div><div class="line">	VPADDD X0, X1, X0</div><div class="line">	<span class="comment">// Store the reduced sum</span></div><div class="line">	VMOVD X0, R8</div><div class="line">end:</div><div class="line">	MOVL R8, ret+<span class="number">48</span>(FP)</div><div class="line">	VZEROALL</div><div class="line">	RET</div></pre></td></tr></table></figure>

<p>这种实现又带来了另外 21% 的改进。真不赖！<br><img src="slow-to-simd5.png" alt=""></p>
<h2 id="下一步">下一步</h2>
<p>好吧，我对吞吐量增加 9.3 倍和内存使用量减少 4 倍感到非常满意，所以我可能会适可而止了。</p>
<p>现实生活中的答案可能是“使用索引”。有大量优秀的工作致力于使最近邻居搜索更快,并且有许多内置向量DB使其部署相当简单。</p>
<p>然而，如果你想要一些有趣的思考，我的一位同事在 <a href="https://github.com/sourcegraph/sourcegraph/compare/simd-post-gpu-embeddings~3...simd-post-gpu-embeddings" target="_blank" rel="external">GPU 实现的点积</a>。</p>
<p><strong>一些有价值的资料</strong></p>
<ul>
<li>如果你还没有使用过 <a href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat" target="_blank" rel="external">benchstat</a>，你应该使用。太棒了。基准测试结果超级简单统计比较。</li>
<li>不要错过<a href="https://go.godbolt.org/z/qT3M7nPGf" target="_blank" rel="external">compiler explorer</a>，这是一个非常有用的挖掘生成的汇编代码工具。</li>
<li>还有一次,我被技术上的挑战吸引,实现了<a href="https://github.com/camdencheek/simd_blog/blob/main/dot_arm64.s" target="_blank" rel="external">ARM NEON的版本</a>,这带来了一些有趣的对比。</li>
<li>如果您还没有遇到过它，<a href="https://www.agner.org/optimize/" target="_blank" rel="external">Agner Fog 说明表</a>会让您大吃一惊,很多底层优化的参考资料。在优化点积函数的工作中，我使用它们来理解指令延迟的差异,以及为什么某些流水线优于其他流水线。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>SourceGraph 的工程师 Camden Cheek 提供的一个利用SIMD进行Go性能优化的故事:<a href="https://sourcegraph.com/blog/slow-to-simd" target="_blank" rel="external">From slow to SIMD: A Go optimization story</a>。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[遍历函数？Go 1.22中隐藏的功能]]></title>
    <link href="https://colobu.com/2024/01/18/range-over-func/"/>
    <id>https://colobu.com/2024/01/18/range-over-func/</id>
    <published>2024-01-18T13:29:15.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.22中可以 range 一个整数，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span><span class="number"> 10</span> {</div><div class="line">    fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个大家都已经知道了，其实对应的提案中还有一个隐藏的功能，就是可以 range 一个函数，比如下面的代码(摘自官方代码库<a href="https://github.com/golang/go/blob/97daa6e94296980b4aa2dac93a938a5edd95ce93/src/internal/trace/v2/event.go#L262" target="_blank" rel="external">internal/trace/v2/event.go</a>)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Frames is an iterator over the frames in a Stack.</span></div><div class="line"><span class="keyword">func</span> (s Stack) Frames(yield <span class="keyword">func</span>(f StackFrame) <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> s.id ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	stk := s.table.stacks.mustGet(s.id)</div><div class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> stk.frames {</div><div class="line">		sf := StackFrame{</div><div class="line">			PC:   f.pc,</div><div class="line">			Func: s.table.strings.mustGet(f.funcID),</div><div class="line">			File: s.table.strings.mustGet(f.fileID),</div><div class="line">			Line: f.line,</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !yield(sf) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>就少有介绍了。</p>
<p>本文尝试介绍它，让读者先了解一下，它在Go 1.22 中是一个实验性的功能，还不确定未来在哪个版本中会被正式支持。</p>
<p>官方wiki中也有一篇介绍: <a href="https://go.dev/wiki/RangefuncExperiment" target="_blank" rel="external">Rangefunc Experiment</a>，类似问答的形式，也是必读的知识库。<br><a id="more"></a></p>
<p>这个功能去年Russ Cox发起讨论(<a href="https://github.com/golang/go/discussions/56413" target="_blank" rel="external">#56413</a>), 并建立一个提案(<a href="https://github.com/golang/go/issues/61405" target="_blank" rel="external">#61405</a>),大家讨论都很激烈啊，几百次的讨论，所以我也不准备介绍前因后果了，直接了当的说结论。<br>先前, <code>for-range</code>所能遍历(迭代)的类型很有限，只能是slice、数组、map、字符串、channel等。<br>现在，除了上面的五种类型，还可以是整数和三种三种函数。</p>
<p>当然<code>for x := range n { ... }</code>等价于<code>for x := T(0); x &lt; n; x++ { ... }</code>, 其中T是n的类型。这个大家都知道了。</p>
<p>三个函数可能大家不是很了解，很正常，目前这只是一个实验性的功能。当然range的类型如下：</p>
<table>
<thead>
<tr>
<th>Range 表达式</th>
<th>第一个值</th>
<th>第二个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>array or slice      a  [n]E, *[n]E, or []E</td>
<td>index    i  int</td>
<td>a[i]       E</td>
</tr>
<tr>
<td>string              s  string type</td>
<td>index    i  int</td>
<td>see below  rune</td>
</tr>
<tr>
<td>map                 m  map[K]V</td>
<td>key      k  K</td>
<td>m[k]       V</td>
</tr>
<tr>
<td>channel             c  chan E, &lt;-chan E</td>
<td>element  e  E</td>
<td></td>
</tr>
<tr>
<td>integer             n  integer type</td>
<td>index    i int</td>
<td></td>
</tr>
<tr>
<td>function, 0 values  f  func(func()bool) bool</td>
<td></td>
<td></td>
</tr>
<tr>
<td>function, 1 value   f  func(func(V)bool) bool</td>
<td>value    v  V</td>
<td></td>
</tr>
<tr>
<td>function, 2 values  f  func(func(K, V)bool) bool</td>
<td>key      k  K</td>
<td>v          V</td>
</tr>
</tbody>
</table>
<p>本文介绍的就是后三种形式</p>
<h2 id="三种可遍历的函数">三种可遍历的函数</h2>
<p>假设<code>f</code>是一个这样的函数:<code>func(func()bool) bool</code>, 那么<code>for x := range f { ... }</code>类似于<code>f(func(x T1, y T2) bool { ... })</code>，其中for循环移动到方法体中了。<code>yield</code>的bool返回值指示是否还要继续遍历。</p>
<p>对于这样一个<code>f</code>,下面的格式都可以:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> x, y := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> x, _ := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> _, y := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> f { ... }</div></pre></td></tr></table></figure>

<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>(k <span class="typename">int</span>, v <span class="typename">byte</span>) <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">		<span class="keyword">if</span> !yield(i, <span class="typename">byte</span>(<span class="string">'a'</span>+i)) {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> fn {</div><div class="line">	fmt.Printf(<span class="string">"%d: %c\n"</span>, k, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行可以看到结果符合预期，我们遍历了26个小写字母，注意range的数据类型是我们的函数:<br><img src="range-func.png" alt=""></p>
<p>这里，fn这个函数没有返回值，其实也可以有bool返回值，有bool返回值就可以组合多个range函数，可以容易写出复杂且难以维护的代码，减少自己失业的可能。<br>这里的<code>yield</code>函数接收两个参数，第一个是<code>int</code>类型，第二个是<code>byte</code>类型，返回值是<code>bool</code>类型，这个<code>yield</code>函数的返回值决定了是否继续遍历。当然这里我们可以写泛型的程序，这里为了简单，就不写了。</p>
<p>下面是一个<code>f</code>是<code>func(func(V)bool) bool</code>的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>(v <span class="typename">byte</span>) <span class="typename">bool</span>) {</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">        <span class="keyword">if</span> !yield(<span class="typename">byte</span>(<span class="string">'a'</span> + i)) {</div><div class="line">            <span class="keyword">return</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> fn {</div><div class="line">    fmt.Printf(<span class="string">"%c\n"</span>, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="range-func2.png" alt=""></p>
<p>当然yield函数也可以没有参数，比如<code>func(func()bool) bool</code>，下面这个例子就是无参数的形式，输出结果是26。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>() <span class="typename">bool</span>) {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">			<span class="keyword">if</span> !yield() {</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> count <span class="typename">int</span></div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> fn {</div><div class="line">		count++</div><div class="line">	}</div><div class="line">	fmt.Println(count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果不使用for-range 函数的形式，我们可以进行改写，比如两个参数的列子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>(k <span class="typename">int</span>, v <span class="typename">byte</span>) <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">		<span class="keyword">if</span> !yield(i, <span class="typename">byte</span>(<span class="string">'a'</span>+i)) {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">fn(<span class="keyword">func</span>(k <span class="typename">int</span>, v <span class="typename">byte</span>) <span class="typename">bool</span> {</div><div class="line">	fmt.Printf(<span class="string">"%d: %c\n"</span>, k, v)</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">})</div></pre></td></tr></table></figure>

<p>注意<code>yield</code>参数名称不是一个关键字，它只是一个普通的参数名称，可以随便取名字，但是为了模仿和其它语言中的<code>generator</code>,使用了<code>yield</code>这样一个名称，以至于代码更加易读。</p>
<p>看起来这个功能就是一个语法糖， 代码<a href="https://go.googlesource.com/go/+/refs/changes/41/510541/7/src/cmd/compile/internal/rangefunc/rewrite.go" target="_blank" rel="external">rangefunc/rewrite</a>将range-over-func代码写成非range-over-func代码的形式。</p>
<h2 id="为什么要这样做？">为什么要这样做？</h2>
<p>标准库中就有 <code>archive/tar.Reader.Next</code>, <code>bufio.Reader.ReadByte</code>, <code>bufio.Scanner.Scan</code>, <code>container/ring.Ring.Do</code>, <code>database/sql.Rows</code>, <code>expvar.Do</code>, <code>flag.Visit</code>, <code>go/token.FileSet.Iterate</code>, <code>path/filepath.Walk</code>, <code>go/token.FileSet.Iterate</code>, <code>runtime.Frames.Next</code> 和<code>sync.Map.Range</code>等各种遍历的函数，所以如果有一种统一的格式更好。</p>
<p>第三方库中有更多的类似代码。</p>
<p>虽然这个功能还没有正式支持，但是我看到有些库摩拳擦掌准备使用了，而<a href="https://github.com/achille-roussel/sqlrange" target="_blank" rel="external">sqlrange</a>更进一步，已经支持了。</p>
<p>当然你使用它必须下载Go 1.22或者gotip, 并且设置<code>export GOEXPERIMENT=rangefunc</code>。</p>
<p>它提供了<code>Query</code>和<code>Exec</code>可遍历函数。比如<code>Query</code>从一个表中查询<code>Point</code>数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> {</div><div class="line">    X <span class="typename">float64</span> <span class="string">`sql:"x"`</span></div><div class="line">    Y <span class="typename">float64</span> <span class="string">`sql:"y"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> p, err := <span class="keyword">range</span> sqlrange.Query[Point](db, <span class="string">`select x, y from points`</span>) {</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        ...</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>遍历查询和ORM一气呵成。这里的资源管理是自动的,底层的<code>*sql.Rows</code>遍历完会自动关闭。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.22中可以 range 一个整数，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span><span class="number"> 10</span> {</div><div class="line">    fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个大家都已经知道了，其实对应的提案中还有一个隐藏的功能，就是可以 range 一个函数，比如下面的代码(摘自官方代码库<a href="https://github.com/golang/go/blob/97daa6e94296980b4aa2dac93a938a5edd95ce93/src/internal/trace/v2/event.go#L262" target="_blank" rel="external">internal/trace/v2/event.go</a>)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Frames is an iterator over the frames in a Stack.</span></div><div class="line"><span class="keyword">func</span> (s Stack) Frames(yield <span class="keyword">func</span>(f StackFrame) <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> s.id ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	stk := s.table.stacks.mustGet(s.id)</div><div class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> stk.frames {</div><div class="line">		sf := StackFrame{</div><div class="line">			PC:   f.pc,</div><div class="line">			Func: s.table.strings.mustGet(f.funcID),</div><div class="line">			File: s.table.strings.mustGet(f.fileID),</div><div class="line">			Line: f.line,</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !yield(sf) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>就少有介绍了。</p>
<p>本文尝试介绍它，让读者先了解一下，它在Go 1.22 中是一个实验性的功能，还不确定未来在哪个版本中会被正式支持。</p>
<p>官方wiki中也有一篇介绍: <a href="https://go.dev/wiki/RangefuncExperiment" target="_blank" rel="external">Rangefunc Experiment</a>，类似问答的形式，也是必读的知识库。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 6.8 网络优化, 大量并发连接的TCP性能提高40%左右]]></title>
    <link href="https://colobu.com/2024/01/14/Linux-6-8-Networking/"/>
    <id>https://colobu.com/2024/01/14/Linux-6-8-Networking/</id>
    <published>2024-01-14T09:21:08.000Z</published>
    <updated>2024-02-02T07:54:29.788Z</updated>
    <content type="html"><![CDATA[<p>除了通常的新有线/无线网络硬件支持和大型 Linux 网络子系统中的其他例行变动之外，Linux 6.8 内核还对核心网络代码进行了一些关键改进，当遇到许多并发网络连接时，TCP 性能可以提高 ~40%。</p>
<a id="more"></a>
<p>首先，对核心网络结构进行了分析和重组。这项工作一直围绕着<strong>优化缓存行</strong>的使用和添加保护措施，以确保未来的更改不会倒退。反过来，这种对核心网络结构的优化导致许多并发连接的 TCP 性能提高了 40% 或更多！</p>
<p>Google 的 Coco Li 解释了他们对网络代码的 cachline 优化工作：</p>
<blockquote>
<p>当前,网络栈中的变量密集结构按时间顺序、逻辑顺序组织，有时按缓存行访问组织。这个补丁系列试图重新组织核心网络栈变量,以在数据传输阶段最小化缓存行消耗。具体来说,我们研究了TCP/IP栈和TCP中的快速路径定义。<br>出于文档目的,我们还为我们考虑的每个核心数据结构添加了新的文件,尽管由于现有缓存行跨度的数量,并非所有在快速路径上都已被修改。在文档中,我们记录了我们在快速路径上识别的所有变量及原因。我们还希望在未来添加/修改变量时,可以参考并相应地更新文档,以反映最新变量组织。</p>
<p>测试:我们的测试使用<code>neper tcp_rr</code>测试tcp流量。测试具有<code>$cpu</code>数量的线程和可变数量的流量(见下文)。测试在6.5-rc1上运行 效率计算为cpu秒数/吞吐量(一个tcp_rr往返行程)。下面的结果显示在应用补丁系列之前和之后的效率delta。</p>
</blockquote>
<ul>
<li>在AMD平台上， <strong>100Gb/s</strong> 的网卡和 <strong>256Mb</strong> 三级缓存：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">IPv4</div><div class="line">Flows   with patches    clean kernel      Percent reduction</div><div class="line"><span class="number">30</span>k     <span class="number">0.0001736538065</span> <span class="number">0.0002741191042</span> -<span class="number">36.65</span>%</div><div class="line"><span class="number">20</span>k     <span class="number">0.0001583661752</span> <span class="number">0.0002712559158</span> -<span class="number">41.62</span>%</div><div class="line"><span class="number">10</span>k     <span class="number">0.0001639148817</span> <span class="number">0.0002951800751</span> -<span class="number">44.47</span>%</div><div class="line"><span class="number">5</span>k      <span class="number">0.0001859683866</span> <span class="number">0.0003320642536</span> -<span class="number">44.00</span>%</div><div class="line"><span class="number">1</span>k      <span class="number">0.0002035190546</span> <span class="number">0.0003152056382</span> -<span class="number">35.43</span>%</div><div class="line"></div><div class="line">IPv6</div><div class="line">Flows   with patches  clean kernel    Percent reduction</div><div class="line"><span class="number">30</span>k     <span class="number">0.000202535503</span>  <span class="number">0.0003275329163</span> -<span class="number">38.16</span>%</div><div class="line"><span class="number">20</span>k     <span class="number">0.0002020654777</span> <span class="number">0.0003411304786</span> -<span class="number">40.77</span>%</div><div class="line"><span class="number">10</span>k     <span class="number">0.0002122427035</span> <span class="number">0.0003803674705</span> -<span class="number">44.20</span>%</div><div class="line"><span class="number">5</span>k      <span class="number">0.0002348776729</span> <span class="number">0.0004030403953</span> -<span class="number">41.72</span>%</div><div class="line"><span class="number">1</span>k      <span class="number">0.0002237384583</span> <span class="number">0.0002813646157</span> -<span class="number">20.48</span>%</div></pre></td></tr></table></figure>

<ul>
<li>在Intel平台上， <strong>200Gb/s</strong> 的网卡和 <strong>205Mb</strong> 三级缓存：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IPv6</div><div class="line">Flows   with patches    clean kernel    Percent reduction</div><div class="line"><span class="number">30</span>k     <span class="number">0.0006296537873</span> <span class="number">0.0006370427753</span> -<span class="number">1.16</span>%</div><div class="line"><span class="number">20</span>k     <span class="number">0.0003451029365</span> <span class="number">0.0003628016076</span> -<span class="number">4.88</span>%</div><div class="line"><span class="number">10</span>k     <span class="number">0.0003187646958</span> <span class="number">0.0003346835645</span> -<span class="number">4.76</span>%</div><div class="line"><span class="number">5</span>k      <span class="number">0.0002954676348</span> <span class="number">0.000311807592</span>  -<span class="number">5.24</span>%</div><div class="line"><span class="number">1</span>k      <span class="number">0.0001909169342</span> <span class="number">0.0001848069709</span> <span class="number">3.31</span>%</div></pre></td></tr></table></figure>

<p>对于Intel的服务器，优化不是那么明显，但是对于对于AMD EPYC服务器而言，这是一个天使般的改进，它们的网络性能提高了 40% 左右，这是一个巨大的提升。</p>
<p>相关的优化补丁可以查看<a href="https://lore.kernel.org/netdev/20231129072756.3684495-1-lixiaoyan@google.com/" target="_blank" rel="external">Analyze and Reorganize core Networking Structs to optimize cacheline consumption</a>, 主要由谷歌的Coco Li提交。</p>
<p><img src="tcp-cacheline.png" alt=""></p>
<p>tcp的优化已经实现了，udp的优化还会远吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>除了通常的新有线/无线网络硬件支持和大型 Linux 网络子系统中的其他例行变动之外，Linux 6.8 内核还对核心网络代码进行了一些关键改进，当遇到许多并发网络连接时，TCP 性能可以提高 ~40%。</p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="https://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高效I/O并发处理：双缓冲和Exchanger]]></title>
    <link href="https://colobu.com/2024/01/14/double-buffering-and-Exchanger/"/>
    <id>https://colobu.com/2024/01/14/double-buffering-and-Exchanger/</id>
    <published>2024-01-14T03:45:47.000Z</published>
    <updated>2024-02-02T07:54:29.792Z</updated>
    <content type="html"><![CDATA[<p>双缓冲(double buffering)是高效处理I/O操作的一种并发技术，它使用两个buffer,一个goroutine使用其中一个buffer进行写，而另一个goroutine使用另一个buffer进行读，然后进行交换。这样两个goroutine可能并发的执行，减少它们之间的等待和阻塞。</p>
<p>本文还提供了一个类似Java的<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Exchanger.html" target="_blank" rel="external">java.util.concurrent.Exchanger</a>的Go并发原语，它可以用来在两个goroutine之间交换数据，快速实现双缓冲的模式。 这个并发原语可以在<a href="https://pkg.go.dev/github.com/smallnest/exp@v0.2.2/sync#Exchanger" target="_blank" rel="external">github.com/smallnest/exp/sync/Exchanger</a>找到。</p>
<a id="more"></a>
<h2 id="double_buffering_并发模式">double buffering 并发模式</h2>
<p>双缓冲(double buffering)设计方式虽然在一些领域中被广泛的应用，但是我还没有看到它在并发模式中专门列出了，或者专门列为一种模式。这里我们不妨把它称之为<strong>双缓存模式</strong>。</p>
<p>这是一种在I/O处理领域广泛使用的用来提速的编程技术，它使用两个缓冲区来加速计算机，该计算机可以重叠 <strong>I/O</strong> 和<strong>处理</strong>。一个缓冲区中的数据正在处理，而下一组数据被读入另一个缓冲区。<br>在流媒体应用程序中，一个缓冲区中的数据被发送到声音或图形卡，而另一个缓冲区则被来自源（Internet、本地服务器等）的更多数据填充。<br>当视频显示在屏幕上时，一个缓冲区中的数据被填充，而另一个缓冲区中的数据正在显示。当在缓冲区之间移动数据的功能是在硬件电路中实现的，而不是由软件执行时，全动态视频的速度会加快，不但速度被加快，而且可以减少黑屏闪烁的可能。</p>
<p>！<a href="double-buffering.png"></a></p>
<p>在这个模式中，两个goroutine并发的执行，一个goroutine使用一个buffer进行写(不妨称为buffer1)，而另一个goroutine使用另一个buffer进行读(不妨称为buffer2)。如图所示。<br>当左边的writer写满它当前使用的buffer1后，它申请和右边的goroutine的buffer2进行交换，这会出现两种情况：</p>
<ul>
<li>右边的reader已经读完了它当前使用的buffer2，那么它会立即交换，这样左边的writer可以继续写buffer2，而右边的reader可以继续读buffer1。</li>
<li>右边的reader还没有读完buffer2，那么左边的writer就会阻塞，直到右边的reader读完buffer2，然后交换。<br>周而复始。</li>
</ul>
<p>同样右边的goroutine也是同样的处理，当它读完buffer2后，它会申请和左边的goroutine的buffer1进行交换，这会出现两种情况：</p>
<ul>
<li>左边的writer已经写完了它当前使用的buffer1，那么它会立即交换，这样右边的reader可以继续读buffer1，而左边的writer可以继续写buffer2。</li>
<li>左边的writer还没有写完buffer1，那么右边的reader就会阻塞，直到左边的writer写完buffer1，然后交换。<br>周而复始。</li>
</ul>
<p>这样两个goroutine就可以并发的执行，而不用等待对方的读写操作。这样可以提高并发处理的效率。</p>
<p>不仅仅如此， double buffering其实可以应用于更多的场景， 不仅仅是buffer的场景，如Java的垃圾回收机制中，HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to,或者s0和s1），在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被<strong>清空</strong>。这个时候，“From”和“To”会交换(<strong>exchange</strong>)他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<br><img src="java-gc.png" alt=""></p>
<h2 id="Exchanger的实现">Exchanger的实现</h2>
<p>既然有这样的场景，有这样的需求，所以我们需要针对这样场景的一个同步原语。Java给我们做了一个很好的师范，接下来我们使用实现相应的Go,但是我们的实现和Java的实现完全不同，我们要基于Go既有的同步原语来实现。</p>
<p>基于Java实现的Exchanger的功能，我们也实现一个<code>Exchanger</code>, 我们期望它的功能如下：</p>
<ul>
<li>只用作两个goroutine之间的数据交换，不支持多个goroutine之间的数据交换。</li>
<li>可以重用。交换完之后还可以继续交换</li>
<li>支持泛型，可以交换任意类型的数据</li>
<li>如果对端还没有准备交换，就阻塞等待</li>
<li>在交换完之前，阻塞的goroutine不可能调用<code>Exchange</code>方法两次</li>
<li>Go内存模型补充： 同一次交换， 一个goroutine在调用<code>Exchange</code>方法的完成，一定<strong>happens after</strong>另一个goroutine调用<code>Exchange</code>方法的开始。</li>
</ul>
<p>如果你非常熟悉Go的各种同步原语，你可以很快的组合出这样一个同步原语。如果你还不是那么熟悉，建议你阅读《深入理解Go并发编程》这本书，京东有售。<br>下面是一个简单的实现，代码在<a href="https://pkg.go.dev/github.com/smallnest/exp@v0.2.2/sync#Exchanger" target="_blank" rel="external">Exchanger</a>。<br>我们只用<code>left</code>、<code>right</code>指代这两个goroutine, goroutine是Go语言中的并发单元，我们期望的就是这两个goroutine发生关系。</p>
<p>为了跟踪这两个goroutine，我们需要使用goroutine id来标记这两个goroutine，这样避免了第三者插入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Exchanger[T any] <span class="keyword">struct</span> {</div><div class="line">	leftGoID, rightGoID <span class="typename">int64</span></div><div class="line">	left, right         <span class="keyword">chan</span> T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你必须使用 <code>NewExchanger</code> 创建一个<code>Exchanger</code>，它会返回一个<code>Exchanger</code>的指针。<br>初始化的时候我们把left和right的id都设置为-1，表示还没有goroutine使用它们，并且不会和所有的goroutine的id冲突。<br>同时我们创建两个channel，一个用来左边的goroutine写，右边的goroutine读，另一个用来右边的goroutine写，左边的goroutine读。channel的buffer设置为1，这样可以避免死锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewExchanger[T any]() *Exchanger[T] {</div><div class="line">	<span class="keyword">return</span> &Exchanger[T]{</div><div class="line">		leftGoID: <span class="number"> -1</span>,</div><div class="line">		rightGoID:<span class="number"> -1</span>,</div><div class="line">		left:      <span class="built_in">make</span>(<span class="keyword">chan</span> T,<span class="number"> 1</span>),</div><div class="line">		right:     <span class="built_in">make</span>(<span class="keyword">chan</span> T,<span class="number"> 1</span>),</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Exchange</code>方法是核心方法，它用来交换数据，它的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *Exchanger[T]) Exchange(value T) T {</div><div class="line">	goid := goroutine.ID()</div><div class="line"></div><div class="line">	<span class="comment">// left goroutine</span></div><div class="line">	isLeft := atomic.CompareAndSwapInt64(&e.leftGoID,<span class="number"> -1</span>, goid)</div><div class="line">	<span class="keyword">if</span> !isLeft {</div><div class="line">		isLeft = atomic.LoadInt64(&e.leftGoID) == goid</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> isLeft {</div><div class="line">		e.right &lt;- value <span class="comment">// send value to right</span></div><div class="line">		<span class="keyword">return</span> &lt;-e.left  <span class="comment">// wait for value from right</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// right goroutine</span></div><div class="line">	isRight := atomic.CompareAndSwapInt64(&e.rightGoID,<span class="number"> -1</span>, goid)</div><div class="line">	<span class="keyword">if</span> !isRight {</div><div class="line">		isRight = atomic.LoadInt64(&e.rightGoID) == goid</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> isRight {</div><div class="line">		e.left &lt;- value  <span class="comment">// send value to left</span></div><div class="line">		<span class="keyword">return</span> &lt;-e.right <span class="comment">// wait for value from left</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// other goroutine</span></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"sync: exchange called from neither left nor right goroutine"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当一个goroutine调用的时候，首先我们尝试把它设置为<code>left</code>,如果成功，那么它就是<code>left</code>。<br>如果不成功，我们就判断它是不是先前已经是<code>left</code>，如果是，那么它就是<code>left</code>。<br>如果先前，或者此时<code>left</code>已经被另一个goroutine占用了，它还有机会成为<code>right</code>，同样的逻辑检查和设置<code>right</code>。</p>
<p>如果既不是<code>left</code>也不是<code>right</code>，那么就是第三者插入了，我们需要panic，因为我们不希望第三者插足。</p>
<p>如果它是<code>left</code>，那么它就会把数据发送到<code>right</code>，然后等待<code>right</code>发送数据过来。<br>如果它是<code>right</code>，那么它就会把数据发送到<code>left</code>，然后等待<code>left</code>发送数据过来。</p>
<p>这样就实现了数据的交换。</p>
<h2 id="Exchanger的使用">Exchanger的使用</h2>
<p>我们使用一个简单的双缓冲例子来说明如何使用<code>Exchanger</code>，我们创建两个goroutine，一个goroutine负责写，另一个goroutine负责读，它们之间通过<code>Exchanger</code>来交换数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">buf1 := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>))</div><div class="line">buf2 := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>))</div><div class="line"></div><div class="line">exchanger := syncx.NewExchanger[*bytes.Buffer]()</div><div class="line"></div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">wg.Add<span class="number">(2</span>)</div><div class="line"></div><div class="line">expect :=<span class="number"> 0</span></div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() { <span class="comment">// g1</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	buf := buf1</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 1024</span>; j++ {</div><div class="line">			buf.WriteByte(<span class="typename">byte</span>(j /<span class="number"> 256</span>))</div><div class="line">			expect += j /<span class="number"> 256</span></div><div class="line">		}</div><div class="line"></div><div class="line">		buf = exchanger.Exchange(buf)</div><div class="line">	}</div><div class="line">}()</div><div class="line"></div><div class="line"><span class="keyword">var</span> got <span class="typename">int</span></div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() { <span class="comment">// g2</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	buf := buf2</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		buf = exchanger.Exchange(buf)</div><div class="line">		<span class="keyword">for</span> _, b := <span class="keyword">range</span> buf.Bytes() {</div><div class="line">			got += <span class="typename">int</span>(b)</div><div class="line">		}</div><div class="line">		buf.Reset()</div><div class="line">	}</div><div class="line">}()</div><div class="line"></div><div class="line">wg.Wait()</div><div class="line"></div><div class="line">fmt.Println(got)</div><div class="line">fmt.Println(expect == got)</div></pre></td></tr></table></figure>

<p>在这个例子中 <code>g1</code>负责写，每个buffer的容量是1024，写满就交给另外一个读g2,并从读g2中交换过来一个空的buffer继续写。<br>交换10次之后，两个goroutine都退出了，我们检查写入的数据和读取的数据是否一致，如果一致，那么就说明我们的<code>Exchanger</code>实现是正确的。</p>
<h2 id="总结">总结</h2>
<p>文本介绍了一种类似Java的<code>Exchanger</code>的同步原语的实现，这个同步原语可以在双缓冲的场景中使用，提高并发处理的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>双缓冲(double buffering)是高效处理I/O操作的一种并发技术，它使用两个buffer,一个goroutine使用其中一个buffer进行写，而另一个goroutine使用另一个buffer进行读，然后进行交换。这样两个goroutine可能并发的执行，减少它们之间的等待和阻塞。</p>
<p>本文还提供了一个类似Java的<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Exchanger.html" target="_blank" rel="external">java.util.concurrent.Exchanger</a>的Go并发原语，它可以用来在两个goroutine之间交换数据，快速实现双缓冲的模式。 这个并发原语可以在<a href="https://pkg.go.dev/github.com/smallnest/exp@v0.2.2/sync#Exchanger" target="_blank" rel="external">github.com/smallnest/exp/sync/Exchanger</a>找到。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go运行时的并发原语]]></title>
    <link href="https://colobu.com/2024/01/07/concurrent-codes-in-Go-runtime-and-standard-library/"/>
    <id>https://colobu.com/2024/01/07/concurrent-codes-in-Go-runtime-and-standard-library/</id>
    <published>2024-01-07T05:40:31.000Z</published>
    <updated>2024-02-02T07:54:29.792Z</updated>
    <content type="html"><![CDATA[<p>这篇文章我们来了解一下隐藏在Go运行时中的一些并发原语， 因为运行时是底座和包循环依赖等原因，运行时中很少使用标准库中的并发原语，它有自己的并发原语。</p>
<a id="more"></a>
<h3 id="mutex">mutex</h3>
<p>在<a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L164" target="_blank" rel="external">runtime/runtime2.go</a> 定义了一个互斥锁，它的定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> mutex <span class="keyword">struct</span> {</div><div class="line">	lockRankStruct</div><div class="line">	key <span class="typename">uintptr</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它可是运行时中的大红人了，在很多数据结构中都被广泛的使用，凡事涉及到并发访问的地方都会用到它，你在<code>runtime2.go</code>文件中就能看到多处使用它的地方，因为很多地方都在使用它，我就不一一列举了在runtime这个文件夹中搜<code>mutex</code>这个关键子就都搜出来了。</p>
<p>举一个大家常用来底层分析的数据结构<code>channel</code>为例，channel的数据结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</div><div class="line">	qcount   <span class="typename">uint</span>           </div><div class="line">	dataqsiz <span class="typename">uint</span>           </div><div class="line">	buf      unsafe.Pointer </div><div class="line">	elemsize <span class="typename">uint16</span></div><div class="line">	closed   <span class="typename">uint32</span></div><div class="line">	elemtype *_type </div><div class="line">	sendx    <span class="typename">uint</span>   </div><div class="line">	recvx    <span class="typename">uint</span>   </div><div class="line">	recvq    waitq  </div><div class="line">	sendq    waitq  </div><div class="line"></div><div class="line">	lock mutex</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后哪个字段<code>lock mutex</code>就是使用的这个互斥锁。因为一个通道在发送和接收的时候都会涉及到对通道的修改，在多发送者或者接收者情况下，需要使用互斥锁来保护。</p>
<p>这个互斥锁的使用需要调用几个函数。</p>
<ul>
<li>lockInit: 需要初始化这个锁，比如在channel的实现中，有如下的初始化代码：<code>lockInit(&amp;c.lock, lockRankHchan)</code>, 它将lock初始化(lockInit)时设置锁的等级(rank)。如果不明确去初始化一个锁,那么可以在调用lock自身的时候通过lockWithRank指定这个锁的等级。这个等级在启用<code>GOEXPERIMENT=staticlockranking</code>用来加强锁的静态分析。</li>
<li>lock: 加锁，在不同的操作系统下有不同的实现。如channel使用这个代码进行加锁：<code>lock(&amp;c.lock)</code></li>
<li>unlock: 解锁，在不同的操作系统下有不同的实现。如channel使用这个代码进行解锁：<code>unlock(&amp;c.lock)</code></li>
</ul>
<p>我在<a href="https://colobu.com/2020/12/06/mutex-in-go-runtime/" target="_blank" rel="external">Go运行时中的 Mutex</a>中详细介绍了它，这里就不再赘述了。</p>
<h3 id="rwmutex">rwmutex</h3>
<p>运行时中还实现了读写锁<a href="https://github.com/golang/go/blob/master/src/runtime/rwmutex.go" target="_blank" rel="external">rwmutex</a>。<br>这个读写锁完全是从<code>sync.RWMutex</code>中拷贝过来的，只是将<code>sync.RWMutex</code>中的<code>sync</code>包替换成了<code>runtime</code>包，因为<code>sync</code>包依赖了<code>runtime</code>包，所以不能直接使用。</p>
<p>你看它的数据结构定义和<code>sync.RWMutex</code>几乎是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> rwmutex <span class="keyword">struct</span> {</div><div class="line">	rLock      mutex    <span class="comment">// protects readers, readerPass, writer</span></div><div class="line">	readers    muintptr <span class="comment">// list of pending readers</span></div><div class="line">	readerPass <span class="typename">uint32</span>   <span class="comment">// number of pending readers to skip readers list</span></div><div class="line"></div><div class="line">	wLock  mutex    <span class="comment">// serializes writers</span></div><div class="line">	writer muintptr <span class="comment">// pending writer waiting for completing readers</span></div><div class="line"></div><div class="line">	readerCount atomic.Int32 <span class="comment">// number of pending readers</span></div><div class="line">	readerWait  atomic.Int32 <span class="comment">// number of departing readers</span></div><div class="line"></div><div class="line">	readRank  lockRank <span class="comment">// semantic lock rank for read locking</span></div><div class="line">	writeRank lockRank <span class="comment">// semantic lock rank for write locking</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>mutex</code>和<code>rwmutex</code>会直接阻塞<code>M</code>。</p>
<h3 id="gopark/goready">gopark/goready</h3>
<p>在其它编程语言中，会直接提供<code>park</code>和<code>unpark</code>的功能，比如rust,提供对并发单元的更底层的控制。</p>
<p><code>park</code>就是停止一会，很形象，就是暂时让并发单元阻塞，不再参与调度，直到<code>unpark</code>它，它才会重新参与调度。</p>
<p>Go运行时并没有直接提供<code>park</code>和<code>unpark</code>的功能，它提供了<code>gopark</code>和<code>goready</code>的功能，它们的实现在<a href="https://github.com/golang/go/blob/master/src/runtime/proc.go#L385" target="_blank" rel="external">runtime/proc.go</a>。</p>
<p><code>gopark</code>会将goroutine放到等待队列中，从调度器的运行队列中移出去，等待被唤醒。<br><code>goready</code>会将goroutine放到可运行队列中，加入到调度器的运行队列，等待被调度。</p>
<h3 id="note">note</h3>
<p><code>note</code>实现一次性的通知机制。</p>
<p><code>note</code>的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> note <span class="keyword">struct</span> {</div><div class="line">	key <span class="typename">uintptr</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以使用<code>notesleep</code>和<code>notewakeup</code>进行休眠和唤醒。</p>
<p>就像<code>mutex</code>一样，<code>notesleep</code>会阻塞<code>M</code>，<code>notewakeup</code>会唤醒一个<code>M</code>，并且不会重新调度<code>G</code>和<code>P</code>,而<code>notetsleepg</code>就像一个阻塞的系统调用一样，允许<code>P</code>选择另外一个<code>G</code>运行。<br><code>noteclear</code>用来重置<code>note</code></p>
<p>总结一下， 上面几种同步原语阻塞的角色如下：</p>
<table><tbody><tr><th></th><th colspan="3">阻塞角色</th></tr><br><tr><th>同步原语</th><th>G</th><th>M</th><th>P</th></tr><br><tr><td>mutex/rwmutex</td><td>Y</td><td>Y</td><td>Y</td></tr><br><tr><td>note</td><td>Y</td><td>Y</td><td>Y/N</td></tr><br><tr><td>park</td><td>Y</td><td>N</td><td>N</td></tr><br></tbody></table>

<h3 id="filelock">filelock</h3>
<p>&quot;filelock&quot;（文件锁）通常是指在计算机系统中使用的一种机制，用于确保对文件的独占性访问，以防止多个进程或线程同时修改文件而导致数据不一致或损坏。</p>
<p>一些应用程序经常利用文件锁，来控制只有一个实例在运行，在linux环境下非常常见，比如mysql等。</p>
<p>在不同的操作系统和编程语言中，文件锁的实现方式可能会有所不同。一般而言，文件锁可以分为两种主要类型：</p>
<ul>
<li>共享锁（Shared Lock）： 多个进程或线程可以同时获取共享锁，允许它们同时读取文件，但阻止其他进程或线程获取独占锁进行写操作。</li>
<li>独占锁（Exclusive Lock）： 只允许一个进程或线程获取独占锁，阻止其他进程或线程同时进行读或写操作。</li>
</ul>
<p>文件锁的代码在<a href="https://github.com/golang/go/tree/8db131082d08e497fd8e9383d0ff7715e1bef478/src/cmd/go/internal/lockedfile" target="_blank" rel="external">cmd/go/internal/lockedfile</a>中,我们以Linux为例，看看它的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> lockType <span class="typename">int16</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	readLock  lockType = syscall.LOCK_SH</div><div class="line">	writeLock lockType = syscall.LOCK_EX</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> lock(f File, lt lockType) (err error) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		err = syscall.Flock(<span class="typename">int</span>(f.Fd()), <span class="typename">int</span>(lt))</div><div class="line">		<span class="keyword">if</span> err != syscall.EINTR {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> &fs.PathError{</div><div class="line">			Op:   lt.String(),</div><div class="line">			Path: f.Name(),</div><div class="line">			Err:  err,</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> unlock(f File) error {</div><div class="line">	<span class="keyword">return</span> lock(f, syscall.LOCK_UN)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到它实际是调用系统调用<code>syscall.Flock</code>实现的。</p>
<p>这不属于运行时内定义的同步原语，但是它给我们提供了一个实现文件锁的思路，它甚至还封装了一个<code>Mutex</code>供我们使用。如果有类似的需求，我们可以参考它的实现。</p>
<h3 id="sema">sema</h3>
<p>不太清楚Go为啥不在运行时或者标准库sync中实现信号量，而是在扩展包中去实现，信号量可以说是一个非常广泛使用的同步原语了。</p>
<p>虽然没有在运行时中没有明确实现，但是运行时中的<a href="https://github.com/golang/go/blob/master/src/runtime/sema.go" target="_blank" rel="external">runtime/sema.go</a>提供了与信号量相近功能，而且<code>sync.Mutex</code>严重依赖它。</p>
<p>这个实现旨在提供一个可以在其他同步原语争用的情况下使用的睡眠和唤醒原语，因此，它的目标与Linux的futex相同，但语义要简单得多。<br>Go团队说你不要将这些视为信号量，而是将它们视为一种实现睡眠和唤醒的方式，以确保每个睡眠都与单个唤醒配对，<br>这是有历史原因，这些从贝尔实验室出来的大佬，对于先前他们在Plan 9中的一些想法一脉相承的继承下来，这个设计可以参见 Mullender 和 Cox 的<a href="https://swtch.com/semaphore.pdf" target="_blank" rel="external">Plan 9中的信号量</a>。</p>
<p>比如<code>sync.Mutex</code>睡眠和唤醒的函数其实就是这里实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire</span></div><div class="line"><span class="keyword">func</span> sync_runtime_Semacquire(addr *<span class="typename">uint32</span>) {</div><div class="line">	semacquire1(addr, <span class="constant">false</span>, semaBlockProfile,<span class="number"> 0</span>, waitReasonSemacquire)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname poll_runtime_Semacquire internal/poll.runtime_Semacquire</span></div><div class="line"><span class="keyword">func</span> poll_runtime_Semacquire(addr *<span class="typename">uint32</span>) {</div><div class="line">	semacquire1(addr, <span class="constant">false</span>, semaBlockProfile,<span class="number"> 0</span>, waitReasonSemacquire)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></div><div class="line"><span class="keyword">func</span> sync_runtime_Semrelease(addr *<span class="typename">uint32</span>, handoff <span class="typename">bool</span>, skipframes <span class="typename">int</span>) {</div><div class="line">	semrelease1(addr, handoff, skipframes)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex</span></div><div class="line"><span class="keyword">func</span> sync_runtime_SemacquireMutex(addr *<span class="typename">uint32</span>, lifo <span class="typename">bool</span>, skipframes <span class="typename">int</span>) {</div><div class="line">	semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes, waitReasonSyncMutexLock)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// RWMutex使用的一些函数</span></div><div class="line">...</div></pre></td></tr></table></figure>

<h3 id="atomic">atomic</h3>
<p><a href="https://github.com/golang/go/tree/master/src/runtime/internal/atomic" target="_blank" rel="external">atomic</a> 提供原子操作，独立于<code>sync/atomic</code>，仅供运行时使用。</p>
<p>在大多数平台上，编译器能够识别此包中定义的函数，并用平台特定的内部函数替换它们。在其他平台上，提供了通用的实现。<br>除非另有说明，在此包中定义的操作在处理它们所操作的值时对线程是有序一致的(sequentially consistent)。更具体地说，在一个线程上按特定顺序发生的操作，将始终被另一个线程观察到以完全相同的顺序发生。</p>
<p>因为和特定的CPU架构有关，它的实现针对不同的CPU架构，由不同的指令实现而成，而且基本使用汇编实现，比如AMD64下的Cas实现，使用了<code>LOCK</code> + <code>CMPXCHGL</code>指令：</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TEXT ·Cas(SB),<span class="preprocessor">NOSPLIT</span>,<span class="number">$0</span>-<span class="number">17</span></div><div class="line">	<span class="keyword">MOVQ</span>	<span class="preprocessor">ptr</span>+<span class="number">0</span>(FP), <span class="number">BX</span></div><div class="line">	MOVL	old+<span class="number">8</span>(FP), <span class="number">AX</span></div><div class="line">	MOVL	new+<span class="number">12</span>(FP), <span class="number">CX</span></div><div class="line">	<span class="keyword">LOCK</span></div><div class="line">	CMPXCHGL	<span class="number">CX</span>, <span class="number">0</span>(<span class="number">BX</span>)</div><div class="line">	SETEQ	<span class="keyword">ret</span>+<span class="number">16</span>(FP)</div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

<p>其实<code>sync/atomic</code>下的实现，也是调用这里的实现，否则维护两套代码就太麻烦了，而且可能出现不一致的现象。你看<code>sync/atomic/asm.s</code>:</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">...</span></div><div class="line">TEXT ·CompareAndSwapInt64(SB),NOSPLIT,$<span class="number">0</span></div><div class="line">	JMP	runtime∕internal∕atomic·Cas64(SB)</div><div class="line"></div><div class="line">TEXT ·CompareAndSwapUint64(SB),NOSPLIT,$<span class="number">0</span></div><div class="line">	JMP	runtime∕internal∕atomic·Cas64(SB)</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>它也是调用<code>untime∕internal∕atomic</code>下对应的函数。</p>
<h3 id="singleflight">singleflight</h3>
<p><code>singleflight</code>特别适合大并发情况下许多请求做同一件事情的场景，这个时候只处理一个请求就可以了，其它请求等待那一个请求的结果，这样对下游的压力大大减少，比如在读取cache的时候。</p>
<p>因为它在特定场景下很有用，Go的扩展库中也同样实现了它。</p>
<p>它没有定义在运行时中，而是定义在<a href="https://github.com/golang/go/tree/master/src/internal/singleflight" target="_blank" rel="external">internal/singleflight</a>中。</p>
<p>比如在包<code>net</code>中，我们查找一台主机的IP地址时，如果并发的请求，对资源是很大的浪费，这个时候我们只让一个请求处理就好了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Resolver <span class="keyword">struct</span> {</div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="comment">// lookupGroup merges LookupIPAddr calls together for lookups for the same</span></div><div class="line">	<span class="comment">// host. The lookupGroup key is the LookupIPAddr.host argument.</span></div><div class="line">	<span class="comment">// The return values are ([]IPAddr, error).</span></div><div class="line">	lookupGroup singleflight.Group</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (r *Resolver) lookupIPAddr(ctx context.Context, network, host <span class="typename">string</span>) ([]IPAddr, error) {</div><div class="line">	...</div><div class="line"></div><div class="line">	ch := r.getLookupGroup().DoChan(lookupKey, <span class="keyword">func</span>() (any, error) {</div><div class="line">		<span class="keyword">return</span> testHookLookupIP(lookupGroupCtx, resolverFunc, network, host)</div><div class="line">	})</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章我们来了解一下隐藏在Go运行时中的一些并发原语， 因为运行时是底座和包循环依赖等原因，运行时中很少使用标准库中的并发原语，它有自己的并发原语。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习C++20, 为Go的atomic类型插上一双翅膀]]></title>
    <link href="https://colobu.com/2024/01/06/extend-atomic/"/>
    <id>https://colobu.com/2024/01/06/extend-atomic/</id>
    <published>2024-01-06T03:58:52.000Z</published>
    <updated>2024-02-02T07:54:29.798Z</updated>
    <content type="html"><![CDATA[<p>如果我们将Go语言的并发原语弄的滚瓜烂熟，那么我们使用组合的方式，创造出更高级的并发原语，针对一些特定的并发场景，可以提供更高效的并发原语。</p>
<p>这篇文章就是就是利用atomic中的并发原语和条件变量，组合出类似C++ 20规范中atomic类型的wait/notify_one/notify_all的功能。</p>
<a id="more"></a>
<h2 id="C++20中的wait/notify_one/notify_all">C++20中的wait/notify_one/notify_all</h2>
<p><img src="cpp20-atomic-wait.png" alt=""></p>
<p>在<a href="https://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="external">C++ 20规范</a>中，为atomic类型增加了wait/notify_one/notify_all的功能，这样就可以实现类似Java中的wait/notify/notifyAll的功能.<br>这三个方法类似于Go中的Cond(条件变量)的Wait/Signal/Broadcast方法。</p>
<ul>
<li>wait: 阻塞当前线程，直到被通知且原子值被改变， 类似于Go中的Cond.Wait</li>
<li>notify_one: 通知至少一个阻塞在这个原子值上的线程， 类似于Go中的Cond.Signal</li>
<li>notify_all: 通知所有阻塞在这个原子值上的线程， 类似于Go中的Cond.Broadcast</li>
</ul>
<p>c++也有条件变量，但是和Go的Cond类似，条件变量需要和mutex一起使用，而atomic类型的wait/notify_one/notify_all不需要和mutex一起使用的。</p>
<p>注意wait这个函数，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> wait( T old, std::memory_order order =</div><div class="line">                      std::memory_order::seq_cst ) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div><div class="line"><span class="keyword">void</span> wait( T old, std::memory_order order =</div><div class="line">                      std::memory_order::seq_cst ) <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</div></pre></td></tr></table></figure>

<p>它的行为就像重复下面的操作一样：</p>
<ul>
<li>比较<code>this-&gt;load(order)</code>和<code>old</code>的值<ul>
<li>如果相等，就阻塞当前线程，直到被<code>notify_one()</code> 或者 <code>notify_all()</code>唤醒,或者线程被虚假的解锁</li>
<li>如果不相等，就返回</li>
</ul>
</li>
</ul>
<p>这个函数保证返回时原子值被改变了，不管它是被唤醒的还是使用底层技术以虚假方式取消阻塞。</p>
<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;chrono&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;future&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// 创建原子布尔变量，表示所有任务是否完成</span></div><div class="line">    std::atomic&lt;<span class="keyword">bool</span>&gt; all_tasks_completed{<span class="keyword">false</span>};</div><div class="line">    </div><div class="line">    <span class="comment">// 创建原子无符号整数，表示完成的任务数量</span></div><div class="line">    std::atomic&lt;<span class="keyword">unsigned</span>&gt; completion_count{};</div><div class="line">    </div><div class="line">    <span class="comment">// 创建包含16个std::future&lt;void&gt;对象的数组，用于存储异步任务的future</span></div><div class="line">    std::future&lt;<span class="keyword">void</span>&gt; task_futures[<span class="number">16</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建原子无符号整数，表示未完成的任务数量，初始值为16</span></div><div class="line">    std::atomic&lt;<span class="keyword">unsigned</span>&gt; outstanding_task_count{<span class="number">16</span>};</div><div class="line"></div><div class="line">    <span class="comment">// 生成多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">    <span class="keyword">for</span> (std::future&lt;<span class="keyword">void</span>&gt;& task_future : task_futures)</div><div class="line">        task_future = std::async([&]</div><div class="line">        {</div><div class="line">            <span class="comment">// 模拟真实工作...</span></div><div class="line">            std::this_thread::sleep_for(<span class="number">50</span>ms);</div><div class="line">            </div><div class="line">            <span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">            ++completion_count;</div><div class="line">            --outstanding_task_count;</div><div class="line"></div><div class="line">            <span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">            <span class="keyword">if</span> (outstanding_task_count.load() == <span class="number">0</span>)</div><div class="line">            {</div><div class="line">                all_tasks_completed = <span class="keyword">true</span>;</div><div class="line">                all_tasks_completed.notify_one();</div><div class="line">            }</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有任务完成</span></div><div class="line">    all_tasks_completed.wait(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 输出已完成任务的数量</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Tasks completed = "</span> &lt;&lt; completion_count.load() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个程序创建了16个异步任务，每个任务模拟了一些工作，然后通过原子操作更新已完成任务数量和未完成任务数量。主线程等待所有任务完成后输出已完成任务的数量。</p>
<p><strong>注意</strong>： 由于 <a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="external">ABA</a> 问题，原子值瞬态变化老到另一个值，然后返回到老的值，这个变化可能会被监听者锁遗漏，被Wait方法阻塞的线程无法解锁。</p>
<p>rust也有人提出了这样的需求:<a href="https://www.reddit.com/r/rust/comments/mrkqoy/is_there_a_wait_and_notify_for_atomics/" target="_blank" rel="external">Is there a wait() and notify() for atomics?</a></p>
<h2 id="使用场景">使用场景</h2>
<p>大部分场景下，我们使用C++的<code>std::condition_variable</code>或者Go语言中的<code>sync.Cond</code>就可以了。</p>
<p>比如使用Go语言中的条件变量，我们可以将上面的例子改造成下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> mu sync.Mutex</div><div class="line">	cond := sync.NewCond(&mu)</div><div class="line"></div><div class="line">	<span class="comment">// 任务是否已完成</span></div><div class="line">	<span class="keyword">var</span> completed atomic.Bool</div><div class="line">	<span class="comment">// 已完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> completionCount atomic.Int64</div><div class="line">	<span class="comment">// 未完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> outstandingTaskCount atomic.Int64</div><div class="line">	outstandingTaskCount.Store<span class="number">(16</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 启动多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 16</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="comment">// 模拟真实工作...</span></div><div class="line">			time.Sleep<span class="number">(50</span> * time.Millisecond)</div><div class="line"></div><div class="line">			<span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">			completionCount.Add<span class="number">(1</span>)</div><div class="line">			newValue := outstandingTaskCount.Add<span class="number">(-1</span>)</div><div class="line"></div><div class="line">			<span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">			<span class="keyword">if</span> newValue ==<span class="number"> 0</span> {</div><div class="line">				completed.Store(<span class="constant">true</span>)</div><div class="line">				cond.Signal()</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 等待所有任务完成</span></div><div class="line">	mu.Lock()</div><div class="line">	<span class="keyword">for</span> !completed.Load() {</div><div class="line">		cond.Wait()</div><div class="line">	}</div><div class="line">	mu.Unlock()</div><div class="line"></div><div class="line">	<span class="comment">// 输出已完成任务的数量</span></div><div class="line">	fmt.Printf(<span class="string">"Tasks completed = %v\n"</span>, completionCount.Load())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，我们使用<code>atmoic</code>的类型，加上<code>Cond</code> (包括<code>Mutex</code>)，可以实现变量更改了，并且达到某个条件时，通知等待者的功能。</p>
<p>针对这种使用<code>atmoic</code>的场景，我们是不是可以把<code>atomic</code> + <code>Cond</code>封装成一个新的类型，这样就可以更方便的使用了。</p>
<p>一旦封装起来，就像C++ 20这样做的一样，为atomic类型增加了一个通知的“翅膀”，在条件(配置)监控、消息等待、事件通知的场景中，可以更方便的使用。</p>
<p>接下来就是我做的一个尝试。</p>
<p>相关的代码可以在<a href="https://github.com/smallnest/exp/blob/master/sync/atomicx/type.go" target="_blank" rel="external">github.com/smallnest/exp/sync/atomicx</a>上找到。</p>
<h2 id="使用atomic-XXX和Cond,_实现wait/notify_one/notify_all">使用atomic.XXX和Cond, 实现wait/notify_one/notify_all</h2>
<p>不像Rust、Scala这样的语言，Go语言表达能力还不是那么丰富，所以我们无法在原有的atomic.XXX类型上增加wait/notify_one/notify_all的方法，只能创建一个新的类型，然后在这个类型上增加这三个方法。</p>
<p>我们还是沿用Go语言的<code>Wait/Signal/Broadcast</code>的命名方式，这样使用者就不会感到陌生,而不是C++的<code>wait/notify_one/notify_all</code>命名方式。</p>
<p>你可以看到，标准库atomic包下针对不同的基本类型，有对应的atomic.XXX类型，比如<code>atomic.Bool</code>、<code>atomic.Int32</code>、<code>atomic.Uint64</code>等等，所以我们也沿用这种方式，创建了<code>atomicx.Bool</code>、<code>atomicx.Int32</code>、<code>atomicx.Uint64</code>等等。</p>
<blockquote>
<p>你可以思考一下，为什么Go标准库不写成泛型的方式，，只提供一个<code>atomicx.Atomic[T]</code>类型，这样就可以避免创建这么多的类型了。</p>
</blockquote>
<p>我们以<code>atomicx.Int32</code>为例，看看它的实现。<br>这里我们采用组合的方式，将<code>atomic.Int32</code>和<code>sync.Cond</code>组合在一起，然后在这个组合类型上增加<code>Wait/Signal/Broadcast</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Int32 <span class="keyword">struct</span> {</div><div class="line">	atomic.Int32</div><div class="line"></div><div class="line">	mu      sync.Mutex</div><div class="line">	condvar *sync.Cond</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Wait blocks until the int32 is not equal to the given value.</span></div><div class="line"><span class="keyword">func</span> (ai *Int32) Wait() {</div><div class="line">	v := ai.Load()</div><div class="line"></div><div class="line">	ai.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> ai.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ai.condvar == <span class="constant">nil</span> {</div><div class="line">		ai.condvar = sync.NewCond(&ai.mu)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> ai.Load() == v {</div><div class="line">		ai.condvar.Wait()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Broadcast wakes all goroutines waiting on the int32.</span></div><div class="line"><span class="keyword">func</span> (ai *Int32) Broadcast() {</div><div class="line">	ai.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> ai.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ai.condvar == <span class="constant">nil</span> {</div><div class="line">		ai.condvar = sync.NewCond(&ai.mu)</div><div class="line">	}</div><div class="line"></div><div class="line">	ai.condvar.Broadcast()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Signal wakes one goroutine waiting on the int32.</span></div><div class="line"><span class="keyword">func</span> (ai *Int32) Signal() {</div><div class="line">	ai.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> ai.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ai.condvar == <span class="constant">nil</span> {</div><div class="line">		ai.condvar = sync.NewCond(&ai.mu)</div><div class="line">	}</div><div class="line"></div><div class="line">	ai.condvar.Signal()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们采用Go标准库sync包中的各种同步原语的风格，声明的时候默认零值，不需要<code>new(XXX)</code>方式显式创建，这样使用起来更方便。<br>这样就带来一个问题，怎么初始化<code>sync.Cond</code>字段呢？它是需要<code>NewCond</code> 函数创建的，传入一个<code>Locker</code>。<br>这里我们使用一个技巧，惰式初始化，需要使用它的时候，先请求锁，然后在检查它是否初始化了，如果没有初始化，就初始化它。</p>
<p><code>Wait</code>方法就是不断的<code>Load</code>这个原子值，和初始值进行比较，如果相等，就阻塞当前线程，直到被<code>Signal</code>或者<code>Broadcast</code>唤醒，当值不一致时，返回。</p>
<p><code>Signal</code>和<code>Broadcast</code>方法就是调用<code>sync.Cond</code>的<code>Signal</code>和<code>Broadcast</code>方法。</p>
<p>这是一个比较简单的通过组合的方式实现C++ 20中atomic类型的wait/notify_one/notify_all的功能的例子。<br>相信将Cond和Mutex的实现的代码拆解出来，再加上atomic.XXX的实现，你可能会实现性能更高的同样功能的同步原语，那样代码可能就变得复杂反而不如这种组合的方式更容易维护。</p>
<h2 id="使用atomicx改写上面的例子">使用atomicx改写上面的例子</h2>
<p>既然我们实现了一个封装类型<code>atomicx.Bool</code>,我们就用起来。</p>
<p>那么我们就可以把下面三个字段使用一个<code>var completed atomicx.Bool</code>来替换了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mu sync.Mutex</div><div class="line">cond := sync.NewCond(&mu)</div><div class="line"></div><div class="line"><span class="comment">// 任务是否已完成</span></div><div class="line"><span class="keyword">var</span> completed atomic.Bool</div></pre></td></tr></table></figure>

<p>如果条件满足，我们可以把<code>completed</code>设置为true,并且通知一个等待的goroutine。<br>等待的goroutine的代码也可以简化，只使用一条<code>completed.Wait()</code>就行了，不需要加锁和For循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/exp/sync/atomicx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 任务是否已完成</span></div><div class="line">	<span class="keyword">var</span> completed atomicx.Bool</div><div class="line">	<span class="comment">// 已完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> completionCount atomic.Int64</div><div class="line">	<span class="comment">// 未完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> outstandingTaskCount atomic.Int64</div><div class="line">	outstandingTaskCount.Store<span class="number">(16</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 启动多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 16</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="comment">// 模拟真实工作...</span></div><div class="line">			time.Sleep<span class="number">(50</span> * time.Millisecond)</div><div class="line"></div><div class="line">			<span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">			completionCount.Add<span class="number">(1</span>)</div><div class="line">			newValue := outstandingTaskCount.Add<span class="number">(-1</span>)</div><div class="line"></div><div class="line">			<span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">			<span class="keyword">if</span> newValue ==<span class="number"> 0</span> {</div><div class="line">				completed.Store(<span class="constant">true</span>)</div><div class="line">				completed.Signal()</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 等待所有任务完成</span></div><div class="line">	completed.Wait()</div><div class="line"></div><div class="line">	<span class="comment">// 输出已完成任务的数量</span></div><div class="line">	fmt.Printf(<span class="string">"Tasks completed = %v\n"</span>, completionCount.Load())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>completed.Wait()</code>一定要在<code>completed.Store(true)</code>之前，否则主goroutine可能永远被阻塞。</p>
<h2 id="解决_ABA_问题">解决 ABA 问题</h2>
<p>如果一个原子量快速的从A变成B，然后又快速的从B变成A，那么一个等待者可能会错过这个变化，从而导致它永远阻塞。<br>为了解决这个问题，我们可以在原子量的值的基础上增加一个版本号，每次变化的时候，版本号也会变化，这样等待者就可以检查版本号是否变化了，如果变化了，就不会阻塞。</p>
<p>下面就是定义了一个要原子操作的类型,每次做更改的时候:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Completed <span class="keyword">struct</span> {</div><div class="line">	Value   <span class="typename">bool</span></div><div class="line">	Version <span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样即使completed.Value的值从true变成false，但是Version的值也会变化，这样等待者就不会错过这个变化了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/exp/sync/atomicx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Completed <span class="keyword">struct</span> {</div><div class="line">	Value   <span class="typename">bool</span></div><div class="line">	Version <span class="typename">int64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 任务是否已完成</span></div><div class="line">	<span class="keyword">var</span> completed atomicx.Pointer[Completed]</div><div class="line">	completed.Store(&Completed{Value: <span class="constant">false</span>, Version:<span class="number"> 0</span>})</div><div class="line"></div><div class="line">	<span class="comment">// 已完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> completionCount atomic.Int64</div><div class="line">	<span class="comment">// 未完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> outstandingTaskCount atomic.Int64</div><div class="line">	outstandingTaskCount.Store<span class="number">(16</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 启动多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 16</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="comment">// 模拟真实工作...</span></div><div class="line">			time.Sleep<span class="number">(50</span> * time.Millisecond)</div><div class="line"></div><div class="line">			<span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">			completionCount.Add<span class="number">(1</span>)</div><div class="line">			newValue := outstandingTaskCount.Add<span class="number">(-1</span>)</div><div class="line"></div><div class="line">			<span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">			<span class="keyword">if</span> newValue ==<span class="number"> 0</span> {</div><div class="line">                <span class="comment">// 如果不能确保Version的并发安全修改，下面的代码需要修改成CompareAndSwap的spin的方式</span></div><div class="line">				completed.Store(&Completed{Value: <span class="constant">true</span>, Version: completed.Load().Version +<span class="number"> 1</span>})</div><div class="line">				completed.Store(&Completed{Value: <span class="constant">false</span>, Version: completed.Load().Version +<span class="number"> 1</span>}) <span class="comment">// 伪造一个操作，把值又设置回false</span></div><div class="line">				completed.Signal()</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 等待所有任务完成</span></div><div class="line">	completed.Wait()</div><div class="line"></div><div class="line">	<span class="comment">// 输出已完成任务的数量</span></div><div class="line">	fmt.Printf(<span class="string">"Tasks completed = %+v, %+v\n"</span>, completionCount.Load(), completed.Load())</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>如果我们将Go语言的并发原语弄的滚瓜烂熟，那么我们使用组合的方式，创造出更高级的并发原语，针对一些特定的并发场景，可以提供更高效的并发原语。</p>
<p>这篇文章就是就是利用atomic中的并发原语和条件变量，组合出类似C++ 20规范中atomic类型的wait/notify_one/notify_all的功能。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++中的同步原语]]></title>
    <link href="https://colobu.com/2023/12/26/synchronization-primitives-in-c/"/>
    <id>https://colobu.com/2023/12/26/synchronization-primitives-in-c/</id>
    <published>2023-12-26T14:59:31.000Z</published>
    <updated>2024-02-02T07:54:29.801Z</updated>
    <content type="html"><![CDATA[<p>C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。</p>
<a id="more"></a>
<h2 id="std::thread">std::thread</h2>
<p><code>std::thread</code>是在C++11中引入的，它表示一个可执行的线程。线程允许多个函数并发执行。</p>
<p>线程在关联的线程对象构造完成后立即开始执行（受操作系统调度延迟影响），从作为构造函数参数提供的顶级函数开始。顶级函数的返回值会被忽略，如果它通过抛出异常终止，std::terminate 会被调用。顶级函数可以通过 std::promise 或通过修改共享变量（可能需要同步，参见 std::mutex 和 std::atomic）向调用者传达其返回值或异常。</p>
<p>std::thread 对象也可能处于不表示任何线程的状态（在默认构造、移动构造、分离或加入之后），而且执行线程可能不与任何线程对象关联（在分离之后）。</p>
<p>没有两个 std::thread 对象可以表示同一个执行线程；std::thread 不可复制构造或复制赋值，尽管它是可移动构造和可移动赋值的。</p>
<p>你需要手动管理线程的生命周期，包括启动和加入（或分离）线程。如果你忘记在一个<code>std::thread</code>对象销毁之前加入（<code>join</code>）或分离（<code>detach</code>）它的线程，程序将会终止（因为<code>std::thread</code>的析构函数会调用<code>std::terminate</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> threadFunction() {</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from thread!\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::thread t(threadFunction);</div><div class="line">    <span class="comment">// 必须在t销毁之前对其调用join或detach</span></div><div class="line">    t.join(); <span class="comment">// 等待线程结束</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="std::jthread">std::jthread</h2>
<p><code>std::jthread</code>是在C++20中引入的，它提供了一些改进和附加功能，相比于<code>std::thread</code>，使得线程管理变得更加容易和安全。</p>
<p>它在std::thread的基础上增加了自动的线程加入功能。std::jthread的一个关键特性是它的析构函数会自动请求线程停止（如果支持的话）并等待线程完成，从而减少了程序员需要手动管理线程生命周期的需求。</p>
<p>此外，std::jthread支持协作式中断，它提供了一种机制，使得线程可以被请求停止执行。这是通过传递一个std::stop_token来实现的，线程函数可以定期检查这个stop_token来决定是否应该停止执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> threadFunction(std::stop_token stoken) {</div><div class="line">    <span class="keyword">while</span> (!stoken.stop_requested()) { <span class="comment">// 检查是否请求停止线程</span></div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from jthread!\n"</span>;</div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    }</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping as requested.\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::jthread jt(threadFunction);</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">3</span>));</div><div class="line">    <span class="comment">// 不需要手动调用join，析构函数会自动处理</span></div><div class="line">    <span class="comment">// jt.request_stop(); 如果需要提前请求停止线程，则调用这个</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的例子中，<code>std::jthread</code>的析构函数会自动调用<code>request_stop</code>来请求线程函数停止，然后等待线程完成。这使得使用<code>std::jthread</code>比<code>std::thread</code>更加安全和方便，因为它消除了忘记加入或分离线程时可能出现的问题。</p>
<p>总结来说，<code>std::jthread</code>在<code>std::thread</code>的基础上提供了自动加入和协作式中断的功能，从而简化了线程的管理。如果你使用的是C++20或更高版本，优先考虑使用<code>std::jthread</code>。</p>
<h2 id="atomic">atomic</h2>
<h3 id="std::atomic">std::atomic</h3>
<p><code>std::atomic</code> 是一个模板类，提供了一种机制来安全地在多线程环境中操作共享数据，而不需要使用互斥锁。<code>std::atomic</code> 类型保证了基本的原子操作，比如读取、写入、递增和递减等，都是原子性的，也就是说在一个操作执行完毕前，不会被其他线程打断。</p>
<p>原子性意味着当一个线程正在执行原子操作时，没有其他线程可以同时执行任何其他对同一数据的原子操作。此外，C++11 引入的内存模型定义了原子操作的内存顺序（memory order），这是一个非常复杂的主题，决定了在不同线程中操作之间的可见性和排序。我在《并发编程顶峰对决： Go vs Rust》讲了Rust的内存顺序模型，也提到了Rust的内存顺序模型和C++的内存顺序模型，这里就不赘述了,总之内存序包含下面几种类型，你应该正确且清晰的使用它们：</p>
<ul>
<li>std::memory_order_relaxed</li>
<li>std:: memory_order_consume</li>
<li>std::memory_order_acquire</li>
<li>std::memory_order_release</li>
<li>std::memory_order_acq_rel</li>
<li>std::memory_order_seq_cst</li>
</ul>
<p><code>std::atomic</code> 类型的对象可以通过调用成员函数<code>load</code>和<code>store</code>来读取和写入，也可以通过<code>operator++</code>和<code>operator--</code>来递增和递减。<code>std::atomic</code> 类型的对象还可以通过调用成员函数<code>exchange</code>来交换值，通过调用成员函数<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>来比较和交换值。</p>
<p><code>wait</code>、<code>notify</code>和<code>notify_all</code>函数可以用来等待和通知其他线程，这些函数在C++20中引入。有点像条件变量。</p>
<p>通过<code>std::atomic</code>类模板，我们可以创建原子类型的对象，比如<code>std::atomic&lt;int&gt;</code>，<code>std::atomic&lt;bool&gt;</code>，<code>std::atomic&lt;std::string&gt;</code>等等。<code>std::atomic</code>类模板还提供了一些特化版本，比如<code>std::atomic_flag</code>，<code>std::atomic_bool</code>，<code>std::atomic_int</code>，<code>std::atomic_uint</code>，<code>std::atomic_llong</code>等等。</p>
<p>下面是一个计数器的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::atomic&lt;<span class="keyword">int</span>&gt; counter(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> increment() {</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) {</div><div class="line">        counter.fetch_add(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment));</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& t : threads) {</div><div class="line">        t.join();</div><div class="line">    }</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Counter: "</span> &lt;&lt; counter.load() &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，10个线程并发地递增一个std::atomic<int>计数器。由于counter是原子类型，所以每个线程的修改都是原子操作，不会相互干扰。最终的计数器值应该是100000。</int></p>
<h3 id="std::atomic_flag">std::atomic_flag</h3>
<p><code>std::atomic_flag</code> 是 C++11 中引入的原子类型，它是最简单的原子类型，提供了一个布尔标志，可以用来进行简单的锁定操作。由于其简单性，<code>std::atomic_flag</code> 通常可以实现为一个非常高效的原子类型，因此它在实现自旋锁等低级同步原语时非常有用。</p>
<p><code>std::atomic_flag</code> 保证是 <code>lock-free</code> 的，即不会引起调用线程的阻塞。这是 <code>std::atomic_flag</code> 相对于其他原子类型的一个独特优点，因为其他原子类型在一些平台上可能不是 <code>lock-free</code> 的。</p>
<p>std::atomic_flag 提供以下几个主要操作：</p>
<ul>
<li>clear(): 将标志设置为 false。</li>
<li>test_and_set(): 测试标志的当前值，然后将其设置为 true。这个操作是原子的，即测试和设置是一个不可分割的步骤。</li>
<li>test(): C++20 新增的操作，测试标志的当前值而不修改它。</li>
<li>wait(): C++20 新增的操作，如果标志为 true，则阻塞调用线程。</li>
<li>notify_one(): C++20 新增的操作，通知等待线程中的一个线程。</li>
<li>notify_all(): C++20 新增的操作，通知等待线程中的所有线程。</li>
</ul>
<p>下面这个例子是检查 atomic_flag 是否已被设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"></div><div class="line">std::atomic_flag flag = ATOMIC_FLAG_INIT;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="comment">// 设置标志</span></div><div class="line">    flag.test_and_set();</div><div class="line">    </div><div class="line">    <span class="comment">// 检查标志是否已经设置</span></div><div class="line">    <span class="keyword">if</span> (flag.test()) {</div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Flag is set.\n"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 清除标志</span></div><div class="line">    flag.clear();</div><div class="line">    </div><div class="line">    <span class="comment">// 再次检查标志</span></div><div class="line">    <span class="keyword">if</span> (!flag.test()) {</div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Flag is cleared.\n"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="std::atomic_ref">std::atomic_ref</h3>
<p><code>std::atomic_ref</code> 是 C++20 引入的一个模板类，它提供了对非原子类型的原子操作。这意味着你可以将 <code>std::atomic_ref</code> 对象绑定到非原子类型的引用上，并执行原子操作，而无需将该类型本身声明为原子类型。这在你需要对现有数据结构中的某个成员进行原子操作，而不想更改数据结构定义时非常有用。</p>
<p><code>std::atomic_ref</code> 的特性</p>
<ul>
<li><code>std::atomic_ref</code> 通过引用传递给它的对象，并提供原子访问。</li>
<li>它对绑定的对象执行原子操作，如加载(load)、存储(store)、增加(fetch_add)、减少(fetch_sub)等。</li>
<li><code>std::atomic_ref</code> 不拥有它所绑定的对象，故该对象的生命周期必须超过 std::atomic_ref 对象的生命周期。</li>
<li>你可以在多个 <code>std::atomic_ref</code> 实例之间共享同一个对象，但是要保证这些实例不会同时访问该对象。</li>
</ul>
<p>std::atomic_ref 的主要成员函数</p>
<ul>
<li>store(T desired, std::memory_order order = std::memory_order_seq_cst): 将 desired 值原子地存储到引用的对象中。</li>
<li>T load(std::memory_order order = std::memory_order_seq_cst) const: 原子地加载并返回引用的对象的值。</li>
<li>T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst): 原子地将 arg 添加到引用的对象的当前值，并返回之前的值。</li>
<li>T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst): 原子地从引用的对象的当前值中减去 arg，并返回之前的值。</li>
<li>bool compare_exchange_weak(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst): 原子地比较引用的对象的值与 expected，如果相同，则将该对象的值设置为 desired。</li>
<li>bool compare_exchange_strong(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst): 类似于 compare_exchange_weak，但具有更强的保证，防止假失败。</li>
<li>wait(): C++20 新增的操作，如果标志为 true，则阻塞调用线程。</li>
<li>notify_one(): C++20 新增的操作，通知等待线程中的一个线程。</li>
<li>notify_all(): C++20 新增的操作，通知等待线程中的所有线程。</li>
</ul>
<p>以下是一个使用 std::atomic_ref 的简单示例，演示了如何对一个共享的 int 变量执行原子操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="keyword">int</span> shared_value = <span class="number">0</span>;</div><div class="line">    std::atomic_ref&lt;<span class="keyword">int</span>&gt; atomic_ref(shared_value);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> incrementer = [&atomic_ref]() {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">            atomic_ref.fetch_add(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子地增加 shared_value 的值</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    <span class="comment">// 创建 10 个线程，每个线程都增加 shared_value 的值</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.emplace_back(incrementer);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final value of shared_value: "</span> &lt;&lt; shared_value &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// 正确的输出应该是 1000</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个普通的 int 类型变量 <code>shared_value</code> 和一个 <code>std::atomic_ref&lt;int&gt;</code> 实例 <code>atomic_ref</code>，后者引用了前者。然后我们启动了 10 个线程，每个线程都通过 <code>atomic_ref</code> 原子地对 <code>shared_value</code> 执行 100 次增加操作。在所有线程完成后，我们期望 <code>shared_value</code> 的最终值为 1000。</p>
<h2 id="std::mutex">std::mutex</h2>
<p><code>std::mutex</code> 用于保护共享数据，避免多个线程同时访问导致的数据竞争和不一致性。当多个线程尝试同时修改同一数据时，<code>std::mutex</code> 提供了一种机制来确保只有一个线程能够访问数据，其余试图访问该数据的线程将被阻塞，直到拥有互斥锁的线程释放锁为止。</p>
<p><code>std::mutex</code> 的主要操作</p>
<ul>
<li>lock(): 阻塞当前线程，直到能够锁定该互斥锁。如果互斥锁已被其他线程锁定，则当前线程将等待（阻塞），直到互斥锁被解锁。</li>
<li>unlock(): 解锁互斥锁，允许其他正在等待的线程能够尝试锁定互斥锁。</li>
<li>try_lock(): 尝试锁定互斥锁，如果互斥锁当前未被锁定，则锁定它并立即返回 true；如果已被其他线程锁定，则不会阻塞当前线程，立即返回 false。</li>
</ul>
<p>使用 <code>std::mutex</code> 保护共享数据的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> increment_counter() {</div><div class="line">    mtx.lock(); <span class="comment">// 获取锁</span></div><div class="line">    ++counter; <span class="comment">// 修改共享数据</span></div><div class="line">    mtx.unlock(); <span class="comment">// 释放锁</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发环境</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment_counter));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : threads) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value: "</span> &lt;&lt; counter &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，100个线程尝试并发地增加一个共享计数器。没有互斥锁的情况下，多个线程可能同时读写同一内存位置，导致计数器的值不正确。通过使用 std::mutex，我们确保了每次只有一个线程能够增加计数器，从而保证了最终结果的正确性。</p>
<p>可以使用<code>std::lock_guard</code> 管理 <code>std::mutex</code> 的锁定和解锁,类似Rust:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> increment_counter() {</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mtx); <span class="comment">// 创建 lock_guard 对象时自动获取锁，并在作用域结束时自动释放锁</span></div><div class="line">    ++counter; <span class="comment">// 修改共享数据</span></div><div class="line">    <span class="comment">// lock_guard 对象析构时自动调用 unlock</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发环境</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment_counter));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : threads) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value: "</span> &lt;&lt; counter &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了基本的 <code>std::mutex</code>，还提供了几种其他类型的锁，用于满足不同的同步需求。以下是一些常见的锁类型：</p>
<ul>
<li>std::recursive_mutex<br><code>std::recursive_mutex</code> 是一种特殊类型的互斥锁，它允许同一个线程多次对同一个互斥锁加锁（即递归锁定）。每次对 <code>std::recursive_mutex</code> 的成功锁定都必须由相应数量的解锁操作与之匹配。这适用于递归函数调用，其中函数可能会直接或间接地多次请求同一互斥锁。</li>
<li>std::timed_mutex<br><code>std::timed_mutex</code> 是互斥锁的一个扩展，它提供了尝试锁定一段时间的功能。如果锁在指定时间内未被获取，则尝试锁定操作失败并返回。它提供了两个额外的成员函数：<code>try_lock_for()</code> 和 <code>try_lock_until()</code>，分别用于指定等待锁定的时间长度和绝对时间点。</li>
<li>std::recursive_timed_mutex<br><code>std::recursive_timed_mutex</code> 结合了 <code>std::recursive_mutex</code> 和 <code>std::timed_mutex</code> 的功能，允许一个线程对同一个互斥锁进行多次锁定，并提供了基于时间的锁定尝试。</li>
<li>std::shared_mutex<br><code>std::shared_mutex</code> 是一个读写锁，它允许多个线程同时读取共享数据（共享锁定），但一次只允许一个线程写入（独占锁定）。它提供了 <code>lock_shared()</code> 和 <code>unlock_shared()</code> 来管理共享锁定，以及 <code>lock()</code> 和 <code>unlock()</code> 来管理独占锁定。</li>
<li>std::shared_timed_mutex<br><code>std::shared_timed_mutex</code> 结合了 <code>std::shared_mutex</code> 和 <code>std::timed_mutex</code> 的特性，提供了时间限制的读写锁。它允许多个线程在一段时间内尝试以共享或独占方式锁定互斥锁。</li>
</ul>
<p>还有一些辅助管理mutex的类：</p>
<ul>
<li><p>std::lock_guard<br><code>std::lock_guard</code> 是一个作用域锁，当创建它的对象时自动获取互斥锁，并在该对象的生命周期结束时自动释放互斥锁。<code>std::lock_guard</code> 不支持显式的解锁操作或条件等待。</p>
</li>
<li><p>std::unique_lock<br><code>std::unique_lock</code> 是一个灵活的作用域锁，它提供了比 <code>std::lock_guard</code> 更多的功能，包括延迟锁定、时间限制的锁定尝试、递归锁定以及条件变量的支持。<code>std::unique_lock</code> 对象可以在其生命周期中多次锁定和解锁关联的互斥锁。</p>
</li>
<li><p>std::scoped_lock (C++17)<br><code>std::scoped_lock</code> 是 C++17 引入的一个作用域锁，它可以锁定一个或多个互斥锁，而无需担心死锁。它在内部使用了一个死锁避免算法（如锁的排序获取），确保在多个互斥锁的情况下不会发生死锁。</p>
</li>
</ul>
<p>一个读写锁的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;shared_mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::shared_mutex rw_mutex;</div><div class="line"><span class="keyword">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> reader(<span class="keyword">int</span> id) {</div><div class="line">    std::shared_lock&lt;std::shared_mutex&gt; lock(rw_mutex); <span class="comment">// 获取共享锁</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reader #"</span> &lt;&lt; id &lt;&lt; <span class="string">" read value: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> writer(<span class="keyword">int</span> id) {</div><div class="line">    std::unique_lock&lt;std::shared_mutex&gt; lock(rw_mutex); <span class="comment">// 获取独占锁</span></div><div class="line">    ++shared_data;</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writer #"</span> &lt;&lt; id &lt;&lt; <span class="string">" wrote value: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> readers;</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> writers;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建读者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</div><div class="line">        readers.push_back(std::thread(reader, i));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 创建写者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        writers.push_back(std::thread(writer, i));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待读者线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : readers) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待写者线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : writers) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::shared_mutex</code> 被用作一个读写锁来保护共享数据。读者线程使用 <code>std::shared_lock</code> 获取共享锁，这允许多个读者线程同时读取数据。写者线程使用 <code>std::unique_lock</code> 获取独占锁，这确保了在写入数据时只有一个写者线程可以访问数据。</p>
<h2 id="std::condition_variable">std::condition_variable</h2>
<p><code>std::condition_variable</code> 用于在多线程程序中进行线程间的通知和等待操作。它允许一个或多个线程在某些条件成立之前挂起（等待），直到另一个线程通知它们条件已经满足。<br><code>std::condition_variable</code> 通常与 <code>std::mutex</code>（或 <code>std::unique_lock</code>）一起使用，以保护共享数据并提供安全的同步机制。</p>
<p>主要方法：</p>
<ul>
<li>wait(): 阻塞当前线程，直到其他线程调用 notify_one() 或 notify_all()。在等待期间，互斥锁会被释放，以允许其他线程修改共享数据。当条件变量被通知时，线程会被唤醒，并在返回前重新获取互斥锁。</li>
<li>notify_one(): 唤醒一个等待的线程。如果没有线程在等待，则调用没有任何效果。</li>
<li>notify_all(): 唤醒所有等待的线程。如果没有线程在等待，则调用没有任何效果。</li>
<li>wait_for(): 阻塞当前线程一段时间，或直到被通知。如果在指定的时间段内没有接收到通知，线程会自动唤醒。</li>
<li>wait_until(): 阻塞当前线程直到指定的时间点，或直到被通知。如果到达指定的时间点时没有接收到通知，线程会自动唤醒。</li>
</ul>
<p>下面是一个使用 <code>std::condition_variable</code> 的简单示例，演示了生产者-消费者问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;condition_variable&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line">std::condition_variable cv; <span class="comment">// 条件变量</span></div><div class="line">std::<span class="stl_container"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span> product_queue; <span class="comment">// 共享数据队列</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> producer(<span class="keyword">int</span> id) {</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx); <span class="comment">// 加锁</span></div><div class="line">    product_queue.push(id); <span class="comment">// 生产产品</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer "</span> &lt;&lt; id &lt;&lt; <span class="string">" produced a product."</span> &lt;&lt; std::endl;</div><div class="line">    lck.unlock(); <span class="comment">// 解锁</span></div><div class="line">    cv.notify_one(); <span class="comment">// 通知一个消费者</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> consumer() {</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx); <span class="comment">// 加锁</span></div><div class="line">    <span class="keyword">while</span> (product_queue.empty()) { <span class="comment">// 如果队列为空，则等待</span></div><div class="line">        cv.wait(lck); <span class="comment">// 在这里，互斥锁会被释放</span></div><div class="line">    }</div><div class="line">    <span class="keyword">int</span> product = product_queue.front();</div><div class="line">    product_queue.pop();</div><div class="line">    lck.unlock(); <span class="comment">// 解锁</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer consumed product "</span> &lt;&lt; product &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::thread consumers[<span class="number">2</span>];</div><div class="line">    std::thread producers[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建消费者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        consumers[i] = std::thread(consumer);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 创建生产者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        producers[i] = std::thread(producer, i+<span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待生产者线程结束</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        producers[i].join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待消费者线程结束</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        consumers[i].join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程生产产品并将其放入队列中，然后通过调用 cv.notify_one() 唤醒一个等待的消费者线程。消费者线程在队列为空时调用 cv.wait() 进入等待状态，等待生产者的通知。当生产者生产了一个产品后，消费者线程被唤醒，从队列中取出产品并消费它。</p>
<p><strong>注意事项</strong>: (和Go的Cond类似)</p>
<ul>
<li>使用 <code>std::condition_variable</code> 时，应该总是和一个互斥锁一起使用，以避免竞争条件。</li>
<li>在调用 <code>wait()</code>、<code>wait_for()</code> 或 <code>wait_until()</code> 时，互斥锁必须已被锁定。这些函数会在开始等待时自动释放锁，并在线程被唤醒时重新获取锁。</li>
<li><code>std::condition_variable</code> 的 <code>wait()</code> 函数可能会出现&quot;虚假唤醒&quot;，即在没有收到通知的情况下线程可能被唤醒。因此，通常需要在一个循环中使用 <code>wait()</code>，并检查等待条件是否满足。</li>
<li><code>notify_one()</code> 和 <code>notify_all()</code> 不需要持有互斥锁，但通常会在更新共享数据并持有互斥锁后调用它们。</li>
<li><code>std::condition_variable</code> 只能与 <code>std::unique_lock&lt;std::mutex&gt;</code> 一起使用，不能直接与 <code>std::mutex</code> 一起使用。如果你需要和 <code>std::mutex</code> 一起使用条件变量，请使用 <code>std::condition_variable_any</code>。</li>
</ul>
<h2 id="semaphore">semaphore</h2>
<p>在 C++20 之前，标准库没有提供信号量（semaphore）的实现，但是在 C++20 中引入了两种类型的信号量：<code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code>。</p>
<h3 id="std::counting_semaphore">std::counting_semaphore</h3>
<p><code>std::counting_semaphore</code> 是一种通用的同步原语，用于控制对<strong>有限数量资源</strong>的访问。它维护一个内部的计数器，表示可用资源的数量。计数器的值可以增加（通过 <code>release()</code> 函数）或减少（通过 <code>acquire()</code> 函数）。</p>
<p>信号量的主要操作包括：</p>
<ul>
<li>acquire(): 减少信号量的计数器值。如果计数器的当前值大于零，调用 acquire() 将减少计数器的值，并允许线程继续执行。如果计数器值为零，则调用线程将阻塞，直到其他线程释放资源。</li>
<li>release(): 增加信号量的计数器值。调用 release() 会将计数器的值增加一定数量（默认为1），并可能唤醒正在等待的线程。</li>
<li>try_acquire(): 尝试获取资源，如果信号量的计数器值大于零，则减少计数器并返回 true；如果计数器值为零，则不阻塞，直接返回 false。</li>
</ul>
<p><code>std::counting_semaphore</code> 的计数器值可以大于1，因此它可以用于多个资源的同步。例如，可以用它来实现连接池，限制同时运行的线程数量，等等。</p>
<h3 id="std::binary_semaphore">std::binary_semaphore</h3>
<p><code>std::binary_semaphore</code> 是 <code>std::counting_semaphore</code> 的一个特例，其计数器值限定为最多1。这意味着它可以被看作是一个可以阻塞线程的布尔标志。</p>
<p><code>std::binary_semaphore</code> 的行为类似于互斥锁（<code>mutex</code>），但与互斥锁不同的是，<code>std::binary_semaphore</code> 不要求同一个线程执行 <code>acquire()</code> 和 <code>release()</code>。这使得信号量可以用于线程间的通知和同步，而不仅仅是互斥。</p>
<p>下面是一个使用<code>std::counting_semaphore</code>的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;semaphore&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 初始化信号量，允许同时有3个线程访问资源。</span></div><div class="line">std::counting_semaphore&lt;<span class="number">3</span>&gt; sem(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> access_resource(<span class="keyword">int</span> thread_id) {</div><div class="line">    <span class="comment">// 请求访问资源</span></div><div class="line">    sem.acquire();</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">" is accessing the resource."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 模拟资源访问</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">" is releasing the resource."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// 释放资源</span></div><div class="line">    sem.release();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发资源访问</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.emplace_back(access_resource, i);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="std::barrier">std::barrier</h2>
<p><code>std::barrier</code> 也是 C++20 引入的一个同步原语，它允许一组线程相互等待，直到所有线程都达到某个同步点（称为屏障点或栅栏点），然后再继续执行。<code>std::barrier</code> 可以用于协调并行算法中的线程，确保所有线程都完成了某个阶段的工作，然后再一起进入下一个阶段。</p>
<p>std::barrier 的主要特性</p>
<ul>
<li>std::barrier 可以配置一个可调用对象（通常是一个函数或 lambda 表达式），当所有线程都到达屏障点时，这个可调用对象会被执行。这可以用于在所有线程继续之前进行一些初始化或清理工作。</li>
<li>std::barrier 是可重用的，这意味着一旦所有线程通过了屏障点，它可以被用于下一个同步点。</li>
<li>std::barrier 的构造函数接受一个表示线程总数的参数，以及一个可选的可调用对象。</li>
</ul>
<p>std::barrier 的主要成员函数</p>
<ul>
<li>arrive_and_wait(): 该函数使调用线程到达屏障点并等待其他线程。当最后一个线程调用 arrive_and_wait() 时，所有线程都被释放，并且可调用对象（如果有）被执行。</li>
<li>arrive(): 该函数使调用线程到达屏障点但不等待。它可以用于线程通知已到达屏障点，但随后立即继续执行其他任务。</li>
<li>wait(): 该函数使已到达屏障点的线程等待其他线程。它通常与 arrive() 配合使用。</li>
<li>arrive_and_drop(): 该函数使调用线程到达屏障点并永久退出屏障。它将屏障点的期望线程总数减少一个。这对于动态线程管理很有用。</li>
</ul>
<p>以下是一个使用 std::barrier 的简单示例，演示了如何同步多个线程在屏障点上相互等待:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;barrier&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 创建一个屏障，用于同步三个线程</span></div><div class="line">std::barrier sync_point(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> work(<span class="keyword">int</span> id) {</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is doing some work before the barrier."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行前半部分的工作</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 等待屏障点，等待其他线程</span></div><div class="line">    sync_point.arrive_and_wait();</div><div class="line"></div><div class="line">    <span class="comment">// 当所有线程都达到屏障点时，继续执行后半部分的工作</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is doing some work after the barrier."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line"></div><div class="line">    <span class="comment">// 启动三个工作线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</div><div class="line">        threads.emplace_back(work, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::barrier</code> 对象 <code>sync_point</code>，它配置为同步三个线程。每个线程都执行一些工作，然后调用 <code>sync_point.arrive_and_wait()</code> 来等待其他线程。一旦所有三个线程都到达屏障点（即都调用了 <code>arrive_and_wait()</code>），它们将一起继续执行后面的代码。</p>
<p><code>std::barrier</code> 是一种强大的同步工具，特别适用于需要分阶段执行的并行算法，确保在算法的每个阶段开始前，所有线程都已完成前一个阶段的工作。这有助于避免竞争条件，确保算法的正确执行。</p>
<h2 id="std::latch">std::latch</h2>
<p><code>std::latch</code> 也是 C++20 引入的一个同步原语，它使一组线程可以等待直到一个给定数量的操作完成。它是一个一次性的屏障，一旦触发打开，就不能再重置或再次使用。<code>std::latch</code> 用于在多个线程之间同步操作，允许一个线程等待一个或多个线程完成某些操作。类似Java中的CountDownLatch。</p>
<p>std::latch 的主要特性</p>
<ul>
<li>std::latch 在构造时接受一个计数值，这个值表示需要等待的操作数。</li>
<li>当线程完成它的操作时，它调用 count_down() 方法来减少 std::latch 的计数器。</li>
<li>线程可以调用 wait() 方法来阻塞，直到 std::latch 的计数器达到零。</li>
<li>std::latch 可以有多个线程同时等待计数器达到零。</li>
<li>一旦 std::latch 的计数器达到零，所有调用 wait() 的线程都将被释放，之后的任何 wait() 调用都会立即返回。</li>
<li>std::latch 提供了一个 try_wait() 方法，该方法立即返回并告知调用者 std::latch 是否已经触发（计数器是否已经为零）。</li>
</ul>
<p>std::latch 的主要成员函数</p>
<ul>
<li>count_down(): 减少 std::latch 的计数器。如果计数器达到零，所有等待的线程都将被释放。</li>
<li>wait(): 阻塞调用线程，直到 std::latch 的计数器为零。</li>
<li>try_wait(): 检查 std::latch 的计数器是否为零，不阻塞调用线程。</li>
</ul>
<p>以下是一个使用 std::latch 的简单示例，演示了如何同步多个线程完成初始化操作后，主线程才继续执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;latch&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 创建一个 std::latch 对象，用于等待三个线程完成初始化</span></div><div class="line">std::latch initialization_latch(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> initialize_system(<span class="keyword">int</span> id) {</div><div class="line">    <span class="comment">// 模拟一些初始化工作</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is initializing."</span> &lt;&lt; std::endl;</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; id &lt;&lt; <span class="string">" initialization complete."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 完成工作后，调用 count_down() 减少 latch 的计数</span></div><div class="line">    initialization_latch.count_down();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line"></div><div class="line">    <span class="comment">// 启动三个线程以执行系统初始化</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</div><div class="line">        threads.emplace_back(initialize_system, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 主线程等待所有初始化完成</span></div><div class="line">    initialization_latch.wait();</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All systems are initialized. Main thread is proceeding."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::latch</code> 用于确保三个并发运行的初始化操作都完成了，主线程才开始执行后续的任务。每个初始化线程在完成初始化后调用 <code>initialization_latch.count_down()</code>，这将减少 <code>std::latch</code> 的计数器。主线程调用 <code>initialization_latch.wait()</code> 来等待所有的初始化操作完成。一旦所有的初始化操作都调用了 <code>count_down()</code>，<code>std::latch</code> 的计数器达到零，主线程将继续执行。</p>
<p><code>std::latch</code> 是一个非常有用的同步工具，特别是在涉及一次性事件或需要多个线程完成启动步骤之后才能继续的场景中。它简化了在这些情况下的线程协调。</p>
<h2 id="std::promise、std::future_和_std::async">std::promise、std::future 和 std::async</h2>
<p><code>std::promise</code> 和 <code>std::future</code> 是 C++11 引入的同步原语，它们提供了一种在线程之间传递值的机制，也可以用于线程之间的同步。<code>std::async</code> 是 C++11 引入的一个函数模板，用于异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便在将来某个时间点获取该函数的结果。</p>
<h3 id="std::promise">std::promise</h3>
<p><code>std::promise</code> 允许你在某个线程中存储一个值或异常，该值或异常可以在将来某个时刻被另一个线程检索。当创建 <code>std::promise</code> 对象时，它与一个 <code>std::future</code> 对象相关联，<code>std::future</code> 对象可用于访问 <code>std::promise</code> 中存储的值。</p>
<p>主要成员函数包括：</p>
<ul>
<li>set_value(const T&amp; value): 用来设置值，这会导致与之相关联的 std::future 对象变为 ready 状态，之后可以从中获取这个值。</li>
<li>set_exception(std::exception_ptr p): 用来设置异常，这也会导致相关联的 std::future 对象变为 ready 状态，但尝试从中获取值会引发异常。</li>
<li>get_future(): 返回与 std::promise 对象相关联的 std::future 对象。</li>
</ul>
<h3 id="std::future">std::future</h3>
<p><code>std::future</code> 提供了一种访问异步操作结果的机制。它与 <code>std::promise</code> 对象相关联，用于获取通过 <code>promise</code> 设置的值或异常。</p>
<p>主要成员函数包括：</p>
<ul>
<li>get(): 获取存储在 std::promise 中的值，如果值还未被设置，会阻塞调用线程直到值变为可用。如果 promise 中存储了异常，则调用 get() 会抛出该异常。</li>
<li>wait(): 等待异步操作完成，不返回结果。</li>
<li>valid(): 检查 future 对象是否与一个共享状态相关联（即它是否有值可以获取）。</li>
</ul>
<h2 id="std::async">std::async</h2>
<p><code>std::async</code> 是一个函数模板，用于启动一个异步任务，它的返回类型是 <code>std::future</code>，通过该 <code>future</code> 可以访问异步任务的结果。当调用 <code>std::async</code> 时，可以指定一个函数或可调用对象，以及传递给该函数的参数。<code>std::async</code> 可以指定启动策略，例如 <code>std::launch::async</code>（在新线程中运行）或 <code>std::launch::deferred</code>（延迟执行，直到调用 <code>std::future::get()</code> 或 <code>wait()</code>）。</p>
<p>以下是一个使用 <code>std::promise</code> 和 <code>std::future</code> 的简单示例，模拟了一个异步计算任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;future&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="comment">// 创建一个 promise 对象</span></div><div class="line">    std::promise&lt;<span class="keyword">int</span>&gt; prom;</div><div class="line"></div><div class="line">    <span class="comment">// 从 promise 中获取 future</span></div><div class="line">    std::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future();</div><div class="line"></div><div class="line">    <span class="comment">// 启动一个线程来完成一个计算任务并设置 promise 的值</span></div><div class="line">    std::thread t([&prom]() {</div><div class="line">        <span class="comment">// 模拟一些计算</span></div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">2</span>));</div><div class="line">        prom.set_value(<span class="number">42</span>); <span class="comment">// 设置 promise 的值</span></div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 在主线程中，我们可以等待 future 变为 ready 并获取值</span></div><div class="line">    <span class="keyword">int</span> result = fut.get();  <span class="comment">// 这里会阻塞直到线程设置了 promise 的值</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span> &lt;&lt; result &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    t.join();  <span class="comment">// 等待线程完成</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::async</code> 用于启动一个新线程来执行 <code>compute</code> 函数。通过返回的 <code>std::future</code> 对象，主线程可以在稍后获取异步计算的结果。如果在此期间尚未完成计算，调用 <code>fut.get()</code> 将会阻塞主线程。</p>
<p><code>std::promise</code>、<code>std::future</code> 和 <code>std::async</code> 提供了 C++ 中进行异步编程的基础设施，允许开发者在不同线程之间传递数据和同步操作，同时将并发复杂性降到最低。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。</p>
]]>
    
    </summary>
    
      <category term="C++" scheme="https://colobu.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go http.ServeMux中的模式匹配]]></title>
    <link href="https://colobu.com/2023/12/25/patterns-in-ServeMux-HandleFunc/"/>
    <id>https://colobu.com/2023/12/25/patterns-in-ServeMux-HandleFunc/</id>
    <published>2023-12-25T14:42:10.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.22中一个很大的变化是<code>http.ServeMux</code>中的模式匹配，先前这个功能是很多第三方的web框架或者router库实现的。</p>
<p>我们很有必要好好研究它，将来在实现HTTP API的时候可能优先使用它。</p>
<a id="more"></a>
<p><code>http.ServeMux</code>是一个HTTP请求多路复用器,它将每个传入请求的URL与已注册的模式列表进行匹配，并调用与最接近URL匹配的模式对应的处理程序。</p>
<p>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mux.HandleFunc(<span class="string">"POST /items/create"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprint(w, <span class="string">"POST item created"</span>)</div><div class="line">})</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"/items/create"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprint(w, <span class="string">"item created"</span>)</div><div class="line">})</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"/items/{id}"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    id := r.PathValue(<span class="string">"id"</span>)</div><div class="line">    fmt.Fprintf(w, <span class="string">"Item ID = %s"</span>, id)</div><div class="line">})</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"/files/{path...}"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    path := r.PathValue(<span class="string">"path"</span>)</div><div class="line">    fmt.Fprintf(w, <span class="string">"File path = %s"</span>, path)</div><div class="line">})</div></pre></td></tr></table></figure>

<p>和原来的<code>HandleFunc</code>相比，第一个参数貌似有了不一样的变化，除了正常的path之外，还有HTTP POST Method，还有<code>{id}</code>和<code>{path...}</code>这样的变量，这就是Go 1.22中新增加的模式匹配。</p>
<p>通过<code>PathValue</code>可以获取路径中的通配符匹配的值。</p>
<h2 id="模式匹配">模式匹配</h2>
<p>模式匹配用在注册handler的时候，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Handle(pattern <span class="typename">string</span>, handler Handler)</div><div class="line"><span class="keyword">func</span> HandleFunc(pattern <span class="typename">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request))</div></pre></td></tr></table></figure>

<p>其中<code>pattern</code>模式的格式是这样子的:<code>[METHOD ][HOST]/[PATH]</code>, 中括号代表这一项可以省略。<br>因此<code>POST /items/create</code>、<code>POST rpcx.io/items/create</code>、<code>GET /items/123</code>、<code>/items/123</code>都是合法的模式。</p>
<p>如果不设置HTTP Method如<code>POST</code>,那么默认是匹配所有的HTTP Method。注意HTTP Method 之后有一个空格。<br>模式匹配<code>GET</code>会匹配<code>GET</code>和<code>HEAD</code>,除此之外，其他的HTTP Method都是精确匹配。</p>
<p>如果未设置HOST，那么默认是匹配所有的HOST。否则，HOST必须完全匹配。</p>
<h3 id="通配符">通配符</h3>
<p>请求的路径中可以包含通配符，如<code>&quot;/b/{bucket}/o/{objectname...}&quot;</code>。配符名称必须是有效的Go标识符。通配符必须是完整的路径段，例如<code>/b_{bucket}</code>就不是一个合法的通配符。</p>
<ul>
<li><code>/items/{id}</code>: 正常情况下一个通配符只匹配一个路径段，比如匹配<code>/items/123</code>，但是不匹配<code>/items/123/456</code>。</li>
<li><code>/items/{apth...}</code>: 但是如果通配符后面跟着<code>...</code>，那么它就会匹配多个路径段，比如<code>/items/123</code>、<code>/items/123/456</code>都会匹配这个模式。</li>
<li><code>/items/{$}</code>: 以<code>/</code>结尾的模式会匹配所有以它为前缀的路径，比如<code>/items/</code>、<code>/items/123</code>、<code>/items/123/456</code>都会匹配这个模式。如果以<code>/{$}</code>为后缀，那么表示严格匹配路径，不会匹配带后缀的路径，比如这个例子只会匹配<code>/items/</code>，不会匹配<code>/items/123</code>、<code>/items/123/456</code>。</li>
</ul>
<p>在匹配过程中，模式路径和传入请求路径都会逐段解码。因此，例如，路径 <code>/a%2Fb/100%25</code> 被视为具有两个段，<code>a/b</code> 和 <code>100%</code>。模式 <code>/a%2fb/</code> 与之匹配，但模式 <code>/a/b/</code> 则不匹配。</p>
<h3 id="优先级">优先级</h3>
<p>如果两个模式都可以匹配同一个路径咋办呢？比如<code>/items/{id}</code>和<code>/items/{path...}</code>都可以匹配<code>/items/123</code>，那么谁优先呢？</p>
<ul>
<li>最具体的模式具有优先权。比如<code>/items/{id}</code>比<code>/items/</code>更具体。</li>
<li>如果两者都不更具体，则模式冲突。<ul>
<li>在冲突的情况下，具有主机的模式具有优先权 <code>rpcx.io/items/{id}</code>比<code>/items/{id}</code>优先权更高。</li>
<li>如果两者都没有HOST，则模式冲突,panic。 <code>items/{id}</code>和<code>/items/{index}</code>都没有HOST，所以会panic。</li>
</ul>
</li>
</ul>
<h2 id="后缀/的转发">后缀<code>/</code>的转发</h2>
<p><code>/images/</code> 会导致<code>ServeMux</code>把<code>/images</code>重定向到<code>/images/</code>除非你注册了<code>/images</code>的handler。</p>
<h2 id="请求清理">请求清理</h2>
<p><code>ServeMux</code> 还负责清理URL请求路径和Host标头，去除端口号，并将包含 <code>.</code> 或 <code>..</code> 段或重复斜杠的任何请求重定向到等效、更清晰的URL。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.22中一个很大的变化是<code>http.ServeMux</code>中的模式匹配，先前这个功能是很多第三方的web框架或者router库实现的。</p>
<p>我们很有必要好好研究它，将来在实现HTTP API的时候可能优先使用它。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go标准库的新 math/rand]]></title>
    <link href="https://colobu.com/2023/12/24/new-math-rand-in-Go/"/>
    <id>https://colobu.com/2023/12/24/new-math-rand-in-Go/</id>
    <published>2023-12-24T08:45:20.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.22 就要在龙年春节期间发布了。Go 1.22的新特性包括了新的 <code>math/rand</code> 包。这个包的目标是提供一个更好的伪随机数生成器，它的 API 也更加简单易用。本文将介绍这个新的包的特性。<br><a id="more"></a></p>
<p><a href="https://tip.golang.org/doc/go1.22" target="_blank" rel="external">Go 1.22 release notes</a> 正在编写之中，大家可以关注这个网页以便全面了解Go 1.22的变化，前几天有Gopher制作了一个<a href="https://antonz.org/go-1-22/" target="_blank" rel="external">交互式运行新特性代码的网页</a>，也非常好，在reddit上关注度很高。今天这篇文章只关注于于<code>math/rand/v2</code>这个新的包。</p>
<h2 id="为什么要新的math/rand包">为什么要新的math/rand包</h2>
<p>其实大家对<code>math/rand</code>不是那么满意。<br>2017年，<a href="https://github.com/golang/go/issues/20661" target="_blank" rel="external">#20661</a> 中提到<code>math/rand.Read</code>和<code>crypto/rand.Read</code>相近，导致本来应该使用<code>crypto/rand.Read</code>的地方使用了<code>math/rand.Read</code>，导致了安全问题。<br>2017年，<a href="https://github.com/golang/go/issues/21835" target="_blank" rel="external">#21835</a> 中 Rob Pike 提议在Go 2中使用PCG Source。<br>2018年，<a href="https://github.com/golang/go/issues/26263" target="_blank" rel="external">#26263</a> 中 Josh Bleecher Snyder 提议对<code>math/rand</code>进行彻底的重构。<br>2023年6月， Russ Cox基于先前的对<code>math/rand</code>的吐槽，以及和Rob Pike的讨论，建立了一个讨论(<a href="https://github.com/golang/go/discussions/60751" target="_blank" rel="external">#60751</a>),准备新建一个包<code>math/rand/v2</code>,重新设计和实现一个新的伪随机数的库讨论也很热烈，最后实现了一个提案<a href="https://github.com/golang/go/issues/61716" target="_blank" rel="external">#61716</a>，这个提案最直接的动机是清理 <code>math/rand</code> 并解决其中许多悬而未决的问题，特别是使用过时生成器、缓慢的算法，以及与 <code>crypto/rand.Read</code> 的不幸冲突。</p>
<p>由于go module的支持版本<code>v2、v3、...</code>, Go 1.22中将会有一个新的包<code>math/rand/v2</code>，这个包将会是一个新的包，而不是<code>math/rand</code>的升级版本。这个包的目标是提供一个更好的伪随机数生成器，它的 API 也更加简单易用，同时一些检查工具也能支持这个包，不会报错。</p>
<p>看样子，<code>math/rand/v2</code>将会是第一个在标准库中建立<code>v2</code>版本的包，如果大家能够接受，将来会有更多的包加入进来，比如<code>sync/v2</code>、<code>encoding/json/v2</code>等等。</p>
<h2 id="提案的主要内容">提案的主要内容</h2>
<p><code>math/rand/v2</code> API 以 <code>math/rand</code> 为起点，进行以下<strong>不兼容的更改</strong>：</p>
<p>1、 移除 <code>Rand.Read</code> 和顶层的 <code>Read</code>。假装伪随机生成器是任意长字节序列的良好来源几乎总是错误的。<code>math/rand</code> 适用于模拟和非确定性算法，几乎从不需要字节序列。<code>Read</code> 是 <code>math/rand</code> 和 <code>crypto/rand</code> 之间唯一共享的 API 部分，代码应该基本上总是使用 <code>crypto/rand.Read</code>。（<code>math/rand.Read</code> 和 <code>crypto/rand.Read</code> 存在问题，因为它们具有相同的签名; <code>math/rand.Int</code> 和 <code>crypto/rand.Int</code> 也都存在，但具有不同的签名，这意味着代码永远不会意外地将一个错认为是另一个。）</p>
<p>2、 移除 <code>Source.Seed</code>、<code>Rand.Seed</code> 和顶层的 <code>Seed</code>。顶层的 <code>Seed</code> 已在 Go 1.20 中废弃。<code>Source.Seed</code> 和 <code>Rand.Seed</code> 假定底层源可以由单个 <code>int64</code> 作为种子，这只对有限数量的源是真实的。具体的源实现可以提供具有适当签名的 <code>Seed</code> 方法，或者对于不能重新设置种子的生成器根本不提供；简单来说使用一个<code>int64</code> 作为种子没有普适性，不适合定义一个通用的接口。</p>
<p>注意，移除顶层 <code>Seed</code> 意味着顶层函数如 <code>Int</code> 将始终以随机方式而不是确定性方式生成。<code>math/rand/v2</code> 将不关注 <code>math/rand</code> 所关注的 <a href="https://tip.golang.org/doc/go1.20#mathrandpkgmathrand" target="_blank" rel="external"><code>randautoseed</code></a> GODEBUG 设置；顶层函数的自动设置哦随机种子是唯一的模式。这反过来意味着顶层函数使用的具体 PRNG 算法是未指定的，可以在发布之间更改而不破坏任何现有代码。</p>
<p>3、 将 <code>Source</code> 接口更改为具有单个 <code>Uint64() uint64</code> 方法，取代 <code>Int63() int64</code>。后者过于拟合原始的 Mitchell &amp; Reeds LFSR 生成器。现代生成器可以提供 <code>uint64</code>。</p>
<p>4、 移除 <code>Source64</code>，现在不再需要，因为 <code>Source</code> 提供了 <code>Uint64</code> 方法。</p>
<p>5、 在 <code>Float32</code> 和 <code>Float64</code> 中使用更直观的实现。以 <code>Float64</code> 为例，它最初使用 <code>float64(r.Int63()) / (1&lt;&lt;63)</code>，但这存在问题，偶尔会四舍五入为 <code>1.0</code>。我们尝试将其更改为 <code>float64(r.Int63n(1&lt;&lt;53) / (1&lt;&lt;53)</code>，避免了四舍五入的问题。</p>
<p>6、 修复 <code>ExpFloat64</code> 和 <code>NormFloat64</code> 中的偏差问题。</p>
<p>7、 使用 <code>Rand.Shuffle</code> 实现 <code>Rand.Perm</code>。</p>
<p>8、 将 <code>Intn</code>、<code>Int31</code>、<code>Int31n</code>、<code>Int63</code>、<code>Int64n</code> 重命名为 <code>IntN</code>、<code>Int32</code>、<code>Int32N</code>、<code>Int64</code>、<code>Int64N</code>。原来的名称中的 <code>31</code> 和 <code>63</code> 是令人困惑的，而大写 <code>N</code> 在 Go 中作为名称的第二个“单词”更为习惯。</p>
<p>9、 添加 <code>Uint32</code>、<code>Uint32N</code>、<code>Uint64</code>、<code>Uint64N</code>、<code>Uint</code>、<code>UintN</code>，既作为顶层函数，也作为 <code>Rand</code> 的方法。</p>
<p>10、在 <code>N</code>、<code>IntN</code>、<code>UintN</code> 等中使用 <a href="https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction" target="_blank" rel="external">Lemire</a> 的算法。初步基准测试显示，与 <code>v1 Int31n</code> 相比，节省了 40%，与 <code>v1 Int63n</code> 相比，节省了 75%。</p>
<p>11、添加一个通用的顶层函数 <code>N</code>，类似于 <code>Int64N</code> 或 <code>Uint64N</code>，但适用于任何整数类型。特别是这允许使用 <code>rand.N(1*time.Minute)</code> 来获取范围在 <code>[0, 1*time.Minute)</code> 内的随机持续时间。</p>
<p>12、添加一个新的 <code>Source</code> 实现，<code>PCG-DXSM</code>。PCG 是一个简单、高效的算法，具有良好的统计随机性质。DXSM 变体是作者专门为纠正原始 (PCG-XSLRR) 中的一种罕见、隐晦的缺陷而引入的，并且现在是 Numpy 中的默认生成器。</p>
<p>13、移除 Mitchell &amp; Reeds LFSR 生成器和 NewSource。</p>
<p>14、添加一个新的 Source 实现，<code>ChaCha8</code>。ChaCha8 是从 ChaCha8 流密码派生的具有强密码学随机性质的随机数生成器。它提供与 ChaCha8 加密等效的安全性。</p>
<p>15、在 <code>math/rand/v2</code> 和 <code>math/rand</code>（未设置种子时）中使用每个 OS 线程的 ChaCha8 作为全局随机生成器。</p>
<h2 id="math/rand/v2介绍">math/rand/v2介绍</h2>
<p>注意，根据go module的定义，<code>v2</code>只是版本号，新的包名还是叫做<code>rand</code>。</p>
<p><code>rand</code> 包实现了适用于模拟(<code>simulation</code>)等任务的伪随机数生成器，但<strong>不应用于对安全性敏感</strong>的工作。</p>
<p>随机数由 <code>Source</code>生成，通常包装在 <code>Rand</code> 中。这两种类型应该一次由单个 goroutine 使用：在多个 goroutine 之间共享<strong>需要某种形式的同步</strong>。</p>
<p>顶层函数，如 <code>Float64</code> 和 <code>Int</code>，对于多个 goroutine 的<strong>并发使用是安全</strong>的。</p>
<p>该包的输出可能在设置种子的方式不同的情况下很容易可预测。对于适用于对安全性敏感的工作的随机数，请参阅 <code>crypto/rand</code> 包。</p>
<p>简单综述：所以你考虑到安全避免被人预测的场景下，还是要使用<code>crypto/rand</code> 包。 包级别的函数比如<code>Int</code>是线程安全的，但是如果你自己生成一个<code>Rand</code>对象，那么就要注意了，因为<code>Rand</code>对象是非线程安全的。</p>
<h3 id="包级别的函数">包级别的函数</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ExpFloat64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> Float32() <span class="typename">float32</span></div><div class="line"><span class="keyword">func</span> Float64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> Int() <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Int32() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> Int32N(n <span class="typename">int32</span>) <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> Int64() <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> Int64N(n <span class="typename">int64</span>) <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> IntN(n <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> N[Int intType](n Int) Int</div><div class="line"><span class="keyword">func</span> NormFloat64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> Perm(n <span class="typename">int</span>) []<span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Shuffle(n <span class="typename">int</span>, swap <span class="keyword">func</span>(i, j <span class="typename">int</span>))</div><div class="line"><span class="keyword">func</span> Uint32() <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> Uint32N(n <span class="typename">uint32</span>) <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> Uint64N(n <span class="typename">uint64</span>) <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> UintN(n <span class="typename">uint</span>) <span class="typename">uint</span></div></pre></td></tr></table></figure>

<p>针对<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>,分别有<code>Xxxxx()</code>和<code>XxxxxN()</code>两种函数，前者返回一个随机数，后者返回一个范围在<code>[0,n)</code>的随机数。<br><code>Float32</code>和<code>Float64</code>返回范围在<code>[0.0, 1.0)</code>的随机浮点数。<br><code>IntN</code>返回一个范围在<code>[0,n)</code>的随机数，数据类型是<code>int</code>类型。<br><code>N</code>是一个泛型的函数，返回一个范围在<code>[0,n)</code>的随机数，底层数据是int类型的，特别适合<code>time.Duration</code>这样的类型。</p>
<p><code>Perm</code>返回一个长度为<code>n</code>的随机排列的<code>int</code>数组。<br><code>Shuffle</code>洗牌算法</p>
<p><code>NormFloat64</code>返回一个标准正态分布的随机数。<br><code>ExpFloat64</code>返回一个指数分布的随机数。</p>
<h3 id="三种伪随机数生成器">三种伪随机数生成器</h3>
<p><code>ChaCha8</code> 也是包级别的函数使用的伪随机数生成器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChaCha8</div><div class="line"><span class="keyword">func</span> NewChaCha8(seed <span class="number">[32</span>]<span class="typename">byte</span>) *ChaCha8</div><div class="line"><span class="keyword">func</span> (c *ChaCha8) MarshalBinary() ([]<span class="typename">byte</span>, error)</div><div class="line"><span class="keyword">func</span> (c *ChaCha8) Seed(seed <span class="number">[32</span>]<span class="typename">byte</span>)</div><div class="line"><span class="keyword">func</span> (c *ChaCha8) Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (c *ChaCha8) UnmarshalBinary(data []<span class="typename">byte</span>) error</div></pre></td></tr></table></figure>

<p><code>PCG</code> 是另外一种伪随机数生成器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PCG</div><div class="line"><span class="keyword">func</span> NewPCG(seed1, seed2 <span class="typename">uint64</span>) *PCG</div><div class="line"><span class="keyword">func</span> (p *PCG) MarshalBinary() ([]<span class="typename">byte</span>, error)</div><div class="line"><span class="keyword">func</span> (p *PCG) Seed(seed1, seed2 <span class="typename">uint64</span>)</div><div class="line"><span class="keyword">func</span> (p *PCG) Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (p *PCG) UnmarshalBinary(data []<span class="typename">byte</span>) error</div></pre></td></tr></table></figure>

<p><code>Zipf</code>是生成Zipf分布的伪随机数生成器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Zipf</div><div class="line"><span class="keyword">func</span> NewZipf(r *Rand, s <span class="typename">float64</span>, v <span class="typename">float64</span>, imax <span class="typename">uint64</span>) *Zipf</div><div class="line"><span class="keyword">func</span> (z *Zipf) Uint64() <span class="typename">uint64</span></div></pre></td></tr></table></figure>

<p>相信后续还会有一些第三方的伪随机数生成器出现。</p>
<p>它们都实现了接口<code>Source</code>,<code>Source</code>接口只有一个方法<code>Uint64()</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Source <span class="keyword">interface</span> {</div><div class="line">	Uint64() <span class="typename">uint64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所有的伪随机数生成器都可以包装成一个<code>Rand</code>对象，<code>Rand</code>对象是非线程安全的，所以要注意。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> New(src Source) *Rand</div></pre></td></tr></table></figure>

<blockquote>
<p>这和Rust中的实现模式类似。&lt;<programming rust="">&gt;第一版把它叫做伴型特性，第二版中不知道为什么把这一节去掉了。<br>Rust中的<code>Rng</code>类似这里的Go的<code>Source</code>,可以有多种实现生成器。Rust中的<code>Rand</code>也类似这里Go的<code>Rand</code>,基于<code>Uint64() uint64</code>提供各种类型的随机数。</programming></p>
</blockquote>
<p><code>Rand</code>提供了各种便利的方法，这些方法其实和包级别的函数是一样的，只是它们是<code>Rand</code>对象的方法而已：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (r *Rand) Float32() <span class="typename">float32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Float64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int() <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int32() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int32N(n <span class="typename">int32</span>) <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int64() <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int64N(n <span class="typename">int64</span>) <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) IntN(n <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (r *Rand) NormFloat64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Perm(n <span class="typename">int</span>) []<span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Shuffle(n <span class="typename">int</span>, swap <span class="keyword">func</span>(i, j <span class="typename">int</span>))</div><div class="line"><span class="keyword">func</span> (r *Rand) Uint32() <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Uint32N(n <span class="typename">uint32</span>) <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Uint64N(n <span class="typename">uint64</span>) <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) UintN(n <span class="typename">uint</span>) <span class="typename">uint</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.22 就要在龙年春节期间发布了。Go 1.22的新特性包括了新的 <code>math/rand</code> 包。这个包的目标是提供一个更好的伪随机数生成器，它的 API 也更加简单易用。本文将介绍这个新的包的特性。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Go channel中批量读取数据]]></title>
    <link href="https://colobu.com/2023/12/23/batch-read-from-channels/"/>
    <id>https://colobu.com/2023/12/23/batch-read-from-channels/</id>
    <published>2023-12-23T13:49:51.000Z</published>
    <updated>2024-02-02T07:54:29.791Z</updated>
    <content type="html"><![CDATA[<p>有时候批量积攒一批数据集中处理，是一个高效的提高程序性能的方法，比如我们可以批量写入数据库，批量发送消息到kafka，批量写入网络数据等等。<br>批量把数据收集出来，我们常用channel类型，此时channel的功能就是一个buffer,多个生产者把数据写入到channel中，消费者从channel中读取数据，但是Go的channel并没有提供批量读取的方法，我们需要自己实现一个。<br><a id="more"></a></p>
<p><img src="batch-read.png" alt=""></p>
<h3 id="ithub-com/smallnest/exp/chanx_库">ithub.com/smallnest/exp/chanx 库</h3>
<p>当然我已经实现了一个batch库，你可以直接拿来用，本文主要介绍它的功能、使用方法以及设计原理和考量：<a href="https://github.com/smallnest/exp/blob/master/chanx/batcher.go" target="_blank" rel="external">github.com/smallnest/exp/chanx</a>。</p>
<p>我们可以使用这个库的<code>Batch</code>方法来批量读取数据，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Batch[T any](ctx context.Context, ch &lt;-<span class="keyword">chan</span> T, batchSize <span class="typename">int</span>, fn <span class="keyword">func</span>([]T))</div></pre></td></tr></table></figure>

<ul>
<li>第一个参数是<code>Context</code>,可以让调用者主动取消或者超时控制</li>
<li>第二个参数是channel，我们从这个channel中读取数据。channel可以在外部被关闭</li>
<li>第三个参数是批处理的大小，也就是我们从channel中读取一批数据的最大量</li>
<li>第四个参数是一个函数，我们把从channel中读取的一批数据传递给这个函数，由这个函数来处理这批数据</li>
</ul>
<p>举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestBatch(t *testing.T) {</div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>,<span class="number"> 10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		ch &lt;- i</div><div class="line">	}</div><div class="line"></div><div class="line">	count :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">go</span> Batch[<span class="typename">int</span>](context.Background(), ch,<span class="number"> 5</span>, <span class="keyword">func</span>(batch []<span class="typename">int</span>) {</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(batch) !=<span class="number"> 5</span> {</div><div class="line">			assert.Fail(t, <span class="string">"expected batch size 5, got %d"</span>, <span class="built_in">len</span>(batch))</div><div class="line">		}</div><div class="line">		count += <span class="built_in">len</span>(batch)</div><div class="line">	})</div><div class="line">	time.Sleep(time.Second)</div><div class="line">	<span class="built_in">close</span>(ch)</div><div class="line">	assert.Equal(t,<span class="number"> 10</span>, count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子一开始我们把10个数据写入到一个channel中，然后我们从channel中批量读取，每次读取5个，然后把这5个数据传递给一个函数来处理，我们可以看到，我们读取了两次，每次读取5个，总共读取了10个数据。</p>
<p>我们还可以使用<code>FlatBatch</code>方法来批量读取批量数据，它的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> FlatBatch[T any](ctx context.Context, ch &lt;-<span class="keyword">chan</span> []T, batchSize <span class="typename">int</span>, fn <span class="keyword">func</span>([]T))</div></pre></td></tr></table></figure>

<p>这个函数和<code>Batch</code>类似，只不过它的channel中的数据是一个切片，每次从channel中读取到一个切片后，把这个切片中的数据展开放入到一批数据中，最后再传递给处理函数。所以它有<code>Flat</code>和<code>Batch</code>两个功能。</p>
<p>举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestFlatBatch(t *testing.T) {</div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="typename">int</span>,<span class="number"> 10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		ch &lt;- []<span class="typename">int</span>{i, i}</div><div class="line">	}</div><div class="line"></div><div class="line">	count :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">go</span> FlatBatch[<span class="typename">int</span>](context.Background(), ch,<span class="number"> 5</span>, <span class="keyword">func</span>(batch []<span class="typename">int</span>) {</div><div class="line">		assert.NotEmpty(t, batch)</div><div class="line">		count += <span class="built_in">len</span>(batch)</div><div class="line">	})</div><div class="line">	time.Sleep(time.Second)</div><div class="line">	<span class="built_in">close</span>(ch)</div><div class="line">	assert.Equal(t,<span class="number"> 20</span>, count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们把10个切片写入到channel中，每个切片中有两个元素，然后我们从channel中批量读取并展开，放入到一个batch中，如果batch中的数据大于或等于5个，就把这5个数据传递给一个函数来处理，我们可以看到，我们读取了两次，每次读取5个，总共读取了10个数据。</p>
<h3 id="实现原理和考量">实现原理和考量</h3>
<p>想要从channel中批量读取数据，我们需要考虑以下几个问题：</p>
<ol>
<li>我们需要设定一个批处理的大小，不能无限制的读取而不处理，否则会把消费者饿死，内存也会爆表</li>
<li>从channel中读取数据的时候，如果channel中没有数据，我们需要等待，直到channel中有数据，或者channel被关闭。</li>
<li>不能无限制的等待，或者长时间的等待，否则消费者会饥饿，而且时延太长业务不允许</li>
</ol>
<p>我先举一个简单但是不太好的实现方式，我们在它的基础上做优化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Batch[T any](ctx context.Context, ch &lt;-<span class="keyword">chan</span> T, batchSize <span class="typename">int</span>, fn <span class="keyword">func</span>([]T)) {</div><div class="line">	<span class="keyword">var</span> batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">				fn(batch)</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> v, ok := &lt;-ch:</div><div class="line">			<span class="keyword">if</span> !ok { <span class="comment">// closed</span></div><div class="line">				fn(batch)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line"></div><div class="line">			batch = <span class="built_in">append</span>(batch, v)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(batch) == batchSize { <span class="comment">// full</span></div><div class="line">				fn(batch)</div><div class="line">				batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个实现中我们使用了一个<code>batch</code>变量来保存从channel中读取的数据，当<code>batch</code>中的数据量达到<code>batchSize</code>时，我们就把这个<code>batch</code>传递给处理函数，然后清空<code>batch</code>，继续读取数据。</p>
<p>这个实现的一个最大的问题就是，如果channel中没有数据，并且当前batch的数量还未达到预期， 我们就会一直等待，直到channel中有数据，或者channel被关闭，这样会导致消费者饥饿。</p>
<p>我们可以使用<code>select</code>语句来解决这个问题，我们可以在<code>select</code>语句中加入一个<code>default</code>分支，当channel中没有数据的时候，就会执行<code>default</code>分支以便在channel中没有数据的时候，我们能够把已读取到的数据也能交给函数fn去处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Batch[T any](ctx context.Context, ch &lt;-<span class="keyword">chan</span> T, batchSize <span class="typename">int</span>, fn <span class="keyword">func</span>([]T)) {</div><div class="line">    <span class="keyword">var</span> batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize)</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">                fn(batch)</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">case</span> v, ok := &lt;-ch:</div><div class="line">            <span class="keyword">if</span> !ok { <span class="comment">// closed</span></div><div class="line">                fn(batch)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line"></div><div class="line">            batch = <span class="built_in">append</span>(batch, v)</div><div class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) == batchSize { <span class="comment">// full</span></div><div class="line">                fn(batch)</div><div class="line">                batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">            }</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">                fn(batch)</div><div class="line">                batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个实现貌似解决了消费者饥饿的问题，但是也会带来一个新的问题，如果channel中总是没有数据，那么我们总是落入<code>default</code>分支中，导致CPU空转，这个goroutine可能导致CPU占用100%, 这样也不行。</p>
<p>有些人会使用<code>time.After</code>来解决这个问题，我们可以在<code>select</code>语句中加入一个<code>time.After</code>分支，当channel中没有数据的时候，就会执行<code>time.After</code>分支，这样我们就可以在channel中没有数据的时候，等待一段时间，如果还是没有数据，就把已读取到的数据也能交给函数fn去处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Batch[T any](ctx context.Context, ch &lt;-<span class="keyword">chan</span> T, batchSize <span class="typename">int</span>, fn <span class="keyword">func</span>([]T)) {</div><div class="line">    <span class="keyword">var</span> batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize)</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">                fn(batch)</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">case</span> v, ok := &lt;-ch:</div><div class="line">            <span class="keyword">if</span> !ok { <span class="comment">// closed</span></div><div class="line">                fn(batch)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line"></div><div class="line">            batch = <span class="built_in">append</span>(batch, v)</div><div class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) == batchSize { <span class="comment">// full</span></div><div class="line">                fn(batch)</div><div class="line">                batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">            }</div><div class="line">        <span class="keyword">case</span> &lt;-time.After<span class="number">(100</span> * time.Millisecond):</div><div class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">                fn(batch)</div><div class="line">                batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样貌似解决了CPU空转的问题，如果你测试这个实现，生产者在生产数据很慢的时候，程序的CPU的确不会占用100%。<br>但是正如有经验的Gopher意识到的那样，这个实现还是有问题的，如果生产者生产数据的速度很快，而消费者处理数据的速度很慢，那么我们就会产生大量的<code>Timer</code>,这些Timer不能及时的被回收，可能导致大量的内存占用，而且如果有大量的Timer,也会导致Go运行时处理Timer的性能。</p>
<p>这里我提出一个新的解决办法，在这个库中实现了，我们不应该使用<code>time.After</code>，因为<code>time.After</code>既带来了性能的问题，还可能导致它在休眠的时候不能及时读取channel中的数据，导致业务时延增加。</p>
<p>最终的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Batch[T any](ctx context.Context, ch &lt;-<span class="keyword">chan</span> T, batchSize <span class="typename">int</span>, fn <span class="keyword">func</span>([]T)) {</div><div class="line">	<span class="keyword">var</span> batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">				fn(batch)</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> v, ok := &lt;-ch:</div><div class="line">			<span class="keyword">if</span> !ok { <span class="comment">// closed</span></div><div class="line">				fn(batch)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line"></div><div class="line">			batch = <span class="built_in">append</span>(batch, v)</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(batch) == batchSize { <span class="comment">// full</span></div><div class="line">				fn(batch)</div><div class="line">				batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">			}</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> { <span class="comment">// partial</span></div><div class="line">				fn(batch)</div><div class="line">				batch = <span class="built_in">make</span>([]T,<span class="number"> 0</span>, batchSize) <span class="comment">// reset</span></div><div class="line">			} <span class="keyword">else</span> { <span class="comment">// empty</span></div><div class="line">				<span class="comment">// wait for more</span></div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(batch) &gt;<span class="number"> 0</span> {</div><div class="line">						fn(batch)</div><div class="line">					}</div><div class="line">					<span class="keyword">return</span></div><div class="line">				<span class="keyword">case</span> v, ok := &lt;-ch:</div><div class="line">					<span class="keyword">if</span> !ok {</div><div class="line">						<span class="keyword">return</span></div><div class="line">					}</div><div class="line"></div><div class="line">					batch = <span class="built_in">append</span>(batch, v)</div><div class="line">				}</div><div class="line"></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个实现的巧妙之处在于<code>default</code>出来。</p>
<p>如果代码运行落入到<code>default</code>分支，说明当前channel中没有数据可读。那么它会检查当前的<code>batch</code>中是否有数据，如果有，就把这个<code>batch</code>传递给处理函数，然后清空<code>batch</code>，继续读取数据。这样已读取的数据能够及时得到处理。</p>
<p>如果当前的<code>batch</code>中没有数据，那么它会再次进入<code>select</code>语句，等待channel中有数据，或者channel被关闭，或者<code>ctx</code>被取消。如果channel中没有数据，那么它会被阻塞，直到channel中有数据，或者channel被关闭，或者<code>ctx</code>被取消。这样就能够及时的读取channel中的数据，而不会导致CPU空转。</p>
<p>通过在<code>default</code>分支中的特殊处理，我们就可以低时延高效的从channel中批量读取数据了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时候批量积攒一批数据集中处理，是一个高效的提高程序性能的方法，比如我们可以批量写入数据库，批量发送消息到kafka，批量写入网络数据等等。<br>批量把数据收集出来，我们常用channel类型，此时channel的功能就是一个buffer,多个生产者把数据写入到channel中，消费者从channel中读取数据，但是Go的channel并没有提供批量读取的方法，我们需要自己实现一个。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“鲜有人了解的同步原语Phaser，和Barrier有啥区别？”]]></title>
    <link href="https://colobu.com/2023/12/20/Phaser-in-go/"/>
    <id>https://colobu.com/2023/12/20/Phaser-in-go/</id>
    <published>2023-12-19T23:18:11.000Z</published>
    <updated>2024-02-02T07:54:29.790Z</updated>
    <content type="html"><![CDATA[<p>Java中的Phaser是一个同步原语，它可以让多个线程在某个时刻同步执行。它和Barrier有点类似，但是它比Barrier更加灵活。</p>
<a id="more"></a>
<p>举一个例子哈，比如足球迷特别喜欢的欧洲冠军联赛，它的赛制就分为多个阶段：</p>
<blockquote>
<p>欧洲冠军联赛由欧冠资格赛、欧冠附加赛和欧冠正赛三部分组成。<br>欧冠资格赛，分为预赛轮（preliminary round）、第一轮资格赛（first qualifying round）、第二轮资格赛（second qualifying round）和第三轮资格赛（third qualifying round）。第三轮资格赛的优胜的10支球队进入欧冠附加赛，附加赛优胜的6支球队（冠军之路4队、联赛之路2队）将和26支自动晋级的队伍一起，参加欧冠小组赛。<br>欧冠正赛分为小组赛、1/8决赛、1/4决赛、半决赛和决赛。</p>
</blockquote>
<p>所以欧冠联赛分成了多个阶段，每一个阶段，会有一些球队参加，等到下一阶段，淘汰了一部分球队，又会有新的球队加入，每个阶段的球队都会有变化。这种情况非常适合使用Phaser来模拟。</p>
<p><img src="ucl.png" alt=""></p>
<p><code>Phaser</code> 和 <code>CyclicBarrier</code>的功能非常的相似，都是应用于多个参与者多阶段处理问题的场景，每个阶段都有障碍点，在障碍点需要等待所有的参与者到齐后才能进入下一个阶段。但是<code>Phaser</code>比<code>CyclicBarrier</code>更加灵活，<code>CyclicBarrier</code>的参与者数量是固定的，所以初始化<code>CyclicBarrier</code>的时候就需要设定参与者的数量，而<code>Phaser</code>的参与者数量是可以动态变化的，每个阶段完成后参与者可以选择离开，新的参与者也可以加入进来，所以上面欧冠的例子非常使用<code>Phaser</code>来模拟。</p>
<p>一旦一个同步原语的功能不是那么通用，而是面向非常细分的场景，那么它的使用范围非常有限，因为大部分场景我们都会使用<code>WaitGroup</code>、<code>channel</code>甚至<code>CyclicBarrier</code>去解决，但是针对参与者需要动态变化的场景，我们使用<code>Phaser</code>如鱼得水，比自己再封装和实现类似<code>Phaser</code>的功能更方便。正所谓“技多不压身”，我们多了解一些同步原语，在解决问题的时候就会更加得心应手。</p>
<p>Go标准库和扩展库中都没有实现，第三方库也鲜有实现，但是Java中有，我们可以参考Java中的实现，自己实现了一个，比如 <a href="https://github.com/smallnest/exp/blob/master/sync/phaser.go" target="_blank" rel="external">github.com/smallnest/exp/sync/Phaser</a>，当然针对Java复杂的实现做了精简，不再支持Phaser的父子关系，函数名也做了简化，将<code>Register/Deregister</code>改为<code>Join/Leave</code>等，如果你之前不了解Java的Phaser，可以看看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Phaser.html" target="_blank" rel="external">Java Phaser</a>。</p>
<p>我们看看它的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewPhaser(parties <span class="typename">int32</span>) *Phaser</div><div class="line"><span class="keyword">func</span> NewPhaserWithAction(parties <span class="typename">int32</span>, arriveAction <span class="keyword">func</span>(parties <span class="typename">int32</span>) error) *Phaser</div><div class="line"><span class="keyword">func</span> (p *Phaser) Arrive() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (p *Phaser) ArriveAndLeave() <span class="typename">int32</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Phaser) Wait(phase <span class="typename">int</span>) <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (p *Phaser) ArriveAndWait() <span class="typename">int32</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Phaser) ForceTermination()</div><div class="line"><span class="keyword">func</span> (p *Phaser) IsTerminated() <span class="typename">bool</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Phaser) Join() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (p *Phaser) BulkJoin(parties <span class="typename">int32</span>) <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (p *Phaser) Leave() <span class="typename">int32</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Phaser) Arrived() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (p *Phaser) Parties() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (p *Phaser) Phase() <span class="typename">int32</span></div></pre></td></tr></table></figure>

<p>我们分成几个部分来看。</p>
<ul>
<li><p>初始化</p>
<ul>
<li><code>NewPhaser</code>：初始化一个Phaser，指定参与者的数量。</li>
<li><code>NewPhaserWithAction</code>：初始化一个Phaser，指定参与者的数量，以及每个阶段的障碍点到达后的回调函数。</li>
</ul>
</li>
<li><p>动作</p>
<ul>
<li><code>Arrive</code>：参与者到达障碍点，但是不等待其他参与者，直接返回当前阶段。阶段的编号从0开始，每进入一个新的阶段，阶段编号会自增1。</li>
<li><code>ArriveAndLeave</code>：参与者到达障碍点，但是不等待其他参与者，直接返回当前阶段，并且离开Phaser。</li>
<li><code>Wait</code>：等待指定的阶段，如果指定的阶段已经完成，直接返回，否则等待指定的阶段完成后返回。</li>
<li><code>ArriveAndWait</code>：参与者到达障碍点，等待其他参与者到达障碍点，然后返回当前阶段。</li>
</ul>
</li>
<li><p>加入和离开</p>
<ul>
<li><code>Join</code>：参与者加入Phaser，参与者的数量会自增1。</li>
<li><code>Leave</code>：参与者离开Phaser，参与者的数量会自减1。</li>
<li><code>BulkJoin</code>：批量加入参与者，参与者的数量会自增指定的数量。</li>
</ul>
</li>
<li><p>终止</p>
<ul>
<li><code>ForceTermination</code>：强制终止Phaser，所有的参与者都会离开Phaser。</li>
</ul>
</li>
<li><p>查询</p>
<ul>
<li><code>Arrived</code>：返回当前阶段已经到达障碍点的参与者数量。</li>
<li><code>Parties</code>：返回当前Phaser中参与者的数量。</li>
<li><code>Phase</code>：返回当前阶段的编号。</li>
<li><code>IsTerminated</code>：返回Phaser是否已经终止。</li>
</ul>
</li>
</ul>
<p>举一个例子,我在代码中加上注释，来解释代码的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestPhaser_phase(t *testing.T) {</div><div class="line">	<span class="comment">// 模拟一个有三个阶段的场景，其中一个参与者(id=1)在参加完第一阶段就离开了</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化一个Phaser，指定参与者的数量为0</span></div><div class="line">	phaser := NewPhaser<span class="number">(0</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 在整个过程中有10个参与者</span></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		phaser.Join()</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>(id <span class="typename">int</span>) {</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">			t.Logf(<span class="string">"goroutine %d started\n"</span>, id)</div><div class="line"></div><div class="line">			<span class="comment">// phase == 0， 第一阶段，等待其他参与者到达</span></div><div class="line">			phase := phaser.ArriveAndWait()</div><div class="line">			assert.Equal(t, <span class="typename">int32</span><span class="number">(1</span>), phase) <span class="comment">// 第一阶段完成，返回下一阶段的编号1</span></div><div class="line">			t.Logf(<span class="string">"goroutine %d finished phase 0， enter phase 1\n"</span>, id)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> id ==<span class="number"> 1</span> { <span class="comment">// #1 goroutine退出后面的阶段</span></div><div class="line">				phaser.Leave()</div><div class="line">				t.Logf(<span class="string">"goroutine %d exit after phase 0\n"</span>, id)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line"></div><div class="line">			time.Sleep(time.Duration(rand.Intn<span class="number">(10</span>) * <span class="typename">int</span>(time.Second)))</div><div class="line"></div><div class="line">			<span class="comment">// phase == 1， 第二阶段，等待其他参与者到达</span></div><div class="line">			assert.Equal(t, <span class="typename">int32</span><span class="number">(1</span>), phaser.Phase())</div><div class="line">			phase = phaser.ArriveAndWait()</div><div class="line">			assert.Equal(t, <span class="typename">int32</span><span class="number">(2</span>), phase) <span class="comment">// 第二阶段完成，返回下一阶段的编号2</span></div><div class="line">			t.Logf(<span class="string">"goroutine %d finished phase 1， enter phase 2\n"</span>, id)</div><div class="line"></div><div class="line">			time.Sleep(time.Duration(rand.Intn<span class="number">(10</span>) * <span class="typename">int</span>(time.Second)))</div><div class="line"></div><div class="line">            <span class="comment">// phase == 2， 第三阶段，等待其他参与者到达</span></div><div class="line">			phase = phaser.ArriveAndWait()</div><div class="line">			assert.Equal(t, <span class="typename">int32</span><span class="number">(3</span>), phase) <span class="comment">// 第三阶段完成，返回下一阶段的编号3</span></div><div class="line">			t.Logf(<span class="string">"goroutine %d finished phase 2， enter phase 3\n"</span>, id)</div><div class="line">		}(i)</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait() <span class="comment">// 所有的参与者都完成了各阶段。 9个参与了三个阶段，一个参与了第一阶段</span></div><div class="line"></div><div class="line">    phaser.ForceTermination() <span class="comment">// 强制终止Phaser</span></div><div class="line"></div><div class="line">	t.Logf(<span class="string">"phaser terminated"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Java中的Phaser是一个同步原语，它可以让多个线程在某个时刻同步执行。它和Barrier有点类似，但是它比Barrier更加灵活。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[每个Go程序员必犯之错]]></title>
    <link href="https://colobu.com/2023/12/17/Less-Error-Prone-Loop-Variable-Scopin/"/>
    <id>https://colobu.com/2023/12/17/Less-Error-Prone-Loop-Variable-Scopin/</id>
    <published>2023-12-17T09:37:12.000Z</published>
    <updated>2024-02-02T07:54:29.788Z</updated>
    <content type="html"><![CDATA[<p>说起每个程序员必犯的错误，那还得是&quot;循环变量&quot;这个错误了，就连Go的开发者都犯过这个错误，这个错误在Go的FAQ中也有提到<a href="https://go.dev/doc/faq#closures_and_goroutines" target="_blank" rel="external">What happens with closures running as goroutines?</a>:</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">var</span> wg sync.WaitGroup</div><div class="line"></div><div class="line">    values := []<span class="typename">string</span>{<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>}</div><div class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values {</div><div class="line">        wg.Add<span class="number">(1</span>)</div><div class="line">        <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">            fmt.Println(v)</div><div class="line">            wg.Done()</div><div class="line">        }()</div><div class="line">    }</div><div class="line"></div><div class="line">    wg.Wait()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可能期望能输出<code>a</code>、<code>b</code>、<code>c</code>这三个字符(可能顺序不同)，但是实际可能输出的是<code>c</code>、<code>c</code>、<code>c</code>。<br>这是因为循环变量的作用域是整个循环，而不是单次迭代，所以在循环体中使用的变量是同一个变量，而不是每次迭代都是一个新的变量。</p>
<p>这个错误有时候隐藏很深，即使没有goroutine，也有可能，比如下面的代码，并没有使用额外的goroutine和闭包，也是有问题的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Char <span class="keyword">struct</span> {</div><div class="line">	Char *<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> chars []Char</div><div class="line"></div><div class="line">	values := []<span class="typename">string</span>{<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>}</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values {</div><div class="line">		chars = <span class="built_in">append</span>(chars, Char{Char: &v})</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> chars {</div><div class="line">		fmt.Println(*v.Char)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出也大概率是<code>c</code>、<code>c</code>、<code>c</code>,因为给每个<code>Char</code>的字段赋值的是v的指针，v在整个循环中都是一个变量，所以最后的结果都是<code>c</code>。</p>
<p>Go团队很早也意识到这个问题了，但是考虑到兼容的问题，大家的容忍程度，那就这样了。每个Go程序员都在这里摔一跤，也就长记性了，所以一直没有改变这个设计。我在这里摔了好多跤，以至于我写for循环的时候都战战兢兢的，和Russ Cox统计的网上的处理一样，不管有无必要，很多时候我都是先把循环变量赋值给一个局部变量，然后再使用，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values {</div><div class="line">    v := v</div><div class="line">    wg.Add<span class="number">(1</span>)</div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        fmt.Println(v)</div><div class="line">        wg.Done()</div><div class="line">    }()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>今年5月份的时候，Russ Cox忍不住了，提了一个提案<a href="https://github.com/golang/go/issues/60078" target="_blank" rel="external">#60078</a>,提案的内容是在for循环中，如果变量只在循环体中使用，那么就会在每次迭代中创建一个新的变量，而不是使用同一个变量。这个提案引起了很多人的关注，很多人都在讨论这个提案，这个提案被接收了，具体提案内容在文档中<a href="https://go.googlesource.com/proposal/+/master/design/60078-loopvar.md" target="_blank" rel="external">Proposal: Less Error-Prone Loop Variable Scoping</a>。</p>
<p>如果你使用Go 1.21， 你可以开始这个功能，使用<code>GOEXPERIMENT=loopvar go run main.go</code>运行上面的程序，会输出<code>c</code>、<code>b</code>、<code>a</code>这样的输出，不再是<code>c</code>、<code>c</code>、<code>c</code>了。<br>这个特性在Go 1.22中会默认开启，不需要设置<code>GOEXPERIMENT</code>了。还有一两个月才能正式发布go 1.22,大家可以使用gotip测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gotip run main.go</div><div class="line">a</div><div class="line">b</div><div class="line">c</div></pre></td></tr></table></figure>

<p>不只是<code>for-range</code>,下面的<code>3-clause</code>也是同样的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> ids []*<span class="typename">int</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">		i =<span class="number"> 10</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, id := <span class="keyword">range</span> ids {</div><div class="line">		fmt.Println(*id)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Go 1.22中也会修复这个问题。C#语言就只修改了<code>for-range</code>语句，<code>3-clause</code>语句就没有修改, Go两种都做了修改。</p>
<p><strong>但是</strong>， 问题就来了哈，像下面的代码，Go 1.22和以前的代码会一样么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> ids []*<span class="typename">int</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 3</span>; i++ {</div><div class="line">        i =<span class="number"> 10</span></div><div class="line">		ids = <span class="built_in">append</span>(ids, &i)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, id := <span class="keyword">range</span> ids {</div><div class="line">		fmt.Println(*id)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果用Go 1.21,它会输出<code>11</code>。<br>如果用Go 1.22,它会输出<code>10</code>。<br>原因还是在于这个提案实现后，每次迭代的时候，都会创建一个新的变量，所以<code>ids</code>中的元素都是指向不同的变量，而不是同一个变量。</p>
<p>看起来打破了向下兼容的承诺，你如果先前就想利用这个corner case的话，Go1.22已经不兼容了。</p>
<p>更进一步，你会发现再执行<code>3-clause</code>的第三条clause的时候，变量已经被重新创建，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">for</span> i, p :=<span class="number"> 0</span>, (*<span class="typename">int</span>)(<span class="constant">nil</span>); i &lt;<span class="number"> 3</span>; <span class="built_in">println</span>(<span class="string">"3rd-clause:"</span>, &i, p) {</div><div class="line">		p = &i</div><div class="line">		fmt.Println(<span class="string">"loop body:"</span>, &i, p)</div><div class="line">		i++</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gotip</span> run main.go</div><div class="line">loop body: <span class="number">0</span>x14000120018 <span class="number">0</span>x14000120018</div><div class="line"><span class="number">3</span>rd-clause: <span class="number">0</span>x14000120030 <span class="number">0</span>x14000120018 // &i已经变为<span class="number">0</span>x14000120030</div><div class="line">loop body: <span class="number">0</span>x14000120030 <span class="number">0</span>x14000120030</div><div class="line"><span class="number">3</span>rd-clause: <span class="number">0</span>x14000120038 <span class="number">0</span>x14000120030 // &i已经变为<span class="number">0</span>x14000120038</div><div class="line">loop body: <span class="number">0</span>x14000120038 <span class="number">0</span>x14000120038</div><div class="line"><span class="number">3</span>rd-clause: <span class="number">0</span>x14000120040 <span class="number">0</span>x14000120038 // &i已经变为<span class="number">0</span>x14000120040</div></pre></td></tr></table></figure>

<p>这次修改还带来了一个福利，就是range的变量，除了数组、slice、字符串、map、channel外，还可以是一个整数，比如<code>for i := range 10</code>,它相当于<code>for i := 0; i &lt; 10; i++</code>。<br><code>range n</code>相当于一个语法糖，如果n &gt; 0，那么它会迭代`0到n-1的值， 如果n &lt;= 0, 那么它不会迭代任何值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起每个程序员必犯的错误，那还得是&quot;循环变量&quot;这个错误了，就连Go的开发者都犯过这个错误，这个错误在Go的FAQ中也有提到<a href="https://go.dev/doc/faq#closures_and_goroutines" target="_blank" rel="external">What happens with closures running as goroutines?</a>:</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2023年在地球上举行的Gopher大会]]></title>
    <link href="https://colobu.com/2023/12/16/gopher-conferences-in-2023/"/>
    <id>https://colobu.com/2023/12/16/gopher-conferences-in-2023/</id>
    <published>2023-12-16T14:43:23.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>疫情结束后，很多的Gopher大会在全世界举行，本文整理了今年在地球上举行的Gopher大会，并列出了大会中一些有趣的议题和油管链接。</p>
<a id="more"></a>
<h2 id="GopherCon_Israel_2023,_时间：2023-02-07,_地点:_以色列_特拉维夫">GopherCon Israel 2023, 时间：2023-02-07, 地点: 以色列 特拉维夫</h2>
<p><a href="https://www.gophercon.org.il/" target="_blank" rel="external">https://www.gophercon.org.il/</a><br>特拉维夫是以色列第二大城市，事实上的首都，也是以色列的经济、文化和科技中心。以色列的高科技产业在特拉维夫和其周边地区集中，被称为“以色列硅谷”。</p>
<p>一个小规模的GopherCon，是以色列国内Gopher的盛会。但是分享的内容还是很不错的，比如下面的分享：</p>
<ul>
<li>Bottlenecks in Golang memory management</li>
<li>Hot path optimizations for latency-critical applications in GO </li>
</ul>
<p>总体上来说分享的内容还是比较基础。</p>
<p>分享视频: <a href="https://www.youtube.com/playlist?list=PLRM-8sTy13Xvr1ZaZarF5t_PBPxJdZHxt" target="_blank" rel="external">https://www.youtube.com/playlist?list=PLRM-8sTy13Xvr1ZaZarF5t_PBPxJdZHxt</a></p>
<h2 id="GopherCon_Brasil_2023,_时间：2023-05-09_~_2023-05-10,_地点:_巴西_弗洛里亚诺波利斯">GopherCon Brasil 2023, 时间：2023-05-09 ~ 2023-05-10, 地点: 巴西 弗洛里亚诺波利斯</h2>
<p><a href="https://gopherconbr.org/en/" target="_blank" rel="external">https://gopherconbr.org/en/</a></p>
<p>葡萄牙语，看不懂。</p>
<p>分析视频：<a href="https://www.youtube.com/playlist?list=PLOpPtg0fjj4hoS9S8Wm2Fj7VU1aRUe2q3" target="_blank" rel="external">https://www.youtube.com/playlist?list=PLOpPtg0fjj4hoS9S8Wm2Fj7VU1aRUe2q3</a></p>
<h2 id="Go_Conference_2023_Japan,_时间：2023-06-02,_地点:_线上">Go Conference 2023 Japan, 时间：2023-06-02, 地点: 线上</h2>
<p><a href="https://gocon.jp/2023" target="_blank" rel="external">https://gocon.jp/2023</a></p>
<p>主要是日文分享，线上举行的，不说也罢。</p>
<h2 id="GopherChina_2023,_时间：2023-06-09_~_2023-06-11,_地点:_中国_北京">GopherChina 2023, 时间：2023-06-09 ~ 2023-06-11, 地点: 中国 北京</h2>
<p>谢大组织的国内最大的Gopher盛会。疫情过去终于可以在线下举行。</p>
<p>2023的议题：<a href="https://www.bagevent.com/event/gopherchina2023" target="_blank" rel="external">https://www.bagevent.com/event/gopherchina2023</a></p>
<p>历年演讲材料分享：<a href="https://github.com/gopherchina/conference" target="_blank" rel="external">https://github.com/gopherchina/conference</a></p>
<p>11月又在上海举行了分会。<br>2024会在更多的城市举行大会和meetup，大家可以关注一下。</p>
<h2 id="GopherCon_Europe_2023，时间：2023-06-26_~_2023-06-28,_地点:_德国_柏林">GopherCon Europe 2023，时间：2023-06-26 ~ 2023-06-28, 地点: 德国 柏林</h2>
<p><a href="https://gophercon.eu/" target="_blank" rel="external">https://gophercon.eu/</a><br>欧洲Gopher盛会，在柏林举行，2024年分成两期，2月在希腊雅典举行，6月在柏林举行。</p>
<p>一些好的议题如：</p>
<ul>
<li>The state of Go</li>
<li>Go Right Ahead! Simple Hacks to Cut Memory Usage by 80%</li>
<li>Writing a TSDB from Scratch: Performance Optimization</li>
<li>Go Sync or Go Home</li>
<li>Gentle Introduction to EBPF</li>
<li>Race Conditions in Details</li>
</ul>
<p>视频分享：<a href="https://www.youtube.com/playlist?list=PLtoVuM73AmsJWvXYd_9rbYXcbv1UdzeLT" target="_blank" rel="external">https://www.youtube.com/playlist?list=PLtoVuM73AmsJWvXYd_9rbYXcbv1UdzeLT</a></p>
<h2 id="GopherCon_UK_2023,_时间：2023-08-16_~_2023-08-18,_地点:_英国_伦敦">GopherCon UK 2023, 时间：2023-08-16 ~ 2023-08-18, 地点: 英国 伦敦</h2>
<p><a href="https://www.gophercon.co.uk/" target="_blank" rel="external">https://www.gophercon.co.uk/</a><br>英国举行的GopherCon大会。</p>
<p>分享视频：<a href="https://www.youtube.com/@GopherConUK" target="_blank" rel="external">https://www.youtube.com/@GopherConUK</a></p>
<p>这个会议的分享质量还是非常高的，干货比较多，比如下面的分享，都是纯纯的干货：</p>
<ul>
<li>Fun with Algorithms and Data Structures</li>
<li>Fun with Generics</li>
<li>Level-Up Real-time Go Applications with Ringbuffers</li>
<li>The context package internals</li>
<li>Efficient Debugging and Logging with OpenTelemetry in Go</li>
<li>Understanding Language Server Protocol - autocomplete, formatting</li>
<li>The Adventurer’s Guide to Forking the Go Runtime</li>
<li>Understanding the Go Compiler</li>
</ul>
<p>这些分享都加入到我的冬季学习列表中了，看看我能不能出一些学习笔记这个会议真的是非常的赞。</p>
<h2 id="GopherCon_India_2023,_时间：2023-09-09_~_2023-09-09,_地点:_印度_浦那">GopherCon India 2023, 时间：2023-09-09 ~ 2023-09-09, 地点: 印度 浦那</h2>
<p><a href="https://gopherconindia.org/" target="_blank" rel="external">https://gopherconindia.org/</a></p>
<p>印度国内举行的Gopher会议，我每发现太多的亮点，我比较关注的并发的议题还有一些新鲜的主题，看到一个相关的主题：</p>
<ul>
<li>Locks, Lock Free and everything in between</li>
</ul>
<p>分享视频：<a href="https://www.youtube.com/playlist?list=PLbgP71NCXCqEIgXsrPhkIZvEa3p1OdkBD" target="_blank" rel="external">https://www.youtube.com/playlist?list=PLbgP71NCXCqEIgXsrPhkIZvEa3p1OdkBD</a></p>
<h2 id="GopherCon_2023,_时间：2023-09-25_~_2023-09-28,_地点:_美国_圣地亚哥">GopherCon 2023, 时间：2023-09-25 ~ 2023-09-28, 地点: 美国 圣地亚哥</h2>
<p><a href="https://www.gophercon.com/" target="_blank" rel="external">https://www.gophercon.com/</a><br>美国本地的举行的GopherCon，大咖云集，也很热闹。<br>以前在丹佛举行，最近几期在圣地亚哥举行。</p>
<p>看最近广告商的<del>分享</del>(广告)多了起来，可以有选择的观看。</p>
<p>我发现字节的同学Zhang Yifei有一个有意思的分享Balanced GC: A Copying Garbage Collector for Golang。</p>
<p>相关的主题列表见 <a href="https://www.gophercon.com/agenda" target="_blank" rel="external">https://www.gophercon.com/agenda</a></p>
<p>目前我还未发现相关的视频分享和ppt分享。</p>
<h2 id="GopherCon_Singapore_2023,_时间：2023-11-02_~_2023-11-03,_地点:_新加坡">GopherCon Singapore 2023, 时间：2023-11-02 ~ 2023-11-03, 地点: 新加坡</h2>
<p><a href="https://2023.gophercon.sg/" target="_blank" rel="external">https://2023.gophercon.sg/</a></p>
<p>新加坡的Gopher盛会。</p>
<p>一些有趣的议题：</p>
<ul>
<li>Go low latency patterns</li>
<li>Go Concurrency Techniques for Self-Healing Applications</li>
<li>Three techniques for building high performance parsers</li>
</ul>
<p>这次Dave Cheney重出江湖，最近几年他都销声匿迹了。</p>
<p>他们的视频目前还没有在油管上分享，后续大家可以关注一下。</p>
<h2 id="GopherCon_Australia_2023,_时间：2023-11-08_~_2023-11-10,_地点:_澳大利亚_悉尼">GopherCon Australia 2023, 时间：2023-11-08 ~ 2023-11-10, 地点: 澳大利亚 悉尼</h2>
<p><a href="https://gophercon.com.au/" target="_blank" rel="external">https://gophercon.com.au/</a></p>
<p>Rob Pike 和 Russ Cox都去了，这么重视?!</p>
<p>专门有一个Go并发编程的workshop, 499美元， 我又想做我的书的广告了。</p>
<p>议题大家看看，我还是比较关注Go的两位大咖的分享。<br>Russ Cox现场的分享因为录音问题效果不好，所以他单独又录了一篇<br><a href="https://www.youtube.com/watch?v=X4rxi9jStLo" target="_blank" rel="external">https://www.youtube.com/watch?v=X4rxi9jStLo</a></p>
<p>其他的视频分享应该会在油管上分享，理论上两个星期后就上传了，不过实际上目前还没。</p>
<h2 id="GolangConf_Russia_2023,_时间：2023-11-27_~_2023-11-28,_地点:_俄罗斯_莫斯科">GolangConf Russia 2023, 时间：2023-11-27 ~ 2023-11-28, 地点: 俄罗斯 莫斯科</h2>
<p><a href="https://golangconf.ru/2023/" target="_blank" rel="external">https://golangconf.ru/2023/</a></p>
<p>以前有个GopherCon Russia，貌似最近两年停办了。几年俄罗斯举办了这个，俄语，看不懂。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>疫情结束后，很多的Gopher大会在全世界举行，本文整理了今年在地球上举行的Gopher大会，并列出了大会中一些有趣的议题和油管链接。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[卷起来，老程序员也得了解errors包的新变化]]></title>
    <link href="https://colobu.com/2023/12/13/learn-more-about-errors/"/>
    <id>https://colobu.com/2023/12/13/learn-more-about-errors/</id>
    <published>2023-12-13T13:11:09.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.13 中errors包有了一些变化，这些变化是为了更好地支持Go的错误处理提案。Go 1.20中也增加了一个新方法，这个新方法可以代替第三方的库处理多个error，这篇文章将介绍这些变化。</p>
<p>因为原来的Go的errors中的内容非常的简单，可能会导致大家轻视这个包，对于新的变化不是那么的关注。让我们一一介绍这些新的方法。<br><a id="more"></a></p>
<h2 id="Unwrap">Unwrap</h2>
<p>如果一个err实现了<code>Unwrap</code>函数，那么<code>errors.Unwrap</code>会返回这个err的<code>unwrap</code>方法的结果，否则返回nil。<br>一般标准的error都没有实现<code>Unwrap</code>方法，比如<code>io.EOF</code>, 但是也有一小部分的error实现了<code>Unwrap</code>方法，比如<code>os.PathError</code>，<code>os.LinkError</code>、<code>os.SyscallError</code>、<code>net.OpError</code>、<code>net.DNSConfigError</code>等等。</p>
<p>比如下面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fmt.Println(errors.Unwrap(io.EOF)) <span class="comment">// nil</span></div><div class="line">_, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"invalid.address:80"</span>)</div><div class="line">fmt.Println(errors.Unwrap(err))</div></pre></td></tr></table></figure>

<p>第一行因为<code>io.EOF</code>没有<code>Unwrap</code>方法，所以输出nil。<br>net.Dial失败返回的err是<code>*net.OpError</code>,它实现了<code>Unwrap</code>方法，返回更底层的<code>*net.DNSError</code>,所以第二行输出为<code>lookup invalid.address: no such host</code>。</p>
<p>最常用的，我们使用<code>fmt.Errorf</code> + <code>%w</code>包装一个error,比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">e1 := fmt.Errorf(<span class="string">"e1: %w"</span>, io.EOF)</div><div class="line">e2 := fmt.Errorf(<span class="string">"e2: %w + %w"</span>, e1, io.ErrClosedPipe)</div><div class="line">e3 := fmt.Errorf(<span class="string">"e3: %w"</span>, e2)</div><div class="line">e4 := fmt.Errorf(<span class="string">"e4: %w"</span>, e3)</div><div class="line">fmt.Println(errors.Unwrap(e4)) <span class="comment">// e3: e2: e1: EOF + io: read/write on closed pipe</span></div></pre></td></tr></table></figure>

<p>这段代码逐层进行了包装，最后的<code>e4</code>包含了所有的error，我们可以通过<code>errors.Unwrap</code>逐层进行解包，直到最底层的error。<br>fmt.Errorf可以1一次包装多个error，比如上面的<code>e2</code>，它包含了<code>e1</code>和<code>io.ErrClosedPipe</code>两个error。</p>
<p>我们常常在多层调用的时候，把最底层的error逐层包装传递上去，这个时候我们可以使用<code>fmt.Errorf</code> + <code>%w</code>包装error。<br>在最高层处理error的时候，再逐层<code>Unwrap</code>解开error,逐层处理。</p>
<h2 id="Is">Is</h2>
<p><code>Is</code>函数检查error的树中是否包含指定的目标error。</p>
<p>啥是error的<strong>树</strong>? 一个error的数包括它本身，以及通过<code>Unwrap</code>方法逐层解开的error。<br>error的<code>Unwrap</code>方法的返回值，可能是单个error,也可能是是多个error,在返回多个error的时候，会采用深度优先的方式进行遍历检查，寻找目标error。</p>
<p>怎么才算找到目标error呢？一种情况就是此err就是目标error,这没有什么好说的，第二种就是此err实现了<code>Is(err)</code>方法，把目标err扔进<code>Is</code>方法返回true。</p>
<p>所以从功能上看<code>Is</code>函数其实叫做<code>Has</code>函数更贴切些。</p>
<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">e1 := fmt.Errorf(<span class="string">"e1: %w"</span>, io.EOF)</div><div class="line">e2 := fmt.Errorf(<span class="string">"e2: %w + %w"</span>, e1, io.ErrClosedPipe)</div><div class="line">e3 := fmt.Errorf(<span class="string">"e3: %w"</span>, e2)</div><div class="line">e4 := fmt.Errorf(<span class="string">"e4: %w"</span>, e3)</div><div class="line">fmt.Println(errors.Is(e4, io.EOF)) <span class="comment">// true</span></div><div class="line">fmt.Println(errors.Is(e4, io.ErrClosedPipe)) <span class="comment">// true</span></div><div class="line">fmt.Println(errors.Is(e4, io.ErrUnexpectedEOF)) <span class="comment">// false</span></div></pre></td></tr></table></figure>

<h2 id="As">As</h2>
<p><code>Is</code>是遍历error的数，检查是否包含目标error。<br><code>As</code>是遍历error的数，检查每一个error,看看是否可以把从error赋值给目标变量，如果是，则返回true,并且目标变量已赋值，否则返回false。</p>
<p>下面这个例子，我们可以看到<code>As</code>的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> _, err := os.Open(<span class="string">"non-existing"</span>); err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">var</span> pathError *fs.PathError</div><div class="line">	<span class="keyword">if</span> errors.As(err, &pathError) {</div><div class="line">		fmt.Println(<span class="string">"failed at path:"</span>, pathError.Path)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Println(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果os.Open返回的error的树中包含<code>*fs.PathError</code>，那么<code>errors.As</code>会把这个error赋值给<code>pathError</code>变量，并且返回true,否则返回false。<br>我们这个例子正好制造的就是文件不存在的error，所以它会输出：<code>failed at path: non-existing</code></p>
<p>经常常犯的一个错误就是我们使用一个<code>error</code>变量作为<code>As</code>的第二个参数。下面这个例子tmp就是error接口类型，所以origin可以直接赋值给tmp，所以<code>errors.As</code>返回true,并且tmp的值就是origin的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> origin = fmt.Errorf(<span class="string">"error: %w"</span>, io.EOF)</div><div class="line"></div><div class="line"><span class="keyword">var</span> tmp = io.ErrClosedPipe</div><div class="line"><span class="keyword">if</span> errors.As(origin, &tmp) {</div><div class="line">	fmt.Println(tmp) <span class="comment">// error: EOF</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>As</code>使用起来总是那么别别扭扭，每次总得声明一个变量，然后把这个变量传递给<code>As</code>函数，在Go支持泛型之后，<code>As</code>应该可以简化成如下的方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> As[T error](err error) (T, <span class="typename">bool</span>)</div></pre></td></tr></table></figure>

<p>但是，Go不会修改这个导致不兼容的API，所以我们只能继续保留<code>As</code>函数，增加一个新的函数是一个可行的方法，无论它叫做<code>IsA</code>、<code>AsOf</code>还是<code>AsTarget</code>或者其他。</p>
<p>如果你已经掌握了Go的泛型，你可以自己实现一个<code>As</code>函数，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> AsA[T error](err error) (T, <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">var</span> isErr T</div><div class="line">	<span class="keyword">if</span> errors.As(err, &isErr) {</div><div class="line">		<span class="keyword">return</span> isErr, <span class="constant">true</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> zero T</div><div class="line">	<span class="keyword">return</span> zero, <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>写段测试代码，我们可以看到它的效果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (*MyError) Error() <span class="typename">string</span> { <span class="keyword">return</span> <span class="string">"MyError"</span> }</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> err error = fmt.Errorf(<span class="string">"error: %w"</span>, &MyError{})</div><div class="line">	m, ok := AsA[*MyError](err) <span class="comment">// MyError does not implement error (Error method has pointer receiver)</span></div><div class="line">	fmt.Println(m, ok)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大家在<a href="https://github.com/golang/go/issues/51945" target="_blank" rel="external">#51945</a>讨论了一段时间，又是无疾而终了。</p>
<h2 id="Join">Join</h2>
<p>在我们的项目中，有时候需要处理多个error,比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *Server) Serve() error {</div><div class="line">    <span class="keyword">var</span> errs []error</div><div class="line">    <span class="keyword">if</span> err := s.init(); err != <span class="constant">nil</span> {</div><div class="line">        errs = <span class="built_in">append</span>(errs, err)</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> err := s.start(); err != <span class="constant">nil</span> {</div><div class="line">        errs = <span class="built_in">append</span>(errs, err)</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> err := s.stop(); err != <span class="constant">nil</span> {</div><div class="line">        errs = <span class="built_in">append</span>(errs, err)</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt;<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"server error: %v"</span>, errs)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码中，我们需要处理三个error,如果有一个error不为nil,那么我们就返回errs。<br>当然，为了处理多个errors情况，先前，有很多的第三方库可以供我们使用，比如</p>
<ul>
<li>go.uber.org/multierr</li>
<li>github.com/hashicorp/go-multierror</li>
<li>github.com/cockroachdb/errors</li>
</ul>
<p>但是现在，你不用再造轮子或者使用第三方库了，因为Go 1.20中增加了<code>errors.Join</code>函数，它可以把多个error合并成一个error,比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> e1 = io.EOF</div><div class="line"><span class="keyword">var</span> e2 = io.ErrClosedPipe</div><div class="line"><span class="keyword">var</span> e3 = io.ErrNoProgress</div><div class="line"><span class="keyword">var</span> e4 = io.ErrShortBuffer</div><div class="line"></div><div class="line">_, e5 := net.Dial(<span class="string">"tcp"</span>, <span class="string">"invalid.address:80"</span>)</div><div class="line">e6 := os.Remove(<span class="string">"/path/to/nonexistent/file"</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> e = errors.Join(e1, e2)</div><div class="line">e = errors.Join(e, e3)</div><div class="line">e = errors.Join(e, e4)</div><div class="line">e = errors.Join(e, e5)</div><div class="line">e = errors.Join(e, e6)</div><div class="line"></div><div class="line">fmt.Println(e.Error())</div><div class="line">   <span class="comment">// 输出如下，每一个err一行</span></div><div class="line">   <span class="comment">//</span></div><div class="line"><span class="comment">// EOF</span></div><div class="line"><span class="comment">// io: read/write on closed pipe</span></div><div class="line"><span class="comment">// multiple Read calls return no data or error</span></div><div class="line"><span class="comment">// short buffer</span></div><div class="line"><span class="comment">// dial tcp: lookup invalid.address: no such host</span></div><div class="line"><span class="comment">// remove /path/to/nonexistent/file: no such file or directory</span></div><div class="line"></div><div class="line"></div><div class="line">fmt.Println(errors.Unwrap(e)) <span class="comment">// nil</span></div><div class="line">fmt.Println(errors.Is(e, e6)) <span class="comment">//true</span></div><div class="line">fmt.Println(errors.Is(e, e3)) <span class="comment">// true</span></div><div class="line">fmt.Println(errors.Is(e, e1)) <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>你可以使用<code>Is</code>判断是否包含某个error,或者使用<code>As</code>提取出目标error。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.13 中errors包有了一些变化，这些变化是为了更好地支持Go的错误处理提案。Go 1.20中也增加了一个新方法，这个新方法可以代替第三方的库处理多个error，这篇文章将介绍这些变化。</p>
<p>因为原来的Go的errors中的内容非常的简单，可能会导致大家轻视这个包，对于新的变化不是那么的关注。让我们一一介绍这些新的方法。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go单线程运行也会有并发问题]]></title>
    <link href="https://colobu.com/2023/12/11/concurrency-issues-of-the-single-thread-in-Go/"/>
    <id>https://colobu.com/2023/12/11/concurrency-issues-of-the-single-thread-in-Go/</id>
    <published>2023-12-11T05:37:51.000Z</published>
    <updated>2023-12-11T05:55:08.016Z</updated>
    <content type="html"><![CDATA[<p>一个Go大佬群中严肃的讨论了一个问题：Go程序单线程多goroutine访问一个map会遇到并发读写panic么？</p>
<a id="more"></a>
<p>答案是肯定的，因为出现了这个问题所以大家才在群中讨论。</p>
<p>为什么呢？因为单线程意味着并行单元只有一个(多线程也可能并行单元只有一个)，但是多goroutine意味着并发单元有多个，如果并发单元同时执行，即使是单线程，可能就会产生数据竞争的问题，除非这些goroutine是顺序执行的。</p>
<p>举一个例子哈：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestCounter() {</div><div class="line">    runtime.GOMAXPROCS<span class="number">(1</span>)</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> counter <span class="typename">int</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		i := i</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Printf(<span class="string">"start task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 10</span>_0000; j++ {</div><div class="line">				counter++</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"end task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">	fmt.Println(counter)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段测试代码是启动10个goroutine对计数器加一，每个goroutine负责加10万次。在我的MBP m1笔记本上，每次的结果都是100万，符合期望。如果你运行这段代码，会发现goroutine其实是一个一个串行执行的(9-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8，当然可能在你的机器上不是这样的)，如果是串行执行，不会有并发问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">start task<span class="comment">#9, counter: 0</span></div><div class="line">end task<span class="comment">#9, counter: 100000</span></div><div class="line">start task<span class="comment">#0, counter: 100000</span></div><div class="line">end task<span class="comment">#0, counter: 200000</span></div><div class="line">start task<span class="comment">#1, counter: 200000</span></div><div class="line">end task<span class="comment">#1, counter: 300000</span></div><div class="line">start task<span class="comment">#2, counter: 300000</span></div><div class="line">end task<span class="comment">#2, counter: 400000</span></div><div class="line">start task<span class="comment">#3, counter: 400000</span></div><div class="line">end task<span class="comment">#3, counter: 500000</span></div><div class="line">start task<span class="comment">#4, counter: 500000</span></div><div class="line">end task<span class="comment">#4, counter: 600000</span></div><div class="line">start task<span class="comment">#5, counter: 600000</span></div><div class="line">end task<span class="comment">#5, counter: 700000</span></div><div class="line">start task<span class="comment">#6, counter: 700000</span></div><div class="line">end task<span class="comment">#6, counter: 800000</span></div><div class="line">start task<span class="comment">#7, counter: 800000</span></div><div class="line">end task<span class="comment">#7, counter: 900000</span></div><div class="line">start task<span class="comment">#8, counter: 900000</span></div><div class="line">end task<span class="comment">#8, counter: 1000000</span></div><div class="line"><span class="number">1000000</span></div></pre></td></tr></table></figure>

<p>为了制造点紧张气氛，我将代码改写成下面这样子，将<code>counter++</code>三条指令明显写成三条语句，并在中间插入<code>runtime.Gosched()</code>,故意给其它goroutine的执行制造机会：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestCounter2() {</div><div class="line">    runtime.GOMAXPROCS<span class="number">(1</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> counter <span class="typename">int</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		i := i</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Printf(<span class="string">"start task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 10</span>_0000; j++ {</div><div class="line">				temp := counter</div><div class="line">				runtime.Gosched()</div><div class="line">				temp = temp +<span class="number"> 1</span></div><div class="line">				counter = temp</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"end task#%d, counter: %d\n"</span>, i, counter)</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">	fmt.Println(counter)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这段代码，你就会明显看到数据不一致的效果，即使是单个线程运行goroutine,也出现了数据竞争的问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">start task<span class="comment">#9, counter: 0</span></div><div class="line">start task<span class="comment">#0, counter: 0</span></div><div class="line">start task<span class="comment">#1, counter: 0</span></div><div class="line">start task<span class="comment">#2, counter: 0</span></div><div class="line">start task<span class="comment">#3, counter: 0</span></div><div class="line">start task<span class="comment">#4, counter: 0</span></div><div class="line">start task<span class="comment">#5, counter: 0</span></div><div class="line">start task<span class="comment">#6, counter: 0</span></div><div class="line">start task<span class="comment">#7, counter: 0</span></div><div class="line">start task<span class="comment">#8, counter: 0</span></div><div class="line">end task<span class="comment">#9, counter: 100000</span></div><div class="line">end task<span class="comment">#1, counter: 100000</span></div><div class="line">end task<span class="comment">#3, counter: 100000</span></div><div class="line">end task<span class="comment">#2, counter: 100000</span></div><div class="line">end task<span class="comment">#5, counter: 100000</span></div><div class="line">end task<span class="comment">#0, counter: 100000</span></div><div class="line">end task<span class="comment">#4, counter: 100000</span></div><div class="line">end task<span class="comment">#6, counter: 100000</span></div><div class="line">end task<span class="comment">#7, counter: 100000</span></div><div class="line">end task<span class="comment">#8, counter: 100000</span></div><div class="line"><span class="number">100000</span></div></pre></td></tr></table></figure>

<p>这个结果非常离谱，期望100万，最后只有10万。</p>
<p>因为单个线程运行多个goroutine会有数据竞争的问题，所以访问同一个map对象也有可能出现并发bug,比如下面的代码，10个goroutine并发的写同一个map:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestMap() {</div><div class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>)</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		i := i</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			fmt.Printf(<span class="string">"start map task#%d, m: %v\n"</span>, i, <span class="built_in">len</span>(m))</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 10</span>_0000; j++ {</div><div class="line">				m[j] = i<span class="number">*10</span>_0000 + j</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"end map task#%d, m: %v\n"</span>, i, <span class="built_in">len</span>(m))</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大概率会出现panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">start <span class="keyword">map</span> task<span class="number">#9</span>, m:<span class="number"> 0</span></div><div class="line">start <span class="keyword">map</span> task<span class="number">#0</span>, m:<span class="number"> 49152</span></div><div class="line">fatal error: concurrent <span class="keyword">map</span> writes</div><div class="line"></div><div class="line">goroutine<span class="number"> 41</span> [running]:</div><div class="line">main.TestMap.func1()</div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:72</span><span class="number"> +0</span>xcc</div><div class="line">created by main.TestMap in goroutine<span class="number"> 1</span></div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:69</span><span class="number"> +0</span>x4c</div><div class="line"></div><div class="line">goroutine<span class="number"> 1</span> [semacquire]:</div><div class="line">sync.runtime_Semacquire<span class="number">(0</span>x140000021a0?)</div><div class="line">	/usr/local/<span class="keyword">go</span>/src/runtime/sema.<span class="keyword">go</span><span class="number">:62</span><span class="number"> +0</span>x2c</div><div class="line">sync.(*WaitGroup).Wait<span class="number">(0</span>x1400000e1d0)</div><div class="line">	/usr/local/<span class="keyword">go</span>/src/sync/waitgroup.<span class="keyword">go</span><span class="number">:116</span><span class="number"> +0</span>x74</div><div class="line">main.TestMap()</div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:79</span><span class="number"> +0</span>xb8</div><div class="line">main.main()</div><div class="line">	/Users/chaoyuepan/study/single_thread/main.<span class="keyword">go</span><span class="number">:15</span><span class="number"> +0</span>x2c</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>一个Go大佬群中严肃的讨论了一个问题：Go程序单线程多goroutine访问一个map会遇到并发读写panic么？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更精准的sleep]]></title>
    <link href="https://colobu.com/2023/12/07/more-precise-sleep/"/>
    <id>https://colobu.com/2023/12/07/more-precise-sleep/</id>
    <published>2023-12-06T23:18:11.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>书接上回。昨天我写了一篇《这个限流库两个大bug存在了半年之久，没人发现？》，提到了Go语言中的<code>time.Sleep</code>函数的问题。有网友也私下和我探讨，提到这个可能属于系统的问题，因为现代的操作系统都是分时操作系统，每个线程可能会分配一个或者多个时间片，Windows默认线程时间精度在15毫秒，Linux在1毫秒，所以<code>time.Sleep</code>的精度不可能那么高。</p>
<p><strong>本文原文有误导，结论部分正确，我在文章末尾作了更正</strong></p>
<a id="more"></a>
<p>嗯，理论上这可以解释<code>time.Sleep</code>的行为，但是没有办法解释网友提出的在<code>go 1.16</code>之前的版本中，<code>time.Sleep</code>的精度更高，而<code>go 1.16</code>之后的版本中，<code>time.Sleep</code>的精度更低的问题。</p>
<p>这个问题在Go的bug系统中有很多，不只是单单上篇文章介绍的#44343, 比如#29485、#61456、#44476、#44608、#61042。这些bug中Ian Lance Taylor的有些评论很有价值，对于了解Go运行时的Sleep很有帮助。但是阅览了这么多的bug,没有人给出为啥<code>go 1.16</code>之后的版本中，<code>time.Sleep</code>的精度更低的解释，到底发生了啥？或许和Timer调度的变化有关。</p>
<p>Linux和Windows提供了更高精度的Sleep, Go开发者也在尝试解决Windows中过长的问题。</p>
<p>为了把这个问题说明白，我们举一个典型的例子，这里我使用了<a href="https://github.com/loov/hrtime" target="_blank" rel="external">loov/hrtime</a>,它能提供更高精度的时间和benchmark方法。看到作者的名字我觉得眼熟，果然，作者的一个项目lensm也非常有名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">intervals := []time.Duration{time.Nanosecond, time.Millisecond,<span class="number"> 50</span> * time.Millisecond}</div><div class="line"></div><div class="line"><span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals {</div><div class="line">	fmt.Printf(<span class="string">"sleep %v\n"</span>, interval)</div><div class="line">	b := hrtime.NewBenchmark<span class="number">(100</span>)</div><div class="line">	<span class="keyword">for</span> b.Next() {</div><div class="line">		time.Sleep(interval)</div><div class="line">	}</div><div class="line">	fmt.Println(b.Histogram<span class="number">(10</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们尝试使用<code>time.Sleep</code>休眠1纳秒、1微秒和50微秒，可以看到实际休眠的时间基本在<code>380ns</code>、<code>1ms</code>、<code>50ms</code>。我是在腾讯云上的一台Linux轻量级服务器上测试的，可以看到<code>time.Sleep</code>休眠1毫秒以上还是和实际差不太多的，但是休眠1纳秒是不太可能的，这也符合我们的预期，只是实际休眠的时间是380纳秒还是挺长的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">ubuntu@lab:~/workplace/timer$ go run main.go</div><div class="line">sleep <span class="number">1</span>ns</div><div class="line">  avg <span class="number">726</span>ns;  min <span class="number">380</span>ns;  p50 <span class="number">476</span>ns;  max <span class="number">22.4</span>µs;</div><div class="line">  p90 <span class="number">670</span>ns;  p99 <span class="number">22.4</span>µs;  p999 <span class="number">22.4</span>µs;  p9999 <span class="number">22.4</span>µs;</div><div class="line">      <span class="number">380</span>ns [ <span class="number">99</span>] ████████████████████████████████████████</div><div class="line">        <span class="number">5</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">10</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">15</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">20</span>µs [  <span class="number">1</span>]</div><div class="line">       <span class="number">25</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">30</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">35</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">40</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">45</span>µs [  <span class="number">0</span>]</div><div class="line"></div><div class="line">sleep <span class="number">1</span>ms</div><div class="line">  avg <span class="number">1.06</span>ms;  min <span class="number">1.02</span>ms;  p50 <span class="number">1.06</span>ms;  max <span class="number">1.09</span>ms;</div><div class="line">  p90 <span class="number">1.07</span>ms;  p99 <span class="number">1.09</span>ms;  p999 <span class="number">1.09</span>ms;  p9999 <span class="number">1.09</span>ms;</div><div class="line">     <span class="number">1.02</span>ms [  <span class="number">2</span>] █▌</div><div class="line">     <span class="number">1.03</span>ms [  <span class="number">6</span>] █████</div><div class="line">     <span class="number">1.04</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">1.05</span>ms [  <span class="number">1</span>] ▌</div><div class="line">     <span class="number">1.06</span>ms [ <span class="number">48</span>] ████████████████████████████████████████</div><div class="line">     <span class="number">1.07</span>ms [ <span class="number">39</span>] ████████████████████████████████</div><div class="line">     <span class="number">1.08</span>ms [  <span class="number">3</span>] ██</div><div class="line">     <span class="number">1.09</span>ms [  <span class="number">1</span>] ▌</div><div class="line">      <span class="number">1.1</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">1.11</span>ms [  <span class="number">0</span>]</div><div class="line"></div><div class="line">sleep <span class="number">50</span>ms</div><div class="line">  avg <span class="number">50.1</span>ms;  min <span class="number">50.1</span>ms;  p50 <span class="number">50.1</span>ms;  max <span class="number">50.1</span>ms;</div><div class="line">  p90 <span class="number">50.1</span>ms;  p99 <span class="number">50.1</span>ms;  p999 <span class="number">50.1</span>ms;  p9999 <span class="number">50.1</span>ms;</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">2</span>] ██</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">1</span>] █</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">13</span>] ███████████████</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">34</span>] ████████████████████████████████████████</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">31</span>] ████████████████████████████████████</div><div class="line">     <span class="number">50.2</span>ms [ <span class="number">15</span>] █████████████████▌</div><div class="line">     <span class="number">50.2</span>ms [  <span class="number">2</span>] ██</div><div class="line">     <span class="number">50.2</span>ms [  <span class="number">2</span>] ██</div></pre></td></tr></table></figure>

<p>其实Linux提供了一个更高精度的系统调用<code>nanosleep</code>,可以提供纳秒级别的休眠，它是一个阻塞的系统调用，会阻塞当前线程,直到睡眠结束或被中断。</p>
<p><code>nanosleep</code>系统调用和标准库的<code>time.Sleep</code>的主要区别：</p>
<ul>
<li>阻塞方式不同:<ul>
<li>nanosleep 会阻塞当前线程,直到睡眠结束或被中断</li>
<li>time.Sleep 会阻塞当前 goroutine</li>
</ul>
</li>
<li>精度不同:<ul>
<li>nanosleep 可以精确到纳秒</li>
<li>time.Sleep 最高只能精确到毫秒</li>
</ul>
</li>
<li>中断处理不同:<ul>
<li>nanosleep 可以通过信号中断并立即返回</li>
<li>time.Sleep 不可以中断,只能等待睡眠期满</li>
</ul>
</li>
<li>用途不同:<ul>
<li>nanosleep 主要用于需要精确睡眠时间的低级控制</li>
<li>time.Sleep 更适合高级逻辑控制,不需要精确睡眠时间</li>
</ul>
</li>
</ul>
<p>我们使用上面的测试代码，使用<code>nanosleep</code>替换<code>time.Sleep</code>，看看效果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals {</div><div class="line">	fmt.Printf(<span class="string">"nanosleep %v\n"</span>, interval)</div><div class="line">	req := syscall.NsecToTimespec(<span class="typename">int64</span>(interval))</div><div class="line">	b := hrtime.NewBenchmark<span class="number">(100</span>)</div><div class="line">	<span class="keyword">for</span> b.Next() {</div><div class="line">		syscall.Nanosleep(&req, <span class="constant">nil</span>)</div><div class="line">	}</div><div class="line">	fmt.Println(b.Histogram<span class="number">(10</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这段代码可以得到结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">nanosleep <span class="number">1</span>ns</div><div class="line">  avg <span class="number">60.4</span>µs;  min <span class="number">58.7</span>µs;  p50 <span class="number">60.2</span>µs;  max <span class="number">77.5</span>µs;</div><div class="line">  p90 <span class="number">61.2</span>µs;  p99 <span class="number">77.5</span>µs;  p999 <span class="number">77.5</span>µs;  p9999 <span class="number">77.5</span>µs;</div><div class="line">     <span class="number">58.8</span>µs [ <span class="number">33</span>] █████████████████████▌</div><div class="line">       <span class="number">60</span>µs [ <span class="number">61</span>] ████████████████████████████████████████</div><div class="line">       <span class="number">62</span>µs [  <span class="number">1</span>] ▌</div><div class="line">       <span class="number">64</span>µs [  <span class="number">3</span>] █▌</div><div class="line">       <span class="number">66</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">68</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">70</span>µs [  <span class="number">1</span>] ▌</div><div class="line">       <span class="number">72</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">74</span>µs [  <span class="number">0</span>]</div><div class="line">       <span class="number">76</span>µs [  <span class="number">1</span>] ▌</div><div class="line"></div><div class="line">nanosleep <span class="number">1</span>ms</div><div class="line">  avg <span class="number">1.06</span>ms;  min <span class="number">1.03</span>ms;  p50 <span class="number">1.06</span>ms;  max <span class="number">1.07</span>ms;</div><div class="line">  p90 <span class="number">1.06</span>ms;  p99 <span class="number">1.07</span>ms;  p999 <span class="number">1.07</span>ms;  p9999 <span class="number">1.07</span>ms;</div><div class="line">     <span class="number">1.04</span>ms [  <span class="number">1</span>]</div><div class="line">     <span class="number">1.04</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">1.05</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">1.05</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">1.06</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">1.06</span>ms [  <span class="number">5</span>] ██</div><div class="line">     <span class="number">1.07</span>ms [ <span class="number">92</span>] ████████████████████████████████████████</div><div class="line">     <span class="number">1.07</span>ms [  <span class="number">1</span>]</div><div class="line">     <span class="number">1.08</span>ms [  <span class="number">1</span>]</div><div class="line">     <span class="number">1.08</span>ms [  <span class="number">0</span>]</div><div class="line"></div><div class="line">nanosleep <span class="number">50</span>ms</div><div class="line">  avg <span class="number">50</span>ms;  min <span class="number">50</span>ms;  p50 <span class="number">50</span>ms;  max <span class="number">50</span>ms;</div><div class="line">  p90 <span class="number">50</span>ms;  p99 <span class="number">50</span>ms;  p999 <span class="number">50</span>ms;  p9999 <span class="number">50</span>ms;</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">3</span>] ███▌</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">5</span>] ██████</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">26</span>] █████████████████████████████████▌</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">31</span>] ████████████████████████████████████████</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">18</span>] ███████████████████████</div><div class="line">     <span class="number">50.1</span>ms [ <span class="number">16</span>] ████████████████████▌</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">1</span>] █</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">0</span>]</div><div class="line">     <span class="number">50.1</span>ms [  <span class="number">0</span>]</div></pre></td></tr></table></figure>

<p>可以看到在程序休眠1纳秒时， nanosleep实际休眠60纳秒，相比于<code>tome.Sleep</code>的380纳秒，精度提高了很多。但是在休眠1毫秒和50毫秒时，nanosleep和time.Sleep的精度差不多，都是1毫秒和50毫秒。</p>
<p>既然nanosleep可以提高精度，那么我们能不能以后就使用这个系统调用来代替<code>time.Sleep</code>呢？答案是视情况而定，你需要注意<code>nanosleep</code>是一个阻塞的系统调用，Go程序在调用它时，会将当前线程阻塞，直到休眠结束或者被中断，它会额外占用一个线程。如果你的程序中有很多的goroutine，那么你的程序可能会因为阻塞而导致性能下降。所以你需要权衡一下，如果你的程序中有很多的goroutine，而且你的程序中的goroutine需要休眠，那么你可以考虑使用<code>time.Sleep</code>，如果你的程序中的goroutine不多，而且你的程序中的goroutine需要精确的休眠时间，那么你可以考虑使用<code>nanosleep</code>。</p>
<p>而且，当前Go并不会将<code>nanosleep</code>占用的线程主动释放，而且放在池中备用，在并发<code>nanosleep</code>调用的时候，可能会导致线程数暴增，下面的代码演示了这个情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Threads() {</div><div class="line">	<span class="keyword">var</span> threadProfile = pprof.Lookup(<span class="string">"threadcreate"</span>)</div><div class="line">	fmt.Printf((<span class="string">"threads in starting: %d\n"</span>), threadProfile.Count())</div><div class="line"></div><div class="line">	<span class="keyword">var</span> sleepTime time.Duration = time.Hour</div><div class="line">	req := syscall.NsecToTimespec(<span class="typename">int64</span>(sleepTime))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 100</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			syscall.Nanosleep(&req, <span class="constant">nil</span>)</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	time.Sleep<span class="number">(10</span> * time.Second)</div><div class="line"></div><div class="line">	fmt.Printf((<span class="string">"threads in nanosleep: %d\n"</span>), threadProfile.Count())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的轻量级服务器上，显示结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">threads <span class="keyword">in</span> starting: <span class="number">4</span></div><div class="line">threads <span class="keyword">in</span> nanosleep: <span class="number">103</span></div></pre></td></tr></table></figure>

<p>在<code>nanosleep</code>并发运行的时候，可以看到线程数达到了<code>103</code>个。线程数暴增会导致系统资源的浪费，而且程序性能也会下降。</p>
<blockquote>
<p>当然如果你对<code>threadcreate</code>有疑义，也可以使用<code>pstree</code>查看程序当前的线程数。</p>
</blockquote>
<p>线程不会释放的问题，已经在Go的bug系统中提出了，但是目前还没有解决，不过你可以通过增加<code>runtime.LockOSThread()</code>这个技巧来释放线程。注意没有调用UnlockOSThread():</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 100</span>; i++ {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		syscall.Nanosleep(&req, <span class="constant">nil</span>)</div><div class="line">		runtime.LockOSThread()</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>本文并没有对生产环境做任何的建议，只是分析了:</p>
<ul>
<li><code>time.Sleep</code>和<code>nanosleep</code>的精度问题</li>
<li><code>nanosleep</code>的使用方法</li>
<li><code>nanosleep</code>的陷阱</li>
</ul>
<p>算是对上一篇文章的延伸。</p>
<h2 id="更正">更正</h2>
<p>基于网友在评论中指出我把时间单位看错了，我重新测试并做了更正。老眼昏花，先前确实看错了。</p>
<p>我想基于三个interval做测试： 50纳秒、50微秒、1毫秒。我使用了<code>time.Sleep</code>和<code>syscall.Nanosleep</code>两种方式，在阿里云的一台轻量级虚机(Ubuntu 22.04)上做了测试。</p>
<p>因为先前大家反映<code>time.Sleep</code>的精度不高，Linux只能达到毫秒级别，所以使用了50纳秒和50微秒。</p>
<p>下面是<code>time.Sleep</code>的测试结果：<br>50纳秒的情况下，实际达到了954纳秒，比预期的50纳秒要高很多。<br>50微秒的情况下，实际达到了1.08毫秒，比预期的50微秒要高很多。<br>1毫秒的情况下，实际达到了1.07毫秒，和预期的1毫秒差不多。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<p>sh<br>sleep 50ns<br>  avg 954ns;  min 350ns;  p50 421ns;  max 30.3µs;<br>  p90 573ns;  p99 30.3µs;  p999 30.3µs;  p9999 30.3µs;<br>      350ns [ 98] ████████████████████████████████████████<br>        5µs [  0]<br>       10µs [  0]<br>       15µs [  1]<br>       20µs [  0]<br>       25µs [  0]<br>       30µs [  1]<br>       35µs [  0]<br>       40µs [  0]<br>       45µs [  0]</p>
<p>sleep 50µs<br>  avg 1.08ms;  min 1.05ms;  p50 1.08ms;  max 1.14ms;<br>  p90 1.09ms;  p99 1.14ms;  p999 1.14ms;  p9999 1.14ms;<br>     1.05ms [  1] ▌<br>     1.06ms [  1] ▌<br>     1.07ms [ 24] █████████████████<br>     1.08ms [ 56] ████████████████████████████████████████<br>     1.09ms [  9] ██████<br>      1.1ms [  6] ████<br>     1.11ms [  2] █<br>     1.12ms [  0]<br>     1.13ms [  0]<br>     1.14ms [  1] ▌</p>
<p>sleep 1ms<br>  avg 1.07ms;  min 1.06ms;  p50 1.07ms;  max 1.11ms;<br>  p90 1.09ms;  p99 1.11ms;  p999 1.11ms;  p9999 1.11ms;<br>     1.06ms [  2] ██<br>     1.07ms [ 35] ████████████████████████████████████████<br>     1.07ms [  6] ██████▌<br>     1.08ms [ 10] ███████████<br>     1.08ms [ 19] █████████████████████▌<br>     1.09ms [  9] ██████████<br>     1.09ms [  8] █████████<br>      1.1ms [  8] █████████<br>      1.1ms [  1] █<br>     1.11ms+[  2] ██</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面是<span class="string">`syscall.Nanosleep`</span>的测试结果。</div><div class="line">在<span class="number">50</span>纳秒的情况下，实际达到了<span class="number">62.9</span>毫秒，比预期的<span class="number">50</span>纳秒要高了很多。</div><div class="line">在<span class="number">50</span>微秒的情况下，实际达到了<span class="number">118</span>微秒，比预期的<span class="number">50</span>微秒要翻倍，但是比<span class="keyword">time</span>.Sleep要好很多。</div><div class="line">在<span class="number">1</span>毫秒的情况下，实际达到了<span class="number">1.06</span>毫秒，和预期的<span class="number">1</span>毫秒差不多。</div></pre></td></tr></table></figure>

<p>sh<br>nanosleep 50ns<br>  avg 62.9µs;  min 58.7µs;  p50 60.6µs;  max 130µs;<br>  p90 65.7µs;  p99 130µs;  p999 130µs;  p9999 130µs;<br>     58.7µs [ 32] █████████████████████▌<br>       60µs [ 59] ████████████████████████████████████████<br>       70µs [  5] ███<br>       80µs [  2] █<br>       90µs [  1] ▌<br>      100µs [  0]<br>      110µs [  0]<br>      120µs [  0]<br>      130µs [  1] ▌<br>      140µs [  0]</p>
<p>nanosleep 50µs<br>  avg 118µs;  min 109µs;  p50 111µs;  max 223µs;<br>  p90 137µs;  p99 223µs;  p999 223µs;  p9999 223µs;<br>      109µs [ 83] ████████████████████████████████████████<br>      120µs [  8] ███▌<br>      140µs [  7] ███<br>      160µs [  0]<br>      180µs [  0]<br>      200µs [  1]<br>      220µs [  1]<br>      240µs [  0]<br>      260µs [  0]<br>      280µs [  0]</p>
<p>nanosleep 1ms<br>  avg 1.06ms;  min 1.06ms;  p50 1.06ms;  max 1.08ms;<br>  p90 1.07ms;  p99 1.08ms;  p999 1.08ms;  p9999 1.08ms;<br>     1.06ms [ 10] █████▌<br>     1.07ms [ 69] ████████████████████████████████████████<br>     1.07ms [ 13] ███████▌<br>     1.08ms [  3] █▌<br>     1.08ms [  2] █<br>     1.09ms [  3] █▌<br>     1.09ms [  0]<br>      1.1ms [  0]<br>      1.1ms [  0]<br>     1.11ms [  0]<br><code>`</code></p>
<p>综合比较，<code>syscall.Nanosleep</code>的精度要比<code>time.Sleep</code>高很多，纳秒级别的精度虽然达不到，但是在微秒级别的精度上勉强还可以接受。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>书接上回。昨天我写了一篇《这个限流库两个大bug存在了半年之久，没人发现？》，提到了Go语言中的<code>time.Sleep</code>函数的问题。有网友也私下和我探讨，提到这个可能属于系统的问题，因为现代的操作系统都是分时操作系统，每个线程可能会分配一个或者多个时间片，Windows默认线程时间精度在15毫秒，Linux在1毫秒，所以<code>time.Sleep</code>的精度不可能那么高。</p>
<p><strong>本文原文有误导，结论部分正确，我在文章末尾作了更正</strong></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
