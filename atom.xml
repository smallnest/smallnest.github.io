<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2022-12-22T01:34:48.793Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[机智！生抠 map的哈希函数]]></title>
    <link href="https://colobu.com/2022/12/21/use-the-builtin-map-hasher/"/>
    <id>https://colobu.com/2022/12/21/use-the-builtin-map-hasher/</id>
    <published>2022-12-21T09:17:43.000Z</published>
    <updated>2022-12-21T12:29:25.473Z</updated>
    <content type="html"><![CDATA[<p>前一段时间我尝试为<a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="external">orcaman/concurrent-map</a>实现泛型的支持时，遭遇到为任意类型计算哈希值的问题，现在这个库也自己实现了泛型支持，你也可以看到它的哈希也没有好的办法，只能提供出一个函数对象让用户自己实现。当然你也可以参考[cornelk/hashmap/blob/36b3b9c2b7ec993f1ef12a6957d45826aca726e6/util_hash.go#L49)中的实现，但是它的实现既不全面也不高效？</p>
<p>我们经常会在一些场景，比如特定的数据结构、cache等场景中使用这样一个哈希函数，那么如何为任务类型实现一个优雅高效的hash函数呢？其实Go运行时中map中就实现了。回想一下内建的map是不是支持泛型的？它的key可以是<code>comparable</code>类型(包括接口类型),内部实现中会把此类型的key计算一个哈希值，能不能吧它的hash函数拿出来使用？很遗憾，Go官方并没有想暴露出来这样的hasher的想法，它的代码也是不容易抽取整理成一个hasher函数。</p>
<p>今天看到一篇文章<a href="https://www.dolthub.com/blog/2022-12-19-maphash/" target="_blank" rel="external">Hacking Go&#39;s Runtime with Generics</a>,提供了一种方法，脑洞大开。没看之前确实没想到，看到之后才发觉这么简单有效，接下来我翻译了这么文章，赶快学习吧。</p>
<a id="more"></a>
<p>今天的博客是关于<a href="https://github.com/dolthub/maphash" target="_blank" rel="external">maphash</a>的，这是一个用于哈希任意Go类型(<code>comparable</code>)。我们将深入探讨它是如何实现的，以及一些有趣的 Golang 运行时花絮。</p>
<h2 id="散列所有类型">散列所有类型</h2>
<p><code>maphash</code>是一个超级小的库，旨在达到一个目的：将 Golang 内置哈希的强大功能交到开发人员手中。 任意 Golang 类型可以使用<code>maphash.Hasher</code>进行哈希处理。 API 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Hasher[K comparable] <span class="keyword">struct</span> {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewHasher[K comparable]() Hasher[K] {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h Hasher[K]) Hash(key K) <span class="typename">uint64</span> {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Go语言中，<code>comparable</code>类型约束是所有实现了操作符<code>==</code>和<code>!=</code>类型的集合(接口类型目前还不在这个集合中，但是后续的Go版本接口也很快满足comparable类型约束了)，这包括所有scalar 类型、channel、接口、数组和字段类型是comparable的结构。基本上maphash中你可以用任何类型作为map的key。</p>
<p>那么有什么意义呢？这个包的动机来自于为 Dolt 实现并发的、<a href="https://dzone.com/articles/fine-grained-concurrency-guava" target="_blank" rel="external">stripe-locked</a>的缓存。设计看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Cache[K comparable, V any] <span class="keyword">struct</span> {</div><div class="line">    stripes <span class="number">[64</span>]<span class="keyword">map</span>[K]V</div><div class="line">    locks   <span class="number">[64</span>]sync.RWLock</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用泛型，我们可以创建一个由内置map支持的灵活的容器类。但是，当我们尝试实现这个类的访问器方法时，我们陷入了编写泛型函数来选择每个键所属的stripe的困境：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getStripe returns the stripe that |key| belongs to.</span></div><div class="line"><span class="keyword">func</span> (c Cache[K, V]) getStripe(key K) <span class="typename">int8</span> {</div><div class="line">    ???</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们这里需要的是泛型的哈希函数,为comparable类型K提供哈希算法。</p>
<h2 id="背景">背景</h2>
<p>希望Go标准库提供一个公开的通用哈希函数的想法由来已久。 Golang团队的Byran Mills 2017年最早就提出了这个想法<a href="https://github.com/golang/go/issues/21195" target="_blank" rel="external">#21195</a>， 建议添加一个内置函数去哈希comparable类型，方便实现自定义容器和数据结构。该提案认为，Golang开发人员在编写基于哈希的数据结构(<a href="https://en.wikipedia.org/wiki/Trie#" target="_blank" rel="external">Tries</a>、<a href="https://pkg.go.dev/github.com/orcaman/concurrent-map#ConcurrentMap.Set" target="_blank" rel="external">concurrent hash map</a>)时， 被迫多大量的额外的工作。 想要高效的基于哈希数据结构的开发人员只有使用内置的map。</p>
<p>当这个问题最初在 2017 年创建时，Golang 没有泛型，因此提议的接口缺少具体类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Local(<span class="keyword">interface</span>{}) <span class="typename">uintptr</span></div></pre></td></tr></table></figure>

<p>这个 API 起初似乎是合理的，但是因为没有具体的类型信息，编译器没法高效的实现它。Go内建map能够高效实现的秘密在于它为各种类型产生了定制的哈希函数<a href="https://dave.cheney.net/tag/maps" target="_blank" rel="external">custom hash functions</a>。产生的哈希函数知道怎么去遍历指定的类型，并能利用硬件支持的 <a href="https://en.wikipedia.org/wiki/AES_instruction_set" target="_blank" rel="external">AES</a>指令加速哈希。不幸的是，所有的模仿都隐藏在运行时中，编译器在编译的时候才去处理。</p>
<p>在 Go 1.19 中，标准库增加了<a href="https://pkg.go.dev/hash/maphash" target="_blank" rel="external">maphash</a>包，核暴露了哈希字符串和字节切片的能力，可以利用AES指令加速。这些添加当然是好事，但是它们仍然缺乏编写通用容器类型所需的灵活性，今年早些时候<a href="https://github.com/golang/go/issues/54670" target="_blank" rel="external">#54670</a>提议扩展这个包支持任意的comparable类型，但是依照Go团队的风格，&quot;不是我的提案都不高优，我的提案最高优&quot;，这个提案就一直挂在哪里。目前我们只有一个选择，通过黑客的方式自己实现。</p>
<h3 id="破解运行时">破解运行时</h3>
<p>我们已经知道，编译器有能力生成这样一个哈希函数，更进一步，我们知道使用<code>map[T]V</code>会触发编译器生成一个为类型<code>T</code>哈希的函数，这个哈希函数可以通过<code>maptype</code>类型得到:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> {</div><div class="line">    typ    _type</div><div class="line">    key    *_type</div><div class="line">    elem   *_type</div><div class="line">    bucket *_type <span class="comment">// internal type representing a hash bucket</span></div><div class="line">    <span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></div><div class="line">    hasher     <span class="keyword">func</span>(unsafe.Pointer, <span class="typename">uintptr</span>) <span class="typename">uintptr</span></div><div class="line">    keysize    <span class="typename">uint8</span>  <span class="comment">// size of key slot</span></div><div class="line">    elemsize   <span class="typename">uint8</span>  <span class="comment">// size of elem slot</span></div><div class="line">    bucketsize <span class="typename">uint16</span> <span class="comment">// size of bucket</span></div><div class="line">    flags      <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>map</code>时会传入<code>*maptype</code>和<code>*hmap</code>实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// v := map[k]</span></div><div class="line"><span class="keyword">func</span> mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// v, ok := map[k]</span></div><div class="line"><span class="keyword">func</span> mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, <span class="typename">bool</span>) {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// delete(map, k)</span></div><div class="line"><span class="keyword">func</span> mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>So how can we get access to this? Using Golang&#39;s unsafe package, we can work around the type system and get access to the private fields within t找到，hese runtime types. This is what it looks like in our new maphash package:</p>
<p>妥了，目标已经找到，下一步是我们如何才能获得这个哈希函数呢？使用 Golang 的<code>unsafe</code>包，下面的代码就是我们的maphash库中的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> getRuntimeHasher[K comparable]() (h hashfn, seed <span class="typename">uintptr</span>) {</div><div class="line">    a := any(<span class="built_in">make</span>(<span class="keyword">map</span>[K]<span class="keyword">struct</span>{}))</div><div class="line">    i := (*mapiface)(unsafe.Pointer(&a))</div><div class="line">    h, seed = i.typ.hasher, <span class="typename">uintptr</span>(i.val.hash0)</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> hashfn <span class="keyword">func</span>(unsafe.Pointer, <span class="typename">uintptr</span>) <span class="typename">uintptr</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> mapiface <span class="keyword">struct</span> {</div><div class="line">    typ *maptype</div><div class="line">    val *hmap</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// mirrors go/src/runtime/type.go</span></div><div class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> {</div><div class="line">    typ    _type</div><div class="line">    key    *_type</div><div class="line">    elem   *_type</div><div class="line">    bucket *_type</div><div class="line">    <span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></div><div class="line">    hasher     <span class="keyword">func</span>(unsafe.Pointer, <span class="typename">uintptr</span>) <span class="typename">uintptr</span></div><div class="line">    keysize    <span class="typename">uint8</span></div><div class="line">    elemsize   <span class="typename">uint8</span></div><div class="line">    bucketsize <span class="typename">uint16</span></div><div class="line">    flags      <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>In getRuntimeHasher<a href="">K comparable</a>, start by declaring a map[K]struct{}. This declaration makes the compiler create the hash function we want. Next we cast our map to type any, forcing the compiler to add additional metadata do describe the dynamic type of the variable a. For maps, this metadata is a pointer to a maptype object, which is just what we need to access the hash function! Using an unsafe.Pointer we can cast a to mapiface (a runtime type), get our hasher, and construct a maphash.Hasher:</p>
<p>在<code>getRuntimeHasher[K comparable]()</code>的开始部分，声明了一个<code>map[K]struct{}</code>。这个声明促使编译器创建我们所需要的哈希函数。下一步我们把这个map转换成<code>any</code>类型，强制编译器增加一些元数据信息。对于map类型，这些元数据是一个指针，指向 <code>maptype</code>类型，这个类型正式我们能拿到哈希函数的类型!</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Hasher[K comparable] <span class="keyword">struct</span> {</div><div class="line">    hash hashfn</div><div class="line">    seed <span class="typename">uintptr</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewHasher[K comparable]() Hasher[K] {</div><div class="line">    h, s := getRuntimeHasher[K]()</div><div class="line">    <span class="keyword">return</span> Hasher[K]{hash: h, seed: s}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Using a maphash.Hasher we can create hash-based datastructures keyed by UUIDs, time.Time, or any other comparable type. And thanks to the compiler, Hasher is able to take advantage of optimized AES instructions. Hashing a string with maphash is just as fast as the standard library version!</p>
<p>使用<code>maphash.Hasher</code>我们可以创建基于哈希的数据结构，key可以是 UUID、time.Time或者其它comparable类型。借助于编译器，这个Hasher还能充分利用 AES 指令，哈希字符串的性能和标准库的一样快:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">goos: darwin</div><div class="line">goarch: amd64</div><div class="line">pkg: github.com/dolthub/maphash</div><div class="line">cpu: Intel(R) Core(TM) i7<span class="number">-9750</span>H CPU @<span class="number"> 2.60</span>GHz</div><div class="line">BenchmarkCompareStringHasher</div><div class="line">BenchmarkCompareStringHasher/string_hasher</div><div class="line">BenchmarkCompareStringHasher/string_hasher<span class="number">-12</span>         <span class="number">	237970230</span>	        <span class="number"> 5.341</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkCompareStringHasher/std_string_hasher</div><div class="line">BenchmarkCompareStringHasher/std_string_hasher<span class="number">-12</span>     <span class="number">	207972664</span>	        <span class="number"> 5.759</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">PASS</div></pre></td></tr></table></figure>

<h2 id="一个虚心的请求">一个虚心的请求</h2>
<p>如果你认为这段代码是对Golang的滥用，我同意你的看法。maphash的实现，就像map一样，是和运行时紧紧耦合的。虽然最近几个Go的版本中，map类型相对稳定，但是任何有影响的改变都得移植到maphash库中。相当脆弱！maphash使用<a href="https://www.digitalocean.com/community/tutorials/customizing-go-binaries-with-build-tags" target="_blank" rel="external">build tags</a>限制此库使用的Go版本为Go 1.18和 Go 1.19，未来的版本我们也会扩展支持。</p>
<p>如果您认为有更好的方法可以做到这一点，我再次同意您的看法！我虚心的提出一个要求，希望你能到<a href="https://github.com/golang/go/issues/54670" target="_blank" rel="external">#54670</a>评论，并upvote支持一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Comparable returns the hash of comparable value v with the given seed</span></div><div class="line"><span class="comment">// such that Comparable(s, v1) == Comparable(s, v2) if v1 == v2.</span></div><div class="line"><span class="comment">// If v contains a floating-point NaN, then the hash is non-deterministically random.</span></div><div class="line"><span class="keyword">func</span> Comparable[T comparable](seed Seed, v T) <span class="typename">uint64</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>前一段时间我尝试为<a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="external">orcaman/concurrent-map</a>实现泛型的支持时，遭遇到为任意类型计算哈希值的问题，现在这个库也自己实现了泛型支持，你也可以看到它的哈希也没有好的办法，只能提供出一个函数对象让用户自己实现。当然你也可以参考[cornelk/hashmap/blob/36b3b9c2b7ec993f1ef12a6957d45826aca726e6/util_hash.go#L49)中的实现，但是它的实现既不全面也不高效？</p>
<p>我们经常会在一些场景，比如特定的数据结构、cache等场景中使用这样一个哈希函数，那么如何为任务类型实现一个优雅高效的hash函数呢？其实Go运行时中map中就实现了。回想一下内建的map是不是支持泛型的？它的key可以是<code>comparable</code>类型(包括接口类型),内部实现中会把此类型的key计算一个哈希值，能不能吧它的hash函数拿出来使用？很遗憾，Go官方并没有想暴露出来这样的hasher的想法，它的代码也是不容易抽取整理成一个hasher函数。</p>
<p>今天看到一篇文章<a href="https://www.dolthub.com/blog/2022-12-19-maphash/" target="_blank" rel="external">Hacking Go&#39;s Runtime with Generics</a>,提供了一种方法，脑洞大开。没看之前确实没想到，看到之后才发觉这么简单有效，接下来我翻译了这么文章，赶快学习吧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[没用微服务，Shopify的单体程序居然支撑了127万/秒的请求？]]></title>
    <link href="https://colobu.com/2022/12/04/Shopify-monolith-served-1-27-Million-requests-per-second-during-Black-Friday/"/>
    <id>https://colobu.com/2022/12/04/Shopify-monolith-served-1-27-Million-requests-per-second-during-Black-Friday/</id>
    <published>2022-12-04T10:02:12.000Z</published>
    <updated>2022-12-21T09:15:07.822Z</updated>
    <content type="html"><![CDATA[<p>在今年的国外的黑色星期五(类似国内的双十一购物季)， Shopify公司取得了亮眼的成绩，他们的工程团队给出了以下的技术的数据：</p>
<a id="more"></a>
<ul>
<li>MySQL: 1400万/秒 QPS (峰值)</li>
<li>Metrics: 200亿的指标/分钟，27G/秒指标数据</li>
<li>服务峰值：127万/秒 服务调用,7598万次/每分钟</li>
<li>320亿个异步服务</li>
<li>240亿个webhhok</li>
<li>Kafka: 2000万条消息/秒</li>
</ul>
<p>Shopify 是加拿大的一家跨国电子商务公司，总部位于安大略省渥太华，Shopify也是该公司所有的电子商务平台的名称。Shopify为在线零售商提供一整套服务“包括支付、市场营销、运输和客户契合工具，以简化小型商户开设在线商店的过程”。Shopify成立于2004年，公司的三位创始人原计划开设一家经营滑雪设备的在线商店（Snowdevil），由于对市场上的电子商务产品不够满意，创始人之一的程序员吕特克决定开发一套自己的程序。吕特克使用开源框架Ruby on Rails进行开发，2006年6月Shopify平台上线。2015 年 Shopify 在纽约与多伦多两地证券交易所上市。</p>
<blockquote>
<p>有些人总是会问大厂为什么主要使用某些语言？比如腾讯百度偏爱C/C++、阿里喜欢Java、字节钟情Go,一些公司使用Python等等。其实很多情况下并没有太多的道理，公司初始的时候时候就是要活下来，使用最熟悉的编程语言快速生成出原型产品，得到市场的认可快速扩大的过程中一般还是会基于最基础的语言和平台，中间发展中重新设计和推到重来的情况非常少，至多也就是公司在迅速扩大的过程中有些团队会引入其他编程语言，但是主编程语言和平台还是有初创时期抉择结果的影子。</p>
</blockquote>
<p>回到主题，我们看到Shopify公布的今年黑色星期五的计数中有一条：</p>
<p><strong>服务峰值：127万/秒 服务调用,7598万次/每分钟</strong></p>
<p>也许你不知道的是，Shopify 和stackoverflow一样，并不是一个微服务的发烧友，他们的商务平台是一个单体程序，所有的商务平台代码都在一个仓库中。</p>
<p>难道一个单体程序就能达到每秒百万的服务，尤其是复杂的电子商务业务？</p>
<p>这里是很多人误区，尤其当今单体架构貌似都被标记成“坏”的标签。单体程序在有些场景下还是有市场的，尤其是Shopify这样业务，他们实现了模块化的单体程序，实际并不是一台服务器一个应用程序的方式部署，而是可以部署成百个单体程序，通过分片等方式也可以做到规模横向扩展。</p>
<p>当然我整理这篇文章也不是鼓吹单体架构，而且我觉得他们采用单体架构有历史的背景，通过模块化组织，组件式的开发也满足他们当前的规模和业务方向。但是一旦规模持续扩大，并且公司进行多元化的经营，还是会遇到规模等各种问题，就像他们前几年遇到的情况一样，他们通过一年多的治理，摸索出解决单体架构的困境，将来有一天，他们还是要继续治理。</p>
<p>那么本文通过他们工程团队分享的资料，看看它们的经验。</p>
<h2 id="单体程序_vs_微服务">单体程序 vs 微服务</h2>
<p>依照维基百科上的定义，单体(monolith)程序的各种功能都是交织在一起的，而不是架构上独立的组件。对于Shopify单体来说，处理运费计算的代码与处理结账的代码共存，几乎没有什么可以阻止它们相互调用。随着时间的推移，这导致了处理不同业务流程的代码之间的高度耦合。</p>
<h3 id="单体程序的优缺点">单体程序的优缺点</h3>
<p>优点：</p>
<ul>
<li>容易实现，没有复杂的架构，尤其对于Shopify使用的 RoR (Ruby on Rails)，所有代码都在一个库这，引用方便。</li>
<li>就一个代码库，管理和发布很容易。在代码库中可以搜索到所有代码和函数。测试和发布流水线就一套。数据存储到一套可以共享的数据库中，数据库的跨表查询也方便。</li>
<li>因为单体程序的功能都作为一个整体都发布到一个地方，部署架构也简单，就一套环境标准就可以了。数据库、web服务、后台任务、Redis、Kafka、ES等等就一套。</li>
<li>因为是单体，你可以直接调用其它的组件，而不是通过rpc或者web service api去访问其它的服务</li>
</ul>
<p>缺点：<br>随着规模的扩大，单体程序也面临的不可控的问题，Shopify在2016年也遇到了问题。</p>
<ul>
<li>应用程序变得脆弱了，新的代码带来了意想不到的影响,看似无害的更改可能会引发一连串不相关的测试失败。</li>
<li>代码的紧耦合和缺乏边界，导致测试难以编写，并且在CI上运行缓慢</li>
<li>即使做一个简单改变的开发，也得需要了解复杂的上下文，尤其对于新员工=来说，两眼黑。复杂的单体应用程序会导致陡峭的学习曲线。</li>
</ul>
<p>Shopify工程师认为，他们遇到的所有问题都是由于代码中不同功能之间缺乏界限的直接结果。他们要做的工作是减少不同业务领域之间的耦合，但问题是如何去做？</p>
<blockquote>
<p>当然这里我认为还有部分业务领域可能需要大规模的扩展，但有些业务不需要，那么如果进行部分业务扩展？某个业务需要升级或者降级，需要单体程序整体升降机？如果一个业务有问题导致程序异常，异常所有的业务？所有这些，Shopify的工程师并没有回答，或者说，这对于他们来说不是最重要的问题。</p>
</blockquote>
<h3 id="为啥不使用微服务？">为啥不使用微服务？</h3>
<p>Shopify工程师也考察了微服务架构。微服务架构是一种应用程序开发方法，其中大型应用程序构建为一组独立部署的较小服务。他们认为虽然微服务可以解决他们遇到的问题，但它们会带来另一套问题。</p>
<p>改造成微服务，他们必须维护不同的测试和部署流水线，并且需要为每个微服务增加基础设施的开销。每个微服务都是独立部署的，他们之间的访问需要跨网络，带来了延迟，并且降低开了可用性。并且跨多个服务的大型重构可能很繁琐，需要更改所有依赖服务并协调部署。</p>
<p>总结一下，他们的担忧是:</p>
<ul>
<li>测试和运维复杂</li>
<li>需要更多的部署成本</li>
<li>微服务带来网络延迟和可用性降低</li>
<li>现在全改成微服务很麻烦了</li>
</ul>
<p>第1，2条可能不是问题。作为一个上市公司，这个成本应该还不算问题。第三条是微服务必然带来的问题，在架构抉择的会做权衡。第四条属于骑虎难下的情况，我的架构已经这样了，让我推到重来，对于一个上市公司服务了那么多的客户，这个架构的全改变确实风险太高了。另外这里他们并没有考虑未来的业务发展带来的更大规模的影响，以及新的业务带来的需求。</p>
<p>为了降低第四条的影响，其实是可以逐步的应用微服务，比如把结账服务抽取成微服务，逐步演进。但是Shopify工程师没有这么做，而是从单体程序的模块化入手去解决。</p>
<h2 id="模块化单体程序">模块化单体程序</h2>
<p>他们想要一个在不增加部署单元数量的情况下提高模块化的解决方案，使我们能够获得单体和微服务的优势，而没有太多缺点。这不就是鱼与熊掌都想兼得嘛，有这种好事？</p>
<p><img src="MonolithvsMicroservicesbySimonBrown.webp" alt=""></p>
<p>模块化单体是一个系统，其中所有代码都服务于单个应用程序，并且不同业务域之间存在严格强制执行的边界。</p>
<p>Shopify实现模块化单体的方式是组件化(Componentization)，2017年初他们成立了一个精干的小组专门去解决这个问题。</p>
<p>他们重新组织了他们的代码结构：<br><img src="ReorganizationByRealWorldConceptsBeforeAndAfter.webp" alt=""></p>
<p>可以看到，它们把一个单体程序按照业务分成了多个组件，每个组件都是一个单独的小的RoR程序，最终组件作为ruby模块，它们之间不再耦合。</p>
<p>进一步的解耦业务域，它们之间定义清晰的边界接口，域边界通过公共API标识，并对关联数据拥有独占所有权。他们分析组件之间的调用，并且专门做了一个跟踪系统进行分析和推进。</p>
<p>可以说，Shopify的工程师从模块化单体程序方向上做了很多工作。</p>
<p>其实感觉他们这样做，正在朝着微服务架构方式做演进，当然他们将来也未必改造成微服务，不过和微服务的演进方式很类似，首先进行了业务域的划分和边界的整改，程序还是一个单体程序。</p>
<h2 id="Shopify_数据单体">Shopify 数据单体</h2>
<p>Shopify数据库的架构也非常有意思。他们也应对大量的数据库访问，就像今年黑五的指标一样，1400万/秒 QPS的峰值。如果应对呢？</p>
<p>最初他们采用分片的方式能够水平扩展数据库并继续增长。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Sharding.with_each_shard <span class="built_in">do</span></div><div class="line"></div><div class="line">some_action</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">end</span></span></div></pre></td></tr></table></figure>

<p>但是失去了性能和可扩展性。如果我们的任何分片出现故障，整个操作将无法在整个平台上使用。2016年，我们坐下来重组Shopify的运行时架构。他们意识到仅仅对数据库进行分片是不够的，需要完全<strong>隔离</strong>每个分片，这样故障就不会演变成平台中断。他们引入了 pod（不要与 Kubernetes pods 混淆）来解决这个问题。容器由一组商店组成，这些商店位于一组完全隔离的数据存储上。每个工作单元（Web 请求和延迟作业）分配给单个 Pod。这意味着，处理请求只需要一个 Pod 联机。</p>
<p><img src="ReorganizationByRealWorldConceptsBeforeAndAfter.webp" alt=""></p>
<p>Shopify为每个 Pod 分配了一对数据中心，在任何时候，其中一个将成为活动数据中心，而第二个充当恢复站点,也就是master-standby的方式容灾。他们还开发了一种名为 Pod Mover 的工具，允许我们在一分钟内将 Pod 移动到其恢复数据中心，而不会丢弃请求或作业。</p>
<p>如果能把业务分解成这样，还怕什么规模扩展呢？有规模的需求就扩展POD就好了，而且POD之间有隔离，每个POD就是一个单体。</p>
<p>总体上看， Shopify采用务实的方式，结合自己公司的历史架构、开发特点，摸索出一套行之有效的手段，在今年的黑五中很好的应对了流量洪峰。</p>
<h2 id="参考资料">参考资料</h2>
<ol start="0">
<li><a href="https://www.reddit.com/r/programming/comments/z90juf/shopify_monolith_served_127_million_requests_per/" target="_blank" rel="external">https://www.reddit.com/r/programming/comments/z90juf/shopify_monolith_served_127_million_requests_per/</a></li>
<li><a href="https://shopify.engineering/shopify-monolith" target="_blank" rel="external">https://shopify.engineering/shopify-monolith</a></li>
<li><a href="https://shopify.engineering/deconstructing-monolith-designing-software-maximizes-developer-productivity" target="_blank" rel="external">https://shopify.engineering/deconstructing-monolith-designing-software-maximizes-developer-productivity</a></li>
<li><a href="https://shopify.engineering/a-pods-architecture-to-allow-shopify-to-scale" target="_blank" rel="external">https://shopify.engineering/a-pods-architecture-to-allow-shopify-to-scale</a></li>
<li><a href="https://stackshare.io/kirs/decisions" target="_blank" rel="external">https://stackshare.io/kirs/decisions</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在今年的国外的黑色星期五(类似国内的双十一购物季)， Shopify公司取得了亮眼的成绩，他们的工程团队给出了以下的技术的数据：</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些关于时间和定时任务的库]]></title>
    <link href="https://colobu.com/2022/11/26/some-time-and-cron-libs/"/>
    <id>https://colobu.com/2022/11/26/some-time-and-cron-libs/</id>
    <published>2022-11-26T04:11:53.000Z</published>
    <updated>2022-12-21T09:15:07.884Z</updated>
    <content type="html"><![CDATA[<p>避免重复发明轮子。如果有一些好用的库，我们就直接使用就好了，没必要做一些重复的工作，如果这些库不能满足需求，不妨提交pull request或者clone 它们，提升它们，优化它们，当前前提是你得知道它们。</p>
<p>这篇文章给大家介绍一些关于时间和类似linux cron功能的定时任务库。</p>
<a id="more"></a>
<h2 id="jinzhu/now">jinzhu/now</h2>
<p>张金柱大佬除了给大家贡献了gorm外，还写了一些好用的Go库， <a href="https://github.com/jinzhu/now" target="_blank" rel="external">jinzhu/now</a>就是之一。</p>
<p>当前，Go标准库提供了关于时间的库<a href="https://pkg.go.dev/time" target="_blank" rel="external">time</a>，可以满足我们80%的场景，但是对于一些特殊的场景，使用标准库却很麻烦，其它一些编程语言也是这样，标准库中的时间相关的函数在一些特殊场景下不方便使用，金柱提供的now库满足了一些特殊场景的需求，使用起来特别的方便。</p>
<p>这个库最重要的函数我把它分成两类：</p>
<ul>
<li>计算第一天和最后一天的函数</li>
<li>解析</li>
</ul>
<p>当然它还包含求四季，以及明确求周日周一的函数(有的国家和地区星期天算一周的开始、有的周一算一周的开始)，这更少用了，我们就不介绍了。</p>
<h3 id="计算开始和最后时刻的函数">计算开始和最后时刻的函数</h3>
<p>给定一个时间，你可以得到这个时刻的此分钟开始的时刻、此小时开始的时刻、此天的开始的时刻、此周开始的时刻、此月开始的时刻、此季节开始的时刻、此半年开始的时刻，此年开始的时刻：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/jinzhu/now"</span></div><div class="line"></div><div class="line">time.Now() <span class="comment">// 2013-11-18 17:51:49.123456789 Mon</span></div><div class="line"></div><div class="line">now.BeginningOfMinute()        <span class="comment">// 2013-11-18 17:51:00 Mon</span></div><div class="line">now.BeginningOfHour()          <span class="comment">// 2013-11-18 17:00:00 Mon</span></div><div class="line">now.BeginningOfDay()           <span class="comment">// 2013-11-18 00:00:00 Mon</span></div><div class="line">now.BeginningOfWeek()          <span class="comment">// 2013-11-17 00:00:00 Sun</span></div><div class="line">now.BeginningOfMonth()         <span class="comment">// 2013-11-01 00:00:00 Fri</span></div><div class="line">now.BeginningOfQuarter()       <span class="comment">// 2013-10-01 00:00:00 Tue</span></div><div class="line">now.BeginningOfYear()          <span class="comment">// 2013-01-01 00:00:00 Tue</span></div></pre></td></tr></table></figure>

<p>或者这个时刻的此分钟最后的时刻、此小时最后的时刻、此天的最后的时刻、此周最后的时刻、此月最后的时刻、此季节最后的时刻、此半年最后的时刻，此年最后的时刻：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">now.EndOfMinute()              <span class="comment">// 2013-11-18 17:51:59.999999999 Mon</span></div><div class="line">now.EndOfHour()                <span class="comment">// 2013-11-18 17:59:59.999999999 Mon</span></div><div class="line">now.EndOfDay()                 <span class="comment">// 2013-11-18 23:59:59.999999999 Mon</span></div><div class="line">now.EndOfWeek()                <span class="comment">// 2013-11-23 23:59:59.999999999 Sat</span></div><div class="line">now.EndOfMonth()               <span class="comment">// 2013-11-30 23:59:59.999999999 Sat</span></div><div class="line">now.EndOfQuarter()             <span class="comment">// 2013-12-31 23:59:59.999999999 Tue</span></div><div class="line">now.EndOfYear()                <span class="comment">// 2013-12-31 23:59:59.999999999 Tue</span></div><div class="line"></div><div class="line">now.WeekStartDay = time.Monday <span class="comment">// 设置 Monday 作为每周的第一天, 默认星期天是一周的第一天</span></div><div class="line">now.EndOfWeek()                <span class="comment">// 2013-11-24 23:59:59.999999999 Sun</span></div></pre></td></tr></table></figure>

<p>如果你是求当前时刻的开始时刻和结束时刻，你可以使用包的函数，它提供了便利的函数，比如当前小时的开始时刻:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_ = time.BeginningOfHour()</div></pre></td></tr></table></figure>

<p>它实际的实现是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BeginningOfHour() time.Time {</div><div class="line">	<span class="keyword">return</span> With(time.Now()).BeginningOfHour()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你还可以设置特定的时区、日期格式和每周的开始的第一天是星期一还是星期天:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myConfig := &now.Config{</div><div class="line">	WeekStartDay: time.Monday,</div><div class="line">	TimeLocation: location,</div><div class="line">	TimeFormats: []<span class="typename">string</span>{<span class="string">"2006-01-02 15:04:05"</span>},</div><div class="line">}</div><div class="line"></div><div class="line">t := time.Date<span class="number">(2013</span>,<span class="number"> 11</span>,<span class="number"> 18</span>,<span class="number"> 17</span>,<span class="number"> 51</span>,<span class="number"> 49</span>,<span class="number"> 123456789</span>, time.Now().Location()) <span class="comment">// // 2013-11-18 17:51:49.123456789 Mon</span></div><div class="line">myConfig.With(t).BeginningOfWeek()         <span class="comment">// 2013-11-18 00:00:00 Mon</span></div></pre></td></tr></table></figure>

<h3 id="日期解析">日期解析</h3>
<p>标注库的日期解析方式是以样本的方式提供的，比如<code>2006-01-02 15:04:05</code>,这种解析方法比较特殊，经常我们需要查看帮助文档才能正确设置想起的格式，而且解析的时候容错能力不是太好。</p>
<p><code>jizhu/now</code>库提供了一种容错式的解析方式，它会遍历标准库的<a href="https://pkg.go.dev/time#pkg-constants" target="_blank" rel="external">时间格式</a>，尝试使用其中的一种格式进行解析。它的处理方式有遍历和正则表达式，所以如果是在追求性能和日期格式比较明确的情况下，用标准库的解析就好，但是如果不追求极致的性能，这个解析能很好的容错，你不需要记住格式模板，输入一个日期字符串它就能解析。(哦觉得它还可以做一个优化，除了标准库提供的日期格式外，允许用户提供特定的日期格式模板，并且设定优先级)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Parse(string) (time.Time, error)</span></div><div class="line">t, err := now.Parse(<span class="string">"2017"</span>)                <span class="comment">// 2017-01-01 00:00:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"2017-10"</span>)             <span class="comment">// 2017-10-01 00:00:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"2017-10-13"</span>)          <span class="comment">// 2017-10-13 00:00:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"1999-12-12 12"</span>)       <span class="comment">// 1999-12-12 12:00:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"1999-12-12 12:20"</span>)    <span class="comment">// 1999-12-12 12:20:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"1999-12-12 12:20:21"</span>) <span class="comment">// 1999-12-12 12:20:21, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"10-13"</span>)               <span class="comment">// 2013-10-13 00:00:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"12:20"</span>)               <span class="comment">// 2013-11-18 12:20:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"12:20:13"</span>)            <span class="comment">// 2013-11-18 12:20:13, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"14"</span>)                  <span class="comment">// 2013-11-18 14:00:00, nil</span></div><div class="line">t, err := now.Parse(<span class="string">"99:99"</span>)               <span class="comment">// 2013-11-18 12:20:00, Can't parse string as time: 99:99</span></div><div class="line"></div><div class="line"><span class="comment">// MustParse must parse string to time or it will panic</span></div><div class="line">now.MustParse(<span class="string">"2013-01-13"</span>)             <span class="comment">// 2013-01-13 00:00:00</span></div><div class="line">now.MustParse(<span class="string">"02-17"</span>)                  <span class="comment">// 2013-02-17 00:00:00</span></div><div class="line">now.MustParse(<span class="string">"2-17"</span>)                   <span class="comment">// 2013-02-17 00:00:00</span></div><div class="line">now.MustParse(<span class="string">"8"</span>)                      <span class="comment">// 2013-11-18 08:00:00</span></div><div class="line">now.MustParse(<span class="string">"2002-10-12 22:14"</span>)       <span class="comment">// 2002-10-12 22:14:00</span></div><div class="line">now.MustParse(<span class="string">"99:99"</span>)                  <span class="comment">// panic: Can't parse string as time: 99:99</span></div></pre></td></tr></table></figure>

<h2 id="carbon">carbon</h2>
<p>carbon是另外一个日期/时间扩展库。很多语言都有一个兼做carbon的日期扩展库，比如javascript、php、python、rust等等。Go语言这也不止一个，这里我介绍的是<a href="https://github.com/golang-module/carbon" target="_blank" rel="external">golang-module/carbon</a><br>golang-module/carbon是一个轻量级、语义化、对开发者友好的 golang 时间处理库，支持链式调用，由<a href="https://www.gouguoyin.com/" target="_blank" rel="external">够过瘾</a>开发。</p>
<p>它提供了非常丰富的函数，看的我老眼昏花。它提供的函数大致分为几类。</p>
<h3 id="创建carbon实例">创建carbon实例</h3>
<p>根据参数的不同，创建的方式很多，下面只是列出了几种创建的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">carbon.CreateFromTimestamp<span class="number">(0</span>).ToString() <span class="comment">// 1970-01-01 08:00:00 +0800 CST</span></div><div class="line">carbon.CreateFromTimestampMilli<span class="number">(1649735755981</span>).ToString() <span class="comment">// 2022-04-12 11:55:55.981 +0800 CST</span></div><div class="line">carbon.CreateFromDate<span class="number">(2020</span>,<span class="number"> 8</span>,<span class="number"> 5</span>).ToString() <span class="comment">// // 2020-08-05 13:14:15 +0800 CST</span></div><div class="line">carbon.CreateFromTime<span class="number">(13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>).ToString() <span class="comment">// 2020-08-05 13:14:15 +0800 CST</span></div></pre></td></tr></table></figure>

<p>和标准库互转:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将 time.Time 转换成 Carbon</span></div><div class="line">carbon.Time2Carbon(time.Now())</div><div class="line"><span class="comment">// 将 Carbon 转换成 time.Time</span></div><div class="line">carbon.Now().Carbon2Time()</div></pre></td></tr></table></figure>

<p>昨天、今天和明天, 以及转换成字符串，下面是一部分例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 今天此刻</span></div><div class="line">fmt.Sprintf(<span class="string">"%s"</span>, carbon.Now()) <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.Now().ToString() <span class="comment">// 2020-08-05 13:14:15 +0800 CST</span></div><div class="line">carbon.Now().ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line"><span class="comment">// 今天日期</span></div><div class="line">carbon.Now().ToDateString() <span class="comment">// 2020-08-05</span></div><div class="line"><span class="comment">// 今天时间</span></div><div class="line">carbon.Now().ToTimeString() <span class="comment">// 13:14:15</span></div><div class="line"></div><div class="line"><span class="comment">// 昨天此刻</span></div><div class="line">fmt.Sprintf(<span class="string">"%s"</span>, carbon.Yesterday()) <span class="comment">// 2020-08-04 13:14:15</span></div><div class="line">carbon.Yesterday().ToString() <span class="comment">// 2020-08-04 13:14:15 +0800 CST</span></div><div class="line"></div><div class="line"><span class="comment">// 明天此刻</span></div><div class="line">fmt.Sprintf(<span class="string">"%s"</span>, carbon.Tomorrow()) <span class="comment">// 2020-08-06 13:14:15</span></div><div class="line">carbon.Tomorrow().ToString() <span class="comment">// 2020-08-06 13:14:15 +0800 CST</span></div><div class="line">carbon.Tomorrow().ToDateTimeString() <span class="comment">// 2020-08-06 13:14:15</span></div></pre></td></tr></table></figure>

<p>一些字符串格式例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出日期时间字符串</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05T13:14:15.999999999+08:00"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line"><span class="comment">// 输出日期时间字符串，包含毫秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05T13:14:15.999999999+08:00"</span>).ToDateTimeMilliString() <span class="comment">// 2020-08-05 13:14:15.999</span></div><div class="line"><span class="comment">// 输出日期时间字符串，包含微秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05T13:14:15.999999999+08:00"</span>).ToDateTimeMicroString() <span class="comment">// 2020-08-05 13:14:15.999999</span></div><div class="line"><span class="comment">// 输出日期时间字符串，包含纳秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05T13:14:15.999999999+08:00"</span>).ToDateTimeNanoString() <span class="comment">// 2020-08-05 13:14:15.999999999</span></div></pre></td></tr></table></figure>

<h3 id="解析">解析</h3>
<p>carbon解析采用标准格式或者模板格式，标准格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">carbon.Parse(<span class="string">"now"</span>).ToString() <span class="comment">// 2020-08-05 13:14:15 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"yesterday"</span>).ToString() <span class="comment">// 2020-08-04 13:14:15 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"tomorrow"</span>).ToString() <span class="comment">// 2020-08-06 13:14:15 +0800 CST</span></div><div class="line"></div><div class="line">carbon.Parse(<span class="string">"2020"</span>).ToString() <span class="comment">// 2020-01-01 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-8"</span>).ToString() <span class="comment">// 2020-08-01 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-08"</span>).ToString() <span class="comment">// 2020-08-01 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-8-5"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-8-05"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05.999"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00.999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05.999999"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00.999999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05.999999999"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00.999999999 +0800 CST</span></div><div class="line"></div><div class="line">carbon.Parse(<span class="string">"2020-8-5 13:14:15"</span>).ToString() <span class="comment">// 2020-08-05 13:14:15 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-8-05 13:14:15"</span>).ToString() <span class="comment">// 2020-08-05 13:14:15 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05T13:14:15.999999999+08:00"</span>).ToString() <span class="comment">// 2020-08-05 13:14:15.999999999 +0800 CST</span></div><div class="line"></div><div class="line">carbon.Parse(<span class="string">"20200805"</span>).ToString() <span class="comment">// 2020-08-05 00:00:00 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"20200805131415.999999999+08:00"</span>).ToString() <span class="comment">// 2020-08-05 13:14:15.999999999 +0800 CST</span></div></pre></td></tr></table></figure>

<p>模板格式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">carbon.ParseByFormat(<span class="string">"2020|08|05 13|14|15"</span>, <span class="string">"Y|m|d H|i|s"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.ParseByFormat(<span class="string">"It is 2020-08-05 13:14:15"</span>, <span class="string">"\\I\\t \\i\\s Y-m-d H:i:s"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.ParseByFormat(<span class="string">"今天是 2020年08月05日13时14分15秒"</span>, <span class="string">"今天是 Y年m月d日H时i分s秒"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.ParseByFormat(<span class="string">"2020-08-05 13:14:15"</span>, <span class="string">"Y-m-d H:i:s"</span>, carbon.Tokyo).ToDateTimeString() <span class="comment">// 2020-08-05 14:14:15</span></div></pre></td></tr></table></figure>

<p>或者Go标准库布局模式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">carbon.ParseByLayout(<span class="string">"2020|08|05 13|14|15"</span>, <span class="string">"2006|01|02 15|04|05"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.ParseByLayout(<span class="string">"It is 2020-08-05 13:14:15"</span>, <span class="string">"It is 2006-01-02 15:04:05"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.ParseByLayout(<span class="string">"今天是 2020年08月05日13时14分15秒"</span>, <span class="string">"今天是 2006年01月02日15时04分05秒"</span>).ToDateTimeString() <span class="comment">// 2020-08-05 13:14:15</span></div><div class="line">carbon.ParseByLayout(<span class="string">"2020-08-05 13:14:15"</span>, <span class="string">"2006-01-02 15:04:05"</span>, carbon.Tokyo).ToDateTimeString() <span class="comment">// 2020-08-05 14:14:15</span></div></pre></td></tr></table></figure>

<h3 id="开始时刻和结束时刻">开始时刻和结束时刻</h3>
<p>和jizhu/now的功能类似，求一个时刻开始点和结束点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 本世纪开始时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).StartOfCentury().ToDateTimeString() <span class="comment">// 2000-01-01 00:00:00</span></div><div class="line"><span class="comment">// 本世纪结束时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).EndOfCentury().ToDateTimeString() <span class="comment">// 2999-12-31 23:59:59</span></div><div class="line"></div><div class="line"><span class="comment">// 本年代开始时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).StartOfDecade().ToDateTimeString() <span class="comment">// 2020-01-01 00:00:00</span></div><div class="line">carbon.Parse(<span class="string">"2021-08-05 13:14:15"</span>).StartOfDecade().ToDateTimeString() <span class="comment">// 2020-01-01 00:00:00</span></div><div class="line">carbon.Parse(<span class="string">"2029-08-05 13:14:15"</span>).StartOfDecade().ToDateTimeString() <span class="comment">// 2020-01-01 00:00:00</span></div><div class="line"><span class="comment">// 本年代结束时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).EndOfDecade().ToDateTimeString() <span class="comment">// 2029-12-31 23:59:59</span></div><div class="line">carbon.Parse(<span class="string">"2021-08-05 13:14:15"</span>).EndOfDecade().ToDateTimeString() <span class="comment">// 2029-12-31 23:59:59</span></div><div class="line">carbon.Parse(<span class="string">"2029-08-05 13:14:15"</span>).EndOfDecade().ToDateTimeString() <span class="comment">// 2029-12-31 23:59:59</span></div><div class="line"></div><div class="line"><span class="comment">// 本年开始时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).StartOfYear().ToDateTimeString() <span class="comment">// 2020-01-01 00:00:00</span></div><div class="line"><span class="comment">// 本年结束时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).EndOfYear().ToDateTimeString() <span class="comment">// 2020-12-31 23:59:59</span></div><div class="line"></div><div class="line"><span class="comment">// 本季度开始时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).StartOfQuarter().ToDateTimeString() <span class="comment">// 2020-07-01 00:00:00</span></div><div class="line"><span class="comment">// 本季度结束时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).EndOfQuarter().ToDateTimeString() <span class="comment">// 2020-09-30 23:59:59</span></div><div class="line"></div><div class="line">......</div><div class="line"><span class="comment">// 本分钟开始时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).StartOfMinute().ToDateTimeString() <span class="comment">// 2020-08-05 13:14:00</span></div><div class="line"><span class="comment">// 本分钟结束时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).EndOfMinute().ToDateTimeString() <span class="comment">// 2020-08-05 13:14:59</span></div><div class="line"></div><div class="line"><span class="comment">// 本秒开始时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).StartOfSecond().ToString() <span class="comment">// 2020-08-05 13:14:15 +0800 CST</span></div><div class="line"><span class="comment">// 本秒结束时间</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).EndOfSecond().ToString() <span class="comment">// 2020-08-05 13:14:15.999999999 +0800 CST</span></div></pre></td></tr></table></figure>



<p>好吧，向上它已经提供劳务世纪初和世纪末的时间点、已经秒级别的开始时间点和结束时间点。</p>
<h3 id="时间旅行">时间旅行</h3>
<p>提供了时间时移的功能，增加时间或者减少时间到另外一个时间点。</p>
<p>依然很大气哦，可以提供世纪级别的方法纳秒级别的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 三个世纪后</span></div><div class="line">carbon.Parse(<span class="string">"2020-02-29 13:14:15"</span>).AddCenturies<span class="number">(3</span>).ToDateTimeString() <span class="comment">// 2320-02-29 13:14:15</span></div><div class="line"><span class="comment">// 三个世纪后(月份不溢出)</span></div><div class="line">carbon.Parse(<span class="string">"2020-02-29 13:14:15"</span>).AddCenturiesNoOverflow<span class="number">(3</span>).ToDateTimeString() <span class="comment">// 2320-02-29 13:14:15</span></div><div class="line">......</div><div class="line"><span class="comment">// 三个世纪后</span></div><div class="line">carbon.Parse(<span class="string">"2020-02-29 13:14:15"</span>).AddCenturies<span class="number">(3</span>).ToDateTimeString() <span class="comment">// 2320-02-29 13:14:15</span></div><div class="line"><span class="comment">// 三个世纪后(月份不溢出)</span></div><div class="line">carbon.Parse(<span class="string">"2020-02-29 13:14:15"</span>).AddCenturiesNoOverflow<span class="number">(3</span>).ToDateTimeString() <span class="comment">// 2320-02-29 13:14:15</span></div><div class="line">......</div><div class="line"><span class="comment">// 三纳秒后</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15.222222222"</span>).AddNanoseconds<span class="number">(3</span>).ToString() <span class="comment">// 2020-08-05 13:14:15.222222225 +0800 CST</span></div><div class="line"><span class="comment">// 一纳秒后</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15.222222222"</span>).AddNanossecond().ToString() <span class="comment">// 2020-08-05 13:14:15.222222223 +0800 CST</span></div><div class="line"><span class="comment">// 三纳秒前</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15.222222222"</span>).SubNanosseconds<span class="number">(3</span>).ToString() <span class="comment">// 2020-08-05 13:14:15.222222219 +0800 CST</span></div><div class="line"><span class="comment">// 一纳秒前</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15.222222222"</span>).SubNanossecond().ToString() <span class="comment">// 2020-08-05 13:14:15.222222221 +0800 CST</span></div></pre></td></tr></table></figure>

<p>仁者见仁智者见智，有些人喜欢这种细粒度的方法，挺好。不过看到这么多的方法，提供类似的功能，我会提供一个方法，然后第二个单位用枚举类型来指定，这样一个时移通过一个方法就搞定了，这样学习起来和维护起来比较方便，比如我会设计成这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">carbon.Parse(<span class="string">"2020-02-29 13:14:15"</span>).Add<span class="number">(3</span>, carbon.Century)</div><div class="line">carbon.Parse(<span class="string">"2020-02-29 13:14:15"</span>).Add<span class="number">(3</span>, carbon.Nano)</div></pre></td></tr></table></figure>

<p>你喜欢哪种方法，欢迎评论区写出你的想法。</p>
<h3 id="时间差">时间差</h3>
<p>求两个时间的差值,比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相差多少年</span></div><div class="line">carbon.Parse(<span class="string">"2021-08-05 13:14:15"</span>).DiffInYears(carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>)) <span class="comment">// -1</span></div><div class="line"><span class="comment">// 相差多少年（绝对值）</span></div><div class="line">carbon.Parse(<span class="string">"2021-08-05 13:14:15"</span>).DiffAbsInYears(carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>)) <span class="comment">// 1</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">/ 相差多少秒</div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).DiffInSeconds(carbon.Parse(<span class="string">"2020-08-05 13:14:14"</span>)) <span class="comment">// -1</span></div><div class="line"><span class="comment">// 相差多少秒（绝对值）</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).DiffAbsInSeconds(carbon.Parse(<span class="string">"2020-08-05 13:14:14"</span>)) <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 相差字符串</span></div><div class="line">carbon.Now().DiffInString() <span class="comment">// just now</span></div><div class="line">carbon.Now().AddYearsNoOverflow<span class="number">(1</span>).DiffInString() <span class="comment">// -1 year</span></div><div class="line">carbon.Now().SubYearsNoOverflow<span class="number">(1</span>).DiffInString() <span class="comment">// 1 year</span></div><div class="line"><span class="comment">// 相差字符串（绝对值）</span></div><div class="line">carbon.Now().DiffAbsInString(carbon.Now()) <span class="comment">// just now</span></div><div class="line">carbon.Now().AddYearsNoOverflow<span class="number">(1</span>).DiffAbsInString(carbon.Now()) <span class="comment">// 1 year</span></div><div class="line">carbon.Now().SubYearsNoOverflow<span class="number">(1</span>).DiffAbsInString(carbon.Now()) <span class="comment">// 1 year</span></div></pre></td></tr></table></figure>

<h3 id="一些时间判断">一些时间判断</h3>
<p>比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">carbon.Parse(<span class="string">"0"</span>).IsZero() <span class="comment">// true</span></div><div class="line">carbon.Parse(<span class="string">"0000-00-00 00:00:00"</span>).IsZero() <span class="comment">// true</span></div><div class="line">carbon.Parse(<span class="string">"0"</span>).IsZero() <span class="comment">// true</span></div><div class="line">carbon.Parse(<span class="string">"0000-00-00 00:00:00"</span>).IsZero() <span class="comment">// true</span></div><div class="line"><span class="comment">// 是否是闰年</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).IsLeapYear() <span class="comment">// true</span></div><div class="line"><span class="comment">// 是否是长年</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).IsLongYear() <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 是否是一月</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).IsJanuary() <span class="comment">// false</span></div><div class="line"><span class="comment">// 是否是闰年</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).IsLeapYear() <span class="comment">// true</span></div><div class="line"><span class="comment">// 是否是长年</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).IsLongYear() <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 是否是一月</span></div><div class="line">carbon.Parse(<span class="string">"2020-08-05 13:14:15"</span>).IsJanuary() <span class="comment">// false</span></div></pre></td></tr></table></figure>

<h3 id="设置时间的某个单位">设置时间的某个单位</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/ 设置区域</div><div class="line">carbon.Parse(<span class="string">"2020-07-05 13:14:15"</span>).SetLocale(<span class="string">"en"</span>).DiffForHumans() <span class="comment">// 1 month ago</span></div><div class="line">carbon.Parse(<span class="string">"2020-07-05 13:14:15"</span>).SetLocale(<span class="string">"zh-CN"</span>).DiffForHumans() <span class="comment">// 1 月前</span></div><div class="line"></div><div class="line"><span class="comment">// 设置年月日时分秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTime<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>).ToString() <span class="comment">// 2019-02-02 13:14:15 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTime<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>).ToString() <span class="comment">// 2019-03-03 13:14:15 +0800 CST</span></div><div class="line"><span class="comment">// 设置年月日时分秒毫秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMilli<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999</span>).ToString() <span class="comment">// 2019-02-02 13:14:15.999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMilli<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999</span>).ToString() <span class="comment">// 2019-03-03 13:14:15.999 +0800 CST</span></div><div class="line"><span class="comment">// 设置年月日时分秒微秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMicro<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999</span>).ToString() <span class="comment">// 2019-02-02 13:14:15.999999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMicro<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999</span>).ToString() <span class="comment">// 2019-03-03 13:14:15.999999 +0800 CST</span></div><div class="line"><span class="comment">// 设置年月日时分秒纳秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeNano<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999999</span>).ToString() <span class="comment">// 2019-02-02 13:14:15.999999999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeNano<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999999</span>).ToString() <span class="comment">// 2019-03-03 13:14:15.999999999 +0800 CST</span></div></pre></td></tr></table></figure>

<h3 id="获取时间的某个单位">获取时间的某个单位</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/ 设置区域</div><div class="line">carbon.Parse(<span class="string">"2020-07-05 13:14:15"</span>).SetLocale(<span class="string">"en"</span>).DiffForHumans() <span class="comment">// 1 month ago</span></div><div class="line">carbon.Parse(<span class="string">"2020-07-05 13:14:15"</span>).SetLocale(<span class="string">"zh-CN"</span>).DiffForHumans() <span class="comment">// 1 月前</span></div><div class="line"></div><div class="line"><span class="comment">// 设置年月日时分秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTime<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>).ToString() <span class="comment">// 2019-02-02 13:14:15 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTime<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>).ToString() <span class="comment">// 2019-03-03 13:14:15 +0800 CST</span></div><div class="line"><span class="comment">// 设置年月日时分秒毫秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMilli<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999</span>).ToString() <span class="comment">// 2019-02-02 13:14:15.999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMilli<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999</span>).ToString() <span class="comment">// 2019-03-03 13:14:15.999 +0800 CST</span></div><div class="line"><span class="comment">// 设置年月日时分秒微秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMicro<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999</span>).ToString() <span class="comment">// 2019-02-02 13:14:15.999999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeMicro<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999</span>).ToString() <span class="comment">// 2019-03-03 13:14:15.999999 +0800 CST</span></div><div class="line"><span class="comment">// 设置年月日时分秒纳秒</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeNano<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 2</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999999</span>).ToString() <span class="comment">// 2019-02-02 13:14:15.999999999 +0800 CST</span></div><div class="line">carbon.Parse(<span class="string">"2020-01-01"</span>).SetDateTimeNano<span class="number">(2019</span>,<span class="number"> 2</span>,<span class="number"> 31</span>,<span class="number"> 13</span>,<span class="number"> 14</span>,<span class="number"> 15</span>,<span class="number"> 999999999</span>).ToString() <span class="comment">// 2019-03-03 13:14:15.999999999 +0800 CST</span></div><div class="line"></div><div class="line"><span class="comment">// 获取当前区域</span></div><div class="line">carbon.Now().Locale() <span class="comment">// en</span></div><div class="line">carbon.Now().SetLocale(<span class="string">"zh-CN"</span>).Locale() <span class="comment">// zh-CN</span></div><div class="line"></div><div class="line"><span class="comment">// 获取当前星座</span></div><div class="line">carbon.Now().Constellation() <span class="comment">// Leo</span></div><div class="line">carbon.Now().SetLocale(<span class="string">"en"</span>).Constellation() <span class="comment">// Leo</span></div><div class="line">carbon.Now().SetLocale(<span class="string">"zh-CN"</span>).Constellation() <span class="comment">// 狮子座</span></div><div class="line"></div><div class="line"><span class="comment">// 获取当前季节</span></div><div class="line">carbon.Now().Season() <span class="comment">// Summer</span></div><div class="line">carbon.Now().SetLocale(<span class="string">"en"</span>).Season() <span class="comment">// Summer</span></div><div class="line">carbon.Now().SetLocale(<span class="string">"zh-CN"</span>).Season() <span class="comment">// 夏季</span></div></pre></td></tr></table></figure>

<p>carbon还提供了获取星座、季节、农历的方法， 以及设计json编解码的数据格式，数据库日期格式的支持。</p>
<p>总体来说， carbon提供了非常丰富，可以说是保姆级的方法，让你处理日期时间的时候不用再做格外的处理。</p>
<h2 id="robfig/cron">robfig/cron</h2>
<p>在做业务开发的时候，我们经常会设置一些定时器，有些情况下我们使用<a href="https://pkg.go.dev/time#Ticker" target="_blank" rel="external">Ticker</a>就好了，但是我们想做更细致的定时任务的控制，就得另想办法了，大家第一个想到的就是Linux的cron功能，非常的灵活，所以Go生态圈中也有相应的库，这里给大家介绍两个。</p>
<p><a href="https://pkg.go.dev/github.com/robfig/cron/v3" target="_blank" rel="external">robfig/cron</a>是一款兼容Linux cron格式的定时任务库，同时它还提供了扩展的格式，支持秒粒度的设定，这是一种兼容知名的Java Tigger库<a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/tutorial-lesson-06.html" target="_blank" rel="external">quartz</a>的格式。我们以Linux cron格式介绍。</p>
<p>虽然cron提供<code>AddFunc</code>、<code>AddJob</code>、<code>Schedule</code>,但是大同小异，我们一般用<code>AddFunc</code>去增加定时任务。<code>AddFunc</code>的第一个参数是cron 表达式，第二个参数是无参函数，用来在cron定义的表达式包额诶触发时要执行的函数。<br>cron使用的例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">c := cron.New()</div><div class="line">c.AddFunc(<span class="string">"30 * * * *"</span>, <span class="keyword">func</span>() { fmt.Println(<span class="string">"在每个小时的30分钟的时候实行"</span>) })</div><div class="line">c.AddFunc(<span class="string">"30 3-6,20-23 * * *"</span>, <span class="keyword">func</span>() { fmt.Println(<span class="string">"在每天早上3-6点, 晚上8-11点的30分钟执行"</span>) })</div><div class="line">c.AddFunc(<span class="string">"CRON_TZ=Asia/Shanghai 30 04 * * *"</span>, <span class="keyword">func</span>() { fmt.Println(<span class="string">"在每天的北京时间04:30执行"</span>) }) <span class="comment">// 如果不指定，默认使用机器的时区</span></div><div class="line">c.AddFunc(<span class="string">"@hourly"</span>,      <span class="keyword">func</span>() { fmt.Println(<span class="string">"每一小时执行。从1小时后开始"</span>) })</div><div class="line">c.AddFunc(<span class="string">"@every 1h30m"</span>, <span class="keyword">func</span>() { fmt.Println(<span class="string">"每一小时30分执行，1小时30分开始"</span>) })</div><div class="line">c.Start()</div><div class="line">...</div><div class="line"><span class="comment">// 函数在它们的goroutine中异步的执行</span></div><div class="line">...</div><div class="line"><span class="comment">// 期间可以安全的增加任务</span></div><div class="line">c.AddFunc(<span class="string">"@daily"</span>, <span class="keyword">func</span>() { fmt.Println(<span class="string">"每天执行"</span>) })</div><div class="line">...</div><div class="line"><span class="comment">// 可以检查任务的状态</span></div><div class="line">inspect(c.Entries())</div><div class="line">...</div><div class="line">c.Remove(entryID) <span class="comment">// 移除某个任务</span></div><div class="line">...</div><div class="line">c.Stop()  <span class="comment">// 不再执行后续的任务</span></div></pre></td></tr></table></figure>

<p>`</p>
<p><strong>cron的格式</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">字段名        <span class="string">| 强制设置?   | 允许值           | 允许的特殊字符</span></div><div class="line">----------   <span class="string">| ---------- | --------------  | --------------------------</span></div><div class="line">Minutes      <span class="string">| Yes        | 0-59            | * / , -</span></div><div class="line">Hours        <span class="string">| Yes        | 0-23            | * / , -</span></div><div class="line">Day of month <span class="string">| Yes        | 1-31            | * / , - ?</span></div><div class="line">Month        <span class="string">| Yes        | 1-12 or JAN-DEC | * / , -</span></div><div class="line">Day of week  <span class="string">| Yes        | 0-6 or SUN-SAT  | * / , - ?</span></div></pre></td></tr></table></figure>

<p><a href="https://en.wikipedia.org/wiki/Cron" target="_blank" rel="external">维基百科</a>也介绍了cron的格式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># ┌───────────── minute (0 - 59)</span></div><div class="line"><span class="preprocessor"># │ ┌───────────── hour (0 - 23)</span></div><div class="line"><span class="preprocessor"># │ │ ┌───────────── day of the month (1 - 31)</span></div><div class="line"><span class="preprocessor"># │ │ │ ┌───────────── month (1 - 12)</span></div><div class="line"><span class="preprocessor"># │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;</span></div><div class="line"><span class="preprocessor"># │ │ │ │ │                                   7 is also Sunday on some systems)</span></div><div class="line"><span class="preprocessor"># │ │ │ │ │</span></div><div class="line"><span class="preprocessor"># │ │ │ │ │</span></div><div class="line"><span class="preprocessor"># * * * * * &lt;command to execute&gt;</span></div></pre></td></tr></table></figure>

<p><strong>特殊字符</strong>代表的意义：</p>
<ul>
<li><code>*</code>: 代表满足这个字段的每一个值。</li>
<li><code>/</code>: 代表对于时间范围的步数，比如第一个字段<code>*/5</code>代表每5分钟,也就是<code>5,10,15,20,25,30,35,40,45,50,55,00</code>分钟。</li>
<li><code>,</code>: 代表一组列表，比如第五个字段<code>MON,WED,FRI</code>代表每星期一、星期三、星期五会触发。</li>
<li><code>-</code>: 代表一个范围，比如第二个字段<code>10-15</code>代表会在每天10点、11点、12点、13点、14点、15点被触发。</li>
<li><code>?</code>: 有时候可以在第三个和第五个字段代替<code>*</code></li>
</ul>
<p>同时这个库还提供预定义的几种形式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">预定义类型               | 描述                                       | 等价格式</div><div class="line">-----                  | -----------                                | -------------</div><div class="line"><span class="variable">@yearly</span> (<span class="keyword">or</span> <span class="variable">@annually</span>) | 在每年的一月一日零点                          | <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> *</div><div class="line"><span class="variable">@monthly</span>               | 在每月的第一天零点                            | <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> * *</div><div class="line"><span class="variable">@weekly</span>                | 在每周的第一天零点，也就是周日零点              | <span class="number">0</span> <span class="number">0</span> * * <span class="number">0</span></div><div class="line"><span class="variable">@daily</span> (<span class="keyword">or</span> <span class="variable">@midnight</span>)  | 每天零点运行                                | <span class="number">0</span> <span class="number">0</span> * * *</div><div class="line"><span class="variable">@hourly</span>                | 每小时开始的时候运行                         | <span class="number">0</span> * * * *</div></pre></td></tr></table></figure>

<h2 id="go-co-op/gocron">go-co-op/gocron</h2>
<p><a href="https://github.com/go-co-op/gocron" target="_blank" rel="external">go-co-op/gocron</a>是另外一个优秀的定时任务库。</p>
<p>它提供了丰富的例子，所以很容易上手，你很容易把它应用到项目中。它的cron解析使用的就是上面的robfig/cron库,你可以使用cron格式实现定时任务:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/go-co-op/gocron"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> task = <span class="keyword">func</span>() {}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := gocron.NewScheduler(time.UTC)</div><div class="line"></div><div class="line">	_, _ = s.Cron(<span class="string">"*/1 * * * *"</span>).Do(task) <span class="comment">// 每分钟执行一次</span></div><div class="line">	_, _ = s.Cron(<span class="string">"0 1 * * *"</span>).Do(task)   <span class="comment">// 每天一点执行</span></div><div class="line">	_, _ = s.Cron(<span class="string">"0 0 * * 6,0"</span>).Do(task) <span class="comment">// 周末的零点执行</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是它还提供了其它人性化的设置，不一定使用cron配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">s := gocron.NewScheduler(time.UTC)</div><div class="line"></div><div class="line">s.Every<span class="number">(5</span>).Seconds().Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line"><span class="comment">// 每5分钟</span></div><div class="line">s.Every(<span class="string">"5m"</span>).Do(<span class="keyword">func</span>(){ ... })</div><div class="line"><span class="comment">// 每5天</span></div><div class="line">s.Every<span class="number">(5</span>).Days().Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line">s.Every<span class="number">(1</span>).Month<span class="number">(1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>).Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line"><span class="comment">// set time</span></div><div class="line">s.Every<span class="number">(1</span>).Day().At(<span class="string">"10:30"</span>).Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line"><span class="comment">// set multiple times</span></div><div class="line">s.Every<span class="number">(1</span>).Day().At(<span class="string">"10:30;08:00"</span>).Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line">s.Every<span class="number">(1</span>).Day().At(<span class="string">"10:30"</span>).At(<span class="string">"08:00"</span>).Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line"><span class="comment">// Schedule each last day of the month</span></div><div class="line">s.Every<span class="number">(1</span>).MonthLastDay().Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line"><span class="comment">// Or each last day of every other month</span></div><div class="line">s.Every<span class="number">(2</span>).MonthLastDay().Do(<span class="keyword">func</span>(){ ... })</div><div class="line"></div><div class="line"><span class="comment">// cron expressions supported</span></div><div class="line">s.Cron(<span class="string">"*/1 * * * *"</span>).Do(task) <span class="comment">// every minute</span></div><div class="line"></div><div class="line"><span class="comment">// 异步执行，避免任务会阻塞scheduler</span></div><div class="line">s.StartAsync()</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>避免重复发明轮子。如果有一些好用的库，我们就直接使用就好了，没必要做一些重复的工作，如果这些库不能满足需求，不妨提交pull request或者clone 它们，提升它们，优化它们，当前前提是你得知道它们。</p>
<p>这篇文章给大家介绍一些关于时间和类似linux cron功能的定时任务库。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[零拷贝技术第二篇：Go语言中的应用]]></title>
    <link href="https://colobu.com/2022/11/21/zero-copy-and-how-to-use-it-in-go-2/"/>
    <id>https://colobu.com/2022/11/21/zero-copy-and-how-to-use-it-in-go-2/</id>
    <published>2022-11-21T12:35:11.000Z</published>
    <updated>2022-12-21T09:15:07.884Z</updated>
    <content type="html"><![CDATA[<p>书接上回:<a href="https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/" target="_blank" rel="external">零拷贝技术第一篇：综述</a>, 我们留了一个小尾巴，还没有介绍Go语言中零拷贝技术的应用，那么本文将带你了解Go标准库中零拷贝技术。</p>
<a id="more"></a>
<h2 id="Go标准库中的零拷贝">Go标准库中的零拷贝</h2>
<p>在Go标准库中，也广泛使用了零拷贝技术来提高性能。因为零拷贝相关的技术很多都是通过系统调用提供的，所以在Go标准库中，也封装了这些系统调用，相关封装的代码可以在<a href="https://github.com/golang/go/tree/600db8a514600df0d3a11edc220ed7e2f51ca158/src/internal/poll" target="_blank" rel="external">internal/poll</a>找到。</p>
<p>我们以Linux为例，毕竟我们大部分的业务都是在Linux运行的。</p>
<h3 id="sendfile">sendfile</h3>
<p>在<code>internal/poll/sendfile_linux.go</code>文件中，封装了<code>sendfile</code>系统调用，我删除了一部分的代码，这样更容易看到它是如何封装的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/ SendFile wraps the sendfile system call.</div><div class="line"><span class="keyword">func</span> SendFile(dstFD *FD, src <span class="typename">int</span>, remain <span class="typename">int64</span>) (<span class="typename">int64</span>, error) {</div><div class="line">	...... <span class="comment">//写锁</span></div><div class="line"></div><div class="line">	dst := dstFD.Sysfd</div><div class="line">	<span class="keyword">var</span> written <span class="typename">int64</span></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">for</span> remain &gt;<span class="number"> 0</span> {</div><div class="line">		n := maxSendfileSize</div><div class="line">		<span class="keyword">if</span> <span class="typename">int64</span>(n) &gt; remain {</div><div class="line">			n = <span class="typename">int</span>(remain)</div><div class="line">		}</div><div class="line">		n, err1 := syscall.Sendfile(dst, src, <span class="constant">nil</span>, n)</div><div class="line">		<span class="keyword">if</span> n &gt;<span class="number"> 0</span> {</div><div class="line">			written += <span class="typename">int64</span>(n)</div><div class="line">			remain -= <span class="typename">int64</span>(n)</div><div class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> n ==<span class="number"> 0</span> && err1 == <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		...... <span class="comment">// error处理</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> written, err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到<code>SendFile</code>调用senfile批量写入数据。<code>sendfile</code>系统调用一次最多会传输 0x7ffff00(2147479552) 字节的数据。这里Go语言设置maxSendfileSize为 0&lt;&lt;20 (4194304)字节。</p>
<p><code>net/sendfile_linux.go</code>文件中会使用到它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> sendFile(c *netFD, r io.Reader) (written <span class="typename">int64</span>, err error, handled <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">var</span> remain <span class="typename">int64</span> =<span class="number"> 1</span> &lt;&lt;<span class="number"> 62</span> <span class="comment">// by default, copy until EOF</span></div><div class="line"></div><div class="line">	lr, ok := r.(*io.LimitedReader)</div><div class="line">	......</div><div class="line">	f, ok := r.(*os.File)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	sc, err := f.SyscallConn()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> werr error</div><div class="line">	err = sc.Read(<span class="keyword">func</span>(fd <span class="typename">uintptr</span>) <span class="typename">bool</span> {</div><div class="line">		written, werr = poll.SendFile(&c.pfd, <span class="typename">int</span>(fd), remain)</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	})</div><div class="line">	<span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">		err = werr</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> lr != <span class="constant">nil</span> {</div><div class="line">		lr.N = remain - written</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> written, wrapSyscallError(<span class="string">"sendfile"</span>, err), written &gt;<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个函数谁又会调用呢？是<strong>TCPConn</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *TCPConn) readFrom(r io.Reader) (<span class="typename">int64</span>, error) {</div><div class="line">	<span class="keyword">if</span> n, err, handled := splice(c.fd, r); handled {</div><div class="line">		<span class="keyword">return</span> n, err</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> n, err, handled := sendFile(c.fd, r); handled {</div><div class="line">		<span class="keyword">return</span> n, err</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> genericReadFrom(c, r)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个方法又会被ReadFrom方法封装。 记住这个<strong>ReadFrom</strong>方法，我们待会再说。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *TCPConn) ReadFrom(r io.Reader) (<span class="typename">int64</span>, error) {</div><div class="line">	<span class="keyword">if</span> !c.ok() {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, syscall.EINVAL</div><div class="line">	}</div><div class="line">	n, err := c.readFrom(r)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> && err != io.EOF {</div><div class="line">		err = &OpError{Op: <span class="string">"readfrom"</span>, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> n, err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>TCPConn.readFrom方法实现很有意思。它首先检查是否满足使用splice系统调用进行零拷贝优化，在目的是TCP connection, 源是TCP或者是Unix connection才能调用splice。<br>否则才尝试使用sendfile。如果要使用sendfile优化，也有限制，要求源是*os.File文件。<br>再否则使用不同的拷贝方式。</p>
<p>ReadFrom又会在什么情况下被调用？实际上你经常会用到，<code>io.Copy</code>就会调用<code>ReadFrom</code>。也许在不经意之间，当你在将文件写入到socket过程中，就不经意使用到了零拷贝。当然这不是唯一的调用和被使用的方式。</p>
<p>如果我们看一个调用链，就会把脉络弄清楚：<code>io.Copy</code> -&gt; <code>*TCPConn.ReadFrom</code> -&gt; <code>*TCPConn.readFrom</code> -&gt; <code>net.sendFile</code> -&gt; <code>poll.sendFile</code>。</p>
<h3 id="splice">splice</h3>
<p>上面你也看到了，<code>*TCPConn.readFrom</code>初始就是尝试使用splice,使用的场景和限制也提到了。<br><code>net.splice</code>函数其实是调用<code>poll.Splice</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Splice(dst, src *FD, remain <span class="typename">int64</span>) (written <span class="typename">int64</span>, handled <span class="typename">bool</span>, sc <span class="typename">string</span>, err error) {</div><div class="line">	p, sc, err := getPipe()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">false</span>, sc, err</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> putPipe(p)</div><div class="line">	<span class="keyword">var</span> inPipe, n <span class="typename">int</span></div><div class="line">	<span class="keyword">for</span> err == <span class="constant">nil</span> && remain &gt;<span class="number"> 0</span> {</div><div class="line">		max := maxSpliceSize</div><div class="line">		<span class="keyword">if</span> <span class="typename">int64</span>(max) &gt; remain {</div><div class="line">			max = <span class="typename">int</span>(remain)</div><div class="line">		}</div><div class="line">		inPipe, err = spliceDrain(p.wfd, src, max)</div><div class="line">		handled = handled || (err != syscall.EINVAL)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> || inPipe ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		p.data += inPipe</div><div class="line"></div><div class="line">		n, err = splicePump(dst, p.rfd, inPipe)</div><div class="line">		<span class="keyword">if</span> n &gt;<span class="number"> 0</span> {</div><div class="line">			written += <span class="typename">int64</span>(n)</div><div class="line">			remain -= <span class="typename">int64</span>(n)</div><div class="line">			p.data -= n</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> written, handled, <span class="string">"splice"</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> written, <span class="constant">true</span>, <span class="string">""</span>, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上一篇中讲到pipe如果每次都创建其实挺损耗性能的，所以这里使用了pip pool,也提到是潘少优化的。</p>
<p>所以你看到，不经意间你就会用到splice或者sendfile。</p>
<h3 id="CopyFileRange">CopyFileRange</h3>
<p><a href="https://github.com/golang/go/blob/600db8a514600df0d3a11edc220ed7e2f51ca158/src/internal/poll/copy_file_range_linux.go" target="_blank" rel="external">copy_file_range_linux.go</a>封装了copy_file_range系统调用。因为这个系统调用非常的新，所以封装的时候首先要检查Linux的版本，看看是否支持此系统调用。 版本检查和调用批量拷贝的代码我们略过，具体看是怎么使用这个系统调用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> copyFileRange(dst, src *FD, max <span class="typename">int</span>) (written <span class="typename">int64</span>, err error) {</div><div class="line">	<span class="keyword">if</span> err := dst.writeLock(); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> dst.writeUnlock()</div><div class="line">	<span class="keyword">if</span> err := src.readLock(); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> src.readUnlock()</div><div class="line">	<span class="keyword">var</span> n <span class="typename">int</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		n, err = unix.CopyFileRange(src.Sysfd, <span class="constant">nil</span>, dst.Sysfd, <span class="constant">nil</span>, max,<span class="number"> 0</span>)</div><div class="line">		<span class="keyword">if</span> err != syscall.EINTR {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">int64</span>(n), err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>哪里会使用到它呢？of.File的读取数据的时候：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pollCopyFileRange = poll.CopyFileRange</div><div class="line"></div><div class="line"><span class="keyword">func</span> (f *File) readFrom(r io.Reader) (written <span class="typename">int64</span>, handled <span class="typename">bool</span>, err error) {</div><div class="line">	<span class="comment">// copy_file_range(2) does not support destinations opened with</span></div><div class="line">	<span class="comment">// O_APPEND, so don't even try.</span></div><div class="line">	<span class="keyword">if</span> f.appendMode {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">false</span>, <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	remain := <span class="typename">int64</span><span class="number">(1</span> &lt;&lt;<span class="number"> 62</span>)</div><div class="line"></div><div class="line">	lr, ok := r.(*io.LimitedReader)</div><div class="line">	<span class="keyword">if</span> ok {</div><div class="line">		remain, r = lr.N, lr.R</div><div class="line">		<span class="keyword">if</span> remain &lt;=<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">true</span>, <span class="constant">nil</span></div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	src, ok := r.(*File)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">false</span>, <span class="constant">nil</span></div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> src.checkValid(<span class="string">"ReadFrom"</span>) != <span class="constant">nil</span> {</div><div class="line">		<span class="comment">// Avoid returning the error as we report handled as false,</span></div><div class="line">		<span class="comment">// leave further error handling as the responsibility of the caller.</span></div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, <span class="constant">false</span>, <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	written, handled, err = pollCopyFileRange(&f.pfd, &src.pfd, remain)</div><div class="line">	<span class="keyword">if</span> lr != <span class="constant">nil</span> {</div><div class="line">		lr.N -= written</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> written, handled, NewSyscallError(<span class="string">"copy_file_range"</span>, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同样的是*FIle.ReadFrom调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (f *File) ReadFrom(r io.Reader) (n <span class="typename">int64</span>, err error) {</div><div class="line">	<span class="keyword">if</span> err := f.checkValid(<span class="string">"write"</span>); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">	}</div><div class="line">	n, handled, e := f.readFrom(r)</div><div class="line">	<span class="keyword">if</span> !handled {</div><div class="line">		<span class="keyword">return</span> genericReadFrom(f, r) <span class="comment">// without wrapping</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> n, f.wrapErr(<span class="string">"write"</span>, e)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以这个优化用在文件的拷贝中，一般的调用链路是 <code>io.Copy</code> -&gt; <code>*File.ReadFrom</code> -&gt; <code>*File.readFrom</code> -&gt; <code>poll.CopyFileRange</code> -&gt; <code>poll.copyFileRange</code> </p>
<h3 id="标准库零拷贝的应用">标准库零拷贝的应用</h3>
<p>Go标准库将零拷贝技术在底层做了封装，所以很多时候你是不知道的。比如你实现了一个简单的文件服务器：</p>
<figure class="highlight package"><figcaption><span>main</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import <span class="string">"net/http"</span></div><div class="line"></div><div class="line">func main() {</div><div class="line"><span class="comment">	// 绑定一个handler</span></div><div class="line">	<span class="keyword">http</span>.Handle(<span class="string">"/"</span>, <span class="keyword">http</span>.StripPrefix(<span class="string">"/static/"</span>, <span class="keyword">http</span>.FileServer(<span class="keyword">http</span>.Dir(<span class="string">"../root.img"</span>))))</div><div class="line"><span class="comment">	// 监听服务</span></div><div class="line">	<span class="keyword">http</span>.ListenAndServe(<span class="string">":8972"</span>, nil)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>调用链如左：<code>http.FileServer</code> -&gt; <code>*fileHandler.ServeHTTP</code> -&gt; <code>http.serveFile</code> -&gt; <code>http.serveContent</code> -&gt; <code>io.CopyN</code> -&gt; <code>io.Copy</code> -&gt; 和sendFile的调用链接上了。<br>可以看到访问文件的时候是调用了sendFile。</p>
<h2 id="第三方库">第三方库</h2>
<p>有几个库提供了sendFile/splice的封装。</p>
<ul>
<li><a href="https://github.com/acln0/zerocopy" target="_blank" rel="external">https://github.com/acln0/zerocopy</a></li>
<li><a href="https://github.com/hslam/splice" target="_blank" rel="external">https://github.com/hslam/splice</a></li>
<li><a href="https://github.com/hslam/sendfile" target="_blank" rel="external">https://github.com/hslam/sendfile</a></li>
</ul>
<p>因为直接调用系统调用很方便，所以很多时候我们可以模仿标准库实现我们自己零拷贝的方法。<br>所以个人感觉这些传统的方式没有太多锦上添花的东西可做了，要做的就是新的零拷贝系统接口的封装或者自定义开发。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>书接上回:<a href="https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/" target="_blank" rel="external">零拷贝技术第一篇：综述</a>, 我们留了一个小尾巴，还没有介绍Go语言中零拷贝技术的应用，那么本文将带你了解Go标准库中零拷贝技术。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[零拷贝技术第一篇：综述]]></title>
    <link href="https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/"/>
    <id>https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/</id>
    <published>2022-11-19T14:37:16.000Z</published>
    <updated>2022-12-21T09:15:07.885Z</updated>
    <content type="html"><![CDATA[<p><strong>零拷贝</strong>(zero copy)在一些语境下指代的意思有所不同,本文讲的零拷贝就是大家常说的，通过这个技术让CPU释放出来不去执行内存中数据拷贝的功能，或者避免不必要的拷贝，所以说零拷贝不是没有数据的拷贝(复制)，而是广义上讲的减少和避免不必要的数据拷贝,可以用来节省CPU使用和内带宽等，比如通过网络高速传输文件、实现网络proxy等等，零拷技术可以极大的提高程序的性能。</p>
<a id="more"></a>
<p>本文总结零拷贝的各种技术，下一篇介绍常见的零拷贝技术在Go语言中的应用。</p>
<h2 id="零拷贝技术">零拷贝技术</h2>
<p>其实，零拷贝很久以来都被用在提升程序的性能上，比如nginx、kafka等，而且很多文章也详细介绍了零拷贝就要解决的问题，我在这里还是在总结一下，如果你已经了解了零拷贝的计数，不妨回顾一下。</p>
<p>我们来分析一个从网络读取文件的场景。服务器从磁盘读取一个文件，并写入到socket中返回给客户端。我们看看服务端的数据拷贝情况：<br><img src="readwrite.png" alt=""></p>
<p>程序开始使用系统调用<a href="https://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="external">read</a>告诉操作系统要从磁盘文件中读取数据，它首先从用户态切换到内核态，这个切换是有花费的，操作系统需要保存用户态的状态，一些寄存器的地址等，等read系统调用完成后返回，程序又需要从内核态切换到用户态，把保存的用户态的状态恢复，所以一次系统调用需要两次的用户态/内核态的切换。同样，把文件的内容写入到socket的时候，程序调用<a href="https://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="external">write</a>系统调用，又进行了两次用户态/内核态的切换。</p>
<p>从操作的数据来看，这个数据还被拷贝了四次。在read系统调用的时候，DMA方式从磁盘拷贝到内核缓冲区，又通过CPU拷贝从内核缓冲区拷贝到用户的程序缓冲区，这里发生了两次拷贝。在写入socket的时候，数据先从用户程序缓冲区写入到socket缓冲区，又通过DMA方式从socket缓冲区写入到网卡。数据拷贝也发生了四次。</p>
<blockquote>
<p>DMA(Direct Memory Access，直接存储器访问) 是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，允许不同速度的硬件设备来沟通，而不需要依于中央处理器的大量中断负载。</p>
</blockquote>
<p>你可以看到，传统的IO读写方式，包括了四次用户态/内核态的上下文切换，四次数据的拷贝，对性能的影响还是挺大的。广义的零拷贝的技术，就是要尽量减少用户态/内核态的上下文切换，以及数据的拷贝次数，为此操作系统也提供了几种方法。</p>
<h3 id="mmap_+_write">mmap + write</h3>
<p>通过mmap系统调用，将用户空间的虚拟地址和内核空间的虚拟地址映射成同一个物理地址这样可以减少内核空间和内核空间的数据拷贝。</p>
<p><img src="mmap.png" alt=""></p>
<p>通过mmap系统调用发起IO读取，DMA将磁盘数据写入到内核缓冲区，此时mmap系统调用就返回了。程序调用write系统调用，CPU将内核缓冲区的数据写入到socket缓冲区，DMA又将数据从socket缓冲区谢瑞到网卡。</p>
<p>可以看到，mmap+write方式有两次系统调用，发生四次用户态/内核态的切换，三次数据拷贝。</p>
<p>相对传统的IO方式，减少了一次数据拷贝，但是应该还有优化的空间。</p>
<h3 id="sendfile">sendfile</h3>
<p><a href="https://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">sendfile</a>是Linux2.1内核版本后引入的一个系统调用函数,用来优化数据传输。它可以在文件描述符之间传递数据，因为都是在内核之间传递数据，所以非常高效。<br>Linux 2.6.33之前目的文件描述符必须是文件，以后的版本就没有限制了，可以是任意的文件。</p>
<p>但是源文件描述符要求必须是支持<a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="external">mmap</a>操作的文件描述符，普通的文件可以，但是socket就不行了。所以sendfile适合从文件读取数据写socket场景，所以<strong>sendfile</strong>这个名字还是很贴切的，发送文件。</p>
<p><img src="sendfile.png" alt=""></p>
<p>用户调用sendfile系统调用，数据通过DMA拷贝到内核缓冲区，CPU将数据从内核缓冲区再写入到socket缓冲区，DMA将socket缓冲区数据写入到网卡，然后sendfile系统调用返回。</p>
<p>可以看到，这里只有一次系统调用，也就是两次用户态/内核态的切换，三次数据拷贝。</p>
<p>相对来说，这种方式对性能已经有所提升。</p>
<p>linux 2.4之后，又对sendfile做了优化，对于支持 dms scatter/gather功能的网卡，只把关于数据的位置和长度的信息的描述符被追加到了socket缓冲区中。DMA引擎直接把数据从内核缓冲区传输到网卡(protocol engine），从而消除了仅有的一次CPU拷贝。</p>
<p><img src="sg-dma.png" alt=""></p>
<h3 id="splice、tee、vmsplice">splice、tee、vmsplice</h3>
<p>sendfile性能虽好，但是还是有些场景下是不能使用的，比如我们想做一个socket proxy,源和目的都是socket,就不能直接使用sendfile了。这个时候我们可以考虑<a href="https://man7.org/linux/man-pages/man2/splice.2.html" target="_blank" rel="external">splice</a>。</p>
<p>Linux 2.6.30版本之前，源和目的只能有一个是管道(pipe), 自2.6.31开始, 源和目的只要保证有一个是就行。</p>
<p><img src="splice.png" alt=""></p>
<p>当然，如果我们处理的源和目的不是管道的话，我们可以先建立一个管道，这样就可以使用splice系统调用来实现零拷贝了。</p>
<p>但是，如果每次都创建一个管道，你会发现每次都会多一次系统调用，也就是两次用户态/内核态的切换，所以你如果频繁的拷贝数据，那么可以建立一个管道池就像潘建给Go的标准库提供的一个补丁一样，利用pipe pool对Go语言中的splice做了优化。</p>
<p>tee系统调用用来在两个管道中拷贝数据。<br>vmsplice系统调用pipe指向的内核缓冲区和用户程序的缓冲区之间的数据拷贝。</p>
<h3 id="MSG_ZEROCOPY">MSG_ZEROCOPY</h3>
<p>Linux v4.14 版本接受了在TCP send系统调用中实现的支持零拷贝(<a href="https://www.kernel.org/doc/html/v4.17/networking/msg_zerocopy.html" target="_blank" rel="external">MSG_ZEROCOPY</a>)的patch，通过这个patch，用户进程就能够把用户缓冲区的数据通过零拷贝的方式经过内核空间发送到网络套接字中去，在5.0中支持UDP。Willem de Bruijn 在他的论文里给出的压测数据是：采用 netperf 大包发送测试，性能提升 39%，而线上环境的数据发送性能则提升了 5%~8%，官方文档陈述说这个特性通常只在发送 10KB 左右大包的场景下才会有显著的性能提升。一开始这个特性只支持 TCP，到内核 v5.0 版本之后才支持 UDP。这里也有一篇官方文档介绍:<a href="https://lwn.net/Articles/726917/" target="_blank" rel="external">Zero-copy networking</a></p>
<p>首先你需要设置socket选项:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_ZEROCOPY, &one, <span class="keyword">sizeof</span>(one)))</div><div class="line">        error(<span class="number">1</span>, errno, <span class="string">"setsockopt zerocopy"</span>);</div></pre></td></tr></table></figure>

<p>然后调用send系统调用是传入<code>MSG_ZEROCOPY</code>参数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ret = send(fd, buf, <span class="keyword">sizeof</span>(buf), MSG_ZEROCOPY);</div></pre></td></tr></table></figure>

<p>这里我们传入了buf,但是啥时候buf可以重用呢？这个内核会通知程序进程。它将完成通知放在socket error队列中，所以你需要读取这个队列，知道拷贝啥时候完成buf可释放或者重用了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pfd.fd = fd;</div><div class="line">pfd.events = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (poll(&pfd, <span class="number">1</span>, -<span class="number">1</span>) != <span class="number">1</span> || pfd.revents & POLLERR == <span class="number">0</span>)</div><div class="line">        error(<span class="number">1</span>, errno, <span class="string">"poll"</span>);</div><div class="line"></div><div class="line">ret = recvmsg(fd, &msg, MSG_ERRQUEUE);</div><div class="line"><span class="keyword">if</span> (ret == -<span class="number">1</span>)</div><div class="line">        error(<span class="number">1</span>, errno, <span class="string">"recvmsg"</span>);</div><div class="line"></div><div class="line">read_notification(msg);</div></pre></td></tr></table></figure>

<p>因为它可能异步发送数据，你需要检查buf啥时候释放，增加代码复杂度，以及会导致多次用户态和内核态的上下文切换；</p>
<p>Linux 4.18中也支持的receive MSG_ZEROCOPY机制(<a href="https://lwn.net/Articles/752188/" target="_blank" rel="external">Zero-copy TCP receive</a>).</p>
<p>字节跳动的同学2021年10曾写过文章，通过修改内核的方式兼容先前的send调用方式。这毕竟是特殊的优化，不适合大众的使用方式，所以这个零拷贝的方式还是只在一些特殊的场景下进行优化：</p>
<blockquote>
<p>字节跳动框架组和字节跳动内核组合作，由内核组提供了同步的接口：当调用 sendmsg 的时候，内核会监听并拦截内核原先给业务的回调，并且在回调完成后才会让 sendmsg 返回。 这使得我们无需更改原有模型，可以很方便地接入 ZeroCopy send。同时，字节跳动内核组还实现了基于 unix domain socket 的 ZeroCopy，可以使得业务进程与 Mesh sidecar 之间的通信也达到零拷贝。</p>
<p><a href="https://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">字节跳动在 Go 网络库上的实践</a></p>
</blockquote>
<h3 id="copy_file_range">copy_file_range</h3>
<p>Linux 4.5 增加了一个新的API: <a href="https://man7.org/linux/man-pages/man2/copy_file_range.2.html" target="_blank" rel="external">copy_file_range</a>, 它在内核态进行文件的拷贝，不再切换用户空间，所以会比cp少块一些，在一些场景下会提升性能。<br><img src="copy_file_range.png" alt=""></p>
<h2 id="其它">其它</h2>
<p><a href="https://lwn.net/Articles/750845/" target="_blank" rel="external">AF_XDP</a>是Linux 4.18新增加的功能，以前称为AF_PACKETv4（从未包含在主线内核中），是一个针对高性能数据包处理优化的原始套接字，并允许内核和应用程序之间的零拷贝。由于套接字可用于接收和发送，因此它仅支持用户空间中的高性能网络应用。</p>
<p>当然零拷贝技术和数据拷贝的优化一直是大家追求性能优化的方式之一，相关技术也在不断研究之中，欢迎在原文的评论中写出你的看法。</p>
<p>##参考文章<br>以下文章是我整理的关于零拷贝技术一部分文章，如果你想深入了解零拷贝技术，可以阅读这些更多的文章。</p>
<ol>
<li><a href="https://www.zhihu.com/question/35093238?utm_id=0" target="_blank" rel="external">https://www.zhihu.com/question/35093238?utm_id=0</a></li>
<li><a href="https://strikefreedom.top/archives/pipe-pool-for-splice-in-go" target="_blank" rel="external">https://strikefreedom.top/archives/pipe-pool-for-splice-in-go</a></li>
<li><a href="https://www.modb.pro/db/212924" target="_blank" rel="external">https://www.modb.pro/db/212924</a></li>
<li><a href="https://blog.lpflpf.cn/passages/golang-zerocopy/" target="_blank" rel="external">https://blog.lpflpf.cn/passages/golang-zerocopy/</a></li>
<li><a href="https://medium.com/swlh/linux-zero-copy-using-sendfile-75d2eb56b39b" target="_blank" rel="external">https://medium.com/swlh/linux-zero-copy-using-sendfile-75d2eb56b39b</a></li>
<li><a href="https://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/#zerocopy" target="_blank" rel="external">https://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/#zerocopy</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/360343446" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/360343446</a></li>
<li><a href="https://blog.devgenius.io/linux-zero-copy-d61d712813fe" target="_blank" rel="external">https://blog.devgenius.io/linux-zero-copy-d61d712813fe</a></li>
<li><a href="https://www.kernel.org/doc/html/v4.18/networking/msg_zerocopy.html" target="_blank" rel="external">https://www.kernel.org/doc/html/v4.18/networking/msg_zerocopy.html</a></li>
<li><a href="https://lwn.net/Articles/879724/" target="_blank" rel="external">https://lwn.net/Articles/879724/</a></li>
<li><a href="https://www.phoronix.com/news/Linux-5.20-IO_uring-ZC-Send" target="_blank" rel="external">https://www.phoronix.com/news/Linux-5.20-IO_uring-ZC-Send</a></li>
<li><a href="https://en.wikipedia.org/wiki/Zero-copy" target="_blank" rel="external">https://en.wikipedia.org/wiki/Zero-copy</a></li>
<li><a href="https://aijishu.com/a/1060000000149804" target="_blank" rel="external">https://aijishu.com/a/1060000000149804</a></li>
<li><a href="https://github.com/golang/go/issues/48530" target="_blank" rel="external">https://github.com/golang/go/issues/48530</a></li>
<li><a href="https://juejin.cn/post/6863264864140935175" target="_blank" rel="external">https://juejin.cn/post/6863264864140935175</a></li>
<li><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="external">https://www.linuxjournal.com/article/6345</a></li>
<li><a href="https://jishuin.proginn.com/p/763bfbd47570" target="_blank" rel="external">https://jishuin.proginn.com/p/763bfbd47570</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>零拷贝</strong>(zero copy)在一些语境下指代的意思有所不同,本文讲的零拷贝就是大家常说的，通过这个技术让CPU释放出来不去执行内存中数据拷贝的功能，或者避免不必要的拷贝，所以说零拷贝不是没有数据的拷贝(复制)，而是广义上讲的减少和避免不必要的数据拷贝,可以用来节省CPU使用和内带宽等，比如通过网络高速传输文件、实现网络proxy等等，零拷技术可以极大的提高程序的性能。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[还咋优化？我是说Go程序]]></title>
    <link href="https://colobu.com/2022/10/17/a-first-look-at-arena/"/>
    <id>https://colobu.com/2022/10/17/a-first-look-at-arena/</id>
    <published>2022-10-17T14:26:09.000Z</published>
    <updated>2022-12-21T09:15:07.824Z</updated>
    <content type="html"><![CDATA[<p>Go语言是一个极容易上手的语言，而且Go程序的优化套路基本上被大家莫得清清楚楚的，如果你有心，可以在互联网上搜出很多Go程序优化的技巧，有些文章可能只介绍了几个优化点，有些文章从CPU的架构到Slice预分配，再到通过pprof找性能的瓶颈点等等全面介绍Go程序的优化，所以说可见的手段基本上被大家摸得门清，最近老貘出了一道题，如下所示，可以看到大家对Go语言的优化已经摸的多深了。</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> N =<span class="number"> 1000</span></div><div class="line"><span class="keyword">var</span> a [N]<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="comment">//go:noinline</span></div><div class="line"><span class="keyword">func</span> g0(a *[N]<span class="typename">int</span>) {</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> a {</div><div class="line">		a[i] = i <span class="comment">// line 12</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:noinline</span></div><div class="line"><span class="keyword">func</span> g1(a *[N]<span class="typename">int</span>) {</div><div class="line">	_ = *a <span class="comment">// line 18</span></div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> a {</div><div class="line">		a[i] = i <span class="comment">// line 20</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Go 官方也没闲着。虽然Go语言创立之初也并没有目标要和C++语言打平性能，但是Go团队对Go语言的编译和运行时优化也一直在进行着。</p>
<p>最近，Go语言也正在新加两个性能优化的特性，一个是<a href="https://github.com/golang/go/issues/55022#" target="_blank" rel="external">cmd/compile: profile-guided optimization</a>, 这个<a href="https://github.com/golang/proposal/blob/master/design/55022-pgo-implementation.md" target="_blank" rel="external">提案</a>已经被接受, 后续功能初步成型后我们再介绍。另外一个增加<a href="https://github.com/golang/go/issues/51317" target="_blank" rel="external">memory arena</a>。</p>
<p>除了大家常见的通用语言的优化外，影响Go程序性能最大的问题之一就是垃圾回收，所以使用C++、Rust开发的程序员diss Go程序的原因之一。不过这也是垃圾回收编程语言无法绕开的特性，基本上无可避免的带有STW的开销，即使没有STW,垃圾回收时也会耗资源进行对象的便利和检查，所以理论上来说Go性能相比较C+/Rust语言性能总会差一些，除非你禁用垃圾回收、纯粹做CPU计算。</p>
<p>Debian的 benchmark&#39;s game网站测试和公布了好多语言的一些场景的性能比较，比如下面这个是Rust和Go的几个实现版本的性能比较：</p>
<p><img src="binary-trees-rust-vs-go.png" alt=""></p>
<p>可以看到在这个二叉树的场景下Go的性能比Rust的也差很多。不过性能最好的Rust实现使用<code>arena</code>的内存分配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> bumpalo::Bump;</div><div class="line"><span class="keyword">use</span> rayon::prelude::*;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug, PartialEq, Clone, Copy)]</span></div><div class="line"><span class="keyword">struct</span> Tree&lt;'a&gt; {</div><div class="line">    left: Option&lt;&'a Tree&lt;'a&gt;&gt;,</div><div class="line">    right: Option&lt;&'a Tree&lt;'a&gt;&gt;,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">item_check</span></span>(tree: &Tree) -&gt; <span class="keyword">i32</span> {</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (Some(left), Some(right)) = (tree.left, tree.right) {</div><div class="line">        <span class="number">1</span> + item_check(right) + item_check(left)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="number">1</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bottom_up_tree</span></span>&lt;'r&gt;(arena: &'r Bump, depth: <span class="keyword">i32</span>) -&gt; &'r Tree&lt;'r&gt; {</div><div class="line">    <span class="keyword">let</span> tree = arena.alloc(Tree { left: None, right: None });</div><div class="line">    <span class="keyword">if</span> depth &gt; <span class="number">0</span> {</div><div class="line">        tree.right = Some(bottom_up_tree(arena, depth - <span class="number">1</span>));</div><div class="line">        tree.left = Some(bottom_up_tree(arena, depth - <span class="number">1</span>));</div><div class="line">    }</div><div class="line">    tree</div><div class="line">}</div><div class="line">...</div></pre></td></tr></table></figure>

<p>arena是一个内存池的技术，一般来说arena会创建一个大的连续内存块，该内存块只需要预先分配一次，在这块内存上的创建和释放都是手工执行的。</p>
<p>Go语言准备新加入 arena 的功能，并在标准库提供一个新的包: <code>arena</code>。当前这个<a href="https://github.com/golang/go/issues/51317" target="_blank" rel="external">提案</a>还是holding的状态，但是相关的代码已经陆陆续续地提到master分支了，所以说配批准也基本跑不了了，应该在Go 1.20，也就是明年春季的版本中尝试使用了。(当然也有开发者对Go的这种做法不满，因为外部开发者提出这种想法基本上被驳回或者不被关注，而Go团队的人有这想法就可以立马实现，甚至提案还没批准)。</p>
<p>包<code>arena</code>当前提供了几个方法:</p>
<ul>
<li>NewArena(): 创建一个Arena, 你可以创建多个Arena, 批量创建一批对象，统一手工释放。它不是线程安全的。</li>
<li>Free(): 释放Arena以及它上面创建出来的所有的对象。释放的对象你不应该再使用了，否则可能会导致意想不到的错误。</li>
<li>New<a href="a *Arena">T any</a> *T： 创建一个对象</li>
<li>MakeSlice<a href="a *Arena, len, cap int">T any</a> []T: 在Arena创建一个Slice。</li>
<li><p>Clone<a href="s T">T any</a>: 克隆一个Arena上对象，只能是指针、slice或者字符串。如果传入的对象不是在Arena分配的，直接原对象返回，否则脱离Arena创建新的对象。</p>
<p>当前还没有实现<code>MakeMap</code>、<code>MakeChan</code>这样在Arena上创建map和channel的方法，后续可能会加上。</p>
<p>arena的功能为一组Go对象创建一块内存，手工整体一次性的释放，可以避免垃圾回收。毕竟，我们也提到了，垃圾回收是Go程序的最大的性能杀手之一。</p>
</li>
</ul>
<p>官方建议在批量创建大量的Go对象的时候，每次能以Mib分配内存的场景下使用更有效，甚至他们找到了一个场景： protobuf的反序列化。</p>
<p>因为涉及到垃圾回收、内存分配的问题，所以这个功能实现起来也并不简单，涉及到对运行时代码的改造。不考虑垃圾回收对arena的处理， arena主要的实现在在运行时的<a href="https://github.com/golang/go/blob/26b48442569102226baba1d9b4a83aaee3d06611/src/runtime/arena.go" target="_blank" rel="external">arena.go</a>中。因为这个功能还在开发之中，或许这个文件还会有变更。</p>
<p>接下来，我们使用debian benchmark&#39;s game的二叉树的例子，对使用arena和不使用arena的情况下做一个比较:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"arena"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strconv"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// gotip run -tags "goexperiment.arenas" main.go -arena 21</span></div><div class="line"><span class="comment">// GOEXPERIMENT=arenas gotip run main.go -arena 21</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> n =<span class="number"> 0</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> {</div><div class="line">	left, right *Node</div><div class="line">	value       []<span class="typename">byte</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> bottomUpTree(depth <span class="typename">int</span>) *Node {</div><div class="line">	<span class="keyword">if</span> depth &lt;=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> &Node{}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> &Node{bottomUpTree(depth -<span class="number"> 1</span>), bottomUpTree(depth -<span class="number"> 1</span>), <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 128</span>,<span class="number"> 128</span>)}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> bottomUpTreeWithArena(depth <span class="typename">int</span>, a *arena.Arena) *Node {</div><div class="line">	node := arena.New[Node](a)</div><div class="line">	node.value = arena.MakeSlice[<span class="typename">byte</span>](a,<span class="number"> 128</span>,<span class="number"> 128</span>)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> depth &lt;=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> node</div><div class="line">	}</div><div class="line"></div><div class="line">	node.left = bottomUpTreeWithArena(depth<span class="number">-1</span>, a)</div><div class="line">	node.right = bottomUpTreeWithArena(depth<span class="number">-1</span>, a)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> node</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (n *Node) itemCheck() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">if</span> n.left == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 1</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span><span class="number"> 1</span> + n.left.itemCheck() + n.right.itemCheck()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> minDepth =<span class="number"> 4</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> useArena = flag.Bool(<span class="string">"arena"</span>, <span class="constant">false</span>, <span class="string">"use arena"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line">	<span class="keyword">if</span> flag.NArg() &gt;<span class="number"> 0</span> {</div><div class="line">		n, _ = strconv.Atoi(flag.Arg<span class="number">(0</span>))</div><div class="line">	}</div><div class="line"></div><div class="line">	appStart := time.Now()</div><div class="line">	<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Printf(<span class="string">"benchmark took: %v\n"</span>, time.Since(appStart))</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *useArena {</div><div class="line">		maxDepth := n</div><div class="line">		<span class="keyword">if</span> minDepth<span class="number">+2</span> &gt; n {</div><div class="line">			maxDepth = minDepth +<span class="number"> 2</span></div><div class="line">		}</div><div class="line">		stretchDepth := maxDepth +<span class="number"> 1</span></div><div class="line"></div><div class="line">		a := arena.NewArena()</div><div class="line">		start := time.Now()</div><div class="line">		check := bottomUpTreeWithArena(stretchDepth, a).itemCheck()</div><div class="line">		a.Free()</div><div class="line">		fmt.Printf(<span class="string">"stretch tree of depth %d\t check: %d, took: %v\n"</span>, stretchDepth, check, time.Since(start))</div><div class="line"></div><div class="line">		a = arena.NewArena()</div><div class="line">		longLiveStart := time.Now()</div><div class="line">		longLivedTree := bottomUpTreeWithArena(maxDepth, a)</div><div class="line">		<span class="keyword">defer</span> a.Free()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> depth := minDepth; depth &lt;= maxDepth; depth +=<span class="number"> 2</span> {</div><div class="line">			iterations :=<span class="number"> 1</span> &lt;&lt; <span class="typename">uint</span>(maxDepth-depth+minDepth)</div><div class="line">			check =<span class="number"> 0</span></div><div class="line"></div><div class="line">			start := time.Now()</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 1</span>; i &lt;= iterations; i++ {</div><div class="line">				a := arena.NewArena()</div><div class="line">				check += bottomUpTreeWithArena(depth, a).itemCheck()</div><div class="line">				a.Free()</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"%d\t trees of depth %d\t check: %d, took: %v\n"</span>, iterations, depth, check, time.Since(start))</div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"long lived tree of depth %d\t check: %d, took: %v\n"</span>, maxDepth, longLivedTree.itemCheck(), time.Since(longLiveStart))</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		maxDepth := n</div><div class="line">		<span class="keyword">if</span> minDepth<span class="number">+2</span> &gt; n {</div><div class="line">			maxDepth = minDepth +<span class="number"> 2</span></div><div class="line">		}</div><div class="line">		stretchDepth := maxDepth +<span class="number"> 1</span></div><div class="line"></div><div class="line">		start := time.Now()</div><div class="line">		check := bottomUpTree(stretchDepth).itemCheck()</div><div class="line">		fmt.Printf(<span class="string">"stretch tree of depth %d\t check: %d, took: %v\n"</span>, stretchDepth, check, time.Since(start))</div><div class="line"></div><div class="line">		longLiveStart := time.Now()</div><div class="line">		longLivedTree := bottomUpTree(maxDepth)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> depth := minDepth; depth &lt;= maxDepth; depth +=<span class="number"> 2</span> {</div><div class="line">			iterations :=<span class="number"> 1</span> &lt;&lt; <span class="typename">uint</span>(maxDepth-depth+minDepth)</div><div class="line">			check =<span class="number"> 0</span></div><div class="line"></div><div class="line">			start := time.Now()</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 1</span>; i &lt;= iterations; i++ {</div><div class="line">				check += bottomUpTree(depth).itemCheck()</div><div class="line">			}</div><div class="line">			fmt.Printf(<span class="string">"%d\t trees of depth %d\t check: %d, took: %v\n"</span>, iterations, depth, check, time.Since(start))</div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"long lived tree of depth %d\t check: %d, took: %v\n"</span>, maxDepth, longLivedTree.itemCheck(), time.Since(longLiveStart))</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段程序中我们使用<code>-arena</code>参数控制要不要使用<code>arena</code>。首先你必须安装或者更新<code>gotip</code>到最新版(如果你已经安装了gotip, 执行<code>gotip downloamd</code>,如果还未安装，请先<code>go install golang.org/dl/gotip@latest</code>)。</p>
<ul>
<li>启用<code>-arena</code>: 运行<code>GOEXPERIMENT=arenas gotip run -arena main.go 21</code></li>
<li>不启用<code>-arena</code>: 运行<code>GOEXPERIMENT=arenas gotip run -arena=false main.go 21</code></li>
</ul>
<p>不过这个特性还在开发之中，功能还不完善。</p>
<p>我在MacOS上测试，使用<code>arena</code>性能会有明显的提升，而在windows下测试，性能反而下降了。</p>
<p><img src="arena-windows.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go语言是一个极容易上手的语言，而且Go程序的优化套路基本上被大家莫得清清楚楚的，如果你有心，可以在互联网上搜出很多Go程序优化的技巧，有些文章可能只介绍了几个优化点，有些文章从CPU的架构到Slice预分配，再到通过pprof找性能的瓶颈点等等全面介绍Go程序的优化，所以说可见的手段基本上被大家摸得门清，最近老貘出了一道题，如下所示，可以看到大家对Go语言的优化已经摸的多深了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust 并发编程实战课]]></title>
    <link href="https://colobu.com/2022/10/13/concurrency-programming-via-rust/"/>
    <id>https://colobu.com/2022/10/13/concurrency-programming-via-rust/</id>
    <published>2022-10-12T23:48:21.000Z</published>
    <updated>2022-12-21T09:15:07.826Z</updated>
    <content type="html"><![CDATA[<p>Rust 越来越得到广泛的应用，尤其对于追求性能的系统编程领域，最近还正式进入了Linux 内核的主干，并预计在 6.1 版本中正式使用。</p>
<p>Rust 虽然设计理念独树一帜，性能也是那么的优秀，但是学习起来并不简单，学习曲线很陡。同时由于Rust不像Go语言一样，不受某一家公司的控制，看起来在开源方面貌似很“Open”,所以也得到了广大开发者的青睐，贡献了许多库，不乏高质量的库，甚至比标准库的质量和使用率还高，这也带来了一些问题。其他语言，比如Go语言，它的标准库相当的优秀，比如一堆优秀高质量的并发原语，在开发者在开发并发程序的时候，需要同步控制和任务编排时，脑海中第一选择就是标准库的并发原语，实在找不到合适的并发原语才去找第三方的库。但是Rust不一样，虽然标准库也提供了一些优秀的并发原语，但是限于语言的特性，使用起来相当的复杂，也有很多第三方的库提供性能更好或者特性更多或者更易使用的功能，所以在使用Rust开发并发程序的时候，很多开发者对并发逻辑的控制无从下手，或者有“选择困难症”，所以我专门开了一个序列，准备系统的介绍 Rust的并发编程的知识，通过一百多个简短而明确的例子，全面介绍Rust的并发编程和相关库的使用：<a href="https://github.com/smallnest/concurrency-programming-via-rust" target="_blank" rel="external">rust programming via rust </a>.</p>
<a id="more"></a>
<p><img src="gear.png" alt=""></p>
<p>两年前，在我刚离开微博的时候，非常高兴接受郭蕾的邀请，抽时间把自己先前做的Go并发编程实战的整理成<a href="https://time.geekbang.org/column/intro/100061801" target="_blank" rel="external">Go 并发编程实战课</a>,在极客时间专门开了一个专栏，系统的介绍了 Go 语言的并发编程，尤其是各种并发原语，从使用方法、实现细节，历史实现方式、每种并发原语使用的坑等方面详细做了介绍。</p>
<p>这一次，趁国庆假期的时间，除了和业界的大佬一起翻译《100 go mistakes and how to avoid them》这本书外，我专门系统的整理了Rust的并发编程的相关的资料，准备新开一个系列，通过公众号 ( 微信搜 <strong>专家极客圈</strong>)连载的方式，系统的介绍 Rust的编程知识。</p>
<p>这次的写作风格，和 Go并发编程实战课的风格有所不同。第一这一次内容非常的多，相关的并发原语非常的丰富，第二这次基本不会讲并发原语实现的细节，而是重要介绍它们的功能和使用场景，或许将会开一个专门的高级课程去讲实现和陷阱，但是这一次，主要是从入门入手，让大家了解和熟悉这些并发原语，在工作中用起来。</p>
<p>基本上我会每周一章的方式，把精彩的内容呈现给大家。</p>
<p>当前写作都是在业务时间完成的，我尽量按照这个节奏，在周末的时候完成每周的计划，或许有延迟，但是尽量按照这个节奏去走。</p>
<p>最重要的一点，要把大纲整理出来，大纲一旦整理出来，工作就完成了三分之一。</p>
<p>如果把相关的代码都实现了，那么任务就又完成了三分之一。</p>
<p>很高兴的是大纲已经完成，示例代码也基本完成了，所以如果你不想看我啰嗦的文字的话，也可以直接看github上的<a href="https://github.com/smallnest/concurrency-programming-via-rust" target="_blank" rel="external">示例代码</a>。</p>
<p>昨天我把源代码的仓库发布到 <a href="https://www.reddit.com/r/rust/comments/y1toqc/more_than_100_examples_to_learn_concurrency/" target="_blank" rel="external">reddit</a> 上后，世界各地的 Rust 开发者(rustaceans) 反响非常的强烈，纷纷点赞和关注，一夜之间仓库增加了一百多个star。我在考虑在写中文教程的时候，是不是同时也写英文的教程，以飨国外的读者。</p>
<p>整体上，我会从一下几个方面去介绍 Rust的并发编程的知识：</p>
<ul>
<li>chapter 1: Thread： 介绍标准库和第三方库线程的使用</li>
<li>chapter 2: Thread Pool: 介绍线程池</li>
<li>chapter 3: async/await: 介绍最新的异步编程</li>
<li>chapter 4: synchronization primitives: 介绍同步容器和同步原语</li>
<li>chapter 5: concurrency collections: 介绍如何实现基于标准库的线程安全的集合</li>
<li>chapter 6: process: 进程</li>
<li>chapter 7: channel: 通道，标准库和第三方库的</li>
<li>chapter 8: timer/ticker: 必须掌握的，定时器</li>
<li>chapter 9: parking_lot： 优秀的库</li>
<li>chapter 10: crossbeam: 优秀的库</li>
<li>chapter 11: rayon: 优秀的库</li>
<li>chapter 12: tokio: 优秀的库</li>
<li>chapter n: special: 巨量的为专门的目的实现的同步库</li>
</ul>
<p>当然在写作的时候还会做补充和调整，但是基本脉络就是这样的。 如果你对Rust的并发编程感兴趣，不要忘记star这个仓库 <a href="https://github.com/smallnest/concurrency-programming-via-rust" target="_blank" rel="external">https://github.com/smallnest/concurrency-programming-via-rust</a> 和公众号 (<strong>专家极客圈</strong>)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Rust 越来越得到广泛的应用，尤其对于追求性能的系统编程领域，最近还正式进入了Linux 内核的主干，并预计在 6.1 版本中正式使用。</p>
<p>Rust 虽然设计理念独树一帜，性能也是那么的优秀，但是学习起来并不简单，学习曲线很陡。同时由于Rust不像Go语言一样，不受某一家公司的控制，看起来在开源方面貌似很“Open”,所以也得到了广大开发者的青睐，贡献了许多库，不乏高质量的库，甚至比标准库的质量和使用率还高，这也带来了一些问题。其他语言，比如Go语言，它的标准库相当的优秀，比如一堆优秀高质量的并发原语，在开发者在开发并发程序的时候，需要同步控制和任务编排时，脑海中第一选择就是标准库的并发原语，实在找不到合适的并发原语才去找第三方的库。但是Rust不一样，虽然标准库也提供了一些优秀的并发原语，但是限于语言的特性，使用起来相当的复杂，也有很多第三方的库提供性能更好或者特性更多或者更易使用的功能，所以在使用Rust开发并发程序的时候，很多开发者对并发逻辑的控制无从下手，或者有“选择困难症”，所以我专门开了一个序列，准备系统的介绍 Rust的并发编程的知识，通过一百多个简短而明确的例子，全面介绍Rust的并发编程和相关库的使用：<a href="https://github.com/smallnest/concurrency-programming-via-rust" target="_blank" rel="external">rust programming via rust </a>.</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[十多年了，这个最容易犯错的Go语法终于要改了]]></title>
    <link href="https://colobu.com/2022/10/04/redefining-for-loop-variable-semantics/"/>
    <id>https://colobu.com/2022/10/04/redefining-for-loop-variable-semantics/</id>
    <published>2022-10-04T02:12:35.000Z</published>
    <updated>2022-12-21T09:15:07.883Z</updated>
    <content type="html"><![CDATA[<p>Go 语言中你最容易犯错的语法是什么？很多人可能都有不同的答案，但是最多的答案之一就是 for 循环中变量的使用问题了。即使是 Go 团队的开发者，我也曾看到他们提交的代码犯过这种错误，更不用说其他的 Go 开发者了,比如<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1619047" target="_blank" rel="external">this problem at Let’s Encrypt</a>,几乎每个Go开发者都犯过这个错误，这种类型的错误已经在我的心里留下了阴影，每次写for循环我都心头一紧，经常使用局部变量shade一下循环变量，即使没有问题。</p>
<a id="more"></a>
<p>Russ Cox 检查了1.4万个go module，大约1.2万个github仓库，搜寻使用 <code>x := x</code>这种技巧来解决循环变量的问题，发现大约有600个提交都是解决这个问题的，仔细观察后，大约一半的提交是没有必要的,可能是在不准确的静态工具分析下或者对语义的混淆又或者像我一朝被蛇咬十年怕井绳的谨慎心态下做得修改。比如下面两个项目中的修改，一个是有必要的，一个没有必要：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> 	<span class="keyword">for</span> _, informer := <span class="keyword">range</span> c.informerMap {</div><div class="line">+		informer := informer</div><div class="line"> 		<span class="keyword">go</span> informer.Run(stopCh)</div><div class="line"> 	}</div></pre></td></tr></table></figure>

<p>另一个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> 	<span class="keyword">for</span> _, a := <span class="keyword">range</span> alarms {</div><div class="line">+		a := a</div><div class="line"> 		<span class="keyword">go</span> a.Monitor(b)</div><div class="line"> 	}</div></pre></td></tr></table></figure>

<p>其中一个循环变量是接口，所以是没必要的。另一个是struct类型，并且方法的Receiver是指针类型，所以需要修改以便每次循环都是不同的指针。</p>
<p>所以说你看几乎相同的代码，有的是bug有的不是bug,讨不讨厌？</p>
<p>循环变量问题一直是一个问题，而且还不容易发现，它存在多种类型，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> all []*Item</div><div class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> items {</div><div class="line">	all = <span class="built_in">append</span>(all, &item)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prints []<span class="keyword">func</span>()</div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>} {</div><div class="line">	prints = <span class="built_in">append</span>(prints, <span class="keyword">func</span>() { fmt.Println(v) })</div><div class="line">}</div><div class="line"><span class="keyword">for</span> _, <span class="built_in">print</span> := <span class="keyword">range</span> prints {</div><div class="line">	<span class="built_in">print</span>()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者像最上面的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> alarms {</div><div class="line">	<span class="keyword">go</span> a.Monitor(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> alarms {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">          fmt.Println(a)</div><div class="line">      }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, scheme := <span class="keyword">range</span> artifact.Schemes {</div><div class="line">	Runtime.artifactByScheme[scheme.ID] = id</div><div class="line">	Runtime.schemesByID[scheme.ID] = scheme</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; n; i++ {</div><div class="line">  use(&i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>防不胜防。最重要的原因是当前的魂环变量<code>i</code>、<code>v</code>、<code>item</code>等都是 <code>per-loop</code>的，而不是<code>per-iteration</code>。也就是说这些循环变量在此循环中是唯一的，而不是每迭代唯一。<br>解决这个问题最好的技巧就是使用局部变量(<code>x := x</code>)破解,比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> alarms {</div><div class="line">      a := a</div><div class="line">	<span class="keyword">go</span> a.Monitor(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>大家深受其苦，所以也有一些提案希望能改进这个语法。比如<a href="https://github.com/golang/go/issues/20733" target="_blank" rel="external">#20733</a>、<a href="https://github.com/golang/go/issues/24282" target="_blank" rel="external">#24282</a>、<a href="https://github.com/golang/go/issues/21130" target="_blank" rel="external">#21130</a>。</p>
<p>虽然多少年Go团队对这个问题置之不理，但是今天，就在今天， Russ Cox终于出手了， 他建了一个讨论主题: <a href="https://github.com/golang/go/discussions/56010" target="_blank" rel="external">#56010</a>。</p>
<p>因为改动这个语法，将循环变量的语义从<code>per-loop</code>改成<code>per-iteration</code>，破坏了向下兼容的许诺，所以这个改动还比较谨慎，目前还在讨论阶段，但是很显然，这是广大Gopher期望修改的一个特性。</p>
<p>并且Russ Cox也想到了解决方案，如果这个feature在某个版本中增加，比如 <code>1.30</code>,那么go module中定义的版本如果小于这个版本的库的话，则使用老的<code>per-loop</code>编译，大于等于这个版本使用<code>per-iteration</code>。</p>
<p>你可以关注这个讨论，或者点个赞，期望这个特性早点加入到主干中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 语言中你最容易犯错的语法是什么？很多人可能都有不同的答案，但是最多的答案之一就是 for 循环中变量的使用问题了。即使是 Go 团队的开发者，我也曾看到他们提交的代码犯过这种错误，更不用说其他的 Go 开发者了,比如<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1619047" target="_blank" rel="external">this problem at Let’s Encrypt</a>,几乎每个Go开发者都犯过这个错误，这种类型的错误已经在我的心里留下了阴影，每次写for循环我都心头一紧，经常使用局部变量shade一下循环变量，即使没有问题。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go CPU profiler 内幕]]></title>
    <link href="https://colobu.com/2022/09/29/Inside-the-Go-CPU-profiler/"/>
    <id>https://colobu.com/2022/09/29/Inside-the-Go-CPU-profiler/</id>
    <published>2022-09-29T12:06:41.000Z</published>
    <updated>2022-12-21T09:15:07.818Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://sumercip.com/posts/inside-the-go-cpu-profiler/" target="_blank" rel="external">Inside the Go CPU profiler</a>,作者 Sümer Cip。我猜测 Felix Geisendörfer 肯定会进行评论，果不其然。</p>
<p>Go 是那种自带 profiler (分析器)的语言之一。它的运行时包含强大的自成一派的各种 profiler。其它语言，比如 Ruby、Python 和 Node.js, 它们也包含 profiler或者一些用来编写profiler的API，但是与Go的开箱即用的 profiler相比，它们提供的profiler功能有限。如果你想多了解Go提供的这些可观察工具的情况，我强烈推荐你阅读 Felix Geisendörfer的 <a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md" target="_blank" rel="external">The Busy Developer’s Guide to Go Profiling, Tracing and Observability</a>。</p>
<p>作为一个好奇的工程师，我喜欢挖掘事物在底层上的工作方式，我一直想去学习Go CPU profiler底层·是怎么工作的。这篇文章就是此次探索的结果。每当我阅读Go运行时代码时，我总是学到到一些新东西，这次也不例外。</p>
<a id="more"></a>
<h2 id="基本知识">基本知识</h2>
<p>当前市面上存在两种类型的profiler:</p>
<ul>
<li><strong>tracing</strong>(跟踪): 当预定义的事件发生时进行测量。例如，函数被调用，函数退出等等。</li>
<li><strong>Sampling</strong>(采样): 定期进行测量。</li>
</ul>
<p>Go CPU profiler 是一个采样分析器。当然Go还有一个执行跟踪器（execution tracer），它是 tracing profiler, 跟踪某些事件，例如请求锁，GC相关事件等等。</p>
<p>sampling profiler 通常由两个基本部分组成：</p>
<ul>
<li>采样器(sampler)：定期调用回调，并且通常分析数据收集堆栈跟踪(stack trace)。不同的profiler使用不同的策略来触发回调。</li>
<li>数据收集：这是profiler收集其数据的地方：它可能会消耗内存或调用计数，基本上是与堆栈跟踪关联的一些指标。</li>
</ul>
<h2 id="关于其它profiler如何工作的小调查">关于其它profiler如何工作的小调查</h2>
<p>Linux <strong>perf</strong> 使用 PMU(Performance Monitor Unit)计数器进行采样。你可以指示PMU 在某些事件发生 N 次后生成中断，例如，每 1000 个 CPU 时钟周期执行一次。<br>丹尼斯·巴赫瓦洛夫（Denis Bakhvalov）撰写的一篇<a href="https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics" target="_blank" rel="external">详细文章</a>解释了如何像 perf 和 VTune 工具使用PMU计数器来实现这一目标。一旦定期触发数据收集回调函数，剩下的工作就是收集堆栈跟踪并正确聚合它们。为了完整起见，Linux <strong>perf</strong> 使用 perf_event_open(PERF_SAMPLE_STACK_USER,...) 收集堆栈信息。捕获的堆栈跟踪通过 mmap 环形缓冲区写入用户空间。</p>
<p><a href="https://github.com/benfred/py-spy" target="_blank" rel="external">pyspy</a>和<a href="https://github.com/rbspy/rbspy" target="_blank" rel="external">rbspy</a>是著名的Python和Ruby的sampling profiler。它们都作为外部进程运行，并定期读取目标应用程序内存以捕获正在运行的线程的堆栈跟踪。在Linux中，他们使用process_vm_readv方法收集数据，如果我没有记错的话，这个API在内存读取期间会将目标应用程序暂停几毫秒。然后，它们在读取的内存中跟踪指针，以查找当前正在运行的线程结构和堆栈跟踪信息。正如人们可能猜到的那样，这是一种容易出错且复杂的方法，但效果非常好。如果我没记错的话，<a href="https://github.com/uber-archive/pyflame" target="_blank" rel="external">pyflame</a>也使用类似的方法。</p>
<p>最近的profiler，如<a href="https://sumercip.com/posts/inside-the-go-cpu-profiler/parca.dev" target="_blank" rel="external">Parca</a>（还有其它几个）使用 <a href="https://ebpf.io/" target="_blank" rel="external">eBPF</a>。eBPF 是一项最新的技术，允许在内核 VM 中运行用户空间代码。这是一项出色的技术，用于安全、网络和可观察性等许多领域。我强烈建议阅读有关eBPF的一些信息，这是一个非常大的话题，远远超出了这篇文章的范围。</p>
<h2 id="如何定期触发探查器？">如何定期触发探查器？</h2>
<p>Go CPU profiler 是一个采样分析器。在 Linux 中，Go 运行时使用 <strong>setitimer/timer_create/timer_settime</strong> 来设置 <strong>SIGPROF</strong> 信号处理器。此处理器按<strong>runtime.SetCPUProfileRate</strong>设置的周期间隔触发，默认情况下是100Mz(10毫秒)。顺便说一句，在Go 1.18之前，Go CPU profiler的采样器存在一些严重的问题，你可以在<a href="https://www.datadoghq.com/blog/engineering/profiling-improvements-in-go-1-18/" target="_blank" rel="external">这里</a>看到这些问题的细节。我们记错的话，<strong>settimer</strong> API 是Linux中每个线程触发基于时间的信号的推荐方法: 从技术上讲，它的工作原理就像你期望的进程信号处理机制一样。但它并不是多核分析的良好机制。</p>
<p>让我们看看如何手动启用 Go CPU profiler：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">f, err := os.Create(<span class="string">"profile.pb.gz"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    ...</div><div class="line">}</div><div class="line"><span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="constant">nil</span> {</div><div class="line">    ...</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</div></pre></td></tr></table></figure>

<p>一旦<strong>pprof.StartCPUProfile</strong>被调用，Go运行时就可以按照指定的时间间隔产生<strong>SIGPROF</strong>信号。Linux内核向应用程序中正在运行的线程之一发送<strong>SIGPROF</strong>信号。由于 Go 使用非阻塞 I/O，等待I/O的goroutine不会被统计为running的goroutine，Go CPU profiler 不会捕获这类goroutine的数据。顺便说一句：这是实现<a href="https://github.com/felixge/fgprof" target="_blank" rel="external">fgprof</a>的基本原因。 fgprof使用<strong>runtime.GoroutineProfile</strong>获取 on-CPU 和 off-CPU的数据。</p>
<p>A picture is worth a thousand words; below is how Go runtime handles SIGPROF signal:</p>
<p>一图胜千言。以下是 Go 运行时处理SIGPROF信号的方式：</p>
<p><img src="sigprof.png" alt=""></p>
<h2 id="profiler_如何收集数据？">profiler 如何收集数据？</h2>
<p>一个一个随机的运行的goroutine收到<strong>SIGPROF</strong>信号，它会被中断并执行信号处理程序。中断的 goroutine 的堆栈跟踪在此信号处理程序的上下文中获取到，然后与当前<a href="https://rakyll.org/profiler-labels/" target="_blank" rel="external">profiler标签</a>一起保存到<a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/" target="_blank" rel="external">lock-free</a>日志结构中（每个捕获的堆栈跟踪都可以与自定义标签相关联，您可以稍后对其进行过滤）。这个特殊的lock-free结构被命名为<strong>profBuf</strong>，它在 <a href="https://github.com/golang/go/blob/master/src/runtime/profbuf.go" target="_blank" rel="external">runtime/profbuf.go</a> 定义，并详细解释了它是如何工作的。它是一个单写单读(single-writer,single-reader)的lock-free的ringbuffer，类似于此处<a href="http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf" target="_blank" rel="external">介绍</a>的数据结构。Writer是信号处理器，而reader是 <strong>profileWriter</strong> goroutine，profileWriter goroutine定期的读取此缓冲区并将结果聚合到最终的hashmap。这个最终的hashmap被命名为<strong>profMap</strong>, 定义在<a href="https://github.com/golang/go/blob/master/src/runtime/pprof/map.go" target="_blank" rel="external">runtime/pprof/map.go</a>。</p>
<p>以下是把刚才介绍的组合在一起的一个可视化图：</p>
<p><img src="sigprof_handler.png" alt=""></p>
<p>可以看到，最终的结构与常规的<strong>pprof.Profile</strong>对象非常相似：它是一个hashmap,其中的键是堆栈跟踪+标签，值是在应用程序中观察到此调用堆栈的次数。当<strong>pprof.StopCPUProfile()</strong>被调用时，分析就会停止，profileWriter goroutine调用<a href="https://github.com/golang/go/blob/aa4299735b78189eeac1e2c4edafb9d014cc62d7/src/runtime/pprof/proto.go#L348" target="_blank" rel="external">build()</a>。这个函数负责写<strong>profMap</strong>结构到<strong>io.Writer</strong>，此Writer由pprof.StartCPUProfile初始调用的时候提供。基本上这就是最终的<a href="https://pkg.go.dev/runtime/pprof#Profile" target="_blank" rel="external">pprof.Profile</a>产生的过程。</p>
<p>profileWriter的伪代码可能对你理解这个过程更有帮助:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> profileWriter(w io.Writer) {</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        time.Sleep<span class="number">(100</span> * time.Millisecond)</div><div class="line"></div><div class="line">        data, tags := readProfile()</div><div class="line">        <span class="keyword">if</span> e := b.addCPUData(data, tags); e != <span class="constant">nil</span> {</div><div class="line">            ...</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> profilerStopped {</div><div class="line">            <span class="keyword">break</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    ...</div><div class="line">    b.build() <span class="comment">// -&gt; generates final pprof.Profile</span></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦我对设计有了高层次的了解，我就会问自己以下问题：<br><strong>为什么 Go 为了实现一个独特的lock-free结构而花费了那么大精力只为了保存临时分析数据？为什么不定期将所有内容写入hashmap？</strong></p>
<p>答案就在设计本身。</p>
<p>首先看的第一件事就是<strong>SIGPROF</strong>处理器就是禁用内存分派。此外，profiler代码不包含热门和锁，甚至堆栈的最大深度也是硬编码的。截止<strong>Go 1.19</strong>, 最大深度是<a href="https://github.com/golang/go/blob/54cf1b107d24e135990314b56b02264dba8620fc/src/runtime/cpuprof.go#L22" target="_blank" rel="external">64</a>。所有这些细节都可以为profiler提供更高效、更可预测的开销。低且可预测的性能是生产就绪型profiler的关键。</p>
<h2 id="开销">开销</h2>
<p>根据设计，profiler开销是恒定的？嗯，这要视情况而定。让我解释一下原因：在单个profiler中断中，会发生以下情况：</p>
<ul>
<li>一个随机运行的goroutine执行上下文切换来运行SIGPROF处理器，</li>
<li>执行堆栈遍历，并且 Go 运行时将堆栈跟踪保存到lock-free ring buffer中，</li>
<li>goroutine 恢复。</li>
</ul>
<p>从理论上讲，似乎上述所有内容都应该在恒定时间内运行，因为没有发生内存分配和锁竞争。我记得所有的这是真的：以上所有事情都发生在大约1微秒（在典型的CPU上）。但是，在实践中，情况变得更糟。如果您搜索“Go CPU profiler的开销”，您将看到从 <strong>%0.5</strong> 到 <strong>%1-%5</strong> 的数字（没有发现关于这个数字的公开提及，也没有适当的证据）。这背后的原因主要与CPU的工作方式有关。现代CPU是复杂的怪兽。它们会积极地使用缓存。典型的单 CPU 内核具有三层缓存：L1、L2 和 L3。当特定的 CPU 密集型代码正在运行时，这些缓存将得到充分利用。对于某些应用程序而言，高缓存利用率尤其如此，在这些应用程序中，小（可以放入缓存中的数据）和顺序数据被大量读取。</p>
<p>一个很好的例子是矩阵乘法：在矩阵乘法期间，CPU大量访问内存中顺序存储的独立单元格。这些缓存友好型应用程序可能会为采样profiler产生严重的开销。虽然很容易使用<strong>prof</strong>做一些基准测试来验证这一说法，但这超出了这篇文章的范围。</p>
<p>综上所述，Go 运行时在保持profiler开销尽可能可预测和尽可能低方面做得很好。如果你不相信我，你有所质疑，也许下面引用的一个<a href="https://groups.google.com/g/golang-nuts/c/e6lB8ENbIw8/m/azeTCGj7AgAJ" target="_blank" rel="external">讨论对话</a>可以说服你：</p>
<blockquote>
<p>在谷歌，我们持续分析Go生产服务，这样做是安全的。</p>
</blockquote>
<p>另一个来自datadog的持续profiler的<a href="https://github.com/DataDog/dd-trace-go/commit/54604a13335b9c5e4ac18a898e4d5971b6b6fc8c" target="_blank" rel="external">代码提交</a>也可以印证这一点：</p>
<blockquote>
<p>在许多高容量内部工作负荷上测试此默认值后(默认开启profiler)，我们已确定此默认值对生产是安全的。</p>
</blockquote>
<p>最后，基于上述理论，我们可以进行以下观察结果：</p>
<p><strong>在典型的 I/O 密集型应用程序上，profiler的开销将非常小。</strong></p>
<p>这是因为当有许多休眠/空闲的 goroutine 时，CPU 缓存丢弃没有太大区别。在 Go CPU profiler基准测试期间，我们一遍又一遍地观察到这一点：在典型的 I/O 密集型应用程序上，开销实际上为零（或统计上微不足道）。但是，同样，提供经验证据超出了这篇文章的范围，人们可以通过在profiler打开和关闭时，观察Go Web应用程序的负载测试期间的吞吐量来做到这一点。</p>
<h2 id="结论">结论</h2>
<p>我喜欢这种设计的一点是，它证明了你可以根据你对底层数据结构的访问模式的理解程度来优化代码。在这种情况下，Go 运行时使用lock-free结构，即使在大多数情况下这完全是矫枉过正。Go运行时充满了像这样的聪明优化，我强烈建议你花时间深入研究你觉得有趣的部分。</p>
<p>我希望你喜欢它！</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md" target="_blank" rel="external">https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md</a></li>
<li><a href="https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics" target="_blank" rel="external">https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics</a></li>
<li><a href="https://www.instana.com/blog/go-profiler-internals/" target="_blank" rel="external">https://www.instana.com/blog/go-profiler-internals/</a></li>
<li><a href="https://www.datadoghq.com/blog/engineering/profiling-improvements-in-go-1-18/" target="_blank" rel="external">https://www.datadoghq.com/blog/engineering/profiling-improvements-in-go-1-18/</a></li>
<li><a href="http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf" target="_blank" rel="external">http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf</a></li>
<li><a href="https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics" target="_blank" rel="external">https://easyperf.net/blog/2018/06/01/PMU-counters-and-profiling-basics</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://sumercip.com/posts/inside-the-go-cpu-profiler/" target="_blank" rel="external">Inside the Go CPU profiler</a>,作者 Sümer Cip。我猜测 Felix Geisendörfer 肯定会进行评论，果不其然。</p>
<p>Go 是那种自带 profiler (分析器)的语言之一。它的运行时包含强大的自成一派的各种 profiler。其它语言，比如 Ruby、Python 和 Node.js, 它们也包含 profiler或者一些用来编写profiler的API，但是与Go的开箱即用的 profiler相比，它们提供的profiler功能有限。如果你想多了解Go提供的这些可观察工具的情况，我强烈推荐你阅读 Felix Geisendörfer的 <a href="https://github.com/DataDog/go-profiler-notes/blob/main/guide/README.md" target="_blank" rel="external">The Busy Developer’s Guide to Go Profiling, Tracing and Observability</a>。</p>
<p>作为一个好奇的工程师，我喜欢挖掘事物在底层上的工作方式，我一直想去学习Go CPU profiler底层·是怎么工作的。这篇文章就是此次探索的结果。每当我阅读Go运行时代码时，我总是学到到一些新东西，这次也不例外。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多年老司机，面对这些Go并发问题，也迟疑了]]></title>
    <link href="https://colobu.com/2022/09/12/go-synchronization-is-hard/"/>
    <id>https://colobu.com/2022/09/12/go-synchronization-is-hard/</id>
    <published>2022-09-12T08:36:25.000Z</published>
    <updated>2022-12-21T09:15:07.883Z</updated>
    <content type="html"><![CDATA[<p>Go一向以它的简单易学而著称，我也遇到过同学说只需半天就能掌握Go语言了，两三年的Go开发经验就称专家了。</p>
<p>想比较Rust等编程语言，Go语言的确容易上手，查看Go语言的规范你也会看到，它的语言规范相比较其它编程语言非常的简短，的确可以一个小时就可以读完。但是如果你深入了解这门语言(其它语言也是类似情况)，就会发现很多细节的地方，需要花谢心思和时间仔细琢磨琢磨。这不，我先来几道Go并发的源代码考考你，看看你能回答上来不？</p>
<a id="more"></a>
<h2 id="几道Go并发的源代码问题">几道Go并发的源代码问题</h2>
<h3 id="在另一个goroutine看到的write顺序">在另一个goroutine看到的write顺序</h3>
<p>下面这段代码，是否可能输出<code>1, 0</code>?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(2</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> x, y <span class="typename">int</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		x =<span class="number"> 1</span></div><div class="line">		y =<span class="number"> 1</span></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		r1 := y</div><div class="line">		r2 := x</div><div class="line">		</div><div class="line">        fmt.Println(r1, r2)  <span class="comment">// ❶ r1 = 1, r2 = 0 可能吗?</span></div><div class="line">       </div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="两个goroutine交叉read/write">两个goroutine交叉read/write</h3>
<p>下面这段代码是否可能输出 r1= 0, r2 =0这样的结果？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(2</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> x, y <span class="typename">int</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		x =<span class="number"> 1</span></div><div class="line">		r1 := y</div><div class="line">		fmt.Println(r1) <span class="comment">// ❶</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		y =<span class="number"> 1</span></div><div class="line">		r2 := x</div><div class="line">		fmt.Println(r2) <span class="comment">// ❷</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="两个goroutine看到的write顺序">两个goroutine看到的write顺序</h3>
<p>下面这段代码, ❶和❷可能输出<code>1,0</code>和<code>0,1</code>这两种不同的结果吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> x, y <span class="typename">int</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		x =<span class="number"> 1</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		y =<span class="number"> 1</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		r1 := x</div><div class="line">		r2 := y</div><div class="line"></div><div class="line">		fmt.Println(r1, r2) <span class="comment">// ❶ 1,0</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		r3 := x</div><div class="line">		r4 := y</div><div class="line"></div><div class="line">		fmt.Println(r3, r4) <span class="comment">// ❷ 0,1</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="sync-Once">sync.Once</h3>
<p>下面是Go标准库中<code>sync.Once</code>的实现，虽然很简单的几行代码，你品一品，有没有什么疑问？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (o *Once) Do(f <span class="keyword">func</span>()) {</div><div class="line">	<span class="keyword">if</span> atomic.LoadUint32(&o.done) ==<span class="number"> 0</span> { <span class="comment">// ❶</span></div><div class="line">		o.doSlow(f)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Once) doSlow(f <span class="keyword">func</span>()) {</div><div class="line">	o.m.Lock() <span class="comment">// ❷</span></div><div class="line">	<span class="keyword">defer</span> o.m.Unlock() <span class="comment">// ❸</span></div><div class="line">	<span class="keyword">if</span> o.done ==<span class="number"> 0</span> { <span class="comment">// ❹</span></div><div class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&o.done,<span class="number"> 1</span>) <span class="comment">// ❺</span></div><div class="line">		f()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为什么❹处不使用atomic?那么❶和❺处不使用atomic行不行？</p>
<h3 id="sync-WaitGroup">sync.WaitGroup</h3>
<p>下面是一段<code>WaitGroup</code>的示例代码, ❶处需要使用atomic.Load吗？ 如果不使用，一定输出10吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> count <span class="typename">int64</span></div><div class="line">	</div><div class="line">    <span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			atomic.AddInt64(&count,<span class="number"> 1</span>)</div><div class="line">			wg.Done()</div><div class="line">		}()</div><div class="line">	}</div><div class="line">	</div><div class="line">    wg.Wait()</div><div class="line"></div><div class="line">	fmt.Println(count) <span class="comment">// ❶</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="TryLock">TryLock</h3>
<p>下面这段代码是Mutex的TryLock方法的实现。❶处为什么不使用atomic,会不会导致锁已经释放了但是TryLock获取不到锁？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	old := m.state <span class="comment">// ❶</span></div><div class="line">	<span class="keyword">if</span> old&(mutexLocked|mutexStarving) !=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !atomic.CompareAndSwapInt32(&m.state, old, old|mutexLocked) {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以先思考一下这几个问题，我们暂时不分析，接下来我们看看最新的Go内存模型，然后再分析这几个题目。</p>
<h2 id="Go_内存模型">Go 内存模型</h2>
<p>新版的(Go 1.19)内存模型对原有的内存模型文字做了大幅度的<a href="https://go-review.googlesource.com/c/go/+/381315/" target="_blank" rel="external">修改</a>:</p>
<ul>
<li><p>文档化 Go 对内存模型整体的实现方法<br>data race指对同一个内存位置有并发的write-write或者write-read，除非使用了atomic进行原子操作，否则可能就有数据竞争，所以你看啊, read-read并没有数据竞争。没有数据竞争的程序的行为就像所有的goroutine运行在单处理器上，这个属性有时候也叫 <code>DRF-SC</code> (data-race-free programs execute in a sequentially consistent manner)。</p>
</li>
<li><p>文档化 multiword race 可能会导致崩溃</p>
</li>
<li>文档化 <code>runtime.SetFinalizer</code>的 happens-before 规则</li>
<li>文档化(或者增加<a href="https://go-review.googlesource.com/c/go/+/381316/" target="_blank" rel="external">连接</a>) 针对更多同步原语的 happens-before 规则</li>
<li>文档化 <code>sync/atomic</code>的 happens-before 规则， 对应 C++ 的 顺序一致性 atomic (以及其它语言Java，JavaScript, Rust, Swift, C, ...)</li>
<li>文档化 禁止编译器优化</li>
</ul>
<p>内存操作可以分为三者：</p>
<ul>
<li>read-like: 比如 read、atomic read、mutex lock 和channel receive</li>
<li>write-like: 比如 write、atomic write、mutex unlock、channel send 和 channe close</li>
<li>read-like和write-like并存: 比如 atomic compare-and-swap</li>
</ul>
<p>内存模型有提出了两种关系: <code>sequenced before</code>和<code>synchronized before</code>。<br>在一个goroutine中执行的语句和表达式遵循<code>sequenced before</code>,按照Go语言规范中定义的控制流程和表达式的求值顺序执行。<br>如果一个同步执行的read-like的内存操作<strong>r</strong>观察到一个同步执行的write-like的内存操作<strong>w</strong>,那么w <code>synchronized before</code> r。<br>而<code>happens before</code>关系就被定义为一组<code>sequenced before</code>和<code>synchronized before</code>构成的具有传递性的组合。</p>
<p>我的理解，Go内存模型相当于把<code>happens before</code>关系细化了。</p>
<p>一个非同步的数据读取r, 读取内存地址x,如果写w对r可见，也就是r能观察到w话，需要保证:</p>
<ul>
<li>w happens before r</li>
<li>w does not happen before any other write w&#39; (to x) that happens before r (翻译过来还不如看英文哈)</li>
</ul>
<p>其实我不想讲太多的关于Go内存模型的理论了，毕竟是翻译官方的文档，而且我翻译几次发觉翻译的不好，不如直接看官方文档。另外个人觉得这个官方文档也写得不好，虽然前面有一些定义，但是一些术语或者论据并没有很好的解释或者严格的论证(一家之言)。比如当你说<code>some</code>的时候，你要严格定义some到底包含哪些场景。当你说特定的术语或者短语时，你要定义术语或或者增加引用。</p>
<p>不管怎样，重要的，或者说对于Gopher来说容易理解的是，它对各种同步场景给了严格的保证(定义)，比如<code>init</code>、goroutine的创建和执行、channel、Mutex、RWMutex、Once以及新增加<code>SetFinalizer</code>,但是最最重要的是，终于提供了atomic的同步定义。</p>
<h3 id="atomic的保证">atomic的保证</h3>
<p><code>sync/atomic</code>包提供了一组原子操作。如果原子操作<code>A</code>能被原子操作<code>B</code>观察到，那么我们就说 A synchronized before B。<br>所有的程序中的原子操作的执行就像按照顺序一致性顺序执行一样。</p>
<p>和C++中的sequentially consistent atomic， 以及Java的volatile变量一样。</p>
<p>因为不同的CPU指令不同，所以具体的atomic的实现也是针对不同架构各有不同。我们以AMD64架构为例。</p>
<p>对于读操作，比如atomic.Load其实没有做任何处理，因为是single word读取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Load(ptr *<span class="typename">uint32</span>) <span class="typename">uint32</span> {</div><div class="line">	<span class="keyword">return</span> *ptr</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Loadp(ptr unsafe.Pointer) unsafe.Pointer {</div><div class="line">	<span class="keyword">return</span> *(*unsafe.Pointer)(ptr)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Load64(ptr *<span class="typename">uint64</span>) <span class="typename">uint64</span> {</div><div class="line">	<span class="keyword">return</span> *ptr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于写(读写)操作，使用<code>LOCK</code>前缀:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TEXT ·Cas64(SB), NOSPLIT, <span class="number">$0</span><span class="number">-25</span></div><div class="line">	MOVQ	ptr<span class="number">+0</span>(FP), BX</div><div class="line">	MOVQ	old<span class="number">+8</span>(FP), AX</div><div class="line">	MOVQ	<span class="built_in">new</span><span class="number">+16</span>(FP), CX</div><div class="line">	LOCK</div><div class="line">	CMPXCHGQ	CX,<span class="number"> 0</span>(BX)</div><div class="line">	SETEQ	ret<span class="number">+24</span>(FP)</div><div class="line">	RET</div></pre></td></tr></table></figure>

<p>LOCK前缀可以确保共享内存可以排他使用，并且对数据的修改会通过MESI对其它处理器可见。LOCK在老的Intel CPU中可能采用锁总线的方式，但是在现代的CPU中，通过锁cache line方式。一个更清楚的解释可以看这篇文章<a href="https://hackmd.io/@vesuppi/Syvoiw1f8" target="_blank" rel="external">x86 LOCK prefix</a>。</p>
<p>Store就使用了<code>XCHG</code>指令，不需要LOCK前缀，本身它就具有LOCK的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TEXT ·Store64(SB), NOSPLIT, <span class="number">$0</span><span class="number">-16</span></div><div class="line">	MOVQ	ptr<span class="number">+0</span>(FP), BX</div><div class="line">	MOVQ	val<span class="number">+8</span>(FP), AX</div><div class="line">	XCHGQ	AX,<span class="number"> 0</span>(BX)</div><div class="line">	RET</div></pre></td></tr></table></figure>

<p>虽然我们看的是AMD64架构的atomic实现，但是我们不妨看一个x86架构的Load64，这是一个很有意思的知识点。<br>x86是32位的架构，word是32位，读取int64的值的时候就是multiword的场景，不使用atomic,就可能读到部分修改的值，所以32位的情况下，原子读取int64的值需要特殊处理一下，不想AMD64架构下直接读取:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">TEXT ·Load64(SB), NOSPLIT, <span class="number">$0</span><span class="number">-12</span></div><div class="line">	NO_LOCAL_POINTERS</div><div class="line">	MOVL	ptr<span class="number">+0</span>(FP), AX</div><div class="line">	TESTL	<span class="number">$7</span>, AX</div><div class="line">	JZ<span class="number">	2</span>(PC)</div><div class="line">	CALL	·panicUnaligned(SB)</div><div class="line">	MOVQ	(AX), M0</div><div class="line">	MOVQ	M0, ret<span class="number">+4</span>(FP)</div><div class="line">	EMMS</div><div class="line">	RET</div></pre></td></tr></table></figure>

<p>首先它会检查是否是8byte对齐，要是不对齐就会panic。然后呢，使用MMX0寄存器(64bit)巧妙的实现原子读取。</p>
<h3 id="WaitGroup、Cond、sync-Pool、sync-Map">WaitGroup、Cond、sync.Pool、sync.Map</h3>
<p>最新的Go内存模型还在注释(go doc)对各种并发原语的内存模型进行了定义，虽然我觉得在Go内存模型文档中记录更合理一些。</p>
<p>比如WaitGroup:</p>
<blockquote>
<p>In the terminology of the Go memory model, a call to Done “synchronizes before” the return of any Wait call that it unblocks.</p>
</blockquote>
<p>比如 Cond:</p>
<blockquote>
<p>In the terminology of the Go memory model, Cond arranges that a call to Broadcast or Signal “synchronizes before” any Wait call that it unblocks.</p>
</blockquote>
<p>比如Pool:</p>
<blockquote>
<p>In the terminology of the Go memory model, a call to Put(x) “synchronizes before” a call to Get returning that same value x. Similarly, a call to New returning x “synchronizes before” a call to Get returning that same value x.</p>
</blockquote>
<p>比如sync.Map:</p>
<blockquote>
<p>In the terminology of the Go memory model, Map arranges that a write operation “synchronizes before” any read operation that observes the effect of the write.</p>
</blockquote>
<p>比如RWMutex:</p>
<blockquote>
<p>In the terminology of the Go memory model, the n&#39;th call to Unlock “synchronizes before” the m&#39;th call to Lock for any n &lt; m, just as for Mutex. For any call to RLock, there exists an n such that the n&#39;th call to Unlock “synchronizes before” that call to RLock, and the corresponding call to RUnlock “synchronizes before” the n+1&#39;th call to Lock.</p>
</blockquote>
<p>比如Mutex:</p>
<blockquote>
<p>In the terminology of the Go memory model, the n&#39;th call to Unlock “synchronizes before” the m&#39;th call to Lock for any n &lt; m. A successful call to TryLock is equivalent to a call to Lock. A failed call to TryLock does not establish any “synchronizes before” relation at all.</p>
</blockquote>
<p>比如Once:</p>
<blockquote>
<p>In the terminology of the Go memory model, the n&#39;th call to Unlock “synchronizes before” the m&#39;th call to Lock for any n &lt; m. A successful call to TryLock is equivalent to a call to Lock. A failed call to TryLock does not establish any “synchronizes before” relation at all.</p>
</blockquote>
<p>比如runtime.SetFinalizer:</p>
<blockquote>
<p>In the terminology of the Go memory model, a call SetFinalizer(x, f) “synchronizes before” the finalization call f(x). However, there is no guarantee that KeepAlive(x) or any other use of x “synchronizes before” f(x).</p>
</blockquote>
<p>为什么要了解这些保证，或者说为什么要了解Go内存模型呢？就是为了能编写data-race-free、没有并发问题的程序。</p>
<p>比如下面一段并发代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="typename">string</span></div><div class="line"><span class="keyword">var</span> done <span class="typename">bool</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> setup() {</div><div class="line">	a = <span class="string">"hello, world"</span></div><div class="line">	done = <span class="constant">true</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">go</span> setup()</div><div class="line">	<span class="keyword">for</span> !done { <span class="comment">// 空转，等待done=true</span></div><div class="line">	}</div><div class="line">	<span class="built_in">print</span>(a)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>done</code>的读写并没有使用atomic进行同步控制，所以在main goroutine中没有保证&quot;a的赋值&quot; happens before &quot;done的赋值&quot;,所以这个程序有可能输出空的字符串，甚至极端main goroutine一直观察不到done的赋值导致程序永远没办法完成。</p>
<h2 id="x86的TSO">x86的TSO</h2>
<p>不同的CPU架构对memory order的处理是不一样的，而Go内存模型保证的是在所有支持的架构下的一致性。有些并发问题在x86是没问题的，但是在ARM架构下可能会有问题。</p>
<p>我们看看现代的x86的内存模型。下面是它们的一种架构:<br><img src="mem-tso.png" alt=""></p>
<p>每一个处理器都有自己的写队列，同时都连着一个共享主内存。处理器读的时候先查询自己的写队列，再查询主内存。处理器不会查询其它处理器的写队列。</p>
<p>虽然处理器会看到自己的写，暂时看不到其它处理器的写，但是到了主内存的时候，所有的写都是顺序的，所有的处理器看到的主内存的写都是有序的，所以x86的内存模型也叫做存储全序模型(TSO,total store order)。</p>
<p>对于x86内存模型，只要一个值写入了主内存，未来的读会看到它(直到一个新的写覆盖了它)。</p>
<p>ARM/POWER 使用一种更宽松的内存模型，每个处理器都读写它自己的内存副本，每个写都会独自传播到其它的处理器。在传播的时候允许重排序,并没有像x86 存储全序。<br><img src="mem-weak.png" alt=""></p>
<p>但是对于ARM/POWER， 不同线程对同一个内存地址的写是全序的，也就是一个线程观察到的同一个内存地址的写和另一个线程观察到的同一个内存地址的写顺序都是一样的，尽管对不同的地址的写观察到的顺序可能不一样，这被称之为<strong>Coherence</strong>。</p>
<h2 id="分析上面的问题">分析上面的问题</h2>
<p>啰嗦了这么多，其实还是讲一个memory model的背景,而且这些这些知识也在Russ Cox的硬件内存模型做了介绍，也有很多相关的文章专门介绍memory order等相关的知识。 Russ Cox为了修订Go内存模型，专门对此做了深入的研究，还写了<a href="https://research.swtch.com/mm" target="_blank" rel="external">三篇文章</a>对此进行介绍。</p>
<p>以上都是理论，但是Go内存模型对真实的并发程序有什么指导呢？那就逐个分析开头我们提出的几个问题吧。</p>
<h3 id="在另一个goroutine看到的write顺序-1">在另一个goroutine看到的write顺序</h3>
<p>第一道题，下面这段代码❶是否可能输出<code>1, 0</code>?</p>
<p>对于x86架构， 答案是: <strong>否</strong>。<br>x86架构保证TSO,存储有序。 对于第一个写goroutine， x,y的写入顺序是保证有序的，写入到第一个线程的write queue保证 x sequenced before y, 又因为TSO存储有序， 其它的goroutine观察到的顺序也是x sequenced before y。</p>
<p>对于ARM架构， 答案是: <strong>是</strong>。 对于第一个写goroutine， x,y的写入顺序是有序的,但是由于arm架构不是TSO， 对x,y的写在传播到其它处理器时，可能会重排序，所以有可能有的处理器看到x,y write,有的看到y,x write。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(2</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> x, y <span class="typename">int</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		x =<span class="number"> 1</span></div><div class="line">		y =<span class="number"> 1</span></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		r1 := y</div><div class="line">		r2 := x</div><div class="line">		</div><div class="line">        fmt.Println(r1, r2)  <span class="comment">// ❶ r1 = 1, r2 = 0 可能吗?</span></div><div class="line">       </div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="两个goroutine交叉read/write-1">两个goroutine交叉read/write</h3>
<p>第二道题，下面这段代码是否可能速出 r1= 0, r2 =0这样的结果？</p>
<p>正常的理解,  <code>x=1</code>或者<code>y=1</code>先会发生，或者输出结果总会有一个1, 所以<code>r1= 0, r2 =0</code>不太可能发生。</p>
<p><strong>但是</strong>，在x86架构下，两个goroutine(线程)把它们的write放入write buffer,之后接着读另一个变量，这个时候它们的写可能还没有同步到主内存中，就会导致它们的读到的还是零值。所以在x86下答案是： <strong>是</strong>, 有可能发生。</p>
<p>对于ARM/POWER, 也类似，goroutine各自的写有可能还未传播到对方的处理器，所以答案也是: <strong>是</strong>， 有可能发生。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(2</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> x, y <span class="typename">int</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		x =<span class="number"> 1</span></div><div class="line">		r1 := y</div><div class="line">		fmt.Println(r1) <span class="comment">// ❶</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		y =<span class="number"> 1</span></div><div class="line">		r2 := x</div><div class="line">		fmt.Println(r2) <span class="comment">// ❷</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="两个goroutine看到的write顺序-1">两个goroutine看到的write顺序</h3>
<p>下面这段代码, ❶和❷可能输出<code>1,0</code>和<code>0,1</code>这两种不同的结果吗？</p>
<p>对于x86架构， 答案是: <strong>否</strong>, 不可能发生。既然第三个goroutine已经观察到了<code>1,0</code>,因为x86是TSO,存储有序，所以<code>x=1</code> sychronized before <code>y=1</code>, 第四个goroutine观察到的只能是<code>0,0</code>、<code>1,0</code>或者<code>1,1</code>,不可能是<code>0,1</code>。</p>
<p>对于ARM架构，答案是: <strong>是</strong>, 是有可能发生的，不同的线程观察到的对不同的内存地址的写的顺序可能不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> x, y <span class="typename">int</span></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		x =<span class="number"> 1</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		y =<span class="number"> 1</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		r1 := x</div><div class="line">		r2 := y</div><div class="line"></div><div class="line">		fmt.Println(r1, r2) <span class="comment">// ❶ 1,0</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		r3 := x</div><div class="line">		r4 := y</div><div class="line"></div><div class="line">		fmt.Println(r3, r4) <span class="comment">// ❷ 0,1</span></div><div class="line"></div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="sync-Once-1">sync.Once</h3>
<p>上面都是一些测试例子，为了举例内存同步的复杂性，接下来我们看一下实际标准库中为了内存同步所做的特殊处理。</p>
<p>下面是Go标准库中<code>sync.Once</code>的实现，虽然很简单的几行代码，你品一品，有没有什么疑问？</p>
<p>这个简短的几行代码经常会对深入研究Go代码的同学造成困惑，为什么❹处不使用atomic? 那么❶和❺处不使用atomic行不行？</p>
<p>❹处执行一个double check, ❺处的对o.done执行了一个写，他俩不会data race么？</p>
<p>假定g1执行了❺, 一个并发的的g2也正好执行到了❷。</p>
<p>因为根据g1, ❺ sequnenced before ❸, 根据Mutex的保证， g2的❷ synchronized before ❹， 所以当g2获取了获取，执行到4的时候，他是能看到g1已经把o.done标记为1了。</p>
<p>那么 ❶和❺处不使用atomic行不行？不行！ 严谨的说，为了性能，不行!</p>
<p>❶和❺处为了实现同步，必须要使用同步原语，这里最简单的就是使用atomic。 ❺处的写一定会被❶处的读看到。</p>
<p>如果❶和❺处不使用atomic,那么极端情况❶处总是检查o.done==0,然后总是会进入doSlow进行double check,耗费性能。</p>
<p>对于x86架构， ❶处可以不使用atomic,但是❺处必须使用atomic,以便能把done=1写入到主内存中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (o *Once) Do(f <span class="keyword">func</span>()) {</div><div class="line">	<span class="keyword">if</span> atomic.LoadUint32(&o.done) ==<span class="number"> 0</span> { <span class="comment">// ❶</span></div><div class="line">		o.doSlow(f)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Once) doSlow(f <span class="keyword">func</span>()) {</div><div class="line">	o.m.Lock() <span class="comment">// ❷</span></div><div class="line">	<span class="keyword">defer</span> o.m.Unlock() <span class="comment">// ❸</span></div><div class="line">	<span class="keyword">if</span> o.done ==<span class="number"> 0</span> { <span class="comment">// ❹</span></div><div class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&o.done,<span class="number"> 1</span>) <span class="comment">// ❺</span></div><div class="line">		f()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="sync-WaitGroup-1">sync.WaitGroup</h3>
<p>下面是一段<code>WaitGroup</code>的示例代码, ❶处需要使用atomic.Load吗？ 如果不使用，一定输出10吗？</p>
<p>答案是: <strong>不需要</strong>， 一定输出10。</p>
<p>❶ suquenced before ❷, ❷ synchronized before ❸, ❸ sequenced before ❹, 所以❹一定会看到各个goroutine对count的写， 所以❹处不需要atomic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> count <span class="typename">int64</span></div><div class="line">	</div><div class="line">    <span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add<span class="number">(10</span>)</div><div class="line">	</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			atomic.AddInt64(&count,<span class="number"> 1</span>) <span class="comment">// ❶</span></div><div class="line">			wg.Done() <span class="comment">// ❷</span></div><div class="line">		}()</div><div class="line">	}</div><div class="line">	</div><div class="line">    wg.Wait() <span class="comment">// ❸</span></div><div class="line"></div><div class="line">	fmt.Println(count) <span class="comment">// ❹</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="TryLock-1">TryLock</h3>
<p>下面这段代码是Mutex的TryLock方法的实现。❶处为什么不使用atomic,会不会导致锁已经释放了但是TryLock获取不到锁？</p>
<p>答案是: <strong>会</strong>, 在某些CPU架构下，有可能锁已经释放了，但是后续的 goroutine会获取不到锁。</p>
<blockquote>
<p>As far as the memory model is concerned, <code>l.TryLock</code> (or <code>l.TryRLock</code>) may be considered to be able to return false even when the mutex l is unlocked.<br>就Go内存模型而言，即使 l 已经释放了锁,  <code>l.TryLock</code> (或者 <code>l.TryRLock</code>) 也可能返回false。</p>
</blockquote>
<p>对于我们普通开发者而言，这叫做bug或者data race, 但是对于Go开发组来说，他们称之为为性能优化所做的特殊设计。</p>
<blockquote>
<p>The memory model is defining when one event is synchronized before another. That sentence is saying that in a sequence Lock -&gt; Unlock -&gt; TryLock -&gt; Lock there is no promise that the TryLock is synchronized before the Lock. The TryLock can fail to lock the mutex even though the mutex is unlocked.</p>
<p>From Ian Lance Taylor</p>
</blockquote>
<p>但是对于x86来说，这不是一个问题。当一个goroutine释放了锁， ❶处是能及时观察到锁的释放的。但是对于Arm架构， 锁释放后， ❶处不一定能及时的获取到锁的释放，所以即使锁释放了，它依然可能返回false，这只是非常极端极端的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	old := m.state <span class="comment">// ❶</span></div><div class="line">	<span class="keyword">if</span> old&(mutexLocked|mutexStarving) !=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !atomic.CompareAndSwapInt32(&m.state, old, old|mutexLocked) {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://research.swtch.com/hwmm" target="_blank" rel="external">https://research.swtch.com/hwmm</a></li>
<li><a href="https://github.com/golang/go/issues/5045" target="_blank" rel="external">https://github.com/golang/go/issues/5045</a></li>
<li><a href="https://go.dev/ref/mem" target="_blank" rel="external">https://go.dev/ref/mem</a></li>
<li><a href="https://github.com/golang/go/discussions/47141" target="_blank" rel="external">https://github.com/golang/go/discussions/47141</a></li>
<li><a href="https://hackmd.io/@vesuppi/Syvoiw1f8" target="_blank" rel="external">https://hackmd.io/@vesuppi/Syvoiw1f8</a></li>
<li><a href="https://www.chanmufeng.com/posts/concurrency/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.html" target="_blank" rel="external">https://www.chanmufeng.com/posts/concurrency/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go一向以它的简单易学而著称，我也遇到过同学说只需半天就能掌握Go语言了，两三年的Go开发经验就称专家了。</p>
<p>想比较Rust等编程语言，Go语言的确容易上手，查看Go语言的规范你也会看到，它的语言规范相比较其它编程语言非常的简短，的确可以一个小时就可以读完。但是如果你深入了解这门语言(其它语言也是类似情况)，就会发现很多细节的地方，需要花谢心思和时间仔细琢磨琢磨。这不，我先来几道Go并发的源代码考考你，看看你能回答上来不？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[与日俱进，在 Go 1.20 中这种高效转换的方式又变了]]></title>
    <link href="https://colobu.com/2022/09/06/string-byte-convertion/"/>
    <id>https://colobu.com/2022/09/06/string-byte-convertion/</id>
    <published>2022-09-06T05:54:38.000Z</published>
    <updated>2022-09-06T11:02:06.183Z</updated>
    <content type="html"><![CDATA[<p>在 Go 1.19 的开发中, <code>string.SliceHeader</code>和<code>string.StringHeader</code>经历了一个生死存亡的争斗，这两个类型一度被标记为弃用(<a href="https://github.com/golang/go/commit/bc2e961cf4cda945dc6d607a5076b4e376553e9f" target="_blank" rel="external"><code>deprecated</code></a>),但是这两个类型经常用在 slice of byte 和 string 高效互转的场景中，如果被标记为弃用，但是目前还没有可替代的方法，所以这两个类型又把弃用标记去掉了，如无意外，它们也会在 Go 1.20 再次被标记为弃用。</p>
<a id="more"></a>
<h2 id="byte_slice_和_string_的转换优化">byte slice 和 string 的转换优化</h2>
<p>直接通过强转<code>string(bytes)</code>或者<code>[]byte(str)</code>会带来数据的复制，性能不佳，所以在追求极致性能场景，我们会采用『骇客』的方式，来实现这两种类型的转换,比如k8s采用下面的方式：</p>
<figure class="highlight go"><figcaption><span>https://github.com/kubernetes/apiserver/blob/706a6d89cf35950281e095bb1eeed5e3211d6272/pkg/authentication/token/cache/cached_token_authenticator.go#L263-L271</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// toBytes performs unholy acts to avoid allocations</span></div><div class="line"><span class="keyword">func</span> toBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&s))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// toString performs unholy acts to avoid allocations</span></div><div class="line"><span class="keyword">func</span> toString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&b))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>更多的采用下面的方式(rpcx也采用下面的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> SliceByteToString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&b))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> StringToSliceByte(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	x := (*<span class="number">[2</span>]<span class="typename">uintptr</span>)(unsafe.Pointer(&s))</div><div class="line">	h := <span class="number">[3</span>]<span class="typename">uintptr</span>{x<span class="number">[0</span>], x<span class="number">[1</span>], x<span class="number">[1</span>]}</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&h))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至，标准库也采用这种方式：</p>
<figure class="highlight go"><figcaption><span>https://github.com/golang/go/blob/82f902ae8e2b7f7eff0cdb087e47e939cc296a62/src/strings/clone.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Clone(s <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span></div><div class="line">	}</div><div class="line">	b := <span class="built_in">make</span>([]<span class="typename">byte</span>, <span class="built_in">len</span>(s))</div><div class="line">	<span class="built_in">copy</span>(b, s)</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&b))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为 slice of byte 和 string 数据结构类似，所以我们可以可以使用这种『骇客』的方式强转。这两种类型的数据结构在<code>reflect</code>包中有定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">	Data <span class="typename">uintptr</span></div><div class="line">	Len  <span class="typename">int</span></div><div class="line">	Cap  <span class="typename">int</span></div><div class="line">}</div><div class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> {</div><div class="line">	Data <span class="typename">uintptr</span></div><div class="line">	Len  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Slice</code>比<code>String</code>多一个<code>Cap</code>字段，它们的数据通过一个数组存储，这两个结构的<code>Data</code>存储了指向这个数组的指针。</p>
<h2 id="Go_1-20_的新的方式">Go 1.20 的新的方式</h2>
<p>很多项目中都使用上面的方式进行性能提升，但是这是通过<code>unsafe</code>实现的，有相当的风险，因为强转之后，slice可能会做一些变动，导致相关的数据被覆盖了或者被回收了，也经常会出现一些意想不到的问题，我在使用这种方式做RedisProxy的时候，也犯过类似的错误，我当时还以为是标准库出错了呢。</p>
<p>因此， Go官方准备在 1.20 中把这两个类型<code>SliceHeader</code>和<code>StringHeader</code>废弃掉，避免大家的误用。<br>废弃就废弃吧，但是也得提供相应的替代方法才行。这不，在 Go 1.12中，增加了几个方法<code>String</code>、<code>StringData</code>、<code>Slice</code>和<code>SliceData</code>,用来做这种性能转换。</p>
<ul>
<li>func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType: 返回一个Slice,它的底层数组自ptr开始，长度和容量都是len</li>
<li>func SliceData(slice []ArbitraryType) *ArbitraryType：返回一个指针，指向底层的数组</li>
<li>func String(ptr *byte, len IntegerType) string： 生成一个字符串，底层的数组开始自ptr, 长度是len</li>
<li>func StringData(str string) *byte: 返回字符串底层的数组</li>
</ul>
<p>这四个方法看起来很原始很底层。</p>
<p>这个提交是由cuiweixie提交的。因为涉及到很基础很底层的实现，而且又是可能被广泛使用的方法，所以大家review起来特别的仔细，大家可以围观: <a href="https://go-review.googlesource.com/c/go/+/427095/" target="_blank" rel="external">go-review#427095</a>。</p>
<p>甚至，这个修改都惊动了蛰伏多月的Rob Pike大佬，他老人家询问为啥只有实现连注释文档都没有呢:<a href="https://github.com/golang/go/issues?q=is%3Aissue+unsafe" target="_blank" rel="external">#54858</a>，当然原因是这个功能还在开发和review之中，不过可以看出Rob Pike很重视这个修改。</p>
<p>cuiweixie 甚至还修改了标准库里面一些<a href="https://github.com/golang/go/issues/54854" target="_blank" rel="external">写法</a>，使用他提交的unsafe中的这四个方法。</p>
<h2 id="性能测试">性能测试</h2>
<p>虽然cuiweixie的提交还没有被merge到主分支，还存在一些变数，但是我发现使用gotip能使用这几个方法了。 我理解的是gotip适合master分支保持一致的，难道不是么？</p>
<p>不管怎样，先写个benchmark:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> L =<span class="number"> 1024</span> *<span class="number"> 1024</span></div><div class="line"><span class="keyword">var</span> str = strings.Repeat(<span class="string">"a"</span>, L)</div><div class="line"><span class="keyword">var</span> s = bytes.Repeat([]<span class="typename">byte</span>{<span class="string">'a'</span>}, L)</div><div class="line"></div><div class="line"><span class="keyword">var</span> str2 <span class="typename">string</span></div><div class="line"><span class="keyword">var</span> s2 []<span class="typename">byte</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkString2Slice(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		bt := []<span class="typename">byte</span>(str)</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bt) != L {</div><div class="line">			b.Fatal()</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkString2SliceReflect(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		bt := *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&str))</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bt) != L {</div><div class="line">			b.Fatal()</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkString2SliceUnsafe(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		bt := unsafe.Slice(unsafe.StringData(str), <span class="built_in">len</span>(str))</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(bt) != L {</div><div class="line">			b.Fatal()</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkSlice2String(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		ss := <span class="typename">string</span>(s)</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(ss) != L {</div><div class="line">			b.Fatal()</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkSlice2StringReflect(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		ss := *(*<span class="typename">string</span>)(unsafe.Pointer(&s))</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(ss) != L {</div><div class="line">			b.Fatal()</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkSlice2StringUnsafe(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		ss := unsafe.String(unsafe.SliceData(s), <span class="built_in">len</span>(str))</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(ss) != L {</div><div class="line">			b.Fatal()</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际测试结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜  strslice gotip test -benchmem  -bench .</div><div class="line">goos: darwin</div><div class="line">goarch: arm64</div><div class="line">pkg: github.com/smallnest/study/strslice</div><div class="line">BenchmarkString2Slice-<span class="number">8</span>          	   <span class="number">18826</span>	         <span class="number">63942</span> ns/op	 <span class="number">1048579</span> B/op	       <span class="number">1</span> allocs/op</div><div class="line">BenchmarkString2SliceReflect-<span class="number">8</span>   	<span class="number">1000000000</span>	         <span class="number">0.6498</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkString2SliceUnsafe-<span class="number">8</span>    	<span class="number">1000000000</span>	         <span class="number">0.8178</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkSlice2String-<span class="number">8</span>          	   <span class="number">18686</span>	         <span class="number">65864</span> ns/op	 <span class="number">1048580</span> B/op	       <span class="number">1</span> allocs/op</div><div class="line">BenchmarkSlice2StringReflect-<span class="number">8</span>   	<span class="number">1000000000</span>	         <span class="number">0.6488</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkSlice2StringUnsafe-<span class="number">8</span>    	<span class="number">1000000000</span>	         <span class="number">0.9744</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div></pre></td></tr></table></figure>

<p>可以看到，不通过『骇客』的方式，两种类型强转耗时非常巨大，如果采用<code>reflect</code>的方式，性能提升大大改观。</p>
<p>如果采用最新的<code>unsafe</code>包的方式，性能也能大大提高，虽然耗时比<code>reflect</code>略有增加，可以忽略。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 Go 1.19 的开发中, <code>string.SliceHeader</code>和<code>string.StringHeader</code>经历了一个生死存亡的争斗，这两个类型一度被标记为弃用(<a href="https://github.com/golang/go/commit/bc2e961cf4cda945dc6d607a5076b4e376553e9f" target="_blank" rel="external"><code>deprecated</code></a>),但是这两个类型经常用在 slice of byte 和 string 高效互转的场景中，如果被标记为弃用，但是目前还没有可替代的方法，所以这两个类型又把弃用标记去掉了，如无意外，它们也会在 Go 1.20 再次被标记为弃用。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个线程安全的泛型支持map库]]></title>
    <link href="https://colobu.com/2022/09/04/a-thread-safe-and-generic-supported-map/"/>
    <id>https://colobu.com/2022/09/04/a-thread-safe-and-generic-supported-map/</id>
    <published>2022-09-04T11:18:16.000Z</published>
    <updated>2022-09-04T12:15:14.627Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="external">orcaman/concurrent-map</a>是一个非常高效的线程安全的map库，正如它的文档中所说的那样，标准库<code>sync.Map</code>更适合<code>append-only</code>的场景，或者说少写大量的读的场景，如果针对多读多写的场景，<code>concurrent-map</code>可能会更有优势。它是通过分片的方式，将锁的粒度减少，从而提高性能。</p>
<p>今年初的时候，这个库做了改造，开始<a href="https://github.com/orcaman/concurrent-map/commit/b62fe33532f54e844634ecfad05209bbbcb69ddf" target="_blank" rel="external">支持泛型</a>，但是不幸的是，它只支持Value值泛型，它的key只能是<code>string</code>类型，这就限制了它的应用场景。</p>
<a id="more"></a>
<p>我fork了这个项目，创建了一个新的线程安全的库<a href="https://github.com/smallnest/safemap" target="_blank" rel="external">smallnest/safemap</a>,同时支持Key和Value的泛型，可以应用更多的sh使用场合。</p>
<p>我能理解为什么<code>concurrent-map</code>的key不支持泛型，因为不好实现。因为对于一个泛型的Key,我们不太好计算它的hash值，要么转换成string再计算hash值性能底下，要么提供一个hash函数变量，让用户自己实现hash算法，用户使用起来又不方便。</p>
<p>我最近看到一个新的项目<a href="https://github.com/alphadose/haxmap" target="_blank" rel="external">alphadose/haxmap</a>,它也是一个线程安全的map, 基于<a href="https://www.cl.cam.ac.uk/research/srg/netos/papers/2001-caslists.pdf" target="_blank" rel="external">Harris lock-free list</a>算法，参考它的Key的hash的计算方法，实现了对<code>concurrent-map</code>打补丁，以便Key和Value同时支持泛型，这就促成了<a href="https://github.com/smallnest/safemap" target="_blank" rel="external">smallnest/safemap</a>库。</p>
<p>当然，在复制haxmap的hash算法的过程中，也发现了它的hash算法对一些类型有问题，做了修复。</p>
<p>大家既可以使用<code>safemap</code>处理并发读写的场景，也可以通过<code>safemap</code>了解如何对一个既有的项目进行泛型支持的改造。</p>
<h2 id="Map_Key/Value同时支持泛型的改造">Map Key/Value同时支持泛型的改造</h2>
<p><code>concurrent-map</code>的定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ConcurrentMap[V any] []*ConcurrentMapShared[V]</div><div class="line"></div><div class="line"><span class="keyword">type</span> ConcurrentMapShared[V any] <span class="keyword">struct</span> {</div><div class="line">	items        <span class="keyword">map</span>[<span class="typename">string</span>]V</div><div class="line">	sync.RWMutex <span class="comment">// Read Write mutex, guards access to internal map.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，它只定义了<code>V any</code>类型约束，用来做Value的类型，而它的Key类型只能是string类型: <code>items        map[string]V</code>。<br>这个好处是它可以只实现一个特定的对string类型的hash算法，不用考虑各种key类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fnv32(key <span class="typename">string</span>) <span class="typename">uint32</span> {</div><div class="line">	hash := <span class="typename">uint32</span><span class="number">(2166136261</span>)</div><div class="line">	<span class="keyword">const</span> prime32 = <span class="typename">uint32</span><span class="number">(16777619</span>)</div><div class="line">	keyLength := <span class="built_in">len</span>(key)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; keyLength; i++ {</div><div class="line">		hash *= prime32</div><div class="line">		hash ^= <span class="typename">uint32</span>(key[i])</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> hash</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为啥不使用内建map的hash算法，针对所有的comparable类型计算hash值呢？这个问题也有过讨论<a href="https://github.com/golang/go/issues/21195" target="_blank" rel="external">#21195</a>,但最后也不了了之了。虽然在Go 1.19 Go官方把内部的memhash算法<a href="https://pkg.go.dev/hash/maphash" target="_blank" rel="external">暴露出来</a>，但是针对本文的场景，我们期望的是能暴露一个泛型的Hash算法。</p>
<p>不管怎样，我们假定有一个办法，我们自己实现了一个针对泛型的hash算法。那么我们现在就需要对<code>ConcurrentMap</code>进行改造。</p>
<p>我首先把它命名为<code>SafeMap</code>,更简短一些，同时支持Key和Value的类型约束:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SafeMap[K comparable, V any] <span class="keyword">struct</span> {</div><div class="line">	shared []*SafeMapShared[K, V]</div><div class="line">	hasher <span class="keyword">func</span>(K) <span class="typename">uintptr</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> SafeMapShared[K comparable, V any] <span class="keyword">struct</span> {</div><div class="line">	items        <span class="keyword">map</span>[K]V</div><div class="line">	sync.RWMutex </div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里定义了一个泛型的hasher: <code>hasher func(K) uintptr</code>,用来计算一个泛型的Key的hash值。下面我们去实现它。</p>
<p>接着就是修复程序的标红的地方。也就是原来硬编码string的地方，我们都要用K进行替换，比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *SafeMap[K, V]) GetShard(key K) *SafeMapShared[K, V] {</div><div class="line">	k := <span class="typename">uint</span>(m.hasher(key))</div><div class="line">	<span class="keyword">return</span> m.shared[<span class="typename">uint</span>(k)%<span class="typename">uint</span>(ShardCount)]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Sets the given value under the specified key.</span></div><div class="line"><span class="keyword">func</span> (m *SafeMap[K, V]) Set(key K, value V) {</div><div class="line">	<span class="comment">// Get map shard.</span></div><div class="line">	shard := m.GetShard(key)</div><div class="line">	shard.Lock()</div><div class="line">	shard.items[key] = value</div><div class="line">	shard.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Receiver</code>要进行修改，因为目前它有两个类型约束(<code>K</code>、<code>V</code>)。涉及到<code>Key string</code>的地方都要使用<code>Key K</code>进行替换。</p>
<p>这个的hash计算使用<code>hasher</code>方法。接下来就看看我们默认的hasher算法。</p>
<h2 id="hasher">hasher</h2>
<p>这个hasher方法实现的难点在于要支持泛型。 如果要是特定的类型，比如int64、string，我们可以直接使用它底层的值计算hash值。如果要是<code>interface{}</code>呢,也好办，利用<code>type switch</code>也可以方便的机型处理。 如果是泛型呢，它是在编译期执行的，也不能直接使用<code>type switch</code>，那怎么办呢？</p>
<p>首先，我们在初始化的时候去判断Key的类型，这可以通过反射实现(先把Key转为<code>interface{}</code>,再使用<code>type switch</code>)，然后根据不同的类型返回特定的hasher算法，这样因为hasher实在初始化的时候确定下来的，也不影响后续的Set、Get方法的性能。</p>
<p>下面是生成hasher的片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> （</div><div class="line">	<span class="comment">// qword hasher, key size -&gt; 8 bytes</span></div><div class="line">	qwordHasher = <span class="keyword">func</span>(key <span class="typename">uint64</span>) <span class="typename">uintptr</span> {</div><div class="line">		k1 := key * prime2</div><div class="line">		k1 = bits.RotateLeft64(k1,<span class="number"> 31</span>)</div><div class="line">		k1 *= prime1</div><div class="line">		h := (prime5 +<span class="number"> 8</span>) ^ k1</div><div class="line">		h = bits.RotateLeft64(h,<span class="number"> 27</span>)*prime1 + prime4</div><div class="line">		h ^= h &gt;&gt;<span class="number"> 33</span></div><div class="line">		h *= prime2</div><div class="line">		h ^= h &gt;&gt;<span class="number"> 29</span></div><div class="line">		h *= prime3</div><div class="line">		h ^= h &gt;&gt;<span class="number"> 32</span></div><div class="line">		<span class="keyword">return</span> <span class="typename">uintptr</span>(h)</div><div class="line">	}</div><div class="line"></div><div class="line">    	float64Hasher = <span class="keyword">func</span>(key <span class="typename">float64</span>) <span class="typename">uintptr</span> {</div><div class="line">		k := *(*<span class="typename">uint64</span>)(unsafe.Pointer(&key))</div><div class="line">		h := prime5 +<span class="number"> 4</span></div><div class="line">		h ^= <span class="typename">uint64</span>(k) * prime1</div><div class="line">		h = bits.RotateLeft64(h,<span class="number"> 23</span>)*prime2 + prime3</div><div class="line">		h ^= h &gt;&gt;<span class="number"> 33</span></div><div class="line">		h *= prime2</div><div class="line">		h ^= h &gt;&gt;<span class="number"> 29</span></div><div class="line">		h *= prime3</div><div class="line">		h ^= h &gt;&gt;<span class="number"> 32</span></div><div class="line">		<span class="keyword">return</span> <span class="typename">uintptr</span>(h)</div><div class="line">	}</div><div class="line">）</div><div class="line">    </div><div class="line"><span class="keyword">func</span> genHasher[K comparable]() <span class="keyword">func</span>(K) <span class="typename">uintptr</span> {</div><div class="line">	<span class="keyword">var</span> hasher <span class="keyword">func</span>(K) <span class="typename">uintptr</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span> any(*<span class="built_in">new</span>(K)).(<span class="keyword">type</span>) {</div><div class="line">	<span class="keyword">case</span> <span class="typename">int64</span>, <span class="typename">uint64</span>:</div><div class="line">		hasher = *(*<span class="keyword">func</span>(K) <span class="typename">uintptr</span>)(unsafe.Pointer(&qwordHasher))</div><div class="line">	<span class="keyword">case</span> <span class="typename">float64</span>:</div><div class="line">		hasher = *(*<span class="keyword">func</span>(K) <span class="typename">uintptr</span>)(unsafe.Pointer(&float64Hasher))</div></pre></td></tr></table></figure>

<p>首先把泛型的值转换成<code>interface{}</code>，这样才能type switch: <code>switch any(*new(K)).(type) {</code>。</p>
<p>如果是int64、uint64类型, 我们可以使用<code>qwordHasher</code>这个预定义的hasher,不过它的类型是<code>func(key uint64) uintptr</code>，对于int64类型来说，可以使用<code>unsafe</code>强制转一下。</p>
<p>这样，最难的一点我们就攻克了，各种类型都可以独立的去处理，只需要进一步针对不同的类型定义相应的hasher就可以了。你可以使用各种hash算法去实现。</p>
<p>这样，<code>safemap</code>就改造完了。性能怎么样，我建议你实际进行测试，而且最好根据你的实际的场景进行测试。项目中提供了一些基本的benchmark测试。</p>
<p>另外，我还建议你关注一下<a href="https://github.com/alphadose/haxmap" target="_blank" rel="external">alphadose/haxmap</a>,我的初步测试它的性能会更好，但是我还需要等待它发展一段时间，变得更稳定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="external">orcaman/concurrent-map</a>是一个非常高效的线程安全的map库，正如它的文档中所说的那样，标准库<code>sync.Map</code>更适合<code>append-only</code>的场景，或者说少写大量的读的场景，如果针对多读多写的场景，<code>concurrent-map</code>可能会更有优势。它是通过分片的方式，将锁的粒度减少，从而提高性能。</p>
<p>今年初的时候，这个库做了改造，开始<a href="https://github.com/orcaman/concurrent-map/commit/b62fe33532f54e844634ecfad05209bbbcb69ddf" target="_blank" rel="external">支持泛型</a>，但是不幸的是，它只支持Value值泛型，它的key只能是<code>string</code>类型，这就限制了它的应用场景。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[啊哈，一道有趣的Go并发题]]></title>
    <link href="https://colobu.com/2022/09/01/fizzbuzz-in-go/"/>
    <id>https://colobu.com/2022/09/01/fizzbuzz-in-go/</id>
    <published>2022-09-01T14:00:32.000Z</published>
    <updated>2022-09-09T08:51:25.826Z</updated>
    <content type="html"><![CDATA[<p>今天一位同学给我出了一道并发题，作为在极客时间开了《GO并发编程实战课》的作者，居然一时间没有回答上来，惭愧啊，所以晚上专门研究了一下题目，给出几个实现方案供探讨。</p>
<a id="more"></a>
<p>这道题貌似在哪里见过，凭借回忆我找到了，原来是Leetcode的<a href="https://leetcode.cn/problems/fizz-buzz-multithreaded/" target="_blank" rel="external">并发题</a>。这道题是这么说的:</p>
<p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p>
<p>如果这个数字可以被 3 整除，输出 &quot;fizz&quot;。<br>如果这个数字可以被 5 整除，输出 &quot;buzz&quot;。<br>如果这个数字可以同时被 3 和 5 整除，输出 &quot;fizzbuzz&quot;。<br>例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</p>
<p>假设有这么一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class FizzBuzz {</div><div class="line">  <span class="keyword">public</span> <span class="title">FizzBuzz</span>(<span class="keyword">int</span> n) { ... }               <span class="comment">// constructor</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span>(printFizz) { ... }          <span class="comment">// only output "fizz"</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span>(printBuzz) { ... }          <span class="comment">// only output "buzz"</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span>(printFizzBuzz) { ... }  <span class="comment">// only output "fizzbuzz"</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span>(printNumber) { ... }      <span class="comment">// only output the numbers</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：</p>
<p>线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。<br>线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。<br>线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。<br>线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</p>
<p>基本上，这是一个任务编排的并发题，其实使用最简单的并发原语就可以实现。</p>
<h2 id="将并发转为串行">将并发转为串行</h2>
<p>我开始的思路想错了，我想实现一个manager，去调度四个goroutine,但是其实有一个最简单的糙快猛的方法，就像我在专栏中出的&quot;击鼓传花”那道题一样，可以将这四个goroutine串行化。</p>
<p>每一个数字，交给一个goroutine去处理，如果不是它负责处理，那么它就交给下一个goroutine。<br>这道题的妙处就在于，这四种case是没有交叉的，一个数字只能由一个goroutine处理，并且肯定会有一个goroutine去处理，这就好办了。在四个goroutine交递的过程中，肯定有一个goroutine会输出内容，如果它输出了内容，它就将数字加一，交给下一个groutine去检查和处理，这就开启了新的一轮数字的检查和处理。</p>
<p>当处理的数字大于指定的数字，它将数字交递给下一个goroutine,然后返回。这样下一个goroutine同样的处理也会返回。最后四个goroutine都返回了。</p>
<p>我们使用一个WaitGroup等待四个goroutine都返回，然后程序退出。</p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> FizzBuzz <span class="keyword">struct</span> {</div><div class="line">	n <span class="typename">int</span></div><div class="line"></div><div class="line">	chs []<span class="keyword">chan</span> <span class="typename">int</span></div><div class="line">	wg  sync.WaitGroup</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> New(n <span class="typename">int</span>) *FizzBuzz {</div><div class="line">	chs := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="typename">int</span>,<span class="number"> 4</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 4</span>; i++ {</div><div class="line">		chs[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>,<span class="number"> 1</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &FizzBuzz{</div><div class="line">		n:   n,</div><div class="line">		chs: chs,</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) start() {</div><div class="line">	fb.wg.Add<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> fb.fizz()</div><div class="line">	<span class="keyword">go</span> fb.buzz()</div><div class="line">	<span class="keyword">go</span> fb.fizzbuzz()</div><div class="line">	<span class="keyword">go</span> fb.number()</div><div class="line"></div><div class="line">	fb.chs<span class="number">[0</span>] &lt;-<span class="number"> 1</span></div><div class="line"></div><div class="line">	fb.wg.Wait()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) fizz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	next := fb.chs<span class="number">[1</span>]</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.chs<span class="number">[0</span>] {</div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			next &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> {</div><div class="line">				next &lt;- v</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" fizz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" fizz,"</span>)</div><div class="line">			}</div><div class="line"></div><div class="line">			next &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		next &lt;- v</div><div class="line">	}</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) buzz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	next := fb.chs<span class="number">[2</span>]</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.chs<span class="number">[1</span>] {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			next &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">				next &lt;- v</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" buzz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" buzz,"</span>)</div><div class="line">			}</div><div class="line"></div><div class="line">			next &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		next &lt;- v</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) fizzbuzz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	next := fb.chs<span class="number">[3</span>]</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.chs<span class="number">[2</span>] {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			next &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> && v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" fizzbuzz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" fizzbuzz,"</span>)</div><div class="line">			}</div><div class="line"></div><div class="line">			next &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		next &lt;- v</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) number() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	next := fb.chs<span class="number">[0</span>]</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.chs<span class="number">[3</span>] {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			next &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> !=<span class="number"> 0</span> && v<span class="number">%3</span> !=<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Printf(<span class="string">" %d。"</span>, v)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Printf(<span class="string">" %d,"</span>, v)</div><div class="line">			}</div><div class="line"></div><div class="line">			next &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		next &lt;- v</div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fb := New<span class="number">(15</span>)</div><div class="line">	fb.start()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用一个channel">使用一个channel</h2>
<p>上面讲并发转为串行的操作，总是让人感觉差强人意，我们更想并发的去执行。</p>
<p>所以可以转换一下思路，四个goroutine使用同一个channel。 如果某个goroutine非常幸运，从这个channel中取出一个值，它会做检查，无非两种情况：</p>
<ul>
<li>正好是自己要处理的数： 它输出相应的文本，并且把值加一，再放入到channel中</li>
<li>不是自己要处理的数：把此数再放回到channel中</li>
</ul>
<p>对于每一个数，总会有goroutine取出来并处理。</p>
<p>当取出来的数大于指定的数时，把此数放回到channel，并返回。</p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> FizzBuzz <span class="keyword">struct</span> {</div><div class="line">	n <span class="typename">int</span></div><div class="line"></div><div class="line">	ch <span class="keyword">chan</span> <span class="typename">int</span></div><div class="line">	wg sync.WaitGroup</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> New(n <span class="typename">int</span>) *FizzBuzz {</div><div class="line">	<span class="keyword">return</span> &FizzBuzz{</div><div class="line">		n:  n,</div><div class="line">		ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>,<span class="number"> 1</span>),</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) start() {</div><div class="line">	fb.wg.Add<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> fb.fizz()</div><div class="line">	<span class="keyword">go</span> fb.buzz()</div><div class="line">	<span class="keyword">go</span> fb.fizzbuzz()</div><div class="line">	<span class="keyword">go</span> fb.number()</div><div class="line"></div><div class="line">	fb.ch &lt;-<span class="number"> 1</span></div><div class="line"></div><div class="line">	fb.wg.Wait()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) fizz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.ch {</div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			fb.ch &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> {</div><div class="line">				fb.ch &lt;- v</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" fizz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" fizz,"</span>)</div><div class="line">			}</div><div class="line"></div><div class="line">			fb.ch &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		fb.ch &lt;- v</div><div class="line">	}</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) buzz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.ch {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			fb.ch &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">				fb.ch &lt;- v</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" buzz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" buzz,"</span>)</div><div class="line">			}</div><div class="line"></div><div class="line">			fb.ch &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		fb.ch &lt;- v</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) fizzbuzz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.ch {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			fb.ch &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> && v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" fizzbuzz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" fizzbuzz,"</span>)</div><div class="line">			}</div><div class="line"></div><div class="line">			fb.ch &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		fb.ch &lt;- v</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) number() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> fb.ch {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			fb.ch &lt;- v</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> !=<span class="number"> 0</span> && v<span class="number">%3</span> !=<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Printf(<span class="string">" %d。"</span>, v)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Printf(<span class="string">" %d,"</span>, v)</div><div class="line">			}</div><div class="line"></div><div class="line">			fb.ch &lt;- v +<span class="number"> 1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		fb.ch &lt;- v</div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fb := New<span class="number">(15</span>)</div><div class="line">	fb.start()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里有一个知识点： 会不会总是只有一个goroutine把值取出来放回去，取出来放回去，别的goroutine没有机会读取到这个值呢？</p>
<p>不会的，根据channel的实现，waiter还是有先来后到之说的，某个goroutine总是能有机会取到自己要处理的数据。</p>
<h2 id="使用栅栏">使用栅栏</h2>
<p>其实我一直想实现的是使用<a href="https://github.com/marusama/cyclicbarrier" target="_blank" rel="external">cyclicbarrier</a>，可能有些同学不熟悉这个并发原语，但是针对这个场景，使用Barrier代码就非常的简洁，逻辑非常的明了。<br>而且循环栅栏更适合这个场景，因为我们要重复使用栅栏。</p>
<p>针对每一个数字，我们都设置了栅栏，让每一个goroutine都去检查和处理，四个goroutine中总会有一个会处理这个数字。处理完这个数字之后，把数字加一，等待下一次栅栏放行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/marusama/cyclicbarrier"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，要求：</span></div><div class="line"></div><div class="line"><span class="comment">// 	如果这个数字可以被 3 整除，输出 "fizz"。</span></div><div class="line"><span class="comment">// 	如果这个数字可以被 5 整除，输出 "buzz"。</span></div><div class="line"><span class="comment">// 	如果这个数字可以同时被 3 和 5 整除，输出 "fizzbuzz"。</span></div><div class="line"><span class="comment">// 	例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</span></div><div class="line"></div><div class="line"><span class="comment">// 	假设有这么一个结构体：</span></div><div class="line"><span class="comment">// 	type FizzBuzz struct {}</span></div><div class="line"><span class="comment">// 	func (fb *FizzBuzz) fizz() {}</span></div><div class="line"><span class="comment">// 	func (fb *FizzBuzz) buzz() {}</span></div><div class="line"><span class="comment">// 	func (fb *FizzBuzz) fizzbuzz() {}</span></div><div class="line"><span class="comment">// 	func (fb *FizzBuzz) number() {}</span></div><div class="line"></div><div class="line"><span class="comment">// 请你实现一个有四个线程的多协程版 FizzBuzz，同一个 FizzBuzz 对象会被如下四个协程使用：</span></div><div class="line"></div><div class="line"><span class="comment">// 协程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。</span></div><div class="line"><span class="comment">// 协程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。</span></div><div class="line"><span class="comment">// 协程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。</span></div><div class="line"><span class="comment">// 协程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> FizzBuzz <span class="keyword">struct</span> {</div><div class="line">	n <span class="typename">int</span></div><div class="line"></div><div class="line">	barrier cyclicbarrier.CyclicBarrier</div><div class="line">	wg      sync.WaitGroup</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> New(n <span class="typename">int</span>) *FizzBuzz {</div><div class="line">	<span class="keyword">return</span> &FizzBuzz{</div><div class="line">		n:       n,</div><div class="line">		barrier: cyclicbarrier.New<span class="number">(4</span>),</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) start() {</div><div class="line">	fb.wg.Add<span class="number">(4</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> fb.fizz()</div><div class="line">	<span class="keyword">go</span> fb.buzz()</div><div class="line">	<span class="keyword">go</span> fb.fizzbuzz()</div><div class="line">	<span class="keyword">go</span> fb.number()</div><div class="line"></div><div class="line">	fb.wg.Wait()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) fizz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	ctx := context.Background()</div><div class="line">	v :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fb.barrier.Await(ctx)</div><div class="line">		v++</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> {</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" fizz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" fizz,"</span>)</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) buzz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	ctx := context.Background()</div><div class="line"></div><div class="line">	v :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fb.barrier.Await(ctx)</div><div class="line">		v++</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" buzz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" buzz,"</span>)</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) fizzbuzz() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	ctx := context.Background()</div><div class="line">	v :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fb.barrier.Await(ctx)</div><div class="line">		v++</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> ==<span class="number"> 0</span> && v<span class="number">%3</span> ==<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Print(<span class="string">" fizzbuzz。"</span>)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Print(<span class="string">" fizzbuzz,"</span>)</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (fb *FizzBuzz) number() {</div><div class="line">	<span class="keyword">defer</span> fb.wg.Done()</div><div class="line"></div><div class="line">	ctx := context.Background()</div><div class="line">	v :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		fb.barrier.Await(ctx)</div><div class="line">		v++</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v &gt; fb.n {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> v<span class="number">%5</span> !=<span class="number"> 0</span> && v<span class="number">%3</span> !=<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">if</span> v == fb.n {</div><div class="line">				fmt.Printf(<span class="string">" %d。"</span>, v)</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				fmt.Printf(<span class="string">" %d,"</span>, v)</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fb := New<span class="number">(15</span>)</div><div class="line">	fb.start()</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>谢谢 <strong>仁亮</strong> 指出第一版的代码对v的读写是有并发问题的。现在做了修改。</p>
</blockquote>
<h2 id="使用其它并发原语">使用其它并发原语</h2>
<p>我还想到了<code>sync.Cond</code>、<code>Semaphore</code>、<code>WaitGroup</code>等并发原语，<del>简单</del>评估之后，我感觉使用这几个并发原语做任务编排不太合适。</p>
<ul>
<li><code>sync.Cond</code>: 貌似可以，不过实际使用的时候,让这个四个goroutine&quot;自洽&quot;实现Wait/Broadcast并不太容易。使用额外的一个goroutine做Manager貌似还可以</li>
<li><code>Semaphore</code>: 每个goroutine获取一个信号量，相应的goroutine处理完后把数加一，然后再释放信号量貌似可以。但是有可能导致饥饿的情况，总是由一个goroutine请求信号量释放信号量</li>
<li><code>WaitGroup</code>: WaitGroup在这个场景下最大的困难是要重复使用，而重复使用WaitGroup很容易导致panic</li>
</ul>
<p>所以这三个并发原语我尝试之后放弃了。我个人还是比较喜欢Barrier的实现方式，虽然它有一个“惊群”的缺点，但是对于这道题而言问题不大。</p>
<p>你有什么想法和实现，欢迎在原文链接的评论区留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天一位同学给我出了一道并发题，作为在极客时间开了《GO并发编程实战课》的作者，居然一时间没有回答上来，惭愧啊，所以晚上专门研究了一下题目，给出几个实现方案供探讨。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[爱折腾的WaitGroup]]></title>
    <link href="https://colobu.com/2022/08/30/waitgroup-to-love-to-toss/"/>
    <id>https://colobu.com/2022/08/30/waitgroup-to-love-to-toss/</id>
    <published>2022-08-30T11:18:53.000Z</published>
    <updated>2022-08-31T01:19:57.245Z</updated>
    <content type="html"><![CDATA[<p><a href="https://pkg.go.dev/sync#WaitGroup" target="_blank" rel="external">WaitGroup</a>是Go并发编程中经常使用的做任务编排的一个一个并发原语。看起来它只有几个简单的方法，使用起来比较简单。实际上，WaitGroup的内部实现也陆陆续续改变了好几次,主要是针对它的字段的原子操作不断的做优化。</p>
<a id="more"></a>
<h2 id="WaitGroup原始的实现">WaitGroup原始的实现</h2>
<p>最早的<code>WaitGroup</code>的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	m       Mutex</div><div class="line">	counter <span class="typename">int32</span></div><div class="line">	waiters <span class="typename">int32</span></div><div class="line">	sema    *<span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (wg *WaitGroup) Add(delta <span class="typename">int</span>) {</div><div class="line">	v := atomic.AddInt32(&wg.counter, <span class="typename">int32</span>(delta))</div><div class="line">	<span class="keyword">if</span> v &lt;<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup count"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> v &gt;<span class="number"> 0</span> || atomic.LoadInt32(&wg.waiters) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	wg.m.Lock()</div><div class="line">	<span class="keyword">for</span> i := <span class="typename">int32</span><span class="number">(0</span>); i &lt; wg.waiters; i++ {</div><div class="line">		runtime_Semrelease(wg.sema)</div><div class="line">	}</div><div class="line">	wg.waiters =<span class="number"> 0</span></div><div class="line">	wg.sema = <span class="constant">nil</span></div><div class="line">	wg.m.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的实现字段的意义比较明确，但是实现还略显粗糙，比如sema采用指针实现。</p>
<p>之后将字段<code>counter</code>和<code>waiters</code>合并。为了要保证64bit的原子操作8位对齐， 需要找到state1的对齐点。 sema去掉了指针实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></div><div class="line">	<span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></div><div class="line">	<span class="comment">// the aligned 8 bytes in them as state.</span></div><div class="line">	state1 <span class="number">[12</span>]<span class="typename">byte</span></div><div class="line">	sema   <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (wg *WaitGroup) state() *<span class="typename">uint64</span> {</div><div class="line">	<span class="keyword">if</span> <span class="typename">uintptr</span>(unsafe.Pointer(&wg.state1))<span class="number">%8</span> ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&wg.state1))</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&wg.state1<span class="number">[4</span>]))</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>后来，<code>WaitGroup</code>实现如下，并稳定下来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></div><div class="line">	<span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></div><div class="line">	<span class="comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span></div><div class="line">	<span class="comment">// for the sema.</span></div><div class="line">	state1 <span class="number">[3</span>]<span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// state returns pointers to the state and sema fields stored within wg.state1.</span></div><div class="line"><span class="keyword">func</span> (wg *WaitGroup) state() (statep *<span class="typename">uint64</span>, semap *<span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">if</span> <span class="typename">uintptr</span>(unsafe.Pointer(&wg.state1))<span class="number">%8</span> ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&wg.state1)), &wg.state1<span class="number">[2</span>]</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&wg.state1<span class="number">[1</span>])), &wg.state1<span class="number">[0</span>]</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>state1 和 sema字段合并成一个字段<code>state1</code>， 这个数组是uint32,四字节。所以要么是第一个元素就是8byte对齐的，要么就是第二个元素是8byte对齐的。找到对齐的8byte,剩余的4byte就作为sema。</p>
<p>这个实现没有问题，就是有些饶人。因为你不得不检查state1的对齐，才能确定哪个是counter和waiters,哪个是sema。</p>
<blockquote>
<p>问个问题： WaitGroup的waiter数最多是多大？</p>
</blockquote>
<h2 id="Go_1-18的改变">Go 1.18的改变</h2>
<p>在Go 1.18中， WaitGroup又做了改变，针对64bit架构的环境，编译器保证伟uint64类型的字段按照8byte对齐。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></div><div class="line">	<span class="comment">// compilers only guarantee that 64-bit fields are 32-bit aligned.</span></div><div class="line">	<span class="comment">// For this reason on 32 bit architectures we need to check in state()</span></div><div class="line">	<span class="comment">// if state1 is aligned or not, and dynamically "swap" the field order if</span></div><div class="line">	<span class="comment">// needed.</span></div><div class="line">	state1 <span class="typename">uint64</span></div><div class="line">	state2 <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然为了兼容32bit的架构，还是需要判断一下对齐:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (wg *WaitGroup) state() (statep *<span class="typename">uint64</span>, semap *<span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">if</span> unsafe.Alignof(wg.state1) ==<span class="number"> 8</span> || <span class="typename">uintptr</span>(unsafe.Pointer(&wg.state1))<span class="number">%8</span> ==<span class="number"> 0</span> {</div><div class="line">		<span class="comment">// state1 is 64-bit aligned: nothing to do.</span></div><div class="line">		<span class="keyword">return</span> &wg.state1, &wg.state2</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="comment">// state1 is 32-bit aligned but not 64-bit aligned: this means that</span></div><div class="line">		<span class="comment">// (&state1)+4 is 64-bit aligned.</span></div><div class="line">		state := (*<span class="number">[3</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&wg.state1))</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&state<span class="number">[1</span>])), &state<span class="number">[0</span>]</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>总体上来说，在linux/amd64环境中，此修改会带来 9%~30%的性能提升。</p>
<h2 id="Go_1-20中的改变">Go 1.20中的改变</h2>
<p>优化还未万。在Go 1.19中， Russ Cox实现了atomic.Uint64,它在64bit架构和32bit架构下都是8byte对齐的,为啥呢？因为它有一个&quot;尚方宝剑&quot;:<code>align64</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// An Uint64 is an atomic uint64. The zero value is zero.</span></div><div class="line"><span class="keyword">type</span> Uint64 <span class="keyword">struct</span> {</div><div class="line">	_ noCopy</div><div class="line">	_ align64</div><div class="line">	v <span class="typename">uint64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>64bit架构下没有问题，32bit架构下看到这个字段，Go编译器就会自动把它按照8byte对齐，这是一个约定。你在你的package下定义struct加上<code>align64</code>是没有用的。<br>不过如果你也想让你的struct 8byte对齐的话,你可以使用下面的技术:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"sync/atomic"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> {</div><div class="line">    _ <span class="number">[0</span>]atomic.Int64 <span class="comment">// 占用0字节，但是隐含字段是8byte对齐的</span></div><div class="line">    x <span class="typename">uint64</span> <span class="comment">// x是8byte对齐的</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样依赖， WaitGroup的实现又可以简化成了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	state atomic.Uint64 <span class="comment">// high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	sema  <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也不必实现单独的<code>state()</code>方法了。直接使用state字段即可(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (wg *WaitGroup) Add(delta <span class="typename">int</span>) {</div><div class="line">	state := wg.state.Add(<span class="typename">uint64</span>(delta) &lt;&lt;<span class="number"> 32</span>)</div><div class="line">	v := <span class="typename">int32</span>(state &gt;&gt;<span class="number"> 32</span>)</div><div class="line">	w := <span class="typename">uint32</span>(state)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> v &lt;<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sync: negative WaitGroup counter"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> w !=<span class="number"> 0</span> && delta &gt;<span class="number"> 0</span> && v == <span class="typename">int32</span>(delta) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> v &gt;<span class="number"> 0</span> || w ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	<span class="comment">// This goroutine has set counter to 0 when waiters &gt; 0.</span></div><div class="line">	<span class="comment">// Now there can't be concurrent mutations of state:</span></div><div class="line">	<span class="comment">// - Adds must not happen concurrently with Wait,</span></div><div class="line">	<span class="comment">// - Wait does not increment waiters if it sees counter == 0.</span></div><div class="line">	<span class="comment">// Still do a cheap sanity check to detect WaitGroup misuse.</span></div><div class="line">	<span class="keyword">if</span> wg.state.Load() != state {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sync: WaitGroup misuse: Add called concurrently with Wait"</span>)</div><div class="line">	}</div><div class="line">	<span class="comment">// Reset waiters count to 0.</span></div><div class="line">	wg.state.Store<span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> ; w !=<span class="number"> 0</span>; w-- {</div><div class="line">		runtime_Semrelease(&wg.sema, <span class="constant">false</span>,<span class="number"> 0</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://pkg.go.dev/sync#WaitGroup" target="_blank" rel="external">WaitGroup</a>是Go并发编程中经常使用的做任务编排的一个一个并发原语。看起来它只有几个简单的方法，使用起来比较简单。实际上，WaitGroup的内部实现也陆陆续续改变了好几次,主要是针对它的字段的原子操作不断的做优化。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最近对rpcx做的一些优化以及一些优化尝试]]></title>
    <link href="https://colobu.com/2022/08/25/some-small-optimizations-of-rpcx/"/>
    <id>https://colobu.com/2022/08/25/some-small-optimizations-of-rpcx/</id>
    <published>2022-08-25T14:29:07.000Z</published>
    <updated>2022-08-30T08:16:32.794Z</updated>
    <content type="html"><![CDATA[<p>最近在做<a href="https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/" target="_blank" rel="external">2022 Go生态圈 rpc 框架 Benchmark</a>之前，专门花了一星期时间，对rpcx进行了重点的优化，这篇文章专门记录一下几个重要的优化点，供大家参考。</p>
<a id="more"></a>
<h2 id="增加handler方式，避免服务端使用reflect">增加handler方式，避免服务端使用reflect</h2>
<p>在之前的rpcx实现中，参考的是标准库rpc的注册方式，一个服务的注册如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpcxserver.RegisterName(<span class="string">"Hello"</span>, <span class="built_in">new</span>(Hello), <span class="string">""</span>)</div></pre></td></tr></table></figure>

<p>它实际是通过反射的方式遍历这个<code>rcvr</code>,找到它的服务方法和参数类型，并缓存下来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *Server) register(rcvr <span class="keyword">interface</span>{}, name <span class="typename">string</span>) (<span class="typename">string</span>, error) {</div><div class="line">	s.serviceMapMu.Lock()</div><div class="line">	<span class="keyword">defer</span> s.serviceMapMu.Unlock()</div><div class="line"></div><div class="line">	service := <span class="built_in">new</span>(service)</div><div class="line">	service.typ = reflect.TypeOf(rcvr)</div><div class="line">	service.rcvr = reflect.ValueOf(rcvr)</div><div class="line">	sname := reflect.Indirect(service.rcvr).Type().Name() <span class="comment">// Type</span></div><div class="line">	service.name = sname</div><div class="line"></div><div class="line">	<span class="comment">// Install the methods</span></div><div class="line">	service.method = suitableMethods(service.typ, <span class="constant">true</span>)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(service.method) ==<span class="number"> 0</span> {</div><div class="line">		......</div><div class="line">	}</div><div class="line">	s.serviceMap[service.name] = service</div><div class="line">	<span class="keyword">return</span> sname, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后在处理请求的时候，根据调用的服务和方法，找到相应的类型，对请求类型和返回类型利用reflect产生相应的值，再利用reflect的function.Call执行方法调用，虽然中间使用了池化的技术，但是内部还是大量使用的反射的功能，性能损失不少。</p>
<p>Go标准库http router的实现给我了灵感，而<a href="https://github.com/lesismal/arpc" target="_blank" rel="external">lesismal/arpc</a>的应用和性能优异的表现，促使我决定在rpcx增加一个更有效的服务处理方式,类型配置http handler一样的方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> hello(ctx *server.Context) error {</div><div class="line">	msg := &proto.BenchmarkMessage{}</div><div class="line"></div><div class="line">	err := ctx.Bind(msg)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	}</div><div class="line"></div><div class="line">	msg.Field1 = <span class="string">"OK"</span></div><div class="line">	msg.Field2 =<span class="number"> 100</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> *delay &gt;<span class="number"> 0</span> {</div><div class="line">		time.Sleep(*delay)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		runtime.Gosched()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ctx.Write(msg)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	host  = flag.String(<span class="string">"s"</span>, <span class="string">"127.0.0.1:8972"</span>, <span class="string">"listened ip and port"</span>)</div><div class="line">	delay = flag.Duration(<span class="string">"delay"</span>,<span class="number"> 0</span>, <span class="string">"delay to mock business processing by sleep"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	rpcxserver := server.NewServer()</div><div class="line"></div><div class="line">	rpcxserver.AddHandler(<span class="string">"Hello"</span>, <span class="string">"Say"</span>, hello)</div><div class="line">	rpcxserver.Serve(<span class="string">"tcp"</span>, *host)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>服务方法签名如<code>func Xxx(ctx *server.Context) error</code>,它会传入一个特制的Context,通过这个Context,能获得请求参数，也可以写回response。</p>
<p>通过<code>ctx.Bind</code>解码出请求参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   msg := &proto.BenchmarkMessage{}</div><div class="line"></div><div class="line">err := ctx.Bind(msg)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<code>ctx.Write(msg)</code>把response写回。</p>
<p>这里不会用到反射。如果你的编解码器使用的不是反射的方式的话,会更高效。</p>
<h2 id="使用goroutine_pool">使用goroutine pool</h2>
<p>rpcx默认采用每个request至少一个goroutine处理方式。这样如果在高并发的情况下，服务端会有非常巨大的goroutine存在，虽然说Go支持上万的goroutine,但是在goroutine非常多的情况下，(内存)资源占用非常多，对Go的调度和垃圾回收也会有一定的影响，所以在高并发的场景下，采用goroutine 池在一定程度上会提升性能。</p>
<p>说起线程池，网上已经有不下十个goroutine pool （或者叫做worker pool）的实现。rpcx使用的是<a href="https://github.com/alitto/pond" target="_blank" rel="external">alitto/pond</a>, 并没有太多的性能的考虑，而是从使用方便性方面去考虑。</p>
<p>如果想使用goroutine池，你可以使用<code>server.WithPool(100, 1000000)</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpcxserver := server.NewServer(server.WithPool<span class="number">(100</span>,<span class="number"> 1000000</span>))</div></pre></td></tr></table></figure>

<p>其中第一个参数是goroutine(worker)的数量，第二个参数capacity是最大的待处理的请求。超过capacity，新的请求就会被阻塞。</p>
<p>解析后的请求会被提交的goroutine pool中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> s.pool != <span class="constant">nil</span> {</div><div class="line">	s.pool.Submit(<span class="keyword">func</span>() {</div><div class="line">		s.processOneRequest(ctx, req, conn, writeCh)</div><div class="line">	})</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	<span class="keyword">go</span> s.processOneRequest(ctx, req, conn, writeCh)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="调整进程优先级">调整进程优先级</h3>
<p>有时候，你的程序可能会和其它程序混跑，即使没有其它的业务程序，也可能有系统自带的一些应用，如果我们把rpcx程序的优先级设置的高一些，使它有更多的可能被Linux系统程序调度，也会带来更多的优先级。</p>
<p>Linux每个进程都有一个介于 -20 到 19 之间的 nice 值， 值越低会有更多的机会获得Linux的调度。默认情况下，进程的 nice 值为 0。</p>
<p>进程的 nice 值，可以通过 nice 命令和 renice 命令修改，进而调整进程的运行顺序。</p>
<p><code>nice [-n NI值] 程序</code> 按照指定的优先级启动程序。</p>
<p>renice 命令可以在进程运行时修改其 NI 值，从而调整优先级。<code>renice [优先级] PID</code>。</p>
<p>当然你也可以通过程序动态的设置进程的优先级：<code>syscall.Setpriority(syscall.PRIO_PROCESS, 0, -20)</code>，这条命令设置本进程的优先级为<code>-20</code>。</p>
<p>这个带来10% ~ 20%性能的提升。</p>
<p>我还想尝试只设置<code>listener.Accept</code>的goroutine,让有更多的机会获得处理的机会。不过没有可调用的系统调用去设置。尝试了<code>runtime.LockOSThread()</code>让<code>listener.Accept</code>锁定一个线程去去处理，没啥鸟用。</p>
<h3 id="进一步优化想法">进一步优化想法</h3>
<p>当然，还有一些优化的方法，不过还没有验证。</p>
<p>比如redis，采用单线程(主逻辑)的方式处理请求、还有比如nginx，采用多个worker独立的去处理连接。这样可以减少并发锁的请求。<br>rpcx可以改成单worker的方式，然后启动多个worker去监听和处理请求，可能也会提升性能。不过这个没有进一步的测试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做<a href="https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/" target="_blank" rel="external">2022 Go生态圈 rpc 框架 Benchmark</a>之前，专门花了一星期时间，对rpcx进行了重点的优化，这篇文章专门记录一下几个重要的优化点，供大家参考。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2022 Go生态圈 rpc 框架 Benchmark]]></title>
    <link href="https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/"/>
    <id>https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/</id>
    <published>2022-07-31T07:49:55.000Z</published>
    <updated>2022-08-25T14:24:21.356Z</updated>
    <content type="html"><![CDATA[<p>距离上一次<a href="https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/" target="_blank" rel="external">2021年Go生态圈rpc框架benchmark</a>的测试整整一年了。一年来，各个RPC框架也获得长足的进展，<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>也在众多网友的支持下做了一些有益的优化和精简，所以是时候再做一次国内几个常用框架的性能比较了。</p>
<a id="more"></a>
<p>每次性能结果的发布，必然引来众多的人的注目，也引来更多的争议。这是很正常的。一个benchmark不代表评价一个框架的优劣，一个benchmakr测试也不足以代表测试所有的应用场景。在不同的业务形态下、巨大的连接数差别、消息的格式不同、消息大小的不同、部署环境的不同都可能导致某些场景下某个框架的结果比较好，某个框架的结果比较差。我们将讨论和焦点放在还有哪些可以性能提升的点上即可。某个框架的优化点或许能够其它框架带来一些优化的提示。</p>
<p>另外，在实际使用微服务框架的时候，<strong>大部分的性能瓶颈在于业务代码</strong>，而不是框架本身，所以重点优化业务代码也非常的重要。</p>
<p>本文测试的不同框架底层传输的协议是不同，比如grpc是通过HTTP2.0，kitex支持TTHeader、HTTP2等协议，arpc使用自研的协议，rpcx使用自研的协议,标准库rpc使用自研的协议。</p>
<p>测试的消息体编解码采用统一的protobuf。</p>
<p><strong>YangruiEmma 指出<a href="https://github.com/rpcxio/rpcx-benchmark/issues/13" target="_blank" rel="external">测试公平性的修正建议</a>, kitex采用的protobuf生成是官方的方式，但是其它几个框架采用的是<a href="https://github.com/gogo/protobuf" target="_blank" rel="external">gogo/protobuf</a>，性能上会有所不同。这是一个问题，因为kitex创建pb代码的时候配合使用的是官方的pb库。不过字节的同学说采用自研的protobuf库，会更快</strong></p>
<p>本测试并未记录CPU和内存的消耗。这是一个缺陷。 因为CPU和内存会一直变化，没太想好如何科学的记录测试时的CPU和内存使用值。</p>
<p>本次测试针对五种常见的rpc框架进行了测试:</p>
<ul>
<li><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>, 最早的Go生态圈微服务框架之一，被新浪、好未来等公司使用</li>
<li><a href="https://github.com/cloudwego/kitex" target="_blank" rel="external">kitex</a>, 字节跳动出品的微服务框架</li>
<li><a href="https://github.com/lesismal/arpc" target="_blank" rel="external">arpc</a>: 一个性能优异的rpc框架 by lesismal</li>
<li><a href="https://grpc.io/" target="_blank" rel="external">grpc</a>: Google发起的一个开源rpc框架，支持跨语言，使用广泛。该系统基于HTTP/2 协议传输，使用Protocol Buffers 作为接口描述语言。</li>
<li><a href="https://pkg.go.dev/net/rpc" target="_blank" rel="external">标准库的rpc/std_rpc</a>: Go标准库自带的rpc框架，目前处于维护状态</li>
</ul>
<p>测试采用了各框架的最新版本:</p>
<ul>
<li><strong>rpcx</strong>: v1.7.8</li>
<li><strong>kitex</strong>: v0.3.4</li>
<li><strong>arpc</strong>: v1.2.9</li>
<li><strong>grpc</strong>: v1.48.0</li>
<li><strong>std_rpc</strong>: v1.8.4</li>
</ul>
<p>为了尽量保持一致性的测试，所有的测试都是在相同的测试环境下，相同的测试逻辑，相同的测试消息进行的:</p>
<ul>
<li>测试环境(已经服役6年的老机器,两台，一台做server,一台做client)<ul>
<li>CPU型号: Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz / 2颗</li>
<li>物理核: 6个; 逻辑核: 12核</li>
<li>内存: 64G</li>
<li>开启网卡多队列</li>
</ul>
</li>
<li>都采用protobuf作为消息体的编码方式，编码后的消息体大小为581个字节</li>
<li>在客户端统计，统计吞吐量(throughputs)和延迟(lantency, 包括最大值，平均值，中位数值，和p99.9的值， 最小值都小于1毫秒，所以未统计)<ul>
<li>对于延迟，我们还需要关注它的长尾情况，所以需要关注中位数和p99.9。p99.9指千分之999的请求的延迟都小于某个时间。</li>
</ul>
</li>
</ul>
<p>主要分为三个场景进行测试。</p>
<ul>
<li>TCP连接数为10, 长连接。并发数为100、200、500、1000、2000、5000的情况<br>主要测试高并发的情况下各框架最大的能力，包括吞吐量和延迟。</li>
<li>TCP连接数为10,并发数为200,长连接。 吞吐量为10万/秒、15万/秒、18万/秒的情况下的延迟<br>主要测在吞吐保持一致的情况下，各个框架的延迟情况和长尾情况。延迟或长尾太大意味着使用这个吞吐率是不合适。</li>
<li>TCP连接数为1000，并发数为1000，长连接。<br>主要测试大连接数比较高的情况下各框架的性能。主要是想针对字节的kitex这种自研的netpoll,看看是否更适合这种大量连接数的情况。</li>
</ul>
<p>这里并发数是指客户端启动的goroutine数量，多个goroutine可能共享同一个client(连接)。</p>
<p>所有的各框架的测试代码都放在了<a href="https://github.com/rpcxio/rpcx-benchmark" target="_blank" rel="external">rpcx-benchmark</a>。测试的命令非常简单，如下面的介绍中所示，所以你可以下载下来自己测试验证，也欢迎提供优化补丁，补充更多的rpc框架等等。</p>
<h2 id="场景一：_TCP连接数为10,_长连接。并发数为100、200、500、1000、2000、5000的情况">场景一： TCP连接数为10, 长连接。并发数为100、200、500、1000、2000、5000的情况</h2>
<ul>
<li>服务端启动: <code>./server -s xxx.xxx.xxx.xxx:8972</code> // xxx.xxx.xxx.xxx是服务端监听的IP地址</li>
<li>客户端测试: <code>./client -c 2000 -n 1000000 -s xxx.xxx.xxx.xxx:8972</code> // 这里的并发数是2000, 测试总共发送1百万个请求</li>
</ul>
<p>测试原始数据: </p>
<iframe width="700" height="300" frameborder="0" scrolling="no" src="https://onedrive.live.com/embed?resid=CD09EE1AE0AE8966%211237&authkey=%21ALkUD_tZUvdczJ8&em=2&wdAllowInteractivity=False&wdDownloadButton=True&wdInConfigurator=True&wdInConfigurator=True&edesNext=false&ejss=false"></iframe>


<h3 id="吞吐量">吞吐量</h3>
<p><img src="1.png" alt=""><br>Y轴是吞吐量/秒，越高越好。可以看到arpc框架吞吐非常的好，去年的测试也是arpc表现比较好，其次是rpcx、标准的rpc、kitex、grpc。</p>
<p>可以看到在并发量比较大的情况下，除了grpc， 其它都能达到18万个请求/秒的吞吐量。</p>
<h3 id="平均延迟">平均延迟</h3>
<p><img src="2.png" alt=""><br>Y轴是平均延迟，越低越好，可以看到grpc的延迟较高。延迟正好和上面的吞吐量相反。</p>
<h3 id="P99-9_延迟">P99.9 延迟</h3>
<p>另外一个我们可能比较关注长尾的情况，可以选取中位数或者p99.9观察。 下面是p99.9的情况。<br><img src="3.png" alt=""></p>
<p>当然，并发数为5000的情况下比较是无意义的，因为在并发数为5000的情况下，各框架的吞吐量是不一样的，在吞吐量高的情况下延迟也会大。<br>所以为了在公平的情况下观察长尾情况，我设计了下面的测试。</p>
<h2 id="场景二:_TCP连接数为10,并发数为200,长连接。_吞吐量为10万/秒、15万/秒、18万/秒的情况下的延迟">场景二: TCP连接数为10,并发数为200,长连接。 吞吐量为10万/秒、15万/秒、18万/秒的情况下的延迟</h2>
<p>为了观察延迟，我们需要保证吞吐量都尽量一样，在相同的吞吐量情况下观察延迟和长尾情况更科学。</p>
<p>所以场景二就是在并发数为200的情况下，针对吞吐量为10万/秒、15万/秒、18万/秒三个场景，观察框架的延迟和P99.9延迟。</p>
<p>测试原始数据: </p>
<iframe width="700" height="346" frameborder="0" scrolling="no" src="https://onedrive.live.com/embed?resid=CD09EE1AE0AE8966%211240&authkey=%21AH7IxJNptuzNIRI&em=2&wdAllowInteractivity=False&wdDownloadButton=True&wdInConfigurator=True&wdInConfigurator=True&edesNext=false&ejss=false"></iframe>

<h3 id="平均延迟-1">平均延迟</h3>
<p><img src="4.png" alt=""><br>平均延迟看起来grpc比较高，因为它达不到18万/秒的吞吐，所以它的最后一个数值是没有的。kitex相对较高，这个还得具体看是不是kitex有一些具体的调优。 基本上是和吞吐量成负相关的。</p>
<h3 id="P99-9_延迟-1">P99.9 延迟</h3>
<p>长尾的情况，下面是p99.9的情况。<br><img src="5.png" alt=""></p>
<p>arpc、rpcx和标准rpc的P99.9延迟还是比较好的。</p>
<h2 id="场景三:_TCP连接数为1000，并发数为1000，长连接。">场景三: TCP连接数为1000，并发数为1000，长连接。</h2>
<p>观察在大量连接情况下各框架的表现(吞吐率和延迟)。这个场景并没有选择巨量的连接数，而是选择了一个较常见的1000的连接数做测试，连接为长连接。</p>
<p><img src="6.png" alt=""></p>
<p>arpc在连接数比较多的情况下明显要好于其它框架，其次就是rpcx和标准rpc框架。</p>
<p>平均耗时和P99.9耗时也符合这个情况，具体原始数据参考</p>
<iframe width="700" height="346" frameborder="0" scrolling="no" src="https://onedrive.live.com/embed?resid=CD09EE1AE0AE8966%211242&authkey=%21ADlRyez3xISIKx4&em=2&wdAllowInteractivity=False&wdDownloadButton=True&wdInConfigurator=True&wdInConfigurator=True&edesNext=false&ejss=false"></iframe>


<p>总体来看，rpcx的性能还是不错的，希望在以后的日子，参考兄弟rpc框架，做进一步的优化。<br>欢迎在<a href="https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/" target="_blank" rel="external">本文留言区</a>进行探讨。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>距离上一次<a href="https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/" target="_blank" rel="external">2021年Go生态圈rpc框架benchmark</a>的测试整整一年了。一年来，各个RPC框架也获得长足的进展，<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>也在众多网友的支持下做了一些有益的优化和精简，所以是时候再做一次国内几个常用框架的性能比较了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 垃圾回收器指南]]></title>
    <link href="https://colobu.com/2022/07/16/A-Guide-to-the-Go-Garbage-Collector/"/>
    <id>https://colobu.com/2022/07/16/A-Guide-to-the-Go-Garbage-Collector/</id>
    <published>2022-07-16T06:37:59.000Z</published>
    <updated>2022-07-25T12:19:30.941Z</updated>
    <content type="html"><![CDATA[<p>Go官方原文: <a href="https://tip.golang.org/doc/gc-guide?continueFlag=bf311ba190bf0d160b5d3461e092f0f4" target="_blank" rel="external">A Guide to the Go Garbage Collector</a></p>
<a id="more"></a>
<h2 id="简介">简介</h2>
<p>本指南旨在帮助高级Go语言用户更好地了解Go语言垃圾回收器的使用成本。 它还提供了Go用户如何利用这些知识来提高应用程序的资源利用率的指导。 它并不假设你了解垃圾回收，但假设你熟悉Go语言。</p>
<p>Go语言负责安排Go语言值的存储。在大多数情况下，Go语言开发人员根本不需要关心这些值存储在哪里，或者为什么要存储。 然而，在实践中，这些值通常需要存储在计算机<strong>物理内存</strong>中，而物理内存是有限的资源。 因为内存是有限的，所以必须小心地管理和回收内存，以避免在执行Go语言程序时耗尽内存。 Go语言的工作就是根据需要分配和回收内存。</p>
<p>自动回收内存的另一个说法是<strong>垃圾回收</strong>。 从较高的层次上讲，垃圾回收器（或简称为GC）是一个系统，这个系统通过标识内存的哪些部分不再需要来代表应用程序回收内存。 Go语言的标准工具链提供了一个运行时库，它随每个应用程序一起提供，并且这个运行时库包含了一个垃圾回收器。</p>
<p>请注意，Go语言规范并不能保证本指南所描述的垃圾回收器的存在，只不过Go语言本身负责管理Go语言值的底层存储。 这一省略是有意的，并允许使用完全不同的内存管理技术。</p>
<p>因此，本指南是关于Go语言的一个具体实现的指导，可能不适用于其他实现。 具体来说，本指南适用于标准工具链（gc Go compiler和工具）。 Gccgo和Gollvm都使用非常相似的GC实现，因此许多相同的概念都适用，但细节可能会有所不同。</p>
<p>此外，这是一个一直在修正的文档，随着时间的推移而变化，以最好地反映Go语言的最新版本。 本文档目前描述的是Go语言1.19中的垃圾回收器。</p>
<h3 id="价值所在">价值所在</h3>
<p>在深入研究GC之前，让我们首先讨论一下不需要由GC管理的内存。</p>
<p>例如，存储在局部变量中的非指针Go语言的值可能根本不会被Go语言的GC管理，Go语言会安排内存的分配，并将其绑定到创建它的<a href="https://go.dev/ref/spec#Declarations_and_scope" target="_blank" rel="external">词法作用域</a>中。 一般来说，这比依赖GC更有效率，因为Go语言编译器能够预先确定何时释放内存，并发出清理内存的机器指令。 通常，我们把这种为Go语言的值分配内存的方式称为“<strong>栈分配</strong>”，因为空间存储在goroutine栈中。</p>
<p>如果Go语言的值不能以这种方式分配内存，则Go语言编译器无法确定它的生存期，那么这些值就被称为“<strong>逃逸到堆</strong>”。 “堆”可以被认为是内存分配的一个大杂烩，Go语言的值需要被放置在堆的某个地方。 在堆上分配内存的操作通常称为“动态内存分配”，因为编译器和运行库都很少会对如何使用内存以及何时可以清理内存做出假设。 这就是GC的用武之地：它是一个专门标识和清理动态内存分配的系统。</p>
<p>Go语言的值需要逃逸到堆中的原因有很多。 一个原因可能是其大小是动态确定的。 例如，考虑一个切片的支持数组，它的初始大小由一个变量而不是一个常量确定。 请注意，逃逸到堆也必须是可传递的：如果一个Go值的引用被写入到另一个已经被确定为逃逸的Go值中，那么这个值也必须逃逸。</p>
<p>Go语言的值是否逃逸取决于使用它的上下文和Go语言编译器的逃逸分析算法。 当价值观逃逸时，试图准确地列举它将是脆弱和困难的：算法本身相当复杂，并且在不同的Go语言版本中会有所变化。 有关如何识别哪些值逃逸而哪些值不逃逸的详细信息，请参阅<a href="https://tip.golang.org/doc/gc-guide#Eliminating_heap_allocations" target="_blank" rel="external">消除堆分配</a>一节。</p>
<h3 id="跟踪垃圾回收">跟踪垃圾回收</h3>
<p>垃圾回收可能指自动回收内存的众多实现方法，例如引用计数。 在本文档的上下文中，垃圾回收指的是跟踪垃圾回收，其通过循着指针来标识正在使用的、所谓的活动对象。</p>
<p>让我们更严格地定义这些术语:</p>
<ul>
<li><strong>对象</strong> - 对象是一个动态分配的内存块，包含一个或多个Go值。</li>
<li><strong>指针</strong> - 指向对象内任何值的内存地址。 这自然包括 <code>*T</code> 形式的Go语言值，但也包括部分内置Go语言值。 字符串、切片、通道、map和接口值都包含GC必须跟踪的内存地址。</li>
</ul>
<p>对象和指向其他对象的指针一起形成<strong>对象图</strong>。 为了识别活动内存，GC从程序的<strong>根</strong>开始遍历对象图，程序明确使用的对象的指针。 根的两个例子是局部变量和全局变量。 遍历对象图的过程被称为<strong>扫描</strong>。</p>
<p>此基本算法对所有跟踪GC通用。 跟踪GC的不同之处在于，一旦它们发现内存是活的，它们会做什么。 Go语言的GC使用了<strong>标记(mark)</strong>—<strong>清除(sweep)</strong>技术，这意味着为了跟踪它的过程，GC也会将它遇到的值<strong>标记</strong>为活动的。 跟踪完成后，GC将遍历堆中的所有内存，并使所有未标记的对象的内存设置为可用于分配的内存。 此过程称为<strong>扫描(scanning)</strong>。</p>
<p>您可能熟悉的另一种技术是将对象实际移动到内存的新部分，并留下一个转发指针，以后将使用该指针更新应用程序的所有指针。 我们称以这种方式移动对象的GC为<strong>移动GC</strong>; Go的GC不是这样子的，它是<strong>非移动GC</strong>。</p>
<h2 id="GC循环">GC循环</h2>
<p>由于Go GC是一个标记—清除GC，因此它大致分为两个阶段：<strong>标记阶段</strong>和<strong>清扫阶段</strong>。 虽然这句话似乎是重复的，但它包含了一个重要的见解：在跟踪完所有内存之前，不可能释放内存以供分配，因为可能仍有未扫描的指针使对象保持活动状态。 因此，清扫动作必须与标记动作完全分开。 此外，当没有与GC相关的工作要做时，GC也可能根本不活动。 GC在离开(off)、标记和扫描这三种状态之间不断循环，这就是所谓的GC循环。</p>
<p>接下来的几个章节我们将集中讨论如何直观地了解GC的成本，以帮助用户调整GC参数，从而为自己谋福利。</p>
<h2 id="了解成本">了解成本</h2>
<p>GC本质上是一个构建在更复杂系统上的复杂软件。 当试图理解GC并调整其行为时，很容易陷入细节的泥潭。 本节旨在提供一个框架，用于说明Go GC的开销和调优参数。</p>
<p>开始讨论前，先了解基于四个简单公理的GC成本模型。</p>
<ol>
<li>在GC执行时，应用程序会暂停。</li>
<li>GC只涉及两种资源：CPU时间和物理内存。</li>
<li>GC的内存开销包括活动堆内存、标记阶段之前分配的新堆内存，以及元数据空间（即使与前两个的开销成比例，但相比之下元数据空间开销也很小）。<blockquote>
<p>注意：活动堆内存是由上一个GC周期确定为活动的内存，而新堆内存是在当前周期中分配的任何内存，在结束时可能是活动的，也可能不是活动的。</p>
</blockquote>
</li>
<li>GC的CPU成本被建模为每个周期的固定成本，以及与活动堆的大小成比例的边际成本(marginal cost)。<blockquote>
<p>注意：从渐进的角度来说，清扫的伸缩性比标记和扫描要差，因为它必须执行与整个堆的大小成比例的工作，包括被确定为非活动（即“死”）的内存。 然而，在当前的实现中，清扫操作比标记和扫描快得多，因此在本讨论中可以忽略其相关成本。</p>
</blockquote>
</li>
</ol>
<p>这种模型简单而有效：它准确地对GC的主要成本进行了分类。 然而，这个模型没有说明这些成本的规模，也没有说明它们是如何相互作用的。 为了对此建模，考虑以下情况，我们称这种场景为<strong>稳态</strong>(steady-stat)。</p>
<ul>
<li><p>应用程序分配新内存的速率（以字节/秒为单位）是恒定的。</p>
<blockquote>
<p>注意：重要的是要理解这个分配率与这个新内存是否是活动的完全无关。 没有一个是活的，所有的都是活的，或者一部分是活的都有可能。 (除此之外，一些旧的堆内存也可能死亡，因此，如果该内存是活动的，活动堆大小不一定会增长。）<br>更具体地说，假设有一个web服务为它处理的每个请求分配2 MiB的总堆内存。 在请求过程中，2 MiB中最多有512 KiB在请求进行期间保持活动状态，当服务完成对请求的处理时，所有这些内存都会死亡。 稳定的请求流（比如每秒100个请求）会产生200 MiB/s的分配率和50 MiB的峰值活动堆。</p>
</blockquote>
</li>
<li><p>应用程序的对象图每次看起来都大致相同（对象的大小相似，指针的数量大致恒定，图的最大深度大致恒定）。<br>另一种思考方式是GC的边际成本是恒定的。</p>
</li>
</ul>
<blockquote>
<p>注意：稳态可能看起来是人为的，但它的确代表了应用程序在某个恒定工作负载下的行为。 当然，在应用程序执行时，工作负载也可能发生变化，但通常应用程序行为看起来总体上像是一串稳定状态，中间穿插着一些瞬态行为。</p>
</blockquote>
<blockquote>
<p>注意：稳定状态对活动堆没有任何假设。 它可能会随着每个后续GC周期而增长，可能会缩小，也可能会保持不变。 然而，试图在下面的解释中包含所有这些情况很无聊乏味，而且不是很有说明性，所以本指南将重点放在活动堆保持不变的示例上。 GOGC一节会更详细地探讨了非常量活动堆的场景。</p>
</blockquote>
<p>在活动堆大小不变的稳定状态下，只要GC在经过相同的时间后执行，每个GC周期在成本模型中看起来都是相同的。 这是因为在固定的时间内，如果应用程序的分配速率是固定的，则将分配固定数量的新堆内存。 因此，在活动堆大小和新堆内存保持不变的情况下，内存使用量将始终保持不变。 而且因为活动堆的大小相同，所以边际GC CPU成本也相同，并且固定成本将以某个固定间隔发生。</p>
<p>现在考虑GC如果延迟，发生在稍后时间应该运行的点之后， 因此将分配更多的内存，但每个GC周期仍将导致相同的CPU开销。 但是，在其他固定的时间窗口中，完成的GC周期会更少，从而降低了总体CPU成本。 如果GC决定提前启动，则情况正好相反：将分配较少的内存并且将更频繁地引起CPU成本。</p>
<p>这种情况代表了GC可以在CPU时间和内存之间进行的基本权衡，由GC实际执行的频率来控制。 换句话说，折衷完全由GC的频率定义。</p>
<p>还有一个细节需要定义，那就是GC应该决定何时开始。 注意，这直接设置了任何特定稳态下的GC频率，从而定义了折衷。 在Go语言中，决定GC何时启动是用户可以控制的主要参数。</p>
<h2 id="GOGC">GOGC</h2>
<p>GOGC是Go GC的一个调优参数，它通过控制GC频率直接反映了CPU时间和内存之间的平衡。 更具体地说，GOGC设置GC的目标堆大小，或者在标记阶段完成之前应该分配的新内存量。 GOGC被定义为GC需要完成的工作量的百分比开销。 这项工作目前被定义为活动堆的大小加上GC根的大小（以字节为单位）。</p>
<p>举个例子，假设一个Go语言程序，它有8 MiB的堆，1 MiB的goroutine栈，1 MiB的全局变量指针。 如果GOGC值为100，则在下一次GC运行之前将分配的新内存量将为10 MiB，或10 MiB工作量的100%，总堆占用量为18 MiB。 如果GOGC值为50，则它将为50%，即分配的新内存量为5 MiB。 如果GOGC值为200，则为200%，即分配的新内存量20 MiB。</p>
<blockquote>
<p>注意：GOGC可以更精确地描述为定义在下一个扫描阶段开始之前可以分配的新内存量。 从技术上讲，这个记时对于本指南目前使用的GC模型来说是正确的，但是它也适用于Go语言使用的真实GC实现，在延迟一节中会有更详细的讨论。</p>
</blockquote>
<p>以这种方式定义权衡(trade-off)的好处是，无论GC必须完成的工作量如何（也就是说，无论活动堆和根集的大小如何），GC的成本在稳态下都保持不变，因为频率总是与必须完成的工作量成比例。 换句话说，它代表了CPU成本和内存使用之间权衡的一个固定点。 (需要注意的是，如果稳定状态也发生变化，则此固定点也可能发生偏移，但关键是它不依赖于活动堆的大小。）</p>
<blockquote>
<p>注意：GOGC 自Go 1.18开始包含根集， 以前它只对活动堆进行计数。 通常，goroutine堆栈中的内存量非常小，并且活动堆的大小支配着GC的所有其他工作来源, (所以先前的计算大概也没问题,) 但是当程序有几十万个goroutine时，GC会做出错误的判断。</p>
</blockquote>
<p>GOGC可以通过GOGC环境变量（所有Go语言程序都能识别）或者<code>runtime/debug</code>包中的<code>SetGCPercent</code> API来配置。</p>
<blockquote>
<p>请注意，GOGC也可用于通过设置<code>GOGC=off</code>或调用<code>SetGCPercent(-1)</code>来完全关闭GC（前提是memory limit没有使用）。 从概念上讲，此设置等效于将GOGC设置为无穷大值，因为在触发GC之前新内存的数量是无限的。</p>
</blockquote>
<p>为了更好地理解我们到目前为止讨论的所有内容，请尝试下面的交互式可视化，它是基于前面讨论的GC成本模型构建的。 该可视化描述了某个程序的执行，该程序的非GC工作需要10秒的CPU时间才能完成。 在进入稳定状态之前的第一秒，它执行一些初始化步骤（增长其活动堆）。 应用程序总共分配200 MiB，其中20 MiB一次处于活动状态。 它假设要完成的唯一相关GC工作来自活动堆，并且（不现实地）应用程序不使用额外的内存。</p>
<p>使用滑块调整GOGC的值，以查看应用程序在总持续时间和GC开销方面的响应情况。 每次GC循环都会在新堆降为零时发生。 X轴移动以始终显示程序的完整CPU持续时间。 请注意，GC使用的额外CPU时间会增加总持续时间。</p>
<p><img src="1.png" alt=""></p>
<p>请注意，GC总是会导致一些CPU和峰值内存开销。 随着GOGC的增加，这些CPU开销降低，但峰值内存与活动堆大小成比例增加。 随着GOGC的减小，峰值内存需求也会减少，但会增加额外的CPU开销。</p>
<blockquote>
<p>注意：图形显示的是CPU时间，而不是完成程序所需的挂钟时间(wall-clock time)。 如果程序在1个CPU上运行并充分利用其资源，则它们是等效的。 真实的的程序可能运行在多核系统上，并且不会始终100%地利用CPU。 在这些情况下，GC的挂钟时间影响会比较低。</p>
</blockquote>
<blockquote>
<p>注意：Go GC的最小总堆大小为4 MiB，因此如果GOGC设置的目标值低于该值，则会取整。 这个图形展示反映此细节。</p>
</blockquote>
<p>这里有一个动态的和更有真实感的例子。 同样，在没有GC的情况下，应用程序需要10个CPU秒才能完成，但在中途，稳态分配率急剧增加，并且活动堆大小在第一阶段发生了一些变化。 这个示例演示了当活动堆大小实际上发生变化时，稳定状态可能是什么样子的，以及更高的分配率如何导致更频繁的GC周期。</p>
<p><img src="2.png" alt=""></p>
<h2 id="内存限制_（memory_limit）">内存限制 （memory limit）</h2>
<p>在Go 1.19之前，GOGC是唯一一个可以用来修改GC行为的参数。 虽然它作为一种设置权衡(trade-off)的方式非常有效，但它没有考虑到可用内存是有限的。 考虑当活动堆大小出现短暂峰值时会发生什么情况：因为GC将选择与活动堆大小成比例的总堆大小，所以GOGC必须被配置为峰值活动堆大小相匹配的值，即使在通常情况下，较高的GOGC值会提供了更好的权衡效果。</p>
<p>下面的可视化演示了这种瞬态堆峰值情况。</p>
<p><img src="3.png" alt=""></p>
<p>如果示例工作负载在可用内存略高于60 MiB的容器中运行，则GOGC不能增加到100以上，即使其余GC周期有可用内存来使用该额外内存。 此外，在一些应用中，这些瞬时峰值可能是罕见的并且难以预测，从而导致偶然的、不可避免的并且可能代价高昂的内存不足情况。</p>
<p>这就是为什么在1.19版本中，Go语言增加了对设置运行时内存限制的支持。 内存限制可以通过所有Go语言程序都能识别的<strong>GOMEMLIMIT</strong>环境变量来配置，也可以通过<code>runtime/debug</code>包中的<code>SetMemoryLimit</code>函数来配置。</p>
<p>这个内存限制设置了Go语言运行时可以使用的最大内存总量。 包含的特定内存集是<code>runtime.MemStats</code>的<code>Sys - HeapReleased</code>的值，或者等价于<code>runtime/metrics</code>的公式<code>/memory/classes/total:bytes - /memory/classes/heap/released:bytes</code>。</p>
<p>因为Go GC可以显式控制它使用多少堆内存，所以它会根据这个内存限制和Go运行时使用的其他内存来设置总的堆大小。</p>
<p>下面的可视化描述了来自GOGC部分的相同的单阶段稳态工作负载，但这次Go运行时额外增加了10 MiB的开销，并且内存限制可调。 尝试在GOGC和内存限制之间移动，看看会发生什么。</p>
<p><img src="4.png" alt=""></p>
<p>请注意，当内存限制降低到GOGC确定的峰值内存（GOGC为100时为42 MiB）以下时，GC会更频繁地运行，以将峰值内存保持在限制的内存之下。</p>
<p>回到我们前面的瞬态堆峰值的例子，通过设置内存限制并打开GOGC，我们可以获得两个世界的最佳结果：不违反内存限制，且更好地节约资源。 请尝试以下交互式可视化。</p>
<p><img src="5.png" alt=""></p>
<p>请注意，对于GOGC的某些值和内存限制，峰值内存使用在内存限制为多少时停止，但程序执行的其余部分仍然遵守GOGC设置的总堆大小规则。</p>
<p>这一观察引出了另一个有趣的细节：即使GOGC设置为关闭，内存限制仍然有效! 实际上，这种特定的配置代表了资源经济的最大化，因为它设置了维持某个内存限制所需的最小GC频率。 在这种情况下，所有程序的执行都会使堆大小增加以满足内存限制。</p>
<p>现在，虽然内存限制显然是一个强大的工具，<strong>但使用内存限制并不是没有代价的</strong>，当然也不会使GOGC的实用性失效。</p>
<p>请考虑当活动堆增长到足以使总内存使用量接近内存限制时会发生什么。 在上面的稳定状态可视化中，尝试关闭GOGC，然后慢慢地进一步降低内存限制，看看会发生什么。 请注意，应用程序花费的总时间将开始以无限制的方式增长，因为GC不断地执行以维持不可能的内存限制。</p>
<p>这种情况，即程序由于不断的GC循环而无法取得合理的进展，称为系统颠簸(thrashing)。 这是特别危险的，因为它严重地拖延了程序。 更糟糕的是，它可能会发生在我们试图避免使用GOGC的情况下：一个足够大临时堆尖峰会导致程序无限期地停止! 尝试在瞬态堆峰值可视化中降低内存限制（大约30 MiB或更低），并注意最坏的行为是如何从堆峰值开始的。</p>
<p>在许多情况下，无限期暂停比内存不足情况更糟，因为后者往往会导致更快的失败以便我们发现和处理。</p>
<p>因此，内存限制被定义为软限制。 Go语言运行时并不保证在任何情况下都能保持这个内存限制;它只承诺了一些合理的努力。 内存限制的放宽对于避免系统颠簸行为至关重要，因为它为GC提供了一条出路：让内存使用超过限制以避免在GC中花费太多时间。</p>
<p>这在内部是如何工作的？GC mitigates 设置了一个在某个时间窗口内可以使用的CPU时间量的上限（对于CPU使用中非常短的瞬时峰值，有一些滞后）。 此限制当前设置为大约50%，具有<code>2 * GOMAXPROCS CPU-second</code>窗口。 限制GC CPU时间的结果是GC的工作被延迟，同时Go程序可能会继续分配新的堆内存，甚至超过内存限制。</p>
<p>50% GC CPU限制背后的直觉是基于对具有充足可用内存的程序的最坏情况影响。 在内存限制配置错误的情况下，它被错误地设置得太低，程序最多会慢2倍，因为GC占用的CPU时间不能超过50%。</p>
<p>注意：此页上的可视化不会模拟GC CPU限制。</p>
<h3 id="建议用法">建议用法</h3>
<p>虽然内存限制是一个强大的工具，Go语言运行时也会采取措施来减少误用造成的最坏行为，但谨慎使用它仍然很重要。 下面是一些关于内存限制在哪些地方最有用，以及在哪些地方可能弊大于利的建议。</p>
<ul>
<li><p>当Go语言程序的执行环境完全在你的控制之下，并且Go语言程序是唯一可以访问某些资源的程序时（也就是说，某种内存预留，就像容器内存限制一样），一定要利用内存限制。<br>一个很好的示例是将web服务部署到具有固定可用内存量的容器中。<br><strong>在这种情况下，一个很好的经验法则是，留出额外的5-10%的空间来处理Go语言运行时不知道的内存资源。</strong></p>
</li>
<li><p>请随时调整内存限制，以适应不断变化的条件。<br>一个很好的例子是cgo程序，其中C库暂时需要使用更多的内存。</p>
</li>
<li><p>如果Go语言程序可能会与其他程序共享有限的内存，那么不要将GOGC设置为off，因为这些程序通常与Go语言程序是解耦的。 相反，保留内存限制，因为它可能有助于抑制不需要的瞬态行为，但将GOGC设置为某个较小的、对于一般情况而言合理的值。</p>
</li>
</ul>
<p>虽然尝试为共享程序“保留”内存是很诱人的，但除非程序完全同步（例如，Go程序在被调用程序执行时调用某些子进程和阻塞），否则结果将不太可靠，因为两个程序都不可避免地需要更多内存。 让Go程序在不需要内存的时候使用更少的内存，总体上会产生更可靠的结果。 此建议也适用于过量使用的情况，在这种情况下，在一台计算机上运行的容器的内存限制之和可能会超过该计算机可用的实际物理内存。</p>
<ul>
<li><p>当部署到您无法控制的执行环境时，不要使用内存限制，特别是当程序的内存使用与其输入成比例时。<br>CLI工具或桌面应用程序就是一个很好的例子。 在不清楚可能输入什么类型的输入，或者系统上可能有多少可用内存时，将内存限制写入程序可能会导致混乱的崩溃和性能下降。 此外，高级最终用户可以根据需要设置内存限制。</p>
</li>
<li><p>当程序已经接近其环境的内存限制时，不要设置内存限制以避免内存不足的情况。</p>
</li>
</ul>
<p>这有效地将内存不足的风险替换为严重的应用程序速度减慢的风险，这通常不是一个有利的交易，即使Go语言努力减轻系统颠簸。 在这种情况下，提高环境的内存限制（然后可能设置内存限制）或降低GOGC（这提供了比系统颠簸缓解更干净的权衡）将更加有效。</p>
<h3 id="延迟时间">延迟时间</h3>
<p>到目前为止，本文将应用程序建模在在GC执行时会暂停这一公理上。 确实存在这样的GC实现，它们被称为<strong>stop-the-world</strong> GC。</p>
<p>然而，Go GC并不是完全停止工作，实际上它的大部分工作都是与应用程序同时进行的。 这样做的主要原因是它减少了应用程序延迟。 具体来说，延迟是指单个计算单元（例如，web请求）的端到端持续时间。 到目前为止，本文主要考虑应用程序吞吐量，或这些操作的聚合（例如，每秒处理的web请求）。 请注意，GC周期部分中的每个示例都侧重于执行程序的总CPU持续时间。 然而，这样的持续时间对于例如web服务来说意义要小得多，web服务的持续时间主要捕获可靠性（即uptime）而不是成本。 虽然吞吐量（即每秒的查询数）对于web服务仍然很重要，但通常每个单独请求的延迟甚至更重要，因为它与其他重要指标相关。</p>
<p>就延迟而言，stop-the-world GC可能需要相当长的时间来执行其标记和扫描阶段，在此期间，应用程序以及在web服务的上下文中的任何正在进行的请求都无法取得进一步的进展。 相反，Go GC确保了任何全局应用程序暂停的长度都不会以任何形式与堆的大小成比例，并且在应用程序主动执行的同时执行核心跟踪算法。 这种选择并非没有成本，因为在实践中，它往往会导致吞吐量较低的设计，但需要注意的是，低延迟并不必然意味着低吞吐量，即使在许多情况下，这两者并不一致。</p>
<p>首先，Go GC的并发特性可能看起来与前面介绍的成本模型有很大的不同。 幸运的是，模型背后的直觉仍然适用。</p>
<p>虽然第一条公理不再成立，但它开始并不是那么重要;其余的成本仍然如模型所描述的那样，并且使用相同的稳态概念。 因此，GC频率仍然是GC在CPU时间和内存吞吐量之间进行权衡的主要方式，它还承担了延迟的角色。 关于吞吐量，只要假设并发GC所产生的所有小开销都发生在GC周期的末尾，就很容易回到模型的范围内。 关于延迟，GC增加的延迟中的大部分特别来自标记阶段处于活动状态的时间段。 因此，GC处于标记阶段的频率越高，这些成本就越频繁地发生，因此等待时间也跟随GC频率。</p>
<p>更具体地，调整GC参数以降低GC频率也可以导致延迟改善。 这意味着需要增加GOGC和/或内存限制。</p>
<p>然而，理解延迟通常比理解吞吐量更复杂，因为它是程序即时执行的产物，而不仅仅是成本的聚合之物。 因此，延迟和GC频率之间的联系更加脆弱，可能不那么直接。 下面是一个可能导致延迟的来源列表，供那些倾向于深入研究的人使用。 这些延迟源在执行跟踪中是可见的。</p>
<ul>
<li>当GC在标记和清除阶段之间转换时，</li>
<li>调度延迟是因为GC在标记阶段占用了25%的CPU资源，</li>
<li>用户goroutine贡献出来以便辅助GC处理高内存分配率</li>
<li>当GC处于标记阶段时，指针写入需要额外的处理。</li>
<li>运行中的goroutine必须被暂停，以便扫描它们的根。</li>
</ul>
<h3 id="其他资源">其他资源</h3>
<p>虽然上面提供的信息是准确的，但它缺乏充分理解Go GC设计中的成本和权衡的细节。 有关详细信息，请参阅以下其他资源。</p>
<ul>
<li><a href="https://tip.golang.org/doc/gc-guide#:~:text=following%20additional%20resources.-,The%20GC%20Handbook,-%E2%80%94An%20excellent%20general" target="_blank" rel="external">The GC Handbook</a> — 一个垃圾收集器设计的优秀通用资源和参考资料。</li>
<li><a href="https://google.github.io/tcmalloc/design.html" target="_blank" rel="external">TCMalloc</a> — C/C++内存分配器TCMalloc的设计文档，Go内存分配器就是基于此。</li>
<li><a href="https://go.dev/blog/go15gc" target="_blank" rel="external">Go 1.5 GC announcement</a> — 官方介绍Go 1.5并发GC的博客文章，其中更详细地描述了算法。</li>
<li><a href="https://go.dev/blog/ismmkeynote" target="_blank" rel="external">Getting to Go</a> — 深入介绍Go GC设计到2018年的演变</li>
<li><a href="https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit" target="_blank" rel="external">Go 1.5 concurrent GC pacing</a> — 确定何时开始并发标记阶段的设计文档</li>
<li><a href="https://github.com/golang/go/issues/30333" target="_blank" rel="external">Smarter scavenging</a> — 订正Go运行时向操作系统返回内存的方式的设计文档</li>
<li><a href="https://github.com/golang/go/issues/35112" target="_blank" rel="external">Scalable page allocator</a> — 订正Go运行时管理其从操作系统获得的内存的方式的设计文档</li>
<li><a href="https://github.com/golang/go/issues/44167" target="_blank" rel="external">GC pacer redesign (Go 1.18)</a> — 用于修改算法以确定何时开始并发标记阶段的设计文件</li>
<li><a href="https://github.com/golang/go/issues/48409" target="_blank" rel="external">Soft memory limit (Go 1.19)</a> — 软内存限制的设计文件</li>
</ul>
<h2 id="关于虚拟内存注意事项">关于虚拟内存注意事项</h2>
<p>本指南主要关注GC的物理内存使用，但经常出现的一个问题是你到底想说个啥，以及它与虚拟内存的比较（通常在像top这样的程序中表示为“VSS”）。</p>
<p>物理内存是大多数计算机中实际物理RAM芯片中的内存。 虚拟内存是由操作系统提供的物理内存上的抽象，用于将程序彼此隔离。 程序保留完全不映射到任何物理地址的虚拟地址空间通常也是可以接受的。</p>
<p><strong>由于虚拟内存只是操作系统维护的映射，因此保留不映射到物理内存的大型虚拟内存通常非常便宜。</strong></p>
<p>Go语言运行时通常在以下几个方面依赖于这种虚拟内存开销视图：</p>
<ul>
<li><p>Go语言运行时不会删除它所映射的虚拟内存。 相反，它使用大多数操作系统提供的特殊操作来显式释放与某个虚拟内存范围相关联的任何物理内存资源。<br>该技术被显式地用于管理内存限制，并将Go语言运行时不再需要的内存返回给操作系统。 Go运行时也会在后台连续释放不再需要的内存。 有关详细信息，请参阅其他资源。</p>
</li>
<li><p>在32位平台上，Go运行时会为堆预留128 MiB到512 MiB的地址空间，以限制碎片问题。</p>
</li>
<li><p>Go语言运行时在实现几个内部数据结构时使用了大量的虚拟内存地址空间预留。 在64位平台上，它们通常具有大约700 MiB的最小虚拟内存占用量。 在32位平台上，它们的占用空间可以忽略不计。</p>
</li>
</ul>
<p>因此，虚拟内存指标，比如top中的“VSS”，在理解Go语言程序的内存占用方面通常不是很有用。 相反，应该关注“RSS”和类似的度量，它们更直接地反映了物理内存的使用情况。</p>
<h2 id="优化指南">优化指南</h2>
<h3 id="确定成本">确定成本</h3>
<p>在尝试优化Go语言应用程序与GC的交互方式之前，首先确定GC是一个主要的开销，这一点很重要。</p>
<p>Go生态系统提供了大量的工具来识别成本和优化Go应用程序。 有关这些工具的简要概述，请参阅<a href="https://tip.golang.org/doc/diagnostics" target="_blank" rel="external">诊断指南</a>。 在这里，我们将重点讨论这些工具的一个子集，以及应用它们的合理顺序，以便理解GC的影响和行为。</p>
<p><strong> 1、CPU profile</strong></p>
<p>优化程序的一个很好的起点是<a href="https://pkg.go.dev/runtime/pprof#hdr-Profiling_a_Go_program" target="_blank" rel="external">CPU profiling</a>。 CPU profiling提供了CPU时间花费在何处的概述，尽管对于未经训练的眼睛来说，可能很难确定GC在特定应用程序中所起作用的大小。 幸运的是，理解profile的GC主要归结为了解<code>runtime</code>包中不同函数的含义即可。 以下是这些函数中用于解释CPU profile文件的有用子集。</p>
<blockquote>
<p>注意：下面列出的函数不是叶函数，因此它们可能不会显示在pprof工具为top命令提供的默认值中。 相反，使用<code>top cum</code>命令或直接对这些函数使用<code>list</code>命令，并将注意力集中在累计百分比列上。</p>
</blockquote>
<ul>
<li><strong>runtime.gcBgMarkWorker</strong>: 专用标记工作goroutine的入口点。 这里花费的时间与GC频率以及对象图的复杂性和大小成比例。 它表示应用程序标记和扫描所用时间的基准。</li>
</ul>
<p>注意：在一个大部分时间都处于空闲状态的Go应用程序中，Go GC会消耗额外的（空闲的）CPU资源来更快地完成任务。 结果，该符号可以表示它认为是免费采样部分。 一个常见的原因是，一个应用程序完全在一个goroutine中运行，但是GOMAXPROCS &gt; 1。</p>
<ul>
<li><p><strong>runtime.mallocgc</strong>:堆内存的内存分配器的入口点。 此处花费的大量累积时间（&gt; 15%）通常表示分配了大量内存。</p>
</li>
<li><p><strong>runtime.gcAssistAlloc</strong>: goroutine进入这个函数是为了腾出一些时间来帮助GC进行扫描和标记。 这里花费的大量累积时间（&gt; 5%）表明应用程序在分配速度方面可能超过了GC。 它表示GC的影响程度特别高，并且还表示应用程序在标记和扫描上花费的时间。 请注意，它包含在<code>runtime.mallocgc</code>调用树中，因此它也会使该调用树累计时间增加。</p>
</li>
</ul>
<p><strong>2、执行跟踪</strong></p>
<p>虽然CPU profile文件非常适合用于确定时间在聚合中的花费点，但对于指示更细微、更罕见或与延迟具体相关的性能成本，它们的用处不大。 另一方面，执行跟踪提供了Go语言程序执行的一个短窗口的丰富而深入的视图。 它们包含了与Go GC相关的各种事件，可以直接观察到具体的执行路径，沿着应用程序与Go GC的交互方式。 所有被跟踪的GC事件都在跟踪查看器中被方便地标记为GC事件。</p>
<p>有关如何开始使用执行跟踪的信息，请参阅 <a href="https://pkg.go.dev/runtime/trace" target="_blank" rel="external">runtime/trace</a> 的文档。</p>
<p><strong> 3、GC跟踪</strong></p>
<p>当所有其他方法都失败时，Go GC还提供了一些不同的特定跟踪，这些跟踪提供了对GC行为的更深入的了解。 这些踪迹总是被直接打印到 STDERR 中，每个GC循环一行，并且通过所有Go语言程序都能识别的 GODEBUG 环境变量来配置。 它们主要用于调试Go GC本身，因为它们需要对GC实现的细节有一定的了解，但是偶尔也可以用于更好地理解GC的行为。</p>
<p>通过设置<code>GODEBUG=gctrace=1</code>，可以启用核心GC跟踪。 此跟踪生成的输出记录在<a href="https://pkg.go.dev/runtime#hdr-Environment_Variables" target="_blank" rel="external">runtime</a>包文档的环境变量部分中。</p>
<p>一个称为<code>pacer trace</code>的技术用来补充GC跟踪，提供了更深入的见解，它通过设置<code>GODEBUG=gcpacertrace=1</code>来启用。 解释这个输出需要理解GC的<code>pacer</code>（参见<a href="https://tip.golang.org/doc/gc-guide#Additional_resources" target="_blank" rel="external">其他参考资料</a>），这超出了本指南的范围。</p>
<h3 id="消除堆分配">消除堆分配</h3>
<p>降低GC成本的一种方法是让GC开始管理较少的值。 下面描述的技术可以带来一些最大的性能改进，因为正如GOGC部分所展示的，Go语言程序的分配率是GC频率的一个主要因素，GC频率是本指南使用的关键成本度量。</p>
<h4 id="堆分析">堆分析</h4>
<p>在确定GC是一个巨大开销的来源之后，消除堆分配的下一步是找出它们中的大多数来自哪里。 为此，内存 profile 文件（实际上是堆内存 profile 文件）非常有用。 请查看<a href="https://pkg.go.dev/runtime/pprof#hdr-Profiling_a_Go_program" target="_blank" rel="external">文档</a>以了解如何开始使用它们。</p>
<p>内存 profile 文件描述了程序堆中分配的来源，并通过分配时的堆栈跟踪来标识它们。 每个内存 profile 文件可以按四种方式分析：</p>
<ul>
<li>inuse_objects - 活动对象的数量</li>
<li>inuse_space - 按活动对象使用的内存量（以字节为单位</li>
<li>alloc_objects - 自Go程序开始执行以来已经分配的对象数</li>
<li>alloc_space - 自Go程序开始执行以来所分配的内存总量</li>
</ul>
<p>在这些不同的堆内存视图之间切换可以通过pprof工具的 <code>-sample_index</code>标志来完成，或者在交互式使用该工具时通过<code>sample_index</code>选项来完成。</p>
<blockquote>
<p>注意：默认情况下，内存 profile 文件只对堆对象的子集进行采样，因此它们不会包含有关每个堆分配的信息。 但是，这足以找到热点。 若要更改采样率，请参见<a href="https://pkg.go.dev/runtime#pkg-variables" target="_blank" rel="external">runtime.MemProfileRate</a>。</p>
</blockquote>
<p>为了降低GC成本，alloc_space通常是最有用的视图，因为它直接对应于分配率。 此视图将指示可提供最大益处的分配热点。</p>
<h4 id="逃逸分析">逃逸分析</h4>
<p>一旦在<a href="https://tip.golang.org/doc/Heap_profiling" target="_blank" rel="external">堆 profile 文件</a>的帮助下确定了候选堆分配点，如何消除它们？ 关键是要利用Go语言编译器的逃逸分析，让Go语言编译器为这个内存找到替代的、更有效的存储空间，比如在goroutine栈中。 幸运的是，Go语言编译器能够描述为什么要将Go语言的值逃逸到堆中。 有了这些知识，就变成了重新组织源代码以改变分析结果的问题（这通常是最困难的部分，但超出了本指南的范围）。</p>
<p>至于如何从Go语言编译器的逃逸分析中获取信息，最简单的方法是通过Go语言编译器支持的调试标志，该标志以文本格式描述了对某个包应用或未应用的所有优化。 这包括值是否逃逸。 尝试下面的命令，其中<code>package</code>是Go语言包的路径:<br><code>$go build-gcflags=-m=3 软件包</code></p>
<p>此信息也可以在VS代码中可视化为覆盖图。 此覆盖在VS Code Go插件设置中配置和启用:</p>
<ul>
<li>设置<a href="https://github.com/golang/vscode-go/wiki/settings#uicodelenses" target="_blank" rel="external">ui.codelenses设置以包括gc_details</a></li>
<li>通过<a href="https://github.com/golang/vscode-go/wiki/settings#uidiagnosticannotations" target="_blank" rel="external">将ui.diagnostic.annotations设置为包括逃逸，启用逃逸分析的覆盖</a></li>
</ul>
<p>最后，Go编译器以机器可读（JSON）格式提供了这些信息，可以用来构建其他定制工具。 有关这方面的更多信息，请参见<a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/logopt/log_opts.go;l=25;drc=351e0f4083779d8ac91c05afebded42a302a6893" target="_blank" rel="external">Go语言源代码中的文档</a>。</p>
<h3 id="基于特定实现的优化">基于特定实现的优化</h3>
<p>Go GC对活动内存的人口统计很敏感，因为对象和指针的复杂图既限制了并行性，又为GC生成了更多的工作。 因此，GC包含了一些针对特定公共结构的优化。 下面列出了对性能优化最直接有用的方法。</p>
<blockquote>
<p>注意：应用下面的优化可能会因为混淆意图而降低代码的可读性，并且可能无法在Go语言的各个版本中保持。 希望只在最重要的地方应用这些优化。 可以使用确定成本一节中列出的工具来确定这些地点。</p>
</blockquote>
<ul>
<li>无指针值与其他值分开。</li>
</ul>
<p>因此，从并不严格需要指针的数据结构中消除指针可能是有利的，因为这减少了GC施加在程序上的缓存压力。 因此，依赖于指针值上的索引的数据结构虽然类型化较差，但可能执行得更好。 只有当对象图很复杂并且GC花费大量时间进行标记和扫描时，才值得这样做。</p>
<ul>
<li>GC将在值中的最后一个指针处停止扫描值。</li>
</ul>
<p>因此，将结构类型值中的指针字段分组在值的开头可能是有利的。 只有当应用程序花费大量时间进行标记和扫描时，才值得这样做。 (理论上，编译器可以自动执行此操作，但尚未实现，并且结构字段的排列方式与源代码中所写的相同。）</p>
<p>此外，GC必须与它所看到的几乎每个指针交互，因此，例如，使用切片中的索引而不是指针，可以帮助降低GC成本。</p>
<blockquote>
<p>译者著， 这篇文章， 和Russ Cox的那三遍关于Go内存的模型一样， 里面有众多的未解释的名词，不是那么容易进行翻译，而Go语言规范和Go内存相对就容易理解和翻译了。我之所以尝试翻译，最重要的原因想深入学习本文介绍的相关知识，疏漏之处，欢迎斧正。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go官方原文: <a href="https://tip.golang.org/doc/gc-guide?continueFlag=bf311ba190bf0d160b5d3461e092f0f4" target="_blank" rel="external">A Guide to the Go Garbage Collector</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式系统设计模式]]></title>
    <link href="https://colobu.com/2022/06/26/distributed-system-design-patterns/"/>
    <id>https://colobu.com/2022/06/26/distributed-system-design-patterns/</id>
    <published>2022-06-26T10:27:32.000Z</published>
    <updated>2022-06-26T11:19:54.168Z</updated>
    <content type="html"><![CDATA[<p>原文:<a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="external">Distributed System Design Patterns</a> </p>
<p>与分布式系统相关的常见问题的关键设计模式。<br><a id="more"></a></p>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p>Bloom 过滤器是一种节省空间的概率数据结构，用于测试元素是否为某集合的成员。它用于我们只需要检查元素是否属于对象的场景。</p>
<p><img src="bloom-filter.png" alt=""></p>
<p>在BigTable（和Cassandra）中，任何读取操作都必须从组成Tablet的SSTable中读取。如果这些 SSTable 不在内存中，则读取操作可能最终会执行许多磁盘访问以便读取所需的SSTable。为了减少磁盘访问次数，BigTable 使用 Bloom 过滤器。</p>
<h2 id="一致性哈希">一致性哈希</h2>
<p>一致的哈希允许您轻松扩展，从而允许以有效的方式复制数据，从而实现更好的可用性和容错能力。</p>
<p>通过对数据项的键进行哈希处理以产生其在环上的位置，然后顺时针遍历环以查找位置大于该项位置的第一个节点，将每个由键标识的数据项分配给节点。与节点关联的节点是数据项的位置。</p>
<p><img src="chash.png" alt=""></p>
<p>一致散列的主要优点是增量稳定性;节点离开或到达集群仅影响其直接邻居，其他节点不受影响。</p>
<h2 id="Quorum">Quorum</h2>
<p>在分布式环境中，quorum是在确认操作成功之前需要成功执行此分布式操作的最小服务器数。</p>
<p><img src="quorum.png" alt=""></p>
<p>Cassandra，为了确保数据一致性，每个写入请求都可以配置为仅当数据已写入至少一个quorum（或大多数）副本节点时才成功。</p>
<p>对于领导者选举，Chubby使用Paxos，它使用quorum来确保强大的一致性。</p>
<p>Dynamo 将写入复制到系统中其他节点的草率quorum，而不是像 Paxos 那样的严格多数quorum。所有读/写操作都在首选项列表中的第一个 NN 正常节点上执行，该节点可能并不总是在遍历一致哈希环时遇到的第一个 NN 节点。</p>
<h2 id="领导者(Leader)和追随者(Follower)">领导者(Leader)和追随者(Follower)</h2>
<p>为了在管理数据的系统中实现容错，需要在多个服务器上复制数据。</p>
<p>在集群中选择一个服务器作为领导者。领导者负责代表整个集群做出决策，并将决策传播到所有其他服务器。</p>
<p>三到五个节点的集群，就像在实现共识的系统中一样，领导者选举可以在数据集群本身内实施，而不依赖于任何外部系统。领导者选举在服务器启动时进行。每个服务器在启动时都会启动领导者选举，并尝试选举领导者。除非选出领导者，否则系统不接受任何客户端请求。</p>
<h2 id="心跳">心跳</h2>
<p>心跳机制用于检测现有领导者是否失败，以便可以启动新的领导者选举。</p>
<h2 id="Fencing">Fencing</h2>
<p>在领导者-追随者模式中，当领导者失败时，不可能确定领导者已停止工作。例如，慢速网络或网络分区可能会触发新的领导者选举，即使前一个领导者仍在运行并认为它仍然是活动的领导者。</p>
<p>屏蔽是指在以前处于活动状态的领导者周围设置围栏，使其无法访问集群资源，从而停止为任何读/写请求提供服务。</p>
<p>使用以下两种技术：</p>
<ul>
<li><strong>资源屏蔽</strong>：系统会阻止以前处于活动状态的领导者访问执行基本任务所需的资源。</li>
<li><strong>节点屏蔽</strong>：系统会阻止以前处于活动状态的领导者访问所有资源。执行此操作的常见方法是关闭节点电源或重置节点。</li>
</ul>
<h2 id="WAL_(预写日志_Write-ahead_Log)">WAL (预写日志 Write-ahead Log)</h2>
<p>预写日志记录是解决操作系统中<a href="https://www.geeksforgeeks.org/file-system-inconsistency/" target="_blank" rel="external">文件系统不一致</a>的问题的高级解决方案。受数据库管理系统的启发，此方法首先将要执行的操作的摘要记入“日志”中，然后再将其实际写入磁盘。在发生崩溃的情况下，操作系统只需检查此日志并从中断的位置继续。</p>
<h2 id="分段日志">分段日志</h2>
<p>将日志拆分为多个较小的文件，而不是单个大文件，以便于操作。</p>
<p>单个日志文件在启动时读取时可能会增长并成为性能瓶颈。较旧的日志会定期清理，并且很难对单个大文件执行清理操作。</p>
<p>单个日志拆分为多个段。日志文件在指定的大小限制后滚动。使用日志分段，需要有一种将逻辑日志偏移量（或日志序列号）映射到日志段文件的简单方法。</p>
<h2 id="高水位线_(High-Water_mark)">高水位线 (High-Water mark)</h2>
<p>跟踪领导者上的最后一个日志条目，该条目已成功复制到追随者的quorum。日志中此条目的索引称为高水位线索引。领导者仅公开到高水位线索引的数据。</p>
<p>Kafka：为了处理非可重复读取并确保数据一致性，Kafka broker会跟踪高水位线，这是特定分区的最大偏移量。使用者只能看到高水位线之前的消息。</p>
<h2 id="租约(Lease)">租约(Lease)</h2>
<p>租约就像一个锁，但即使客户端离开，它也能工作。客户端请求有限期限的租约，之后租约到期。如果客户端想要延长租约，它可以在租约到期之前续订租约。</p>
<p>Chubby 客户端与领导者保持有时限的会话租约。在此时间间隔内，领导者保证不会单方面终止会话。</p>
<h2 id="Gossip_协议">Gossip 协议</h2>
<p>Gossip协议是点对点通信机制，其中节点定期交换有关自己和他们所知道的其他节点的状态信息。</p>
<p>每个节点每秒启动一轮Gossip回合，以与另一个随机节点交换有关自己和其他节点的状态信息。</p>
<p><img src="gossip.png" alt=""></p>
<h2 id="Phi_累计故障检测（Phi_Accrual_Failure_Detection）">Phi 累计故障检测（Phi Accrual Failure Detection）</h2>
<p>此算法使用历史检测信号信息使阈值自适应。通用的应计故障检测器不会判断服务器是否处于活动状态，而是输出有关服务器的可疑级别。</p>
<p>Cassandra 使用 Phi 应计故障检测器算法来确定群集中节点的状态。</p>
<h2 id="脑裂">脑裂</h2>
<p>分布式系统具有两个或多个活动领导者的场景称为脑裂。</p>
<p>通过使用生成时钟(Generation Clock)可以解决脑裂问题，生成时钟只是一个单调递增的数字，用于指示服务器的生成。</p>
<p>每次选出新领导者时，时钟数字(generation number)都会增加。这意味着，如果旧领导者的时钟数为“1”，则新领导人的时钟数将为“2”。此时钟号包含在从领导发送到其他节点的每个请求中。通过这种方式，节点现在可以通过简单地信任具有最高数字的领导者来轻松区分真正的领导者。</p>
<p>Kafka：为了处理脑裂（我们可以有多个active controller broker），Kafka使用“纪元数”（Epoch number），这只是一个单调增加的数字来表示服务器的代次(generation)。</p>
<p>HDFS：ZooKeeper用于确保任何时候只有一个NameNode处于活动状态。epoch 编号作为每个事务 ID 的一部分进行维护，以反映 NameNode 的代次。</p>
<h2 id="校验和_(checksum)">校验和 (checksum)</h2>
<p>在分布式系统中，在组件之间移动数据时，从节点获取的数据可能会损坏。</p>
<p>计算校验和并将其与数据一起存储。</p>
<p>要计算校验和，请使用 MD5、SHA-1、SHA-256 或 SHA-512 等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）;此字符串称为校验和。</p>
<p>当系统存储某些数据时，它会计算数据的校验和，并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，则客户端可以选择从另一个副本检索该数据。</p>
<p>HDFS和Chubby将每个文件的校验和与数据一起存储。</p>
<h2 id="CAP定理">CAP定理</h2>
<p>CAP定理指出，分布式系统不可能同时提供以下所有三个理想属性：</p>
<p>一致性(C)、可用性(A) 和分区容差(P)。</p>
<p>根据CAP定理，任何分布式系统都需要从三个属性中选择两个。这三个选项是 CA、CP 和 AP。</p>
<p>Dynamo：在CAP定理术语中，Dynamo属于AP系统的类别，旨在牺牲强一致性为代价实现高可用性。</p>
<p>BigTable：就CAP定理而言，BigTable是一个CP系统，即它具有严格一致的读取和写入。</p>
<h2 id="PACELEC_定理">PACELEC 定理</h2>
<p>PACELC定理指出，在复制数据的系统中：</p>
<ul>
<li>如果有一个分区（&#39;P&#39;），分布式系统可以在可用性和一致性（即&#39;A&#39;和&#39;C&#39;）之间进行权衡;</li>
<li>否则（&#39;E&#39;），当系统在没有分区的情况下正常运行时，系统可以在延迟（&#39;L&#39;）和一致性（&#39;C&#39;）之间进行权衡。</li>
</ul>
<p><img src="PACELEC.png" alt=""></p>
<p>定理（PAC）的第一部分与CAP定理相同，ELC是扩展。整个论点假设我们通过复制来保持高可用性。因此，当失败时，CAP定理占上风。但如果没有，我们仍然必须考虑复制系统的一致性和延迟之间的权衡。</p>
<h2 id="提示交接_(Hinted_Handoff)">提示交接 (Hinted Handoff)</h2>
<p>如果节点关闭，系统会保留它们错过的所有请求的提示（或注释）。故障节点恢复后，将根据存储的提示将请求转发给它们。</p>
<p>当节点关闭时，领导者会在本地磁盘上的文本文件中写入提示。此提示包含数据及其所属的节点信息。当领导者意识到它为其保留提示的节点已恢复时，它会将每个提示的写入请求转发到该节点。</p>
<h2 id="读取时修复">读取时修复</h2>
<p>在分布式系统中，数据跨多个节点复制，某些节点最终可能会拥有过时的数据。</p>
<p>在读取操作期间修复过时的数据，因为此时，我们可以从多个节点读取数据以进行比较并找到具有过时数据的节点。此机制称为读取修复。一旦已知具有旧数据的节点，读取修复操作就会将较新版本的数据推送到具有较旧版本的节点。</p>
<p>Cassandra和Dynamo使用“读取修复”将最新版本的数据推送到具有旧版本的节点。</p>
<h2 id="默克尔树_(Merkle_Trees)">默克尔树 (Merkle Trees)</h2>
<p>“读取修复”可在处理读取请求时消除冲突。但是，如果某个副本明显落后于其他副本，则可能需要很长时间才能解决冲突。</p>
<p>副本可以包含大量数据。单纯地拆分整个范围来计算校验和进行比较并不是很可行;有太多的数据需要传输。相反，我们可以使用Merkle树来比较一个范围的副本。</p>
<p>Merkle 树是哈希的二叉树，其中每个内部节点是其两个子节点的哈希，每个叶节点是原始数据一部分的哈希。</p>
<p><img src="merkle-tree.png" alt=""></p>
<p>比较Merkle树在概念上很简单：</p>
<ul>
<li>比较两个树的根哈希。</li>
<li>如果它们相等，请停止。</li>
<li>在左边和右边的孩子上递归检查。</li>
</ul>
<p>为了实现反熵和在后台解决冲突，Dynamo使用Merkle树。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文:<a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="external">Distributed System Design Patterns</a> </p>
<p>与分布式系统相关的常见问题的关键设计模式。<br>]]>
    
    </summary>
    
      <category term="设计模式" scheme="https://colobu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[等等， 怎么使用 SetMemoryLimit?]]></title>
    <link href="https://colobu.com/2022/06/20/how-to-use-SetMemoryLimit/"/>
    <id>https://colobu.com/2022/06/20/how-to-use-SetMemoryLimit/</id>
    <published>2022-06-20T05:43:30.000Z</published>
    <updated>2022-06-20T07:14:58.271Z</updated>
    <content type="html"><![CDATA[<p>Go 1.19中终于实现了<code>SetMemoryLimit</code>的功能。Go的GC并不像Java那样提供了很多的参数可以调整，目前也就有<code>GOGC</code>这么一个参数，所以能增加一个可以调整GC的参数确实让人兴奋。</p>
<a id="more"></a>
<p>一直关注Go性能同学一定知道，最近几年有两个调整Go GC的hack方式:</p>
<ul>
<li><a href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/" target="_blank" rel="external">ballast</a>: 压舱石技术。使用一个&quot;虚假&quot;的内存占用，让Go运行时难以达到触发GC的阈值，来实现减少GC的次数，从而提高性能。如果你的程序的内存占用基本都会在某个阈值之下的话，这个技术非常有效，毕竟，Go很大的一部分性能消耗都是在GC上。这是twitch.tv的工程师提供的一种技术。</li>
<li><a href="https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/" target="_blank" rel="external">GOGC tuner</a>: 通过自动调整GOGC，来动态的调整GC的target,用来在内存足够的时候调整GOGC来减少GC的次数，这也是一个非常有趣有效的技术，在uber公司的实践中行之有效。这是uber工程师提供的一项技术，Uber的工程师并没有把它开源出来，不过曹大根据文章的原理实现了一个<a href="https://github.com/cch123/gogctuner" target="_blank" rel="external">cch123/gogctuner</a>。</li>
</ul>
<p>现在， Go 1.19 提供了<code>SetMemoryLimit</code>的功能，通过这个方法，可以替换<code>ballast</code>的方案，部分替换<code>GOGC Tuner</code>的方案。</p>
<p>谈起这个功能的历史，可以追溯到2017年12月的<a href="https://github.com/golang/go/issues/23044" target="_blank" rel="external">#23044</a>，它提议增加一个方法，可以指定最小的目标堆大小。这个issue大家讨论的热火朝天，结果就是2019年twitch.tv的工程师实现了ballast,从工程的角度验证了GC是可以优化，而且在实践中也有效。</p>
<p>2021年Go team的工程师 Michael Knyszek 发起一个提案<a href="https://github.com/golang/go/issues/44309" target="_blank" rel="external">#44309</a>,包括设计文档<a href="https://github.com/golang/proposal/blob/7f0d01687e030f21e8bdc36dfd9d5aac3a6f4a71/design/44309-user-configurable-memory-target.md" target="_blank" rel="external">user configurable memory target</a>。这个提案的跟踪issue最终归于<a href="https://github.com/golang/go/issues/48409" target="_blank" rel="external">#48409</a>。</p>
<p>本来，这个提案预期在Go 1.18中实现，不过因为提案迟迟没有批准，所以最终会在Go 1.19中实现。</p>
<p>在撰写本文的时候，Go 1.19还在开发之中，不过这个提案的功能已经实现，剩下的是一些文档和bug修复的工作了，所以我们可以使用<a href="https://pkg.go.dev/golang.org/dl/gotip" target="_blank" rel="external">gotip</a>来测试。</p>
<p>这个提案的实现原来就是要实现(替换)ballast的功能，所以一旦Go 1.19发布， ballast的方案就可以废弃了。没想到今年突然Uber的工程师来了一个自动调整GOGC的方案,所以当前方案还不能完全代替GOGC tuner, 毕竟GOGC Tuner可以更灵活的调整GC的target,而<code>SetMemoryLimit</code>在设定的<code>MemoryLimit</code>之下，还是会频繁的进行GC, 如果加上<code>GOGC=off</code>的话，只能等待达到<code>MemoryLimit</code>才能GC,和GOGC Tuner的方式还有有所不同的,所以并不能完全替代GOGC tuner。</p>
<p>详细的 GC调优指导的<a href="https://tip.golang.org/doc/gc-guide" target="_blank" rel="external">官方文档</a>还没有完成，大家也可以关注一下，看看官方的建议。</p>
<blockquote>
<p>This page is currently a work-in-progress and is expected to be complete by the time of the Go 1.19 release. See this <a href="https://tip.golang.org/doc/gc-guide#:~:text=This%20page%20is%20currently%20a%20work%2Din%2Dprogress%20and%20is%20expected%20to%20be%20complete%20by%20the%20time%20of%20the%20Go%201.19%20release.%20See%20this%20tracking%20issue%20for%20more%20details." target="_blank" rel="external">tracking issue</a> for more details.</p>
</blockquote>
<p>即使官方文档还没有完成，依照提案的内容，我们还是可以早点了解这个提案的功能以及带给我们的收益。</p>
<p>下面通过四个场景，观察一下此功能对GC的影响:</p>
<ul>
<li><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>足够大</li>
<li><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>不足够大</li>
<li><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>足够大</li>
<li><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>不足够大</li>
</ul>
<h2 id="基本例子">基本例子</h2>
<p>本文通过Debian的benchmarks game中的<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/binarytrees-go-2.html" target="_blank" rel="external">btree例子</a>演示这四个场景。</p>
<p>因为这个例子会频繁生成生成二叉树，正适合内存分配和回收的场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> {</div><div class="line">	next *next</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> next <span class="keyword">struct</span> {</div><div class="line">	left, right node</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> create(d <span class="typename">int</span>) node {</div><div class="line">	<span class="keyword">if</span> d ==<span class="number"> 1</span> {</div><div class="line">		<span class="keyword">return</span> node{&next{node{}, node{}}}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> node{&next{create(d -<span class="number"> 1</span>), create(d -<span class="number"> 1</span>)}}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p node) check() <span class="typename">int</span> {</div><div class="line">	sum :=<span class="number"> 1</span></div><div class="line">	current := p.next</div><div class="line">	<span class="keyword">for</span> current != <span class="constant">nil</span> {</div><div class="line">		sum += current.right.check() +<span class="number"> 1</span></div><div class="line">		current = current.left.next</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	depth = flag.Int(<span class="string">"depth"</span>,<span class="number"> 10</span>, <span class="string">"depth"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	<span class="keyword">const</span> MinDepth =<span class="number"> 4</span></div><div class="line">	<span class="keyword">const</span> NoTasks =<span class="number"> 4</span></div><div class="line">	maxDepth := *depth</div><div class="line"></div><div class="line">	longLivedTree := create(maxDepth)</div><div class="line"></div><div class="line">	stretchTreeCheck := <span class="string">""</span></div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">	wg.Add<span class="number">(1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		stretchDepth := maxDepth +<span class="number"> 1</span></div><div class="line">		stretchTreeCheck = fmt.Sprintf(<span class="string">"stretch tree of depth %d\t check: %d"</span>,</div><div class="line">			stretchDepth, create(stretchDepth).check())</div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	results := <span class="built_in">make</span>([]<span class="typename">string</span>, (maxDepth-MinDepth)<span class="number">/2</span><span class="number">+1</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> results {</div><div class="line">		depth :=<span class="number"> 2</span>*i + MinDepth</div><div class="line"></div><div class="line">		n := <span class="number">(1</span> &lt;&lt; (maxDepth - depth + MinDepth)) / NoTasks</div><div class="line"></div><div class="line">		tasks := <span class="built_in">make</span>([]<span class="typename">int</span>, NoTasks)</div><div class="line">		wg.Add(NoTasks)</div><div class="line">		<span class="comment">// 执行NoTasks个goroutine, 每个goroutine执行n个深度为depth的tree的check</span></div><div class="line">		<span class="comment">// 一共是n*NoTasks个tree,每个tree的深度是depth</span></div><div class="line">		<span class="keyword">for</span> t := <span class="keyword">range</span> tasks {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(t <span class="typename">int</span>) {</div><div class="line">				check :=<span class="number"> 0</span></div><div class="line">				<span class="keyword">for</span> i := n; i &gt;<span class="number"> 0</span>; i-- {</div><div class="line">					check += create(depth).check()</div><div class="line">				}</div><div class="line">				tasks[t] = check</div><div class="line">				wg.Done()</div><div class="line">			}(t)</div><div class="line">		}</div><div class="line"></div><div class="line">		wg.Wait()</div><div class="line">		check :=<span class="number"> 0</span> <span class="comment">// 总检查次数</span></div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> tasks {</div><div class="line">			check += v</div><div class="line">		}</div><div class="line">		results[i] = fmt.Sprintf(<span class="string">"%d\t trees of depth %d\t check: %d"</span>,</div><div class="line">			n*NoTasks, depth, check)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(stretchTreeCheck)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> results {</div><div class="line">		fmt.Println(s)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"long lived tree of depth %d\t check: %d\n"</span>,</div><div class="line">		maxDepth, longLivedTree.check())</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"took %.02f s"</span>, <span class="typename">float64</span>(time.Since(start).Milliseconds())<span class="number">/1000</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以使用<code>gotip build main.go</code>生成Go 1.19编译的二进制文件。</p>
<p>后面的例子中我并没有使用<code>debug.SetMemoryLimit</code>设置<code>MemoryLimit</code>,而是使用环境变量<code>GOMEMLIMIT</code>。</p>
<h2 id="SetMemoryLimit_+_GOGC=off_+_MemoryLimit足够大"><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>足够大</h2>
<p>首先使用<code>gotip build main.go</code>编译出可执行的二进制文件<code>soft_memory_limit</code>。</p>
<p>运行 <code>GOMEMLIMIT=10737418240 GOGC=off GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code>查看效果：<br><img src="case1.png" alt=""></p>
<p>这里我设置的<code>MemoryLimit</code>为10G,整个程序中并没有达到这个内存阈值，所以没有GC发生。</p>
<p>是不是和设置ballast的效果一样。</p>
<h2 id="SetMemoryLimit_+_GOGC=off_+_MemoryLimit不足够大"><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>不足够大</h2>
<p>我们将<code>MemoryLimit</code>设置为1G,看看GC的表现(<code>GOMEMLIMIT=1073741824 GOGC=off GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code>)：<br><img src="case2.png" alt=""></p>
<p>可以看到程序的运行过程内存占用还是能够触达阈值1G的，这会导致几次的垃圾回收，整体运行时间和case1差别不到，原因是GC回收仅仅几次，可以忽略。</p>
<p>如果你把阈值设置更小，比如缩小10倍(<code>GOMEMLIMIT=107374182 GOGC=off GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code>),可以看到更频繁的垃圾回收，程序整体运行时间也显著增加：<br><img src="case2-2.png" alt=""></p>
<h2 id="SetMemoryLimit_+_GOGC=100_+_MemoryLimit足够大"><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>足够大</h2>
<p>为了达到ballast的效果，前面的case都把GOGC设置为了<code>off</code>,如果我们设置为默认值100呢？</p>
<p><code>GOMEMLIMIT=10737418240 GOGC=100 GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code></p>
<p><img src="case3.png" alt=""></p>
<p>可以看到，会有大量的GC事件，并且很多并没有达到阈值就发生GC了。这也是显而易见的，因为在没有达到<code>MemoryLimit</code>阈值的情况下，还是遵循GOGC的target决定要不要进行垃圾回收。</p>
<p>在这种情况下，可以使用GOGC tuner进行调优，避免这么多次的垃圾回收。</p>
<h2 id="SetMemoryLimit_+_GOGC=100_+_MemoryLimit不足够大"><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>不足够大</h2>
<p>如果设置的<code>MemoryLimit</code>不足够大,在内存触达<code>MemoryLimit</code>的时候也会触发GC,只不过因为没有关闭GOGC,所以GOGC和触达<code>MemoryLimit</code>两种情况下都有可能触发GC,程序整体运行还是比较慢的。</p>
<p><img src="case4.png" alt=""></p>
<p>综上所述,通过<code>SetMemoryLimit</code>设置一个较大的值，再加上 <code>GOGC=off</code>，可以实现ballast的效果。</p>
<p>但是在没有关闭<code>GOGC</code>的情况下，还是有可能会触发很多次的GC,影响性能，这个时候还得GOGC Tuner调优，减少触达<code>MemoryLimit</code>之前的GC次数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.19中终于实现了<code>SetMemoryLimit</code>的功能。Go的GC并不像Java那样提供了很多的参数可以调整，目前也就有<code>GOGC</code>这么一个参数，所以能增加一个可以调整GC的参数确实让人兴奋。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用BPF, 将Go网络程序的吞吐提升8倍]]></title>
    <link href="https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/"/>
    <id>https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/</id>
    <published>2022-06-05T09:05:09.000Z</published>
    <updated>2022-06-05T11:18:34.897Z</updated>
    <content type="html"><![CDATA[<p>经典的bpf(classical Berkeley Packet Filter) 是非常好用的一个技术，在一些特殊的Go底层网络编程的场合，可以很好的提高性能。<br><a id="more"></a></p>
<h2 id="背景">背景</h2>
<p>先前我开发过一个Go UDP应用程序， 客户端和服务端通过UDP程序，通过raw socket进行通讯。程序的目的比较特殊，这里我以一个简单的程序为例介绍。</p>
<p>事实上，我说我使用rawsocket方式并不严谨，我并不是采用下面的方式实现socket并进行通讯的(链路层的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fd, err:= syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW,syscall.ETH_P_ALL)</div><div class="line"><span class="keyword">if</span> (err != <span class="constant">nil</span>) {</div><div class="line">    fmt.Println(<span class="string">"Error: "</span> + err.Error())</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line">fmt.Println(<span class="string">"Obtained fd "</span>, fd)</div><div class="line"><span class="keyword">defer</span> syscall.Close(fd)</div></pre></td></tr></table></figure>

<p>也不是采用下面的rawsocket方式(IP层的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    fd, e := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_UDP)</div><div class="line">    <span class="keyword">if</span> e != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(<span class="string">"Problem @ location 1"</span>)</div><div class="line">    }</div><div class="line">    addr := syscall.SockaddrInet4{</div><div class="line">        Port:<span class="number"> 27289</span>,</div><div class="line">        Addr: <span class="number">[4</span>]<span class="typename">byte</span><span class="number">{127</span>,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 1</span>},</div><div class="line">    }</div><div class="line">    p := pkt()</div><div class="line">    err = syscall.Sendto(fd, p,<span class="number"> 0</span>, &addr)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(<span class="string">"Sendto:"</span>, err)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而是直接采用Go标准库中封装好的方法<code>net.ListenPacket(&quot;ip4:udp&quot;, addr)</code>在IP层进行包的发送和接收。</p>
<p>我通过封装自定义的UDP层的数据结构，实现自定义的包的发送和接收，进行网络的监控。</p>
<p>也许有人说使用标准库的UDPConn不就行了。如果是普通的UDP程序，的确没问题，如果对于一些特殊的需求，比如监听1000个UDP端口，有上万个节点定时的发送监控的数据，我们不太可能建立1000*1万个UDPConn,所以这里我采用rawsocket通讯的方式。</p>
<p>RawSocket是是标准Berkeley socket的一部分，我们使用Go的标准库开发网络程序时，大部分场景都是使用封装好的数据报类型(UDPConn)或者流类型(TCPConn),但是如果想做更底层的一些网络编程的话，就需要使用到RawSocket了，比如更底层的TCP、UDP网络控制、ICMP、ARP等协议。不同的操作系统可能实现的RawSocket也不同，这里我们以Linux环境为例。</p>
<p>Linux man手册对RawSocket相关知识做了详细的介绍:<a href="https://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="external">socket(2)</a>、<a href="https://man7.org/linux/man-pages/man7/packet.7.html" target="_blank" rel="external">packet(7) </a>、<a href="https://man7.org/linux/man-pages/man7/raw.7.html" target="_blank" rel="external">raw(7)</a>,本文不再做转述，这也不是本文的重点。</p>
<p>依照Linux文档，Linux 服务器中收到的包既=会传给内核网络模块，也会传给RawSocket。所以你使用RawSocket的时候有时候需要注意，比如你在处理TCP的包时，可能Linux内核的网络程序已经把这个包处理了。</p>
<blockquote>
<p>Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or TCP which have a protocol module in the kernel.  In this case, the packets are passed to both the kernel module and the raw socket(s).  This should not be relied upon in portable programs, many other BSD socket implementation have limitations here.</p>
</blockquote>
<p>如果没有特殊的需求，我们直接就使用<a href="https://pkg.go.dev/net#ListenPacket" target="_blank" rel="external">net.ListenPacket</a>是实现一个RawSocket的程序。这个方法的签名如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ListenPacket(network, address <span class="typename">string</span>) (PacketConn, error)</div></pre></td></tr></table></figure>

<p>其中第一个参数<code>network</code>可以是<code>udp</code>、<code>udp4</code>、<code>udp6</code>、<code>unixgram</code>，也是可以<code>ip</code>、<code>ip4</code>、<code>ip6</code>加冒号再加一个协议号或者协议名，比如<code>ip:1</code>、<code>ip:icmp</code>，就可以你也处理什么协议。</p>
<h2 id="演示程序">演示程序</h2>
<h3 id="服务端程序">服务端程序</h3>
<p>服务端程序我们使用<code>conn, err := net.ListenPacket(&quot;ip4:udp&quot;, *addr)</code>监听本地地址上所有的UDP包，并启动一个goroutine去处理。处理程序中应该还有一个判断，就是检查UDP的端口是不是我们处理的端口，因为这里<code>net.ListenPacket</code>监听的是本地所有的UDP,可能有很多无用的UDP包都传入到用户态的程序中了。</p>
<p>这里我们使用gopacket对各种协议层的包的定义，方便解析(或创建)TCP/IP各层的网络协议。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">	<span class="string">"golang.org/x/net/bpf"</span></div><div class="line">	<span class="string">"golang.org/x/net/ipv4"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"s"</span>, <span class="string">"localhost"</span>, <span class="string">"server address"</span>)</div><div class="line">	port = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	stat         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">	lastStatTime = <span class="typename">int64</span><span class="number">(0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	cc := conn.(*net.IPConn)</div><div class="line">	cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">	cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	handleConn(conn)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.PacketConn) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">		n, remoteaddr, err := conn.ReadFrom(buffer)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		buffer = buffer[:n]</div><div class="line"></div><div class="line">		packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">		<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">		<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line">			udp, _ := udpLayer.(*layers.UDP)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">				data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>), <span class="typename">uint16</span>(udp.DstPort), <span class="typename">uint16</span>(udp.SrcPort), app.Payload())</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteaddr); err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">					conn.Close()</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="客户端程序">客户端程序</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, <span class="string">"127.0.0.1"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>),<span class="number"> 8972</span>,<span class="number"> 0</span>, []<span class="typename">byte</span>(<span class="string">"hello"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	remoteAddr := &net.IPAddr{IP: net.ParseIP(<span class="string">"127.0.0.1"</span>)}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteAddr); err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">		conn.Close()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	n, _, err := conn.ReadFrom(buffer)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	buffer = buffer[:n]</div><div class="line"></div><div class="line">	packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">	<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">	<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">			fmt.Printf(<span class="string">"reply: %s\n"</span>, app.Payload())</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端程序这里做了简化，写入一个<code>hello</code>,并读取服务端的返回。我们在做性能测试的时候，会使用循环不断的写入一个seq号，并检查服务端是否返回这个seq，以便计算丢包性能。并且还使用一个限流器进行限流，测试在一定的RPS情况下的丢包率。</p>
<h3 id="辅助方法">辅助方法</h3>
<p>下面是<code>EncodeUDPPacket</code>方法，用来产生一个UDP的包数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> codec</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> EncodeUDPPacket(localIP, remoteIP net.IP, localPort, remotePort <span class="typename">uint16</span>, payload []<span class="typename">byte</span>) ([]<span class="typename">byte</span>, error) {</div><div class="line">	ip := &layers.IPv4{</div><div class="line">		Version: <span class="number"> 4</span>,</div><div class="line">		TTL:     <span class="number"> 128</span>,</div><div class="line">		SrcIP:    localIP,</div><div class="line">		DstIP:    remoteIP,</div><div class="line">		Protocol: layers.IPProtocolUDP,</div><div class="line">	}</div><div class="line">	udp := &layers.UDP{</div><div class="line">		SrcPort: layers.UDPPort(localPort),</div><div class="line">		DstPort: layers.UDPPort(remotePort),</div><div class="line">	}</div><div class="line">	udp.SetNetworkLayerForChecksum(ip)</div><div class="line"></div><div class="line">	buf := gopacket.NewSerializeBuffer()</div><div class="line">	opts := gopacket.SerializeOptions{</div><div class="line">		ComputeChecksums: <span class="constant">true</span>,</div><div class="line">		FixLengths:       <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	err := gopacket.SerializeLayers(buf, opts, udp, gopacket.Payload(payload))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> buf.Bytes(), err</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="性能问题">性能问题</h2>
<p>虽然上面的程序运行的很好，但是在并发量比较大的情况，会有一些问题。</p>
<p>上面我们启动了一个goroutine去读取这个包，这里是一个性能瓶颈，最终服务端只能使用一个核去处理RawSocket的包。</p>
<p>即使创建多个goroutine去读取这个PacketConn,也是没有用的，因为这个PacketConn是唯一的，它是一个瓶颈，多个goroutine有时候还不如一个goroutine去读取更好。</p>
<p>那么能不能调用多次<code>net.ListenPacket(&quot;ip4:udp&quot;, *addr)</code>,生成多个RawSocket并发的去处理呢？</p>
<p>貌似看起来可以，但是实际上，这多个RawSocket都会读取到相同的UDPPacket，而不是负载均衡平摊到多个Socket上。所以多个RawSocket不但没用，反而更加耗费服务器的资源了。</p>
<p>实际测试也就能达到2~3万的吞吐，并发量再高就出现丢包的情况了。</p>
<p>但是没有办法了么？</p>
<p>也不是。这里我们可以看到，主要性能瓶颈是我们上面的程序没有办法做到负载均衡，利用多核的能力并发的去处理。第二个性能瓶颈就是程序监听了本机所有的UDP的packet,交给用户态程序筛选去处理，这里面有很多我们不需要的包。</p>
<p>这两个性能问题我们都可以通过BPF进行处理。</p>
<h2 id="BPF进行包过滤">BPF进行包过滤</h2>
<p>经典的BPF早在1994就出现了，虽然大家现在都在谈论扩展的BPF(eBPF),但是经典的BPF依然可以发挥它的威力。</p>
<p>你可能没有在编程中应用过BPF,但是我相信你在实际工作中一定和它发生过什么。</p>
<p>比如你使用tcpdump在监听网络的传输情况时，经常会加上过滤手段，比如下面的命令是只监听tcp协议的8080端口:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -nn -vvvv -i any <span class="string">"tcp port 8080"</span></div></pre></td></tr></table></figure>

<p>tcpdump其实就是把<code>tcp port 8080</code>生成过滤器，在内核中对包进行过滤，只把过滤后的包打筛选出来。</p>
<p>其实你可以通过下面的命令查看编译的过滤的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@lab ~]<span class="comment"># tcpdump -d "tcp port 8080"</span></div><div class="line">(<span class="number">000</span>) ldh      [<span class="number">12</span>]</div><div class="line">(<span class="number">001</span>) jeq      <span class="comment">#0x86dd          jt 2	jf 8</span></div><div class="line">(<span class="number">002</span>) ldb      [<span class="number">20</span>]</div><div class="line">(<span class="number">003</span>) jeq      <span class="comment">#0x6             jt 4	jf 19</span></div><div class="line">(<span class="number">004</span>) ldh      [<span class="number">54</span>]</div><div class="line">(<span class="number">005</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 6</span></div><div class="line">(<span class="number">006</span>) ldh      [<span class="number">56</span>]</div><div class="line">(<span class="number">007</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 19</span></div><div class="line">(<span class="number">008</span>) jeq      <span class="comment">#0x800           jt 9	jf 19</span></div><div class="line">(<span class="number">009</span>) ldb      [<span class="number">23</span>]</div><div class="line">(<span class="number">010</span>) jeq      <span class="comment">#0x6             jt 11	jf 19</span></div><div class="line">(<span class="number">011</span>) ldh      [<span class="number">20</span>]</div><div class="line">(<span class="number">012</span>) jset     <span class="comment">#0x1fff          jt 19	jf 13</span></div><div class="line">(<span class="number">013</span>) ldxb     <span class="number">4</span>*([<span class="number">14</span>]&<span class="number">0</span>xf)</div><div class="line">(<span class="number">014</span>) ldh      [x + <span class="number">14</span>]</div><div class="line">(<span class="number">015</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 16</span></div><div class="line">(<span class="number">016</span>) ldh      [x + <span class="number">16</span>]</div><div class="line">(<span class="number">017</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 19</span></div><div class="line">(<span class="number">018</span>) ret      <span class="comment">#262144</span></div><div class="line">(<span class="number">019</span>) ret      <span class="comment">#0</span></div></pre></td></tr></table></figure>

<p>这代表什么意思的？BPF定义了有限一些指令，可以在VM中，对包进行过滤.<br>第一行是加载包的偏移量(offset 12个字节)，第二行是检查是否是IPV6，如果是跳到<code>002</code>,如果不是跳到<code>008</code>。我们关注一下IPV4。<br><code>008</code>那一行是判断是否是ipv4，如果是跳到<code>009</code>。<code>009</code>加载偏移量23处的一个字节，它是ip proto,<code>010</code>行判断ip proto是否是TCP,如果是跳到<code>011</code>。<br>接下来判断flags，以便确定数据的地址。<br><code>014</code>行和<code>016</code>行是读取TCP协议中的源端口和目的端口，如果等于<code>8080</code>(<code>0x1f90</code>),则最大返回包大小262144个字节，否则就丢弃这个包。</p>
<p>当然tcpdump的生成的代码相当的严谨了我我们实际写的时候，如果确定是ipv4的包，包也没什么扩展的话，写出的代码要比这个简单。但是我们实际在应用BPF的时候不妨采用tcpdump生成的代码，不会出错。</p>
<p>使用<code>-dd</code>可以显示成c代码片段，使用<code>-ddd</code>显示为十进制数。我们看一下<code>-dd</code>的效果，因为这个结果我们可以用来转换成Go的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@lab ~]# tcpdump -dd <span class="string">"tcp port 8080"</span></div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000c },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 6</span>,<span class="number"> 0</span>x000086dd },</div><div class="line">{<span class="number"> 0</span>x30,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000014 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 15</span>,<span class="number"> 0</span>x00000006 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000036 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 12</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000038 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 10</span>,<span class="number"> 11</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 10</span>,<span class="number"> 0</span>x00000800 },</div><div class="line">{<span class="number"> 0</span>x30,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000017 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 8</span>,<span class="number"> 0</span>x00000006 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000014 },</div><div class="line">{<span class="number"> 0</span>x45,<span class="number"> 6</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001fff },</div><div class="line">{<span class="number"> 0</span>xb1,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000e },</div><div class="line">{<span class="number"> 0</span>x48,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000e },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 2</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x48,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000010 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 1</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x6,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00040000 },</div><div class="line">{<span class="number"> 0</span>x6,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000000 },</div></pre></td></tr></table></figure>

<p>实际上，<a href="https://pkg.go.dev/golang.org/x/net/bpf" target="_blank" rel="external">x/net/bpf</a>提供了相应的方法，可以更容易的编写BPF程序，序列化和反序列化。比如编写一个过滤出目的端口等于8972的所有的包，我们可以简单写成如下的格式(考虑到简单形式，我们只考虑了IPV4和普通IP包的形式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">//加载目的端口到寄存器</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val:<span class="number"> 8972</span>, SkipFalse:<span class="number"> 1</span>}, <span class="comment">// 如果值等于8972的话,执行下一行，否则跳过下一行</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},   <span class="comment">// 返回这个包的最多0xffff的字节的数据</span></div><div class="line"></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">// 返回零个字节，也就是忽略这个包</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以写一个程序，把tcpdump生成的代码转换成bpf的RawInstruction指令:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> parse(data <span class="typename">string</span>) (raws []bpf.RawInstruction) {</div><div class="line">	lines := strings.Split(data, <span class="string">"\n"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, line := <span class="keyword">range</span> lines {</div><div class="line">		line = strings.TrimSpace(line)</div><div class="line">		<span class="keyword">if</span> line == <span class="string">""</span> {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		line = strings.TrimPrefix(line, <span class="string">"{"</span>)</div><div class="line">		line = strings.TrimSuffix(line, <span class="string">" },"</span>)</div><div class="line">		items := strings.Split(line, <span class="string">","</span>)</div><div class="line">		<span class="comment">// assert len(items) == 4</span></div><div class="line"></div><div class="line">		raw := bpf.RawInstruction{</div><div class="line">			Op: <span class="typename">uint16</span>(numToInteger(items<span class="number">[0</span>])),</div><div class="line">			Jt: <span class="typename">uint8</span>(numToInteger(items<span class="number">[1</span>])),</div><div class="line">			Jf: <span class="typename">uint8</span>(numToInteger(items<span class="number">[2</span>])),</div><div class="line">			K:  <span class="typename">uint32</span>(numToInteger(items<span class="number">[3</span>])),</div><div class="line">		}</div><div class="line"></div><div class="line">		raws = <span class="built_in">append</span>(raws, raw)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> raws</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> numToInteger(s <span class="typename">string</span>) <span class="typename">int</span> {</div><div class="line">	s = strings.TrimSpace(s)</div><div class="line">	<span class="keyword">if</span> strings.HasPrefix(s, <span class="string">"0x"</span>) {</div><div class="line">		s := strings.Replace(s, <span class="string">"0x"</span>, <span class="string">""</span>,<span class="number"> -1</span>)</div><div class="line">		result, _ := strconv.ParseInt(s,<span class="number"> 16</span>,<span class="number"> 64</span>)</div><div class="line">		<span class="keyword">return</span> <span class="typename">int</span>(result)</div><div class="line">	}</div><div class="line"></div><div class="line">	result, _ := strconv.ParseInt(s,<span class="number"> 10</span>,<span class="number"> 64</span>)</div><div class="line">	<span class="keyword">return</span> <span class="typename">int</span>(result)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>好了所有这一切都准备好了，背景知识介绍了，当前的RawSocket程序的性能瓶颈也介绍了，那么如果解决性能瓶颈呢。</p>
<p>第一个性能瓶颈我们可以生成多个goroutine，每个goroutine负责过滤一部分的包，这样就实现了负载均衡。比如根据客户端的IP进行过滤，或者服务端监听1000个端口，每个goroutine只负责一部分的端口。而可以根据客户端的源端口进行过滤等等。总是，通过BPF过滤，一个goroutine只负责一部分的packet，实现了多核的处理。</p>
<p>第二个瓶颈随着第一个问题也迎刃而解。因为BPF只过滤我们的特定的端口，其它端口的UDP包不会从内核态复制到用户态，减少了无用包的处理。</p>
<p>要为标准库的PacketConn设置BPF过滤，也有多种办法，比如调用<code>syscall.SetsockoptInt</code>进行设置。但是<a href="https://pkg.go.dev/golang.org/x/net/ipv4#PacketConn.SetBPF" target="_blank" rel="external">golang.org/x/net/ipv4</a>提供了SetBPF方法，我们可以直接将标准库的PacketConn转换成ipv4.PacketConn,再进行设置。</p>
<p>比如上面的server程序，我们可以修改为使用BPF在内核态过滤:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">	<span class="string">"golang.org/x/net/bpf"</span></div><div class="line">	<span class="string">"golang.org/x/net/ipv4"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"s"</span>, <span class="string">"localhost"</span>, <span class="string">"server address"</span>)</div><div class="line">	port = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	stat         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">	lastStatTime = <span class="typename">int64</span><span class="number">(0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	cc := conn.(*net.IPConn)</div><div class="line">	cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">	cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	pconn := ipv4.NewPacketConn(conn)</div><div class="line">	<span class="keyword">var</span> assembled []bpf.RawInstruction</div><div class="line">	<span class="keyword">if</span> assembled, err = bpf.Assemble(filter); err != <span class="constant">nil</span> {</div><div class="line">		log.Print(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	pconn.SetBPF(assembled)</div><div class="line"></div><div class="line">	handleConn(conn)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.PacketConn) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">		n, remoteaddr, err := conn.ReadFrom(buffer)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		buffer = buffer[:n]</div><div class="line"></div><div class="line">		packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">		<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">		<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line">			udp, _ := udpLayer.(*layers.UDP)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">				data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>), <span class="typename">uint16</span>(udp.DstPort), <span class="typename">uint16</span>(udp.SrcPort), app.Payload())</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteaddr); err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">					conn.Close()</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">// load the destination port</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val: <span class="typename">uint32</span>(*port), SkipFalse:<span class="number"> 1</span>}, <span class="comment">// if Val != 8972 skip next instruction</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},                                      <span class="comment">// return 0xffff bytes (or less) from packet</span></div><div class="line"></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">// return 0 bytes, effectively ignore this packet</span></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>经典的bpf(classical Berkeley Packet Filter) 是非常好用的一个技术，在一些特殊的Go底层网络编程的场合，可以很好的提高性能。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
