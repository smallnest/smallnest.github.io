<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2024-03-26T09:54:52.390Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[goroutine调度器揭秘 2]]></title>
    <link href="https://colobu.com/2024/03/24/goroutine-scheduler-2/"/>
    <id>https://colobu.com/2024/03/24/goroutine-scheduler-2/</id>
    <published>2024-03-24T09:10:48.000Z</published>
    <updated>2024-03-26T09:37:28.187Z</updated>
    <content type="html"><![CDATA[<p>我翻译了<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a>, 这篇文章发表于1月2号，作者在文章最后说：</p>
<blockquote>
<p>在接下来的部分,我们将更深入地探讨抢占式调度,并分析调度程序在运行期间所采取的每一步骤。</p>
</blockquote>
<a id="more"></a>
<p>接下来快三个月了，也没有下文了，貌似鸽了。<br>为了不让读者等待，我接下来把相关的内容补上。</p>
<p>当然，Go的调度器也在演化之中，你看几年前的代码，或者几年后的代码，可能就没有办法一一对应了，我们以1.21.1版本讲解。</p>
<h2 id="schedule_函数">schedule 函数</h2>
<p>函数<code>schedule</code>执行一次调度器循环，找到一个可运行的goroutine并执行它。这个函数永不返回。当一个 <code>goroutine</code> 执行完毕，它会再次调用 <code>schedule</code> 函数来选择下一个要执行的 <code>goroutine</code>。这就是为什么 <code>schedule</code> 函数看起来像是永不返回：它总是在选择和执行 <code>goroutine</code>，除非没有更多的 <code>goroutine</code> 可以执行。</p>
<p><code>schedule</code> 函数并不是通过常规的函数调用栈来调度 <code>goroutine</code> 的。当一个 <code>goroutine</code> 结束执行，它并不是通过返回到 <code>schedule</code> 函数来调度下一个 <code>goroutine</code>，而是通过一种称为 &quot;栈切换&quot; 的技术。</p>
<p>在具体实现上，每个 <code>goroutine</code> 都有自己的栈，当它开始执行时，运行时系统会将当前的栈指针切换到这个 <code>goroutine</code> 的栈，当它结束执行时，运行时系统会将栈指针切换回原来的栈（通常是所谓的 &quot;系统栈&quot; 或 &quot;调度器栈&quot;）。这样，每个 <code>goroutine</code> 的函数调用栈都是独立的，它们不会互相影响，也不会导致栈溢出。</p>
<p>因此，尽管从代码上看 <code>schedule</code> 函数像是在递归调用，但实际上它并不会导致栈溢出，因为每次调用 <code>schedule</code> 都是在一个新的 <code>goroutine</code> 的栈上，而不是在同一个函数调用栈上。</p>
<p><a href="https://github.com/golang/go/blob/c2c4a32f9e57ac9f7102deeba8273bcd2b205d3c/src/runtime/proc.go#L3857" target="_blank" rel="external">proc.go#schedule</a></p>
<p>以下是一些可能会调用 schedule 函数的函数和它们的使用场景：</p>
<ol>
<li><code>goexit</code>(goexit1-&gt;goexit0)：当一个 <code>goroutine</code> 结束执行时，它会调用 <code>goexit</code> 函数来清理资源并退出。在 <code>goexit</code> 函数中，会调用 <code>schedule</code> 函数来选择下一个要执行的 <code>goroutine</code>。</li>
<li><code>preemptPark</code>：<code>preemptPark</code> 函数被用于实现抢占式调度。当运行时系统决定当前正在执行的 <code>goroutine</code> 需要被抢占时，它会设置 goroutine 的状态为 <code>_Gpreempted</code>，并调用 <code>preemptPark</code> 函数将 <code>goroutine</code> 挂起。</li>
<li><code>park_m</code>: <code>park_m</code> 函数被用于将当前的操作系统线程（M）挂起，直到有新的 <code>goroutine</code> 可以运行。比如没有<code>goroutine</code>可运行时，或者因为每个条件阻塞时。</li>
<li><code>goschedImpl</code>：调用<code>runtime.Gosched</code> 函数时，它被用于让当前的 <code>goroutine</code> 主动让出 CPU，让其他 <code>goroutine</code> 有机会执行。</li>
<li><code>goyield_m</code>: 类似<code>runtime.Gosched</code> 函数, <code>goyield_m</code> 函数也被用于让当前的 <code>goroutine</code> 主动让出 CPU，让其他 <code>goroutine</code> 有机会执行。但是它会把当前的goroutine放到local run queue,而不像<code>Gosched</code>放到global run queue。</li>
<li><code>mstart1</code>：创建的操作系统线程（M）开始执行时被调用的。b比如新创建M时，或者M不够用的时候。它的主要任务是初始化线程的环境，并开始执行调度循环。</li>
<li><code>exitsyscall0</code>: <code>exitsyscall0</code> 函数在一个 <code>goroutine</code> 完成<strong>系统调用</strong>并准备返回到 Go 空间时被调用。系统调用的goroutine返回后，会尝试找一个空闲的P去执行当前的G(和M), 否则会把当前的G放到global run queue中。</li>
</ol>
<p>这些函数都是 Go 语言运行时系统中的内部函数，它们的具体实现可能会因 Go 语言的版本和运行时系统的配置而不同。</p>
<p>在<code>schedule</code>函数中，重要的是调用了<code>findRunnable</code>, 找到一个可以执行的<code>goroutine</code>。必须要找到一个，否则会阻塞直到找到一个<code>goroutine</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></div></pre></td></tr></table></figure>

<p>那么，接下来我们跟踪<code>findRunnable</code>函数,了解它的每一个步骤，这是调度器工作的重点。</p>
<h2 id="findRunnable_函数">findRunnable 函数</h2>
<p><img src="findRunnable.svg" alt=""></p>
<p><code>findRunnable</code> 函数是调度器的核心函数之一，它的主要任务是找到一个可以执行的 <code>goroutine</code>。</p>
<p><code>findRunnable</code> 函数的实现非常复杂，因为它需要考虑很多因素，比如当前的 <code>goroutine</code> 是否需要被抢占，当前的 <code>goroutine</code> 是否需要让出 CPU，当前的 <code>goroutine</code> 是否需要被挂起，当前的 <code>goroutine</code> 是否需要被唤醒，当前的 <code>goroutine</code> 是否需要被移动到其他的 <code>P</code>，等等。我们暂时不考虑这些复杂的情况，只关注最简单的情况：怎么找到一个可以执行的 <code>goroutine</code>。</p>
<h3 id="可以寻找的goroutine">可以寻找的goroutine</h3>
<p>重点它寻找一个可以执行的<code>goroutine</code>，这些goroutine都是存在什么地方内？</p>
<ul>
<li><code>local run queue</code>: 每个P都有一个local run queue，用于存放当前P上的goroutine。</li>
<li><code>global run queue</code>: 所有的P共享一个global run queue，用于存放所有的goroutine。</li>
<li><code>netpoll</code>: 用于处理网络事件的goroutine。</li>
<li><code>timer</code>: 用于处理定时器事件的goroutine。</li>
<li><code>syscall</code>: 用于处理系统调用的goroutine。</li>
</ul>
<p>处于性能优化的目的，每个处理器（P）确实包含一个<strong>四叉堆</strong>（heap），用于保存定时器（timer）。。<br>每个定时器都有一个到期时间，当到达这个时间时，定时器关联的函数就会被调用。四叉堆的结构使得运行时系统可以快速地找到最早到期的定时器，这对于定时器的处理非常重要。<br>当你在 Go 代码中使用 time.After，time.Sleep 或 time.AfterFunc 等函数时，就会创建一个定时器，并将其添加到当前 P 的 timers 四叉堆中。</p>
<p>全局还有一个网络轮询器（netpoller），它用于处理网络事件。每个findRunnable调用的时候也可能去访问它。</p>
<h3 id="findRunnable_寻找goroutine的步骤">findRunnable 寻找goroutine的步骤</h3>
<p><img src="findRunnable-flowchart.svg" alt=""></p>
<p><code>findRunnable</code>函数寻找goroutine过程既复杂又简单。<br>说它复杂，是因为它需要考虑很多因素，做各种检查，执行不同的策略去寻找goroutine。<br>说它简单，是因为它的逻辑很清晰，只是一步一步地检查，直到找到一个可以执行的goroutine。一旦找到goroutine，就直接返回。</p>
<p>根据这个函数的实现，我把大致的逻辑画了一个流程图，如上图所示，下面我们一步一步地解释这个流程图，忽略其中的一些条件检查，我们主要关注它的大的逻辑。</p>
<ol>
<li>首先定义了一个<code>top</code>标签，因为在后面的代码中，需要从头开始重新检查，类似一个for循环，但是这里使用<code>goto</code>语句更清晰。</li>
<li>检查Timer,如果有到期的timer,则执行timer相关的goroutine。如果程序中有大量的Timer也不太好，如果Timer大量的增删或者日期变化，会导致性能问题。</li>
<li>检查tracer, 跟踪调用的goroutine，如果符合条件，执行。</li>
<li>检查是否有gc worker要执行，如果有，执行。</li>
<li>如果tick(嘀嗒)计数器到了61次，并且global run queue中有goroutine，那么执行global run queue中的goroutine。</li>
<li>如有必要，唤醒finalizer</li>
<li>如有必要，执行cgo_yield，让执行cgo系统调用的goroutine让出CPU。</li>
<li>检查local run queue, 如果有goroutine，执行。</li>
<li>再次检查global run queue, 如果有goroutine，执行。</li>
<li>检查netpoll, 如果网络事件需要处理，唤醒相关的goroutine。</li>
<li>从其他P的local run queue中偷取goroutine，如果有goroutine，执行。</li>
<li>如有必要，执行idle-time marking, 执行GC的标记阶段。</li>
<li>wasm相关的逻辑处理</li>
<li>再次检查global run queue, 如果有goroutine，执行。</li>
<li>如有需要，再次从头检查</li>
<li>再次检查netpoll</li>
<li>如果没有找到可以执行的goroutine，阻塞等待</li>
</ol>
<p>总体上看， findRunnable 函数实现了一个通用的goroutine调度逻辑。</p>
<p>也许，针对不同的场景，你可以在这个调度器上微调，尝试获取更高性能调度：</p>
<ol>
<li>调整寻找goroutine的顺序、频次等</li>
<li>进行goroutine的优先级调度、进行NUMA等CPU架构的优化</li>
</ol>
<p>这样，我们把原作者的许诺的分享中的调度步骤的内容补上了，接下来补上最后一部分的内容：抢占式调度。请关注公众号 “鸟窝聊技术” 获取最新文章。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我翻译了<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a>, 这篇文章发表于1月2号，作者在文章最后说：</p>
<blockquote>
<p>在接下来的部分,我们将更深入地探讨抢占式调度,并分析调度程序在运行期间所采取的每一步骤。</p>
</blockquote>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[goroutine调度器揭秘]]></title>
    <link href="https://colobu.com/2024/03/19/goroutine-scheduler-revealed/"/>
    <id>https://colobu.com/2024/03/19/goroutine-scheduler-revealed/</id>
    <published>2024-03-19T15:45:25.000Z</published>
    <updated>2024-03-26T09:37:28.192Z</updated>
    <content type="html"><![CDATA[<p>你以前可能听说过 Goroutine 调度器，但你对它的工作原理了解多少？它如何将 goroutine 与线程配对？</p>
<p>原文:<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a><br><a id="more"></a></p>
<p><img src="behind-goroutines.webp" alt=""></p>
<p>不用着急理解上面的图像,因为我们要从最基本的开始。</p>
<p>goroutine 被分配到线程中运行,这由 goroutine 调度器在后台处理。根据我们之前的讨论,我们了解到以下关于 goroutine 的几点:</p>
<ul>
<li>就原始执行速度而言,goroutine 并不一定比线程更快,因为它们需要在实际线程上运行。</li>
<li>goroutine 真正的优势在于上下文切换、内存占用、创建和销毁的成本等方面。</li>
</ul>
<p>你可能以前听说过 goroutine 调度器,但我们真正了解它的工作原理吗?它是如何将 goroutine 与线程配对的?</p>
<p>现在让我们一步一步地分解调度器的工作原理。</p>
<h2 id="goroutine_M:N_调度器模型">goroutine M:N 调度器模型</h2>
<p>Go 团队真的为我们简化了并发编程,想想看:创建一个 goroutine 只需要在函数前加上 go 关键字就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> doWork()</div></pre></td></tr></table></figure>

<p>但在这个简单的步骤背后,有一个更深层次的系统在运作。</p>
<p>一开始,Go 就没有简单地为我们提供线程。相反,中间有一个助手,即 goroutine 调度器,它是 Go 运行时的关键部分。</p>
<p><img src="scheduler.webp" alt=""></p>
<p>那么<code>M:N</code>这个标签是什么意思呢?</p>
<p>它体现了Go调度器在将<code>M</code>个goroutine映射到<code>N</code>个内核线程方面的作用,形成了<code>M:N</code>模型。操作系统线程的数量可以多于CPU核心数,就像goroutine的数量也可以多于操作系统线程一样。</p>
<p>在深入探讨调度器之前,让我们先区分一下经常混淆的两个概念:并发和并行。</p>
<ul>
<li><strong>并发</strong>: 指同时处理多个任务,这些任务都在运行,但不一定在同一时间运行。</li>
<li><strong>并行</strong>: 指多个任务在同一时刻真正同时运行,通常使用多个CPU核心。<br><img src="cp.webp" alt=""></li>
</ul>
<p>让我们看看 Go Scheduler 如何使用线程。</p>
<h2 id="PMG模型">PMG模型</h2>
<p>在我们解开内部工作原理之前,让我们先解释一下P、M和G分别代表什么意思。</p>
<h3 id="G_(goroutine)">G (goroutine)</h3>
<p>goroutine是Go中最小的执行单元,类似于一个轻量级线程。</p>
<p>在Go运行时,它由一个名为<code>g</code>的struct表示。一旦创建,它就会被放入逻辑处理器P的本地可运行队列(或全局队列),之后P会将它分配给一个实际的内核线程(M)。</p>
<p>goroutine通常存在三种主要状态:</p>
<ul>
<li><strong>Waiting</strong>:在这个阶段,goroutine处于静止状态,可能是由于等待某个操作(如channel或锁),或者是被系统调用阻塞。</li>
<li><strong>Runnable</strong>:goroutine已准备就绪,但尚未开始运行,它正在等待轮到在线程(M)上运行。</li>
<li><strong>Running</strong>:现在goroutine正在线程(M)上积极执行。它将一直运行直到任务完成,除非调度器中断它或其他事物阻碍了它的运行。</li>
</ul>
<p><img src="goroutine-states.webp" alt=""></p>
<p>goroutine不是一次性使用后就被丢弃的。</p>
<p>相反,当启动一个新的goroutine时,Go的运行时会从goroutine池中选择一个,如果池中没有,它会创建一个新的。然后,这个新的goroutine会加入某个P的可运行队列。</p>
<h3 id="P(逻辑处理器)">P(逻辑处理器)</h3>
<p>在Go调度器中,当我们提到&quot;处理器&quot;时,指的是一个逻辑实体,而不是物理实体。</p>
<p>默认情况下,P的数量设置为可用的CPU核心数,你可以使用runtime.GOMAXPROCS(int)检查或更改这些处理器的数量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">runtime.GOMAXPROCS<span class="number">(0</span>) <span class="comment">// get the current allowed number of logical processors</span></div><div class="line"></div><div class="line"><span class="comment">// Output: 8 (depends on your machine)</span></div></pre></td></tr></table></figure>

<p>如果你想修改P的数量,最好在应用程序启动时就这样做,因为如果在运行时修改,它会导致<code>STW</code>(stopTheWorld),所有操作都会暂停,直到处理器大小调整完成。</p>
<p>每个P都有自己的可运行goroutine列表,称为本地运行队列(Local Run Queue),最多可容纳256个goroutine。<br><img src="p.webp" alt=""></p>
<p>如果P的队列已满(256个goroutine),还有一个名为全局运行队列(Global Run Queue)的共享队列,不过我们稍后再讨论这个。</p>
<blockquote>
<p>&quot;那么,&#39;P&#39;的数量真正显示了什么呢?&quot;</p>
</blockquote>
<p>它表示可以并发运行的goroutine数量 - 想象它们并排运行。</p>
<h3 id="M(机器线程_-_操作系统线程)">M(机器线程 - 操作系统线程)</h3>
<p>一个典型的Go程序最多可使用10,000个线程。</p>
<p>没错,我说的是线程而不是goroutine。如果超过这个限制,你的Go应用程序就有崩溃的风险。</p>
<blockquote>
<p>&quot;线程是何时创建的呢?&quot;</p>
</blockquote>
<p>想象这种情况:一个goroutine处于可运行状态并需要一个线程。</p>
<p>如果所有线程都已被阻塞,可能是由于系统调用或不可抢占的操作,会发生什么?在这种情况下,调度器会介入并为该goroutine创建一个新线程。</p>
<p>(<em>需要注意的一点是:如果一个线程只是在进行昂贵的计算或长时间运行的任务,它不被视为陷入困境或被阻塞</em>)</p>
<p>如果你想改变默认的线程限制,可以使用<code>runtime/debug.SetMaxThreads()</code>函数,它允许你设置Go程序可使用的最大操作系统线程数。</p>
<p>另外,值得一提的是,线程会被重用,因为创建或删除线程是一个资源密集型的操作。</p>
<h3 id="MPG是如何协同工作的">MPG是如何协同工作的</h3>
<p>让我们通过以下步骤一步步理解M、P和G是如何协同工作的。</p>
<p>在这里我不会深入探讨每一个细节,但在后续的文章中会更深入地探讨。如果你对此感兴趣,请关注我的公众号。</p>
<p><img src="scheduler-works.webp" alt=""></p>
<ol>
<li>初始化一个goroutine:使用go func()命令时,Go运行时会新建一个goroutine或从池中选择一个已存在的goroutine。</li>
<li>入队排位:goroutine会寻找一个队列来加入,如果所有逻辑处理器(P)的本地队列都已满,该goroutine会被放入全局队列。</li>
<li>线程配对:这就是M发挥作用的地方。它获取一个P,并开始从P的本地队列处理goroutine。当M与这个goroutine交互时,其关联的P就会被占用,无法分配给其他M。</li>
<li>窃取行为:如果一个P的队列被耗尽,M会试图从另一个P的队列&quot;借用&quot;一半可运行的goroutine。如果失败,它会检查全局队列,然后是网络轮询器(参见下面的&quot;窃取过程&quot;图)。</li>
<li>资源分配:在M选择一个goroutine(G)后,它会为运行这个G获取所需的所有资源。</li>
</ol>
<blockquote>
<p>&quot;如果一个线程被阻塞了怎么办?&quot;</p>
</blockquote>
<p>如果一个goroutine启动了一个需要一段时间的系统调用(比如读取文件),M会一直等待。</p>
<p>但调度器不喜欢一直等待,它会将被阻塞的M从它的P上分离,然后将队列中另一个可运行的goroutine连接到一个新的或已存在的M上,M再与P团队合作。<br><img src="blocked.webp" alt=""></p>
<h3 id="窃取过程">窃取过程</h3>
<p>当一个线程(M)完成了它的任务,没有其他事情可做时,它不会就这样闲置。</p>
<p>相反,它会主动寻找更多工作,方法是查看其他处理器并接手它们一半的任务,让我们来分解一下这个过程:</p>
<p><img src="steal.webp" alt=""></p>
<ol>
<li>每61个嘀嗒,一个M会检查全局可运行队列,以确保公平执行。如果在全局队列中找到了可运行的goroutine,就停止。</li>
<li>该线程M现在会检查与它所在的处理器P相连的本地运行队列,看看有没有可运行的goroutine需要处理。</li>
<li>如果该线程发现它的队列为空,它就会查看全局队列,看看是否有任何等待中的任务。</li>
<li>然后,该线程会向网络轮询器询问是否有任何与网络相关的工作。</li>
<li>如果该线程在检查完网络轮询器后仍然没有找到任何任务,它就会进入主动搜索模式,我们可以将其视为自旋状态。</li>
<li>在这种状态下,该线程会尝试从其他处理器的队列中&quot;借用&quot;任务。</li>
<li>经过这些步骤后,如果该线程仍然没有找到任何工作,它就会停止主动搜索。</li>
<li>现在,如果有新的任务到来,并且有空闲的处理器没有正在搜索的线程,另一个线程就可以开始工作。</li>
</ol>
<p>需要注意的一点是,全局队列实际上被检查了两次:一次是每61个嘀嗒检查一次以保证公平性,另一次是在本地队列为空时检查。</p>
<blockquote>
<p>&quot;如果M已与其P绑定,它怎么能从其他处理器获取任务呢?M会改变它的P吗?&quot;</p>
</blockquote>
<p>答案是不会。</p>
<p>即使M从另一个P的队列中获取任务,它也是使用原来的P来运行该任务。因此,尽管M获取了新任务,但它仍然忠于自己的P。</p>
<blockquote>
<p>&quot;为什么是61?&quot;</p>
</blockquote>
<p>在设计算法时,尤其是哈希算法时,通常会选择素数,因为素数除了1和自身之外没有其他因子。</p>
<p>这可以减少出现模式或规律性的可能性,从而避免发生&quot;冲突&quot;或其他不希望出现的行为。</p>
<p>如果时间过短,系统可能会频繁浪费资源检查全局运行队列。如果时间过长,goroutine可能会在执行前过度等待。</p>
<h3 id="网络轮询器(Network_Poller)">网络轮询器(Network Poller)</h3>
<p>我们还没有太多讨论这个网络轮询器,但它出现在了窃取过程的示意图中。</p>
<p>与Go调度器一样,网络轮询器也是Go运行时的一个组件,负责处理与网络相关的调用(例如网络I/O)。</p>
<p>让我们比较一下两种系统调用类型:</p>
<ul>
<li>与网络相关的系统调用: 当一个goroutine执行网络I/O操作时,它不会阻塞当前线程,而是向网络轮询器注册。轮询器异步等待操作完成,一旦完成,该goroutine就可以再次变为可运行状态,并在某个线程上继续执行。</li>
<li>其他系统调用: 如果它们可能会阻塞且没有由网络轮询器处理,它们可能会导致goroutine将执行卸载到一个操作系统线程上。只有该特定的操作系统线程会被阻塞,Go运行时调度器可以在其他线程上执行其他goroutine。</li>
</ul>
<p>在后续部分,我们将更深入地探讨抢占式调度,并分析调度器在运行过程中所采取的每一步骤。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>你以前可能听说过 Goroutine 调度器，但你对它的工作原理了解多少？它如何将 goroutine 与线程配对？</p>
<p>原文:<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a><br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更强大的Go执行跟踪能力]]></title>
    <link href="https://colobu.com/2024/03/18/execution-traces-2024/"/>
    <id>https://colobu.com/2024/03/18/execution-traces-2024/</id>
    <published>2024-03-18T13:32:11.000Z</published>
    <updated>2024-03-26T09:37:28.180Z</updated>
    <content type="html"><![CDATA[<p>Go官方博客:<a href="https://go.dev/blog/execution-traces-2024" target="_blank" rel="external">More powerful Go execution traces</a> by Michael Knyszek.</p>
<a id="more"></a>
<p><a href="https://go.dev/pkg/runtime/trace" target="_blank" rel="external">runtime/trace包</a>包含了一个强大的工具,可用于理解和调试Go程序。该功能允许我们在一段时间内对每个goroutine的执行进行跟踪。使用<a href="https://go.dev/pkg/cmd/trace" target="_blank" rel="external">go tool trace命令</a>(或优秀的开源工具<a href="https://gotraceui.dev/" target="_blank" rel="external">gotraceui</a>),我们就可以可视化和探索这些跟踪数据。</p>
<p>跟踪的魔力在于,它可以轻松揭示程序中一些通过其他方式很难发现的问题。例如,大量goroutine在同一个channel上阻塞导致的并发瓶颈,在CPU分析中可能很难发现,因为没有执行(<code>execution</code>)需要采样。但在执行跟踪中,执行的缺失将被清晰地呈现,而阻塞goroutine的堆栈跟踪会快速指出问题所在。</p>
<p><img src="gotooltrace.png" alt=""></p>
<p>Go开发者甚至可以在自己的程序中使用<a href="https://go.dev/pkg/runtime/trace#Task" target="_blank" rel="external">Task</a>、<a href="https://go.dev/pkg/runtime/trace#WithRegion" target="_blank" rel="external">Region</a>和<a href="https://go.dev/pkg/runtime/trace#Log" target="_blank" rel="external">Log</a>进行检测,从而将他们关注的高级问题与低级执行细节联系起来。</p>
<h2 id="问题">问题</h2>
<p>不幸的是,执行跟踪中丰富的信息往往难以获取。历史上,以下四个主要问题一直阻碍着跟踪的使用:</p>
<ul>
<li>跟踪开销很高。</li>
<li>跟踪的扩展性差,分析时可能会变得太大。</li>
<li>通常难以确定何时开始跟踪以捕获特定的错误行为。</li>
<li>由于缺乏解析和解释执行跟踪的公共包,只有最勇敢的gopher才能以编程方式分析跟踪。</li>
</ul>
<p>如果你在过去几年使用过跟踪,可能会因上述一个或多个问题而感到沮丧。但我们很高兴地分享,在最近两个Go版本中,我们在这四个领域都取得了重大进展。</p>
<h2 id="低开销跟踪">低开销跟踪</h2>
<p>在Go 1.21之前,对许多应用程序而言,跟踪的运行时开销约在<strong>10-20%</strong>的CPU范围内,这限制了跟踪只能被选择性使用,而不能像<code>CPU profiling</code>那样持续使用。事实证明,跟踪的大部分成本归结于traceback(跟踪回溯，在计算机编程中，它通常指的是程序运行时发生错误或异常时，系统生成的调用栈信息，用于帮助开发者定位问题的源头。)。运行时产生的许多事件都附带了堆栈跟踪,这对于实际识别关键执行时刻goroutine的行为是非常有价值的。</p>
<p>感谢<strong>Felix Geisendörfer</strong>和<strong>Nick Ripley</strong>在优化traceback效率方面所做的工作,执行跟踪的运行时CPU开销已经显著降低,对许多应用程序而言,降至1-2%。你可以在Felix关于这个主题的<a href="https://blog.felixge.de/reducing-gos-execution-tracer-overhead-with-frame-pointer-unwinding/" target="_blank" rel="external">精彩博文</a>中阅读更多相关工作的细节。</p>
<h2 id="可扩展的跟踪">可扩展的跟踪</h2>
<p>跟踪格式及其事件的设计侧重于相对高效的发送,但需要工具来解析并维护整个跟踪的状态。分析数百MB的跟踪可能需要几GB的内存!</p>
<p>这个问题从根本上说是由于跟踪生成的方式造成的。为了保持运行时开销低,所有事件都被写入类似线程本地缓冲区。但这意味着事件出现的顺序与真实发生的顺序不一致,跟踪工具需要负担重任来弄清楚真正发生的情况。</p>
<p>在保持低开销的同时使跟踪可扩展的关键在于,偶尔分割正在生成的跟踪。每个分割点的行为有点像同时禁用和重新启用跟踪。到目前为止的所有跟踪数据代表一个完整且独立的跟踪,而新的跟踪数据将无缝地从中断处继续。</p>
<p>你可能已经想到,解决这个问题需要<a href="https://go.dev/issue/60773" target="_blank" rel="external">反思和重写运行时中跟踪实现的大量基础部分</a>。我们很高兴地说,这项工作在Go 1.22中完成并现已正式推出。<a href="https://go.dev/doc/go1.22#runtime/trace" target="_blank" rel="external">重写带来了许多良好的改进</a>,包括对go tool trace命令的一些改进。如果你有兴趣,所有详细内容都在<a href="https://github.com/golang/proposal/blob/master/design/60773-execution-tracer-overhaul.md" target="_blank" rel="external">设计文档</a>中。</p>
<p>(注:go tool trace仍会将整个跟踪加载到内存中,但对于由Go 1.22+程序生成的跟踪,<a href="https://go.dev/issue/65315" target="_blank" rel="external">移除此限制</a>现已变为可行。)</p>
<h2 id="飞行记录">飞行记录</h2>
<p>假设你在开发一个web服务,一个RPC花费了非常长的时间。当你意识到RPC已经运行很久时,你无法在那时开始跟踪,因为导致请求变慢的根本原因已经发生并且没有被记录下来。</p>
<p>有一种称为飞行记录(<code>flight recording</code>)的技术可以帮助解决这个问题,你可能已经在其他编程环境中接触过了。飞行记录的思路是持续开启跟踪,并一直保留最新的跟踪数据,以防万一。然后,一旦发生有趣的事情,程序就可以直接写出它所拥有的数据!</p>
<p>在可以分割跟踪之前,这基本上是行不通的。但由于低开销使得连续跟踪变得可行,而且现在运行时可以随时分割跟踪,因此实现飞行记录变得很直接。</p>
<p>因此,我们很高兴地宣布在<a href="https://go.dev/pkg/golang.org/x/exp/trace#FlightRecorder" target="_blank" rel="external">golang.org/x/exp/trace</a>包中提供了一个飞行记录器实验。</p>
<p>请尝试使用它!下面是一个设置飞行记录器来捕获长时间HTTP请求的示例,可以帮助你入门。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置飞行记录器</span></div><div class="line">fr := trace.NewFlightRecorder()</div><div class="line">fr.Start()</div><div class="line"></div><div class="line"><span class="comment">// 设置和运行HTTP服务器</span></div><div class="line"><span class="keyword">var</span> once sync.Once</div><div class="line">http.HandleFunc(<span class="string">"/my-endpoint"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    start := time.Now()</div><div class="line"></div><div class="line">    <span class="comment">// 干些事情</span></div><div class="line">    doWork(w, r)</div><div class="line"></div><div class="line">    <span class="comment">// 盼到了长耗时请求，来个快照</span></div><div class="line">    <span class="keyword">if</span> time.Since(start) &gt;<span class="number"> 300</span>*time.Millisecond {</div><div class="line">        <span class="comment">// 这里我们为了简化只做一次，实际上你可以做多次</span></div><div class="line">        once.Do(<span class="keyword">func</span>() {</div><div class="line">            <span class="comment">// 抓取快照</span></div><div class="line">            <span class="keyword">var</span> b bytes.Buffer</div><div class="line">            _, err = fr.WriteTo(&b)</div><div class="line">            <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                log.Print(err)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line">            <span class="comment">// 把快照写入文件</span></div><div class="line">            <span class="keyword">if</span> err := os.WriteFile(<span class="string">"trace.out"</span>, b.Bytes(),<span class="number"> 0</span>o755); err != <span class="constant">nil</span> {</div><div class="line">                log.Print(err)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line">        })</div><div class="line">    }</div><div class="line">})</div><div class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>))</div></pre></td></tr></table></figure>

<p>果您有任何反馈，无论是正面的还是负面的，请分享到<a href="https://go.dev/issue/63185" target="_blank" rel="external">提案问题</a>中！</p>
<h2 id="跟踪读取器API">跟踪读取器API</h2>
<p>随着对跟踪实现的重写,我们也努力清理了其他的跟踪内部组件,比如go tool trace。这催生了一次尝试,目标是创建一个足够好的可共享跟踪读取器API,使跟踪更易于访问。</p>
<p>就像飞行记录器一样,我们很高兴地宣布,我们也有一个实验性的跟踪读取器API,希望能与大家分享。它与飞行记录器位于同一个包中,即<a href="https://go.dev/pkg/golang.org/x/exp/trace#Reader" target="_blank" rel="external">golang.org/x/exp/trace</a>。</p>
<p>我们认为它已经足够好,可以在此基础上构建东西了,所以请务必试用!下面是一个示例,它测量了由于等待网络而阻塞的goroutine阻塞事件的比例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始从标准输入读取跟踪数据。</span></div><div class="line">r, err := trace.NewReader(os.Stdin)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatal(err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> blocked <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> blockedOnNetwork <span class="typename">int</span></div><div class="line"><span class="keyword">for</span> {</div><div class="line">    <span class="comment">// 读取事件</span></div><div class="line">    ev, err := r.ReadEvent()</div><div class="line">    <span class="keyword">if</span> err == io.EOF {</div><div class="line">        <span class="keyword">break</span></div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 处理它</span></div><div class="line">    <span class="keyword">if</span> ev.Kind() == trace.EventStateTransition {</div><div class="line">        st := ev.StateTransition()</div><div class="line">        <span class="keyword">if</span> st.Resource.Kind == trace.ResourceGoroutine {</div><div class="line">            id := st.Resource.Goroutine()</div><div class="line">            from, to := st.GoroutineTransition()</div><div class="line"></div><div class="line">            <span class="comment">// 查找阻塞的goroutine, 统计计数</span></div><div class="line">            <span class="keyword">if</span> from.Executing() && to == trace.GoWaiting {</div><div class="line">                blocked++</div><div class="line">                <span class="keyword">if</span> strings.Contains(st.Reason, <span class="string">"network"</span>) {</div><div class="line">                    blockedOnNetwork++</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// 打印我们所需</span></div><div class="line">p :=<span class="number"> 100</span> * <span class="typename">float64</span>(blockedOnNetwork) / <span class="typename">float64</span>(blocked)</div><div class="line">fmt.Printf(<span class="string">"%2.3f%% instances of goroutines blocking were to block on the network\n"</span>, p)</div></pre></td></tr></table></figure>

<p>就像飞行记录器一样,有一个<a href="https://go.dev/issue/62627" target="_blank" rel="external">提案问题</a>可以作为留下反馈的好地方!</p>
<p>我们想特别提及Dominik Honnef,他很早就试用了这个API,提供了宝贵的反馈,并为API贡献了对旧版本跟踪的支持。</p>
<h2 id="感谢!">感谢!</h2>
<p>这项工作能够完成,在很大程度上要感谢一年多前成立的<a href="https://go.dev/issue/57175" target="_blank" rel="external">诊断工作组</a>的帮助,该小组由来自Go社区各界的利益相关者组成,并向公众开放。</p>
<p>我们要借此机会感谢在过去一年中定期参加诊断会议的社区成员:Felix Geisendörfer、Nick Ripley、Rhys Hiltner、Dominik Honnef、Bryan Boreham和thepudds。</p>
<p>你们所做的讨论、反馈和工作是我们走到今天这一步的关键推动力。再次感谢!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go官方博客:<a href="https://go.dev/blog/execution-traces-2024" target="_blank" rel="external">More powerful Go execution traces</a> by Michael Knyszek.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 中的高速数据包处理:从 net.Dial 到 AF_XDP]]></title>
    <link href="https://colobu.com/2024/03/12/high-speed-packet-transmission-in-go-from-net-dial-to-af-xdp/"/>
    <id>https://colobu.com/2024/03/12/high-speed-packet-transmission-in-go-from-net-dial-to-af-xdp/</id>
    <published>2024-03-12T14:39:24.000Z</published>
    <updated>2024-03-26T09:37:28.194Z</updated>
    <content type="html"><![CDATA[<p>原文： <a href="https://atoonk.medium.com/high-speed-packet-transmission-in-go-from-net-dial-to-af-xdp-2699452efef9" target="_blank" rel="external">High-Speed Packet Processing in Go: From net.Dial to AF_XDP</a> by Andree Toonk.</p>
<a id="more"></a>
<blockquote>
<p>推进Go的极限:从net.Dial到系统调用、AF_PACKET和极速AF_XDP。数据包发送性能的基准测试。</p>
</blockquote>
<p>最近,我编写了一个Go程序,向数百万个IP地址<a href="https://github.com/atoonk/ping-aws-ips" target="_blank" rel="external">发送ICMP ping消息</a>。显然,我希望这个过程能尽可能快速高效地完成。因此,这促使我研究各种与网络栈交互和快速发送数据包的各种方法。这是一个有趣的旅程,所以在本文中,我将分享一些学习成果,并记录下来供将来参考:)你将看到,仅使用8个内核就可以达到1880万数据包/秒。这里还有一个<a href="https://github.com/atoonk/go-pktgen" target="_blank" rel="external">GitHub仓库</a>,其中包含了示例代码,可以方便地跟随学习。</p>
<h2 id="使用场景">使用场景</h2>
<p>让我们先简单介绍一下问题背景。我希望能够从Linux机器上每秒发送尽可能多的数据包。有一些使用场景,例如我之前提到的Ping示例,但也可能是更通用的东西,如dpdk-pktgen或者类似iperf的工具。我想你可以将其总结为一种数据包生成器。</p>
<p>我使用Go编程语言来探索各种选项。一般来说,所探索的方法可以应用于任何编程语言,因为这些大多是围绕Linux内核提供的功能而构建的Go特定接口。但是,您可能会受到您最喜欢的编程语言中存在的库或支持的限制。</p>
<p>让我们开始冒险,探索Go中生成网络数据包的各种方式。我将介绍各种选项,最后我们将进行基准测试,显示哪种方法最适合我们的使用场景。我在一个Go包中包含了各种方法的示例;你可以在<a href="https://github.com/atoonk/go-pktgen/" target="_blank" rel="external">这里</a>找到代码。我们将使用相同的代码运行基准测试,看看各种方法相比如何。</p>
<h2 id="net-Dial">net.Dial</h2>
<p><code>net.Dial</code>方法是在Go中建立网络连接最先想到的选择。它是标准库net包提供的一种高级抽象方法,旨在以易于使用和直观的方式建立网络连接。您可以使用它进行双向通信,只需读写<code>net.Conn</code>(套接字)而无需担心细节。</p>
<p>在我们的情况下,我们主要关注发送流量,使用的<code>net.Dial</code>方法如下所示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conn, err := net.Dial(<span class="string">"udp"</span>, fmt.Sprintf(<span class="string">"%s:%d"</span>, s.dstIP, s.dstPort))</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to dial UDP: %w"</span>, err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> conn.Close()</div></pre></td></tr></table></figure>

<p>在此之后,您可以简单地像这样将字节写入conn:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn.Write(payload)</div></pre></td></tr></table></figure>

<p>您可以在文件<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/af_inet.go" target="_blank" rel="external">af_inet.go</a>中找到我们使用这种方法的代码。</p>
<p>就是这样!非常简单,对吗?然而,正如我们将在基准测试中看到的,这是最慢的方法,不是快速发送数据包的最佳选择。使用这种方法,我们可以达到大约697,277个数据包每秒。</p>
<h2 id="Raw_Socket">Raw Socket</h2>
<p>深入到网络栈层面,我决定在Go中使用原始套接字来发送数据包。与更抽象的<code>net.Dial</code>方法不同,原始套接字为我们提供了与网络栈更低层次的接口,可以对数据包头部和内容进行细粒度控制。这种方法允许我们手动构建整个数据包,包括IP头部。</p>
<p>要创建原始套接字,我们必须自己进行系统调用,给它正确的参数,并提供将要发送的流量类型。然后我们将获得一个文件描述符。接下来,我们可以对这个文件描述符进行读写操作。从高层次来看就是这样;完整代码请参见<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/rawsocket.go" target="_blank" rel="external">rawsocket.go</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_RAW)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatalf(<span class="string">"Failed to create raw socket: %v"</span>, err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> syscall.Close(fd)</div><div class="line"></div><div class="line"><span class="comment">// Set options: here, we enable IP_HDRINCL to manually include the IP header</span></div><div class="line"><span class="keyword">if</span> err := syscall.SetsockoptInt(fd, syscall.IPPROTO_IP, syscall.IP_HDRINCL,<span class="number"> 1</span>); err != <span class="constant">nil</span> {</div><div class="line">	log.Fatalf(<span class="string">"Failed to set IP_HDRINCL: %v"</span>, err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>就是这样,现在我们可以像这样对文件描述符进行原始数据包的读写操作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">err := syscall.Sendto(fd, packet,<span class="number"> 0</span>, dstAddr)</div></pre></td></tr></table></figure>

<p>由于我使用了<code>IPPROTO_RAW</code>，我们绕过了内核网络栈的传输层,内核期望我们提供完整的IP数据包。我们使用<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/rawsocket.go#L66C17-L66C28" target="_blank" rel="external">BuildPacket函数</a>来实现这一点。工作量略有增加,但原始套接字的好处在于你可以构造任何你想要的数据包。</p>
<p>我们告诉内核只需接收我们的数据包,它需要做的工作就少了,因此这个过程更快。我们真正要求网络栈做的就是接收这个IP数据包,添加以太网头部,然后将其交给网卡进行发送。因此,很自然地,这个选项确实比Net.Dial选项更快。使用这种方法,我们可以达到约793,781个数据包每秒,比net.Dial方法高出约10万数据包每秒。</p>
<h2 id="AF_INET_系统调用">AF_INET 系统调用</h2>
<p>现在我们已经熟悉了直接使用系统调用,我们还有另一个选择。在这个例子中,我们直接创建一个UDP套接字,如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, syscall.IPPROTO_UDP)</div></pre></td></tr></table></figure>

<p>在此之后,我们可以像之前一样使用<code>Sendto</code>方法简单地将有效负载写入套接字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">err = syscall.Sendto(fd, payload,<span class="number"> 0</span>, dstAddr)</div></pre></td></tr></table></figure>

<p>它看起来类似于原始套接字示例,但存在一些差异。关键区别在于,在这种情况下,我们创建了UDP类型的套接字,这意味着我们不需要像之前那样构造完整的数据包(IP和UDP头部)。使用这种方法时,内核根据我们指定的目标IP和端口来构造UDP头部,并处理将其封装到IP数据包的过程。</p>
<p>在这种情况下,有效负载仅是UDP有效负载。实际上,这种方法类似于之前的Net.Dial方法,但抽象程度更低。</p>
<p>与之前的原始套接字方法相比,我现在看到的是861,372个数据包每秒 - 提高了7万多。我们在每一步都变得更快。我猜我们获得了内核中一些UDP优化的好处。</p>
<h2 id="Pcap_方法">Pcap 方法</h2>
<p>在这里看到使用Pcap来发送数据包可能会感到惊讶。大多数人都知道pcap是从诸如tcpdump或Wireshark这样的工具中捕获数据包的。但它也是一种相当常见的发送数据包的方式。事实上,如果您查看许多Go-packet或Python Scappy示例,这通常是列出的发送自定义数据包的方法。因此,我认为我应该包括它并查看其性能。我持怀疑态度,但当看到每秒数据包数时,我很高兴地感到惊讶!</p>
<p>首先,让我们来看看Go语言是怎么实现的;同样,完整的示例请查看我在<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/pcap.go" target="_blank" rel="external">pcap.go</a>中的实现。</p>
<p>我们首先创建一个Pcap句柄,如下所示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">handle, err := pcap.OpenLive(s.iface,<span class="number"> 1500</span>, <span class="constant">false</span>, pcap.BlockForever)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"could not open device: %w"</span>, err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> handle.Close()</div></pre></td></tr></table></figure>

<p>然后我们<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/pcap.go#L51-L64" target="_blank" rel="external">手动创建数据包</a>,类似于前面的原始套接字方法,但在这种情况下,我们包含了以太网头部。之后,我们可以将数据包写入pcap句柄,就完成了!</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">err := handle.WritePacketData(packet)</div></pre></td></tr></table></figure>

<p>令我惊讶的是,这种方法带来了相当大的性能提升。我们远远超过了每秒一百万个数据包的大关: 1,354,087个数据包每秒 - 几乎比之前高出50万个数据包每秒!</p>
<p>注意,在本文的后面,我们将看到一个警告,但值得注意的是,当发送多个流(Go 例程)时,这种方法的工作效果会变差。</p>
<h2 id="af_packet_方法">af_packet 方法</h2>
<p>在我们探索 Go 中网络数据包制作和传输的各个层次时,接下来发现了 <code>AF_PACKET</code> 方法。这种方法在 Linux 上的入侵检测系统中很受欢迎,并且有充分的理由!</p>
<p>它让我们直接访问网络设备层,允许在链路层传输数据包。这意味着我们可以构建数据包,包括以太网头部,并直接将它们发送到网络接口,绕过更高层的网络层。我们可以使用系统调用创建 <code>AF_PACKET</code> 类型的套接字。在 Go 中,它看起来像这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fd, err := syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW, <span class="typename">int</span>(htons(syscall.ETH_P_IP)))</div></pre></td></tr></table></figure>

<p>这行代码创建一个原始套接字,可以在以太网层发送数据包。使用<code>AF_PACKET</code>时,我们指定<code>SOCK_RAW</code>表示我们对原始网络协议访问感兴趣。通过将协议设置为<code>ETH_P_IP</code>,我们告诉内核我们将处理IP数据包。</p>
<p>获得套接字描述符后,我们必须将其绑定到网络接口。这一步可确保我们构建的数据包通过正确的网络设备发送出去:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addr := &syscall.SockaddrLinklayer{</div><div class="line">	Protocol: htons(syscall.ETH_P_IP),</div><div class="line">	Ifindex:  ifi.Index,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>AF_PACKET</code>构建数据包涉及手动创建以太网帧。这包括设置源和目标MAC地址以及EtherType,以指示该帧承载的有效负载类型(在我们的例子中是IP)。我们使用了与之前Pcap方法相同的<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/af_packet.go#L56-L68" target="_blank" rel="external">BuildPacket函数</a>。</p>
<p>然后,数据包就可以直接发送到这条链路上了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">syscall.Sendto(fd, packet,<span class="number"> 0</span>, addr)</div></pre></td></tr></table></figure>

<p>事实证明,AF_PACKET方法的性能几乎与之前使用pcap方法时的性能相同。简单的谷歌搜索显示,<code>libpcap</code>(tcpdump和Go pcap绑定等工具所使用的底层库)在Linux平台上使用<code>AF_PACKET</code>进行数据包捕获和注入。所以,这解释了它们的性能相似性。</p>
<h2 id="使用_AF_XDP_套接字">使用 AF_XDP 套接字</h2>
<p>我们还有一个选项可以尝试。<code>AF_XDP</code>是一个相对较新的方式!它旨在通过利用传统Linux网络堆栈的快速路径,大幅提高应用程序直接从网络接口卡(NIC)发送和接收数据包的速度。另请参阅我之前关于<a href="https://toonk.io/building-an-xdp-express-data-path-based-bgp-peering-router/index.html" target="_blank" rel="external">XDP的博客文章</a>。</p>
<p><code>AF_XDP</code>利用了XDP(快速数据路径)框架。这种能力不仅通过避免内核开销提供了最小延迟,而且还通过在软件栈中尽可能早的点进行数据包处理,最大化了吞吐量。</p>
<p>Go标准库并没有原生支持AF_XDP套接字,我只能找到一个库来帮助实现这一点。所以这一切都还很新。</p>
<p>我使用了<a href="http://github.com/asavie/xdp" target="_blank" rel="external">asavie/xdp</a>这个库,你可以按如下方式初始化一个<code>AF_XDP</code>套接字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xsk, err := xdp.NewSocket(link.Attrs().Index, s.queueID, <span class="constant">nil</span>)****</div></pre></td></tr></table></figure>

<p>注意,我们需要提供一个NIC队列;这清楚地表明我们正在比以前的方法工作在更低的级别上。完整的代码比其他选择要复杂一些,部分原因是我们需要使用用户空间内存缓冲区(UMEM)来存储数据包数据。这种方法减少了内核在数据包处理中的参与,从而缩短了数据包在系统层中传输的时间。通过直接在驱动程序级别构建和注入数据包。因此,请查看<a href="https://github.com/atoonk/go-pktgen/blob/main/pktgen/af_xdp.go#L40-L97" target="_blank" rel="external">我的代码</a>。</p>
<p>结果看起来不错;使用这种方法,我现在可以生成2,647,936个数据包每秒。这是我们之前使用AF_PACKET时性能的两倍!太棒了!</p>
<h2 id="总结和一些要点">总结和一些要点</h2>
<p>首先，这次做的很有趣，也学到了很多！我们研究了从传统的net.Dial方法生成数据包的各种选项，包括原始套接字、pcap、AF_PACKET，最后是AF_XDP。下面的图表显示了每种方法的数字（都使用一个CPU和一个NIC队列）。AF_XDP是最大的赢家！<br><img src="af_xdp.webp" alt=""></p>
<p>如果感兴趣，您可以在类似下面的Linux系统上自行运行基准测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">./<span class="keyword">go</span>-pktgen --dstip<span class="number"> 192.168</span><span class="number">.64.2</span> --method benchmark \</div><div class="line"> --duration<span class="number"> 5</span> --payloadsize<span class="number"> 64</span> --iface veth0</div><div class="line"></div><div class="line">+-------------+-----------+------+</div><div class="line">|   Method    | Packets/s | Mb/s |</div><div class="line">+-------------+-----------+------+</div><div class="line">| af_xdp      |  <span class="number"> 2647936</span> |<span class="number"> 1355</span> |</div><div class="line">| af_packet   |  <span class="number"> 1368070</span> | <span class="number"> 700</span> |</div><div class="line">| af_pcap     |  <span class="number"> 1354087</span> | <span class="number"> 693</span> |</div><div class="line">| udp_syscall |   <span class="number"> 861372</span> | <span class="number"> 441</span> |</div><div class="line">| raw_socket  |   <span class="number"> 793781</span> | <span class="number"> 406</span> |</div><div class="line">| net_conn    |   <span class="number"> 697277</span> | <span class="number"> 357</span> |</div><div class="line">+-------------+-----------+------+</div></pre></td></tr></table></figure>

<p>重要的是关注每秒数据包数，因为这是软件网络堆栈的限制。<code>Mb/s</code> 数只是数据包大小乘以您可以生成的每秒数据包数。从传统的<code>net.Dial</code> 方法转换到使用 <code>AF_PACKET</code>，可以看到轻松实现了两倍的提升。然后，在使用 <code>AF_XDP</code> 时又实现了另外两倍的提升。如果您对快速发送数据包感兴趣，这确实是很重要的信息！</p>
<p>上述基准测试工具默认使用一个 <code>CPU</code> 和一个 <code>NIC 队列</code>。但是，用户可以选择使用更多的 CPU，这将启动多个 Go 协程以并行执行相同的测试。下面的截图显示了使用 <code>AF_XDP</code> 运行具有 8 个流（和 8 个 CPU）的工具，生成了 <code>186Gb/s</code> 的速率，数据包大小为 <code>1200 字节</code>（<code>18.8Mpps</code>）！这对于一台 Linux 服务器来说确实非常令人印象深刻（而且没有使用 DPDK）。比如，比使用 iperf3 更快。</p>
<p><img src="benchmark.webp" alt=""></p>
<h2 id="一些需要注意的地方和我未来想要关注的事项">一些需要注意的地方和我未来想要关注的事项</h2>
<p>使用 PCAP 方法运行多个流（go 协程）效果不佳。性能会显著下降。相比之下，可比较的 <code>AF_PACKET</code> 方法在多个流和 go 协程下表现良好。</p>
<p>我使用的 <code>AF_XDP</code> 库在大多数硬件 NIC 上似乎表现不佳。我在 GitHub 上提了一个<a href="https://github.com/asavie/xdp/issues/31" target="_blank" rel="external">问题</a>，希望能得到解决。如果能更可靠些，那将是很好的，因为这在某种程度上限制了更多真实世界的 <code>AF_XDP</code> Go 应用。我大部分的测试都是使用 veth 接口进行的；我很想看看它在物理 NIC 和支持 XDP 的驱动程序上的表现。</p>
<p>事实证明，对于 <code>AF_PACKET</code>，通过使用内存映射（<code>mma</code>p）环形缓冲区，可以实现零拷贝模式。这个特性允许用户空间应用直接访问内核空间中的数据包数据，无需在内核和用户空间之间复制数据，有效减少了 CPU 使用量并提高了数据包处理速度。这意味着理论上 <code>AF_PACKET</code> 和 <code>AF_XDP</code> 的性能可能非常相似。然而，似乎 Go 的 <code>AF_PACKET</code> 实现不支持零拷贝模式，或者<a href="https://twitter.com/jtollet/status/1762616103883227490" target="_blank" rel="external">只支持 RX</a> 而不支持 TX。所以我无法使用它。我找到了这个<a href="https://github.com/csulrong/gopacket/pull/1/files" target="_blank" rel="external">补丁</a>，但不幸的是在一个小时内无法让其工作，所以我放弃了。如果这个补丁有效，这可能是首选的方法，因为你不必依赖 <code>AF_XDP</code> 支持。</p>
<p>最后，我很想在这个 <a href="https://github.com/atoonk/go-pktgen/tree/main" target="_blank" rel="external">pktgen 库</a>中包含 DPDK 支持。这是唯一缺失的。但这是一个独立的大项目，我需要值得信赖的 Go DPDK 库。也许将来会实现！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文： <a href="https://atoonk.medium.com/high-speed-packet-transmission-in-go-from-net-dial-to-af-xdp-2699452efef9" target="_blank" rel="external">High-Speed Packet Processing in Go: From net.Dial to AF_XDP</a> by Andree Toonk.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[slog 终极指南]]></title>
    <link href="https://colobu.com/2024/03/10/slog-the-ultimate-guide/"/>
    <id>https://colobu.com/2024/03/10/slog-the-ultimate-guide/</id>
    <published>2024-03-10T03:49:55.000Z</published>
    <updated>2024-03-26T09:37:28.196Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://betterstack.com/community/guides/logging/logging-in-go/" target="_blank" rel="external">Logging in Go with Slog: The Ultimate Guide</a> by Ayooluwa Isaiah.</p>
<a id="more"></a>
<p>在本文中，我们将探讨 Go 中的结构化日志记录，并特别关注这最近推出的 <a href="https://pkg.go.dev/log/slog" target="_blank" rel="external">log/slog</a> 软件包, 这个软件包旨在为 Go 带来高性能、结构化和分级的日志记录标准库。</p>
<p>该软件包起源于由 Jonathan Amsterdam 发起的 <a href="https://github.com/golang/go/discussions/54763" target="_blank" rel="external">GitHub 讨论</a>, 后来专门建立了一个<a href="https://github.com/golang/go/issues/56345" target="_blank" rel="external">提案</a>细化设计。一旦定稿，它在Go v1.21版本中发布。</p>
<p>在以下各节中，我将全面呈现slog的功能， 提供相应的例子。至于它和其它日志框架的性能比较，请参阅此 <a href="https://github.com/betterstack-community/go-logging-benchmarks" target="_blank" rel="external">GitHub 日志框架 benchmark</a>.</p>
<h2 id="开始使用_Slog">开始使用 Slog</h2>
<p>让我们从探讨该包的设计和架构开始。它提供了三种您应该熟悉的主要类型:<code>log/slog</code></p>
<ul>
<li><strong>Logger</strong>：日志&quot;前端&quot;，提供了诸如 <code>Info()</code> 和 <code>Error()</code> 等级别方法来记录感兴趣的事件。</li>
<li><strong>Record</strong>：由 <code>Logger</code> 创建的每个独立日志对象的表示形式。</li>
<li><strong>Handler</strong>：一旦实现了这个接口，就可以决定每个 <code>Record</code> 的格式化和目的地。该包中包含两个内置处理程序：<code>TextHandler</code> 用于 <code>key=value</code> 输出，<code>JSONHandler</code> 用于 <code>JSON</code> 输出。</li>
</ul>
<p>与大多数 <a href="https://betterstack.com/community/guides/logging/best-golang-logging-libraries/" target="_blank" rel="external">Go 日志库</a>一样， <code>slog</code>包公开了一个可通过包级别函数访问的默认 <code>Logger</code>。该 <code>logger</code> 产生的输出与旧的 <code>log.Printf()</code> 方法几乎相同，只是多了日志级别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"log/slog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    log.Print(<span class="string">"Info message"</span>)</div><div class="line">    slog.Info(<span class="string">"Info message"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2024</span><span class="regexp">/01/</span><span class="number">03</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">22</span> Info message</div><div class="line"><span class="number">2024</span><span class="regexp">/01/</span><span class="number">03</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">22</span> INFO Info message</div></pre></td></tr></table></figure>

<p>这是一个有些奇怪的默认设置,因为 <code>slog</code> 的主要目的是为标准库带来结构化日志记录。</p>
<p>不过,通过 <code>slog.New()</code> 方法创建自定义实例就很容易纠正这一点。它接受一个 <code>Handler</code> 接口的实现,用于决定日志的格式化方式和写入位置。</p>
<p>下面是一个使用内置的 <code>JSONHandler</code> 类型将 <code>JSON</code> 日志输出到 <code>stdout</code> 的示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>))</div><div class="line">    logger.Debug(<span class="string">"Debug message"</span>)</div><div class="line">    logger.Info(<span class="string">"Info message"</span>)</div><div class="line">    logger.Warn(<span class="string">"Warning message"</span>)</div><div class="line">    logger.Error(<span class="string">"Error message"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-03-15T12:59:22.227408691+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Info message"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-03-15T12:59:22.227468972+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"WARN"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Warning message"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-03-15T12:59:22.227472149+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"ERROR"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Error message"</span></span>}</div></pre></td></tr></table></figure>

<p>当使用 <code>TextHandler</code> 类型时,每个日志记录将根据 Logfmt 标准进行格式化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logger := slog.New(slog.NewTextHandler(os.Stdout, <span class="constant">nil</span>))</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">time=</span><span class="number">2023</span>-<span class="number">03</span>-<span class="number">15</span>T13:<span class="number">00</span>:<span class="number">11.333</span>+<span class="number">01</span>:<span class="number">00</span> <span class="variable">level=</span>INFO <span class="variable">msg=</span><span class="string">"Info message"</span></div><div class="line"><span class="variable">time=</span><span class="number">2023</span>-<span class="number">03</span>-<span class="number">15</span>T13:<span class="number">00</span>:<span class="number">11.333</span>+<span class="number">01</span>:<span class="number">00</span> <span class="variable">level=</span>WARN <span class="variable">msg=</span><span class="string">"Warning message"</span></div><div class="line"><span class="variable">time=</span><span class="number">2023</span>-<span class="number">03</span>-<span class="number">15</span>T13:<span class="number">00</span>:<span class="number">11.333</span>+<span class="number">01</span>:<span class="number">00</span> <span class="variable">level=</span>ERROR <span class="variable">msg=</span><span class="string">"Error message"</span></div></pre></td></tr></table></figure>

<p>所有<code>Logger</code>实例默认使用 <code>INFO</code> 级别进行日志记录,这将导致 <code>DEBUG</code> 条目被一直不输出,但您可以根据需要轻松更新日志级别。</p>
<h2 id="自定义默认_logger">自定义默认 logger</h2>
<p>自定义默认 <code>logger</code> 最直接的方式是利用 <code>slog.SetDefault()</code> 方法,允许您用自定义的 <code>logger</code> 替换默认的 <code>logger</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>))</div><div class="line"></div><div class="line">    slog.SetDefault(logger)</div><div class="line"></div><div class="line">    slog.Info(<span class="string">"Info message"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你现在会观察到,该包的顶层日志记录方法现在会生成如下所示的 JSON 输出:</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-03-15T13:07:39.105777557+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Info message"</span></span>}</div></pre></td></tr></table></figure>

<p>使用 <code>SetDefault()</code> 方法还会改变 <code>log</code> 包使用的默认 <code>log.Logger</code>。这种行为允许利用旧的 <code>log</code> 包的现有应用程序无缝过渡到结构化日志记录。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>))</div><div class="line"></div><div class="line">    slog.SetDefault(logger)</div><div class="line"></div><div class="line">    <span class="comment">// elsewhere in the application</span></div><div class="line">    log.Println(<span class="string">"Hello from old logger"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-03-16T15:20:33.783681176+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Hello from old logger"</span></span>}</div></pre></td></tr></table></figure>

<p>当您需要利用需要 <code>log.Logger</code> 的 API 时(如 <code>http.Server.ErrorLog</code>)，<code>slog.NewLogLogger()</code> 方法也可用于将<code>slog.Logger</code> 转换为 <code>log.Logger</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>)</div><div class="line"></div><div class="line">    logger := slog.NewLogLogger(handler, slog.LevelError)</div><div class="line"></div><div class="line">    _ = http.Server{</div><div class="line">        <span class="comment">// this API only accepts `log.Logger`</span></div><div class="line">        ErrorLog: logger,</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="为日志记录添加上下文属性">为日志记录添加上下文属性</h2>
<p>结构化日志记录相对于非结构化格式的一个重大优势是能够在日志记录中以键/值对的形式添加任意属性。</p>
<p>这些属性为所记录的事件提供了额外的上下文信息,对于诸如故障排除、生成指标、审计和各种其他用途等任务非常有价值。</p>
<p>下面是一个示例,说明了如何在 slog 中实现这一点:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">logger.Info(</div><div class="line">  <span class="string">"incoming request"</span>,</div><div class="line">  <span class="string">"method"</span>, <span class="string">"GET"</span>,</div><div class="line">  <span class="string">"time_taken_ms"</span>,<span class="number"> 158</span>,</div><div class="line">  <span class="string">"path"</span>, <span class="string">"/hello/world?q=search"</span>,</div><div class="line">  <span class="string">"status"</span>,<span class="number"> 200</span>,</div><div class="line">  <span class="string">"user_agent"</span>, <span class="string">"Googlebot/2.1 (+http://www.google.com/bot.html)"</span>,</div><div class="line">)</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T11:52:49.554074496+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>":<span class="value"><span class="string">"incoming request"</span></span>,</div><div class="line">  "<span class="attribute">method</span>":<span class="value"><span class="string">"GET"</span></span>,</div><div class="line">  "<span class="attribute">time_taken_ms</span>":<span class="value"><span class="number">158</span></span>,</div><div class="line">  "<span class="attribute">path</span>":<span class="value"><span class="string">"/hello/world?q=search"</span></span>,</div><div class="line">  "<span class="attribute">status</span>":<span class="value"><span class="number">200</span></span>,</div><div class="line">  "<span class="attribute">user_agent</span>":<span class="value"><span class="string">"Googlebot/2.1 (+http://www.google.com/bot.html)"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所有的级别方法(<code>Info()</code>、<code>Debug()</code>等)都接受一个日志消息作为第一个参数,之后可以接受无限个宽松类型的键/值对。</p>
<p>这个 API 类似于 <code>Zap</code> 中的 <a href="https://betterstack.com/community/guides/logging/go/zap#examining-zap-s-logging-api" target="_blank" rel="external">SugaredLogger API</a>(具体是以w结尾的级别方法),它以额外的内存分配为代价来换取简洁性。</p>
<p>但要小心,因为这种方法可能会导致意外的问题。具体来说,不匹配的键/值对会导致输出存在问题:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">logger.Info(</div><div class="line">  <span class="string">"incoming request"</span>,</div><div class="line">  <span class="string">"method"</span>, <span class="string">"GET"</span>,</div><div class="line">  <span class="string">"time_taken_ms"</span>, <span class="comment">// the value for this key is missing</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p>由于time_taken_ms键没有对应的值,它将被视为以!BADKEY作为键的值。这不太理想,因为属性对齐错误可能会创建错误的条目,而您可能要等到需要使用日志时才会发现。</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-03-15T13:15:29.956566795+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"incoming request"</span></span>,</div><div class="line">  "<span class="attribute">method</span>": <span class="value"><span class="string">"GET"</span></span>,</div><div class="line">  "<span class="attribute">!BADKEY</span>": <span class="value"><span class="string">"time_taken_ms"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了防止此类问题,您可以运行vet命令或使用lint工具自动报告此类问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go vet ./...</div><div class="line"><span class="comment"># github.com/smallnest/study/logging</span></div><div class="line"><span class="comment"># [github.com/smallnest/study/logging]</span></div><div class="line">./main.go:<span class="number">6</span>:<span class="number">2</span>: call to slog.Info missing a final value</div></pre></td></tr></table></figure>

<p>另一种防止此类错误的方法是使用如下所示的<a href="https://pkg.go.dev/log/slog#Attr" target="_blank" rel="external">强类型上下文属性</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">logger.Info(</div><div class="line">  <span class="string">"incoming request"</span>,</div><div class="line">  slog.String(<span class="string">"method"</span>, <span class="string">"GET"</span>),</div><div class="line">  slog.Int(<span class="string">"time_taken_ms"</span>,<span class="number"> 158</span>),</div><div class="line">  slog.String(<span class="string">"path"</span>, <span class="string">"/hello/world?q=search"</span>),</div><div class="line">  slog.Int(<span class="string">"status"</span>,<span class="number"> 200</span>),</div><div class="line">  slog.String(</div><div class="line">    <span class="string">"user_agent"</span>,</div><div class="line">    <span class="string">"Googlebot/2.1 (+http://www.google.com/bot.html)"</span>,</div><div class="line">  ),</div><div class="line">)</div></pre></td></tr></table></figure>

<p>虽然这是上下文日志记录的一种更好的方法,但它并不是万无一失的,因为没有什么能阻止您混合使用强类型和宽松类型的键/值对,就像这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">logger.Info(</div><div class="line">  <span class="string">"incoming request"</span>,</div><div class="line">  <span class="string">"method"</span>, <span class="string">"GET"</span>,</div><div class="line">  slog.Int(<span class="string">"time_taken_ms"</span>,<span class="number"> 158</span>),</div><div class="line">  slog.String(<span class="string">"path"</span>, <span class="string">"/hello/world?q=search"</span>),</div><div class="line">  <span class="string">"status"</span>,<span class="number"> 200</span>,</div><div class="line">  slog.String(</div><div class="line">    <span class="string">"user_agent"</span>,</div><div class="line">    <span class="string">"Googlebot/2.1 (+http://www.google.com/bot.html)"</span>,</div><div class="line">  ),</div><div class="line">)</div></pre></td></tr></table></figure>

<p>要在为记录添加上下文属性时保证类型安全,您必须使用 <code>LogAttrs()</code> 方法,像这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">logger.LogAttrs(</div><div class="line">  context.Background(),</div><div class="line">  slog.LevelInfo,</div><div class="line">  <span class="string">"incoming request"</span>,</div><div class="line">  slog.String(<span class="string">"method"</span>, <span class="string">"GET"</span>),</div><div class="line">  slog.Int(<span class="string">"time_taken_ms"</span>,<span class="number"> 158</span>),</div><div class="line">  slog.String(<span class="string">"path"</span>, <span class="string">"/hello/world?q=search"</span>),</div><div class="line">  slog.Int(<span class="string">"status"</span>,<span class="number"> 200</span>),</div><div class="line">  slog.String(</div><div class="line">    <span class="string">"user_agent"</span>,</div><div class="line">    <span class="string">"Googlebot/2.1 (+http://www.google.com/bot.html)"</span>,</div><div class="line">  ),</div><div class="line">)</div></pre></td></tr></table></figure>

<p>这个方法只接受 <code>slog.Attr</code> 类型的自定义属性,因此不可能出现不平衡的键/值对。然而,它的 API 更加复杂,因为除了日志消息和自定义属性外,您总是需要向该方法传递上下文(或 nil)和日志级别。</p>
<h2 id="分组上下文属性">分组上下文属性</h2>
<p>Slog 还允许在单个名称下对多个属性进行分组,但输出取决于所使用的 <code>Handler</code>。例如,对于 <code>JSONHandler</code>,每个组都嵌套在 <code>JSON</code> 对象中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">logger.LogAttrs(</div><div class="line">  context.Background(),</div><div class="line">  slog.LevelInfo,</div><div class="line">  <span class="string">"image uploaded"</span>,</div><div class="line">  slog.Int(<span class="string">"id"</span>,<span class="number"> 23123</span>),</div><div class="line">  slog.Group(<span class="string">"properties"</span>,</div><div class="line">    slog.Int(<span class="string">"width"</span>,<span class="number"> 4000</span>),</div><div class="line">    slog.Int(<span class="string">"height"</span>,<span class="number"> 3000</span>),</div><div class="line">    slog.String(<span class="string">"format"</span>, <span class="string">"jpeg"</span>),</div><div class="line">  ),</div><div class="line">)</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T12:03:12.175582603+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>":<span class="value"><span class="string">"image uploaded"</span></span>,</div><div class="line">  "<span class="attribute">id</span>":<span class="value"><span class="number">23123</span></span>,</div><div class="line">  "<span class="attribute">properties</span>":<span class="value">{</span></div><div class="line">    "<span class="attribute">width</span>":<span class="value"><span class="number">4000</span></span>,</div><div class="line">    "<span class="attribute">height</span>":<span class="value"><span class="number">3000</span></span>,</div><div class="line">    "<span class="attribute">format</span>":<span class="value"><span class="string">"jpeg"</span></span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当使用 TextHandler 时,组中的每个键都将以组名作为前缀,如下所示:</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">time=</span><span class="number">2023</span>-<span class="number">02</span>-<span class="number">24</span>T12:<span class="number">06</span>:<span class="number">20.249</span>+<span class="number">01</span>:<span class="number">00</span> <span class="variable">level=</span>INFO <span class="variable">msg=</span><span class="string">"image uploaded"</span> <span class="variable">id=</span><span class="number">23123</span></div><div class="line">  properties.<span class="variable">width=</span><span class="number">4000</span> properties.<span class="variable">height=</span><span class="number">3000</span> properties.<span class="variable">format=</span>jpeg</div></pre></td></tr></table></figure>

<h2 id="创建和使用子_logger">创建和使用子 logger</h2>
<p>在特定范围内的所有记录中包含相同的属性,可以确保它们的存在而无需重复的日志记录语句,这是很有益的。</p>
<p>这就是子 <code>logger</code> 可以派上用场的地方,它创建了一个新的日志记录上下文,该上下文从其父级继承而来,同时允许包含额外的字段。</p>
<p>在 <code>slog</code> 中,创建子 <code>logger</code> 是使用 <code>Logger.With()</code> 方法完成的。它接受一个或多个键/值对,并返回一个包含指定属性的新 <code>Logger</code>。</p>
<p>考虑以下代码片段,它将程序的进程 <code>ID</code> 和用于编译的 <code>Go 版本</code>添加到每个日志记录中,并将它们存储在 <code>program_info</code> 属性中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>)</div><div class="line">    buildInfo, _ := debug.ReadBuildInfo()</div><div class="line"></div><div class="line">    logger := slog.New(handler)</div><div class="line"></div><div class="line">    child := logger.With(</div><div class="line">        slog.Group(<span class="string">"program_info"</span>,</div><div class="line">            slog.Int(<span class="string">"pid"</span>, os.Getpid()),</div><div class="line">            slog.String(<span class="string">"go_version"</span>, buildInfo.GoVersion),</div><div class="line">        ),</div><div class="line">    )</div><div class="line"></div><div class="line">    . . .</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了这个配置，所有由子日志记录器创建的记录都会包含 program_info 属性下指定的属性，只要它在日志点没有被覆盖。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    . . .</div><div class="line"></div><div class="line">    child.Info(<span class="string">"image upload successful"</span>, slog.String(<span class="string">"image_id"</span>, <span class="string">"39ud88"</span>))</div><div class="line">    child.Warn(</div><div class="line">        <span class="string">"storage is 90% full"</span>,</div><div class="line">        slog.String(<span class="string">"available_space"</span>, <span class="string">"900.1 mb"</span>),</div><div class="line">    )</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-02-26T19:26:46.046793623+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"image upload successful"</span></span>,</div><div class="line">  "<span class="attribute">program_info</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">pid</span>": <span class="value"><span class="number">229108</span></span>,</div><div class="line">    "<span class="attribute">go_version</span>": <span class="value"><span class="string">"go1.20"</span></span></div><div class="line">  },</div><div class="line">  "<span class="attribute">image_id</span>": <span class="value"><span class="string">"39ud88"</span></span></div><div class="line">}</div><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-02-26T19:26:46.046847902+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"WARN"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"storage is 90% full"</span></span>,</div><div class="line">  "<span class="attribute">program_info</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">pid</span>": <span class="value"><span class="number">229108</span></span>,</div><div class="line">    "<span class="attribute">go_version</span>": <span class="value"><span class="string">"go1.20"</span></span></div><div class="line">  },</div><div class="line">  "<span class="attribute">available_space</span>": <span class="value"><span class="string">"900.1 MB"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>您还可以使用 <code>WithGroup()</code> 方法创建一个子日志记录器，该方法会启动一个组，以便添加到日志记录器中的所有属性（包括在日志点添加的属性）都嵌套在组名下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">handler := slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>)</div><div class="line">buildInfo, _ := debug.ReadBuildInfo()</div><div class="line">logger := slog.New(handler).WithGroup(<span class="string">"program_info"</span>)</div><div class="line"></div><div class="line">child := logger.With(</div><div class="line">  slog.Int(<span class="string">"pid"</span>, os.Getpid()),</div><div class="line">  slog.String(<span class="string">"go_version"</span>, buildInfo.GoVersion),</div><div class="line">)</div><div class="line"></div><div class="line">child.Warn(</div><div class="line">  <span class="string">"storage is 90% full"</span>,</div><div class="line">  slog.String(<span class="string">"available_space"</span>, <span class="string">"900.1 MB"</span>),</div><div class="line">)</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-05-24T19:00:18.384136084+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"WARN"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"storage is 90% full"</span></span>,</div><div class="line">  "<span class="attribute">program_info</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">pid</span>": <span class="value"><span class="number">1971993</span></span>,</div><div class="line">    "<span class="attribute">go_version</span>": <span class="value"><span class="string">"go1.20.2"</span></span>,</div><div class="line">    "<span class="attribute">available_space</span>": <span class="value"><span class="string">"900.1 mb"</span></span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="自定义_slog_日志级别">自定义 slog 日志级别</h2>
<p>log/slog 软件包默认提供四个日志级别，每个级别都与一个整数值相关联：</p>
<ul>
<li>DEBUG (-4)</li>
<li>INFO (0)</li>
<li>WARN (4)</li>
<li>ERROR (8)</li>
</ul>
<p>每个级别之间间隔 <strong>4</strong> 是经过深思熟虑的设计决策，目的是为了适应在默认级别之间使用自定义级别的日志记录方案。例如，您可以使用 <strong>1</strong>、<strong>2</strong> 或 <strong>3</strong> 的值创建介于 <code>INFO</code> 和 <code>WARN</code> 之间的新日志级别。</p>
<p>我们之前看到过，默认情况下所有日志记录器都配置为 <code>INFO</code> 级别记录日志，这会导致低于该严重性（例如 <code>DEBUG</code>）的事件被忽略。您可以通过以下所示的 <code>HandlerOptions</code> 类型来自定义此行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    opts := &slog.HandlerOptions{</div><div class="line">        Level: slog.LevelDebug,</div><div class="line">    }</div><div class="line"></div><div class="line">    handler := slog.NewJSONHandler(os.Stdout, opts)</div><div class="line"></div><div class="line">    logger := slog.New(handler)</div><div class="line">    logger.Debug(<span class="string">"Debug message"</span>)</div><div class="line">    logger.Info(<span class="string">"Info message"</span>)</div><div class="line">    logger.Warn(<span class="string">"Warning message"</span>)</div><div class="line">    logger.Error(<span class="string">"Error message"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-05-24T19:03:10.70311982+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"DEBUG"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Debug message"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-05-24T19:03:10.703187713+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Info message"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-05-24T19:03:10.703190419+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"WARN"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Warning message"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-05-24T19:03:10.703192892+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"ERROR"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Error message"</span></span>}</div></pre></td></tr></table></figure>

<p>这种设置日志级别的方法会固定处理程序在整个生命周期内的日志级别。如果您需要<a href="https://betterstack.com/community/guides/logging/change-log-levels-dynamically/" target="_blank" rel="external">动态调整</a>最低日志级别，则必须使用 <code>LevelVar</code> 类型，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    logLevel := &slog.LevelVar{} <span class="comment">// INFO</span></div><div class="line"></div><div class="line">    opts := &slog.HandlerOptions{</div><div class="line">        Level: logLevel,</div><div class="line">    }</div><div class="line"></div><div class="line">    handler := slog.NewJSONHandler(os.Stdout, opts)</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>之后您可以随时使用以下方式更新日志级别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logLevel.Set(slog.LevelDebug)</div></pre></td></tr></table></figure>

<h2 id="创建自定义日志级别">创建自定义日志级别</h2>
<p>如果您需要超出 slog 默认提供的日志级别，可以通过实现 <code>Leveler</code> 接口来创建它们。该接口的签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Leveler <span class="keyword">interface</span> {</div><div class="line">    Level() Level</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实现这个接口很简单，可以使用下面展示的 <code>Level</code> 类型（因为 <code>Level</code> 本身就实现了 <code>Leveler</code> 接口）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    LevelTrace  = slog.Level<span class="number">(-8</span>)</div><div class="line">    LevelFatal  = slog.Level<span class="number">(12</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>一旦您像上面那样定义了自定义日志级别，您就只能通过 <code>Log()</code> 或 <code>LogAttrs()</code> 方法来使用它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">opts := &slog.HandlerOptions{</div><div class="line">    Level: LevelTrace,</div><div class="line">}</div><div class="line"></div><div class="line">logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))</div><div class="line"></div><div class="line">ctx := context.Background()</div><div class="line">logger.Log(ctx, LevelTrace, <span class="string">"Trace message"</span>)</div><div class="line">logger.Log(ctx, LevelFatal, <span class="string">"Fatal level"</span>)</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T09:26:41.666493901+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"DEBUG-4"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Trace level"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T09:26:41.666602404+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"ERROR+4"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Fatal level"</span></span>}</div></pre></td></tr></table></figure>

<p>注意到自定义日志级别会使用默认级别的名称进行标注。这显然不是您想要的，因此应该通过 <code>HandlerOptions</code> 类型来自定义级别名称，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">var</span> LevelNames = <span class="keyword">map</span>[slog.Leveler]<span class="typename">string</span>{</div><div class="line">    LevelTrace:      <span class="string">"TRACE"</span>,</div><div class="line">    LevelFatal:      <span class="string">"FATAL"</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    opts := slog.HandlerOptions{</div><div class="line">        Level: LevelTrace,</div><div class="line">        ReplaceAttr: <span class="keyword">func</span>(groups []<span class="typename">string</span>, a slog.Attr) slog.Attr {</div><div class="line">            <span class="keyword">if</span> a.Key == slog.LevelKey {</div><div class="line">                level := a.Value.Any().(slog.Level)</div><div class="line">                levelLabel, exists := LevelNames[level]</div><div class="line">                <span class="keyword">if</span> !exists {</div><div class="line">                    levelLabel = level.String()</div><div class="line">                }</div><div class="line"></div><div class="line">                a.Value = slog.StringValue(levelLabel)</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">return</span> a</div><div class="line">        },</div><div class="line">    }</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>ReplaceAttr()</code> 函数用于自定义 <code>Handler</code> 如何处理 <code>Recor</code>d 中的每个键值对。它可以用来修改键名，或者以某种方式处理值。</p>
<p>在给定的示例中，它将自定义日志级别映射到它们各自的标签，分别生成 <code>TRACE</code> 和 <code>FATAL</code>:</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T09:27:51.747625912+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"TRACE"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Trace level"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T09:27:51.747737319+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"FATAL"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Fatal level"</span></span>}</div></pre></td></tr></table></figure>

<h2 id="自定义_slog_处理程序">自定义 slog 处理程序</h2>
<p>正如之前提到的，<code>TextHandler</code> 和 <code>JSONHandler</code> 都可以使用 <code>HandlerOptions</code> 类型进行定制。您已经看过如何调整最低日志级别以及在记录日志之前修改属性。</p>
<p>通过 <code>HandlerOptions</code> 还可实现的其他自定义功能包括（如果需要的话）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">opts := &slog.HandlerOptions{</div><div class="line">    AddSource: <span class="constant">true</span>,</div><div class="line">    Level:     slog.LevelDebug,</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  <span class="string">"time"</span>: <span class="string">"2024-01-03T11:06:50.971029852+01:00"</span>,</div><div class="line">  <span class="string">"level"</span>: <span class="string">"DEBUG"</span>,</div><div class="line">  <span class="string">"source"</span>: {</div><div class="line">    <span class="string">"function"</span>: <span class="string">"main.main"</span>,</div><div class="line">    <span class="string">"file"</span>: <span class="string">"/home/ayo/dev/betterstack/demo/slog/main.go"</span>,</div><div class="line">    <span class="string">"line"</span>:<span class="number"> 17</span></div><div class="line">  },</div><div class="line">  <span class="string">"msg"</span>: <span class="string">"Debug message"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>根据应用环境切换日志处理程序也非常简单。例如，您可能更喜欢在开发过程中使用 <code>TextHandler</code>，因为它更易于阅读，然后在生产环境中切换到 <code>JSONHandler</code> 以获得更大的灵活性并兼容各种日志工具。</p>
<p>这种行为可以通过环境变量轻松实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appEnv = os.Getenv(<span class="string">"APP_ENV"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    opts := &slog.HandlerOptions{</div><div class="line">        Level: slog.LevelDebug,</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">var</span> handler slog.Handler = slog.NewTextHandler(os.Stdout, opts)</div><div class="line">    <span class="keyword">if</span> appEnv == <span class="string">"production"</span> {</div><div class="line">        handler = slog.NewJSONHandler(os.Stdout, opts)</div><div class="line">    }</div><div class="line"></div><div class="line">    logger := slog.New(handler)</div><div class="line"></div><div class="line">    logger.Info(<span class="string">"Info message"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">time=</span><span class="number">2023</span>-<span class="number">02</span>-<span class="number">24</span>T10:<span class="number">36</span>:<span class="number">39.697</span>+<span class="number">01</span>:<span class="number">00</span> <span class="variable">level=</span>INFO <span class="variable">msg=</span><span class="string">"Info message"</span></div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$APP_ENV</span>=production go run main.go</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-02-24T10:35:16.964821548+01:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"Info message"</span></span>}</div></pre></td></tr></table></figure>

<h3 id="创建自定义日志处理程序">创建自定义日志处理程序</h3>
<p>由于 Handler 是一个接口，因此可以创建自定义处理程序来以不同的格式格式化日志或将它们写入其他目的地。</p>
<p>该接口的签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> {</div><div class="line">    Enabled(context.Context, Level) <span class="typename">bool</span></div><div class="line">    Handle(context.Context, r Record) error</div><div class="line">    WithAttrs(attrs []Attr) Handler</div><div class="line">    WithGroup(name <span class="typename">string</span>) Handler</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以下是每个方法的解释：</p>
<ul>
<li>Enabled：判断日志记录是否应该被处理或丢弃，依据是日志记录的级别。上下文信息也可以用于决策。</li>
<li>Handle：处理发送到该处理程序的每个日志记录 (record)。仅当 Enabled 返回 true 时才会调用此方法。</li>
<li>WithAttrs：使用现有处理程序创建一个新处理程序，并向其中添加指定的属性 (attrs)。</li>
<li>WithGroup：使用现有处理程序创建一个新处理程序，并向其中添加指定的组名 (group)，该名称限定后续的属性。</li>
<li>这是一个使用 log、json 和 <a href="https://github.com/fatih/color" target="_blank" rel="external">color</a> 软件包来实现美化开发环境日志输出的示例：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NOTE: Not well tested, just an illustration of what's possible</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"encoding/json"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"log/slog"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/fatih/color"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> PrettyHandlerOptions <span class="keyword">struct</span> {</div><div class="line">    SlogOpts slog.HandlerOptions</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> PrettyHandler <span class="keyword">struct</span> {</div><div class="line">    slog.Handler</div><div class="line">    l *log.Logger</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h *PrettyHandler) Handle(ctx context.Context, r slog.Record) error {</div><div class="line">    level := r.Level.String() + <span class="string">":"</span></div><div class="line"></div><div class="line">    <span class="keyword">switch</span> r.Level {</div><div class="line">    <span class="keyword">case</span> slog.LevelDebug:</div><div class="line">        level = color.MagentaString(level)</div><div class="line">    <span class="keyword">case</span> slog.LevelInfo:</div><div class="line">        level = color.BlueString(level)</div><div class="line">    <span class="keyword">case</span> slog.LevelWarn:</div><div class="line">        level = color.YellowString(level)</div><div class="line">    <span class="keyword">case</span> slog.LevelError:</div><div class="line">        level = color.RedString(level)</div><div class="line">    }</div><div class="line"></div><div class="line">    fields := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}, r.NumAttrs())</div><div class="line">    r.Attrs(<span class="keyword">func</span>(a slog.Attr) <span class="typename">bool</span> {</div><div class="line">        fields[a.Key] = a.Value.Any()</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    })</div><div class="line"></div><div class="line">    b, err := json.MarshalIndent(fields, <span class="string">""</span>, <span class="string">"  "</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line"></div><div class="line">    timeStr := r.Time.Format(<span class="string">"[15:05:05.000]"</span>)</div><div class="line">    msg := color.CyanString(r.Message)</div><div class="line"></div><div class="line">    h.l.Println(timeStr, level, msg, color.WhiteString(<span class="typename">string</span>(b)))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewPrettyHandler(</div><div class="line">    out io.Writer,</div><div class="line">    opts PrettyHandlerOptions,</div><div class="line">) *PrettyHandler {</div><div class="line">    h := &PrettyHandler{</div><div class="line">        Handler: slog.NewJSONHandler(out, &opts.SlogOpts),</div><div class="line">        l:       log.New(out, <span class="string">""</span>,<span class="number"> 0</span>),</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> h</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你的代码使用<code>PrettyHandler</code>的方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    opts := PrettyHandlerOptions{</div><div class="line">        SlogOpts: slog.HandlerOptions{</div><div class="line">            Level: slog.LevelDebug,</div><div class="line">        },</div><div class="line">    }</div><div class="line">    handler := NewPrettyHandler(os.Stdout, opts)</div><div class="line">    logger := slog.New(handler)</div><div class="line">    logger.Debug(</div><div class="line">        <span class="string">"executing database query"</span>,</div><div class="line">        slog.String(<span class="string">"query"</span>, <span class="string">"SELECT * FROM users"</span>),</div><div class="line">    )</div><div class="line">    logger.Info(<span class="string">"image upload successful"</span>, slog.String(<span class="string">"image_id"</span>, <span class="string">"39ud88"</span>))</div><div class="line">    logger.Warn(</div><div class="line">        <span class="string">"storage is 90% full"</span>,</div><div class="line">        slog.String(<span class="string">"available_space"</span>, <span class="string">"900.1 MB"</span>),</div><div class="line">    )</div><div class="line">    logger.Error(</div><div class="line">        <span class="string">"An error occurred while processing the request"</span>,</div><div class="line">        slog.String(<span class="string">"url"</span>, <span class="string">"https://example.com"</span>),</div><div class="line">    )</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当你执行程序时你会看到如下彩色的输出：<br><img src="color.png" alt=""></p>
<p>你可以在 <a href="https://github.com/search?q=slog-+language%3AGo&amp;type=repositories&amp;l=Go" target="_blank" rel="external">GitHub</a> 和这篇 <a href="https://tip.golang.org/wiki/Resources-for-slog" target="_blank" rel="external">Go Wiki 页面</a>上找到社区创建的几个自定义处理程序。 一些值得关注的例子包括：</p>
<ul>
<li><a href="https://github.com/lmittmann/tint" target="_blank" rel="external">tint</a> - 用于写入带颜色的日志（彩色日志）。</li>
<li><a href="https://github.com/samber/slog-sampling" target="_blank" rel="external">slog-sampling</a> - 通过丢弃重复的日志记录来提高日志处理吞吐量。</li>
<li><a href="https://github.com/samber/slog-multi" target="_blank" rel="external">slog-multi</a> - 实现中间件、扇出、路由、故障转移、负载均衡等工作流。</li>
<li><a href="https://github.com/samber/slog-formatter" target="_blank" rel="external">slog-formatter</a> - 提供更灵活的属性格式化。</li>
</ul>
<h2 id="使用_context_包">使用 context 包</h2>
<p>到目前为止，我们主要使用的是诸如 <code>Info()</code> 和 <code>Debug()</code> 等标准级别的函数，但 slog 还提供了支持 <code>context</code> 的变体，这些变体将 <code>context.Context</code> 值作为第一个参数。下面是每个函数的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (ctx context.Context, msg <span class="typename">string</span>, args ...any)</div></pre></td></tr></table></figure>

<p>使用这些方法，您可以通过将上下文属性存储在 <code>Context</code> 中来跨函数传播它们，这样当找到这些值时，它们就会被添加到任何生成的日志记录中。</p>
<p>请考虑以下程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"log/slog"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    logger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>))</div><div class="line"></div><div class="line">    ctx := context.WithValue(context.Background(), <span class="string">"request_id"</span>, <span class="string">"req-123"</span>)</div><div class="line"></div><div class="line">    logger.InfoContext(ctx, <span class="string">"image uploaded"</span>, slog.String(<span class="string">"image_id"</span>, <span class="string">"img-998"</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在代码中，我们向 <code>ctx</code> 变量添加了一个 <code>request_id</code> 并传递给了 <code>InfoContext</code> 方法。然而，运行程序后，日志中却没有出现 <code>request_id</code> 字段。</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2024-01-02T11:04:28.590527494+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"image uploaded"</span></span>,</div><div class="line">  "<span class="attribute">image_id</span>": <span class="value"><span class="string">"img-998"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了实现这一功能，你需要创建一个自定义处理程序并重新实现 <code>Handle</code> 方法，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ctxKey <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    slogFields ctxKey = <span class="string">"slog_fields"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> ContextHandler <span class="keyword">struct</span> {</div><div class="line">    slog.Handler</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Handle adds contextual attributes to the Record before calling the underlying</span></div><div class="line"><span class="comment">// handler</span></div><div class="line"><span class="keyword">func</span> (h ContextHandler) Handle(ctx context.Context, r slog.Record) error {</div><div class="line">    <span class="keyword">if</span> attrs, ok := ctx.Value(slogFields).([]slog.Attr); ok {</div><div class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> attrs {</div><div class="line">            r.AddAttrs(v)</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> h.Handler.Handle(ctx, r)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// AppendCtx adds an slog attribute to the provided context so that it will be</span></div><div class="line"><span class="comment">// included in any Record created with such context</span></div><div class="line"><span class="keyword">func</span> AppendCtx(parent context.Context, attr slog.Attr) context.Context {</div><div class="line">    <span class="keyword">if</span> parent == <span class="constant">nil</span> {</div><div class="line">        parent = context.Background()</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> v, ok := parent.Value(slogFields).([]slog.Attr); ok {</div><div class="line">        v = <span class="built_in">append</span>(v, attr)</div><div class="line">        <span class="keyword">return</span> context.WithValue(parent, slogFields, v)</div><div class="line">    }</div><div class="line"></div><div class="line">    v := []slog.Attr{}</div><div class="line">    v = <span class="built_in">append</span>(v, attr)</div><div class="line">    <span class="keyword">return</span> context.WithValue(parent, slogFields, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>ContextHandler</code> 结构体嵌入了 <code>slog.Handler</code> 接口，并实现了 <code>Handle</code> 方法。该方法的作用是提取提供者上下文 (context) 中存储的 Slog 属性。如果找到这些属性，它们将被添加到日志记录 (<code>Record</code>) 中。 然后，底层的处理程序 (Handler) 会被调用，负责格式化并输出这条日志记录。</p>
<p>另一方面，<code>AppendCtx</code> 函数用于向 <code>context.Context</code> 中添加 Slog 属性。它使用 <code>slogFields</code> 这个键作为标识符，使得 <code>ContextHandler</code> 能够访问这些属性。</p>
<p>下面将介绍如何同时使用这两个部分来让 request_id 信息出现在日志中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    h := &ContextHandler{slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>)}</div><div class="line"></div><div class="line">    logger := slog.New(h)</div><div class="line"></div><div class="line">    ctx := AppendCtx(context.Background(), slog.String(<span class="string">"request_id"</span>, <span class="string">"req-123"</span>))</div><div class="line"></div><div class="line">    logger.InfoContext(ctx, <span class="string">"image uploaded"</span>, slog.String(<span class="string">"image_id"</span>, <span class="string">"img-998"</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在您将观察到，使用 ctx 参数创建的任何日志记录中都包含了 <code>request_id</code> 信息。</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2024-01-02T11:29:15.229984723+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"image uploaded"</span></span>,</div><div class="line">  "<span class="attribute">image_id</span>": <span class="value"><span class="string">"img-998"</span></span>,</div><div class="line">  "<span class="attribute">request_id</span>": <span class="value"><span class="string">"req-123"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="slog_错误日志记录">slog 错误日志记录</h2>
<p>与大多数框架不同，slog 没有为 <code>error</code> 类型提供特定的日志记录助手函数。因此，您需要像这样使用 <code>slog.Any()</code> 记录错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">err := errors.New(<span class="string">"something happened"</span>)</div><div class="line"></div><div class="line">logger.ErrorContext(ctx, <span class="string">"upload failed"</span>, slog.Any(<span class="string">"error"</span>, err))</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2024-01-02T14:13:44.41886393+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"ERROR"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"upload failed"</span></span>,</div><div class="line">  "<span class="attribute">error</span>": <span class="value"><span class="string">"something happened"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了获取并记录错误的堆栈跟踪信息，您可以使用诸如 <a href="https://github.com/MDobak/go-xerrors" target="_blank" rel="external">xerrors</a> 之类的库来创建带有堆栈跟踪的错误对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">err := xerrors.New(<span class="string">"something happened"</span>)</div><div class="line"></div><div class="line">logger.ErrorContext(ctx, <span class="string">"upload failed"</span>, slog.Any(<span class="string">"error"</span>, err))</div></pre></td></tr></table></figure>

<p>为了在错误日志中看到堆栈跟踪信息，您还需要像之前提到的 <code>ReplaceAttr()</code> 函数一样，提取、格式化并将其添加到对应的 Record 中。</p>
<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"log/slog"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"path/filepath"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/mdobak/go-xerrors"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> stackFrame <span class="keyword">struct</span> {</div><div class="line">    Func   <span class="typename">string</span> <span class="string">`json:"func"`</span></div><div class="line">    Source <span class="typename">string</span> <span class="string">`json:"source"`</span></div><div class="line">    Line   <span class="typename">int</span>    <span class="string">`json:"line"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> replaceAttr(_ []<span class="typename">string</span>, a slog.Attr) slog.Attr {</div><div class="line">    <span class="keyword">switch</span> a.Value.Kind() {</div><div class="line">    <span class="keyword">case</span> slog.KindAny:</div><div class="line">        <span class="keyword">switch</span> v := a.Value.Any().(<span class="keyword">type</span>) {</div><div class="line">        <span class="keyword">case</span> error:</div><div class="line">            a.Value = fmtErr(v)</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> a</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// marshalStack extracts stack frames from the error</span></div><div class="line"><span class="keyword">func</span> marshalStack(err error) []stackFrame {</div><div class="line">    trace := xerrors.StackTrace(err)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(trace) ==<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">    }</div><div class="line"></div><div class="line">    frames := trace.Frames()</div><div class="line"></div><div class="line">    s := <span class="built_in">make</span>([]stackFrame, <span class="built_in">len</span>(frames))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> frames {</div><div class="line">        f := stackFrame{</div><div class="line">            Source: filepath.Join(</div><div class="line">                filepath.Base(filepath.Dir(v.File)),</div><div class="line">                filepath.Base(v.File),</div><div class="line">            ),</div><div class="line">            Func: filepath.Base(v.Function),</div><div class="line">            Line: v.Line,</div><div class="line">        }</div><div class="line"></div><div class="line">        s[i] = f</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// fmtErr returns a slog.Value with keys `msg` and `trace`. If the error</span></div><div class="line"><span class="comment">// does not implement interface { StackTrace() errors.StackTrace }, the `trace`</span></div><div class="line"><span class="comment">// key is omitted.</span></div><div class="line"><span class="keyword">func</span> fmtErr(err error) slog.Value {</div><div class="line">    <span class="keyword">var</span> groupValues []slog.Attr</div><div class="line"></div><div class="line">    groupValues = <span class="built_in">append</span>(groupValues, slog.String(<span class="string">"msg"</span>, err.Error()))</div><div class="line"></div><div class="line">    frames := marshalStack(err)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> frames != <span class="constant">nil</span> {</div><div class="line">        groupValues = <span class="built_in">append</span>(groupValues,</div><div class="line">            slog.Any(<span class="string">"trace"</span>, frames),</div><div class="line">        )</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> slog.GroupValue(groupValues...)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    h := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{</div><div class="line">        ReplaceAttr: replaceAttr,</div><div class="line">    })</div><div class="line"></div><div class="line">    logger := slog.New(h)</div><div class="line"></div><div class="line">    ctx := context.Background()</div><div class="line"></div><div class="line">    err := xerrors.New(<span class="string">"something happened"</span>)</div><div class="line"></div><div class="line">    logger.ErrorContext(ctx, <span class="string">"image uploaded"</span>, slog.Any(<span class="string">"error"</span>, err))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>结合以上步骤，任何使用 <code>xerrors.New()</code> 创建的错误都将以如下格式记录，其中包含格式良好的堆栈跟踪信息：</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2024-01-03T07:09:31.013954119+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"ERROR"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"image uploaded"</span></span>,</div><div class="line">  "<span class="attribute">error</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">msg</span>": <span class="value"><span class="string">"something happened"</span></span>,</div><div class="line">    "<span class="attribute">trace</span>": <span class="value">[</span></div><div class="line">      {</div><div class="line">        "<span class="attribute">func</span>": <span class="value"><span class="string">"main.main"</span></span>,</div><div class="line">        "<span class="attribute">source</span>": <span class="value"><span class="string">"slog/main.go"</span></span>,</div><div class="line">        "<span class="attribute">line</span>": <span class="value"><span class="number">82</span></span></div><div class="line">      },</div><div class="line">      {</div><div class="line">        "<span class="attribute">func</span>": <span class="value"><span class="string">"runtime.main"</span></span>,</div><div class="line">        "<span class="attribute">source</span>": <span class="value"><span class="string">"runtime/proc.go"</span></span>,</div><div class="line">        "<span class="attribute">line</span>": <span class="value"><span class="number">267</span></span></div><div class="line">      },</div><div class="line">      {</div><div class="line">        "<span class="attribute">func</span>": <span class="value"><span class="string">"runtime.goexit"</span></span>,</div><div class="line">        "<span class="attribute">source</span>": <span class="value"><span class="string">"runtime/asm_amd64.s"</span></span>,</div><div class="line">        "<span class="attribute">line</span>": <span class="value"><span class="number">1650</span></span></div><div class="line">      }</div><div class="line">    ]</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在您可以轻松跟踪应用程序中任何意外错误的执行路径。</p>
<h2 id="使用_LogValuer_接口隐藏敏感字段">使用 LogValuer 接口隐藏敏感字段</h2>
<p><code>LogValuer</code> 接口允许您通过指定自定义类型的日志输出方式来标准化日志记录。以下是该接口的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> LogValuer <span class="keyword">interface</span> {</div><div class="line">    LogValue() Value</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实现了该接口的主要用途之一是在自定义类型中隐藏敏感字段。例如，这里有一个 <code>User</code> 类型，它没有实现 <code>LogValuer</code> 接口。请注意，当实例被记录时，敏感细节是如何暴露出来的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// User does not implement `LogValuer` here</span></div><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    ID        <span class="typename">string</span> <span class="string">`json:"id"`</span></div><div class="line">    FirstName <span class="typename">string</span> <span class="string">`json:"first_name"`</span></div><div class="line">    LastName  <span class="typename">string</span> <span class="string">`json:"last_name"`</span></div><div class="line">    Email     <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password  <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    handler := slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>)</div><div class="line">    logger := slog.New(handler)</div><div class="line"></div><div class="line">    u := &User{</div><div class="line">        ID:        <span class="string">"user-12234"</span>,</div><div class="line">        FirstName: <span class="string">"Jan"</span>,</div><div class="line">        LastName:  <span class="string">"Doe"</span>,</div><div class="line">        Email:     <span class="string">"jan@example.com"</span>,</div><div class="line">        Password:  <span class="string">"pass-12334"</span>,</div><div class="line">    }</div><div class="line"></div><div class="line">    logger.Info(<span class="string">"info"</span>, <span class="string">"user"</span>, u)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-02-26T22:11:30.080656774+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"info"</span></span>,</div><div class="line">  "<span class="attribute">user</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">id</span>": <span class="value"><span class="string">"user-12234"</span></span>,</div><div class="line">    "<span class="attribute">first_name</span>": <span class="value"><span class="string">"Jan"</span></span>,</div><div class="line">    "<span class="attribute">last_name</span>": <span class="value"><span class="string">"Doe"</span></span>,</div><div class="line">    "<span class="attribute">email</span>": <span class="value"><span class="string">"jan@example.com"</span></span>,</div><div class="line">    "<span class="attribute">password</span>": <span class="value"><span class="string">"pass-12334"</span></span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于该类型包含不应该出现在日志中的秘密字段（例如电子邮件和密码），这会带来问题，并且也可能使您的日志变得冗长。</p>
<p>您可以通过指定类型在日志中的表示方式来解决这个问题。例如，您可以仅指定记录 <code>ID</code> 字段，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// implement the `LogValuer` interface on the User struct</span></div><div class="line"><span class="keyword">func</span> (u User) LogValue() slog.Value {</div><div class="line">    <span class="keyword">return</span> slog.StringValue(u.ID)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>You will now observe the following output:</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-02-26T22:43:28.184363059+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"info"</span></span>,</div><div class="line">  "<span class="attribute">user</span>": <span class="value"><span class="string">"user-12234"</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了隐藏敏感字段，您还可以像这样对多个属性进行分组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (u User) LogValue() slog.Value {</div><div class="line">    <span class="keyword">return</span> slog.GroupValue(</div><div class="line">        slog.String(<span class="string">"id"</span>, u.ID),</div><div class="line">        slog.String(<span class="string">"name"</span>, u.FirstName+<span class="string">" "</span>+u.LastName),</div><div class="line">    )</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">  "<span class="attribute">time</span>": <span class="value"><span class="string">"2023-03-15T14:44:24.223381036+01:00"</span></span>,</div><div class="line">  "<span class="attribute">level</span>": <span class="value"><span class="string">"INFO"</span></span>,</div><div class="line">  "<span class="attribute">msg</span>": <span class="value"><span class="string">"info"</span></span>,</div><div class="line">  "<span class="attribute">user</span>": <span class="value">{</span></div><div class="line">    "<span class="attribute">id</span>": <span class="value"><span class="string">"user-12234"</span></span>,</div><div class="line">    "<span class="attribute">name</span>": <span class="value"><span class="string">"Jan Doe"</span></span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用第三方日志后端与_Slog_集成">使用第三方日志后端与 Slog 集成</h2>
<p>slog 设计的主要目标之一是在 Go 应用程序中提供统一的日志记录前端（<code>slog.Logger</code>），同时后端（<code>slog.Handler</code>）可以根据程序进行定制。</p>
<p>这样一来，即使后端不同，所有依赖项使用的日志记录 API 都是一致的。 同时，通过使切换不同的后端变得简单，避免了将日志记录实现与特定包耦合在一起。</p>
<p>以下示例展示了将 Slog 前端与 Zap 后端结合使用，可以实现两者的优势：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> get <span class="keyword">go</span>.uber.org/zap</div><div class="line">$ <span class="keyword">go</span> get <span class="keyword">go</span>.uber.org/zap/exp/zapslog</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"log/slog"</span></div><div class="line"></div><div class="line">    <span class="string">"go.uber.org/zap"</span></div><div class="line">    <span class="string">"go.uber.org/zap/exp/zapslog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    zapL := zap.Must(zap.NewProduction())</div><div class="line"></div><div class="line">    <span class="keyword">defer</span> zapL.Sync()</div><div class="line"></div><div class="line">    logger := slog.New(zapslog.NewHandler(zapL.Core(), <span class="constant">nil</span>))</div><div class="line"></div><div class="line">    logger.Info(</div><div class="line">        <span class="string">"incoming request"</span>,</div><div class="line">        slog.String(<span class="string">"method"</span>, <span class="string">"GET"</span>),</div><div class="line">        slog.String(<span class="string">"path"</span>, <span class="string">"/api/user"</span>),</div><div class="line">        slog.Int(<span class="string">"status"</span>,<span class="number"> 200</span>),</div><div class="line">    )</div><div class="line">}</div></pre></td></tr></table></figure>

<p>该代码片段创建了一个新的 <code>Zap</code> 生产环境日志记录器，然后通过 <code>zapslog.NewHandler()</code> 将其用作 Slog 包的处理程序。配置完成后，您只需使用 <code>slog.Logger</code> 提供的方法写入日志，生成的日志记录将根据提供的 <code>zapL</code> 配置进行处理。</p>
<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">level</span>":<span class="value"><span class="string">"info"</span></span>,"<span class="attribute">ts</span>":<span class="value"><span class="number">1697453912.4535635</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"incoming request"</span></span>,"<span class="attribute">method</span>":<span class="value"><span class="string">"GET"</span></span>,"<span class="attribute">path</span>":<span class="value"><span class="string">"/api/user"</span></span>,"<span class="attribute">status</span>":<span class="value"><span class="number">200</span></span>}</div></pre></td></tr></table></figure>

<p>由于日志记录是通过 <code>slog.Logger</code> 来完成的，因此切换到不同的日志记录器真的非常简单。例如，你可以像这样从 <code>Zap</code> 切换到 <code>Zerolog</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> get github.com/rs/zerolog</div><div class="line">$ <span class="keyword">go</span> get github.com/samber/slog-zerolog</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"log/slog"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/rs/zerolog"</span></div><div class="line">    slogzerolog <span class="string">"github.com/samber/slog-zerolog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    zerologL := zerolog.New(os.Stdout).Level(zerolog.InfoLevel)</div><div class="line"></div><div class="line">    logger := slog.New(</div><div class="line">        slogzerolog.Option{Logger: &zerologL}.NewZerologHandler(),</div><div class="line">    )</div><div class="line"></div><div class="line">    logger.Info(</div><div class="line">        <span class="string">"incoming request"</span>,</div><div class="line">        slog.String(<span class="string">"method"</span>, <span class="string">"GET"</span>),</div><div class="line">        slog.String(<span class="string">"path"</span>, <span class="string">"/api/user"</span>),</div><div class="line">        slog.Int(<span class="string">"status"</span>,<span class="number"> 200</span>),</div><div class="line">    )</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">level</span>":<span class="value"><span class="string">"info"</span></span>,"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-10-16T13:22:33+02:00"</span></span>,"<span class="attribute">method</span>":<span class="value"><span class="string">"GET"</span></span>,"<span class="attribute">path</span>":<span class="value"><span class="string">"/api/user"</span></span>,"<span class="attribute">status</span>":<span class="value"><span class="number">200</span></span>,"<span class="attribute">message</span>":<span class="value"><span class="string">"incoming request"</span></span>}</div></pre></td></tr></table></figure>

<p>在上面的代码片段中，<code>Zap</code> 处理器已被自定义的 <code>Zerolog</code> 处理器替换。由于日志记录不是使用任何库的自定义 API 完成的，因此迁移过程只需几分钟，相比之下，如果你需要在整个应用程序中从一个日志记录 API 切换到另一个，那将需要更长时间。</p>
<h2 id="Go_日志编写和存储的最佳实践">Go 日志编写和存储的最佳实践</h2>
<p>一旦你配置了 Slog 或你偏好的第三方 Go 日志记录框架，为确保你能够从应用程序日志中获得最大价值，有必要采用以下最佳实践：</p>
<p><strong>1、标准化你的日志接口</strong><br>实现 <code>LogValuer</code> 接口可以确保你的应用程序中的各种类型在日志记录时的表现一致。这也是确保敏感字段不被包含在应用程序日志中的有效策略，正如我们在本文前面所探讨的。</p>
<p><strong>2、在错误日志中添加堆栈跟踪</strong><br>为了提高在生产环境中调试意外问题的能力，你应该在错误日志中添加堆栈跟踪。这样，你就能够更容易地定位错误在代码库中的起源以及导致问题的程序流程。</p>
<p>目前，Slog 并没有提供将堆栈跟踪添加到错误中的内置方式，但正如我们之前所展示的，可以使用像 <a href="https://github.com/pkg/errors" target="_blank" rel="external">pkgerrors</a> 或 <a href="https://github.com/MDobak/go-xerrors" target="_blank" rel="external">go-xerrors</a> 这样的包，配合一些辅助函数来实现这一功能。</p>
<p><strong>3、Lint Slog 语句以确保一致性</strong><br>Slog API 的一个主要缺点是它允许两种不同类型的参数，这可能导致代码库中的不一致性。除此之外，你还希望强制执行一致的键名约定（如 snake_case、camelCase 等），或者要求日志调用始终包括上下文参数。</p>
<p>像 <a href="https://github.com/go-simpler/sloglint/releases" target="_blank" rel="external">sloglint</a> 这样的 linter 可以帮助你基于你偏好的代码风格来强制执行 Slog 的各种规则。以下是通过 <a href="https://freshman.tech/linting-golang/" target="_blank" rel="external">golangci-lint</a> 使用时的一个示例配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">linters-settings:</div><div class="line">  sloglint:</div><div class="line">    # Enforce <span class="keyword">not</span> mixing key-value pairs <span class="keyword">and</span> attributes.</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">true</span></div><div class="line">    no-mixed-args: <span class="literal">false</span></div><div class="line">    # Enforce using key-value pairs only (overrides no-mixed-args, incompatible <span class="keyword">with</span> attr-only).</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">false</span></div><div class="line">    kv-only: <span class="literal">true</span></div><div class="line">    # Enforce using attributes only (overrides no-mixed-args, incompatible <span class="keyword">with</span> kv-only).</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">false</span></div><div class="line">    attr-only: <span class="literal">true</span></div><div class="line">    # Enforce using methods that accept a context.</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">false</span></div><div class="line">    context-only: <span class="literal">true</span></div><div class="line">    # Enforce using static values <span class="keyword">for</span> <span class="built_in">log</span> messages.</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">false</span></div><div class="line">    static-msg: <span class="literal">true</span></div><div class="line">    # Enforce using constants instead of raw keys.</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">false</span></div><div class="line">    no-raw-keys: <span class="literal">true</span></div><div class="line">    # Enforce a single key naming convention.</div><div class="line">    # Values: snake, kebab, camel, pascal</div><div class="line">    # <span class="keyword">Default</span>: <span class="string">""</span></div><div class="line">    key-naming-<span class="keyword">case</span>: snake</div><div class="line">    # Enforce putting arguments <span class="keyword">on</span> separate lines.</div><div class="line">    # <span class="keyword">Default</span>: <span class="literal">false</span></div><div class="line">    args-<span class="keyword">on</span>-sep-lines: <span class="literal">true</span></div></pre></td></tr></table></figure>

<p><strong>4、集中管理日志，但首先将其持久化到本地文件</strong></p>
<p>将日志记录与将它们发送到集中式日志管理系统的任务解耦通常是更好的做法。首先将日志写入本地文件可以确保在日志管理系统或网络出现问题时有一个备份，防止重要数据的潜在丢失。</p>
<p>此外，在发送日志之前先将其存储在本地，有助于缓冲日志，允许批量传输以优化网络带宽的使用，并最小化对应用程序性能的影响。</p>
<p>本地日志存储还提供了更大的灵活性，因此如果需要过渡到不同的日志管理系统，则只需修改发送方法，而无需修改整个应用程序的日志记录机制。有关使用 <a href="https://betterstack.com/community/guides/logging/vector-explained/" target="_blank" rel="external">Vector</a> 或 <a href="https://betterstack.com/community/guides/logging/fluentd-explained/" target="_blank" rel="external">Fluentd</a> 等专用日志发送程序的更多详细信息，请参阅<a href="https://betterstack.com/community/guides/logging/log-shippers-explained/" target="_blank" rel="external">我们的文章</a>。</p>
<p>将日志记录到文件并不一定要求你配置所选的框架直接写入文件，因为 <a href="https://betterstack.com/community/guides/logging/how-to-control-systemd-with-systemctl/" target="_blank" rel="external">Systemd</a> 可以轻松地将应用程序的标准输出和错误流重定向到文件。<a href="https://betterstack.com/community/guides/logging/how-to-start-logging-with-docker/" target="_blank" rel="external">Docker</a> 也默认收集发送到这两个流的所有数据，并将它们路由到主机上的本地文件。</p>
<p><strong> 5、对日志进行采样</strong></p>
<p>日志采样是一种只记录日志条目中具有代表性的子集，而不是记录每个日志事件的做法。在高流量环境中，系统会产生大量的日志数据，而处理每个条目可能成本高昂，因为集中式日志解决方案通常根据数据摄入率或存储量进行收费，因此这种技术非常有用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log/slog"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line"></div><div class="line">    slogmulti <span class="string">"github.com/samber/slog-multi"</span></div><div class="line">    slogsampling <span class="string">"github.com/samber/slog-sampling"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// Will print 20% of entries.</span></div><div class="line">    option := slogsampling.UniformSamplingOption{</div><div class="line">        Rate:<span class="number"> 0.2</span>,</div><div class="line">    }</div><div class="line"></div><div class="line">    logger := slog.New(</div><div class="line">        slogmulti.</div><div class="line">            Pipe(option.NewMiddleware()).</div><div class="line">            Handler(slog.NewJSONHandler(os.Stdout, <span class="constant">nil</span>)),</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 1</span>; i &lt;=<span class="number"> 10</span>; i++ {</div><div class="line">        logger.Info(fmt.Sprintf(<span class="string">"a message from the gods: %d"</span>, i))</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight log"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-10-18T19:14:09.820090798+02:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"a message from the gods: 4"</span></span>}</div><div class="line">{"<span class="attribute">time</span>":<span class="value"><span class="string">"2023-10-18T19:14:09.820117844+02:00"</span></span>,"<span class="attribute">level</span>":<span class="value"><span class="string">"INFO"</span></span>,"<span class="attribute">msg</span>":<span class="value"><span class="string">"a message from the gods: 5"</span></span>}</div></pre></td></tr></table></figure>

<p>第三方框架，如 Zerolog 和 Zap，提供了内置的日志采样功能。在使用 Slog 时，你需要集成一个第三方处理器，如 <a href="https://github.com/samber/slog-sampling" target="_blank" rel="external">slog-sampling</a>，或开发一个自定义解决方案。你还可以通过专用的日志发送程序（如 Vector）来选择对日志进行采样。</p>
<p><strong>6、使用日志管理服务</strong></p>
<p>将日志集中在一个日志管理系统中，可以方便地跨多个服务器和环境搜索、分析和监控应用程序的行为。将所有日志集中在一个地方，可以显著提高你识别和诊断问题的能力，因为你不再需要在不同的服务器之间跳转来收集有关你的服务的信息。</p>
<p><img src="log.png" alt=""></p>
<p>虽然市面上有很多日志管理解决方案，但 Better Stack 提供了一种简单的方法，可以在几分钟内设置集中式日志管理，其内置了实时追踪、报警、仪表板、正常运行时间监控和事件管理功能，并通过现代化和直观的用户界面进行展示。在这里，你可以通过完全免费的计划来试用它。</p>
<h2 id="总结">总结</h2>
<p>我希望这篇文章能让你对 Go 语言中新的结构化日志包有所了解，以及如何在你的项目中使用它。如果你想进一步探索这个话题，我建议你查看<a href="https://go.googlesource.com/proposal/+/master/design/56345-structured-logging.md" target="_blank" rel="external">完整的提案</a>和<a href="https://pkg.go.dev/log/slog" target="_blank" rel="external">包文档</a>。</p>
<p>感谢阅读，祝你在日志记录方面一切顺利！</p>
<h2 id="补充信息">补充信息</h2>
<p>q其他一些和slog有关的资源。</p>
<h3 id="通用处理器">通用处理器</h3>
<ul>
<li><a href="https://github.com/samber/slog-multi" target="_blank" rel="external">slog-multi</a>：处理器链（管道、路由器、扇出等）。</li>
<li><a href="https://github.com/samber/slog-sampling" target="_blank" rel="external">slog-sampling</a>：丢弃重复的日志条目。</li>
<li><a href="https://github.com/sagikazarmark/slog-shim" target="_blank" rel="external">slog-shim</a>：为 Go &lt;1.21 提供向后兼容的 slog 支持。</li>
<li><a href="https://github.com/go-simpler/sloggen" target="_blank" rel="external">sloggen</a>：生成各种辅助工具。</li>
<li><a href="https://github.com/go-simpler/sloglint" target="_blank" rel="external">sloglint</a>：确保一致的代码风格。</li>
</ul>
<h3 id="格式化">格式化</h3>
<p>提供日志格式化的库。</p>
<ul>
<li><a href="https://github.com/phsym/console-slog" target="_blank" rel="external">console-slog</a>：处理程序，可打印彩色日志，类似于 zerolog 的console writer，且不会牺牲性能。</li>
<li><a href="https://github.com/golang-cz/devslog" target="_blank" rel="external">devslog</a>：为开发环境格式化日志。</li>
<li><a href="https://github.com/samber/slog-formatter" target="_blank" rel="external">slog-formatter</a>：slog 的通用格式化程序，以及构建自定义格式化程序的辅助工具。</li>
<li><a href="https://gitlab.com/greyxor/slogor" target="_blank" rel="external">slogor</a>：一个彩色 slog 处理程序。</li>
<li><a href="https://github.com/dpotapov/slogpfx" target="_blank" rel="external">slogpfx</a>：可以轻松使用日志记录中的属性为日志消息添加前缀。</li>
<li><a href="https://github.com/lmittmann/tint" target="_blank" rel="external">tint</a>：处理程序，可写入带有颜色的日志。</li>
<li><a href="https://github.com/jeffry-luqman/zlog" target="_blank" rel="external">zlog</a>：处理程序，可写入美观、易于阅读的日志。</li>
</ul>
<h3 id="日志增强">日志增强</h3>
<p>用于丰富日志记录的处理程序。</p>
<ul>
<li><a href="https://github.com/m-mizutani/masq" target="_blank" rel="external">masq</a>：在日志中脱敏敏感数据。</li>
<li><a href="https://github.com/go-slog/otelslog" target="_blank" rel="external">otelslog</a>：处理程序，将 OpenTelemetry 跟踪和资源详细信息附加到日志中。</li>
<li><a href="https://github.com/PumpkinSeed/slog-context" target="_blank" rel="external">slog-context</a>：通过上下文将任意键值对附加到日志记录中。</li>
</ul>
<h3 id="日志转发">日志转发</h3>
<p>一些厂家提供了将slog转发到它们平台上的功能，比如datadog、sentry等,这里就不赘述了，因为这些都是第三方的服务，在国内也不太合适使用。其他一些转发的库：</p>
<ul>
<li><a href="https://github.com/samber/slog-kafka" target="_blank" rel="external">slog-kafka</a>: Handler forwarding logs to Kafka.</li>
<li><a href="https://github.com/samber/slog-syslog" target="_blank" rel="external">slog-syslog</a>: Handler forwarding logs to Syslog.</li>
<li><a href="https://github.com/samber/slog-webhook" target="_blank" rel="external">slog-webhook</a>: Handler forwarding logs to a Webhook.</li>
<li><a href="https://github.com/samber/slog-channel" target="_blank" rel="external">slog-channel</a>: Handler for Go channels</li>
</ul>
<h3 id="和其它日志框架集成">和其它日志框架集成</h3>
<p>其他日志库的适配器。</p>
<ul>
<li><a href="https://github.com/evanphx/go-hclog-slog" target="_blank" rel="external">go-hclog-slog</a>：hclog 的处理程序适配器。</li>
<li><a href="https://github.com/samber/slog-logrus" target="_blank" rel="external">slog-logrus</a>：logrus 的处理程序适配器。</li>
<li><a href="https://github.com/samber/slog-zap" target="_blank" rel="external">slog-zap</a>：zap 的处理程序适配器。</li>
<li><a href="https://github.com/samber/slog-zerolog" target="_blank" rel="external">slog-zerolog</a>：zerolog 的处理程序适配器。</li>
<li><a href="https://github.com/chanchal1987/zaphandler" target="_blank" rel="external">zaphandler</a>：Zap 的处理程序适配器。</li>
</ul>
<h3 id="集成到web框架">集成到web框架</h3>
<ul>
<li><a href="https://github.com/FabienMht/ginslog" target="_blank" rel="external">ginslog</a>: A fully featured Gin middleware.</li>
<li><a href="https://github.com/samber/slog-chi" target="_blank" rel="external">slog-chi</a>: Chi middleware.</li>
<li><a href="https://github.com/samber/slog-echo" target="_blank" rel="external">slog-echo</a>: Echo middleware.</li>
<li><a href="https://github.com/samber/slog-fiber" target="_blank" rel="external">slog-fiber</a>: Fiber middleware.</li>
<li><a href="https://github.com/samber/slog-gin" target="_blank" rel="external">slog-gin</a>: Gin middleware.</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li><a href="https://go-review.googlesource.com/c/go/+/548335/5/src/log/slog/example_discard_test.go" target="_blank" rel="external">discard logger</a>: 丢弃用的logger</li>
<li><a href="https://pkg.go.dev/testing/slogtest@go1.22.1" target="_blank" rel="external">slogtest</a>: 测试 handler</li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://betterstack.com/community/guides/logging/logging-in-go/" target="_blank" rel="external">Logging in Go with Slog: The Ultimate Guide</a> by Ayooluwa Isaiah.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现一个友好的堆]]></title>
    <link href="https://colobu.com/2024/03/07/implement-a-heap-in-go/"/>
    <id>https://colobu.com/2024/03/07/implement-a-heap-in-go/</id>
    <published>2024-03-07T13:30:47.000Z</published>
    <updated>2024-03-26T09:37:28.195Z</updated>
    <content type="html"><![CDATA[<p>在上一篇文章中，我吐槽了Go标准库的堆实现，基于“you can you up, no can no BB”的理论，这篇文章我来实现一个友好的堆。</p>
<a id="more"></a>
<p>我们使用堆的时候，一般希望有<code>Heap</code>这样一个对象，并且能指定它是“小根堆”或者&quot;大根堆&quot;。我们希望这个类型有<code>Push</code>和<code>Pop</code>方法，可以加入一个元素或者弹出(最小的)元素。</p>
<p>我们期望这个<code>Heap</code>支持泛型的，任何可以比较的类型都可以使用。</p>
<p>处于简化的考虑，我们实现的<code>Heap</code>不考虑线程安全。如果要保证线程安全，可以使用<code>sync.Mutex</code>来保护<code>Heap</code>的操作。</p>
<p>我们实现的<code>Heap</code>类型的操作基于标准库的操作，只不过我们封装了一下，让它更加友好。</p>
<p>我们能够基于既有的一个slice创建<code>Heap</code>，也可以基于一个空的<code>Heap</code>创建一个新的<code>Heap</code>。</p>
<p>最终我们实现了一个友好的堆，你可以在github上查看它的代码<a href="https://github.com/smallnest/exp/blob/master/container/heap/binheap.go" target="_blank" rel="external">binheap</a>。</p>
<p>首先定义一个<code>binHeap</code>,这是一个泛型的slice,用来保存堆的元素，这样用户就不用定义这样一个类型了，简化了用户的使用。默认是小根堆。所有元素类型需要满足<code>cmp.Ordered</code>接口，可以进行大小比较。这个接口是标准库中的接口，如果你还不知道<code>cmp</code>包，那么需要刷新刷新Go新的变化了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> heap</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"cmp"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> binHeap[V cmp.Ordered] []V</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h binHeap[V]) Len() <span class="typename">int</span>           { <span class="keyword">return</span> <span class="built_in">len</span>(h) }</div><div class="line"><span class="keyword">func</span> (h binHeap[V]) Less(i, j <span class="typename">int</span>) <span class="typename">bool</span> { <span class="keyword">return</span> h[i] &lt; h[j] }</div><div class="line"><span class="keyword">func</span> (h binHeap[V]) Swap(i, j <span class="typename">int</span>)      { h[i], h[j] = h[j], h[i] }</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h *binHeap[V]) Push(x V) {</div><div class="line">	*h = <span class="built_in">append</span>(*h, x)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h *binHeap[V]) Pop() V {</div><div class="line">	old := *h</div><div class="line">	n := <span class="built_in">len</span>(old)</div><div class="line">	x := old[n<span class="number">-1</span>]</div><div class="line">	*h = old<span class="number">[0</span> : n<span class="number">-1</span>]</div><div class="line">	<span class="keyword">return</span> x</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样我们就可以定义一个<code>BinHeap</code>类型，它是<code>binHeap</code>的封装，它有<code>maxHeap</code>字段，用来表示是小根堆还是大根堆。<code>BinHeap</code>类型有<code>Push</code>和<code>Pop</code>方法，可以加入一个元素或者弹出(最小的)元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BinHeap[V cmp.Ordered] <span class="keyword">struct</span> {</div><div class="line">	maxHeap <span class="typename">bool</span></div><div class="line">	binHeap binHeap[V]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// NewBinHeap returns a new binary heap.</span></div><div class="line"><span class="keyword">func</span> NewBinHeap[V cmp.Ordered](opts ...BinHeapOption[V]) *BinHeap[V] {</div><div class="line">	h := &BinHeap[V]{}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts {</div><div class="line">		opt(h)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> h</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Len returns the number of elements in the heap.</span></div><div class="line"><span class="keyword">func</span> (h *BinHeap[V]) Push(x V) {</div><div class="line">	h.binHeap.Push(x)</div><div class="line">	sift_up[V](&h.binHeap, h.binHeap.Len(<span class="number">)-1</span>, h.maxHeap)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Push pushes the element x onto the heap.</span></div><div class="line"><span class="keyword">func</span> (h *BinHeap[V]) Pop() V {</div><div class="line">	n := h.binHeap.Len() -<span class="number"> 1</span></div><div class="line">	h.binHeap.Swap<span class="number">(0</span>, n)</div><div class="line">	sift_down[V](&h.binHeap,<span class="number"> 0</span>, n, h.maxHeap)</div><div class="line">	<span class="keyword">return</span> h.binHeap.Pop()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外还附送了两个常用的方法<code>Len</code>和<code>Peek</code>，<code>Len</code>返回堆的大小，<code>Peek</code>返回堆顶元素但是并不会从堆中移除它，在和堆的最小值做比较的时候很有用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Len returns the number of elements in the heap.</span></div><div class="line"><span class="keyword">func</span> (h *BinHeap[V]) Len() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> h.binHeap.Len()</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Peek returns the element at the top of the heap without removing it.</span></div><div class="line"><span class="keyword">func</span> (h *BinHeap[V]) Peek() (V, <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">var</span> v V</div><div class="line">	<span class="keyword">if</span> h.Len() ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> v, <span class="constant">false</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> h.binHeap<span class="number">[0</span>], <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后，我们还提供了一个<code>BinHeapOption</code>类型，用来设置<code>BinHeap</code>的属性，比如是小根堆还是大根堆；为了提高性能，如果预先已经知道堆的大小，可以在初始化的时候就进行设置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WithMaxHeap returns a BinHeapOption that configures a binary heap to be a max heap.</span></div><div class="line"><span class="keyword">func</span> WithMaxHeap[V cmp.Ordered](h *BinHeap[V]) *BinHeap[V] {</div><div class="line">	h.maxHeap = <span class="constant">true</span></div><div class="line">	<span class="keyword">return</span> h</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// WithMinHeap returns a BinHeapOption that configures a binary heap to be a min heap.</span></div><div class="line"><span class="keyword">func</span> WithCapacity[V cmp.Ordered](n <span class="typename">int</span>) BinHeapOption[V] {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(h *BinHeap[V]) *BinHeap[V] {</div><div class="line">		<span class="keyword">if</span> h.binHeap == <span class="constant">nil</span> {</div><div class="line">			h.binHeap = <span class="built_in">make</span>(binHeap[V],<span class="number"> 0</span>, n)</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> h</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样我们就实现了一个友好的堆。</p>
<p>当然，如果你已经有了一个slice: <code>[]V</code>, 想把它转换成堆，并且在这个slice上进行堆操作，那么你可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewBinHeapWithInitial returns a new binary heap with the given initial slice.</span></div><div class="line"><span class="keyword">func</span> NewBinHeapWithInitial[V cmp.Ordered](s []V, opts ...BinHeapOption[V]) *BinHeap[V] {</div><div class="line">	h := &BinHeap[V]{}</div><div class="line">	h.binHeap = binHeap[V](s)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts {</div><div class="line">		opt(h)</div><div class="line">	}</div><div class="line"></div><div class="line">	n := <span class="built_in">len</span>(s)</div><div class="line">	<span class="keyword">for</span> i := n<span class="number">/2</span> -<span class="number"> 1</span>; i &gt;=<span class="number"> 0</span>; i-- {</div><div class="line">		sift_down[V](&h.binHeap, i, n, h.maxHeap)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> h</div><div class="line">}</div></pre></td></tr></table></figure>

<p>堆的操作<code>sift_down</code>和<code>sift_up</code>的堆和核心操作，也来源子标准库的代码，只不过我把它们改成成泛型的函数了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> sift_up[V cmp.Ordered](h *binHeap[V], j <span class="typename">int</span>, maxHeap <span class="typename">bool</span>) {</div><div class="line">	less := h.Less</div><div class="line">	<span class="keyword">if</span> maxHeap {</div><div class="line">		less = <span class="keyword">func</span>(i, j <span class="typename">int</span>) <span class="typename">bool</span> { <span class="keyword">return</span> !h.Less(i, j) }</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		i := (j -<span class="number"> 1</span>) /<span class="number"> 2</span> <span class="comment">// parent</span></div><div class="line">		<span class="keyword">if</span> i == j || !less(j, i) {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		h.Swap(i, j)</div><div class="line">		j = i</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> sift_down[V cmp.Ordered](h *binHeap[V], i0, n <span class="typename">int</span>, maxHeap <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	less := h.Less</div><div class="line">	<span class="keyword">if</span> maxHeap {</div><div class="line">		less = <span class="keyword">func</span>(i, j <span class="typename">int</span>) <span class="typename">bool</span> { <span class="keyword">return</span> !h.Less(i, j) }</div><div class="line">	}</div><div class="line"></div><div class="line">	i := i0</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		j1 :=<span class="number"> 2</span>*i +<span class="number"> 1</span></div><div class="line">		<span class="keyword">if</span> j1 &gt;= n || j1 &lt;<span class="number"> 0</span> { <span class="comment">// j1 &lt; 0 after int overflow</span></div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		j := j1 <span class="comment">// left child</span></div><div class="line">		<span class="keyword">if</span> j2 := j1 +<span class="number"> 1</span>; j2 &lt; n && less(j2, j1) {</div><div class="line">			j = j2 <span class="comment">// = 2*i + 2  // right child</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !less(j, i) {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		h.Swap(i, j)</div><div class="line">		i = j</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> i &gt; i0</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇文章中，我吐槽了Go标准库的堆实现，基于“you can you up, no can no BB”的理论，这篇文章我来实现一个友好的堆。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一道面试题: Top K 问题]]></title>
    <link href="https://colobu.com/2024/03/04/top-k-problem/"/>
    <id>https://colobu.com/2024/03/04/top-k-problem/</id>
    <published>2024-03-04T14:06:19.000Z</published>
    <updated>2024-03-26T09:37:28.203Z</updated>
    <content type="html"><![CDATA[<p>最近在招一个Go开发工程师，面试中时候我会问一个Top K的问题，这个问题是一个经典的面试题。</p>
<p>有时候我不会要求面试者写出答案，首先我听一下他的思想，如果写代码困难的话我都允许可以上网查标准库的文档，看看heap的用法。</p>
<p>相对来说比Redis的作者antirez的面试要轻松些了，他的面试题是要求面试者写出一个二叉搜索树。</p>
<a id="more"></a>
<p>这道题既然是经典题，很很多教科书或者算法网站上都有，比如leetcode也有，收录在<a href="https://github.com/smallnest/ebooks" target="_blank" rel="external">Leetcode 算法题解精选</a>一书中。</p>
<p><img src="problem.png" alt=""></p>
<h2 id="快速排序">快速排序</h2>
<p>我们可以采用快速排序的方法实现。<br>而且，因为我们只关心第K个最大的元素，我们只需要找出这个元素，不需要对整个数组进行完全排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从乱序的nums数组中找到第k大的数</span></div><div class="line"><span class="keyword">func</span> findKthLargest(nums []<span class="typename">int</span>, k <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    n := <span class="built_in">len</span>(nums)</div><div class="line">    <span class="comment">// 我们排序按照小的放在左边，大的放在右边的方式，所以第k大的数就是第n-k个数</span></div><div class="line">    <span class="keyword">return</span> quickselect(nums,<span class="number"> 0</span>, n -<span class="number"> 1</span>, n - k)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 返回第k大的数</span></div><div class="line"><span class="comment">// l: 数组的左边界</span></div><div class="line"><span class="comment">// r: 数组的右边界</span></div><div class="line"><span class="comment">// k: 找第k大的数</span></div><div class="line"><span class="keyword">func</span> quickselect(nums []<span class="typename">int</span>, l, r, k <span class="typename">int</span>) <span class="typename">int</span>{</div><div class="line">    <span class="keyword">if</span> (l == r){ <span class="comment">// =k</span></div><div class="line">        <span class="keyword">return</span> nums[k]</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 选取第一个数作为分区点，做一次调整</span></div><div class="line">    partition := nums[l]</div><div class="line">    i := l -<span class="number"> 1</span></div><div class="line">    j := r +<span class="number"> 1</span></div><div class="line">    <span class="keyword">for</span> (i &lt; j) {</div><div class="line">        <span class="keyword">for</span> i++;nums[i]&lt;partition;i++{}</div><div class="line">        <span class="keyword">for</span> j--;nums[j]&gt;partition;j--{}</div><div class="line">        <span class="keyword">if</span> (i &lt; j) {</div><div class="line">            nums[i],nums[j]=nums[j],nums[i]</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// 此时 i = j</span></div><div class="line"></div><div class="line">    <span class="comment">// 根据当前分区点的位置，判断k在左边还是右边</span></div><div class="line">    <span class="comment">// 如果k在分区点的左边，那么在左边继续找，右边界已经缩小到j了</span></div><div class="line">    <span class="comment">// 如果k在分区点的右边，那么在右边继续找，左边界已经缩小到j+1了</span></div><div class="line">    <span class="comment">// 通过递归，把边界逐步的缩小，直到左右两边界相等，也就是指向同一个位置，也就是函数开始的判断，就找到结果了</span></div><div class="line">    <span class="keyword">if</span> (k &lt;= j){</div><div class="line">        <span class="keyword">return</span> quickselect(nums, l, j, k) <span class="comment">// k 在左边, 则在左边继续找，右边界已经缩小到j了</span></div><div class="line">    }<span class="keyword">else</span>{ <span class="comment">// k &gt; j， k在右边</span></div><div class="line">        <span class="keyword">return</span> quickselect(nums, j +<span class="number"> 1</span>, r, k) <span class="comment">// 从j+1到r找第k大的数,左边界已经缩小到j+1了</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>递归一向都是难以理解，但是理解之后有觉得非常妙。</p>
<h2 id="堆排序">堆排序</h2>
<p>这道题一个比较简单直观的解答就是堆排序。</p>
<p>我们使用一个最小堆，堆的大小为k，然后遍历数组，如果堆的大小小于k，就把元素放入堆中，如果堆的大小等于k，就把堆顶元素(当前堆内最小的元素)和当前元素比较，如果堆顶元素小于当前元素，就把堆顶元素弹出，把当前元素放入堆中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从乱序的nums数组中找到第k大的数</span></div><div class="line"><span class="keyword">func</span> findKthLargest(nums []<span class="typename">int</span>, k <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    n := <span class="built_in">len</span>(nums)</div><div class="line">    <span class="comment">// 构建一个最小堆</span></div><div class="line">    heap := <span class="built_in">make</span>([]<span class="typename">int</span>, k)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; k; i++ {</div><div class="line">        heap[i] = nums[i]</div><div class="line">    }</div><div class="line">    <span class="comment">// 建堆</span></div><div class="line">    <span class="keyword">for</span> i := k<span class="number">/2</span> -<span class="number"> 1</span>; i &gt;=<span class="number"> 0</span>; i-- {</div><div class="line">        heapify(heap, i, k)</div><div class="line">    }</div><div class="line">    <span class="comment">// 遍历数组，如果堆的大小小于k，就把元素放入堆中，如果堆的大小等于k，就把堆顶元素和当前元素比较，如果堆顶元素大于当前元素，就把堆顶元素弹出，把当前元素放入堆中。</span></div><div class="line">    <span class="keyword">for</span> i := k; i &lt; n; i++ {</div><div class="line">        <span class="keyword">if</span> nums[i] &gt; heap<span class="number">[0</span>] {</div><div class="line">            heap<span class="number">[0</span>] = nums[i]</div><div class="line">            heapify(heap,<span class="number"> 0</span>, k)</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> heap<span class="number">[0</span>]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 堆化</span></div><div class="line"><span class="keyword">func</span> heapify(heap []<span class="typename">int</span>, i, n <span class="typename">int</span>) {</div><div class="line">    left :=<span class="number"> 2</span>*i +<span class="number"> 1</span></div><div class="line">    right :=<span class="number"> 2</span>*i +<span class="number"> 2</span></div><div class="line">    min := i</div><div class="line">    <span class="keyword">if</span> left &lt; n && heap[left] &lt; heap[min] {</div><div class="line">        min = left</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> right &lt; n && heap[right] &lt; heap[min] {</div><div class="line">        min = right</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> min != i {</div><div class="line">        heap[i], heap[min] = heap[min], heap[i]</div><div class="line">        heapify(heap, min, n)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其实，Go标准库中提供了<a href="https://pkg.go.dev/container/heap@go1.22.0" target="_blank" rel="external">heap</a>,我们自己不用实现。使用标准库中的heap,我们可以将上面的代码改写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"container/heap"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义一个最小堆</span></div><div class="line"><span class="keyword">type</span> MinHeap []<span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (h MinHeap) Len() <span class="typename">int</span>           { <span class="keyword">return</span> <span class="built_in">len</span>(h) }</div><div class="line"><span class="keyword">func</span> (h MinHeap) Less(i, j <span class="typename">int</span>) <span class="typename">bool</span> { <span class="keyword">return</span> h[i] &lt; h[j] }</div><div class="line"><span class="keyword">func</span> (h MinHeap) Swap(i, j <span class="typename">int</span>)      { h[i], h[j] = h[j], h[i] }</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h *MinHeap) Push(x <span class="keyword">interface</span>{}) {</div><div class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="typename">int</span>))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (h *MinHeap) Pop() <span class="keyword">interface</span>{} {</div><div class="line">    old := *h</div><div class="line">    n := <span class="built_in">len</span>(old)</div><div class="line">    x := old[n<span class="number">-1</span>]</div><div class="line">    *h = old<span class="number">[0</span> : n<span class="number">-1</span>]</div><div class="line">    <span class="keyword">return</span> x</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> findKthLargest(nums []<span class="typename">int</span>, k <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    h := &MinHeap{}</div><div class="line">    heap.Init(h)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; k; i++ {</div><div class="line">        heap.Push(h, nums[i])</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ {</div><div class="line">        <span class="keyword">if</span> nums[i] &gt; (*h)<span class="number">[0</span>] {</div><div class="line">            heap.Pop(h)</div><div class="line">            heap.Push(h, nums[i])</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> (*h)<span class="number">[0</span>]</div><div class="line">}</div></pre></td></tr></table></figure>

<p>虽然标准库实现了heap，但是实现的非常难用:</p>
<ul>
<li>使用函数式的方式，没有面向对象的方式直观</li>
<li>要求Interface实现Len,Less,Swap三个方法(<code>sort.Interface</code>)，而且还要实现<code>Push(x any)</code>和<code></code>Pop() any`两个方法。</li>
<li>包提供了<code>heap.Init</code>和<code>heap.Fix</code>、<code>heap.Pop</code>、<code>heap.Push</code>、<code>heap.Remove</code>等方法，Pop和Push和<code>Interface</code>的<code>Pop</code>和<code>Push</code>方法重名，这样会让人困惑。</li>
<li>而且，<code>heap.Pop</code>和<code>Interface.Pop</code>没有一点关系。<code>heap.Push</code>和<code>Interface.Push</code>没有一点关系。不要以为<code>heap.Push</code>直接调用<code>Interface.Pop</code>,虽然内部会调用，但是都有额外的处理</li>
</ul>
<p>每次使用，心智负担很重，不是不会写，而是性价比很低。貌似看起来很灵活，提供了很多方法，但是实际使用的时候，却很麻烦。<br>我想我不是唯一一个和我有相同感受的人，比如这个<a href="https://www.dolthub.com/blog/2023-12-01-why-are-go-heaps-confusing/" target="_blank" rel="external">Why Are Golang Heaps So Complicated</a><br>这篇文章还还提供了一个简单的堆实现，可以参考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在招一个Go开发工程师，面试中时候我会问一个Top K的问题，这个问题是一个经典的面试题。</p>
<p>有时候我不会要求面试者写出答案，首先我听一下他的思想，如果写代码困难的话我都允许可以上网查标准库的文档，看看heap的用法。</p>
<p>相对来说比Redis的作者antirez的面试要轻松些了，他的面试题是要求面试者写出一个二叉搜索树。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊聊 Go 的边界检查消除技术]]></title>
    <link href="https://colobu.com/2024/02/19/bce/"/>
    <id>https://colobu.com/2024/02/19/bce/</id>
    <published>2024-02-19T14:47:39.000Z</published>
    <updated>2024-02-20T11:12:22.416Z</updated>
    <content type="html"><![CDATA[<p>在翻译的<a href="https://mp.weixin.qq.com/s/l6Tq_bVDmMpwZg_rPfi1DQ" target="_blank" rel="external">从慢速到SIMD</a>一文中， SourceGraph工程师其中的一个优化就是边界检查消除(BCE,bounds check elimination)技术，同时他也抛给了读者一个问题：</p>
<blockquote>
<p>为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</p>
</blockquote>
<p>本文第一部分先回答这个问题。 第二部分介绍更好的边界检查消除方法。 第三部分再全面梳理Go的边界检查消除技术。</p>
<a id="more"></a>
<h2 id="为啥在使用_a[i:i+4:i+4]_而不是_a[i:i+4]?">为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</h2>
<p>这篇文章发布到几个平台之后，很多Gopher都在问这个问题的答案，包括《100个Go语言典型错误》的作者也在twitter上询问,再比如<a href="https://news.ycombinator.com/item?id=39106972" target="_blank" rel="external">Hacker News</a>上的讨论，<a href="https://www.reddit.com/r/golang/comments/199u7np/from_slow_to_simd_a_go_optimization_story/" target="_blank" rel="external">reddit</a>。</p>
<p>当然，还每看过这篇文章的同学还不明白前因后果，这里我再简单介绍一下。SourceGraph工程师使用BCE做优化，他的代码如下，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotBCE(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slices must have equal lengths"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)<span class="number">%4</span> !=<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slice length must be multiple of 4"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		aTmp := a[i : i<span class="number">+4</span> : i<span class="number">+4</span>] <span class="comment">// &lt;--- 这里会做边界检查</span></div><div class="line">		bTmp := b[i : i<span class="number">+4</span> : i<span class="number">+4</span>] <span class="comment">// &lt;--- 这里会做边界检查</span></div><div class="line">		s0 := aTmp<span class="number">[0</span>] * bTmp<span class="number">[0</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		s1 := aTmp<span class="number">[1</span>] * bTmp<span class="number">[1</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		s2 := aTmp<span class="number">[2</span>] * bTmp<span class="number">[2</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		s3 := aTmp<span class="number">[3</span>] * bTmp<span class="number">[3</span>] <span class="comment">// &lt;--- 这里不会做边界检查</span></div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意做边界检查的那两行，它们做了边界检查，新的slice的len和cap都是4,可以确保<code>aTemp[0]</code>、<code>aTemp[3]</code>、<code>bTemp[0]</code>、<code>bTemp[3]</code>不会越界,所以下面四行不用做边界检查了。不过边界检查少了很多的指令，可以提高性能。</p>
<p>我们怎么知道哪一行做了边界检查呢？可以使用下面的命令编译，会把做边界检查的行数打印出来。</p>
<p><img src="bce1.png" alt=""></p>
<p>可以看到结果和我们注释中的一样，只在第14、15行做了边界检查。</p>
<p>但是话锋一转，SourceGraph工程师突然问了一个问题：为啥这两行使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</p>
<p>难道<code>a[i:i+4]</code>会导致下面四行做边界检查吗？这个问题让很多人都很好奇，几个论坛上没有答案。我翻译的文章评论中也有小伙伴问这个问题。</p>
<p>首先，我们修改为<code>a[i:i+4]</code>，然后编译，看看结果:<br><img src="bce1.png" alt=""></p>
<p>没什么区别，还是在第14、15行做了边界检查，接下来四行做了边界检查消除，不一样么？</p>
<p>这个问题 <a href="https://go101.org/" target="_blank" rel="external">Go101 老貘</a> 在Twitter上提了一下，没有展开讲，购买了他的书的同学可以看看那一章：<br><img src="bce2.png" alt=""></p>
<p>接下来我从最开始的讨论讲起，那还得从2018年的秋天的一个提交讲起。</p>
<p>不想看历史的同学可以直接跳过去，结论就是：这样写不是为了边界检查消除，而是为了性能。</p>
<p>这是一次对<a href="https://go-review.googlesource.com/c/go/+/136935" target="_blank" rel="external">image/draw: optimize bounds checks in loops</a>做边界检查的优化:<br><img src="bce3.png" alt=""></p>
<p>其中有一行<code>s := spix[i : i+4 : i+4]</code>，Sebastien Binet提出一个疑问，为啥这里要设置cap? Brad Fitzpatrick就说那我移除好了，作者Ian Davis说我做了测试，感觉设置cap会给编译器提示，性能更好。大家就对这个奇怪的点展开了有趣的讨论，Ian Davis说如果改成<code>s := spix[i : i+4]</code>虽然对边界检查没有影响，但是性能会下降。Giovanni Bajo给出了正解:</p>
<blockquote>
<p>If you don&#39;t specify the cap, the compiler needs to calculate it computing newcap = oldcap - offset. If you specify it with the same value of len, it does less work.</p>
<p>翻译：如果你不指定cap，编译器需要计算新的<code>newcap = oldcap - offset</code>。如果你指定cap的值和len一样，编译器就可以少做点工作。</p>
</blockquote>
<p>Nigel Tao也指出，这行代码也可以使用<code>_ = spix[i+3]</code>代替。<br>最终这个讨论记录在<a href="https://github.com/golang/go/issues/27857" target="_blank" rel="external">#27857</a>。</p>
<p>回答SourceGraph工程师的问题：<strong>为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</strong></p>
<p>答案是为了更好的性能，而不是为了边界检查消除。</p>
<h2 id="更好的边界检查消除方法">更好的边界检查消除方法</h2>
<p>SourceGraph工程师的代码使用BCE做了优化，但是你还是看到，有两行代码还是做了边界检查，这是因为Go的BCE并不完美，有时候还是会做边界检查。</p>
<p>但是有没有办法全部消除代码的边界检查呢？老貘还是给出了一个解决方案。<br>我们先看看老貘的给出的例子(<code>f8z</code>我略有改动):<br><img src="bce4.png" alt=""></p>
<p>可以看到，Go的BCE还不是那么智能，<code>f8x</code>例子中<code>s[i+3]</code>、<code>s[i+2]</code>、s[i+1]不会越界，但是这三行还是做了边界检查。</p>
<p><code>f8y</code>例子中<code>s[3]</code>做了边界检查后，可以保证<code>s[2]</code>、<code>s[1]</code>、<code>s[0]</code>不会越界，所以这三行不用做边界检查。</p>
<p><code>f8z</code>例子中，每次循环我们都会检查s的长度是否大于4，如果大于4，<code>s[3]</code>、<code>s[2]</code>、<code>s[1]</code>、<code>s[0]</code>肯定不会越界，所以这四行不做边界检查，而且<code>s = s[4:]</code>也不会越界。这样这个实现就整体都不需要做边界检查了</p>
<p>所以SourceGraph工程师的代码可以改成下面这样:</p>
<p><img src="bce5.png" alt=""></p>
<h2 id="Go的边界检查消除技术">Go的边界检查消除技术</h2>
<p>老貘在Go101中有一章专门讲了<a href="https://go101.org/article/bounds-check-elimination.html" target="_blank" rel="external">这个问题</a>，感兴趣的同学可以直接阅读，或者购买他的电子书。</p>
<p>我想从Go实现边界检查消除的提议说起，这个提议是<a href="https://github.com/golang/go/issues/14808），由Alexandru Moșoi提出，他专门写了一篇文档[Bounds Checking Elimination](https://docs.google.com/document/d/1vdAEAjYdzjnPA9WDOQ1e4e05cYVMpqSxJYZT33Cqw2g/edit#heading=h.ywknbkyeha6d" target="_blank" rel="external">cmd/compile: unnecessary bounds checks are not removed #14808</a>。</p>
<p>当然BCE在Go的编译器中也一直做优化，原始的文档整理也不能全面反映现状，但是还是很有意义的，整理的BCE技术进行分类便于学习。我就整理翻译一下。</p>
<p>Go的边界检查有两个:索引<code>a[i]</code>和slice<code>a[i,j]</code>。Go编译器在访问这两种方式的时候会插入一些边界检查代码，但是大部分情况下是不需要的，冗余的，我们的目标就是在编译的时候去掉这些冗余的检查，这样能提供性能，检查二进制文件大小。通过<code>-gcflags=-B</code>可以禁止边界检查。</p>
<p>你可以通过<code>go build -gcflags=&quot;-d=ssa/check_bce&quot; xxx.go</code>查看哪些行进行了边界检查。</p>
<p>下面是一些进行边界检查消除的场景。</p>
<h3 id="重复检查">重复检查</h3>
<p>比如下面的代码中，重复的索引和切片访问就不做边界检查了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line">….</div><div class="line">_ = a[i] <span class="comment">// 边界检查</span></div><div class="line">_ = a[i] <span class="comment">// 重复访问，消除边界检查</span></div><div class="line">_ = a<span class="number">[2</span>*i<span class="number">+7</span>]  <span class="comment">// 边界检查</span></div><div class="line">_ = a<span class="number">[2</span>*i<span class="number">+7</span>]  <span class="comment">// 重复访问，消除边界检查</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line">….</div><div class="line">_ = a[:i]</div><div class="line">_ = a[:i] <span class="comment">// 重复访问，消除边界检查</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span></div><div class="line">….</div><div class="line">_ = a[i:]</div><div class="line">_ = a[i:] <span class="comment">// 重复访问，消除边界检查</span></div></pre></td></tr></table></figure>

<h3 id="带掩码索引的恒定切片大小">带掩码索引的恒定切片大小</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a<span class="number">[17</span>]<span class="typename">int</span></div><div class="line">....</div><div class="line">_ = a[i<span class="number">&5</span>]   <span class="comment">// 0 &lt;= i&5 and i&5 &lt;= 5 &lt; 17 == len(a), 移除边界检查</span></div><div class="line">_ = a[i<span class="number">%5</span>]  <span class="comment">// 不能移除， 因为i可能是负数， 负数就越界了</span></div></pre></td></tr></table></figure>

<h3 id="常数索引">常数索引</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">....</div><div class="line"><span class="keyword">if</span><span class="number"> 5</span> &lt; <span class="built_in">len</span>(a) { _ = a<span class="number">[5</span>] }   <span class="comment">// 0 &lt;= 5 and 5 &lt; len(a), 移除边界检查</span></div></pre></td></tr></table></figure>

<p>这也是上一节我们完全消除边界检查的方式。</p>
<h3 id="常数索引和常数size">常数索引和常数size</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a<span class="number">[10</span>]<span class="typename">int</span></div><div class="line">....</div><div class="line">_ = a<span class="number">[5</span>]   <span class="comment">// 0 &lt;= 5 and 5 &lt; len(a) == 10,  移除边界检查</span></div></pre></td></tr></table></figure>

<h3 id="琐碎的边界检查">琐碎的边界检查</h3>
<p><code>a[i:j]</code> 会产生两个边界检查: <code>0 &lt;= i &lt;= j</code> 和 <code>0 &lt;= j &lt;= cap(a)</code>。有时候我们可以移除它们中的一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">a[i:<span class="built_in">len</span>(a)]  <span class="comment">// 第二个边界检查 0 &lt;= len(a) &lt;= cap(a) 移除了</span></div><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">a[:<span class="built_in">len</span>(a)&gt;<span class="number">&gt;1</span>] <span class="comment">// 第一个边界检查移除了 0 &lt;= 0 &lt;= len(a)&gt;&gt;1， 因为 len(a)&gt;&gt;1 &gt;= 0</span></div><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">a[:<span class="built_in">len</span>(b)] <span class="comment">// 第一个边界检查 0 &lt;= 0 &lt;= len(a) 移除了</span></div></pre></td></tr></table></figure>

<h3 id="基于循环变量的边界检查">基于循环变量的边界检查</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span>   </div><div class="line">…</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a {   <span class="comment">// 不适用于string</span></div><div class="line">  use a[i]  <span class="comment">// 移除, i 循环变量</span></div><div class="line">  use a[i:]  <span class="comment">// 移除</span></div><div class="line">  use a[:i]  <span class="comment">// 移除</span></div><div class="line">}</div><div class="line"><span class="keyword">var</span> a []<span class="typename">int</span>   </div><div class="line">...</div><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i++ {   <span class="comment">// 也适用于string</span></div><div class="line">  use a[i]  <span class="comment">// 移除, i 循环变量</span></div><div class="line">  use a[i:]  <span class="comment">// 移除</span></div><div class="line">  use a[:i]  <span class="comment">// 移除</span></div><div class="line">}</div><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span>   </div><div class="line">…</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a {   <span class="comment">// 不适用于string</span></div><div class="line">  use a[:i<span class="number">+1</span>] <span class="comment">// 移除, i 循环变量</span></div><div class="line">  use a[i<span class="number">+1</span>:] <span class="comment">// 移除</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递减常量索引">递减常量索引</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a[]<span class="typename">int</span></div><div class="line">…</div><div class="line">_ = a<span class="number">[3</span>] <span class="comment">// 一次边界检查</span></div><div class="line">use a<span class="number">[1</span>], a<span class="number">[2</span>], a<span class="number">[3</span>] <span class="comment">// 不需要边界检查</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line">a = a[<span class="number">:3</span>:<span class="built_in">len</span>(a)] <span class="comment">// 一次边界检查</span></div><div class="line">use a<span class="number">[0</span>], a<span class="number">[1</span>], a<span class="number">[2</span>] <span class="comment">// 不需要边界检查</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line">use a<span class="number">[3</span>], a<span class="number">[2</span>], a<span class="number">[1</span>] <span class="comment">// 一次边界检查</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) &gt;=<span class="number"> 3</span> {</div><div class="line">    use a<span class="number">[0</span>], a<span class="number">[1</span>], a<span class="number">[2</span>] <span class="comment">// 一次边界检查</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="不能移除的边界检查">不能移除的边界检查</h3>
<p>下面这个<code>k8x</code>中第一个<code>a[i]</code>中i可能为负数，所以不能移除，接下来的两个可以确保不越界，所以可以移除。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> k8x(a []<span class="typename">int</span>, i <span class="typename">int</span>, j <span class="typename">uint</span>) {</div><div class="line">	<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) {</div><div class="line">		_ = a[i] <span class="comment">// 不能移除，因为i可能为负数</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> j &lt; <span class="typename">uint</span>(<span class="built_in">len</span>(a)) {</div><div class="line">		_ = a[j] <span class="comment">// 移除，因为 0 &lt;= j &lt; len(a)</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span><span class="number"> 0</span> &lt;= i && i &lt; <span class="built_in">len</span>(a) {</div><div class="line">		_ = a[i] <span class="comment">// 移除，因为 0 &lt;= i &lt; len(a)</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面这个<code>k8y</code>中<code>i+2</code>可能溢出，比如<code>i = math.MaxInt</code>, 所以不能移除。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> k8y(a []<span class="typename">int</span>, i <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span><span class="number"> 0</span> &lt;= i && i<span class="number">+2</span> &lt; <span class="built_in">len</span>(a) {</div><div class="line">		_ = a[i<span class="number">+2</span>] <span class="comment">// i+2 might overflow int</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>`</p>
<p>这个文档中有几处场景已经BCE已经完善了，我更正过来了，如上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在翻译的<a href="https://mp.weixin.qq.com/s/l6Tq_bVDmMpwZg_rPfi1DQ" target="_blank" rel="external">从慢速到SIMD</a>一文中， SourceGraph工程师其中的一个优化就是边界检查消除(BCE,bounds check elimination)技术，同时他也抛给了读者一个问题：</p>
<blockquote>
<p>为啥在使用 <code>a[i:i+4:i+4]</code> 而不是 <code>a[i:i+4]</code>?</p>
</blockquote>
<p>本文第一部分先回答这个问题。 第二部分介绍更好的边界检查消除方法。 第三部分再全面梳理Go的边界检查消除技术。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些笔记工具工具以及memos介绍]]></title>
    <link href="https://colobu.com/2024/02/10/some-note-taking-tools-and-memos/"/>
    <id>https://colobu.com/2024/02/10/some-note-taking-tools-and-memos/</id>
    <published>2024-02-09T16:52:07.000Z</published>
    <updated>2024-02-20T11:11:43.123Z</updated>
    <content type="html"><![CDATA[<p>祝大家龙年大吉！</p>
<a id="more"></a>
<p>大家可能好奇我写书的时候是用什么工具？正好最近我画架构图的时候使用Excelidraw,也试用了几款其他的工具。而且这两天搭建了一个备忘录的工具，所以正好总结一下。</p>
<h2 id="写书工具">写书工具</h2>
<p>我在写书稿的时候曾经一度想使用Latex，因为它强大的排版功能几乎可以排版任何东西，而且拥有丰富的插件，输出的pdf效果也很好，但是考虑到交稿给编辑，扁编辑在审稿和校对的时候不方便，而且书稿出版社会使用自己的版式重新排版，虽然我一度整了一个Latex模板并尝试写电子书，但是最终也放弃了。</p>
<p>基本上，我写的书稿是使用Markdown的格式。Markdown的格式对于写作还是很方便的，而且不需要考虑太多的版面的问题，方便组织层次，插入图片和代码也都很方便，编译也容易导出到其他格式。</p>
<p>使用vscode 就可以编写Markdown的文本，后来我听说<a href="https://typora.io/" target="_blank" rel="external">Typora</a>，这是一个很好的Markdown编辑器，支持实时预览，而且支持导出PDF，网上都说使用方便，我也尝试了一下，也确实不错。不过自1.0版本后它开始收费了。</p>
<p>当然收费也无可厚非，毕竟开发者也需要生活，不能够纯用爱发电，对吧？ 但是我还是希望找到一个免费的工具，最终我找到了<a href="https://github.com/marktext/marktext" target="_blank" rel="external">MarkText</a>，这是一个开源的Markdown编辑器，支持实时预览，而且支持导出PDF，这是我最喜欢的一个Markdown编辑器。</p>
<p>所以我就使用MarkText平替Typora来写书稿，完成了《深入理解Go并发编程》的写作。</p>
<p>这个工具的作者还是中国的同学，非常的赞。不过目前代码活跃度不是那么高了，不过对我来说已经够用了，希望它后续能够支持插件，这样可以充分发挥网友的聪明才智，把功能丰富起来。</p>
<p><img src="marktext.png" alt=""></p>
<h2 id="笔记工具">笔记工具</h2>
<p>首先做笔记的工具很多，比如<a href="https://www.notion.so/product" target="_blank" rel="external">Notion</a>、<a href="https://keep.google.com/" target="_blank" rel="external">Google Keep</a>、<a href="https://www.yinxiang.com/" target="_blank" rel="external">Evernote（印象笔记）</a>、<a href="https://www.onenote.com/" target="_blank" rel="external">OneNote</a>、<a href="https://simplenote.com/" target="_blank" rel="external">Simplenote</a>、<a href="https://bear.app/" target="_blank" rel="external">Bear</a>、<a href="https://www.goodnotes.com/" target="_blank" rel="external">GoodNotes</a>、<a href="https://notability.com/" target="_blank" rel="external">Notability</a>等等，很多，但是很多都是收费的，而且基本是web服务，意味着你的数据都在别人的服务器上，不安全， 而且服务可用性也不可控。</p>
<p>所以我想找的是一个桌面工具，免费的，相应的笔记我通过git保存在github或者自建的git服务器上即可。</p>
<p>有两个工具值得推荐。</p>
<p>第一个是 <a href="https://obsidian.md/" target="_blank" rel="external">obsidian</a>, 这是一个免费的笔记工具，支持markdown格式，而且支持插件，可以自己写插件，而且支持本地存储，不需要联网，而且支持git，可以把笔记存储在github上.<br><img src="obsidian.png" alt=""></p>
<p>它具有以下有点：</p>
<ul>
<li>支持Markdown格式编写笔记,可读性强,也方便导出和跨平台使用。</li>
<li>采用文件系统来组织笔记,所有笔记以普通文本文件的形式存储在磁盘上,不依赖任何数据库。</li>
<li>建立笔记之间的双向链接,支持网络化思维,可以将笔记关联起来。</li>
<li>提供图形化界面,支持大纲预览、回链、未链接提醒等功能。</li>
<li>支持嵌入超链接、图片、Latex数学公式等。</li>
<li>插件丰富,支持中文分词、思维导图、时间管理等功能。</li>
<li>支持多种操作系统如Windows、Mac、Linux等。</li>
<li>提供移动版,可以在手机或平板上编辑和查看笔记。</li>
<li>支持团队协作,可搭建或加入专用服务器,实现知识共享。</li>
<li>个性化主题丰富,美观大方。</li>
</ul>
<p>第二个是 <a href="https://github.com/logseq/logseq" target="_blank" rel="external">logseq</a>,logseq是一个开源的网络化个人知识管理和协作工具,具有以下主要特点:<br><img src="logseq.webp" alt=""></p>
<ul>
<li>支持双向链接,所有块(页面和段落)之间可以相互引用,形成一个网络化的知识库。</li>
<li>基于Graph数据结构,支持视图分析、回链和未链接提示等功能。</li>
<li>页面和块支持无限嵌套,可以把知识点进行自由组合。</li>
<li>支持代码块、TeX数学公式等语法高亮。</li>
<li>可以创建Markdown和OrgMode多种格式的页面。</li>
<li>支持同时编辑,实时预览编辑内容。</li>
<li>支持跨平台编辑。</li>
<li>插件系统强大,可以扩展更多功能。</li>
<li>界面简洁优雅,支持日夜两种主题模式。</li>
</ul>
<p>我在Mac上安装Logseq后发现它的功能虽然强大，插件更丰富，但是弹出的对话框不能关闭，后台启动多个进程，占用资源比较大，反应迟钝，这可能是它基于Electron开发的原因，所以我最后卸载了。</p>
<p>其实这两个工具在我的日常生活中都没有使用，我就使用苹果的备忘录，便捷，在多个苹果设备上可以互通。不好的地方在于它过于简单了。</p>
<h2 id="画图工具">画图工具</h2>
<p>其实我之所以考察obsidian和logseq，是因为我最近在画几个技术相关的架构图或者插图。先前较多使用<a href="https://app.diagrams.net/" target="_blank" rel="external">draw.io</a>，这是一个免费的在线画图工具，支持多种图形，而且支持导出多种格式，而且支持保存到本地。不过看看到网上其他同学的架构图图画的都挺好，使用<a href="https://excalidraw.com/" target="_blank" rel="external">excalidraw</a>画的，有手工画图的风格，非常的漂亮，所以我尝试使用excalidraw画图。</p>
<p>excalidraw默认就配置了三种字体：手写、正常和代码字体。对于我们来说，我们希望对于中文，能够使用一款漂亮的字体做渲染，但是excalidraw官方的网站不支持，有些人通过浏览器插件等方式把其中的字体做替换来达到目的，过于麻烦。</p>
<p>我搜了一下网上的教程，说obsidian很好的支持了excalidraw插件，可以配置自己的字体作为第四种可选择的字体，这就非常好了。</p>
<p>你可以选择一款自己喜欢的字体，放在<code>Obsidian Vault/Excalidraw/font</code>中，我选择了“沐瑶随心手写体”，这是一款免费且好看的中文字体，然后在obsidian的设置中配置excalidraw插件，就可以选择这个字体了。<br><img src="excalidraw.png" alt=""></p>
<p>然后我就可以使用excalidraw画图了，可以看到<code>Font family</code>中多了一个字体选项，这就是我配置的字体。<br><img src="excalidraw2.png" alt=""></p>
<p>obsidian也支持了excalidraw的脚本，这极大的丰富了excalidraw的功能，可以画出更加复杂的图形。而且excalidraw插件也支持资源库，我上面图中的gopher就是使用的资源库中的资源。</p>
<p>现在看起来 obsidian + excalidraw插件可以很好的满足我的需求了。</p>
<h2 id="备忘录工具">备忘录工具</h2>
<p>前面提到，我基本使用苹果的备忘录，但是它的功能太简单了，而且不支持markdown格式，所以我想找一个支持markdown格式的备忘录工具，最好是web方式的，这样我在电脑、平板和手机上都可以自如的编写备忘录了。</p>
<p>经常我脑海中会蹦出一点火花，可能是一个新的项目想法，可能是一个新的技术点，可能是一个新的文章的思路，也可能是一本书的大纲，我书包中常备着一个小本子，当这些想法闪现的时候，我都会拿出本子记录下来。但是经常在一些时候，比如外出的时候，或者半夜有想法失眠的时候，本子不在身边，我生怕这些稍纵即逝的想法就这样消失了。所以如果有一个随时随地的备忘录工具就好了，不仅限于苹果系统。</p>
<p>其实上面笔记工具提到的google keep就挺好，但是有时候访问Google并不是那么方便，而且基于Goole历来的表现，说不定哪一天就把这个产品关闭了。<br>不过这个工具确实好， 支持代办列表、图片，甚至可以绘图。<br><img src="keep.png" alt=""></p>
<p>当然，类似的备忘录工具有很多，比如<a href="https://www.zhihu.com/question/21291418" target="_blank" rel="external">这篇知乎文章</a>介绍的。</p>
<p>这两天，我看到了一款非常简洁但是功能有很丰富的备忘录工具，支持自己搭建，我就自己搭建了一个。</p>
<p>这款备忘录工具就是<a href="https://github.com/usememos/memos" target="_blank" rel="external">memos</a>, 你可以访问它的示例网站进行试用，示例网站地址是: <a href="https://demo.usememos.com/" target="_blank" rel="external">https://demo.usememos.com/</a>。<br><img src="memos.png" alt=""></p>
<p><code>usememos/memos</code>是一个开源的轻量级便签服务,可以让用户轻松捕获和分享想法。它的主要特点包括:</p>
<ul>
<li>开源 - usememos在GitHub上以MIT许可证开源,代码公开透明。</li>
<li>轻量级 - 简单注册就可以使用,用户可以快速创建和组织便签。</li>
<li>多租户 - 支持多用户注册,每个用户都有自己的私有空间。也可以创建公共空间,共享便签。</li>
<li>Markdown支持 - 支持Markdown格式,可以格式化便签文本。</li>
<li>快速搜索 - 可以快速搜索并过滤便签。</li>
<li>分享和协作 - 可以分享便签链接到不同平台,也可以与其他人协作编辑。</li>
<li>多种主题 - 提供多种主题选择,用户可以自定义外观。</li>
<li>数据备份 - 数据可以导出为JSON文件,方便备份。</li>
<li>响应式设计 - 可以在移动设备和桌面端流畅使用。</li>
<li>简洁易用 - 界面简洁,使用非常容易上手。</li>
</ul>
<p>最重要的一点，你可以自己通过docker或者直接编译源码来搭建自己的备忘录服务，这样你的数据就不会存储在别人的服务器上，安全性更高。而且可以一键部署，安装简单。</p>
<p>不但安装简单，而且使用也非常简单，你可以在网站上注册一个账号，然后就可以使用了。<br>初始第一个用户是管理员，你可以设置是否允许其他用户注册等，控制这个应用你自己使用还是当成平台共享。</p>
<p>我在自己的服务器上部署了这个程序，并设置了相应的域名 <a href="https://memos.rpcx.io" target="_blank" rel="external">https://memos.rpcx.io</a> , 目前仅限于我自己使用。而且我手机上利用浏览器的功能，创建了一个桌面快捷键，直接点击桌面图标就可以进入，类似桌面APP的效果。</p>
<p>因为memos是开源的，我也进行了相应的修改，比如图标换成我微信的图标， 备忘录的字体也换成了“沐瑶随心手写体”，更有趣一些。汉化了一些不彻底的地方。</p>
<p><img src="memos2.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>祝大家龙年大吉！</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言中的Pinner.Pin]]></title>
    <link href="https://colobu.com/2024/02/02/Pinner-Pin/"/>
    <id>https://colobu.com/2024/02/02/Pinner-Pin/</id>
    <published>2024-02-02T07:56:36.000Z</published>
    <updated>2024-02-02T08:02:16.858Z</updated>
    <content type="html"><![CDATA[<p><a href="https://pkg.go.dev/runtime#Pinner" target="_blank" rel="external">runtime.Pinner</a> 是 Go 1.21.0 中引入的一个类型。</p>
<p><code>Pinner</code>是一组固定的 Go 对象。可以使用 <code>Pin</code> 方法来固定一个对象。<code>Pinner</code>固定的所有对象都可以使用 <code>Unpin</code> 方法解开固定。</p>
<a id="more"></a>
<h3 id="简介">简介</h3>
<p><code>Pinner.Pin</code> 是 Go 语言中用于防止对象被垃圾回收器回收的函数。它接受一个指针参数，并将该指针指向的内存区域标记为不可移动。这意味着，即使该对象不再被任何变量引用，它也不会被回收，直到调用 <code>Pinner.Unpin</code> 函数将其取消固定。</p>
<h3 id="使用场景">使用场景</h3>
<p><code>Pinner.Pin</code> 通常用于以下场景：</p>
<ul>
<li>在与 C 代码互操作时，需要将 Go 对象传递给 C 函数。</li>
<li>在需要确保对象在某个时间段内保持有效的场景中，例如，在进行 I/O 操作或计算密集型操作时。</li>
</ul>
<h3 id="示例">示例</h3>
<p>以下示例演示了如何使用 <code>Pinner.Pin</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"runtime"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// 创建一个新的 `[]byte` 数组</span></div><div class="line">    data := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 10</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 将数组固定</span></div><div class="line">    p := runtime.Pinner.Pin(data)</div><div class="line"></div><div class="line">    <span class="comment">// 对数组进行一些操作</span></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> data {</div><div class="line">        data[i] = <span class="typename">byte</span>(i)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 取消固定数组</span></div><div class="line">    p.Unpin()</div><div class="line"></div><div class="line">    <span class="comment">// 打印数组内容</span></div><div class="line">    fmt.Println(data)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="注意事项">注意事项</h3>
<ul>
<li>只能对以下类型的对象调用 <code>Pinner.Pin</code> 函数：<ul>
<li>通过 <code>new</code> 函数创建的对象</li>
<li>复合字面量的地址</li>
<li>局部变量的地址</li>
</ul>
</li>
<li>如果对非法的对象调用 <code>Pinner.Pin</code> 函数，会导致程序崩溃。</li>
<li>在调用 <code>Pinner.Unpin</code> 函数之前，必须确保不再使用该对象，否则会导致程序运行时错误</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://pkg.go.dev/runtime#Pinner" target="_blank" rel="external">runtime.Pinner</a> 是 Go 1.21.0 中引入的一个类型。</p>
<p><code>Pinner</code>是一组固定的 Go 对象。可以使用 <code>Pin</code> 方法来固定一个对象。<code>Pinner</code>固定的所有对象都可以使用 <code>Unpin</code> 方法解开固定。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[十亿行的挑战]]></title>
    <link href="https://colobu.com/2024/01/30/one-billion-row-challenge/"/>
    <id>https://colobu.com/2024/01/30/one-billion-row-challenge/</id>
    <published>2024-01-30T14:40:26.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>国外的程序员休完他们的假期之后在玩什么？他们在玩十亿行的代码挑战。</p>
<a id="more"></a>
<p>工程师贡纳尔·莫林在元旦发起一个<a href="https://www.morling.dev/blog/one-billion-row-challenge/" target="_blank" rel="external">挑战</a>(1BRC),挑战从 1 月 1 日持续到 1 月 31 日。</p>
<p>如果你决定接受它，你的任务看似简单： <strong>编写一个 Java 程序，用于从文本文件中检索温度测量值并计算每个气象站的最小、平均值和最高温度。</strong><br>只有一点需要注意：文件有 <strong>1,000,000,000 行</strong>！（1 billion， 10亿行)。</p>
<p>这个文本文件结构简单，每行一个测量值, 气象站和它的测量温度：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">Hamburg</span>;<span class="number">12.0</span></div><div class="line"><span class="variable">Bulawayo</span>;<span class="number">8.9</span></div><div class="line"><span class="variable">Palembang</span>;<span class="number">38.8</span></div><div class="line"><span class="variable">St</span>. <span class="variable">John</span>'s;<span class="number">15.2</span></div><div class="line"><span class="variable">Cracow</span>;<span class="number">12.6</span></div><div class="line">...</div></pre></td></tr></table></figure>

<p>程序应打印出每个站的最小值、平均值和最大值，按字母顺序排列，如下所示：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{Abha=<span class="number">5.0</span>/<span class="number">18.0</span>/<span class="number">27.4</span>, Abidjan=<span class="number">15.7</span>/<span class="number">26.0</span>/<span class="number">34.1</span>, Abéché=<span class="number">12.1</span>/<span class="number">29.4</span>/<span class="number">35.6</span>, Accra=<span class="number">14.7</span>/<span class="number">26.4</span>/<span class="number">33.1</span>, Addis Ababa=<span class="number">2.1</span>/<span class="number">16.0</span>/<span class="number">24.3</span>, Adelaide=<span class="number">4.1</span>/<span class="number">17.3</span>/<span class="number">29.7</span>, <span class="keyword">...</span>}</div></pre></td></tr></table></figure>

<p>1BRC挑战的目标是为这项任务创建最快的实现， 在这样做的同时，探索现代 Java 的好处，并找出你可以将这个平台推向多远。 因此，使用所有的（虚拟）线程，利用 Vector API 和 SIMD，优化你的 GC，利用 AOT 编译，或者使用你能想到的任何其他技巧。</p>
<p>没想到莫林提出这个挑战后，一下子火了，在多个平台上都进行了热烈的讨论：<a href="https://news.ycombinator.com/item?id=38851337" target="_blank" rel="external">Hacker News</a>、<a href="https://lobste.rs/s/u2qcnf/one_billion_row_challenge" target="_blank" rel="external">lobste.rs</a>、<a href="https://old.reddit.com/r/programming/comments/18x0x0u/the_one_billion_row_challenge/" target="_blank" rel="external">Reddit</a>。</p>
<p>而且，实现也不再仅限于Java,其他编程语言甚至数据库都有<a href="https://github.com/gunnarmorling/1brc/discussions" target="_blank" rel="external">实现</a>。</p>
<p>在32 core AMD EPYC™ 7502P (Zen2), 128 GB RAM的服务器上，使用8个核，优化的Java程序在使用GraalVM native binary情况下已经跑到了1秒多。在我的Mac M2 mini上可以跑到16.42秒。</p>
<p>我们关注一下Go语言的实现。</p>
<p>一个简单的中规中矩的Go语言实现是<a href="https://github.com/mr-karan/1brc-go" target="_blank" rel="external">mr-karan/1brc-go</a>, 在我的Mac M2 mini机器可以跑到26.66秒。<br>作者专门写了一篇文章介绍优化的<a href="https://mrkaran.dev/posts/1brc/" target="_blank" rel="external">步骤</a>:</p>
<ul>
<li>使用生产者和消费者模式</li>
<li>批处理文本行</li>
<li>减少内存分配</li>
<li>成块读取文本</li>
</ul>
<p>另一个Go语言的实现是<a href="https://github.com/shraddhaag/1brc" target="_blank" rel="external">shraddhaag/1brc</a>, 他把他的优化步骤都在README中列出来了，在我的Mac M2 mini机器可以跑到23.73秒。</p>
<table>
<thead>
<tr>
<th>Attempt Number</th>
<th>Approach</th>
<th>Execution Time</th>
<th>Diff</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Naive Implementation: Read temperatures into a map of cities. Iterate serially over each key (city) in map to find min, max and average temperatures.</td>
<td>6:13.15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>Evaluate each city in map concurrently using goroutines.</td>
<td>4:32.80</td>
<td>-100.35</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/8bd5f437e8cc231e3ee18348b83f4dc694137546" target="_blank" rel="external">8bd5f43</a></td>
</tr>
<tr>
<td>2</td>
<td>Remove sorting float64 slices. Calculate min, max and average by iterating.</td>
<td>4:25.59</td>
<td>-7.21</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/830e5dfacff9fb7a41d12027e21399736bc34701" target="_blank" rel="external">830e5df</a></td>
</tr>
<tr>
<td>3</td>
<td>Decouple reading and processing of file content. A buffered goroutine is used to communicate between the two processes.</td>
<td>5:22.83</td>
<td>+57.24</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/2babf7dda72d92c72722b220b8b663e747075bd7" target="_blank" rel="external">2babf7d</a></td>
</tr>
<tr>
<td>4</td>
<td>Instead of sending each line to the channel, now sending 100 lines chunked together. Also, to minimise garbage collection, not freeing up memory when resetting a slice.</td>
<td>3:41.76</td>
<td>-161.07</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/b7b1781f58fd258a06940bd6c05eb404c8a14af6" target="_blank" rel="external">b7b1781</a></td>
</tr>
<tr>
<td>5</td>
<td>Read file in chunks of 100 MB instead of reading line by line.</td>
<td>3:32.62</td>
<td>-9.14</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/c26fea40019552a7e4fc1c864236f433b1b686f0" target="_blank" rel="external">c26fea4</a></td>
</tr>
<tr>
<td>6</td>
<td>Convert temperature from <code>string</code> to <code>int64</code>, process in <code>int64</code> and convert to <code>float64</code> at the end.</td>
<td>2:51.50</td>
<td>-41.14</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/7812da4d0be07dd4686d5f9b9df1e93b08cd0dd1" target="_blank" rel="external">7812da4</a></td>
</tr>
<tr>
<td>7</td>
<td>In the city &lt;&gt; temperatures map, replaced the value for each key (city) to preprocessed min, max, count and sum of all temperatures instead of storing all recorded temperatures for the city.</td>
<td>1:39.81</td>
<td>-71.79</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/e5213a836b17bec0a858474a11f07c902e724bba" target="_blank" rel="external">e5213a8</a></td>
</tr>
<tr>
<td>8</td>
<td>Use producer consumer pattern to read file in chunks and process the chunks in parallel.</td>
<td>1:43.82</td>
<td>+14.01</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/067f2a44c0d6b3bb7cc073639364f733bce09e3e" target="_blank" rel="external">067f2a4</a></td>
</tr>
<tr>
<td>9</td>
<td>Reduce memory allocation by processing each read chunk into a map. Result channel now can collate the smaller processed chunk maps.</td>
<td>0:28.544</td>
<td>-75.286</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/d4153ac7a841170a5ceee47d930e97738b5a19f6" target="_blank" rel="external">d4153ac</a></td>
</tr>
<tr>
<td>10</td>
<td>Avoid string concatenation overhead by not reading the decimal point when processing city temperature.</td>
<td>0:24.571</td>
<td>-3.973</td>
<td><a href="https://github.com/shraddhaag/1brc/commit/90f2fe121f454f3f1b5cdaeaaebe639bb86d4578" target="_blank" rel="external">90f2fe1</a></td>
</tr>
<tr>
<td>11</td>
<td>Convert byte slice to string directly instead of using a <code>strings.Builder</code>.</td>
<td>0:18.910</td>
<td>-5.761</td>
</tr>
</tbody>
</table>
<p>然后我们再看一个已经merge到官方库的Go语言实现，在我的Mac M2 mini机器可以跑到17.79秒，相当不错了。<br>他的代码在<a href="https://github.com/gunnarmorling/1brc/tree/main/src/main/go/AlexanderYastrebov" target="_blank" rel="external">这里</a>,他也做了很多的优化，比如使用mmap。</p>
<p>这几个代码都是值得学习和研究的，我们不能说他们做了最好的优化，但是确实都是花了不少功夫的。</p>
<p>几个rust的实现也是值得学习的。在我的Mac M2 mini机器的跑分：</p>
<ul>
<li><a href="https://github.com/tumdum/1brc" target="_blank" rel="external">tumdum/1brc</a>: 18.72秒</li>
<li><a href="https://github.com/mtb0x1/1brc" target="_blank" rel="external">mtb0x1/1brc</a>: 18.93秒</li>
<li><a href="https://github.com/coriolinus/1brc" target="_blank" rel="external">coriolinus/1brc</a>：18.87秒</li>
<li><a href="https://github.com/thebracket/one_billion_rows" target="_blank" rel="external">thebracket/one_billion_rows</a>: 16.04秒， 使用了mmap</li>
<li><a href="https://github.com/arthurlm/one-brc-rs" target="_blank" rel="external">arthurlm/one-brc-rs</a>: 17.33秒</li>
</ul>
<p>一个C语言的实现：</p>
<ul>
<li><a href="https://github.com/dannyvankooten/1brc" target="_blank" rel="external">dannyvankooten/1brc</a>: 17.72秒</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>国外的程序员休完他们的假期之后在玩什么？他们在玩十亿行的代码挑战。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从慢速到SIMD: 一个Go优化的故事]]></title>
    <link href="https://colobu.com/2024/01/28/slow-to-simd/"/>
    <id>https://colobu.com/2024/01/28/slow-to-simd/</id>
    <published>2024-01-28T08:21:41.000Z</published>
    <updated>2024-02-02T07:54:29.800Z</updated>
    <content type="html"><![CDATA[<p>SourceGraph 的工程师 Camden Cheek 提供的一个利用SIMD进行Go性能优化的故事:<a href="https://sourcegraph.com/blog/slow-to-simd" target="_blank" rel="external">From slow to SIMD: A Go optimization story</a>。</p>
<a id="more"></a>
<p>这是一个关于某函数的故事，这个函数被大量调用，而且这些调用都在关键路径上。让我们来看看如何让它变快。</p>
<p>剧透一下，这个函数是一个点积函数。</p>
<blockquote>
<p>点积（Dot Product），也称为内积或数量积，是一种数学运算，通常用于计算两个向量之间的乘积。点积的结果是一个标量（即一个实数），而不是一个向量。</p>
<p>假设有两个向量：<br>$$\mathbf{a}=\begin{bmatrix}a_1\\a_2\\\vdots\\a_n\end{bmatrix}$$<br>$$\mathbf{b}=\begin{bmatrix}b_1\\b_2\\\vdots\\b_n\end{bmatrix}$$</p>
<p>那么，这两个向量的点积为：<br>$$\mathbf{a}\cdot\mathbf{b}=\sum_{i=1}^n a_ib_i=a_1b_1+a_2b_2+\cdots+a_nb_n$$</p>
</blockquote>
<h2 id="一些背景">一些背景</h2>
<p>在 Sourcegraph，我们正在开发一个名为 Cody 的 Code AI 工具。为了让 Cody 能够很好地回答问题，我们需要给它足够的上下文。我们做的一种方式是利用<a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="external">嵌入</a>(<code>embedding</code>)。</p>
<p>为了我们的目的，嵌入是文本块的向量表示。它们用某种方式构建，以便语义上相似的文本块具有更相似的向量。当 Cody 需要更多信息来回答查询时，我们在嵌入上运行相似性搜索，以获取一组相关的代码块，并将这些结果提供给 Cody，以提高结果的相关性。</p>
<p>和这篇文章相关的部分是<code>相似度度量</code>，它是一个函数，用于判断两个向量有多相似。对于相似性搜索，常见的度量是<a href="https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="external">余弦相似度</a>。然而，对于归一化向量（单位幅度的向量），点积产生的排名与余弦相似度是等价的。为了运行一次搜索，我们计算数据集中每个嵌入的点积，并保留前几个结果。由于我们在得到必要的上下文之前无法开始执行 LLM，因此优化这一步至关重要。</p>
<p>你可能会想：为什么不使用索引向量数据库？除了添加我们需要管理的另一个基础设施外，索引的构建会增加延迟并增加资源需求。此外，标准的最近邻索引只提供近似检索，这与更易于解释的穷举搜索相比，增加了另一层模糊性。鉴于这一点，我们决定在我们的手工解决方案中投入一点精力，看看我们能走多远。</p>
<h2 id="目标">目标</h2>
<p>下面的代码是一个计算两个向量点积的简单的Go函数实现。我的目标是刻画出我为优化这个函数所采取的方法，并分享我在这个过程中学到的一些工具。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotNaive(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a) && i &lt; <span class="built_in">len</span>(b); i++ {</div><div class="line">		sum += a[i] * b[i]</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除非另有说明，否则所有基准都在 <code>Intel Xeon Platinum 8481C 2.70GHz CPU</code> 上运行。这是一个 <code>c3-highcpu-44</code> GCE VM。本博客文章中的代码都可以在<a href="https://github.com/camdencheek/simd_blog" target="_blank" rel="external">这里</a>找到。</p>
<h2 id="循环展开_(Loop_unrolling)">循环展开 (Loop unrolling)</h2>
<p>现代的CPU都有一个叫做<a href="https://chadaustin.me/2009/02/latency-vs-throughput/" target="_blank" rel="external">指令流水线</a>的东西，它可以同时运行多条指令，如果它们之间没有数据依赖的话。数据依赖只是意味着一个指令的输入取决于另一个指令的输出。</p>
<p>在我们的简单实现中，我们的循环迭代之间有数据依赖。实际上，每个迭代都有一个读/写对，这意味着一个迭代不能开始执行，直到前一个迭代完成。</p>
<p>一个常见的方法是在循环中展开一些迭代，这样我们就可以在没有数据依赖的情况下执行更多的指令。此外，它将固定的循环开销（增量和比较）分摊到多个操作中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotUnroll4(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		s0 := a[i] * b[i]</div><div class="line">		s1 := a[i<span class="number">+1</span>] * b[i<span class="number">+1</span>]</div><div class="line">		s2 := a[i<span class="number">+2</span>] * b[i<span class="number">+2</span>]</div><div class="line">		s3 := a[i<span class="number">+3</span>] * b[i<span class="number">+3</span>]</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我们的展开代码中，乘法指令的依赖关系被移除了，这使得CPU可以更好地利用流水线。这使我们的吞吐量比我们的简单实现提高了37%。<br><img src="slow-to-simd1.png" alt=""></p>
<p>注意，我们实际上可以通过调整我们展开的迭代次数来进一步提高性能。在基准机器上，8似乎是最佳的，但在我的笔记本电脑上，4的性能最好。然而，改进是与平台相关的，而且改进相当微小，所以在本文的其余部分，我将使用4个展开深度来提高可读性。</p>
<h2 id="边界检查消除_(Bounds-checking_elimination)">边界检查消除 (Bounds-checking elimination)</h2>
<p>为了防止越界的切片访问成为安全漏洞（如著名的 <a href="https://en.wikipedia.org/wiki/Heartbleed" target="_blank" rel="external">Heartbleed 漏洞</a>），go 编译器在每次读取之前插入检查。你可以在生成的汇编中<a href="https://go.godbolt.org/z/qT3M7nPGf" target="_blank" rel="external">查看</a>它（查找 runtime.panic）。</p>
<p>编译的代码看起来像我们写了这样的东西：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotUnroll4(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s0 := a[i] * b[i]</div><div class="line">        <span class="keyword">if</span> i<span class="number">+1</span> &gt;= <span class="built_in">cap</span>(a) || i<span class="number">+1</span> &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s1 := a[i<span class="number">+1</span>] * b[i<span class="number">+1</span>]</div><div class="line">        <span class="keyword">if</span> i<span class="number">+2</span> &gt;= <span class="built_in">cap</span>(a) || i<span class="number">+2</span> &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s2 := a[i<span class="number">+2</span>] * b[i<span class="number">+2</span>]</div><div class="line">        <span class="keyword">if</span> i<span class="number">+3</span> &gt;= <span class="built_in">cap</span>(a) || i<span class="number">+3</span> &gt;= <span class="built_in">cap</span>(b) {</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"out of bounds"</span>)</div><div class="line">        }</div><div class="line">		s3 := a[i<span class="number">+3</span>] * b[i<span class="number">+3</span>]</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在像这样的频繁调用循环(hot loop)中，即使是现代的分支预测，每次迭代的额外分支也会增加相当大的性能损失。这在我们的例子中尤其明显，因为插入的跳转限制了我们可以利用流水线的程度。</p>
<p>如果我们可以告诉编译器这些读取永远不会越界，它就不会插入这些运行时检查。这种技术被称为“边界检查消除”，相同的模式也适用于Go之外的语言。</p>
<p>理论上，我们应该能够在循环之外做所有的检查，编译器就能够确定所有的切片索引都是安全的。然而，我找不到正确的检查组合来说服编译器我所做的是安全的。我最终选择了断言长度相等的组合，并将所有的边界检查移到循环的顶部。这足以接近无边界检查版本的速度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotBCE(a, b []<span class="typename">float32</span>) <span class="typename">float32</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slices must have equal lengths"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a)<span class="number">%4</span> !=<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slice length must be multiple of 4"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">	sum := <span class="typename">float32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		aTmp := a[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		bTmp := b[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		s0 := aTmp<span class="number">[0</span>] * bTmp<span class="number">[0</span>]</div><div class="line">		s1 := aTmp<span class="number">[1</span>] * bTmp<span class="number">[1</span>]</div><div class="line">		s2 := aTmp<span class="number">[2</span>] * bTmp<span class="number">[2</span>]</div><div class="line">		s3 := aTmp<span class="number">[3</span>] * bTmp<span class="number">[3</span>]</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个边界检查的最小化使我们的性能提高了 9%。但是始终未将检查降到零，没有什么值得一提的。<br><img src="slow-to-simd2.png" alt=""></p>
<p>这个技术对于内存安全的编程语言来说是非常有用的，比如Rust。</p>
<p>一个问题抛给读者： 为什么我们要像<code>a[i:i+4:i+4]</code>这样切片，而不是只是<code>a[i:i+4]</code>？</p>
<h2 id="量化_(Quantization)">量化 (Quantization)</h2>
<p>目前我们已经提高了单核的搜索的吞吐率50%以上，但现在我们遇到了一个新的瓶颈：内存使用。我们的向量是<strong>1536</strong>维的。用4字节的元素，这就是每个向量<strong>6KiB</strong>，我们每GiB代码生成大约一百万个向量。这很快就积累起来了。我们有一些客户带着一些大型的<code>monorepo</code>来找我们，我们想减少我们的内存使用，这样我们就可以更便宜地支持这些大型代码库。</p>
<p>一个可能的缓解措施是将向量移动到磁盘上，但是在搜索时从磁盘加载它们可能会增加显著的延迟，特别是在慢速磁盘上。相反，我们选择用<strong>int8</strong>量化我们的向量。</p>
<p>有很多方式可以压缩向量，但我们将讨论整数量化，这是相对简单但有效的。这个想法是通过将<strong>4字节</strong>的<code>float32</code>向量元素转换为<strong>1字节</strong>的<code>int8</code>来减少精度。</p>
<p>我不会深入讨论我们如何在<code>float32</code>和<code>int8</code>之间进行转换,因为这是一个相当深奥的<a href="https://huggingface.co/docs/optimum/concept_guides/quantization" target="_blank" rel="external">话题</a>,但可以说我们的函数现在看起来像下面这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> DotInt8BCE(a, b []<span class="typename">int8</span>) <span class="typename">int32</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"slices must have equal lengths"</span>)</div><div class="line">	}</div><div class="line"> </div><div class="line">	sum := <span class="typename">int32</span><span class="number">(0</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(a); i +=<span class="number"> 4</span> {</div><div class="line">		aTmp := a[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		bTmp := b[i : i<span class="number">+4</span> : i<span class="number">+4</span>]</div><div class="line">		s0 := <span class="typename">int32</span>(aTmp<span class="number">[0</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[0</span>])</div><div class="line">		s1 := <span class="typename">int32</span>(aTmp<span class="number">[1</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[1</span>])</div><div class="line">		s2 := <span class="typename">int32</span>(aTmp<span class="number">[2</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[2</span>])</div><div class="line">		s3 := <span class="typename">int32</span>(aTmp<span class="number">[3</span>]) * <span class="typename">int32</span>(bTmp<span class="number">[3</span>])</div><div class="line">		sum += s0 + s1 + s2 + s3</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个改变导致内存使用量减少了4倍，但牺牲了一些准确性（我们进行了仔细的测量，但这与本博客文章无关）。</p>
<p>不幸的是，这个改变导致我们的性能下降了。查看产生的汇编代码(<code>go tool compile -S</code>),我们可以看到一些<code>int8</code>到<code>int32</code>转换的指令，这可能解释了差异。我没有深入研究，因为我们在下一节中的所有性能改进都变得无关紧要了。</p>
<p><img src="slow-to-simd3.png" alt=""></p>
<h2 id="SIMD">SIMD</h2>
<p>到目前为止，速度提升还不错，但对于我们最大的客户来说，还不够。所以我们开始尝试一些更激进的方法。</p>
<p>我总是喜欢找借口来玩SIMD。而这个问题似乎正好对症下药。</p>
<p>对于还不熟悉SIMD的同学来说，SIMD代表“单指令多数据”(<code>Single Instruction Multiple Data</code>)。就像它说的那样，它允许你用一条指令在一堆数据上运行一个操作。举个例子，要对两个<code>int32</code>向量逐元素相加，我们可以用<code>ADD</code>指令一个一个地加起来，或者我们可以用<code>VPADDD</code>指令一次加上64对，延迟相同（取决于架构）。</p>
<p>但是我们还是有点问题。Go不像C或Rust那样暴露SIMD内部函数。我们有两个选择：用C写，然后用Cgo，或者用Go的汇编器手写。我尽量避免使用Cgo，因为有很多原因，这些原因都不是根本原因，但其中一个原因是Cgo会带来性能损失，而这个片段的性能是至关重要的。此外，用汇编写一些东西听起来很有趣，所以我就这么做了。</p>
<p>我想要这个这个算法可以输出到其他编程语言，所以我限制自己只使用AVX2指令，这些指令在大多数x86_64服务器CPU上都支持。我们可以使用运行时进行<a href="https://sourcegraph.com/github.com/sourcegraph/sourcegraph@3ac2170c6523dd074835919a1804f197cf86e451/-/blob/internal/embeddings/dot_amd64.go?L17-21" target="_blank" rel="external">检测</a>，在纯Go中回退到一个更慢的选项。</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line">TEXT ·DotAVX2(SB), <span class="preprocessor">NOSPLIT</span>, <span class="number">$0</span>-<span class="number">52</span></div><div class="line">	// Offsets based on slice header offsets.</div><div class="line">	// To check, use <span class="string">`GOARCH=amd64 go vet`</span></div><div class="line">	<span class="keyword">MOVQ</span> a_base+<span class="number">0</span>(FP), <span class="number">AX</span></div><div class="line">	<span class="keyword">MOVQ</span> b_base+<span class="number">24</span>(FP), <span class="number">BX</span></div><div class="line">	<span class="keyword">MOVQ</span> a_len+<span class="number">8</span>(FP), <span class="number">DX</span></div><div class="line">	XORQ <span class="literal">R8</span>, <span class="literal">R8</span> // return sum</div><div class="line">	// <span class="preprocessor">Zero</span> Y0, which will store <span class="number">8</span> packed <span class="number">32</span>-bit sums</div><div class="line">	<span class="keyword">VPXOR</span> Y0, Y0, Y0</div><div class="line">// <span class="keyword">In</span> blockloop, we calculate the dot product <span class="number">16</span> <span class="preprocessor">at</span> a time</div><div class="line"><span class="label">blockloop:</span></div><div class="line">	CMPQ <span class="number">DX</span>, <span class="number">$16</span></div><div class="line">	<span class="keyword">JB</span> reduce</div><div class="line">	// Sign-extend <span class="number">16</span> bytes <span class="keyword">into</span> <span class="number">16</span> int16s</div><div class="line">	<span class="keyword">VPMOVSXBW</span> (<span class="number">AX</span>), Y1</div><div class="line">	<span class="keyword">VPMOVSXBW</span> (<span class="number">BX</span>), Y2</div><div class="line">	// Multiply words vertically to form doubleword intermediates,</div><div class="line">	// then <span class="keyword">add</span> adjacent doublewords.</div><div class="line">	<span class="keyword">VPMADDWD</span> Y1, Y2, Y1</div><div class="line">	// <span class="keyword">Add</span> results to the running sum</div><div class="line">	<span class="keyword">VPADDD</span> Y0, Y1, Y0</div><div class="line">	ADDQ <span class="number">$16</span>, <span class="number">AX</span></div><div class="line">	ADDQ <span class="number">$16</span>, <span class="number">BX</span></div><div class="line">	SUBQ <span class="number">$16</span>, <span class="number">DX</span></div><div class="line">	<span class="keyword">JMP</span> blockloop</div><div class="line"><span class="label">reduce:</span></div><div class="line">	// X0 is the low <span class="built_in">bits</span> of Y0.</div><div class="line">	// Extract the high <span class="built_in">bits</span> <span class="keyword">into</span> X1, fold <span class="keyword">in</span> half, <span class="keyword">add</span>, repeat.</div><div class="line">	<span class="keyword">VEXTRACTI128</span> <span class="number">$1</span>, Y0, X1</div><div class="line">	<span class="keyword">VPADDD</span> X0, X1, X0</div><div class="line">	<span class="keyword">VPSRLDQ</span> <span class="number">$8</span>, X0, X1</div><div class="line">	<span class="keyword">VPADDD</span> X0, X1, X0</div><div class="line">	<span class="keyword">VPSRLDQ</span> <span class="number">$4</span>, X0, X1</div><div class="line">	<span class="keyword">VPADDD</span> X0, X1, X0</div><div class="line">	// Store the reduced sum</div><div class="line">	<span class="keyword">VMOVD</span> X0, <span class="literal">R8</span></div><div class="line"><span class="label">end:</span></div><div class="line">	MOVL <span class="literal">R8</span>, <span class="keyword">ret</span>+<span class="number">48</span>(FP)</div><div class="line">	<span class="keyword">VZEROALL</span></div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

<p>这个实现的核心循环依赖于三条主要指令：</p>
<ul>
<li><strong>VPMOVSXBW</strong>：将一个<code>int8</code>加载到一个<code>int16</code>向量中</li>
<li><strong>VPMADDWD</strong>：将两个<code>int16</code>向量逐个元素相乘,然后将相邻的两对模糊堆叠相加,生成一个 <code>int32</code> 向量。</li>
<li><strong>VPADDD</strong>：这将生成的 int32 向量累积到我们的运行总和</li>
</ul>
<p><code>VPMADDWD</code> 在这里是真正的主力军。通过将乘法和加法步骤合并为一个步骤，它不仅节省了指令，还帮助我们避免了溢出问题，同时将结果扩展为 <code>int32</code>。</p>
<p>让我们看看这给我们带来了什么。<br><img src="slow-to-simd4.png" alt=""></p>
<p>哇，这是我们之前最好表现的 530% 的增加！SIMD 胜利了 🚀。</p>
<p>现在，情况并非一帆风顺。在 Go 中手写汇编是有点奇怪的。它使用自定义的汇编器，这意味着它的汇编语言看起来与您通常在网上找到的汇编片段相比，会有略微不同而令人困惑。它有一些奇怪的怪癖，比如改变指令操作数的顺序或者使用不同的指令名称。在 Go 汇编器中，有些指令甚至没有名称，只能通过它们的二进制编码来使用。不得不说一句：我发现 sourcegraph.com 对于查找 Go 汇编示例非常有价值，可以供参考。</p>
<p>话虽如此，与 Cgo 相比，还是有一些不错的好处。调试仍然很好用，汇编可以逐步执行，并且可以使用 delve 检查寄存器。没有额外的构建步骤（不需要设置 C 工具链）。很容易设置一个纯 Go 的备用方案，所以跨编译仍然有效。常见问题被 go vet 捕捉到。</p>
<h2 id="SIMD_-_更大">SIMD ... 更大</h2>
<p>以前，我们限制自己只使用 <code>AVX2</code>，但如果不这样呢？<code>AVX-512</code> 的 <code>VNNI</code> 扩展添加了 <code>VPDPBUSD</code> 指令，该指令计算 <code>int8</code> 向量而不是 <code>int16</code> 的点积。这意味着我们可以在单个指令中处理四倍的元素，因为我们不必先转换为 int16，并且我们的向量宽度在 AVX-512 中加倍！</p>
<p>唯一的问题是该指令要求一个向量是有符号字节，另一个向量是无符号字节。而我们的两个向量都是有符号的。我们可以借鉴英特尔开发者指南中的技巧来解决这个问题。给定两个 int8 元素 <code>an</code> 和 <code>bn</code>，我们进行逐元素计算如下：<code>an * (bn + 128) - an * 128</code>。<code>an * 128</code> 项是将 <code>128</code> 加到 <code>bn</code> 以将其提升到 <code>u8</code> 范围的超出部分。我们单独跟踪这部分并在最后进行减法。该表达式中的每个操作都可以进行向量化处理。</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line"><span class="comment">// DotVNNI calculates the dot product of two slices using AVX512 VNNI</span></div><div class="line"><span class="comment">// instructions The slices must be of equal length and that length must be a</span></div><div class="line"><span class="comment">// multiple of 64.</span></div><div class="line">TEXT ·DotVNNI(SB), NOSPLIT, <span class="variable">$0</span>-<span class="number">52</span></div><div class="line">	<span class="comment">// Offsets based on slice header offsets.</span></div><div class="line">	<span class="comment">// To check, use `GOARCH=amd64 go vet`</span></div><div class="line">	MOVQ a_base+<span class="number">0</span>(FP), AX</div><div class="line">	MOVQ b_base+<span class="number">24</span>(FP), BX</div><div class="line">	MOVQ a_len+<span class="number">8</span>(FP), DX</div><div class="line">    ADDQ AX, DX <span class="comment">// end pointer</span></div><div class="line">	<span class="comment">// Zero our accumulators</span></div><div class="line">	VPXORQ Z0, Z0, Z0 <span class="comment">// positive</span></div><div class="line">	VPXORQ Z1, Z1, Z1 <span class="comment">// negative</span></div><div class="line">	<span class="comment">// Fill Z2 with 128</span></div><div class="line">	MOVD <span class="variable">$0</span>x80808080, R9</div><div class="line">	VPBROADCASTD R9, Z2</div><div class="line">blockloop:</div><div class="line">	CMPQ AX, DX</div><div class="line">	JE reduce</div><div class="line">	VMOVDQU8 (AX), Z3</div><div class="line">	VMOVDQU8 (BX), Z4</div><div class="line">	<span class="comment">// The VPDPBUSD instruction calculates of the dot product 4 columns at a</span></div><div class="line">	<span class="comment">// time, accumulating into an i32 vector. The problem is it expects one</span></div><div class="line">	<span class="comment">// vector to be unsigned bytes and one to be signed bytes. To make this</span></div><div class="line">	<span class="comment">// work, we make one of our vectors unsigned by adding 128 to each element.</span></div><div class="line">	<span class="comment">// This causes us to overshoot, so we keep track of the amount we need</span></div><div class="line">	<span class="comment">// to compensate by so we can subtract it from the sum at the end.</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Effectively, we are calculating SUM((Z3 + 128) · Z4) - 128 * SUM(Z4).</span></div><div class="line">	VPADDB Z3, Z2, Z3   <span class="comment">// add 128 to Z3, making it unsigned</span></div><div class="line">	VPDPBUSD Z4, Z3, Z0 <span class="comment">// Z0 += Z3 dot Z4</span></div><div class="line">	VPDPBUSD Z4, Z2, Z1 <span class="comment">// Z1 += broadcast(128) dot Z4</span></div><div class="line">	ADDQ <span class="variable">$6</span>4, AX</div><div class="line">	ADDQ <span class="variable">$6</span>4, BX</div><div class="line">	JMP blockloop</div><div class="line">reduce:</div><div class="line">    <span class="comment">// Subtract the overshoot from our calculated dot product</span></div><div class="line">	VPSUBD Z1, Z0, Z0 <span class="comment">// Z0 -= Z1</span></div><div class="line">    <span class="comment">// Sum Z0 horizontally. There is no horizontal sum instruction, so instead</span></div><div class="line">    <span class="comment">// we sum the upper and lower halves of Z0, fold it in half again, and</span></div><div class="line">    <span class="comment">// repeat until we are down to 1 element that contains the final sum.</span></div><div class="line">    VEXTRACTI64X4 <span class="variable">$1</span>, Z0, Y1</div><div class="line">    VPADDD Y0, Y1, Y0</div><div class="line">	VEXTRACTI128 <span class="variable">$1</span>, Y0, X1</div><div class="line">	VPADDD X0, X1, X0</div><div class="line">	VPSRLDQ <span class="variable">$8</span>, X0, X1</div><div class="line">	VPADDD X0, X1, X0</div><div class="line">	VPSRLDQ <span class="variable">$4</span>, X0, X1</div><div class="line">	VPADDD X0, X1, X0</div><div class="line">	<span class="comment">// Store the reduced sum</span></div><div class="line">	VMOVD X0, R8</div><div class="line">end:</div><div class="line">	MOVL R8, ret+<span class="number">48</span>(FP)</div><div class="line">	VZEROALL</div><div class="line">	RET</div></pre></td></tr></table></figure>

<p>这种实现又带来了另外 21% 的改进。真不赖！<br><img src="slow-to-simd5.png" alt=""></p>
<h2 id="下一步">下一步</h2>
<p>好吧，我对吞吐量增加 9.3 倍和内存使用量减少 4 倍感到非常满意，所以我可能会适可而止了。</p>
<p>现实生活中的答案可能是“使用索引”。有大量优秀的工作致力于使最近邻居搜索更快,并且有许多内置向量DB使其部署相当简单。</p>
<p>然而，如果你想要一些有趣的思考，我的一位同事在 <a href="https://github.com/sourcegraph/sourcegraph/compare/simd-post-gpu-embeddings~3...simd-post-gpu-embeddings" target="_blank" rel="external">GPU 实现的点积</a>。</p>
<p><strong>一些有价值的资料</strong></p>
<ul>
<li>如果你还没有使用过 <a href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat" target="_blank" rel="external">benchstat</a>，你应该使用。太棒了。基准测试结果超级简单统计比较。</li>
<li>不要错过<a href="https://go.godbolt.org/z/qT3M7nPGf" target="_blank" rel="external">compiler explorer</a>，这是一个非常有用的挖掘生成的汇编代码工具。</li>
<li>还有一次,我被技术上的挑战吸引,实现了<a href="https://github.com/camdencheek/simd_blog/blob/main/dot_arm64.s" target="_blank" rel="external">ARM NEON的版本</a>,这带来了一些有趣的对比。</li>
<li>如果您还没有遇到过它，<a href="https://www.agner.org/optimize/" target="_blank" rel="external">Agner Fog 说明表</a>会让您大吃一惊,很多底层优化的参考资料。在优化点积函数的工作中，我使用它们来理解指令延迟的差异,以及为什么某些流水线优于其他流水线。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>SourceGraph 的工程师 Camden Cheek 提供的一个利用SIMD进行Go性能优化的故事:<a href="https://sourcegraph.com/blog/slow-to-simd" target="_blank" rel="external">From slow to SIMD: A Go optimization story</a>。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[遍历函数？Go 1.22中隐藏的功能]]></title>
    <link href="https://colobu.com/2024/01/18/range-over-func/"/>
    <id>https://colobu.com/2024/01/18/range-over-func/</id>
    <published>2024-01-18T13:29:15.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.22中可以 range 一个整数，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span><span class="number"> 10</span> {</div><div class="line">    fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个大家都已经知道了，其实对应的提案中还有一个隐藏的功能，就是可以 range 一个函数，比如下面的代码(摘自官方代码库<a href="https://github.com/golang/go/blob/97daa6e94296980b4aa2dac93a938a5edd95ce93/src/internal/trace/v2/event.go#L262" target="_blank" rel="external">internal/trace/v2/event.go</a>)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Frames is an iterator over the frames in a Stack.</span></div><div class="line"><span class="keyword">func</span> (s Stack) Frames(yield <span class="keyword">func</span>(f StackFrame) <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> s.id ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	stk := s.table.stacks.mustGet(s.id)</div><div class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> stk.frames {</div><div class="line">		sf := StackFrame{</div><div class="line">			PC:   f.pc,</div><div class="line">			Func: s.table.strings.mustGet(f.funcID),</div><div class="line">			File: s.table.strings.mustGet(f.fileID),</div><div class="line">			Line: f.line,</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !yield(sf) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>就少有介绍了。</p>
<p>本文尝试介绍它，让读者先了解一下，它在Go 1.22 中是一个实验性的功能，还不确定未来在哪个版本中会被正式支持。</p>
<p>官方wiki中也有一篇介绍: <a href="https://go.dev/wiki/RangefuncExperiment" target="_blank" rel="external">Rangefunc Experiment</a>，类似问答的形式，也是必读的知识库。<br><a id="more"></a></p>
<p>这个功能去年Russ Cox发起讨论(<a href="https://github.com/golang/go/discussions/56413" target="_blank" rel="external">#56413</a>), 并建立一个提案(<a href="https://github.com/golang/go/issues/61405" target="_blank" rel="external">#61405</a>),大家讨论都很激烈啊，几百次的讨论，所以我也不准备介绍前因后果了，直接了当的说结论。<br>先前, <code>for-range</code>所能遍历(迭代)的类型很有限，只能是slice、数组、map、字符串、channel等。<br>现在，除了上面的五种类型，还可以是整数和三种三种函数。</p>
<p>当然<code>for x := range n { ... }</code>等价于<code>for x := T(0); x &lt; n; x++ { ... }</code>, 其中T是n的类型。这个大家都知道了。</p>
<p>三个函数可能大家不是很了解，很正常，目前这只是一个实验性的功能。当然range的类型如下：</p>
<table>
<thead>
<tr>
<th>Range 表达式</th>
<th>第一个值</th>
<th>第二个值</th>
</tr>
</thead>
<tbody>
<tr>
<td>array or slice      a  [n]E, *[n]E, or []E</td>
<td>index    i  int</td>
<td>a[i]       E</td>
</tr>
<tr>
<td>string              s  string type</td>
<td>index    i  int</td>
<td>see below  rune</td>
</tr>
<tr>
<td>map                 m  map[K]V</td>
<td>key      k  K</td>
<td>m[k]       V</td>
</tr>
<tr>
<td>channel             c  chan E, &lt;-chan E</td>
<td>element  e  E</td>
<td></td>
</tr>
<tr>
<td>integer             n  integer type</td>
<td>index    i int</td>
<td></td>
</tr>
<tr>
<td>function, 0 values  f  func(func()bool) bool</td>
<td></td>
<td></td>
</tr>
<tr>
<td>function, 1 value   f  func(func(V)bool) bool</td>
<td>value    v  V</td>
<td></td>
</tr>
<tr>
<td>function, 2 values  f  func(func(K, V)bool) bool</td>
<td>key      k  K</td>
<td>v          V</td>
</tr>
</tbody>
</table>
<p>本文介绍的就是后三种形式</p>
<h2 id="三种可遍历的函数">三种可遍历的函数</h2>
<p>假设<code>f</code>是一个这样的函数:<code>func(func()bool) bool</code>, 那么<code>for x := range f { ... }</code>类似于<code>f(func(x T1, y T2) bool { ... })</code>，其中for循环移动到方法体中了。<code>yield</code>的bool返回值指示是否还要继续遍历。</p>
<p>对于这样一个<code>f</code>,下面的格式都可以:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> x, y := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> x, _ := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> _, y := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> f { ... }</div><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> f { ... }</div></pre></td></tr></table></figure>

<p>下面是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>(k <span class="typename">int</span>, v <span class="typename">byte</span>) <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">		<span class="keyword">if</span> !yield(i, <span class="typename">byte</span>(<span class="string">'a'</span>+i)) {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> fn {</div><div class="line">	fmt.Printf(<span class="string">"%d: %c\n"</span>, k, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行可以看到结果符合预期，我们遍历了26个小写字母，注意range的数据类型是我们的函数:<br><img src="range-func.png" alt=""></p>
<p>这里，fn这个函数没有返回值，其实也可以有bool返回值，有bool返回值就可以组合多个range函数，可以容易写出复杂且难以维护的代码，减少自己失业的可能。<br>这里的<code>yield</code>函数接收两个参数，第一个是<code>int</code>类型，第二个是<code>byte</code>类型，返回值是<code>bool</code>类型，这个<code>yield</code>函数的返回值决定了是否继续遍历。当然这里我们可以写泛型的程序，这里为了简单，就不写了。</p>
<p>下面是一个<code>f</code>是<code>func(func(V)bool) bool</code>的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>(v <span class="typename">byte</span>) <span class="typename">bool</span>) {</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">        <span class="keyword">if</span> !yield(<span class="typename">byte</span>(<span class="string">'a'</span> + i)) {</div><div class="line">            <span class="keyword">return</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> fn {</div><div class="line">    fmt.Printf(<span class="string">"%c\n"</span>, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="range-func2.png" alt=""></p>
<p>当然yield函数也可以没有参数，比如<code>func(func()bool) bool</code>，下面这个例子就是无参数的形式，输出结果是26。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>() <span class="typename">bool</span>) {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">			<span class="keyword">if</span> !yield() {</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> count <span class="typename">int</span></div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> fn {</div><div class="line">		count++</div><div class="line">	}</div><div class="line">	fmt.Println(count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果不使用for-range 函数的形式，我们可以进行改写，比如两个参数的列子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="keyword">func</span>(yield <span class="keyword">func</span>(k <span class="typename">int</span>, v <span class="typename">byte</span>) <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 26</span>; i++ {</div><div class="line">		<span class="keyword">if</span> !yield(i, <span class="typename">byte</span>(<span class="string">'a'</span>+i)) {</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">fn(<span class="keyword">func</span>(k <span class="typename">int</span>, v <span class="typename">byte</span>) <span class="typename">bool</span> {</div><div class="line">	fmt.Printf(<span class="string">"%d: %c\n"</span>, k, v)</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">})</div></pre></td></tr></table></figure>

<p>注意<code>yield</code>参数名称不是一个关键字，它只是一个普通的参数名称，可以随便取名字，但是为了模仿和其它语言中的<code>generator</code>,使用了<code>yield</code>这样一个名称，以至于代码更加易读。</p>
<p>看起来这个功能就是一个语法糖， 代码<a href="https://go.googlesource.com/go/+/refs/changes/41/510541/7/src/cmd/compile/internal/rangefunc/rewrite.go" target="_blank" rel="external">rangefunc/rewrite</a>将range-over-func代码写成非range-over-func代码的形式。</p>
<h2 id="为什么要这样做？">为什么要这样做？</h2>
<p>标准库中就有 <code>archive/tar.Reader.Next</code>, <code>bufio.Reader.ReadByte</code>, <code>bufio.Scanner.Scan</code>, <code>container/ring.Ring.Do</code>, <code>database/sql.Rows</code>, <code>expvar.Do</code>, <code>flag.Visit</code>, <code>go/token.FileSet.Iterate</code>, <code>path/filepath.Walk</code>, <code>go/token.FileSet.Iterate</code>, <code>runtime.Frames.Next</code> 和<code>sync.Map.Range</code>等各种遍历的函数，所以如果有一种统一的格式更好。</p>
<p>第三方库中有更多的类似代码。</p>
<p>虽然这个功能还没有正式支持，但是我看到有些库摩拳擦掌准备使用了，而<a href="https://github.com/achille-roussel/sqlrange" target="_blank" rel="external">sqlrange</a>更进一步，已经支持了。</p>
<p>当然你使用它必须下载Go 1.22或者gotip, 并且设置<code>export GOEXPERIMENT=rangefunc</code>。</p>
<p>它提供了<code>Query</code>和<code>Exec</code>可遍历函数。比如<code>Query</code>从一个表中查询<code>Point</code>数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> {</div><div class="line">    X <span class="typename">float64</span> <span class="string">`sql:"x"`</span></div><div class="line">    Y <span class="typename">float64</span> <span class="string">`sql:"y"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> p, err := <span class="keyword">range</span> sqlrange.Query[Point](db, <span class="string">`select x, y from points`</span>) {</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        ...</div><div class="line">    }</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>遍历查询和ORM一气呵成。这里的资源管理是自动的,底层的<code>*sql.Rows</code>遍历完会自动关闭。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.22中可以 range 一个整数，比如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span><span class="number"> 10</span> {</div><div class="line">    fmt.Println(i)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个大家都已经知道了，其实对应的提案中还有一个隐藏的功能，就是可以 range 一个函数，比如下面的代码(摘自官方代码库<a href="https://github.com/golang/go/blob/97daa6e94296980b4aa2dac93a938a5edd95ce93/src/internal/trace/v2/event.go#L262" target="_blank" rel="external">internal/trace/v2/event.go</a>)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Frames is an iterator over the frames in a Stack.</span></div><div class="line"><span class="keyword">func</span> (s Stack) Frames(yield <span class="keyword">func</span>(f StackFrame) <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> s.id ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	stk := s.table.stacks.mustGet(s.id)</div><div class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> stk.frames {</div><div class="line">		sf := StackFrame{</div><div class="line">			PC:   f.pc,</div><div class="line">			Func: s.table.strings.mustGet(f.funcID),</div><div class="line">			File: s.table.strings.mustGet(f.fileID),</div><div class="line">			Line: f.line,</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !yield(sf) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>就少有介绍了。</p>
<p>本文尝试介绍它，让读者先了解一下，它在Go 1.22 中是一个实验性的功能，还不确定未来在哪个版本中会被正式支持。</p>
<p>官方wiki中也有一篇介绍: <a href="https://go.dev/wiki/RangefuncExperiment" target="_blank" rel="external">Rangefunc Experiment</a>，类似问答的形式，也是必读的知识库。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 6.8 网络优化, 大量并发连接的TCP性能提高40%左右]]></title>
    <link href="https://colobu.com/2024/01/14/Linux-6-8-Networking/"/>
    <id>https://colobu.com/2024/01/14/Linux-6-8-Networking/</id>
    <published>2024-01-14T09:21:08.000Z</published>
    <updated>2024-02-02T07:54:29.788Z</updated>
    <content type="html"><![CDATA[<p>除了通常的新有线/无线网络硬件支持和大型 Linux 网络子系统中的其他例行变动之外，Linux 6.8 内核还对核心网络代码进行了一些关键改进，当遇到许多并发网络连接时，TCP 性能可以提高 ~40%。</p>
<a id="more"></a>
<p>首先，对核心网络结构进行了分析和重组。这项工作一直围绕着<strong>优化缓存行</strong>的使用和添加保护措施，以确保未来的更改不会倒退。反过来，这种对核心网络结构的优化导致许多并发连接的 TCP 性能提高了 40% 或更多！</p>
<p>Google 的 Coco Li 解释了他们对网络代码的 cachline 优化工作：</p>
<blockquote>
<p>当前,网络栈中的变量密集结构按时间顺序、逻辑顺序组织，有时按缓存行访问组织。这个补丁系列试图重新组织核心网络栈变量,以在数据传输阶段最小化缓存行消耗。具体来说,我们研究了TCP/IP栈和TCP中的快速路径定义。<br>出于文档目的,我们还为我们考虑的每个核心数据结构添加了新的文件,尽管由于现有缓存行跨度的数量,并非所有在快速路径上都已被修改。在文档中,我们记录了我们在快速路径上识别的所有变量及原因。我们还希望在未来添加/修改变量时,可以参考并相应地更新文档,以反映最新变量组织。</p>
<p>测试:我们的测试使用<code>neper tcp_rr</code>测试tcp流量。测试具有<code>$cpu</code>数量的线程和可变数量的流量(见下文)。测试在6.5-rc1上运行 效率计算为cpu秒数/吞吐量(一个tcp_rr往返行程)。下面的结果显示在应用补丁系列之前和之后的效率delta。</p>
</blockquote>
<ul>
<li>在AMD平台上， <strong>100Gb/s</strong> 的网卡和 <strong>256Mb</strong> 三级缓存：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">IPv4</div><div class="line">Flows   with patches    clean kernel      Percent reduction</div><div class="line"><span class="number">30</span>k     <span class="number">0.0001736538065</span> <span class="number">0.0002741191042</span> -<span class="number">36.65</span>%</div><div class="line"><span class="number">20</span>k     <span class="number">0.0001583661752</span> <span class="number">0.0002712559158</span> -<span class="number">41.62</span>%</div><div class="line"><span class="number">10</span>k     <span class="number">0.0001639148817</span> <span class="number">0.0002951800751</span> -<span class="number">44.47</span>%</div><div class="line"><span class="number">5</span>k      <span class="number">0.0001859683866</span> <span class="number">0.0003320642536</span> -<span class="number">44.00</span>%</div><div class="line"><span class="number">1</span>k      <span class="number">0.0002035190546</span> <span class="number">0.0003152056382</span> -<span class="number">35.43</span>%</div><div class="line"></div><div class="line">IPv6</div><div class="line">Flows   with patches  clean kernel    Percent reduction</div><div class="line"><span class="number">30</span>k     <span class="number">0.000202535503</span>  <span class="number">0.0003275329163</span> -<span class="number">38.16</span>%</div><div class="line"><span class="number">20</span>k     <span class="number">0.0002020654777</span> <span class="number">0.0003411304786</span> -<span class="number">40.77</span>%</div><div class="line"><span class="number">10</span>k     <span class="number">0.0002122427035</span> <span class="number">0.0003803674705</span> -<span class="number">44.20</span>%</div><div class="line"><span class="number">5</span>k      <span class="number">0.0002348776729</span> <span class="number">0.0004030403953</span> -<span class="number">41.72</span>%</div><div class="line"><span class="number">1</span>k      <span class="number">0.0002237384583</span> <span class="number">0.0002813646157</span> -<span class="number">20.48</span>%</div></pre></td></tr></table></figure>

<ul>
<li>在Intel平台上， <strong>200Gb/s</strong> 的网卡和 <strong>205Mb</strong> 三级缓存：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IPv6</div><div class="line">Flows   with patches    clean kernel    Percent reduction</div><div class="line"><span class="number">30</span>k     <span class="number">0.0006296537873</span> <span class="number">0.0006370427753</span> -<span class="number">1.16</span>%</div><div class="line"><span class="number">20</span>k     <span class="number">0.0003451029365</span> <span class="number">0.0003628016076</span> -<span class="number">4.88</span>%</div><div class="line"><span class="number">10</span>k     <span class="number">0.0003187646958</span> <span class="number">0.0003346835645</span> -<span class="number">4.76</span>%</div><div class="line"><span class="number">5</span>k      <span class="number">0.0002954676348</span> <span class="number">0.000311807592</span>  -<span class="number">5.24</span>%</div><div class="line"><span class="number">1</span>k      <span class="number">0.0001909169342</span> <span class="number">0.0001848069709</span> <span class="number">3.31</span>%</div></pre></td></tr></table></figure>

<p>对于Intel的服务器，优化不是那么明显，但是对于对于AMD EPYC服务器而言，这是一个天使般的改进，它们的网络性能提高了 40% 左右，这是一个巨大的提升。</p>
<p>相关的优化补丁可以查看<a href="https://lore.kernel.org/netdev/20231129072756.3684495-1-lixiaoyan@google.com/" target="_blank" rel="external">Analyze and Reorganize core Networking Structs to optimize cacheline consumption</a>, 主要由谷歌的Coco Li提交。</p>
<p><img src="tcp-cacheline.png" alt=""></p>
<p>tcp的优化已经实现了，udp的优化还会远吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>除了通常的新有线/无线网络硬件支持和大型 Linux 网络子系统中的其他例行变动之外，Linux 6.8 内核还对核心网络代码进行了一些关键改进，当遇到许多并发网络连接时，TCP 性能可以提高 ~40%。</p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="https://colobu.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高效I/O并发处理：双缓冲和Exchanger]]></title>
    <link href="https://colobu.com/2024/01/14/double-buffering-and-Exchanger/"/>
    <id>https://colobu.com/2024/01/14/double-buffering-and-Exchanger/</id>
    <published>2024-01-14T03:45:47.000Z</published>
    <updated>2024-02-02T07:54:29.792Z</updated>
    <content type="html"><![CDATA[<p>双缓冲(double buffering)是高效处理I/O操作的一种并发技术，它使用两个buffer,一个goroutine使用其中一个buffer进行写，而另一个goroutine使用另一个buffer进行读，然后进行交换。这样两个goroutine可能并发的执行，减少它们之间的等待和阻塞。</p>
<p>本文还提供了一个类似Java的<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Exchanger.html" target="_blank" rel="external">java.util.concurrent.Exchanger</a>的Go并发原语，它可以用来在两个goroutine之间交换数据，快速实现双缓冲的模式。 这个并发原语可以在<a href="https://pkg.go.dev/github.com/smallnest/exp@v0.2.2/sync#Exchanger" target="_blank" rel="external">github.com/smallnest/exp/sync/Exchanger</a>找到。</p>
<a id="more"></a>
<h2 id="double_buffering_并发模式">double buffering 并发模式</h2>
<p>双缓冲(double buffering)设计方式虽然在一些领域中被广泛的应用，但是我还没有看到它在并发模式中专门列出了，或者专门列为一种模式。这里我们不妨把它称之为<strong>双缓存模式</strong>。</p>
<p>这是一种在I/O处理领域广泛使用的用来提速的编程技术，它使用两个缓冲区来加速计算机，该计算机可以重叠 <strong>I/O</strong> 和<strong>处理</strong>。一个缓冲区中的数据正在处理，而下一组数据被读入另一个缓冲区。<br>在流媒体应用程序中，一个缓冲区中的数据被发送到声音或图形卡，而另一个缓冲区则被来自源（Internet、本地服务器等）的更多数据填充。<br>当视频显示在屏幕上时，一个缓冲区中的数据被填充，而另一个缓冲区中的数据正在显示。当在缓冲区之间移动数据的功能是在硬件电路中实现的，而不是由软件执行时，全动态视频的速度会加快，不但速度被加快，而且可以减少黑屏闪烁的可能。</p>
<p>！<a href="double-buffering.png"></a></p>
<p>在这个模式中，两个goroutine并发的执行，一个goroutine使用一个buffer进行写(不妨称为buffer1)，而另一个goroutine使用另一个buffer进行读(不妨称为buffer2)。如图所示。<br>当左边的writer写满它当前使用的buffer1后，它申请和右边的goroutine的buffer2进行交换，这会出现两种情况：</p>
<ul>
<li>右边的reader已经读完了它当前使用的buffer2，那么它会立即交换，这样左边的writer可以继续写buffer2，而右边的reader可以继续读buffer1。</li>
<li>右边的reader还没有读完buffer2，那么左边的writer就会阻塞，直到右边的reader读完buffer2，然后交换。<br>周而复始。</li>
</ul>
<p>同样右边的goroutine也是同样的处理，当它读完buffer2后，它会申请和左边的goroutine的buffer1进行交换，这会出现两种情况：</p>
<ul>
<li>左边的writer已经写完了它当前使用的buffer1，那么它会立即交换，这样右边的reader可以继续读buffer1，而左边的writer可以继续写buffer2。</li>
<li>左边的writer还没有写完buffer1，那么右边的reader就会阻塞，直到左边的writer写完buffer1，然后交换。<br>周而复始。</li>
</ul>
<p>这样两个goroutine就可以并发的执行，而不用等待对方的读写操作。这样可以提高并发处理的效率。</p>
<p>不仅仅如此， double buffering其实可以应用于更多的场景， 不仅仅是buffer的场景，如Java的垃圾回收机制中，HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to,或者s0和s1），在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被<strong>清空</strong>。这个时候，“From”和“To”会交换(<strong>exchange</strong>)他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<br><img src="java-gc.png" alt=""></p>
<h2 id="Exchanger的实现">Exchanger的实现</h2>
<p>既然有这样的场景，有这样的需求，所以我们需要针对这样场景的一个同步原语。Java给我们做了一个很好的师范，接下来我们使用实现相应的Go,但是我们的实现和Java的实现完全不同，我们要基于Go既有的同步原语来实现。</p>
<p>基于Java实现的Exchanger的功能，我们也实现一个<code>Exchanger</code>, 我们期望它的功能如下：</p>
<ul>
<li>只用作两个goroutine之间的数据交换，不支持多个goroutine之间的数据交换。</li>
<li>可以重用。交换完之后还可以继续交换</li>
<li>支持泛型，可以交换任意类型的数据</li>
<li>如果对端还没有准备交换，就阻塞等待</li>
<li>在交换完之前，阻塞的goroutine不可能调用<code>Exchange</code>方法两次</li>
<li>Go内存模型补充： 同一次交换， 一个goroutine在调用<code>Exchange</code>方法的完成，一定<strong>happens after</strong>另一个goroutine调用<code>Exchange</code>方法的开始。</li>
</ul>
<p>如果你非常熟悉Go的各种同步原语，你可以很快的组合出这样一个同步原语。如果你还不是那么熟悉，建议你阅读《深入理解Go并发编程》这本书，京东有售。<br>下面是一个简单的实现，代码在<a href="https://pkg.go.dev/github.com/smallnest/exp@v0.2.2/sync#Exchanger" target="_blank" rel="external">Exchanger</a>。<br>我们只用<code>left</code>、<code>right</code>指代这两个goroutine, goroutine是Go语言中的并发单元，我们期望的就是这两个goroutine发生关系。</p>
<p>为了跟踪这两个goroutine，我们需要使用goroutine id来标记这两个goroutine，这样避免了第三者插入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Exchanger[T any] <span class="keyword">struct</span> {</div><div class="line">	leftGoID, rightGoID <span class="typename">int64</span></div><div class="line">	left, right         <span class="keyword">chan</span> T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你必须使用 <code>NewExchanger</code> 创建一个<code>Exchanger</code>，它会返回一个<code>Exchanger</code>的指针。<br>初始化的时候我们把left和right的id都设置为-1，表示还没有goroutine使用它们，并且不会和所有的goroutine的id冲突。<br>同时我们创建两个channel，一个用来左边的goroutine写，右边的goroutine读，另一个用来右边的goroutine写，左边的goroutine读。channel的buffer设置为1，这样可以避免死锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewExchanger[T any]() *Exchanger[T] {</div><div class="line">	<span class="keyword">return</span> &Exchanger[T]{</div><div class="line">		leftGoID: <span class="number"> -1</span>,</div><div class="line">		rightGoID:<span class="number"> -1</span>,</div><div class="line">		left:      <span class="built_in">make</span>(<span class="keyword">chan</span> T,<span class="number"> 1</span>),</div><div class="line">		right:     <span class="built_in">make</span>(<span class="keyword">chan</span> T,<span class="number"> 1</span>),</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Exchange</code>方法是核心方法，它用来交换数据，它的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *Exchanger[T]) Exchange(value T) T {</div><div class="line">	goid := goroutine.ID()</div><div class="line"></div><div class="line">	<span class="comment">// left goroutine</span></div><div class="line">	isLeft := atomic.CompareAndSwapInt64(&e.leftGoID,<span class="number"> -1</span>, goid)</div><div class="line">	<span class="keyword">if</span> !isLeft {</div><div class="line">		isLeft = atomic.LoadInt64(&e.leftGoID) == goid</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> isLeft {</div><div class="line">		e.right &lt;- value <span class="comment">// send value to right</span></div><div class="line">		<span class="keyword">return</span> &lt;-e.left  <span class="comment">// wait for value from right</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// right goroutine</span></div><div class="line">	isRight := atomic.CompareAndSwapInt64(&e.rightGoID,<span class="number"> -1</span>, goid)</div><div class="line">	<span class="keyword">if</span> !isRight {</div><div class="line">		isRight = atomic.LoadInt64(&e.rightGoID) == goid</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> isRight {</div><div class="line">		e.left &lt;- value  <span class="comment">// send value to left</span></div><div class="line">		<span class="keyword">return</span> &lt;-e.right <span class="comment">// wait for value from left</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// other goroutine</span></div><div class="line">	<span class="built_in">panic</span>(<span class="string">"sync: exchange called from neither left nor right goroutine"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当一个goroutine调用的时候，首先我们尝试把它设置为<code>left</code>,如果成功，那么它就是<code>left</code>。<br>如果不成功，我们就判断它是不是先前已经是<code>left</code>，如果是，那么它就是<code>left</code>。<br>如果先前，或者此时<code>left</code>已经被另一个goroutine占用了，它还有机会成为<code>right</code>，同样的逻辑检查和设置<code>right</code>。</p>
<p>如果既不是<code>left</code>也不是<code>right</code>，那么就是第三者插入了，我们需要panic，因为我们不希望第三者插足。</p>
<p>如果它是<code>left</code>，那么它就会把数据发送到<code>right</code>，然后等待<code>right</code>发送数据过来。<br>如果它是<code>right</code>，那么它就会把数据发送到<code>left</code>，然后等待<code>left</code>发送数据过来。</p>
<p>这样就实现了数据的交换。</p>
<h2 id="Exchanger的使用">Exchanger的使用</h2>
<p>我们使用一个简单的双缓冲例子来说明如何使用<code>Exchanger</code>，我们创建两个goroutine，一个goroutine负责写，另一个goroutine负责读，它们之间通过<code>Exchanger</code>来交换数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">buf1 := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>))</div><div class="line">buf2 := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>))</div><div class="line"></div><div class="line">exchanger := syncx.NewExchanger[*bytes.Buffer]()</div><div class="line"></div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">wg.Add<span class="number">(2</span>)</div><div class="line"></div><div class="line">expect :=<span class="number"> 0</span></div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() { <span class="comment">// g1</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	buf := buf1</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 1024</span>; j++ {</div><div class="line">			buf.WriteByte(<span class="typename">byte</span>(j /<span class="number"> 256</span>))</div><div class="line">			expect += j /<span class="number"> 256</span></div><div class="line">		}</div><div class="line"></div><div class="line">		buf = exchanger.Exchange(buf)</div><div class="line">	}</div><div class="line">}()</div><div class="line"></div><div class="line"><span class="keyword">var</span> got <span class="typename">int</span></div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span>() { <span class="comment">// g2</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	buf := buf2</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		buf = exchanger.Exchange(buf)</div><div class="line">		<span class="keyword">for</span> _, b := <span class="keyword">range</span> buf.Bytes() {</div><div class="line">			got += <span class="typename">int</span>(b)</div><div class="line">		}</div><div class="line">		buf.Reset()</div><div class="line">	}</div><div class="line">}()</div><div class="line"></div><div class="line">wg.Wait()</div><div class="line"></div><div class="line">fmt.Println(got)</div><div class="line">fmt.Println(expect == got)</div></pre></td></tr></table></figure>

<p>在这个例子中 <code>g1</code>负责写，每个buffer的容量是1024，写满就交给另外一个读g2,并从读g2中交换过来一个空的buffer继续写。<br>交换10次之后，两个goroutine都退出了，我们检查写入的数据和读取的数据是否一致，如果一致，那么就说明我们的<code>Exchanger</code>实现是正确的。</p>
<h2 id="总结">总结</h2>
<p>文本介绍了一种类似Java的<code>Exchanger</code>的同步原语的实现，这个同步原语可以在双缓冲的场景中使用，提高并发处理的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>双缓冲(double buffering)是高效处理I/O操作的一种并发技术，它使用两个buffer,一个goroutine使用其中一个buffer进行写，而另一个goroutine使用另一个buffer进行读，然后进行交换。这样两个goroutine可能并发的执行，减少它们之间的等待和阻塞。</p>
<p>本文还提供了一个类似Java的<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Exchanger.html" target="_blank" rel="external">java.util.concurrent.Exchanger</a>的Go并发原语，它可以用来在两个goroutine之间交换数据，快速实现双缓冲的模式。 这个并发原语可以在<a href="https://pkg.go.dev/github.com/smallnest/exp@v0.2.2/sync#Exchanger" target="_blank" rel="external">github.com/smallnest/exp/sync/Exchanger</a>找到。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go运行时的并发原语]]></title>
    <link href="https://colobu.com/2024/01/07/concurrent-codes-in-Go-runtime-and-standard-library/"/>
    <id>https://colobu.com/2024/01/07/concurrent-codes-in-Go-runtime-and-standard-library/</id>
    <published>2024-01-07T05:40:31.000Z</published>
    <updated>2024-02-02T07:54:29.792Z</updated>
    <content type="html"><![CDATA[<p>这篇文章我们来了解一下隐藏在Go运行时中的一些并发原语， 因为运行时是底座和包循环依赖等原因，运行时中很少使用标准库中的并发原语，它有自己的并发原语。</p>
<a id="more"></a>
<h3 id="mutex">mutex</h3>
<p>在<a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L164" target="_blank" rel="external">runtime/runtime2.go</a> 定义了一个互斥锁，它的定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> mutex <span class="keyword">struct</span> {</div><div class="line">	lockRankStruct</div><div class="line">	key <span class="typename">uintptr</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它可是运行时中的大红人了，在很多数据结构中都被广泛的使用，凡事涉及到并发访问的地方都会用到它，你在<code>runtime2.go</code>文件中就能看到多处使用它的地方，因为很多地方都在使用它，我就不一一列举了在runtime这个文件夹中搜<code>mutex</code>这个关键子就都搜出来了。</p>
<p>举一个大家常用来底层分析的数据结构<code>channel</code>为例，channel的数据结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</div><div class="line">	qcount   <span class="typename">uint</span>           </div><div class="line">	dataqsiz <span class="typename">uint</span>           </div><div class="line">	buf      unsafe.Pointer </div><div class="line">	elemsize <span class="typename">uint16</span></div><div class="line">	closed   <span class="typename">uint32</span></div><div class="line">	elemtype *_type </div><div class="line">	sendx    <span class="typename">uint</span>   </div><div class="line">	recvx    <span class="typename">uint</span>   </div><div class="line">	recvq    waitq  </div><div class="line">	sendq    waitq  </div><div class="line"></div><div class="line">	lock mutex</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后哪个字段<code>lock mutex</code>就是使用的这个互斥锁。因为一个通道在发送和接收的时候都会涉及到对通道的修改，在多发送者或者接收者情况下，需要使用互斥锁来保护。</p>
<p>这个互斥锁的使用需要调用几个函数。</p>
<ul>
<li>lockInit: 需要初始化这个锁，比如在channel的实现中，有如下的初始化代码：<code>lockInit(&amp;c.lock, lockRankHchan)</code>, 它将lock初始化(lockInit)时设置锁的等级(rank)。如果不明确去初始化一个锁,那么可以在调用lock自身的时候通过lockWithRank指定这个锁的等级。这个等级在启用<code>GOEXPERIMENT=staticlockranking</code>用来加强锁的静态分析。</li>
<li>lock: 加锁，在不同的操作系统下有不同的实现。如channel使用这个代码进行加锁：<code>lock(&amp;c.lock)</code></li>
<li>unlock: 解锁，在不同的操作系统下有不同的实现。如channel使用这个代码进行解锁：<code>unlock(&amp;c.lock)</code></li>
</ul>
<p>我在<a href="https://colobu.com/2020/12/06/mutex-in-go-runtime/" target="_blank" rel="external">Go运行时中的 Mutex</a>中详细介绍了它，这里就不再赘述了。</p>
<h3 id="rwmutex">rwmutex</h3>
<p>运行时中还实现了读写锁<a href="https://github.com/golang/go/blob/master/src/runtime/rwmutex.go" target="_blank" rel="external">rwmutex</a>。<br>这个读写锁完全是从<code>sync.RWMutex</code>中拷贝过来的，只是将<code>sync.RWMutex</code>中的<code>sync</code>包替换成了<code>runtime</code>包，因为<code>sync</code>包依赖了<code>runtime</code>包，所以不能直接使用。</p>
<p>你看它的数据结构定义和<code>sync.RWMutex</code>几乎是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> rwmutex <span class="keyword">struct</span> {</div><div class="line">	rLock      mutex    <span class="comment">// protects readers, readerPass, writer</span></div><div class="line">	readers    muintptr <span class="comment">// list of pending readers</span></div><div class="line">	readerPass <span class="typename">uint32</span>   <span class="comment">// number of pending readers to skip readers list</span></div><div class="line"></div><div class="line">	wLock  mutex    <span class="comment">// serializes writers</span></div><div class="line">	writer muintptr <span class="comment">// pending writer waiting for completing readers</span></div><div class="line"></div><div class="line">	readerCount atomic.Int32 <span class="comment">// number of pending readers</span></div><div class="line">	readerWait  atomic.Int32 <span class="comment">// number of departing readers</span></div><div class="line"></div><div class="line">	readRank  lockRank <span class="comment">// semantic lock rank for read locking</span></div><div class="line">	writeRank lockRank <span class="comment">// semantic lock rank for write locking</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>mutex</code>和<code>rwmutex</code>会直接阻塞<code>M</code>。</p>
<h3 id="gopark/goready">gopark/goready</h3>
<p>在其它编程语言中，会直接提供<code>park</code>和<code>unpark</code>的功能，比如rust,提供对并发单元的更底层的控制。</p>
<p><code>park</code>就是停止一会，很形象，就是暂时让并发单元阻塞，不再参与调度，直到<code>unpark</code>它，它才会重新参与调度。</p>
<p>Go运行时并没有直接提供<code>park</code>和<code>unpark</code>的功能，它提供了<code>gopark</code>和<code>goready</code>的功能，它们的实现在<a href="https://github.com/golang/go/blob/master/src/runtime/proc.go#L385" target="_blank" rel="external">runtime/proc.go</a>。</p>
<p><code>gopark</code>会将goroutine放到等待队列中，从调度器的运行队列中移出去，等待被唤醒。<br><code>goready</code>会将goroutine放到可运行队列中，加入到调度器的运行队列，等待被调度。</p>
<h3 id="note">note</h3>
<p><code>note</code>实现一次性的通知机制。</p>
<p><code>note</code>的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> note <span class="keyword">struct</span> {</div><div class="line">	key <span class="typename">uintptr</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以使用<code>notesleep</code>和<code>notewakeup</code>进行休眠和唤醒。</p>
<p>就像<code>mutex</code>一样，<code>notesleep</code>会阻塞<code>M</code>，<code>notewakeup</code>会唤醒一个<code>M</code>，并且不会重新调度<code>G</code>和<code>P</code>,而<code>notetsleepg</code>就像一个阻塞的系统调用一样，允许<code>P</code>选择另外一个<code>G</code>运行。<br><code>noteclear</code>用来重置<code>note</code></p>
<p>总结一下， 上面几种同步原语阻塞的角色如下：</p>
<table><tbody><tr><th></th><th colspan="3">阻塞角色</th></tr><br><tr><th>同步原语</th><th>G</th><th>M</th><th>P</th></tr><br><tr><td>mutex/rwmutex</td><td>Y</td><td>Y</td><td>Y</td></tr><br><tr><td>note</td><td>Y</td><td>Y</td><td>Y/N</td></tr><br><tr><td>park</td><td>Y</td><td>N</td><td>N</td></tr><br></tbody></table>

<h3 id="filelock">filelock</h3>
<p>&quot;filelock&quot;（文件锁）通常是指在计算机系统中使用的一种机制，用于确保对文件的独占性访问，以防止多个进程或线程同时修改文件而导致数据不一致或损坏。</p>
<p>一些应用程序经常利用文件锁，来控制只有一个实例在运行，在linux环境下非常常见，比如mysql等。</p>
<p>在不同的操作系统和编程语言中，文件锁的实现方式可能会有所不同。一般而言，文件锁可以分为两种主要类型：</p>
<ul>
<li>共享锁（Shared Lock）： 多个进程或线程可以同时获取共享锁，允许它们同时读取文件，但阻止其他进程或线程获取独占锁进行写操作。</li>
<li>独占锁（Exclusive Lock）： 只允许一个进程或线程获取独占锁，阻止其他进程或线程同时进行读或写操作。</li>
</ul>
<p>文件锁的代码在<a href="https://github.com/golang/go/tree/8db131082d08e497fd8e9383d0ff7715e1bef478/src/cmd/go/internal/lockedfile" target="_blank" rel="external">cmd/go/internal/lockedfile</a>中,我们以Linux为例，看看它的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> lockType <span class="typename">int16</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	readLock  lockType = syscall.LOCK_SH</div><div class="line">	writeLock lockType = syscall.LOCK_EX</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> lock(f File, lt lockType) (err error) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		err = syscall.Flock(<span class="typename">int</span>(f.Fd()), <span class="typename">int</span>(lt))</div><div class="line">		<span class="keyword">if</span> err != syscall.EINTR {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> &fs.PathError{</div><div class="line">			Op:   lt.String(),</div><div class="line">			Path: f.Name(),</div><div class="line">			Err:  err,</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> unlock(f File) error {</div><div class="line">	<span class="keyword">return</span> lock(f, syscall.LOCK_UN)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到它实际是调用系统调用<code>syscall.Flock</code>实现的。</p>
<p>这不属于运行时内定义的同步原语，但是它给我们提供了一个实现文件锁的思路，它甚至还封装了一个<code>Mutex</code>供我们使用。如果有类似的需求，我们可以参考它的实现。</p>
<h3 id="sema">sema</h3>
<p>不太清楚Go为啥不在运行时或者标准库sync中实现信号量，而是在扩展包中去实现，信号量可以说是一个非常广泛使用的同步原语了。</p>
<p>虽然没有在运行时中没有明确实现，但是运行时中的<a href="https://github.com/golang/go/blob/master/src/runtime/sema.go" target="_blank" rel="external">runtime/sema.go</a>提供了与信号量相近功能，而且<code>sync.Mutex</code>严重依赖它。</p>
<p>这个实现旨在提供一个可以在其他同步原语争用的情况下使用的睡眠和唤醒原语，因此，它的目标与Linux的futex相同，但语义要简单得多。<br>Go团队说你不要将这些视为信号量，而是将它们视为一种实现睡眠和唤醒的方式，以确保每个睡眠都与单个唤醒配对，<br>这是有历史原因，这些从贝尔实验室出来的大佬，对于先前他们在Plan 9中的一些想法一脉相承的继承下来，这个设计可以参见 Mullender 和 Cox 的<a href="https://swtch.com/semaphore.pdf" target="_blank" rel="external">Plan 9中的信号量</a>。</p>
<p>比如<code>sync.Mutex</code>睡眠和唤醒的函数其实就是这里实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire</span></div><div class="line"><span class="keyword">func</span> sync_runtime_Semacquire(addr *<span class="typename">uint32</span>) {</div><div class="line">	semacquire1(addr, <span class="constant">false</span>, semaBlockProfile,<span class="number"> 0</span>, waitReasonSemacquire)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname poll_runtime_Semacquire internal/poll.runtime_Semacquire</span></div><div class="line"><span class="keyword">func</span> poll_runtime_Semacquire(addr *<span class="typename">uint32</span>) {</div><div class="line">	semacquire1(addr, <span class="constant">false</span>, semaBlockProfile,<span class="number"> 0</span>, waitReasonSemacquire)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></div><div class="line"><span class="keyword">func</span> sync_runtime_Semrelease(addr *<span class="typename">uint32</span>, handoff <span class="typename">bool</span>, skipframes <span class="typename">int</span>) {</div><div class="line">	semrelease1(addr, handoff, skipframes)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex</span></div><div class="line"><span class="keyword">func</span> sync_runtime_SemacquireMutex(addr *<span class="typename">uint32</span>, lifo <span class="typename">bool</span>, skipframes <span class="typename">int</span>) {</div><div class="line">	semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes, waitReasonSyncMutexLock)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// RWMutex使用的一些函数</span></div><div class="line">...</div></pre></td></tr></table></figure>

<h3 id="atomic">atomic</h3>
<p><a href="https://github.com/golang/go/tree/master/src/runtime/internal/atomic" target="_blank" rel="external">atomic</a> 提供原子操作，独立于<code>sync/atomic</code>，仅供运行时使用。</p>
<p>在大多数平台上，编译器能够识别此包中定义的函数，并用平台特定的内部函数替换它们。在其他平台上，提供了通用的实现。<br>除非另有说明，在此包中定义的操作在处理它们所操作的值时对线程是有序一致的(sequentially consistent)。更具体地说，在一个线程上按特定顺序发生的操作，将始终被另一个线程观察到以完全相同的顺序发生。</p>
<p>因为和特定的CPU架构有关，它的实现针对不同的CPU架构，由不同的指令实现而成，而且基本使用汇编实现，比如AMD64下的Cas实现，使用了<code>LOCK</code> + <code>CMPXCHGL</code>指令：</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TEXT ·Cas(SB),<span class="preprocessor">NOSPLIT</span>,<span class="number">$0</span>-<span class="number">17</span></div><div class="line">	<span class="keyword">MOVQ</span>	<span class="preprocessor">ptr</span>+<span class="number">0</span>(FP), <span class="number">BX</span></div><div class="line">	MOVL	old+<span class="number">8</span>(FP), <span class="number">AX</span></div><div class="line">	MOVL	new+<span class="number">12</span>(FP), <span class="number">CX</span></div><div class="line">	<span class="keyword">LOCK</span></div><div class="line">	CMPXCHGL	<span class="number">CX</span>, <span class="number">0</span>(<span class="number">BX</span>)</div><div class="line">	SETEQ	<span class="keyword">ret</span>+<span class="number">16</span>(FP)</div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

<p>其实<code>sync/atomic</code>下的实现，也是调用这里的实现，否则维护两套代码就太麻烦了，而且可能出现不一致的现象。你看<code>sync/atomic/asm.s</code>:</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">...</span></div><div class="line">TEXT ·CompareAndSwapInt64(SB),NOSPLIT,$<span class="number">0</span></div><div class="line">	JMP	runtime∕internal∕atomic·Cas64(SB)</div><div class="line"></div><div class="line">TEXT ·CompareAndSwapUint64(SB),NOSPLIT,$<span class="number">0</span></div><div class="line">	JMP	runtime∕internal∕atomic·Cas64(SB)</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>它也是调用<code>untime∕internal∕atomic</code>下对应的函数。</p>
<h3 id="singleflight">singleflight</h3>
<p><code>singleflight</code>特别适合大并发情况下许多请求做同一件事情的场景，这个时候只处理一个请求就可以了，其它请求等待那一个请求的结果，这样对下游的压力大大减少，比如在读取cache的时候。</p>
<p>因为它在特定场景下很有用，Go的扩展库中也同样实现了它。</p>
<p>它没有定义在运行时中，而是定义在<a href="https://github.com/golang/go/tree/master/src/internal/singleflight" target="_blank" rel="external">internal/singleflight</a>中。</p>
<p>比如在包<code>net</code>中，我们查找一台主机的IP地址时，如果并发的请求，对资源是很大的浪费，这个时候我们只让一个请求处理就好了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Resolver <span class="keyword">struct</span> {</div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="comment">// lookupGroup merges LookupIPAddr calls together for lookups for the same</span></div><div class="line">	<span class="comment">// host. The lookupGroup key is the LookupIPAddr.host argument.</span></div><div class="line">	<span class="comment">// The return values are ([]IPAddr, error).</span></div><div class="line">	lookupGroup singleflight.Group</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (r *Resolver) lookupIPAddr(ctx context.Context, network, host <span class="typename">string</span>) ([]IPAddr, error) {</div><div class="line">	...</div><div class="line"></div><div class="line">	ch := r.getLookupGroup().DoChan(lookupKey, <span class="keyword">func</span>() (any, error) {</div><div class="line">		<span class="keyword">return</span> testHookLookupIP(lookupGroupCtx, resolverFunc, network, host)</div><div class="line">	})</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章我们来了解一下隐藏在Go运行时中的一些并发原语， 因为运行时是底座和包循环依赖等原因，运行时中很少使用标准库中的并发原语，它有自己的并发原语。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习C++20, 为Go的atomic类型插上一双翅膀]]></title>
    <link href="https://colobu.com/2024/01/06/extend-atomic/"/>
    <id>https://colobu.com/2024/01/06/extend-atomic/</id>
    <published>2024-01-06T03:58:52.000Z</published>
    <updated>2024-02-02T07:54:29.798Z</updated>
    <content type="html"><![CDATA[<p>如果我们将Go语言的并发原语弄的滚瓜烂熟，那么我们使用组合的方式，创造出更高级的并发原语，针对一些特定的并发场景，可以提供更高效的并发原语。</p>
<p>这篇文章就是就是利用atomic中的并发原语和条件变量，组合出类似C++ 20规范中atomic类型的wait/notify_one/notify_all的功能。</p>
<a id="more"></a>
<h2 id="C++20中的wait/notify_one/notify_all">C++20中的wait/notify_one/notify_all</h2>
<p><img src="cpp20-atomic-wait.png" alt=""></p>
<p>在<a href="https://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="external">C++ 20规范</a>中，为atomic类型增加了wait/notify_one/notify_all的功能，这样就可以实现类似Java中的wait/notify/notifyAll的功能.<br>这三个方法类似于Go中的Cond(条件变量)的Wait/Signal/Broadcast方法。</p>
<ul>
<li>wait: 阻塞当前线程，直到被通知且原子值被改变， 类似于Go中的Cond.Wait</li>
<li>notify_one: 通知至少一个阻塞在这个原子值上的线程， 类似于Go中的Cond.Signal</li>
<li>notify_all: 通知所有阻塞在这个原子值上的线程， 类似于Go中的Cond.Broadcast</li>
</ul>
<p>c++也有条件变量，但是和Go的Cond类似，条件变量需要和mutex一起使用，而atomic类型的wait/notify_one/notify_all不需要和mutex一起使用的。</p>
<p>注意wait这个函数，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> wait( T old, std::memory_order order =</div><div class="line">                      std::memory_order::seq_cst ) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div><div class="line"><span class="keyword">void</span> wait( T old, std::memory_order order =</div><div class="line">                      std::memory_order::seq_cst ) <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</div></pre></td></tr></table></figure>

<p>它的行为就像重复下面的操作一样：</p>
<ul>
<li>比较<code>this-&gt;load(order)</code>和<code>old</code>的值<ul>
<li>如果相等，就阻塞当前线程，直到被<code>notify_one()</code> 或者 <code>notify_all()</code>唤醒,或者线程被虚假的解锁</li>
<li>如果不相等，就返回</li>
</ul>
</li>
</ul>
<p>这个函数保证返回时原子值被改变了，不管它是被唤醒的还是使用底层技术以虚假方式取消阻塞。</p>
<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;chrono&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;future&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// 创建原子布尔变量，表示所有任务是否完成</span></div><div class="line">    std::atomic&lt;<span class="keyword">bool</span>&gt; all_tasks_completed{<span class="keyword">false</span>};</div><div class="line">    </div><div class="line">    <span class="comment">// 创建原子无符号整数，表示完成的任务数量</span></div><div class="line">    std::atomic&lt;<span class="keyword">unsigned</span>&gt; completion_count{};</div><div class="line">    </div><div class="line">    <span class="comment">// 创建包含16个std::future&lt;void&gt;对象的数组，用于存储异步任务的future</span></div><div class="line">    std::future&lt;<span class="keyword">void</span>&gt; task_futures[<span class="number">16</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建原子无符号整数，表示未完成的任务数量，初始值为16</span></div><div class="line">    std::atomic&lt;<span class="keyword">unsigned</span>&gt; outstanding_task_count{<span class="number">16</span>};</div><div class="line"></div><div class="line">    <span class="comment">// 生成多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">    <span class="keyword">for</span> (std::future&lt;<span class="keyword">void</span>&gt;& task_future : task_futures)</div><div class="line">        task_future = std::async([&]</div><div class="line">        {</div><div class="line">            <span class="comment">// 模拟真实工作...</span></div><div class="line">            std::this_thread::sleep_for(<span class="number">50</span>ms);</div><div class="line">            </div><div class="line">            <span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">            ++completion_count;</div><div class="line">            --outstanding_task_count;</div><div class="line"></div><div class="line">            <span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">            <span class="keyword">if</span> (outstanding_task_count.load() == <span class="number">0</span>)</div><div class="line">            {</div><div class="line">                all_tasks_completed = <span class="keyword">true</span>;</div><div class="line">                all_tasks_completed.notify_one();</div><div class="line">            }</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有任务完成</span></div><div class="line">    all_tasks_completed.wait(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 输出已完成任务的数量</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Tasks completed = "</span> &lt;&lt; completion_count.load() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个程序创建了16个异步任务，每个任务模拟了一些工作，然后通过原子操作更新已完成任务数量和未完成任务数量。主线程等待所有任务完成后输出已完成任务的数量。</p>
<p><strong>注意</strong>： 由于 <a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="external">ABA</a> 问题，原子值瞬态变化老到另一个值，然后返回到老的值，这个变化可能会被监听者锁遗漏，被Wait方法阻塞的线程无法解锁。</p>
<p>rust也有人提出了这样的需求:<a href="https://www.reddit.com/r/rust/comments/mrkqoy/is_there_a_wait_and_notify_for_atomics/" target="_blank" rel="external">Is there a wait() and notify() for atomics?</a></p>
<h2 id="使用场景">使用场景</h2>
<p>大部分场景下，我们使用C++的<code>std::condition_variable</code>或者Go语言中的<code>sync.Cond</code>就可以了。</p>
<p>比如使用Go语言中的条件变量，我们可以将上面的例子改造成下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> mu sync.Mutex</div><div class="line">	cond := sync.NewCond(&mu)</div><div class="line"></div><div class="line">	<span class="comment">// 任务是否已完成</span></div><div class="line">	<span class="keyword">var</span> completed atomic.Bool</div><div class="line">	<span class="comment">// 已完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> completionCount atomic.Int64</div><div class="line">	<span class="comment">// 未完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> outstandingTaskCount atomic.Int64</div><div class="line">	outstandingTaskCount.Store<span class="number">(16</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 启动多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 16</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="comment">// 模拟真实工作...</span></div><div class="line">			time.Sleep<span class="number">(50</span> * time.Millisecond)</div><div class="line"></div><div class="line">			<span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">			completionCount.Add<span class="number">(1</span>)</div><div class="line">			newValue := outstandingTaskCount.Add<span class="number">(-1</span>)</div><div class="line"></div><div class="line">			<span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">			<span class="keyword">if</span> newValue ==<span class="number"> 0</span> {</div><div class="line">				completed.Store(<span class="constant">true</span>)</div><div class="line">				cond.Signal()</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 等待所有任务完成</span></div><div class="line">	mu.Lock()</div><div class="line">	<span class="keyword">for</span> !completed.Load() {</div><div class="line">		cond.Wait()</div><div class="line">	}</div><div class="line">	mu.Unlock()</div><div class="line"></div><div class="line">	<span class="comment">// 输出已完成任务的数量</span></div><div class="line">	fmt.Printf(<span class="string">"Tasks completed = %v\n"</span>, completionCount.Load())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，我们使用<code>atmoic</code>的类型，加上<code>Cond</code> (包括<code>Mutex</code>)，可以实现变量更改了，并且达到某个条件时，通知等待者的功能。</p>
<p>针对这种使用<code>atmoic</code>的场景，我们是不是可以把<code>atomic</code> + <code>Cond</code>封装成一个新的类型，这样就可以更方便的使用了。</p>
<p>一旦封装起来，就像C++ 20这样做的一样，为atomic类型增加了一个通知的“翅膀”，在条件(配置)监控、消息等待、事件通知的场景中，可以更方便的使用。</p>
<p>接下来就是我做的一个尝试。</p>
<p>相关的代码可以在<a href="https://github.com/smallnest/exp/blob/master/sync/atomicx/type.go" target="_blank" rel="external">github.com/smallnest/exp/sync/atomicx</a>上找到。</p>
<h2 id="使用atomic-XXX和Cond,_实现wait/notify_one/notify_all">使用atomic.XXX和Cond, 实现wait/notify_one/notify_all</h2>
<p>不像Rust、Scala这样的语言，Go语言表达能力还不是那么丰富，所以我们无法在原有的atomic.XXX类型上增加wait/notify_one/notify_all的方法，只能创建一个新的类型，然后在这个类型上增加这三个方法。</p>
<p>我们还是沿用Go语言的<code>Wait/Signal/Broadcast</code>的命名方式，这样使用者就不会感到陌生,而不是C++的<code>wait/notify_one/notify_all</code>命名方式。</p>
<p>你可以看到，标准库atomic包下针对不同的基本类型，有对应的atomic.XXX类型，比如<code>atomic.Bool</code>、<code>atomic.Int32</code>、<code>atomic.Uint64</code>等等，所以我们也沿用这种方式，创建了<code>atomicx.Bool</code>、<code>atomicx.Int32</code>、<code>atomicx.Uint64</code>等等。</p>
<blockquote>
<p>你可以思考一下，为什么Go标准库不写成泛型的方式，，只提供一个<code>atomicx.Atomic[T]</code>类型，这样就可以避免创建这么多的类型了。</p>
</blockquote>
<p>我们以<code>atomicx.Int32</code>为例，看看它的实现。<br>这里我们采用组合的方式，将<code>atomic.Int32</code>和<code>sync.Cond</code>组合在一起，然后在这个组合类型上增加<code>Wait/Signal/Broadcast</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Int32 <span class="keyword">struct</span> {</div><div class="line">	atomic.Int32</div><div class="line"></div><div class="line">	mu      sync.Mutex</div><div class="line">	condvar *sync.Cond</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Wait blocks until the int32 is not equal to the given value.</span></div><div class="line"><span class="keyword">func</span> (ai *Int32) Wait() {</div><div class="line">	v := ai.Load()</div><div class="line"></div><div class="line">	ai.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> ai.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ai.condvar == <span class="constant">nil</span> {</div><div class="line">		ai.condvar = sync.NewCond(&ai.mu)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> ai.Load() == v {</div><div class="line">		ai.condvar.Wait()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Broadcast wakes all goroutines waiting on the int32.</span></div><div class="line"><span class="keyword">func</span> (ai *Int32) Broadcast() {</div><div class="line">	ai.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> ai.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ai.condvar == <span class="constant">nil</span> {</div><div class="line">		ai.condvar = sync.NewCond(&ai.mu)</div><div class="line">	}</div><div class="line"></div><div class="line">	ai.condvar.Broadcast()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Signal wakes one goroutine waiting on the int32.</span></div><div class="line"><span class="keyword">func</span> (ai *Int32) Signal() {</div><div class="line">	ai.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> ai.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ai.condvar == <span class="constant">nil</span> {</div><div class="line">		ai.condvar = sync.NewCond(&ai.mu)</div><div class="line">	}</div><div class="line"></div><div class="line">	ai.condvar.Signal()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们采用Go标准库sync包中的各种同步原语的风格，声明的时候默认零值，不需要<code>new(XXX)</code>方式显式创建，这样使用起来更方便。<br>这样就带来一个问题，怎么初始化<code>sync.Cond</code>字段呢？它是需要<code>NewCond</code> 函数创建的，传入一个<code>Locker</code>。<br>这里我们使用一个技巧，惰式初始化，需要使用它的时候，先请求锁，然后在检查它是否初始化了，如果没有初始化，就初始化它。</p>
<p><code>Wait</code>方法就是不断的<code>Load</code>这个原子值，和初始值进行比较，如果相等，就阻塞当前线程，直到被<code>Signal</code>或者<code>Broadcast</code>唤醒，当值不一致时，返回。</p>
<p><code>Signal</code>和<code>Broadcast</code>方法就是调用<code>sync.Cond</code>的<code>Signal</code>和<code>Broadcast</code>方法。</p>
<p>这是一个比较简单的通过组合的方式实现C++ 20中atomic类型的wait/notify_one/notify_all的功能的例子。<br>相信将Cond和Mutex的实现的代码拆解出来，再加上atomic.XXX的实现，你可能会实现性能更高的同样功能的同步原语，那样代码可能就变得复杂反而不如这种组合的方式更容易维护。</p>
<h2 id="使用atomicx改写上面的例子">使用atomicx改写上面的例子</h2>
<p>既然我们实现了一个封装类型<code>atomicx.Bool</code>,我们就用起来。</p>
<p>那么我们就可以把下面三个字段使用一个<code>var completed atomicx.Bool</code>来替换了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mu sync.Mutex</div><div class="line">cond := sync.NewCond(&mu)</div><div class="line"></div><div class="line"><span class="comment">// 任务是否已完成</span></div><div class="line"><span class="keyword">var</span> completed atomic.Bool</div></pre></td></tr></table></figure>

<p>如果条件满足，我们可以把<code>completed</code>设置为true,并且通知一个等待的goroutine。<br>等待的goroutine的代码也可以简化，只使用一条<code>completed.Wait()</code>就行了，不需要加锁和For循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/exp/sync/atomicx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 任务是否已完成</span></div><div class="line">	<span class="keyword">var</span> completed atomicx.Bool</div><div class="line">	<span class="comment">// 已完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> completionCount atomic.Int64</div><div class="line">	<span class="comment">// 未完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> outstandingTaskCount atomic.Int64</div><div class="line">	outstandingTaskCount.Store<span class="number">(16</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 启动多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 16</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="comment">// 模拟真实工作...</span></div><div class="line">			time.Sleep<span class="number">(50</span> * time.Millisecond)</div><div class="line"></div><div class="line">			<span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">			completionCount.Add<span class="number">(1</span>)</div><div class="line">			newValue := outstandingTaskCount.Add<span class="number">(-1</span>)</div><div class="line"></div><div class="line">			<span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">			<span class="keyword">if</span> newValue ==<span class="number"> 0</span> {</div><div class="line">				completed.Store(<span class="constant">true</span>)</div><div class="line">				completed.Signal()</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 等待所有任务完成</span></div><div class="line">	completed.Wait()</div><div class="line"></div><div class="line">	<span class="comment">// 输出已完成任务的数量</span></div><div class="line">	fmt.Printf(<span class="string">"Tasks completed = %v\n"</span>, completionCount.Load())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>completed.Wait()</code>一定要在<code>completed.Store(true)</code>之前，否则主goroutine可能永远被阻塞。</p>
<h2 id="解决_ABA_问题">解决 ABA 问题</h2>
<p>如果一个原子量快速的从A变成B，然后又快速的从B变成A，那么一个等待者可能会错过这个变化，从而导致它永远阻塞。<br>为了解决这个问题，我们可以在原子量的值的基础上增加一个版本号，每次变化的时候，版本号也会变化，这样等待者就可以检查版本号是否变化了，如果变化了，就不会阻塞。</p>
<p>下面就是定义了一个要原子操作的类型,每次做更改的时候:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Completed <span class="keyword">struct</span> {</div><div class="line">	Value   <span class="typename">bool</span></div><div class="line">	Version <span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样即使completed.Value的值从true变成false，但是Version的值也会变化，这样等待者就不会错过这个变化了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/exp/sync/atomicx"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Completed <span class="keyword">struct</span> {</div><div class="line">	Value   <span class="typename">bool</span></div><div class="line">	Version <span class="typename">int64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 任务是否已完成</span></div><div class="line">	<span class="keyword">var</span> completed atomicx.Pointer[Completed]</div><div class="line">	completed.Store(&Completed{Value: <span class="constant">false</span>, Version:<span class="number"> 0</span>})</div><div class="line"></div><div class="line">	<span class="comment">// 已完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> completionCount atomic.Int64</div><div class="line">	<span class="comment">// 未完成的任务的数量</span></div><div class="line">	<span class="keyword">var</span> outstandingTaskCount atomic.Int64</div><div class="line">	outstandingTaskCount.Store<span class="number">(16</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 启动多个任务，每个任务模拟不同耗时，然后递减未完成任务数量</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 16</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="comment">// 模拟真实工作...</span></div><div class="line">			time.Sleep<span class="number">(50</span> * time.Millisecond)</div><div class="line"></div><div class="line">			<span class="comment">// 增加已完成任务数量，递减未完成任务数量</span></div><div class="line">			completionCount.Add<span class="number">(1</span>)</div><div class="line">			newValue := outstandingTaskCount.Add<span class="number">(-1</span>)</div><div class="line"></div><div class="line">			<span class="comment">// 当未完成任务数量减至零时，通知等待者（在本例中为主线程）</span></div><div class="line">			<span class="keyword">if</span> newValue ==<span class="number"> 0</span> {</div><div class="line">                <span class="comment">// 如果不能确保Version的并发安全修改，下面的代码需要修改成CompareAndSwap的spin的方式</span></div><div class="line">				completed.Store(&Completed{Value: <span class="constant">true</span>, Version: completed.Load().Version +<span class="number"> 1</span>})</div><div class="line">				completed.Store(&Completed{Value: <span class="constant">false</span>, Version: completed.Load().Version +<span class="number"> 1</span>}) <span class="comment">// 伪造一个操作，把值又设置回false</span></div><div class="line">				completed.Signal()</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 等待所有任务完成</span></div><div class="line">	completed.Wait()</div><div class="line"></div><div class="line">	<span class="comment">// 输出已完成任务的数量</span></div><div class="line">	fmt.Printf(<span class="string">"Tasks completed = %+v, %+v\n"</span>, completionCount.Load(), completed.Load())</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>如果我们将Go语言的并发原语弄的滚瓜烂熟，那么我们使用组合的方式，创造出更高级的并发原语，针对一些特定的并发场景，可以提供更高效的并发原语。</p>
<p>这篇文章就是就是利用atomic中的并发原语和条件变量，组合出类似C++ 20规范中atomic类型的wait/notify_one/notify_all的功能。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++中的同步原语]]></title>
    <link href="https://colobu.com/2023/12/26/synchronization-primitives-in-c/"/>
    <id>https://colobu.com/2023/12/26/synchronization-primitives-in-c/</id>
    <published>2023-12-26T14:59:31.000Z</published>
    <updated>2024-02-02T07:54:29.801Z</updated>
    <content type="html"><![CDATA[<p>C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。</p>
<a id="more"></a>
<h2 id="std::thread">std::thread</h2>
<p><code>std::thread</code>是在C++11中引入的，它表示一个可执行的线程。线程允许多个函数并发执行。</p>
<p>线程在关联的线程对象构造完成后立即开始执行（受操作系统调度延迟影响），从作为构造函数参数提供的顶级函数开始。顶级函数的返回值会被忽略，如果它通过抛出异常终止，std::terminate 会被调用。顶级函数可以通过 std::promise 或通过修改共享变量（可能需要同步，参见 std::mutex 和 std::atomic）向调用者传达其返回值或异常。</p>
<p>std::thread 对象也可能处于不表示任何线程的状态（在默认构造、移动构造、分离或加入之后），而且执行线程可能不与任何线程对象关联（在分离之后）。</p>
<p>没有两个 std::thread 对象可以表示同一个执行线程；std::thread 不可复制构造或复制赋值，尽管它是可移动构造和可移动赋值的。</p>
<p>你需要手动管理线程的生命周期，包括启动和加入（或分离）线程。如果你忘记在一个<code>std::thread</code>对象销毁之前加入（<code>join</code>）或分离（<code>detach</code>）它的线程，程序将会终止（因为<code>std::thread</code>的析构函数会调用<code>std::terminate</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> threadFunction() {</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from thread!\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::thread t(threadFunction);</div><div class="line">    <span class="comment">// 必须在t销毁之前对其调用join或detach</span></div><div class="line">    t.join(); <span class="comment">// 等待线程结束</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="std::jthread">std::jthread</h2>
<p><code>std::jthread</code>是在C++20中引入的，它提供了一些改进和附加功能，相比于<code>std::thread</code>，使得线程管理变得更加容易和安全。</p>
<p>它在std::thread的基础上增加了自动的线程加入功能。std::jthread的一个关键特性是它的析构函数会自动请求线程停止（如果支持的话）并等待线程完成，从而减少了程序员需要手动管理线程生命周期的需求。</p>
<p>此外，std::jthread支持协作式中断，它提供了一种机制，使得线程可以被请求停止执行。这是通过传递一个std::stop_token来实现的，线程函数可以定期检查这个stop_token来决定是否应该停止执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> threadFunction(std::stop_token stoken) {</div><div class="line">    <span class="keyword">while</span> (!stoken.stop_requested()) { <span class="comment">// 检查是否请求停止线程</span></div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from jthread!\n"</span>;</div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    }</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Stopping as requested.\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::jthread jt(threadFunction);</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">3</span>));</div><div class="line">    <span class="comment">// 不需要手动调用join，析构函数会自动处理</span></div><div class="line">    <span class="comment">// jt.request_stop(); 如果需要提前请求停止线程，则调用这个</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的例子中，<code>std::jthread</code>的析构函数会自动调用<code>request_stop</code>来请求线程函数停止，然后等待线程完成。这使得使用<code>std::jthread</code>比<code>std::thread</code>更加安全和方便，因为它消除了忘记加入或分离线程时可能出现的问题。</p>
<p>总结来说，<code>std::jthread</code>在<code>std::thread</code>的基础上提供了自动加入和协作式中断的功能，从而简化了线程的管理。如果你使用的是C++20或更高版本，优先考虑使用<code>std::jthread</code>。</p>
<h2 id="atomic">atomic</h2>
<h3 id="std::atomic">std::atomic</h3>
<p><code>std::atomic</code> 是一个模板类，提供了一种机制来安全地在多线程环境中操作共享数据，而不需要使用互斥锁。<code>std::atomic</code> 类型保证了基本的原子操作，比如读取、写入、递增和递减等，都是原子性的，也就是说在一个操作执行完毕前，不会被其他线程打断。</p>
<p>原子性意味着当一个线程正在执行原子操作时，没有其他线程可以同时执行任何其他对同一数据的原子操作。此外，C++11 引入的内存模型定义了原子操作的内存顺序（memory order），这是一个非常复杂的主题，决定了在不同线程中操作之间的可见性和排序。我在《并发编程顶峰对决： Go vs Rust》讲了Rust的内存顺序模型，也提到了Rust的内存顺序模型和C++的内存顺序模型，这里就不赘述了,总之内存序包含下面几种类型，你应该正确且清晰的使用它们：</p>
<ul>
<li>std::memory_order_relaxed</li>
<li>std:: memory_order_consume</li>
<li>std::memory_order_acquire</li>
<li>std::memory_order_release</li>
<li>std::memory_order_acq_rel</li>
<li>std::memory_order_seq_cst</li>
</ul>
<p><code>std::atomic</code> 类型的对象可以通过调用成员函数<code>load</code>和<code>store</code>来读取和写入，也可以通过<code>operator++</code>和<code>operator--</code>来递增和递减。<code>std::atomic</code> 类型的对象还可以通过调用成员函数<code>exchange</code>来交换值，通过调用成员函数<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>来比较和交换值。</p>
<p><code>wait</code>、<code>notify</code>和<code>notify_all</code>函数可以用来等待和通知其他线程，这些函数在C++20中引入。有点像条件变量。</p>
<p>通过<code>std::atomic</code>类模板，我们可以创建原子类型的对象，比如<code>std::atomic&lt;int&gt;</code>，<code>std::atomic&lt;bool&gt;</code>，<code>std::atomic&lt;std::string&gt;</code>等等。<code>std::atomic</code>类模板还提供了一些特化版本，比如<code>std::atomic_flag</code>，<code>std::atomic_bool</code>，<code>std::atomic_int</code>，<code>std::atomic_uint</code>，<code>std::atomic_llong</code>等等。</p>
<p>下面是一个计数器的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::atomic&lt;<span class="keyword">int</span>&gt; counter(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> increment() {</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) {</div><div class="line">        counter.fetch_add(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment));</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& t : threads) {</div><div class="line">        t.join();</div><div class="line">    }</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Counter: "</span> &lt;&lt; counter.load() &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，10个线程并发地递增一个std::atomic<int>计数器。由于counter是原子类型，所以每个线程的修改都是原子操作，不会相互干扰。最终的计数器值应该是100000。</int></p>
<h3 id="std::atomic_flag">std::atomic_flag</h3>
<p><code>std::atomic_flag</code> 是 C++11 中引入的原子类型，它是最简单的原子类型，提供了一个布尔标志，可以用来进行简单的锁定操作。由于其简单性，<code>std::atomic_flag</code> 通常可以实现为一个非常高效的原子类型，因此它在实现自旋锁等低级同步原语时非常有用。</p>
<p><code>std::atomic_flag</code> 保证是 <code>lock-free</code> 的，即不会引起调用线程的阻塞。这是 <code>std::atomic_flag</code> 相对于其他原子类型的一个独特优点，因为其他原子类型在一些平台上可能不是 <code>lock-free</code> 的。</p>
<p>std::atomic_flag 提供以下几个主要操作：</p>
<ul>
<li>clear(): 将标志设置为 false。</li>
<li>test_and_set(): 测试标志的当前值，然后将其设置为 true。这个操作是原子的，即测试和设置是一个不可分割的步骤。</li>
<li>test(): C++20 新增的操作，测试标志的当前值而不修改它。</li>
<li>wait(): C++20 新增的操作，如果标志为 true，则阻塞调用线程。</li>
<li>notify_one(): C++20 新增的操作，通知等待线程中的一个线程。</li>
<li>notify_all(): C++20 新增的操作，通知等待线程中的所有线程。</li>
</ul>
<p>下面这个例子是检查 atomic_flag 是否已被设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"></div><div class="line">std::atomic_flag flag = ATOMIC_FLAG_INIT;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="comment">// 设置标志</span></div><div class="line">    flag.test_and_set();</div><div class="line">    </div><div class="line">    <span class="comment">// 检查标志是否已经设置</span></div><div class="line">    <span class="keyword">if</span> (flag.test()) {</div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Flag is set.\n"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 清除标志</span></div><div class="line">    flag.clear();</div><div class="line">    </div><div class="line">    <span class="comment">// 再次检查标志</span></div><div class="line">    <span class="keyword">if</span> (!flag.test()) {</div><div class="line">        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Flag is cleared.\n"</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="std::atomic_ref">std::atomic_ref</h3>
<p><code>std::atomic_ref</code> 是 C++20 引入的一个模板类，它提供了对非原子类型的原子操作。这意味着你可以将 <code>std::atomic_ref</code> 对象绑定到非原子类型的引用上，并执行原子操作，而无需将该类型本身声明为原子类型。这在你需要对现有数据结构中的某个成员进行原子操作，而不想更改数据结构定义时非常有用。</p>
<p><code>std::atomic_ref</code> 的特性</p>
<ul>
<li><code>std::atomic_ref</code> 通过引用传递给它的对象，并提供原子访问。</li>
<li>它对绑定的对象执行原子操作，如加载(load)、存储(store)、增加(fetch_add)、减少(fetch_sub)等。</li>
<li><code>std::atomic_ref</code> 不拥有它所绑定的对象，故该对象的生命周期必须超过 std::atomic_ref 对象的生命周期。</li>
<li>你可以在多个 <code>std::atomic_ref</code> 实例之间共享同一个对象，但是要保证这些实例不会同时访问该对象。</li>
</ul>
<p>std::atomic_ref 的主要成员函数</p>
<ul>
<li>store(T desired, std::memory_order order = std::memory_order_seq_cst): 将 desired 值原子地存储到引用的对象中。</li>
<li>T load(std::memory_order order = std::memory_order_seq_cst) const: 原子地加载并返回引用的对象的值。</li>
<li>T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst): 原子地将 arg 添加到引用的对象的当前值，并返回之前的值。</li>
<li>T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst): 原子地从引用的对象的当前值中减去 arg，并返回之前的值。</li>
<li>bool compare_exchange_weak(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst): 原子地比较引用的对象的值与 expected，如果相同，则将该对象的值设置为 desired。</li>
<li>bool compare_exchange_strong(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst): 类似于 compare_exchange_weak，但具有更强的保证，防止假失败。</li>
<li>wait(): C++20 新增的操作，如果标志为 true，则阻塞调用线程。</li>
<li>notify_one(): C++20 新增的操作，通知等待线程中的一个线程。</li>
<li>notify_all(): C++20 新增的操作，通知等待线程中的所有线程。</li>
</ul>
<p>以下是一个使用 std::atomic_ref 的简单示例，演示了如何对一个共享的 int 变量执行原子操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="keyword">int</span> shared_value = <span class="number">0</span>;</div><div class="line">    std::atomic_ref&lt;<span class="keyword">int</span>&gt; atomic_ref(shared_value);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> incrementer = [&atomic_ref]() {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">            atomic_ref.fetch_add(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子地增加 shared_value 的值</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    <span class="comment">// 创建 10 个线程，每个线程都增加 shared_value 的值</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.emplace_back(incrementer);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final value of shared_value: "</span> &lt;&lt; shared_value &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// 正确的输出应该是 1000</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个普通的 int 类型变量 <code>shared_value</code> 和一个 <code>std::atomic_ref&lt;int&gt;</code> 实例 <code>atomic_ref</code>，后者引用了前者。然后我们启动了 10 个线程，每个线程都通过 <code>atomic_ref</code> 原子地对 <code>shared_value</code> 执行 100 次增加操作。在所有线程完成后，我们期望 <code>shared_value</code> 的最终值为 1000。</p>
<h2 id="std::mutex">std::mutex</h2>
<p><code>std::mutex</code> 用于保护共享数据，避免多个线程同时访问导致的数据竞争和不一致性。当多个线程尝试同时修改同一数据时，<code>std::mutex</code> 提供了一种机制来确保只有一个线程能够访问数据，其余试图访问该数据的线程将被阻塞，直到拥有互斥锁的线程释放锁为止。</p>
<p><code>std::mutex</code> 的主要操作</p>
<ul>
<li>lock(): 阻塞当前线程，直到能够锁定该互斥锁。如果互斥锁已被其他线程锁定，则当前线程将等待（阻塞），直到互斥锁被解锁。</li>
<li>unlock(): 解锁互斥锁，允许其他正在等待的线程能够尝试锁定互斥锁。</li>
<li>try_lock(): 尝试锁定互斥锁，如果互斥锁当前未被锁定，则锁定它并立即返回 true；如果已被其他线程锁定，则不会阻塞当前线程，立即返回 false。</li>
</ul>
<p>使用 <code>std::mutex</code> 保护共享数据的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> increment_counter() {</div><div class="line">    mtx.lock(); <span class="comment">// 获取锁</span></div><div class="line">    ++counter; <span class="comment">// 修改共享数据</span></div><div class="line">    mtx.unlock(); <span class="comment">// 释放锁</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发环境</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment_counter));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : threads) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value: "</span> &lt;&lt; counter &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，100个线程尝试并发地增加一个共享计数器。没有互斥锁的情况下，多个线程可能同时读写同一内存位置，导致计数器的值不正确。通过使用 std::mutex，我们确保了每次只有一个线程能够增加计数器，从而保证了最终结果的正确性。</p>
<p>可以使用<code>std::lock_guard</code> 管理 <code>std::mutex</code> 的锁定和解锁,类似Rust:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> increment_counter() {</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mtx); <span class="comment">// 创建 lock_guard 对象时自动获取锁，并在作用域结束时自动释放锁</span></div><div class="line">    ++counter; <span class="comment">// 修改共享数据</span></div><div class="line">    <span class="comment">// lock_guard 对象析构时自动调用 unlock</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发环境</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</div><div class="line">        threads.push_back(std::thread(increment_counter));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : threads) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final counter value: "</span> &lt;&lt; counter &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了基本的 <code>std::mutex</code>，还提供了几种其他类型的锁，用于满足不同的同步需求。以下是一些常见的锁类型：</p>
<ul>
<li>std::recursive_mutex<br><code>std::recursive_mutex</code> 是一种特殊类型的互斥锁，它允许同一个线程多次对同一个互斥锁加锁（即递归锁定）。每次对 <code>std::recursive_mutex</code> 的成功锁定都必须由相应数量的解锁操作与之匹配。这适用于递归函数调用，其中函数可能会直接或间接地多次请求同一互斥锁。</li>
<li>std::timed_mutex<br><code>std::timed_mutex</code> 是互斥锁的一个扩展，它提供了尝试锁定一段时间的功能。如果锁在指定时间内未被获取，则尝试锁定操作失败并返回。它提供了两个额外的成员函数：<code>try_lock_for()</code> 和 <code>try_lock_until()</code>，分别用于指定等待锁定的时间长度和绝对时间点。</li>
<li>std::recursive_timed_mutex<br><code>std::recursive_timed_mutex</code> 结合了 <code>std::recursive_mutex</code> 和 <code>std::timed_mutex</code> 的功能，允许一个线程对同一个互斥锁进行多次锁定，并提供了基于时间的锁定尝试。</li>
<li>std::shared_mutex<br><code>std::shared_mutex</code> 是一个读写锁，它允许多个线程同时读取共享数据（共享锁定），但一次只允许一个线程写入（独占锁定）。它提供了 <code>lock_shared()</code> 和 <code>unlock_shared()</code> 来管理共享锁定，以及 <code>lock()</code> 和 <code>unlock()</code> 来管理独占锁定。</li>
<li>std::shared_timed_mutex<br><code>std::shared_timed_mutex</code> 结合了 <code>std::shared_mutex</code> 和 <code>std::timed_mutex</code> 的特性，提供了时间限制的读写锁。它允许多个线程在一段时间内尝试以共享或独占方式锁定互斥锁。</li>
</ul>
<p>还有一些辅助管理mutex的类：</p>
<ul>
<li><p>std::lock_guard<br><code>std::lock_guard</code> 是一个作用域锁，当创建它的对象时自动获取互斥锁，并在该对象的生命周期结束时自动释放互斥锁。<code>std::lock_guard</code> 不支持显式的解锁操作或条件等待。</p>
</li>
<li><p>std::unique_lock<br><code>std::unique_lock</code> 是一个灵活的作用域锁，它提供了比 <code>std::lock_guard</code> 更多的功能，包括延迟锁定、时间限制的锁定尝试、递归锁定以及条件变量的支持。<code>std::unique_lock</code> 对象可以在其生命周期中多次锁定和解锁关联的互斥锁。</p>
</li>
<li><p>std::scoped_lock (C++17)<br><code>std::scoped_lock</code> 是 C++17 引入的一个作用域锁，它可以锁定一个或多个互斥锁，而无需担心死锁。它在内部使用了一个死锁避免算法（如锁的排序获取），确保在多个互斥锁的情况下不会发生死锁。</p>
</li>
</ul>
<p>一个读写锁的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;shared_mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::shared_mutex rw_mutex;</div><div class="line"><span class="keyword">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> reader(<span class="keyword">int</span> id) {</div><div class="line">    std::shared_lock&lt;std::shared_mutex&gt; lock(rw_mutex); <span class="comment">// 获取共享锁</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reader #"</span> &lt;&lt; id &lt;&lt; <span class="string">" read value: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> writer(<span class="keyword">int</span> id) {</div><div class="line">    std::unique_lock&lt;std::shared_mutex&gt; lock(rw_mutex); <span class="comment">// 获取独占锁</span></div><div class="line">    ++shared_data;</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Writer #"</span> &lt;&lt; id &lt;&lt; <span class="string">" wrote value: "</span> &lt;&lt; shared_data &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> readers;</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> writers;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建读者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</div><div class="line">        readers.push_back(std::thread(reader, i));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 创建写者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        writers.push_back(std::thread(writer, i));</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待读者线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : readers) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待写者线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& th : writers) {</div><div class="line">        th.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::shared_mutex</code> 被用作一个读写锁来保护共享数据。读者线程使用 <code>std::shared_lock</code> 获取共享锁，这允许多个读者线程同时读取数据。写者线程使用 <code>std::unique_lock</code> 获取独占锁，这确保了在写入数据时只有一个写者线程可以访问数据。</p>
<h2 id="std::condition_variable">std::condition_variable</h2>
<p><code>std::condition_variable</code> 用于在多线程程序中进行线程间的通知和等待操作。它允许一个或多个线程在某些条件成立之前挂起（等待），直到另一个线程通知它们条件已经满足。<br><code>std::condition_variable</code> 通常与 <code>std::mutex</code>（或 <code>std::unique_lock</code>）一起使用，以保护共享数据并提供安全的同步机制。</p>
<p>主要方法：</p>
<ul>
<li>wait(): 阻塞当前线程，直到其他线程调用 notify_one() 或 notify_all()。在等待期间，互斥锁会被释放，以允许其他线程修改共享数据。当条件变量被通知时，线程会被唤醒，并在返回前重新获取互斥锁。</li>
<li>notify_one(): 唤醒一个等待的线程。如果没有线程在等待，则调用没有任何效果。</li>
<li>notify_all(): 唤醒所有等待的线程。如果没有线程在等待，则调用没有任何效果。</li>
<li>wait_for(): 阻塞当前线程一段时间，或直到被通知。如果在指定的时间段内没有接收到通知，线程会自动唤醒。</li>
<li>wait_until(): 阻塞当前线程直到指定的时间点，或直到被通知。如果到达指定的时间点时没有接收到通知，线程会自动唤醒。</li>
</ul>
<p>下面是一个使用 <code>std::condition_variable</code> 的简单示例，演示了生产者-消费者问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;condition_variable&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></div><div class="line"></div><div class="line">std::mutex mtx; <span class="comment">// 用于同步的互斥锁</span></div><div class="line">std::condition_variable cv; <span class="comment">// 条件变量</span></div><div class="line">std::<span class="stl_container"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span> product_queue; <span class="comment">// 共享数据队列</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> producer(<span class="keyword">int</span> id) {</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx); <span class="comment">// 加锁</span></div><div class="line">    product_queue.push(id); <span class="comment">// 生产产品</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Producer "</span> &lt;&lt; id &lt;&lt; <span class="string">" produced a product."</span> &lt;&lt; std::endl;</div><div class="line">    lck.unlock(); <span class="comment">// 解锁</span></div><div class="line">    cv.notify_one(); <span class="comment">// 通知一个消费者</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> consumer() {</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx); <span class="comment">// 加锁</span></div><div class="line">    <span class="keyword">while</span> (product_queue.empty()) { <span class="comment">// 如果队列为空，则等待</span></div><div class="line">        cv.wait(lck); <span class="comment">// 在这里，互斥锁会被释放</span></div><div class="line">    }</div><div class="line">    <span class="keyword">int</span> product = product_queue.front();</div><div class="line">    product_queue.pop();</div><div class="line">    lck.unlock(); <span class="comment">// 解锁</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Consumer consumed product "</span> &lt;&lt; product &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::thread consumers[<span class="number">2</span>];</div><div class="line">    std::thread producers[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 创建消费者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        consumers[i] = std::thread(consumer);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 创建生产者线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        producers[i] = std::thread(producer, i+<span class="number">1</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待生产者线程结束</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        producers[i].join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待消费者线程结束</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) {</div><div class="line">        consumers[i].join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，生产者线程生产产品并将其放入队列中，然后通过调用 cv.notify_one() 唤醒一个等待的消费者线程。消费者线程在队列为空时调用 cv.wait() 进入等待状态，等待生产者的通知。当生产者生产了一个产品后，消费者线程被唤醒，从队列中取出产品并消费它。</p>
<p><strong>注意事项</strong>: (和Go的Cond类似)</p>
<ul>
<li>使用 <code>std::condition_variable</code> 时，应该总是和一个互斥锁一起使用，以避免竞争条件。</li>
<li>在调用 <code>wait()</code>、<code>wait_for()</code> 或 <code>wait_until()</code> 时，互斥锁必须已被锁定。这些函数会在开始等待时自动释放锁，并在线程被唤醒时重新获取锁。</li>
<li><code>std::condition_variable</code> 的 <code>wait()</code> 函数可能会出现&quot;虚假唤醒&quot;，即在没有收到通知的情况下线程可能被唤醒。因此，通常需要在一个循环中使用 <code>wait()</code>，并检查等待条件是否满足。</li>
<li><code>notify_one()</code> 和 <code>notify_all()</code> 不需要持有互斥锁，但通常会在更新共享数据并持有互斥锁后调用它们。</li>
<li><code>std::condition_variable</code> 只能与 <code>std::unique_lock&lt;std::mutex&gt;</code> 一起使用，不能直接与 <code>std::mutex</code> 一起使用。如果你需要和 <code>std::mutex</code> 一起使用条件变量，请使用 <code>std::condition_variable_any</code>。</li>
</ul>
<h2 id="semaphore">semaphore</h2>
<p>在 C++20 之前，标准库没有提供信号量（semaphore）的实现，但是在 C++20 中引入了两种类型的信号量：<code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code>。</p>
<h3 id="std::counting_semaphore">std::counting_semaphore</h3>
<p><code>std::counting_semaphore</code> 是一种通用的同步原语，用于控制对<strong>有限数量资源</strong>的访问。它维护一个内部的计数器，表示可用资源的数量。计数器的值可以增加（通过 <code>release()</code> 函数）或减少（通过 <code>acquire()</code> 函数）。</p>
<p>信号量的主要操作包括：</p>
<ul>
<li>acquire(): 减少信号量的计数器值。如果计数器的当前值大于零，调用 acquire() 将减少计数器的值，并允许线程继续执行。如果计数器值为零，则调用线程将阻塞，直到其他线程释放资源。</li>
<li>release(): 增加信号量的计数器值。调用 release() 会将计数器的值增加一定数量（默认为1），并可能唤醒正在等待的线程。</li>
<li>try_acquire(): 尝试获取资源，如果信号量的计数器值大于零，则减少计数器并返回 true；如果计数器值为零，则不阻塞，直接返回 false。</li>
</ul>
<p><code>std::counting_semaphore</code> 的计数器值可以大于1，因此它可以用于多个资源的同步。例如，可以用它来实现连接池，限制同时运行的线程数量，等等。</p>
<h3 id="std::binary_semaphore">std::binary_semaphore</h3>
<p><code>std::binary_semaphore</code> 是 <code>std::counting_semaphore</code> 的一个特例，其计数器值限定为最多1。这意味着它可以被看作是一个可以阻塞线程的布尔标志。</p>
<p><code>std::binary_semaphore</code> 的行为类似于互斥锁（<code>mutex</code>），但与互斥锁不同的是，<code>std::binary_semaphore</code> 不要求同一个线程执行 <code>acquire()</code> 和 <code>release()</code>。这使得信号量可以用于线程间的通知和同步，而不仅仅是互斥。</p>
<p>下面是一个使用<code>std::counting_semaphore</code>的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;semaphore&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 初始化信号量，允许同时有3个线程访问资源。</span></div><div class="line">std::counting_semaphore&lt;<span class="number">3</span>&gt; sem(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> access_resource(<span class="keyword">int</span> thread_id) {</div><div class="line">    <span class="comment">// 请求访问资源</span></div><div class="line">    sem.acquire();</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">" is accessing the resource."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 模拟资源访问</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    </div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; thread_id &lt;&lt; <span class="string">" is releasing the resource."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// 释放资源</span></div><div class="line">    sem.release();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建多个线程，模拟并发资源访问</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</div><div class="line">        threads.emplace_back(access_resource, i);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="std::barrier">std::barrier</h2>
<p><code>std::barrier</code> 也是 C++20 引入的一个同步原语，它允许一组线程相互等待，直到所有线程都达到某个同步点（称为屏障点或栅栏点），然后再继续执行。<code>std::barrier</code> 可以用于协调并行算法中的线程，确保所有线程都完成了某个阶段的工作，然后再一起进入下一个阶段。</p>
<p>std::barrier 的主要特性</p>
<ul>
<li>std::barrier 可以配置一个可调用对象（通常是一个函数或 lambda 表达式），当所有线程都到达屏障点时，这个可调用对象会被执行。这可以用于在所有线程继续之前进行一些初始化或清理工作。</li>
<li>std::barrier 是可重用的，这意味着一旦所有线程通过了屏障点，它可以被用于下一个同步点。</li>
<li>std::barrier 的构造函数接受一个表示线程总数的参数，以及一个可选的可调用对象。</li>
</ul>
<p>std::barrier 的主要成员函数</p>
<ul>
<li>arrive_and_wait(): 该函数使调用线程到达屏障点并等待其他线程。当最后一个线程调用 arrive_and_wait() 时，所有线程都被释放，并且可调用对象（如果有）被执行。</li>
<li>arrive(): 该函数使调用线程到达屏障点但不等待。它可以用于线程通知已到达屏障点，但随后立即继续执行其他任务。</li>
<li>wait(): 该函数使已到达屏障点的线程等待其他线程。它通常与 arrive() 配合使用。</li>
<li>arrive_and_drop(): 该函数使调用线程到达屏障点并永久退出屏障。它将屏障点的期望线程总数减少一个。这对于动态线程管理很有用。</li>
</ul>
<p>以下是一个使用 std::barrier 的简单示例，演示了如何同步多个线程在屏障点上相互等待:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;barrier&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 创建一个屏障，用于同步三个线程</span></div><div class="line">std::barrier sync_point(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> work(<span class="keyword">int</span> id) {</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is doing some work before the barrier."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行前半部分的工作</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 等待屏障点，等待其他线程</span></div><div class="line">    sync_point.arrive_and_wait();</div><div class="line"></div><div class="line">    <span class="comment">// 当所有线程都达到屏障点时，继续执行后半部分的工作</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is doing some work after the barrier."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line"></div><div class="line">    <span class="comment">// 启动三个工作线程</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</div><div class="line">        threads.emplace_back(work, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::barrier</code> 对象 <code>sync_point</code>，它配置为同步三个线程。每个线程都执行一些工作，然后调用 <code>sync_point.arrive_and_wait()</code> 来等待其他线程。一旦所有三个线程都到达屏障点（即都调用了 <code>arrive_and_wait()</code>），它们将一起继续执行后面的代码。</p>
<p><code>std::barrier</code> 是一种强大的同步工具，特别适用于需要分阶段执行的并行算法，确保在算法的每个阶段开始前，所有线程都已完成前一个阶段的工作。这有助于避免竞争条件，确保算法的正确执行。</p>
<h2 id="std::latch">std::latch</h2>
<p><code>std::latch</code> 也是 C++20 引入的一个同步原语，它使一组线程可以等待直到一个给定数量的操作完成。它是一个一次性的屏障，一旦触发打开，就不能再重置或再次使用。<code>std::latch</code> 用于在多个线程之间同步操作，允许一个线程等待一个或多个线程完成某些操作。类似Java中的CountDownLatch。</p>
<p>std::latch 的主要特性</p>
<ul>
<li>std::latch 在构造时接受一个计数值，这个值表示需要等待的操作数。</li>
<li>当线程完成它的操作时，它调用 count_down() 方法来减少 std::latch 的计数器。</li>
<li>线程可以调用 wait() 方法来阻塞，直到 std::latch 的计数器达到零。</li>
<li>std::latch 可以有多个线程同时等待计数器达到零。</li>
<li>一旦 std::latch 的计数器达到零，所有调用 wait() 的线程都将被释放，之后的任何 wait() 调用都会立即返回。</li>
<li>std::latch 提供了一个 try_wait() 方法，该方法立即返回并告知调用者 std::latch 是否已经触发（计数器是否已经为零）。</li>
</ul>
<p>std::latch 的主要成员函数</p>
<ul>
<li>count_down(): 减少 std::latch 的计数器。如果计数器达到零，所有等待的线程都将被释放。</li>
<li>wait(): 阻塞调用线程，直到 std::latch 的计数器为零。</li>
<li>try_wait(): 检查 std::latch 的计数器是否为零，不阻塞调用线程。</li>
</ul>
<p>以下是一个使用 std::latch 的简单示例，演示了如何同步多个线程完成初始化操作后，主线程才继续执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;latch&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 创建一个 std::latch 对象，用于等待三个线程完成初始化</span></div><div class="line">std::latch initialization_latch(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> initialize_system(<span class="keyword">int</span> id) {</div><div class="line">    <span class="comment">// 模拟一些初始化工作</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; id &lt;&lt; <span class="string">" is initializing."</span> &lt;&lt; std::endl;</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; id &lt;&lt; <span class="string">" initialization complete."</span> &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    <span class="comment">// 完成工作后，调用 count_down() 减少 latch 的计数</span></div><div class="line">    initialization_latch.count_down();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;</span> threads;</div><div class="line"></div><div class="line">    <span class="comment">// 启动三个线程以执行系统初始化</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</div><div class="line">        threads.emplace_back(initialize_system, i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 主线程等待所有初始化完成</span></div><div class="line">    initialization_latch.wait();</div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All systems are initialized. Main thread is proceeding."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// 等待所有线程完成</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>& thread : threads) {</div><div class="line">        thread.join();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::latch</code> 用于确保三个并发运行的初始化操作都完成了，主线程才开始执行后续的任务。每个初始化线程在完成初始化后调用 <code>initialization_latch.count_down()</code>，这将减少 <code>std::latch</code> 的计数器。主线程调用 <code>initialization_latch.wait()</code> 来等待所有的初始化操作完成。一旦所有的初始化操作都调用了 <code>count_down()</code>，<code>std::latch</code> 的计数器达到零，主线程将继续执行。</p>
<p><code>std::latch</code> 是一个非常有用的同步工具，特别是在涉及一次性事件或需要多个线程完成启动步骤之后才能继续的场景中。它简化了在这些情况下的线程协调。</p>
<h2 id="std::promise、std::future_和_std::async">std::promise、std::future 和 std::async</h2>
<p><code>std::promise</code> 和 <code>std::future</code> 是 C++11 引入的同步原语，它们提供了一种在线程之间传递值的机制，也可以用于线程之间的同步。<code>std::async</code> 是 C++11 引入的一个函数模板，用于异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便在将来某个时间点获取该函数的结果。</p>
<h3 id="std::promise">std::promise</h3>
<p><code>std::promise</code> 允许你在某个线程中存储一个值或异常，该值或异常可以在将来某个时刻被另一个线程检索。当创建 <code>std::promise</code> 对象时，它与一个 <code>std::future</code> 对象相关联，<code>std::future</code> 对象可用于访问 <code>std::promise</code> 中存储的值。</p>
<p>主要成员函数包括：</p>
<ul>
<li>set_value(const T&amp; value): 用来设置值，这会导致与之相关联的 std::future 对象变为 ready 状态，之后可以从中获取这个值。</li>
<li>set_exception(std::exception_ptr p): 用来设置异常，这也会导致相关联的 std::future 对象变为 ready 状态，但尝试从中获取值会引发异常。</li>
<li>get_future(): 返回与 std::promise 对象相关联的 std::future 对象。</li>
</ul>
<h3 id="std::future">std::future</h3>
<p><code>std::future</code> 提供了一种访问异步操作结果的机制。它与 <code>std::promise</code> 对象相关联，用于获取通过 <code>promise</code> 设置的值或异常。</p>
<p>主要成员函数包括：</p>
<ul>
<li>get(): 获取存储在 std::promise 中的值，如果值还未被设置，会阻塞调用线程直到值变为可用。如果 promise 中存储了异常，则调用 get() 会抛出该异常。</li>
<li>wait(): 等待异步操作完成，不返回结果。</li>
<li>valid(): 检查 future 对象是否与一个共享状态相关联（即它是否有值可以获取）。</li>
</ul>
<h2 id="std::async">std::async</h2>
<p><code>std::async</code> 是一个函数模板，用于启动一个异步任务，它的返回类型是 <code>std::future</code>，通过该 <code>future</code> 可以访问异步任务的结果。当调用 <code>std::async</code> 时，可以指定一个函数或可调用对象，以及传递给该函数的参数。<code>std::async</code> 可以指定启动策略，例如 <code>std::launch::async</code>（在新线程中运行）或 <code>std::launch::deferred</code>（延迟执行，直到调用 <code>std::future::get()</code> 或 <code>wait()</code>）。</p>
<p>以下是一个使用 <code>std::promise</code> 和 <code>std::future</code> 的简单示例，模拟了一个异步计算任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;future&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">    <span class="comment">// 创建一个 promise 对象</span></div><div class="line">    std::promise&lt;<span class="keyword">int</span>&gt; prom;</div><div class="line"></div><div class="line">    <span class="comment">// 从 promise 中获取 future</span></div><div class="line">    std::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future();</div><div class="line"></div><div class="line">    <span class="comment">// 启动一个线程来完成一个计算任务并设置 promise 的值</span></div><div class="line">    std::thread t([&prom]() {</div><div class="line">        <span class="comment">// 模拟一些计算</span></div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">2</span>));</div><div class="line">        prom.set_value(<span class="number">42</span>); <span class="comment">// 设置 promise 的值</span></div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// 在主线程中，我们可以等待 future 变为 ready 并获取值</span></div><div class="line">    <span class="keyword">int</span> result = fut.get();  <span class="comment">// 这里会阻塞直到线程设置了 promise 的值</span></div><div class="line">    std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is: "</span> &lt;&lt; result &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    t.join();  <span class="comment">// 等待线程完成</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::async</code> 用于启动一个新线程来执行 <code>compute</code> 函数。通过返回的 <code>std::future</code> 对象，主线程可以在稍后获取异步计算的结果。如果在此期间尚未完成计算，调用 <code>fut.get()</code> 将会阻塞主线程。</p>
<p><code>std::promise</code>、<code>std::future</code> 和 <code>std::async</code> 提供了 C++ 中进行异步编程的基础设施，允许开发者在不同线程之间传递数据和同步操作，同时将并发复杂性降到最低。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++ 标准库中包含了一些基本的同步原语，尤其是C++ 20标准库又补充了一些。本文简单介绍这些并发原语，并通过示例演示它们基本的功能。</p>
]]>
    
    </summary>
    
      <category term="C++" scheme="https://colobu.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go http.ServeMux中的模式匹配]]></title>
    <link href="https://colobu.com/2023/12/25/patterns-in-ServeMux-HandleFunc/"/>
    <id>https://colobu.com/2023/12/25/patterns-in-ServeMux-HandleFunc/</id>
    <published>2023-12-25T14:42:10.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.22中一个很大的变化是<code>http.ServeMux</code>中的模式匹配，先前这个功能是很多第三方的web框架或者router库实现的。</p>
<p>我们很有必要好好研究它，将来在实现HTTP API的时候可能优先使用它。</p>
<a id="more"></a>
<p><code>http.ServeMux</code>是一个HTTP请求多路复用器,它将每个传入请求的URL与已注册的模式列表进行匹配，并调用与最接近URL匹配的模式对应的处理程序。</p>
<p>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mux.HandleFunc(<span class="string">"POST /items/create"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprint(w, <span class="string">"POST item created"</span>)</div><div class="line">})</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"/items/create"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprint(w, <span class="string">"item created"</span>)</div><div class="line">})</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"/items/{id}"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    id := r.PathValue(<span class="string">"id"</span>)</div><div class="line">    fmt.Fprintf(w, <span class="string">"Item ID = %s"</span>, id)</div><div class="line">})</div><div class="line"></div><div class="line">mux.HandleFunc(<span class="string">"/files/{path...}"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    path := r.PathValue(<span class="string">"path"</span>)</div><div class="line">    fmt.Fprintf(w, <span class="string">"File path = %s"</span>, path)</div><div class="line">})</div></pre></td></tr></table></figure>

<p>和原来的<code>HandleFunc</code>相比，第一个参数貌似有了不一样的变化，除了正常的path之外，还有HTTP POST Method，还有<code>{id}</code>和<code>{path...}</code>这样的变量，这就是Go 1.22中新增加的模式匹配。</p>
<p>通过<code>PathValue</code>可以获取路径中的通配符匹配的值。</p>
<h2 id="模式匹配">模式匹配</h2>
<p>模式匹配用在注册handler的时候，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Handle(pattern <span class="typename">string</span>, handler Handler)</div><div class="line"><span class="keyword">func</span> HandleFunc(pattern <span class="typename">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request))</div></pre></td></tr></table></figure>

<p>其中<code>pattern</code>模式的格式是这样子的:<code>[METHOD ][HOST]/[PATH]</code>, 中括号代表这一项可以省略。<br>因此<code>POST /items/create</code>、<code>POST rpcx.io/items/create</code>、<code>GET /items/123</code>、<code>/items/123</code>都是合法的模式。</p>
<p>如果不设置HTTP Method如<code>POST</code>,那么默认是匹配所有的HTTP Method。注意HTTP Method 之后有一个空格。<br>模式匹配<code>GET</code>会匹配<code>GET</code>和<code>HEAD</code>,除此之外，其他的HTTP Method都是精确匹配。</p>
<p>如果未设置HOST，那么默认是匹配所有的HOST。否则，HOST必须完全匹配。</p>
<h3 id="通配符">通配符</h3>
<p>请求的路径中可以包含通配符，如<code>&quot;/b/{bucket}/o/{objectname...}&quot;</code>。配符名称必须是有效的Go标识符。通配符必须是完整的路径段，例如<code>/b_{bucket}</code>就不是一个合法的通配符。</p>
<ul>
<li><code>/items/{id}</code>: 正常情况下一个通配符只匹配一个路径段，比如匹配<code>/items/123</code>，但是不匹配<code>/items/123/456</code>。</li>
<li><code>/items/{apth...}</code>: 但是如果通配符后面跟着<code>...</code>，那么它就会匹配多个路径段，比如<code>/items/123</code>、<code>/items/123/456</code>都会匹配这个模式。</li>
<li><code>/items/{$}</code>: 以<code>/</code>结尾的模式会匹配所有以它为前缀的路径，比如<code>/items/</code>、<code>/items/123</code>、<code>/items/123/456</code>都会匹配这个模式。如果以<code>/{$}</code>为后缀，那么表示严格匹配路径，不会匹配带后缀的路径，比如这个例子只会匹配<code>/items/</code>，不会匹配<code>/items/123</code>、<code>/items/123/456</code>。</li>
</ul>
<p>在匹配过程中，模式路径和传入请求路径都会逐段解码。因此，例如，路径 <code>/a%2Fb/100%25</code> 被视为具有两个段，<code>a/b</code> 和 <code>100%</code>。模式 <code>/a%2fb/</code> 与之匹配，但模式 <code>/a/b/</code> 则不匹配。</p>
<h3 id="优先级">优先级</h3>
<p>如果两个模式都可以匹配同一个路径咋办呢？比如<code>/items/{id}</code>和<code>/items/{path...}</code>都可以匹配<code>/items/123</code>，那么谁优先呢？</p>
<ul>
<li>最具体的模式具有优先权。比如<code>/items/{id}</code>比<code>/items/</code>更具体。</li>
<li>如果两者都不更具体，则模式冲突。<ul>
<li>在冲突的情况下，具有主机的模式具有优先权 <code>rpcx.io/items/{id}</code>比<code>/items/{id}</code>优先权更高。</li>
<li>如果两者都没有HOST，则模式冲突,panic。 <code>items/{id}</code>和<code>/items/{index}</code>都没有HOST，所以会panic。</li>
</ul>
</li>
</ul>
<h2 id="后缀/的转发">后缀<code>/</code>的转发</h2>
<p><code>/images/</code> 会导致<code>ServeMux</code>把<code>/images</code>重定向到<code>/images/</code>除非你注册了<code>/images</code>的handler。</p>
<h2 id="请求清理">请求清理</h2>
<p><code>ServeMux</code> 还负责清理URL请求路径和Host标头，去除端口号，并将包含 <code>.</code> 或 <code>..</code> 段或重复斜杠的任何请求重定向到等效、更清晰的URL。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.22中一个很大的变化是<code>http.ServeMux</code>中的模式匹配，先前这个功能是很多第三方的web框架或者router库实现的。</p>
<p>我们很有必要好好研究它，将来在实现HTTP API的时候可能优先使用它。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go标准库的新 math/rand]]></title>
    <link href="https://colobu.com/2023/12/24/new-math-rand-in-Go/"/>
    <id>https://colobu.com/2023/12/24/new-math-rand-in-Go/</id>
    <published>2023-12-24T08:45:20.000Z</published>
    <updated>2024-02-02T07:54:29.799Z</updated>
    <content type="html"><![CDATA[<p>Go 1.22 就要在龙年春节期间发布了。Go 1.22的新特性包括了新的 <code>math/rand</code> 包。这个包的目标是提供一个更好的伪随机数生成器，它的 API 也更加简单易用。本文将介绍这个新的包的特性。<br><a id="more"></a></p>
<p><a href="https://tip.golang.org/doc/go1.22" target="_blank" rel="external">Go 1.22 release notes</a> 正在编写之中，大家可以关注这个网页以便全面了解Go 1.22的变化，前几天有Gopher制作了一个<a href="https://antonz.org/go-1-22/" target="_blank" rel="external">交互式运行新特性代码的网页</a>，也非常好，在reddit上关注度很高。今天这篇文章只关注于于<code>math/rand/v2</code>这个新的包。</p>
<h2 id="为什么要新的math/rand包">为什么要新的math/rand包</h2>
<p>其实大家对<code>math/rand</code>不是那么满意。<br>2017年，<a href="https://github.com/golang/go/issues/20661" target="_blank" rel="external">#20661</a> 中提到<code>math/rand.Read</code>和<code>crypto/rand.Read</code>相近，导致本来应该使用<code>crypto/rand.Read</code>的地方使用了<code>math/rand.Read</code>，导致了安全问题。<br>2017年，<a href="https://github.com/golang/go/issues/21835" target="_blank" rel="external">#21835</a> 中 Rob Pike 提议在Go 2中使用PCG Source。<br>2018年，<a href="https://github.com/golang/go/issues/26263" target="_blank" rel="external">#26263</a> 中 Josh Bleecher Snyder 提议对<code>math/rand</code>进行彻底的重构。<br>2023年6月， Russ Cox基于先前的对<code>math/rand</code>的吐槽，以及和Rob Pike的讨论，建立了一个讨论(<a href="https://github.com/golang/go/discussions/60751" target="_blank" rel="external">#60751</a>),准备新建一个包<code>math/rand/v2</code>,重新设计和实现一个新的伪随机数的库讨论也很热烈，最后实现了一个提案<a href="https://github.com/golang/go/issues/61716" target="_blank" rel="external">#61716</a>，这个提案最直接的动机是清理 <code>math/rand</code> 并解决其中许多悬而未决的问题，特别是使用过时生成器、缓慢的算法，以及与 <code>crypto/rand.Read</code> 的不幸冲突。</p>
<p>由于go module的支持版本<code>v2、v3、...</code>, Go 1.22中将会有一个新的包<code>math/rand/v2</code>，这个包将会是一个新的包，而不是<code>math/rand</code>的升级版本。这个包的目标是提供一个更好的伪随机数生成器，它的 API 也更加简单易用，同时一些检查工具也能支持这个包，不会报错。</p>
<p>看样子，<code>math/rand/v2</code>将会是第一个在标准库中建立<code>v2</code>版本的包，如果大家能够接受，将来会有更多的包加入进来，比如<code>sync/v2</code>、<code>encoding/json/v2</code>等等。</p>
<h2 id="提案的主要内容">提案的主要内容</h2>
<p><code>math/rand/v2</code> API 以 <code>math/rand</code> 为起点，进行以下<strong>不兼容的更改</strong>：</p>
<p>1、 移除 <code>Rand.Read</code> 和顶层的 <code>Read</code>。假装伪随机生成器是任意长字节序列的良好来源几乎总是错误的。<code>math/rand</code> 适用于模拟和非确定性算法，几乎从不需要字节序列。<code>Read</code> 是 <code>math/rand</code> 和 <code>crypto/rand</code> 之间唯一共享的 API 部分，代码应该基本上总是使用 <code>crypto/rand.Read</code>。（<code>math/rand.Read</code> 和 <code>crypto/rand.Read</code> 存在问题，因为它们具有相同的签名; <code>math/rand.Int</code> 和 <code>crypto/rand.Int</code> 也都存在，但具有不同的签名，这意味着代码永远不会意外地将一个错认为是另一个。）</p>
<p>2、 移除 <code>Source.Seed</code>、<code>Rand.Seed</code> 和顶层的 <code>Seed</code>。顶层的 <code>Seed</code> 已在 Go 1.20 中废弃。<code>Source.Seed</code> 和 <code>Rand.Seed</code> 假定底层源可以由单个 <code>int64</code> 作为种子，这只对有限数量的源是真实的。具体的源实现可以提供具有适当签名的 <code>Seed</code> 方法，或者对于不能重新设置种子的生成器根本不提供；简单来说使用一个<code>int64</code> 作为种子没有普适性，不适合定义一个通用的接口。</p>
<p>注意，移除顶层 <code>Seed</code> 意味着顶层函数如 <code>Int</code> 将始终以随机方式而不是确定性方式生成。<code>math/rand/v2</code> 将不关注 <code>math/rand</code> 所关注的 <a href="https://tip.golang.org/doc/go1.20#mathrandpkgmathrand" target="_blank" rel="external"><code>randautoseed</code></a> GODEBUG 设置；顶层函数的自动设置哦随机种子是唯一的模式。这反过来意味着顶层函数使用的具体 PRNG 算法是未指定的，可以在发布之间更改而不破坏任何现有代码。</p>
<p>3、 将 <code>Source</code> 接口更改为具有单个 <code>Uint64() uint64</code> 方法，取代 <code>Int63() int64</code>。后者过于拟合原始的 Mitchell &amp; Reeds LFSR 生成器。现代生成器可以提供 <code>uint64</code>。</p>
<p>4、 移除 <code>Source64</code>，现在不再需要，因为 <code>Source</code> 提供了 <code>Uint64</code> 方法。</p>
<p>5、 在 <code>Float32</code> 和 <code>Float64</code> 中使用更直观的实现。以 <code>Float64</code> 为例，它最初使用 <code>float64(r.Int63()) / (1&lt;&lt;63)</code>，但这存在问题，偶尔会四舍五入为 <code>1.0</code>。我们尝试将其更改为 <code>float64(r.Int63n(1&lt;&lt;53) / (1&lt;&lt;53)</code>，避免了四舍五入的问题。</p>
<p>6、 修复 <code>ExpFloat64</code> 和 <code>NormFloat64</code> 中的偏差问题。</p>
<p>7、 使用 <code>Rand.Shuffle</code> 实现 <code>Rand.Perm</code>。</p>
<p>8、 将 <code>Intn</code>、<code>Int31</code>、<code>Int31n</code>、<code>Int63</code>、<code>Int64n</code> 重命名为 <code>IntN</code>、<code>Int32</code>、<code>Int32N</code>、<code>Int64</code>、<code>Int64N</code>。原来的名称中的 <code>31</code> 和 <code>63</code> 是令人困惑的，而大写 <code>N</code> 在 Go 中作为名称的第二个“单词”更为习惯。</p>
<p>9、 添加 <code>Uint32</code>、<code>Uint32N</code>、<code>Uint64</code>、<code>Uint64N</code>、<code>Uint</code>、<code>UintN</code>，既作为顶层函数，也作为 <code>Rand</code> 的方法。</p>
<p>10、在 <code>N</code>、<code>IntN</code>、<code>UintN</code> 等中使用 <a href="https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction" target="_blank" rel="external">Lemire</a> 的算法。初步基准测试显示，与 <code>v1 Int31n</code> 相比，节省了 40%，与 <code>v1 Int63n</code> 相比，节省了 75%。</p>
<p>11、添加一个通用的顶层函数 <code>N</code>，类似于 <code>Int64N</code> 或 <code>Uint64N</code>，但适用于任何整数类型。特别是这允许使用 <code>rand.N(1*time.Minute)</code> 来获取范围在 <code>[0, 1*time.Minute)</code> 内的随机持续时间。</p>
<p>12、添加一个新的 <code>Source</code> 实现，<code>PCG-DXSM</code>。PCG 是一个简单、高效的算法，具有良好的统计随机性质。DXSM 变体是作者专门为纠正原始 (PCG-XSLRR) 中的一种罕见、隐晦的缺陷而引入的，并且现在是 Numpy 中的默认生成器。</p>
<p>13、移除 Mitchell &amp; Reeds LFSR 生成器和 NewSource。</p>
<p>14、添加一个新的 Source 实现，<code>ChaCha8</code>。ChaCha8 是从 ChaCha8 流密码派生的具有强密码学随机性质的随机数生成器。它提供与 ChaCha8 加密等效的安全性。</p>
<p>15、在 <code>math/rand/v2</code> 和 <code>math/rand</code>（未设置种子时）中使用每个 OS 线程的 ChaCha8 作为全局随机生成器。</p>
<h2 id="math/rand/v2介绍">math/rand/v2介绍</h2>
<p>注意，根据go module的定义，<code>v2</code>只是版本号，新的包名还是叫做<code>rand</code>。</p>
<p><code>rand</code> 包实现了适用于模拟(<code>simulation</code>)等任务的伪随机数生成器，但<strong>不应用于对安全性敏感</strong>的工作。</p>
<p>随机数由 <code>Source</code>生成，通常包装在 <code>Rand</code> 中。这两种类型应该一次由单个 goroutine 使用：在多个 goroutine 之间共享<strong>需要某种形式的同步</strong>。</p>
<p>顶层函数，如 <code>Float64</code> 和 <code>Int</code>，对于多个 goroutine 的<strong>并发使用是安全</strong>的。</p>
<p>该包的输出可能在设置种子的方式不同的情况下很容易可预测。对于适用于对安全性敏感的工作的随机数，请参阅 <code>crypto/rand</code> 包。</p>
<p>简单综述：所以你考虑到安全避免被人预测的场景下，还是要使用<code>crypto/rand</code> 包。 包级别的函数比如<code>Int</code>是线程安全的，但是如果你自己生成一个<code>Rand</code>对象，那么就要注意了，因为<code>Rand</code>对象是非线程安全的。</p>
<h3 id="包级别的函数">包级别的函数</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ExpFloat64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> Float32() <span class="typename">float32</span></div><div class="line"><span class="keyword">func</span> Float64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> Int() <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Int32() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> Int32N(n <span class="typename">int32</span>) <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> Int64() <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> Int64N(n <span class="typename">int64</span>) <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> IntN(n <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> N[Int intType](n Int) Int</div><div class="line"><span class="keyword">func</span> NormFloat64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> Perm(n <span class="typename">int</span>) []<span class="typename">int</span></div><div class="line"><span class="keyword">func</span> Shuffle(n <span class="typename">int</span>, swap <span class="keyword">func</span>(i, j <span class="typename">int</span>))</div><div class="line"><span class="keyword">func</span> Uint32() <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> Uint32N(n <span class="typename">uint32</span>) <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> Uint64N(n <span class="typename">uint64</span>) <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> UintN(n <span class="typename">uint</span>) <span class="typename">uint</span></div></pre></td></tr></table></figure>

<p>针对<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>,分别有<code>Xxxxx()</code>和<code>XxxxxN()</code>两种函数，前者返回一个随机数，后者返回一个范围在<code>[0,n)</code>的随机数。<br><code>Float32</code>和<code>Float64</code>返回范围在<code>[0.0, 1.0)</code>的随机浮点数。<br><code>IntN</code>返回一个范围在<code>[0,n)</code>的随机数，数据类型是<code>int</code>类型。<br><code>N</code>是一个泛型的函数，返回一个范围在<code>[0,n)</code>的随机数，底层数据是int类型的，特别适合<code>time.Duration</code>这样的类型。</p>
<p><code>Perm</code>返回一个长度为<code>n</code>的随机排列的<code>int</code>数组。<br><code>Shuffle</code>洗牌算法</p>
<p><code>NormFloat64</code>返回一个标准正态分布的随机数。<br><code>ExpFloat64</code>返回一个指数分布的随机数。</p>
<h3 id="三种伪随机数生成器">三种伪随机数生成器</h3>
<p><code>ChaCha8</code> 也是包级别的函数使用的伪随机数生成器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChaCha8</div><div class="line"><span class="keyword">func</span> NewChaCha8(seed <span class="number">[32</span>]<span class="typename">byte</span>) *ChaCha8</div><div class="line"><span class="keyword">func</span> (c *ChaCha8) MarshalBinary() ([]<span class="typename">byte</span>, error)</div><div class="line"><span class="keyword">func</span> (c *ChaCha8) Seed(seed <span class="number">[32</span>]<span class="typename">byte</span>)</div><div class="line"><span class="keyword">func</span> (c *ChaCha8) Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (c *ChaCha8) UnmarshalBinary(data []<span class="typename">byte</span>) error</div></pre></td></tr></table></figure>

<p><code>PCG</code> 是另外一种伪随机数生成器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PCG</div><div class="line"><span class="keyword">func</span> NewPCG(seed1, seed2 <span class="typename">uint64</span>) *PCG</div><div class="line"><span class="keyword">func</span> (p *PCG) MarshalBinary() ([]<span class="typename">byte</span>, error)</div><div class="line"><span class="keyword">func</span> (p *PCG) Seed(seed1, seed2 <span class="typename">uint64</span>)</div><div class="line"><span class="keyword">func</span> (p *PCG) Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (p *PCG) UnmarshalBinary(data []<span class="typename">byte</span>) error</div></pre></td></tr></table></figure>

<p><code>Zipf</code>是生成Zipf分布的伪随机数生成器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Zipf</div><div class="line"><span class="keyword">func</span> NewZipf(r *Rand, s <span class="typename">float64</span>, v <span class="typename">float64</span>, imax <span class="typename">uint64</span>) *Zipf</div><div class="line"><span class="keyword">func</span> (z *Zipf) Uint64() <span class="typename">uint64</span></div></pre></td></tr></table></figure>

<p>相信后续还会有一些第三方的伪随机数生成器出现。</p>
<p>它们都实现了接口<code>Source</code>,<code>Source</code>接口只有一个方法<code>Uint64()</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Source <span class="keyword">interface</span> {</div><div class="line">	Uint64() <span class="typename">uint64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>所有的伪随机数生成器都可以包装成一个<code>Rand</code>对象，<code>Rand</code>对象是非线程安全的，所以要注意。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> New(src Source) *Rand</div></pre></td></tr></table></figure>

<blockquote>
<p>这和Rust中的实现模式类似。&lt;<programming rust="">&gt;第一版把它叫做伴型特性，第二版中不知道为什么把这一节去掉了。<br>Rust中的<code>Rng</code>类似这里的Go的<code>Source</code>,可以有多种实现生成器。Rust中的<code>Rand</code>也类似这里Go的<code>Rand</code>,基于<code>Uint64() uint64</code>提供各种类型的随机数。</programming></p>
</blockquote>
<p><code>Rand</code>提供了各种便利的方法，这些方法其实和包级别的函数是一样的，只是它们是<code>Rand</code>对象的方法而已：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (r *Rand) Float32() <span class="typename">float32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Float64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int() <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int32() <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int32N(n <span class="typename">int32</span>) <span class="typename">int32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int64() <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Int64N(n <span class="typename">int64</span>) <span class="typename">int64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) IntN(n <span class="typename">int</span>) <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (r *Rand) NormFloat64() <span class="typename">float64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Perm(n <span class="typename">int</span>) []<span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Shuffle(n <span class="typename">int</span>, swap <span class="keyword">func</span>(i, j <span class="typename">int</span>))</div><div class="line"><span class="keyword">func</span> (r *Rand) Uint32() <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Uint32N(n <span class="typename">uint32</span>) <span class="typename">uint32</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Uint64() <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) Uint64N(n <span class="typename">uint64</span>) <span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> (r *Rand) UintN(n <span class="typename">uint</span>) <span class="typename">uint</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.22 就要在龙年春节期间发布了。Go 1.22的新特性包括了新的 <code>math/rand</code> 包。这个包的目标是提供一个更好的伪随机数生成器，它的 API 也更加简单易用。本文将介绍这个新的包的特性。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
