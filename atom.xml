<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2017-06-27T09:46:39.610Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[了解 Go 1.9 的类型别名]]></title>
    <link href="http://colobu.com/2017/06/26/learn-go-type-aliases/"/>
    <id>http://colobu.com/2017/06/26/learn-go-type-aliases/</id>
    <published>2017-06-26T09:20:19.000Z</published>
    <updated>2017-06-27T09:46:30.000Z</updated>
    <content type="html"><![CDATA[<p>如你所知， 类型别名(type aliases) 最终还是加入到Go 1.9中， Go 1.9 beta2今天已经发布了, 正式版预计8月初发布， 是时候深入了解一下它的新特性了，本文介绍的就是它的重要的新特性之一： 类型别名。 </p>
<p>当然，如果你想尝试这些新特性，需要安装Go 1.9的版本，目前是beta2版，可以在官方网站下载。<br><a id="more"></a></p>
<p>类型别名主要解决什么问题，为什么需要这个特性？ Russ Cox 的论文<a href="https://talks.golang.org/2016/refactor.article" target="_blank" rel="external">Codebase Refactoring (with help from Go)</a>介绍了它的背景。类型别名主要用在：</p>
<ol>
<li>在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型， 比如<code>context</code></li>
<li>允许一个庞大的包分解成内部的几个小包，但是小包中的类型需要集中暴漏在上层的大包中</li>
</ol>
<h3 id="类型别名">类型别名</h3>
<p>类型别名的语法如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> identifier = Type</div></pre></td></tr></table></figure>

<p>它和类型定义(type definition)类似，仅仅是在<code>identifier</code>和<code>Type</code>之间加了一个等号<code>=</code>，但是和类型定义区别很大，这一点会在后面专门比较。</p>
<p>下面这个例子就是为字符串<code>string</code>类型定义了一个别名<code>S</code>,你可以声明变量、常量为<code>S</code>类型，将字符串赋值给它，它和字符串类型几乎一模一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> S = <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S = <span class="string">"hello world"</span></div><div class="line">	fmt.Println(s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然， 你可以为任意的类型定义类型别名，语言规范中没有限制，可以为数组、结构体、指针、函数、接口、Slice、Map、Channel定义别名，甚至你还可以为通过类型定义(type definition)的类型定义别名，更甚者是你可以为别名定义别名。</p>
<p>比如下面这个例子， 为函数类型<code>func()</code>定义了一个别名<code>F</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> F = <span class="keyword">func</span>()</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> foo F = <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"hello type aliases"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	foo()	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>又如下面的代码，为<code>interface{}</code>定义了别名<code>G</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> G = <span class="keyword">interface</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> g G = <span class="string">"hello world"</span></div><div class="line">	fmt.Println(g)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>类型别名还可以为其它包中的类型定义别名，只要这个类型在其它包中是<code>exported</code>的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyTime = time.Time</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> t MyTime = time.Now()</div><div class="line">	fmt.Println(t)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="类型命名和类型声明的区别">类型命名和类型声明的区别</h3>
<p>记住下面一句话：</p>
<blockquote>
<p>类型别名和原类型完全一样，只不过是另一种叫法而已</p>
</blockquote>
<p>这句话隐藏着很多的智慧，你可以慢慢体会。</p>
<p>完全一样(<a href="https://golang.org/ref/spec#Type_identity" target="_blank" rel="external">identical types</a>)意味着这两种类型的数据可以互相赋值，而类型定义要和原始类型赋值的时候需要类型转换(Conversion <code>T(x)</code>)。</p>
<p>下面这个例子中，<code>v</code>是整数类型，可以直接赋值给<code>d</code>,因为d的类型是<code>D</code>,是是整数的别名。而<code>var i I = v</code>这一句会出错，因为<code>I</code>和整数是两个类型。 </p>
<p>所以类型别名和类型定义最大的区别在于：类型别名和原类型是相同的，而类型定义和原类型是不同的两个类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> D = <span class="typename">int</span></div><div class="line"><span class="keyword">type</span> I <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	v :=<span class="number"> 100</span></div><div class="line">	<span class="keyword">var</span> d D = v</div><div class="line">	<span class="keyword">var</span> i I = v</div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如类型定义<code>type Tnamed Tunderlying</code>,系列类型和组合类型是不同的:</p>
<ul>
<li><code>Tnamed</code> 和 <code>Tunderlying</code></li>
<li><code>*Tnamed</code> 和 <code>*Tunderlying</code></li>
<li><code>chan Tnamed</code> 和 <code>chan Tunderlying</code></li>
<li><code>func(Tnamed)</code> 和 <code>func(Tunderlying)</code></li>
<li><code>interface{ M() Tnamed }</code> 和 <code>interface{ M() Tunderlying }</code></li>
</ul>
<p>但是对于别名<code>type T1 = T2</code>,下列类型和组合类型是相同的:</p>
<ul>
<li><code>T1</code> 和 <code>T2</code></li>
<li><code>*T1</code> 和 <code>*T2</code></li>
<li><code>chan T1</code> 和 <code>chan T2</code></li>
<li><code>func(T1)</code> 和 <code>func(T2)</code></li>
<li><code>interface{ M() T1 }</code> 和 <code>interface{ M() T2 }</code></li>
</ul>
<p>还有一个重要的区别在于类型定义的类型的方法集和原始类型的方法集没有任何关系，而类型别名和原始类型的方法集是一样的，下面再介绍。</p>
<p>既然类型别名和原类型是相同的，那么在`switch - type中，你不能将原类型和类型别名作为两个分支，因为这是重复的case:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> D = <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> v <span class="keyword">interface</span>{} </div><div class="line">	<span class="keyword">var</span> d D =<span class="number"> 100</span></div><div class="line">	v = d</div><div class="line">	</div><div class="line">	<span class="keyword">switch</span> i := v.(<span class="keyword">type</span>) {</div><div class="line">		<span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">			fmt.Println(<span class="string">"it is an int:"</span>, i)</div><div class="line">		<span class="comment">// case D:</span></div><div class="line">		<span class="comment">// 	fmt.Println("it is D type:", i)</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="类型循环">类型循环</h3>
<p>类型别名在定义的时候不允许出现循环定义别名的情况，如下面所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 = T2</div><div class="line"><span class="keyword">type</span> T2 = T1</div></pre></td></tr></table></figure>

<p>上面的例子太明显，下面这个例子比较隐蔽，也是循环定义类型别名的情况，当然这些在编译代码的时候编译器会帮你检查，如果出现循环定义的情况会出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 = <span class="keyword">struct</span> {</div><div class="line">	next *T2</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 = T1</div></pre></td></tr></table></figure>

<h3 id="可导出性">可导出性</h3>
<p>如果定义的类型别名是<code>exported</code> (首字母大写)的，那么别的包中就可以使用，它和原始类型是否可<code>exported</code>没关系。也就是说，你可以为<code>unexported</code>类型定义一个<code>exported</code>的类型别名，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> t1 <span class="keyword">struct</span> {</div><div class="line">	S <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 t1</div></pre></td></tr></table></figure>

<h3 id="方法集">方法集</h3>
<p>既然类型别名和原始类型是相同的，那么它们的方法集也是相同的。</p>
<p>下面的例子中<code>T1</code>和<code>T3</code>都有<code>say</code>和<code>greeting</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> T3 = T1</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t1 T1) say(){}</div><div class="line"><span class="keyword">func</span> (t3 *T3) greeting(){}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> t1 T1</div><div class="line">	<span class="comment">// var t2 T2</span></div><div class="line">	<span class="keyword">var</span> t3 T3</div><div class="line"></div><div class="line">	t1.say()</div><div class="line">	t1.greeting()</div><div class="line"></div><div class="line">	t3.say()</div><div class="line">	t3.greeting()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果类型别名和原始类型定义了相同的方法，代码编译的时候会报错，因为有重复的方法定义。</p>
<p>另一个有趣的现象是 <code>embedded type</code>, 比如下面的例子， <code>T3</code>是<code>T1</code>的别名。在定义结构体<code>S</code>的时候，我们使用了匿名嵌入类型，那么这个时候调用<code>s.say</code>会怎么样呢？ 实际是你会编译出错，因为<code>s.say｀不知道该调用</code>s.T1.say<code>还是</code>s.T3.say`，所以这个时候你需要明确的调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> T3 = T1</div><div class="line"><span class="keyword">func</span> (t T1) say(){}</div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	T1</div><div class="line">	T3</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S</div><div class="line">	s.say()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>进一步想，这样是不是我们可以为其它库中的类型增加新的方法了， 比如为标准库的<code>time.Time</code>增加一个滴答方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NTime = time.Time</div><div class="line"><span class="keyword">func</span> (t NTime) Dida() {</div><div class="line">	fmt.Println(<span class="string">"嘀嗒嘀嗒嘀嗒嘀嗒搜索"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	t := time.Now()	</div><div class="line">	t.Dida()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答案是: <strong>NO</strong>, 编译的时候会报错: <code>cannot define new methods on non-local type time.Time</code>。</p>
<h3 id="byte_和_rune_类型">byte 和 rune 类型</h3>
<p>在Go 1.9中， 内部其实使用了类型别名的特性。 比如内建的<code>byte</code>类型，其实是<code>uint8</code>的类型别名，而<code>rune</code>其实是<code>int32</code>的类型别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></div><div class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></div><div class="line"><span class="comment">// integer values.</span></div><div class="line"><span class="keyword">type</span> <span class="typename">byte</span> = <span class="typename">uint8</span></div><div class="line"></div><div class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></div><div class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></div><div class="line"><span class="keyword">type</span> <span class="typename">rune</span> = <span class="typename">int32</span></div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://github.com/golang/proposal/blob/master/design/18130-type-alias.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/18130-type-alias.md</a></li>
<li><a href="https://github.com/golang/go/issues/18130" target="_blank" rel="external">https://github.com/golang/go/issues/18130</a></li>
<li><a href="https://talks.golang.org/2016/refactor.article" target="_blank" rel="external">https://talks.golang.org/2016/refactor.article</a></li>
<li><a href="https://github.com/golang/go/issues/16339" target="_blank" rel="external">https://github.com/golang/go/issues/16339</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>如你所知， 类型别名(type aliases) 最终还是加入到Go 1.9中， Go 1.9 beta2今天已经发布了, 正式版预计8月初发布， 是时候深入了解一下它的新特性了，本文介绍的就是它的重要的新特性之一： 类型别名。 </p>
<p>当然，如果你想尝试这些新特性，需要安装Go 1.9的版本，目前是beta2版，可以在官方网站下载。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Golang 中使用 JSON 的小技巧]]></title>
    <link href="http://colobu.com/2017/06/21/json-tricks-in-Go/"/>
    <id>http://colobu.com/2017/06/21/json-tricks-in-Go/</id>
    <published>2017-06-21T09:59:14.000Z</published>
    <updated>2017-06-22T09:55:11.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/taowen" target="_blank" rel="external">taowen</a>是<a href="https://github.com/json-iterator/go" target="_blank" rel="external">json-iterator</a>的作者。 序列化和反序列化需要处理JSON和struct的关系，其中会用到一些技巧。 原文 <a href="http://jsoniter.com/go-tips.cn.html" target="_blank" rel="external">Golang 中使用 JSON 的小技巧</a>是他的经验之谈，介绍了一些struct解析成json的技巧，以及 json-iterator 库的一些便利的处理。</p>
<p>有的时候上游传过来的字段是string类型的，但是我们却想用变成数字来使用。 本来用一个json:&quot;,string&quot; 就可以支持了，如果不知道golang的这些小技巧，就要大费周章了。</p>
<p>参考文章：<a href="http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/" target="_blank" rel="external">http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/</a></p>
<a id="more"></a>
<h3 id="临时忽略struct空字段">临时忽略struct空字段</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果想临时忽略掉空<code>Password</code>字段,可以用<code>omitempty</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">json.Marshal(<span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Password <span class="typename">bool</span> <span class="string">`json:"password,omitempty"`</span></div><div class="line">}{</div><div class="line">    User: user,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="临时添加额外的字段">临时添加额外的字段</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>临时忽略掉空<code>Password</code>字段，并且添加<code>token</code>字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">json.Marshal(<span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Token    <span class="typename">string</span> <span class="string">`json:"token"`</span></div><div class="line">    Password <span class="typename">bool</span> <span class="string">`json:"password,omitempty"`</span></div><div class="line">}{</div><div class="line">    User: user,</div><div class="line">    Token: token,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="临时粘合两个struct">临时粘合两个struct</h3>
<p>通过嵌入struct的方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BlogPost <span class="keyword">struct</span> {</div><div class="line">    URL   <span class="typename">string</span> <span class="string">`json:"url"`</span></div><div class="line">    Title <span class="typename">string</span> <span class="string">`json:"title"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Analytics <span class="keyword">struct</span> {</div><div class="line">    Visitors  <span class="typename">int</span> <span class="string">`json:"visitors"`</span></div><div class="line">    PageViews <span class="typename">int</span> <span class="string">`json:"page_views"`</span></div><div class="line">}</div><div class="line"></div><div class="line">json.Marshal(<span class="keyword">struct</span>{</div><div class="line">    *BlogPost</div><div class="line">    *Analytics</div><div class="line">}{post, analytics})</div></pre></td></tr></table></figure>

<h3 id="一个json切分成两个struct">一个json切分成两个struct</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">json.Unmarshal([]<span class="typename">byte</span>(<span class="string">`{</span></div><div class="line">  "url": "attila@attilaolah.eu",</div><div class="line">  "title": "Attila's Blog",</div><div class="line">  "visitors": 6,</div><div class="line">  "page_views": 14</div><div class="line">}`), &<span class="keyword">struct</span> {</div><div class="line">  *BlogPost</div><div class="line">  *Analytics</div><div class="line">}{&post, &analytics})</div></pre></td></tr></table></figure>

<h3 id="临时改名struct的字段">临时改名struct的字段</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> {</div><div class="line">    Key    <span class="typename">string</span> <span class="string">`json:"key"`</span></div><div class="line">    MaxAge <span class="typename">int</span>    <span class="string">`json:"cacheAge"`</span></div><div class="line">    Value  Value  <span class="string">`json:"cacheValue"`</span></div><div class="line">}</div><div class="line"></div><div class="line">json.Marshal(<span class="keyword">struct</span>{</div><div class="line">    *CacheItem</div><div class="line"></div><div class="line">    <span class="comment">// Omit bad keys</span></div><div class="line">    OmitMaxAge omit <span class="string">`json:"cacheAge,omitempty"`</span></div><div class="line">    OmitValue  omit <span class="string">`json:"cacheValue,omitempty"`</span></div><div class="line"></div><div class="line">    <span class="comment">// Add nice keys</span></div><div class="line">    MaxAge <span class="typename">int</span>    <span class="string">`json:"max_age"`</span></div><div class="line">    Value  *Value <span class="string">`json:"value"`</span></div><div class="line">}{</div><div class="line">    CacheItem: item,</div><div class="line"></div><div class="line">    <span class="comment">// Set the int by value:</span></div><div class="line">    MaxAge: item.MaxAge,</div><div class="line"></div><div class="line">    <span class="comment">// Set the nested struct by reference, avoid making a copy:</span></div><div class="line">    Value: &item.Value,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="用字符串传递数字">用字符串传递数字</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    Field1 <span class="typename">int</span>    <span class="string">`json:",string"`</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个对应的json是 <code>{&quot;Field1&quot;: &quot;100&quot;}</code></p>
<p>如果json是 <code>{&quot;Field1&quot;: 100}</code> 则会报错</p>
<h3 id="容忍字符串和数字互转">容忍字符串和数字互转</h3>
<p>如果你使用的是jsoniter，可以启动<strong>模糊模式</strong>来支持 PHP 传递过来的 JSON。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.RegisterFuzzyDecoders()</div></pre></td></tr></table></figure>

<p>这样就可以处理字符串和数字类型不对的问题了。比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val <span class="typename">string</span></div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`100`</span>, &val)</div></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val <span class="typename">float32</span></div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`"1.23"`</span>, &val)</div></pre></td></tr></table></figure>

<h3 id="容忍空数组作为对象">容忍空数组作为对象</h3>
<p>PHP另外一个令人崩溃的地方是，如果 PHP array是空的时候，序列化出来是<code>[]</code>。但是不为空的时候，序列化出来的是<code>{&quot;key&quot;:&quot;value&quot;}</code>。 我们需要把 <code>[]</code> 当成 <code>{}</code> 处理。</p>
<p>如果你使用的是jsoniter，可以启动模糊模式来支持 PHP 传递过来的 JSON。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.RegisterFuzzyDecoders()</div></pre></td></tr></table></figure>

<p>这样就可以支持了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}</div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`[]`</span>, &val)</div></pre></td></tr></table></figure>

<h3 id="使用_MarshalJSON支持time-Time">使用 MarshalJSON支持time.Time</h3>
<p>golang 默认会把 <code>time.Time</code> 用字符串方式序列化。如果我们想用其他方式表示 <code>time.Time</code>，需要自定义类型并定义 <code>MarshalJSON</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> timeImplementedMarshaler time.Time</div><div class="line"></div><div class="line"><span class="keyword">func</span> (obj timeImplementedMarshaler) MarshalJSON() ([]<span class="typename">byte</span>, error) {</div><div class="line">    seconds := time.Time(obj).Unix()</div><div class="line">    <span class="keyword">return</span> []<span class="typename">byte</span>(strconv.FormatInt(seconds,<span class="number"> 10</span>)), <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>序列化的时候会调用 MarshalJSON</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    Field timeImplementedMarshaler</div><div class="line">}</div><div class="line">should := require.New(t)</div><div class="line">val := timeImplementedMarshaler(time.Unix<span class="number">(123</span>,<span class="number"> 0</span>))</div><div class="line">obj := TestObject{val}</div><div class="line">bytes, err := jsoniter.Marshal(obj)</div><div class="line">should.Nil(err)</div><div class="line">should.Equal(<span class="string">`{"Field":123}`</span>, <span class="typename">string</span>(bytes))</div></pre></td></tr></table></figure>

<h3 id="使用_RegisterTypeEncoder支持time-Time">使用 RegisterTypeEncoder支持time.Time</h3>
<p>jsoniter 能够对不是你定义的type自定义JSON编解码方式。比如对于 <code>time.Time</code> 可以用 epoch int64 来序列化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.RegisterTimeAsInt64Codec(time.Microsecond)</div><div class="line">output, err := jsoniter.Marshal(time.Unix<span class="number">(1</span>,<span class="number"> 1002</span>))</div><div class="line">should.Equal(<span class="string">"1000001"</span>, <span class="typename">string</span>(output))</div></pre></td></tr></table></figure>

<p>如果要自定义的话，参见 <code>RegisterTimeAsInt64Codec</code> 的实现代码</p>
<h3 id="使用_MarshalText支持非字符串作为key的map">使用 MarshalText支持非字符串作为key的map</h3>
<p>虽然 JSON 标准里只支持 <code>string</code> 作为 <code>key</code> 的 <code>map</code>。但是 golang 通过 <code>MarshalText()</code> 接口，使得其他类型也可以作为 <code>map</code> 的 <code>key</code>。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f, _, _ := big.ParseFloat(<span class="string">"1"</span>,<span class="number"> 10</span>,<span class="number"> 64</span>, big.ToZero)</div><div class="line">val := <span class="keyword">map</span>[*big.Float]<span class="typename">string</span>{f: <span class="string">"2"</span>}</div><div class="line">str, err := MarshalToString(val)</div><div class="line">should.Equal(<span class="string">`{"1":"2"}`</span>, str)</div></pre></td></tr></table></figure>

<p>其中 <code>big.Float</code> 就实现了 <code>MarshalText()</code></p>
<h3 id="使用_json-RawMessage">使用 json.RawMessage</h3>
<p>如果部分json文档没有标准格式，我们可以把原始的信息用<code>[]byte</code>保存下来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    Field1 <span class="typename">string</span></div><div class="line">    Field2 json.RawMessage</div><div class="line">}</div><div class="line"><span class="keyword">var</span> data TestObject</div><div class="line">json.Unmarshal([]<span class="typename">byte</span>(<span class="string">`{"field1": "hello", "field2": [1,2,3]}`</span>), &data)</div><div class="line">should.Equal(<span class="string">` [1,2,3]`</span>, <span class="typename">string</span>(data.Field2))</div></pre></td></tr></table></figure>

<h3 id="使用_json-Number">使用 json.Number</h3>
<p>默认情况下，如果是 <code>interface{}</code> 对应数字的情况会是 <code>float64</code> 类型的。如果输入的数字比较大，这个表示会有损精度。所以可以 <code>UseNumber()</code> 启用 <code>json.Number</code> 来用字符串表示数字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">decoder1 := json.NewDecoder(bytes.NewBufferString(<span class="string">`123`</span>))</div><div class="line">decoder1.UseNumber()</div><div class="line"><span class="keyword">var</span> obj1 <span class="keyword">interface</span>{}</div><div class="line">decoder1.Decode(&obj1)</div><div class="line">should.Equal(json.Number(<span class="string">"123"</span>), obj1)</div></pre></td></tr></table></figure>

<p>jsoniter 支持标准库的这个用法。同时，扩展了行为使得 <code>Unmarshal</code> 也可以支持 <code>UseNumber</code> 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">json := Config{UseNumber:<span class="constant">true</span>}.Froze()</div><div class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span>{}</div><div class="line">json.UnmarshalFromString(<span class="string">"123"</span>, &obj)</div><div class="line">should.Equal(json.Number(<span class="string">"123"</span>), obj)</div></pre></td></tr></table></figure>

<h3 id="统一更改字段的命名风格">统一更改字段的命名风格</h3>
<p>经常 JSON 里的字段名 Go 里的字段名是不一样的。我们可以用 field tag 来修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">output, err := jsoniter.Marshal(<span class="keyword">struct</span> {</div><div class="line">    UserName      <span class="typename">string</span> <span class="string">`json:"user_name"`</span></div><div class="line">    FirstLanguage <span class="typename">string</span> <span class="string">`json:"first_language"`</span></div><div class="line">}{</div><div class="line">    UserName:      <span class="string">"taowen"</span>,</div><div class="line">    FirstLanguage: <span class="string">"Chinese"</span>,</div><div class="line">})</div><div class="line">should.Equal(<span class="string">`{"user_name":"taowen","first_language":"Chinese"}`</span>, <span class="typename">string</span>(output))</div></pre></td></tr></table></figure>

<p>但是一个个字段来设置，太麻烦了。如果使用 jsoniter，我们可以统一设置命名风格。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.SetNamingStrategy(LowerCaseWithUnderscores)</div><div class="line">output, err := jsoniter.Marshal(<span class="keyword">struct</span> {</div><div class="line">    UserName      <span class="typename">string</span></div><div class="line">    FirstLanguage <span class="typename">string</span></div><div class="line">}{</div><div class="line">    UserName:      <span class="string">"taowen"</span>,</div><div class="line">    FirstLanguage: <span class="string">"Chinese"</span>,</div><div class="line">})</div><div class="line">should.Nil(err)</div><div class="line">should.Equal(<span class="string">`{"user_name":"taowen","first_language":"Chinese"}`</span>, <span class="typename">string</span>(output))</div></pre></td></tr></table></figure>

<h3 id="使用私有的字段">使用私有的字段</h3>
<p>Go 的标准库只支持 public 的 field。jsoniter 额外支持了 private 的 field。需要使用 <code>SupportPrivateFields()</code> 来开启开关。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.SupportPrivateFields()</div><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    field1 <span class="typename">string</span></div><div class="line">}</div><div class="line">obj := TestObject{}</div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`{"field1":"Hello"}`</span>, &obj)</div><div class="line">should.Equal(<span class="string">"Hello"</span>, obj.field1)</div></pre></td></tr></table></figure>

<p>下面是我补充的内容</p>
<h3 id="忽略掉一些字段">忽略掉一些字段</h3>
<p>原文中第一节有个错误，我更正过来了。<code>omitempty</code>不会忽略某个字段，而是忽略空的字段，当字段的值为空值的时候，它不会出现在JSON数据中。</p>
<p>如果想忽略某个字段，需要使用 <code>json:&quot;-&quot;</code>格式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果想临时忽略掉空<code>Password</code>字段,可以用<code>-</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">json.Marshal(<span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Password <span class="typename">bool</span> <span class="string">`json:"-"`</span></div><div class="line">}{</div><div class="line">    User: user,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="忽略掉一些字段2">忽略掉一些字段2</h3>
<p>如果不想更改原struct,还可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> omit *<span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">type</span> PublicUser <span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Password omit <span class="string">`json:"-"`</span></div><div class="line">}</div><div class="line"></div><div class="line">json.Marshal(PublicUser{</div><div class="line">    User: user,</div><div class="line">})</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/taowen" target="_blank" rel="external">taowen</a>是<a href="https://github.com/json-iterator/go" target="_blank" rel="external">json-iterator</a>的作者。 序列化和反序列化需要处理JSON和struct的关系，其中会用到一些技巧。 原文 <a href="http://jsoniter.com/go-tips.cn.html" target="_blank" rel="external">Golang 中使用 JSON 的小技巧</a>是他的经验之谈，介绍了一些struct解析成json的技巧，以及 json-iterator 库的一些便利的处理。</p>
<p>有的时候上游传过来的字段是string类型的，但是我们却想用变成数字来使用。 本来用一个json:&quot;,string&quot; 就可以支持了，如果不知道golang的这些小技巧，就要大费周章了。</p>
<p>参考文章：<a href="http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/" target="_blank" rel="external">http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 1.9 的新特性]]></title>
    <link href="http://colobu.com/2017/06/20/what-s-new-in-Go-1-9/"/>
    <id>http://colobu.com/2017/06/20/what-s-new-in-Go-1-9/</id>
    <published>2017-06-20T05:17:18.000Z</published>
    <updated>2017-06-20T06:24:06.000Z</updated>
    <content type="html"><![CDATA[<p>现在 Go 1.9 beta版已发布， 正式版预期在8月初发布，让我们先来看看你Go 1.9带来了那些新特性。</p>
<a id="more"></a>
<h3 id="type_alias">type alias</h3>
<p>类型别名原本在1.8中加入的，但是临时发现有些问题，为了能全面的设计 <code>type alias</code> 被移到了 Go 1.9中了。</p>
<p>这个特性主要用在类型从一个package移动到另外一个package中的时候，导致的项目中对引入的路径不一致导致的问题， 比如原先 <code>context</code>是在<code>golang.org／x/net/context</code>包下，在Go 1.7中菜正式移到标准库<code>context</code>。</p>
<p>相关的issue: <a href="https://github.com/golang/go/issues/16339" target="_blank" rel="external">go#16339</a> <a href="https://github.com/golang/go/issues/18130" target="_blank" rel="external">go#18130</a><br>提案: <a href="https://github.com/golang/proposal/blob/master/design/18130-type-alias.md" target="_blank" rel="external">type alias</a></p>
<h3 id="并发map">并发map</h3>
<p>在Go 1.6之前， 内置的<code>map</code>类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<p>群众的呼声是响亮的，并发map在项目中大量使用，所以Go 1.9中在包<code>sync</code>加入了新的map， 查询、存储和删除都是平均常数时间，可以并发访问。</p>
<h3 id="Monotonic_Time">Monotonic Time</h3>
<p>先前的<code>time</code>包的实现都是基于<code>wall time</code>的，但是当机器的时钟调整后会有问题。 比如在计算duration的时候，如果时钟往回拨，可能导致end时间比start时间还早。</p>
<p>所以Go 1.9使用<code>monotonic Time</code>来实现大部分的<code>time</code>中的函数，在计算duration的时候不会出现因为时钟调整出现的误差了。</p>
<p>设计文档: <a href="https://github.com/golang/proposal/blob/master/design/12914-monotonic.md" target="_blank" rel="external">monotonic time</a></p>
<h3 id="位处理操作">位处理操作</h3>
<p>新增加了<code>math/bits</code>包， 提供了很多位运算的函数。</p>
<h3 id="Test_Helper函数">Test Helper函数</h3>
<p>新加｀(<em>T).Helper<code>和</code>(</em>B).Helper m｀， 用来标记调用的函数是一个测试辅助函数，当输出文件名和行数的时候，这个函数回呗忽略。</p>
<h3 id="标准库的微小改动">标准库的微小改动</h3>
<p>标准库也有一些小的功能的加入和提升， 比如<code>image</code>、<code>net</code>、<code>runtime</code>、<code>sync</code>等。</p>
<h3 id="并行编译">并行编译</h3>
<p>支持并行地编译函数，并且在Go 1.9中势默认设置。如果不想并行编译，设置GO19CONCURRENTCOMPILATION为0。</p>
<h3 id="-/-_会忽略vendor下的包">./... 会忽略vendor下的包</h3>
<p>这一条很有用，以后你在Makefile中可以直接使用<code>./...</code>,而不是曲折地将vendor文件夹排除。</p>
<p>如果你想使用vendor下的包， 可以使用<code>./vendor/...</code>通配符。</p>
<h3 id="性能提升">性能提升</h3>
<p>性能提升多少势很难精确描述的，对于大部分的程序，应该运行更快一点。</p>
<p>主要在于垃圾回收器的优化、更好的生成的代码以及核心库的优化。</p>
<p>完整的信息可以参考 <a href="https://golang.org/doc/go1.9" target="_blank" rel="external">Tip Go 1.9 Release Notes</a>, Go 1.9发布后可以访问<a href="https://golang.org/doc/go1.9" target="_blank" rel="external">Go 1.9 Release Notes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在 Go 1.9 beta版已发布， 正式版预期在8月初发布，让我们先来看看你Go 1.9带来了那些新特性。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]使用os/exec执行命令]]></title>
    <link href="http://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/"/>
    <id>http://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/</id>
    <published>2017-06-19T07:28:52.000Z</published>
    <updated>2017-06-19T09:30:37.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="external">Advanced command execution in Go with os/exec</a> by Krzysztof Kowalczyk.<br>完整代码在作者的github上： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec" target="_blank" rel="external">advanced-exec</a></p>
<p>Go可以非常方便地执行外部程序，让我们开始探索之旅吧。</p>
<a id="more"></a>
<h3 id="执行命令并获得输出结果">执行命令并获得输出结果</h3>
<p>最简单的例子就是运行<code>ls -lah</code>并获得组合在一起的stdout/stderr输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	out, err := cmd.CombinedOutput()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	fmt.Printf(<span class="string">"combined out:\n%s\n"</span>, <span class="typename">string</span>(out))</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="将stdout和stderr分别处理">将stdout和stderr分别处理</h3>
<p>和上面的例子类似，只不过将stdout和stderr分别处理。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func main() {</div><div class="line">	cmd := exec.<span class="type">Command</span>(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	<span class="keyword">var</span> <span class="literal">stdout</span>, <span class="literal">stderr</span> bytes.<span class="type">Buffer</span></div><div class="line">	cmd.<span class="type">Stdout</span> = &<span class="literal">stdout</span></div><div class="line">	cmd.<span class="type">Stderr</span> = &<span class="literal">stderr</span></div><div class="line">	err := cmd.<span class="type">Run</span>()</div><div class="line">	<span class="keyword">if</span> err != <span class="keyword">nil</span> {</div><div class="line">		log.<span class="type">Fatalf</span>(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="type">string</span>(<span class="literal">stdout</span>.<span class="type">Bytes</span>()), <span class="type">string</span>(<span class="literal">stderr</span>.<span class="type">Bytes</span>())</div><div class="line">	fmt.<span class="type">Printf</span>(<span class="string">"out:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="命令执行过程中获得输出">命令执行过程中获得输出</h3>
<p>如果一个命令需要花费很长时间才能执行完呢？</p>
<p>除了能获得它的stdout/stderr，我们还希望在控制台显示命令执行的进度。</p>
<p>有点小复杂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> copyAndCapture(w io.Writer, r io.Reader) ([]<span class="typename">byte</span>, error) {</div><div class="line">	<span class="keyword">var</span> out []<span class="typename">byte</span></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>,<span class="number"> 1024</span>)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		n, err := r.Read(buf[:])</div><div class="line">		<span class="keyword">if</span> n &gt;<span class="number"> 0</span> {</div><div class="line">			d := buf[:n]</div><div class="line">			out = <span class="built_in">append</span>(out, d...)</div><div class="line">			os.Stdout.Write(d)</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="comment">// Read returns io.EOF at the end of file, which is not an error for us</span></div><div class="line">			<span class="keyword">if</span> err == io.EOF {</div><div class="line">				err = <span class="constant">nil</span></div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> out, err</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">// never reached</span></div><div class="line">	<span class="built_in">panic</span>(<span class="constant">true</span>)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	<span class="keyword">var</span> stdout, stderr []<span class="typename">byte</span></div><div class="line">	<span class="keyword">var</span> errStdout, errStderr error</div><div class="line">	stdoutIn, _ := cmd.StdoutPipe()</div><div class="line">	stderrIn, _ := cmd.StderrPipe()</div><div class="line">	cmd.Start()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		stdout, errStdout = copyAndCapture(os.Stdout, stdoutIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		stderr, errStderr = copyAndCapture(os.Stderr, stderrIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	err := cmd.Wait()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> errStdout != <span class="constant">nil</span> || errStderr != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to capture stdout or stderr\n"</span>)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="typename">string</span>(stdout), <span class="typename">string</span>(stderr)</div><div class="line">	fmt.Printf(<span class="string">"\nout:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="命令执行过程中获得输出2">命令执行过程中获得输出2</h3>
<p>上一个方案虽然工作，但是看起来<code>copyAndCapture</code>好像重新实现了<code>io.Copy</code>。由于Go的接口的功能，我们可以重用<code>io.Copy</code>。</p>
<p>我们写一个<code>CapturingPassThroughWriter</code>struct，它实现了<code>io.Writer</code>接口。它会捕获所有的数据并写入到底层的<code>io.Writer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CapturingPassThroughWriter is a writer that remembers</span></div><div class="line"><span class="comment">// data written to it and passes it to w</span></div><div class="line"><span class="keyword">type</span> CapturingPassThroughWriter <span class="keyword">struct</span> {</div><div class="line">	buf bytes.Buffer</div><div class="line">	w io.Writer</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// NewCapturingPassThroughWriter creates new CapturingPassThroughWriter</span></div><div class="line"><span class="keyword">func</span> NewCapturingPassThroughWriter(w io.Writer) *CapturingPassThroughWriter {</div><div class="line">	<span class="keyword">return</span> &CapturingPassThroughWriter{</div><div class="line">		w: w,</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (w *CapturingPassThroughWriter) Write(d []<span class="typename">byte</span>) (<span class="typename">int</span>, error) {</div><div class="line">	w.buf.Write(d)</div><div class="line">	<span class="keyword">return</span> w.w.Write(d)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Bytes returns bytes written to the writer</span></div><div class="line"><span class="keyword">func</span> (w *CapturingPassThroughWriter) Bytes() []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">return</span> w.buf.Bytes()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> errStdout, errStderr error</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	stdoutIn, _ := cmd.StdoutPipe()</div><div class="line">	stderrIn, _ := cmd.StderrPipe()</div><div class="line">	stdout := NewCapturingPassThroughWriter(os.Stdout)</div><div class="line">	stderr := NewCapturingPassThroughWriter(os.Stderr)</div><div class="line">	err := cmd.Start()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Start() failed with '%s'\n"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStdout = io.Copy(stdout, stdoutIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStderr = io.Copy(stderr, stderrIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	err = cmd.Wait()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> errStdout != <span class="constant">nil</span> || errStderr != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to capture stdout or stderr\n"</span>)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="typename">string</span>(stdout.Bytes()), <span class="typename">string</span>(stderr.Bytes())</div><div class="line">	fmt.Printf(<span class="string">"\nout:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="命令执行过程中获得输出3">命令执行过程中获得输出3</h3>
<p>事实上Go标准库包含一个更通用的<code>io.MultiWriter</code>,我们可以直接使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> stdoutBuf, stderrBuf bytes.Buffer</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line"></div><div class="line">	stdoutIn, _ := cmd.StdoutPipe()</div><div class="line">	stderrIn, _ := cmd.StderrPipe()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> errStdout, errStderr error</div><div class="line">	stdout := io.MultiWriter(os.Stdout, &stdoutBuf)</div><div class="line">	stderr := io.MultiWriter(os.Stderr, &stderrBuf)</div><div class="line">	err := cmd.Start()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Start() failed with '%s'\n"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStdout = io.Copy(stdout, stdoutIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStderr = io.Copy(stderr, stderrIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	err = cmd.Wait()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> errStdout != <span class="constant">nil</span> || errStderr != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(<span class="string">"failed to capture stdout or stderr\n"</span>)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="typename">string</span>(stdoutBuf.Bytes()), <span class="typename">string</span>(stderrBuf.Bytes())</div><div class="line">	fmt.Printf(<span class="string">"\nout:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>自己实现是很好滴，但是熟悉标准库并使用它更好。</p>
<h3 id="改变执行程序的环境(environment)">改变执行程序的环境(environment)</h3>
<p>你已经知道了怎么在程序中获得环境变量，对吧： ｀os.Environ()｀返回所有的环境变量<code>[]string</code>,每个字符串以<code>FOO=bar</code>格式存在。<code>FOO</code>是环境变量的名称，<code>bar</code>是环境变量的值， 也就是<code>os.Getenv(&quot;FOO&quot;)</code>的返回值。</p>
<p>有时候你可能想修改执行程序的环境。</p>
<p>你可设置<code>exec.Cmd</code>的<code>Env</code>的值，和<code>os.Environ()</code>格式相同。通常你不会构造一个全新的环境，而是添加自己需要的环境变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   cmd := exec.Command(<span class="string">"programToExecute"</span>)</div><div class="line">additionalEnv := <span class="string">"FOO=bar"</span></div><div class="line">newEnv := <span class="built_in">append</span>(os.Environ(), additionalEnv))</div><div class="line">cmd.Env = newEnv</div><div class="line">out, err := cmd.CombinedOutput()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">}</div><div class="line">fmt.Printf(<span class="string">"%s"</span>, out)</div></pre></td></tr></table></figure>

<p>包 <a href="https://godoc.org/github.com/shurcooL/go/osutil#Environ" target="_blank" rel="external">shurcooL/go/osutil</a>提供了便利的方法设置环境变量。</p>
<h3 id="预先检查程序是否存在">预先检查程序是否存在</h3>
<p>想象一下你写了一个程序需要花费很长时间执行，再最后你调用<code>foo</code>做一些基本的任务。</p>
<p>如果<code>foo</code>程序不存在，程序会执行失败。</p>
<p>当然如果我们预先能检查程序是否存在九完美了，如果不存在久打印错误信息。</p>
<p>你可以调用<code>exec.LookPath</code>方法来检查：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> checkLsExists() {</div><div class="line">	path, err := exec.LookPath(<span class="string">"ls"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"didn't find 'ls' executable\n"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"'ls' executable is in '%s'\n"</span>, path)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个检查的办法就是让程序执行一个空操作， 比如传递参数&quot;--help&quot;显示帮助信息。</p>
<p>下面的章节是<a href="http://colobu.com" target="_blank" rel="external">译者</a>补充的内容</p>
<h3 id="管道">管道</h3>
<p>我们可以使用管道将多个命令串联起来， 上一个命令的输出是下一个命令的输入。</p>
<p>使用<code>os.Exec</code>有点麻烦，你可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"bytes"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    c1 := exec.Command(<span class="string">"ls"</span>)</div><div class="line">    c2 := exec.Command(<span class="string">"wc"</span>, <span class="string">"-l"</span>)</div><div class="line"></div><div class="line">    r, w := io.Pipe() </div><div class="line">    c1.Stdout = w</div><div class="line">    c2.Stdin = r</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b2 bytes.Buffer</div><div class="line">    c2.Stdout = &b2</div><div class="line"></div><div class="line">    c1.Start()</div><div class="line">    c2.Start()</div><div class="line">    c1.Wait()</div><div class="line">    w.Close()</div><div class="line">    c2.Wait()</div><div class="line">    io.Copy(os.Stdout, &b2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者直接使用<code>Cmd</code>的<code>StdoutPipe</code>方法，而不是自己创建一个io.Pipe`。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    c1 := exec.Command(<span class="string">"ls"</span>)</div><div class="line">    c2 := exec.Command(<span class="string">"wc"</span>, <span class="string">"-l"</span>)</div><div class="line">    c2.Stdin, _ = c1.StdoutPipe()</div><div class="line">    c2.Stdout = os.Stdout</div><div class="line">    _ = c2.Start()</div><div class="line">    _ = c1.Run()</div><div class="line">    _ = c2.Wait()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="管道2">管道2</h3>
<p>上面的解决方案是Go风格的解决方案，事实上你还可以用一个&quot;Trick&quot;来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cmd := <span class="string">"cat /proc/cpuinfo | egrep '^model name' | uniq | awk '{print substr($0, index($0,$4))}'"</span></div><div class="line">	out, err := exec.Command(<span class="string">"bash"</span>, <span class="string">"-c"</span>, cmd).Output()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"Failed to execute command: %s"</span>, cmd)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(<span class="typename">string</span>(out))</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="external">Advanced command execution in Go with os/exec</a> by Krzysztof Kowalczyk.<br>完整代码在作者的github上： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec" target="_blank" rel="external">advanced-exec</a></p>
<p>Go可以非常方便地执行外部程序，让我们开始探索之旅吧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[突破限制,访问其它Go package中的私有函数]]></title>
    <link href="http://colobu.com/2017/05/12/call-private-functions-in-other-packages/"/>
    <id>http://colobu.com/2017/05/12/call-private-functions-in-other-packages/</id>
    <published>2017-05-12T07:09:50.000Z</published>
    <updated>2017-05-18T10:20:35.000Z</updated>
    <content type="html"><![CDATA[<p>熟悉C++、Java、C#等面向对象的编程语言的同学，在学习Go语言的过程中，经常会被访问权限所困扰，逐渐才能了解这样一个事实：</p>
<p><strong> Go语言通过<code>identifier</code>的首字母是否大写来决定它是否可以被其它package所访问。</strong></p>
<p>正式的Go语言规范是这么规定的：</p>
<blockquote>
<p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p>
<p>the first character of the identifier&#39;s name is a Unicode upper case letter (Unicode class &quot;Lu&quot;); and<br>the identifier is declared in the package block or it is a field name or method name.</p>
<p>All other identifiers are not exported.</p>
</blockquote>
<p>这个Go语言规范定义的访问权限控制方法。</p>
<a id="more"></a>
<p>但是有没有办法突破这个限制呢？</p>
<p>突破可以从两个方向来讨论： 将<code>exported</code>类型变为其它package不可访问；将<code>unexported</code>的类型变为其它package可访问。</p>
<h3 id="将exported类型变为其它package不可访问">将<code>exported</code>类型变为其它package不可访问</h3>
<p>至少有一个办法可以将package中 exported的函数、类型变为其它package不可访问， 那就是定义一个<code>internal</code> package,将这些package放在<code>internal</code> package之下。</p>
<p>Go语言本身没有这个限制，这是通过<code>go</code>命令实现的。最早这个特性是在 <a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="external">go 1.4</a>版本中引入的，相关的细节可以查看文档： <a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit" target="_blank" rel="external">design document</a></p>
<p>这个规则是这样的：</p>
<blockquote>
<p>An import of a path containing the element “internal” is disallowed if the importing code is outside the tree rooted at the parent of the “internal” directory.</p>
</blockquote>
<p>也就是<code>internal</code>包下的 exported 类型只能由internal所在的package (internal的parent)为root的package所访问。</p>
<p>举例来说：</p>
<ul>
<li><code>/a/b/c/internal/d/e/f</code> 可以被<code>/a/b/c</code> import， 不能被 <code>/a/b/g</code> import.</li>
<li><code>$GOROOT/src/pkg/internal/xxx</code>只可以被标准库import ($GOROOT/src/).</li>
<li><code>$GOROOT/src/pkg/net/http/internal</code> 只可以被 <code>net/http</code> 和 <code>net/http/*</code> import.</li>
<li><code>$GOPATH/src/mypkg/internal/foo</code> 只能被<code>$GOPATH/src/mypkg</code> import.</li>
</ul>
<h3 id="访问其它package中的私有方法">访问其它package中的私有方法</h3>
<p>如果你查看 Go 标准库的的代码， 比如 <a href="https://github.com/golang/go/blob/master/src/time/sleep.go" target="_blank" rel="external">time/sleep.go</a> 文件， 你会发现一些奇怪的函数， 如 <code>Sleep</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Sleep(d Duration)</div></pre></td></tr></table></figure>

<p>这个函数我们经常会用到， 也就是<code>time.Sleep</code>函数，但是这个函数并没有函数体，而且同样的目录下也没有汇编语言的代码实现，那么，这个函数在哪里定义的？</p>
<p>依照<a href="https://golang.org/ref/spec#Function_declarations" target="_blank" rel="external">规范</a>，一个只有函数声明的函数是在Go的外部实现的，我们称之为<code>external function</code>。</p>
<p>实际上，这个&quot;外部函数&quot;也是在Go标准库中实现的，它是 runtime中的一个 unexported的函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:linkname timeSleep time.Sleep</span></div><div class="line"><span class="keyword">func</span> timeSleep(ns <span class="typename">int64</span>) {</div><div class="line">	<span class="keyword">if</span> ns &lt;=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	t := getg().timer</div><div class="line">	<span class="keyword">if</span> t == <span class="constant">nil</span> {</div><div class="line">		t = <span class="built_in">new</span>(timer)</div><div class="line">		getg().timer = t</div><div class="line">	}</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>事实上，runtime为其它 package中定义了很多的函数，比如<code>sync</code>、<code>net</code>中的一些函数，你可以通过命令<code>grep linkname /usr/local/go/src/runtime/*.go</code>查找这些函数。</p>
<p>我们会有两个疑问：一是为什么这些函数要定义在 runtime package中，而是这个机制到底是怎么实现的？</p>
<p>将相关的函数定义在<code>runtime</code>中的好处是， 它们可以访问 runtime package中 unexported的类型， 比如<code>getp</code>函数等，相当于往 runtime package打入一个&quot;叛徒&quot;,通过&quot;叛徒&quot;可以访问 runtime package 的私有对象。同时，这些&quot;叛徒&quot;函数尽管被声明为unexported,还是可以在其它package中访问。</p>
<p>第二个问题，其实是Go的<code>go:linkname</code>这个指令发挥的作用,它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:linkname localname importpath.name</span></div></pre></td></tr></table></figure>

<p><a href="https://golang.org/cmd/compile/" target="_blank" rel="external">Go文档</a>说明了这个指令的作用：</p>
<blockquote>
<p>The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported &quot;unsafe&quot;.</p>
</blockquote>
<p>这个指令告诉编译器为函数或者变量<code>localname</code>使用<code>importpath.name</code>作为目标文件的符号名。因为这个指令破坏了类型系统和包的模块化，所以它只能在 import &quot;unsafe&quot; 的情况下才能使用。</p>
<p><code>importpath.name</code>可以是这种格式:<code>a/b/c/d/apkg.foo</code>，这样在package <code>a/b/c/d/apkg</code>中就可以使用这个函数<code>foo</code>了。</p>
<p>举个例子,假设我们的package布局如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├── <span class="keyword">a</span></div><div class="line">│   └── <span class="keyword">a</span>.<span class="keyword">go</span></div><div class="line">├── <span class="keyword">b</span></div><div class="line">│   ├── <span class="keyword">b</span>.<span class="keyword">go</span></div><div class="line">│   └── internal.<span class="keyword">s</span></div><div class="line">└── main</div><div class="line">    └── main.<span class="keyword">go</span></div></pre></td></tr></table></figure>

<p>package <strong>a</strong> 定义了私有的方法,并加上 <code>go:linkname</code>指令， package <strong>b</strong> 可以调用 package <strong>a</strong>的私有方法。 <strong>main.go</strong> 测试访问 <strong>b</strong>中的函数。</p>
<p>首先看看<code>a.go</code>中的实现：</p>
<figure class="highlight go"><figcaption><span>a.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> a</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//go:linkname say a.say</span></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> say(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> <span class="string">"hello, "</span> + name</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname say2 github.com/smallnest/private/b.Hi</span></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> say2(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> <span class="string">"hi, "</span> + name</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定义了两个方法，符号名分别为<code>a.say</code>和<code>github.com/smallnest/private/b.Hi</code>。</p>
<p>这个不同的符号名的方式会影响<strong>b</strong>中的使用。</p>
<figure class="highlight go"><figcaption><span>b.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> b</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"unsafe"</span></div><div class="line"></div><div class="line">	_ <span class="string">"github.com/smallnest/private/a"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//go:linkname say a.say</span></div><div class="line"><span class="keyword">func</span> say(name <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> Greet(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> say(name)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Hi(name <span class="typename">string</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>在<strong>b</strong> 中，如果想使用符号<code>a.say</code>，你还是需要<code>go:linkname</code>,告诉编译器这个函数的符号为<code>a.say</code>。对于<code>Hi</code>函数， 我们不需要<code>go:linkname</code>指令，因为在<code>a.go</code>中我们定义的符号名称<strong>恰巧</strong>就是这个<code>package.funcname</code>。</p>
<p>注意，你需要引入package <code>unsafe</code>,并且在<strong>b.go</strong>还需要import package a.</p>
<p>你可以在<code>main.go</code>中调用<strong>b</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/smallnest/private/b"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := b.Greet(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(s)</div><div class="line">	s = b.Hi(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，如果你<code>go  run main.go</code>,你不会得到正确的结果，而是会出错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">main <span class="keyword">go</span> run main.<span class="keyword">go</span></div><div class="line"># github.com/smallnest/private/b</div><div class="line">../b/b.<span class="keyword">go</span><span class="number">:10</span>: missing function body <span class="keyword">for</span> <span class="string">"say"</span></div><div class="line">../b/b.<span class="keyword">go</span><span class="number">:16</span>: missing function body <span class="keyword">for</span> <span class="string">"Hi"</span></div></pre></td></tr></table></figure>

<p>难道我们前面讲的都是错的吗？</p>
<p>这里有一个技巧，你在 package b下创建一个空的文件， w文件名随意，只要文件后缀为<code>.s</code>，再运行一下<code>go  run main.go</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main go run main.go</div><div class="line">hello, world</div><div class="line">hi, world</div></pre></td></tr></table></figure>

<p>原因在于Go在编译的时候会启用<code>-complete</code>编译器flag,它要求所有的函数必需包含函数体。创建一个空的汇编语言文件绕过这个限制。</p>
<p>当然， 一般情况下我们不会用到本文所列出的两种突破方式，只有在很稀少的情况下，为了更好地组织我们的代码，我们才会有选择的采用这两种方法。至少，作为一个Go开发者，你会记住有两种突破方法，可以打破Go语言规范中关于权限的限制。</p>
<h3 id="访问其它package中的struct_私有字段">访问其它package中的struct 私有字段</h3>
<p>再额外附送一个技巧， 可以访问其它package struct的私有字段。</p>
<p>当然正常情况下struct的私有字段并没有export，所以在其它package是不能正常访问。通过使用<code>refect</code>,可以访问struct的私有字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/private/c"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> ChangeFoo(f *c.Foo) {</div><div class="line">	v := reflect.ValueOf(f)</div><div class="line">	x := v.Elem().FieldByName(<span class="string">"x"</span>)</div><div class="line">	fmt.Println(x.Int())</div><div class="line">	<span class="comment">//panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span></div><div class="line">	<span class="comment">//x.SetInt(100)</span></div><div class="line">	fmt.Println(x.Int())</div><div class="line"></div><div class="line">	y := v.Elem().FieldByName(<span class="string">"Y"</span>)</div><div class="line">	y.SetString(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(f.Y)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是你不能设置私有字段的值，否则会panic,这是因为<code>SetXXX</code>会首先使用<code>v.mustBeAssignable()</code>检查字段是否是exported的。</p>
<p>当然，还可以通过&quot;指针&quot;的方式获取字段的地址，通过地址获取数据或者设置数据。<br>还是用相同的例子：</p>
<figure class="highlight go"><figcaption><span>c.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c</div><div class="line"></div><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</div><div class="line">	x <span class="typename">int</span></div><div class="line">	Y <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (f Foo) X() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> f.x</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> New(x <span class="typename">int</span>, y <span class="typename">string</span>) *Foo {</div><div class="line">	<span class="keyword">return</span> &Foo{x: x, Y: y}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在package d中访问：</p>
<figure class="highlight go"><figcaption><span>d.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> d</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"unsafe"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/private/c"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> ChangeFoo(f *c.Foo) {</div><div class="line">	p := unsafe.Pointer(f)</div><div class="line">	<span class="comment">// 事先获取或者通过 reflect获得</span></div><div class="line">	<span class="comment">// 本例中是第一个字段，所以offset=0</span></div><div class="line">	offset := <span class="typename">uintptr</span><span class="number">(0</span>)</div><div class="line">	ptr2x := (*<span class="typename">int</span>)(unsafe.Pointer(<span class="typename">uintptr</span>(p) + offset))</div><div class="line">	fmt.Println(*ptr2x)</div><div class="line">	*ptr2x =<span class="number"> 100</span></div><div class="line">	fmt.Println(f.X())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="更hack的方法">更hack的方法</h3>
<p>如果你还不满足，那么我再赠送一个更hack的方法，但是这个也有点限制，就是你腰调用的方法应该在之前的某处调用过。</p>
<p>这是 Alan Pierce 提供了一个方法。<a href="https://golang.org/src/runtime/symtab.go" target="_blank" rel="external">runtime/symtab.go</a>中保存了符号表，通过一些技巧(<code>go:linkname</code>),能访问它的私有方法，查找到想要调用的函数，然后就可以调用了，Alan将相关的代码写成了一个库，方便调用：<a href="https://github.com/alangpierce/go-forceexport" target="_blank" rel="external">go-forceexport</a>。</p>
<p>使用方法如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timeNow <span class="keyword">func</span>() (<span class="typename">int64</span>, <span class="typename">int32</span>)</div><div class="line">err := forceexport.GetFunc(&timeNow, <span class="string">"time.now"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// Handle errors if you care about name possibly being invalid.</span></div><div class="line">}</div><div class="line"><span class="comment">// Calls the actual time.now function.</span></div><div class="line">sec, nsec := timeNow()</div></pre></td></tr></table></figure>

<p>我在使用的过程中发现只有相应的方法在某处调用过, 符号表中才有这个函数的信息， <code>forceexport.GetFunc</code>才会返回对应的函数。</p>
<p>另外，这是一个非常hack的方式，不保证Go将来的版本是否还能使用，仅供嬉戏之用，慎用在产品代码中。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="https://golang.org/cmd/compile/" target="_blank" rel="external">https://golang.org/cmd/compile/</a></li>
<li><a href="https://github.com/golang/go/issues/15006" target="_blank" rel="external">https://github.com/golang/go/issues/15006</a></li>
<li><a href="https://siadat.github.io/post/golinkname" target="_blank" rel="external">https://siadat.github.io/post/golinkname</a></li>
<li><a href="https://sitano.github.io/2016/04/28/golang-private/" target="_blank" rel="external">https://sitano.github.io/2016/04/28/golang-private/</a></li>
<li><a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="external">https://golang.org/doc/go1.4#internalpackages</a></li>
<li><a href="http://www.alangpierce.com/blog/2016/03/17/adventures-in-go-accessing-unexported-functions/" target="_blank" rel="external">http://www.alangpierce.com/blog/2016/03/17/adventures-in-go-accessing-unexported-functions/</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/ppGGazd9KXI" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/ppGGazd9KXI</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>熟悉C++、Java、C#等面向对象的编程语言的同学，在学习Go语言的过程中，经常会被访问权限所困扰，逐渐才能了解这样一个事实：</p>
<p><strong> Go语言通过<code>identifier</code>的首字母是否大写来决定它是否可以被其它package所访问。</strong></p>
<p>正式的Go语言规范是这么规定的：</p>
<blockquote>
<p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p>
<p>the first character of the identifier&#39;s name is a Unicode upper case letter (Unicode class &quot;Lu&quot;); and<br>the identifier is declared in the package block or it is a field name or method name.</p>
<p>All other identifiers are not exported.</p>
</blockquote>
<p>这个Go语言规范定义的访问权限控制方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]通过 raft 的 leader lease 来解决集群脑裂时的 stale read 问题]]></title>
    <link href="http://colobu.com/2017/05/08/raft-and-network-partitions/"/>
    <id>http://colobu.com/2017/05/08/raft-and-network-partitions/</id>
    <published>2017-05-08T08:29:12.000Z</published>
    <updated>2017-05-08T08:36:28.000Z</updated>
    <content type="html"><![CDATA[<p>PingCap联合创始人、CTO 黄东旭写的一篇解决Raft网络分区的一种方案: <a href="https://pingcap.com/blog-stale-read-zh" target="_blank" rel="external">通过 raft 的 leader lease 来解决集群脑裂时的 stale read 问题</a>。本文转载之。</p>
<p><strong>问题</strong>： 当 raft group 发生脑裂的情况下，老的 raft leader 可能在一段时间内并不知道新的 leader 已经被选举出来，这时候客户端在老的 leader 上可能会读取出陈旧的数据（stale read）。 比如，我们假想一个拥有 5 个节点的 raft group:</p>
<a id="more"></a>
<p><img src="1.png" alt=""></p>
<p>其中 <strong>Node 5</strong> 是当前的 raft leader，当出现网络分区时，在 Node 5 的 raft lease 任期还没结束的一段时间内，Node 5 仍然认为自己是当前 term 的 leader，但是此时，另外一边分区已经在新的 term 中选出了新的 leader。</p>
<p><img src="2.png" alt=""></p>
<p>如果此时，客户端在新的 leader 上更新了某个值 x，此时是可以更新成功的（因为还是可以复制到多数派）。但是在分区的另一端，此时一个客户端去读取 x 的值，Node 5 还会返回老的值，这样就发生了 <strong>stale read</strong>。</p>
<p><strong>解决方案</strong>:</p>
<p>引入一个新的概念, <strong>region leader</strong>。region leader 是一个逻辑上的概念, 任意时刻对于某一个 region 来说, 一定只拥有一个 region leader, 每个 region leader 在任期之内尝试每隔 t 时间间隔, 在 raft group 内部更新一下 region leader 的 lease. 所有的读写请求都必须通过 region leader 完成， 但是值得注意的是， region leader 和 raft leader 可能不是一个节点，当 region leader 和 raft leader 不重合的时候，region leader 会将请求转发给当前的 raft leader，当网络出现分区时，会出现以下几种情况：</p>
<ol>
<li>region leader 落在多数派，老 raft leader 在多数派这边</li>
<li>region leader 落在多数派，老 raft leader 在少数派这边</li>
<li>region leader 落在少数派，老 raft leader 在多数派这边</li>
<li>region leader 落在少数派，老 raft leader 在少数派这边</li>
</ol>
<p>用开篇的例子来分情况讨论：</p>
<p>对于第一种情况，region leader 的 lease 不会过期，因为 region leader 的心跳仍然能更新到多数派的节点上，老的 raft leader 仍然能同步到大多数节点上，少数派这边也不会选举出新的 leader， 这种情况下不会出现 stale read。</p>
<p><img src="4.png" alt=""></p>
<p>第二种情况，就是开篇提到会出现 stale read 的典型情况，老的 raft leader 被分到了少数派这边，多数派这边选举出了新的 raft leader ，如果此时的 region leader 在多数派这边。</p>
<p><img src="5.png" alt=""></p>
<p>因为所有的读写请求都会找到 region leader 进行，即使在原来没有出现网络分区的情况下，客户端的请求也都是要走 node 1 ，经由 node 1 转发给 node 5，客户端不会直接访问 node 5，所以此时即使网络出现分区，新 leader 也正好在多数派这边，读写直接就打到 node 1 上，皆大欢喜，没有 stale read。</p>
<p>第三种情况，region leader 落在少数派这边，老 raft leader 在多数派这边，这种情况客户端的请求找到 region leader，他发现的无法联系到 leader（因为在少数派这边没有办法选举出新的 leader），请求会失败，直到本次 region leader 的 lease 过期，同时新的 region leader 会在多数派那边产生（因为新的 region leader 需要尝试走一遍 raft 流程）。因为老的 region leader 没办法成功的写入，所以也不会出现 stale read。但是付出的代价是在 region leader lease 期间的系统的可用性。</p>
<p>第四种情况和第三种情况类似，多数派这边会产生新的 raft leader 和 region leader。</p>
<p>总体来说，这种方法牺牲了一定的可用性（在脑裂时部分客户端的可用性）换取了一致性的保证。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>PingCap联合创始人、CTO 黄东旭写的一篇解决Raft网络分区的一种方案: <a href="https://pingcap.com/blog-stale-read-zh" target="_blank" rel="external">通过 raft 的 leader lease 来解决集群脑裂时的 stale read 问题</a>。本文转载之。</p>
<p><strong>问题</strong>： 当 raft group 发生脑裂的情况下，老的 raft leader 可能在一段时间内并不知道新的 leader 已经被选举出来，这时候客户端在老的 leader 上可能会读取出陈旧的数据（stale read）。 比如，我们假想一个拥有 5 个节点的 raft group:</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Golang调度器源码分析]]></title>
    <link href="http://colobu.com/2017/05/04/golang-runtime-scheduler/"/>
    <id>http://colobu.com/2017/05/04/golang-runtime-scheduler/</id>
    <published>2017-05-04T11:27:25.000Z</published>
    <updated>2017-05-04T11:37:10.000Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html" target="_blank" rel="external">Golang调度器源码分析</a>, 作者: 无心之祸<br><a id="more"></a></p>
<h3 id="为什么Golang需要调度器？">为什么Golang需要调度器？</h3>
<p>Goroutine的引入是为了方便高并发程序的编写。 一个Goroutine在进行阻塞操作（比如系统调用）时，会把当前线程中的其他Goroutine移交到其他线程中继续执行， 从而避免了整个程序的阻塞。</p>
<p>由于Golang引入了垃圾回收（gc），在执行gc时就要求Goroutine是停止的。通过自己实现调度器，就可以方便的实现该功能。 通过多个Goroutine来实现并发程序，既有异步IO的优势，又具有多线程、多进程编写程序的便利性。</p>
<p>引入Goroutine，也意味着引入了极大的复杂性。一个Goroutine既要包含要执行的代码， 又要包含用于执行该代码的栈和PC、SP指针。</p>
<h3 id="调度器解决了什么问题？">调度器解决了什么问题？</h3>
<h4 id="栈管理">栈管理</h4>
<p>既然每个Goroutine都有自己的栈，那么在创建Goroutine时，就要同时创建对应的栈。 Goroutine在执行时，栈空间会不停增长。 栈通常是连续增长的，由于每个进程中的各个线程共享虚拟内存空间，当有多个线程时，就需要为每个线程分配不同起始地址的栈。 这就需要在分配栈之前先预估每个线程栈的大小。如果线程数量非常多，就很容易栈溢出。</p>
<p>为了解决这个问题，就有了Split Stacks技术： 创建栈时，只分配一块比较小的内存，如果进行某次函数调用导致栈空间不足时，就会在其他地方分配一块新的栈空间。 新的空间不需要和老的栈空间连续。函数调用的参数会拷贝到新的栈空间中，接下来的函数执行都在新栈空间中进行。</p>
<p>Golang的栈管理方式与此类似，但是为了更高的效率，使用了连续栈 （Golang连续栈） 实现方式也是先分配一块固定大小的栈，在栈空间不足时，分配一块更大的栈，并把旧的栈全部拷贝到新栈中。 这样避免了Split Stacks方法可能导致的频繁内存分配和释放。</p>
<h4 id="抢占式调度">抢占式调度</h4>
<p>Goroutine的执行是可以被抢占的。如果一个Goroutine一直占用CPU，长时间没有被调度过， 就会被runtime抢占掉，把CPU时间交给其他Goroutine。</p>
<h3 id="调度器的设计">调度器的设计</h3>
<p>Golang调度器引入了三个结构来对调度的过程建模：</p>
<ul>
<li>G 代表一个Goroutine；</li>
<li>M 代表一个操作系统的线程；</li>
<li>P 代表一个CPU处理器，通常P的数量等于CPU核数（GOMAXPROCS）。</li>
</ul>
<p>三者都在runtime2.go中定义，他们之间的关系如下：</p>
<ul>
<li>G需要绑定在M上才能运行；</li>
<li>M需要绑定P才能运行；</li>
<li>程序中的多个M并不会同时都处于执行状态，最多只有GOMAXPROCS个M在执行。</li>
</ul>
<p>早期版本的Golang是没有P的，调度是由G与M完成。 这样的问题在于每当创建、终止Goroutine或者需要调度时，需要一个全局的锁来保护调度的相关对象(sched)。 全局锁严重影响Goroutine的并发性能。 (<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit" target="_blank" rel="external">Scalable Go Scheduler</a>)</p>
<p>通过引入P，实现了一种叫做work-stealing的调度算法：</p>
<ul>
<li>每个P维护一个G队列；</li>
<li>当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；</li>
<li>当一个G执行结束时，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， 就随机选择另外一个P，从其可执行的G队列中偷取一半。</li>
</ul>
<p>该算法避免了在Goroutine调度时使用全局锁。</p>
<h3 id="调度器的实现">调度器的实现</h3>
<h4 id="schedule()与findrunnable()函数">schedule()与findrunnable()函数</h4>
<p>Goroutine调度是在P中进行，每当runtime需要进行调度时，会调用schedule()函数， 该函数在proc1.go文件中定义。</p>
<p>schedule()函数首先调用runqget()从当前P的队列中取一个可以执行的G。 如果队列为空，继续调用findrunnable()函数。findrunnable()函数会按照以下顺序来取得G：</p>
<ol>
<li>调用runqget()从当前P的队列中取G（和schedule()中的调用相同）；</li>
<li>调用globrunqget()从全局队列中取可执行的G；</li>
<li>调用netpoll()取异步调用结束的G，该次调用为非阻塞调用，直接返回；</li>
<li>调用runqsteal()从其他P的队列中“偷”。</li>
</ol>
<p>如果以上四步都没能获取成功，就继续执行一些低优先级的工作：</p>
<ol>
<li>如果处于垃圾回收标记阶段，就进行垃圾回收的标记工作；</li>
<li>再次调用globrunqget()从全局队列中取可执行的G；</li>
<li>再次调用netpoll()取异步调用结束的G，该次调用为阻塞调用。</li>
</ol>
<p>如果还没有获得G，就停止当前M的执行，返回findrunnable()函数开头重新执行。 如果findrunnable()正常返回一个G，shedule()函数会调用execute()函数执行该G。 execute()函数会调用gogo()函数（在汇编源文件asm_XXX.s中定义，XXX代表系统架构），gogo() 函数会从G.sched结构中恢复出G上次被调度器暂停时的寄存器现场（SP、PC等），然后继续执行。</p>
<h4 id="如何进行抢占?">如何进行抢占?</h4>
<p>runtime在程序启动时，会自动创建一个系统线程，运行sysmon()函数（在proc1.go中定义）。 sysmon()函数在整个程序生命周期中一直执行，负责监视各个Goroutine的状态、判断是否要进行垃圾回收等。</p>
<p>sysmon()会调用retake()函数，retake()函数会遍历所有的P，如果一个P处于执行状态， 且已经连续执行了较长时间，就会被抢占。retake()调用preemptone()将P的stackguard0设为stackPreempt(关于stackguard的详细内容，可以参考 <a href="https://gcc.gnu.org/wiki/SplitStacks" target="_blank" rel="external">Split Stacks</a>)，这将导致该P中正在执行的G进行下一次函数调用时， 导致栈空间检查失败。进而触发morestack()（汇编代码，位于asm_XXX.s中）然后进行一连串的函数调用，主要的调用过程如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">morestack<span class="function"><span class="params">()</span>（汇编代码）-&gt;</span> newstack<span class="function"><span class="params">()</span> -&gt;</span> gopreempt_m<span class="function"><span class="params">()</span> -&gt;</span> goschedImpl<span class="function"><span class="params">()</span> -&gt;</span> schedule()</div></pre></td></tr></table></figure>

<p>在goschedImpl()函数中，会通过调用dropg()将G与M解除绑定；再调用globrunqput()将G加入全局runnable队列中。最后调用schedule() 来用为当前P设置新的可执行的G。</p>
<p>关于Golang抢占式调度的进一步学习，可以参考 <a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit" target="_blank" rel="external">Go Preemptive Scheduler Design Doc</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html" target="_blank" rel="external">Golang调度器源码分析</a>, 作者: 无心之祸<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go 调度器: M, P 和 G]]></title>
    <link href="http://colobu.com/2017/05/04/go-scheduler/"/>
    <id>http://colobu.com/2017/05/04/go-scheduler/</id>
    <published>2017-05-04T08:32:59.000Z</published>
    <updated>2017-05-04T11:27:42.000Z</updated>
    <content type="html"><![CDATA[<p>这是另一篇关于Go调度器(scheduler)的文章。 原文: <a href="https://povilasv.me/go-scheduler/" target="_blank" rel="external">GO SCHEDULER: MS, PS &amp; GS</a> by Uber工程师 Povilas。</p>
<p>网上已经有很多关于Go调度器的文章了， 比如<a href="http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html" target="_blank" rel="external">Golang调度器源码分析</a>,多看一些，可以加深记忆，也可以对比查看文章中是否有不准确的地方,更全面的了解Go的调度器。</p>
<p>我决定深入了解Go的内部机制， 因为很长时间没人写关于Go scheduler的文章了， 我觉得这是一个很有趣的知识点，所以让我们开始吧。<br><a id="more"></a></p>
<h3 id="基础知识">基础知识</h3>
<p>Go的运行时管理着调度、垃圾回收以及goroutine的运行环境。本文只关注于调度器。</p>
<p>运行时负责运行goroutine并把它们影射到操作系统的线程上。goroutine比线程还轻量， 启动的时候花费很少。每个goroutine都是由一个<strong>G</strong>结构来表示，<br>这个结构体的字段用来跟踪此goroutine的栈(stack)和状态，所以你可以认为<code>G = goroutine</code>。</p>
<p>运行时管理着<strong>G</strong>并把它们映射到<strong>Logical Processor</strong>(称之为<strong>P</strong>). <strong>P</strong>可以看作是一个抽象的资源或者一个上下文，它需要获取以便操作系统线程(称之为<strong>M</strong>)可以运行<strong>G</strong>。</p>
<p>通过<code>runtime.GOMAXPROCS (numLogicalProcessors)</code>可以控制多少<strong>P</strong>可以获取。如果你需要调整这个参数(大部分情况下你无需调整)， 只设置一次， 因为它需要 <code>STW</code> gc pause。</p>
<p>本质上，操作系统运行线程，线程运行你的代码。Go的技巧是编译器会在Go运行时的一些地方插入系统调用， （比如通过channel发送值,调用runtime包等），所以Go可以通知调度器执行特定的操作。</p>
<p><img src="go-runtime.png" alt=""></p>
<p>上图的理解来自 <a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="external">Analysis of the Go runtime scheduler</a></p>
<h3 id="M、P_和_G_之间的交互">M、P 和 G 之间的交互</h3>
<p><strong>M</strong>、<strong>P</strong>和<strong>G</strong>之间的交互有点复杂。看看下面这张来自 Gao Chao的<a href="https://speakerdeck.com/retervision/go-runtime-scheduler" target="_blank" rel="external">go runtime scheduler</a> 幻灯片中的一张图：</p>
<p><img src="go-sched.png" alt=""></p>
<p>可以看到，Go运行时存在两种类型的queue： 一种是一个全局的queue(在<a href="https://github.com/golang/go/blob/5dd978a283ca445f8b5f255773b3904497365b61/src/runtime/runtime2.go#L536" target="_blank" rel="external">schedt结构体中</a>，很少用到)， 一种是每个<strong>P</strong>都维护自己的<strong>G</strong>的queue。</p>
<p>为了运行goroutine, <strong>M</strong>需要持有上下文<strong>P</strong>。<strong>M</strong>会从<strong>P</strong>的queue弹出一个goroutine并执行。</p>
<p>当你创建一个新的goroutine的时候(<code>go func()</code>方法)，它会被放入<strong>P</strong>的queue。当然还有一个 <code>work-stealing</code>调度算法，当<strong>M</strong>执行了一些<strong>G</strong>后,如果它的queue为空，它会随机的选择另外一个<strong>P</strong>,从它的queue中取走一半的<strong>G</strong>到自己的queue中执行。(偷!)</p>
<p>当你的goroutine执行阻塞的系统调用的时候(syscall)，阻塞的系统调用会中断(intercepted)，如果当前有一些<strong>G</strong>在执行，运行时会把这个线程从<strong>P</strong>中摘除(detach)，然后再创建一个新的操作系统的线程(如果没有空闲的线程可用的话)来服务于这个<strong>P</strong>。</p>
<p>当系统调用继续的时候，这个goroutine被放入到本地运行queue，线程会<code>park</code>它自己(休眠)， 加入到空闲线程中。</p>
<p>如果一个goroutine执行网络调用，运行时会做类似的动作。调用会被中断，但是由于Go使用集成的network poller,它有自己的线程，所以还给它。</p>
<p>Go运行时会在下面的goroutine被阻塞的情况下运行另外一个goroutine：</p>
<p>－ blocking syscall (for example opening a file),<br>－ network input,<br>－ channel operations,<br>－ primitives in the sync package.</p>
<h3 id="调度器跟踪调试">调度器跟踪调试</h3>
<p>Go可以跟踪运行时的调度器，这是通过 <code>GODEBUG</code> 环境变量实现的:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ GODEBUG=scheddetail=<span class="number">1</span>,schedtrace=<span class="number">1000</span> ./program</div></pre></td></tr></table></figure>

<p>下面是输出的例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SCHED <span class="number">0</span>ms: <span class="variable">gomaxprocs=</span><span class="number">8</span> <span class="variable">idleprocs=</span><span class="number">7</span> <span class="variable">threads=</span><span class="number">2</span> <span class="variable">spinningthreads=</span><span class="number">0</span> <span class="variable">idlethreads=</span><span class="number">0</span> <span class="variable">runqueue=</span><span class="number">0</span> <span class="variable">gcwaiting=</span><span class="number">0</span> <span class="variable">nmidlelocked=</span><span class="number">0</span> <span class="variable">stopwait=</span><span class="number">0</span> <span class="variable">sysmonwait=</span><span class="number">0</span></div><div class="line">  P0: <span class="variable">status=</span><span class="number">1</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span><span class="number">0</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P1: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P2: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P3: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P4: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P5: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P6: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  P7: <span class="variable">status=</span><span class="number">0</span> <span class="variable">schedtick=</span><span class="number">0</span> <span class="variable">syscalltick=</span><span class="number">0</span> <span class="variable">m=</span>-<span class="number">1</span> <span class="variable">runqsize=</span><span class="number">0</span> <span class="variable">gfreecnt=</span><span class="number">0</span></div><div class="line">  M1: <span class="variable">p=</span>-<span class="number">1</span> <span class="variable">curg=</span>-<span class="number">1</span> <span class="variable">mallocing=</span><span class="number">0</span> <span class="variable">throwing=</span><span class="number">0</span> <span class="variable">preemptoff=</span> <span class="variable">locks=</span><span class="number">1</span> <span class="variable">dying=</span><span class="number">0</span> <span class="variable">helpgc=</span><span class="number">0</span> <span class="variable">spinning=</span><span class="constant">false</span> <span class="variable">blocked=</span><span class="constant">false</span> <span class="variable">lockedg=</span>-<span class="number">1</span></div><div class="line">  M0: <span class="variable">p=</span><span class="number">0</span> <span class="variable">curg=</span><span class="number">1</span> <span class="variable">mallocing=</span><span class="number">0</span> <span class="variable">throwing=</span><span class="number">0</span> <span class="variable">preemptoff=</span> <span class="variable">locks=</span><span class="number">1</span> <span class="variable">dying=</span><span class="number">0</span> <span class="variable">helpgc=</span><span class="number">0</span> <span class="variable">spinning=</span><span class="constant">false</span> <span class="variable">blocked=</span><span class="constant">false</span> <span class="variable">lockedg=</span><span class="number">1</span></div><div class="line">  G1: <span class="variable">status=</span><span class="number">8</span>() <span class="variable">m=</span><span class="number">0</span> <span class="variable">lockedm=</span><span class="number">0</span></div></pre></td></tr></table></figure>

<p>注意输出使用了 <strong>G</strong>、<strong>M</strong>和<strong>P</strong>的概念以及她们的状态， 比如<strong>P</strong>的queue的大小。 如果你不想关心这些细节，你可以使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="variable">GODEBUG=</span><span class="variable">schedtrace=</span><span class="number">1000</span> ./program</div></pre></td></tr></table></figure>

<p>William Kennedy写了一篇很好的<a href="https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="external">文章</a>, 解释了这些细节。</p>
<p>当然，还有一个go自己的工具 <code>go tool trace</code>, 它有一个UI, 允许你查看你的程序和运行时的状况。你可以阅读这篇文章:  <a href="https://making.pusher.com/go-tool-trace" target="_blank" rel="external">Pusher</a>。</p>
<p><strong>参考文档</strong></p>
<ol>
<li><a href="https://www.slideshare.net/matthewrdale/demystifying-the-go-scheduler" target="_blank" rel="external">Slides by Matthew Dale</a></li>
<li><a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="external">Columbia University paper: Analysis of the Go runtime scheduler</a></li>
<li><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit?usp=sharing" target="_blank" rel="external">Scalable Go Scheduler Design Doc</a></li>
<li><a href="https://news.ycombinator.com/item?id=12459841" target="_blank" rel="external">Hacker news chat which explains a lot</a></li>
<li><a href="https://speakerdeck.com/retervision/go-runtime-scheduler" target="_blank" rel="external">go runtime scheduler slides by Gao Chao</a></li>
<li><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="external">Morsmachine article</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是另一篇关于Go调度器(scheduler)的文章。 原文: <a href="https://povilasv.me/go-scheduler/" target="_blank" rel="external">GO SCHEDULER: MS, PS &amp; GS</a> by Uber工程师 Povilas。</p>
<p>网上已经有很多关于Go调度器的文章了， 比如<a href="http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html" target="_blank" rel="external">Golang调度器源码分析</a>,多看一些，可以加深记忆，也可以对比查看文章中是否有不准确的地方,更全面的了解Go的调度器。</p>
<p>我决定深入了解Go的内部机制， 因为很长时间没人写关于Go scheduler的文章了， 我觉得这是一个很有趣的知识点，所以让我们开始吧。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OAuth2 RFC6749中文翻译]]></title>
    <link href="http://colobu.com/2017/04/28/oauth2-rfc6749/"/>
    <id>http://colobu.com/2017/04/28/oauth2-rfc6749/</id>
    <published>2017-04-28T03:36:23.000Z</published>
    <updated>2017-04-28T03:45:07.000Z</updated>
    <content type="html"><![CDATA[<p>转自 <a href="https://github.com/jeansfish/RFC6749.zh-cn" target="_blank" rel="external">RFC 6749-OAuth 2.0授权框架简体中文翻译</a><br><a id="more"></a></p>
<h1 id="1-_简介">1. 简介</h1>
<p>在传统的客户端-服务器身份验证模式中，客户端请求服务器上限制访问的资源（受保护资源）时，需要使用资源所有者的凭据在服务器上进行身份验证。<br>资源所有者为了给第三方应用提供受限资源的访问，需要与第三方共享它的凭据。 这造成一些问题和局限：</p>
<ul>
<li>需要第三方应用存储资源所有者的凭据，以供将来使用，通常是明文密码。</li>
<li>需要服务器支持密码身份认证，尽管密码认证天生就有安全缺陷。</li>
<li>第三方应用获得的资源所有者的受保护资源的访问权限过于宽泛，从而导致资源所有者失去对资源使用时限或使用范围的控制。</li>
<li>资源所有者不能仅撤销某个第三方的访问权限而不影响其它，并且，资源所有者只有通过改变第三方的密码，才能单独撤销这第三方的访问权限。</li>
<li>与任何第三方应用的让步导致对终端用户的密码及该密码所保护的所有数据的让步。</li>
</ul>
<p>OAuth通过引入授权层以及分离客户端角色和资源所有者角色来解决这些问题。<br>在OAuth中，客户端在请求受资源所有者控制并托管在资源服务器上的资源的访问权限时，将被颁发一组不同于资源所有者所拥有凭据的凭据。</p>
<p>客户端获得一个访问令牌（一个代表特定作用域、生命期以及其他访问属性的字符串），用以代替使用资源所有者的凭据来访问受保护资源。<br>访问令牌由授权服务器在资源所有者认可的情况下颁发给第三方客户端。客户端使用访问令牌访问托管在资源服务器的受保护资源。</p>
<p>例如，终端用户（资源所有者）可以许可一个打印服务（客户端）访问她存储在图片分享网站（资源服务器）上的受保护图片，而无需与打印服务分享自己的用户名和密码。<br>反之，她直接与图片分享网站信任的服务器（授权服务器）进行身份验证，该服务器颁发给打印服务具体委托凭据（访问令牌）。</p>
<p>本规范是为HTTP（<a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a>）协议量身定制。在任何非HTTP协议上使用OAuth不在本规范的范围之内。</p>
<p>OAuth 1.0协议（<a href="http://tools.ietf.org/html/rfc5849" title="OAuth 1.0协议" target="_blank" rel="external">RFC5849</a>）作为一个指导性文档发布，是一个小社区的工作成果。<br>本标准化规范在OAuth 1.0的部署经验之上构建，也包括其他使用案例以及从更广泛的IETF社区收集到的可扩展性需求。<br>OAuth 2.0协议不向后兼容OAuth 1.0。这两个版本可以在网络上共存，实现者可以选择同时支持他们。<br>然而，本规范的用意是新的实现支持按本文档指定的Auth 2.0，OAuth 1.0仅用于支持现有的部署。<br>OAuth 2.0协议与OAuth 1.0协议实现细节没有太多关联。熟悉OAuth 1.0的实现者应该学习本文档，而不对有关OAuth 2.0的结构和细节做任何假设。</p>
<ul>
<li>1.1. <a href="1.1.md">角色</a></li>
<li>1.2. <a href="1.2.md">协议流程</a></li>
<li>1.3. <a href="1.3.md">授权许可</a><ul>
<li>1.3.1. <a href="1.3.1.md">授权码</a></li>
<li>1.3.2. <a href="1.3.2.md">隐式授权</a></li>
<li>1.3.3. <a href="1.3.3.md">资源所有者密码凭据</a></li>
<li>1.3.4. <a href="1.3.4.md">客户端凭据</a></li>
</ul>
</li>
<li>1.4. <a href="1.4.md">访问令牌</a></li>
<li>1.5. <a href="1.5.md">刷新令牌</a></li>
<li>1.6. <a href="1.6.md">TLS版本</a></li>
<li>1.7. <a href="1.7.md">HTTP重定向</a></li>
<li>1.8. <a href="1.8.md">互操作性</a></li>
<li>1.9. <a href="1.9.md">符号约定</a></li>
</ul>
<h2 id="Links">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>下一节 <a href="1.1.md">1.1 角色</a></li>
</ul>
<h1 id="1-1-_角色">1.1. 角色</h1>
<p>OAuth定义了四种角色：</p>
<ul>
<li><p>资源所有者</p>
<p>能够许可受保护资源访问权限的实体。当资源所有者是个人时，它作为最终用户被提及。 </p>
</li>
<li><p>资源服务器</p>
<p>托管受保护资源的服务器，能够接收和响应使用访问令牌对受保护资源的请求。</p>
</li>
<li><p>客户端</p>
<p>使用资源所有者的授权代表资源所有者发起对受保护资源的请求的应用程序。术语“客户端”并非特指任何特定的的实现特点（例如：应用程序是否在服务器、台式机或其他设备上执行）。</p>
</li>
<li><p>授权服务器</p>
<p>在成功验证资源所有者且获得授权后颁发访问令牌给客户端的服务器。<br>授权服务器和资源服务器之间的交互超出了本规范的范围。授权服务器可以和资源服务器是同一台服务器，也可以是分离的个体。一个授权服务器可以颁发被多个资源服务器接受的访问令牌。</p>
</li>
</ul>
<h2 id="Links-1">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.md">1. 简介</a></li>
<li>下一节 <a href="1.2.md">1.2 协议流程</a></li>
</ul>
<h1 id="1-2-_协议流程">1.2. 协议流程</h1>
<pre><code> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                               <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(A)</span><span class="literal">-</span> <span class="comment">Authorization</span> <span class="comment">Request</span> <span class="literal">-</span>&gt;<span class="comment">|</span>   <span class="comment">Resource</span>    <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>                               <span class="comment">|</span>     <span class="comment">Owner</span>     <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(B)</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Authorization</span> <span class="comment">Grant</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>                               <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>        <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>                               <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(C)</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Authorization</span> <span class="comment">Grant</span> <span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">Authorization</span> <span class="comment">|</span>
 <span class="comment">|</span> <span class="comment">Client</span> <span class="comment">|</span>                               <span class="comment">|</span>     <span class="comment">Server</span>    <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(D)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>                               <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>        <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>                               <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(E)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>    <span class="comment">Resource</span>   <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>                               <span class="comment">|</span>     <span class="comment">Server</span>    <span class="comment">|</span>
 <span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(F)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Protected</span> <span class="comment">Resource</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span>               <span class="comment">|</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                               <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
</code></pre><p>图1：抽象的协议流程</p>
<p>图1中所示的抽象OAuth 2.0流程描述了四个角色之间的交互，包括以下步骤：</p>
<ul>
<li>（A）客户端向从资源所有者请求授权。授权请求可以直接向资源所有者发起（如图所示），或者更可取的是通过作为中介的授权服务器间接发起。</li>
<li>（B）客户端收到授权许可，这是一个代表资源所有者的授权的凭据，使用本规范中定义的四种许可类型之一或  者使用扩展许可类型表示。授权许可类型取决于客户端请求授权所使用的方式以及授权服务器支持的类型。</li>
<li>（C）客户端与授权服务器进行身份认证并出示授权许可请求访问令牌。</li>
<li>（D）授权服务器验证客户端身份并验证授权许可，若有效则颁发访问令牌。 </li>
<li>（E）客户端从资源服务器请求受保护资源并出示访问令牌进行身份验证。</li>
<li>（F）资源服务器验证访问令牌，若有效则满足该请求。</li>
</ul>
<p>客户端用于从资源所有者获得授权许可（步骤（A）和（B）所示）的更好方法是使用授权服务器作为中介，如                    <a href="../Section04/4.1.md">4.1节</a>图3所示。</p>
<h2 id="Links-2">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.1.md">角色</a></li>
<li>下一节 <a href="1.3.md">授权许可</a></li>
</ul>
<h1 id="1-3-_授权许可">1.3. 授权许可</h1>
<p>授权许可是一个代表资源所有者授权（访问受保护资源）的凭据，客户端用它来获取访问令牌。本规范定义了四种许可类型——授权码、隐式许可、资源所有者密码凭据和客户端凭据——以及用于定义其他类型的可扩展性机制。</p>
<ul>
<li>1.3.1. <a href="1.3.1.md">授权码</a></li>
<li>1.3.2. <a href="1.3.2.md">隐式授权</a></li>
<li>1.3.3. <a href="1.3.3.md">资源所有者密码凭据</a></li>
<li>1.3.4. <a href="1.3.4.md">客户端凭据</a></li>
</ul>
<h2 id="Links-3">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.2.md">协议流程</a></li>
<li>下一节 <a href="1.3.1.md">授权码</a></li>
</ul>
<h1 id="1-3-1-_授权码">1.3.1. 授权码</h1>
<p>授权码通过使用授权服务器做为客户端与资源所有者的中介而获得。客户端不是直接从资源所有者请求授权，而是引导资源所有者至授权服务器（由在<a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a>中定义的用户代理），授权服务器之后引导资源所有者带着授权码回到客户端。</p>
<p>在引导资源所有者携带授权码返回客户端前，授权服务器会鉴定资源所有者身份并获得其授权。由于资源所有者只与授权服务器进行身份验证，所以资源所有者的凭据不需要与客户端分享。</p>
<p>授权码提供了一些重要的安全益处，例如验证客户端身份的能力，以及向客户端直接的访问令牌的传输而非通过资源所有者的用户代理来传送它而潜在暴露给他人（包括资源所有者）。</p>
<h2 id="Links-4">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.3.md">授权许可</a></li>
<li>下一节 <a href="1.3.2.md">隐式授权</a></li>
</ul>
<h1 id="1-3-2-_隐式许可">1.3.2. 隐式许可</h1>
<p>隐式许可是为用如JavaScript等脚本语言在浏览器中实现的客户端而优化的一种简化的授权码流程。在隐式许可流程中，不再给客户端颁发授权码，取而代之的是客户端直接被颁发一个访问令牌（作为资源所有者的授权）。这种许可类型是隐式的，因为没有中间凭据（如授权码）被颁发（之后用于获取访问令牌）。</p>
<p>当在隐式许可流程中颁发访问令牌时，发授权服务器不对客户端进行身份验证。在某些情况下，客户端身份可以通过用于向客户端传送访问令牌的重定向URI验证。访问令牌可能会暴露给资源所有者，或者对资源所有者的用户代理有访问权限的其他应用程序。</p>
<p>隐式许可提高了一些客户端（例如一个作为浏览器内应用实现的客户端）的响应速度和效率，因为它减少了获取访问令牌所需的往返数量。然而，这种便利应该和采用隐式许可的安全影响作权衡，如那些在<a href="../Section10/10.3.md">10.3</a>和<a href="../Section10/10.16.md">10.16</a>节中所述的，尤其是当授权码许可类型可用的时候。</p>
<h2 id="Links-5">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.3.1md">授权码</a></li>
<li>下一节 <a href="1.3.3.md">资源所有者密码授权</a></li>
</ul>
<h1 id="1-3-3-_资源所有者密码凭据">1.3.3. 资源所有者密码凭据</h1>
<p>资源所有者密码凭据（即用户名和密码），可以直接作为获取访问令牌的授权许可。这种凭据只能应该当资源所有者和客户端之间具有高度信任时（例如，客户端是设备的操作系统的一部分，或者是一个高度特权应用程序），以及当其他授权许可类型（例如授权码）不可用时被使用。</p>
<p>尽管本授权类型需要对资源所有者凭据直接的客户端访问权限，但资源所有者凭据仅被用于一次请求并被交换为访问令牌。通过凭据和长期有效的访问令牌或刷新令牌的互换，这种许可类型可以消除客户端存储资源所有者凭据供将来使用的需要。</p>
<h2 id="Links-6">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.3.2.md">隐式授权</a></li>
<li>下一节 <a href="1.3.4.md">客户端凭据</a></li>
</ul>
<h1 id="1-3-4-_客户端凭据">1.3.4. 客户端凭据</h1>
<p>当授权范围限于客户端控制下的受保护资源或事先与授权服务器商定的受保护资源时客户端凭据可以被用作为一种授权许可。典型的当客户端代表自己表演（客户端也是资源所有者）或者基于与授权服务器事先商定的授权请求对受保护资源的访问权限时，客户端凭据被用作为授权许可。</p>
<h2 id="Links-7">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.3.3.md">资源所有者密码授权</a></li>
<li>下一节 <a href="1.4.md">访问令牌</a></li>
</ul>
<h1 id="1-4-_访问令牌">1.4. 访问令牌</h1>
<p>访问令牌是用于访问受保护资源的凭据。访问令牌是一个代表向客户端颁发的授权的字符串。该字符串通常对于客户端是不透明的。令牌代表了访问权限的由资源所有者许可并由资源服务器和授权服务器实施的具体范围和期限。</p>
<p>令牌可以表示一个用于检索授权信息的标识符或者可以以可验证的方式自包含授权信息（即令牌字符串由数据和签名组成）。额外的身份验证凭据——在本规范范围以外——可以被要求以便客户端使用令牌。</p>
<p>访问令牌提供了一个抽象层，用单一的资源服务器能理解的令牌代替不同的授权结构（例如，用户名和密码）。这种抽象使得颁发访问令牌比颁发用于获取令牌的授权许可更受限制，同时消除了资源服务器理解各种各样身份认证方法的需要。</p>
<p>基于资源服务器的安全要求访问令牌可以有不同的格式、结构及采用的方法（如，加密属性）。访问令牌的属性和用于访问受保护资源的方法超出了本规范的范围，它们在<a href="http://tools.ietf.org/html/rfc6750" title="The OAuth 2.0 Authorization Framework: Bearer Token Usage" target="_blank" rel="external">RFC6750</a>等配套规范中定义。</p>
<h2 id="Links-8">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.3.4.md">客户端凭据</a></li>
<li>下一节 <a href="1.5.md">刷新令牌</a></li>
</ul>
<h1 id="1-5-_刷新令牌">1.5. 刷新令牌</h1>
<p>访问令牌是用于获取访问令牌的凭据。刷新令牌由授权服务器颁发给客户端，用于在当前访问令牌失效或过期时，获取一个新的访问令牌，或者获得相等或更窄范围的额外的访问令牌（访问令牌可能具有比资源所有者所授权的更短的生命周期和更少的权限）。颁发刷新令牌是可选的，由授权服务器决定。如果授权服务器颁发刷新令牌，在颁发访问令牌时它被包含在内（即图1中的步骤D）。</p>
<p>刷新令牌是一个代表由资源所有者给客户端许可的授权的字符串。该字符串通常对于客户端是不透明的。该令牌表示一个用于检索授权信息的标识符。不同于访问令牌，刷新令牌设计只与授权服务器使用，并不会发送到资源服务器。</p>
<pre><code><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                           <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
<span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(A)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Authorization</span> <span class="comment">Grant</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                                           <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(B)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>               <span class="comment">&amp;</span> <span class="comment">Refresh</span> <span class="comment">Token</span>             <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                                           <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(C)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>          <span class="comment">|</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                            <span class="comment">|</span>          <span class="comment">|</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(D)</span><span class="literal">-</span> <span class="comment">Protected</span> <span class="comment">Resource</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">|</span> <span class="comment">Resource</span> <span class="comment">|</span>   <span class="comment">|</span> <span class="comment">Authorization</span> <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">Client</span> <span class="comment">|</span>                            <span class="comment">|</span>  <span class="comment">Server</span>  <span class="comment">|</span>   <span class="comment">|</span>     <span class="comment">Server</span>    <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(E)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>          <span class="comment">|</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                            <span class="comment">|</span>          <span class="comment">|</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(F)</span><span class="literal">-</span> <span class="comment">Invalid</span> <span class="comment">Token</span> <span class="comment">Error</span> <span class="literal">-</span><span class="comment">|</span>          <span class="comment">|</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                            <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>   <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                                           <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(G)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Refresh</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>                                           <span class="comment">|</span>               <span class="comment">|</span>
<span class="comment">|</span>        <span class="comment">|</span>&lt;<span class="literal">-</span><span class="comment">(H)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span>               <span class="comment">|</span>
<span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>           <span class="comment">&amp;</span> <span class="comment">Optional</span> <span class="comment">Refresh</span> <span class="comment">Token</span>        <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
</code></pre><p>图2：刷新过期的访问令牌</p>
<p>图2中的所示流程包含以下步骤：</p>
<ul>
<li>（A）客户端通过与授权服务器进行身份验证并出示授权许可请求访问令牌。</li>
<li>（B）授权服务器对客户端进行身份验证并验证授权许可，若有效则颁发访问令牌和刷新令牌。</li>
<li>（C）客户端通过出示访问令牌向资源服务器发起受保护资源的请求。</li>
<li>（D）资源服务器验证访问令牌，若有效则满足该要求。</li>
<li>（E）步骤（C）和（D）重复进行，直到访问令牌到期。如果客户端知道访问令牌已过期，跳到步骤（G），否  则它将继续发起另一个对受保护资源的请求。</li>
<li>（F）由于访问令牌是无效的，资源服务器返回无效令牌错误。</li>
<li>（G）客户端通过与授权服务器进行身份验证并出示刷新令牌，请求一个新的访问令牌。客户端身份验证要求基于客户端的类型和授权服务器的策略。</li>
<li>（H）授权服务器对客户端进行身份验证并验证刷新令牌，若有效则颁发一个新的访问令牌（和——可选地——一个新的刷新令牌）。</li>
</ul>
<p>步骤（C）、（D）、（E）和（F）在本规范的范围以外，如<a href="../Section07/7.md">第7节</a>中所述。</p>
<h2 id="Links-9">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.4.md">访问令牌</a></li>
<li>下一节 <a href="1.6.md">TLS 版本</a></li>
</ul>
<h1 id="1-6-_TLS版本">1.6. TLS版本</h1>
<p>本规范任何时候使用传输层安全性（TLS），基于广泛的部署和已知的安全漏洞TLS的相应版本（或多个版本）将会随时间而变化。在本规范撰写时，TLS 1.2版<a href="http://tools.ietf.org/html/rfc5246" title="传输层安全（TLS）协议1.2版" target="_blank" rel="external">RFC5246</a>是最新的版本，但它具有非常局限的部署基础，可能还未准备好可以实现。TLS 1.0版<a href="http://tools.ietf.org/html/rfc2246" title="TLS协议1.0版" target="_blank" rel="external">RFC2246</a>是部署最广泛的版本并将提供最宽泛的互操作性。</p>
<p>实现也可以支持满足其安全需求的其他传输层安全机制。</p>
<h2 id="Links-10">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.5.md">刷新令牌</a></li>
<li>下一节 <a href="1.7.md">HTTP重定向</a></li>
</ul>
<h1 id="1-7-_HTTP重定向">1.7. HTTP重定向</h1>
<p>本规范广泛采用了HTTP重定向，有此客户端或授权服务器引导资源所有者的用户代理到另一个目的地址。虽然本规范中的例子演示了HTTP 302状态码的使用，但是任何其他通过用户代理完成重定向的方法都是允许的并被考虑作为实现细节。</p>
<h2 id="Links-11">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.6.md">TLS版本</a></li>
<li>下一节 <a href="1.8.md">互操作性</a></li>
</ul>
<h1 id="1-8-_互操作性">1.8. 互操作性</h1>
<p>OAuth 2.0提供了丰富的具有明确的安全性质的授权框架。然而，尽管在其自身看来是一个带有许多可选择组件的丰富且高度可扩展的框架，本规范有可能产生许多非可互操作的实现。</p>
<p>此外，本规范中留下一些必需组件部分或完全没有定义（例如，客户端注册、授权服务器性能、端点发现等）。没有这些组件，客户端必须针对特定的授权服务器和资源服务器被手动并专门配置，以进行互操作。</p>
<p>本框架设计具有一个明确的期望，即未来工作将定义实现完整的web范围的互操作性所需的规范性的配置和扩展。</p>
<h2 id="Links-12">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.7md">HTTP重定向</a></li>
<li>下一节 <a href="1.9.md">符号约定</a></li>
</ul>
<h1 id="1-9-_符号约定">1.9. 符号约定</h1>
<p>本规范中的关键词“必须”、“不能”、“必需的”、“要”、“不要”、“应该”、“不应该”、“推荐的”、“可以”以及“可选的”按<a href="http://tools.ietf.org/html/rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels" target="_blank" rel="external">RFC2119</a>所述解释。<br>本规范使用<a href="http://tools.ietf.org/html/rfc5234" title="Augmented BNF for Syntax Specifications: ABNF" target="_blank" rel="external">RFC5234</a>的扩展巴科斯-诺尔范式(ABNF)表示法。此外，来自“统一资源标识符（URI）：通用语法”<a href="http://tools.ietf.org/html/rfc3986" title="Uniform Resource Identifier (URI): Generic Syntax" target="_blank" rel="external">RFC3986</a>的规则URI引用也包含在内。</p>
<p>某些安全相关的术语按照<a href="http://tools.ietf.org/html/rfc4949" title="Internet Security Glossary, Version 2" target="_blank" rel="external">RFC4949</a>中定义的意思理解。这些术语包括但不限于：“攻击”、“身份认证”、“授权”、“证书”、“机密”，“凭据”，“加密”，“身份”，“记号”，“签名”，“信任”，“验证”和“核实”。</p>
<p>除非另有说明，所有协议参数的名称和值是大小写敏感的。</p>
<h2 id="Links-13">Links</h2>
<ul>
<li><a href="../TableofContents.md">目录</a></li>
<li>上一节 <a href="1.8.md">互操作性</a></li>
<li>下一节 <a href="../Section02/2.md">客户端注册</a></li>
</ul>
<h1 id="2-0_客户端注册">2.0 客户端注册</h1>
<p>在开始协议前，客户端在授权服务器注册。客户端在授权服务器上注册所通过的方式超出了本规范，但典型的涉及到最终用户与HTML注册表单的交互。</p>
<p>客户端注册不要求客户端与授权服务器之间的直接交互。在授权服务器支持时，注册可以依靠其他方式来建立信任关系并获取客户端的属性（如重定向URI、客户端类型）。例如，注册可以使用自发行或第三方发行声明或通过授权服务器使用信任通道执行客户端发现完成。</p>
<p>当注册客户端时，客户端开发者应该：</p>
<ul>
<li>指定<a href="2.1.md">2.1</a>节所述的客户端类型，</li>
<li>提供它的如<a href="../Section03/3.1.2.md">3.1.2</a>节所述的客户端重定向URI，且</li>
<li>包含授权服务器要求的任何其他信息（如，应用名称、网址、描述、Logo图片、接受法律条款等）。</li>
</ul>
<ul>
<li>2.1. <a href="2.1.md">客户端类型</a></li>
<li>2.2. <a href="2.2.md">客户端标识</a></li>
<li>2.3. <a href="2.3.md">客户端身份验证</a></li>
<li>2.3.1. <a href="2.3.1.md">客户端密码</a></li>
<li>2.3.2. <a href="2.3.2.md">其他身份验证方法</a></li>
<li>2.4. <a href="2.4.md">未注册的客户端</a><h1 id="2-1-_客户端类型">2.1. 客户端类型</h1>
根据客户端与授权服务器安全地进行身份验证的能力（即维护客户端凭据机密性的能力），OAuth定义了两种客户端类型：</li>
<li>机密客户端<br>能够维持其凭据机密性（如客户端执行在具有对客户端凭据有限访问权限的安全的服务器上），或者能够使用    其他方式保证客户端身份验证的安全性。</li>
<li>公开客户端<br>不能够维持其凭据的机密性（如客户端执行在由资源所有者使用的设备上，例如已安装的本地应用程序或基于Web浏览器的应用），且不能通过其他方式保证客户端身份验证的安全性。<br>客户端类型的选择基于授权服务器的安全身份认证定义以及其对客户端凭据可接受的暴露程度。授权服务器不应该对客户端类型做假设。</li>
</ul>
<p>客户端可以以分布式的组件集合实现，每一个组件具有不同的客户端类型和安全上下文（例如，一个同时具有机密的基于服务器的组件和公开的基于浏览器的组件的分布式客户端）。如果授权服务器不提供对这类客户端的支持，或不提供其注册方面的指导，客户端应该注册每个组件为一个单独的客户端。<br>本规范围绕下列客户端配置涉及：</p>
<ul>
<li>Web应用程序<br>Web应用是一个运行在Web服务器上的机密客户端。资源所有者通过其使用的设备上的用户代理里渲染的HTML用户界面访问客户端。客户端凭据以及向客户端颁发的任何访问令牌都存储在Web服务器上且不会暴露给资源所有者或者被资源所有者可访问。</li>
<li>基于用户代理的应用<br>基于用户代理的应用是一个公开客户端，客户端的代码从Web服务器下载，并在资源所有者使用的设备上的用户代理（如Web浏览器）中执行。协议数据和凭据对于资源所有者是可轻易访问的（且经常是可见的）。由于这些应用驻留在用户代理内，在请求授权时它们可以无缝地使用用户代理的功能。</li>
<li>本机应用程序<br>本机应用是一个安装、运行在资源所有者使用的设备上的公开客户端。协议数据和凭据对于资源所有者是可访问的。假定包含在应用程序中的任何客户端身份认证凭据可以被提取。另一方面，动态颁发的如访问令牌或者刷新令牌等凭据可以达到可接受的保护水平。至少，这些凭据被保护不被应用可能与之交互的恶意服务器接触。在一些平台上，这些凭证可能被保护免于被驻留在相同设备上的其他应用接触。<h1 id="2-2-_客户端标识">2.2. 客户端标识</h1>
授权服务器颁发给已注册客户端客户端标识——一个代表客户端提供的注册信息的唯一字符串。客户端标识不是一个秘密，它暴露给资源所有者并且不能单独用于客户端身份验证。客户端标识对于授权服务器是唯一的。</li>
</ul>
<p>客户端的字符串大小本规范未定义。客户端应该避免对标识大小做假设。授权服务器应记录其发放的任何标识的大小。</p>
<h1 id="2-3-_客户端身份验证">2.3. 客户端身份验证</h1>
<p>如果客户端类型是机密的，客户端和授权服务器建立适合于授权服务器的安全性要求的客户端身份验证方法。授权服务器可以接受符合其安全要求的任何形式的客户端身份验证。</p>
<p>机密客户端通常颁发（或建立）一组客户端凭据用于与授权服务器进行身份验证（例如，密码、公/私钥对）。授权服务器可以与公共客户端建立客户端身份验证方法。然而，授权服务器不能依靠公共客户端身份验证达到识别客户端的目的。</p>
<p>客户端在每次请求中不能使用一个以上的身份验证方法。</p>
<ul>
<li>2.3.1. <a href="2.3.1.md">客户端密码</a></li>
<li><p>2.3.2. <a href="2.3.2.md">其他身份验证方法</a></p>
<h1 id="2-3-1-_客户端密码">2.3.1. 客户端密码</h1>
<p>拥有客户端密码的客户端可以使用<a href="http://tools.ietf.org/html/rfc2617" title="HTTP Authentication: Basic and Digest Access Authentication" target="_blank" rel="external">RFC2617</a>中定义的HTTP基本身份验证方案与授权服务器进行身份验证。客户端标识使用按照<a href="../AppendixB/b.md">附录B</a>的“application/x-www-form-urlencoded”编码算法编码，编码后的值用作用户名；客户端密码使用相同的算法编码并用作密码。授权服务器必须支持HTTP基本身份验证方案，用于验证被颁发客户端密码的客户端的身份。例如（额外的换行仅用于显示目的）：</p>
<p>   Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3</p>
</li>
</ul>
<p>此外，授权服务器可以使用下列参数支持在请求正文中包含客户端凭据：</p>
<ul>
<li>client_id<br>必需的。如<a href="2.2.md">2.2</a>节所述的注册过程中颁发给客户端的客户端标识。</li>
<li>client_secret<br>必需的。客户端秘密。 客户端可以忽略该参数若客户端秘密是一个空字符串。</li>
</ul>
<p>使用这两个参数在请求正文中包含客户端凭据是不被建议的，应该限于不能直接采用HTTP基本身份验证方案（或其他基于密码的HTTP身份验证方案）的客户端。参数只能在请求正文中传送，不能包含在请求URI中。</p>
<p>例如，使用请求正文参数请求刷新访问令牌（第<a href="../Section06/6.md">6</a>节）（额外的换行仅用于显示目的）：</p>
<pre><code> POST /token HTTP/<span class="number">1.1</span>
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 <span class="variable">grant_type=</span>refresh_token&amp;<span class="variable">refresh_token=</span>tGzv3JOkF0XG5Qx2TlKWIA&amp;<span class="variable">client_id=</span>s6BhdRkqt3&amp;<span class="variable">client_secret=</span><span class="number">7</span>Fjfp0ZBr1KtDRbnfVdmIw
</code></pre><p>当使用密码身份验证发送请求时，授权服务器必须要求使用如<a href="../Section01/1.6.md">1.6</a>所述的TLS。</p>
<p>由于该客户端身份验证方法包含密码，授权服务器必须保护所有使用到密码的端点免受暴力攻击。</p>
<h1 id="2-3-2-_其他身份验证方法">2.3.2. 其他身份验证方法</h1>
<p>授权服务器可以支持任何与其安全要求匹配的合适的HTTP身份验证方案。当使用其他身份验证方法时，授权服务器必须定义客户端标识（注册记录）和认证方案之间的映射。</p>
<h1 id="2-4-_未注册客户端">2.4. 未注册客户端</h1>
<p>本规范不排除使用未注册的客户端。然而，使用这样的客户端超出了本规范的范围，并需要额外的安全性分析并审查其互操作性影响。</p>
<h1 id="3-_协议端点">3. 协议端点</h1>
<p>授权过程采用了两种授权服务器端点（HTTP资源）：</p>
<ul>
<li>授权端点——客户端用其通过用户代理重定向从资源所有者获取授权。</li>
<li>令牌端点——客户端用其将授权许可交换为访问令牌，通常伴有客户端身份验证。</li>
</ul>
<p>以及一种客户端端点：</p>
<ul>
<li>重定向端点——授权服务器用其通过资源所有者用户代理向客户端返回含有授权凭据的响应。</li>
</ul>
<p>并不是每种授权许可类型都采用两种端点。</p>
<p>扩展许可类型可以按需定义其他端点。</p>
<ul>
<li>3.1. <a href="3.1.md">授权端点</a></li>
<li>3.1.1. <a href="3.1.1.md">响应类型</a></li>
<li>3.1.2. <a href="3.1.2.md">重定向端点</a></li>
<li>3.2. <a href="3.2.md">令牌端点</a></li>
<li>3.2.1. <a href="3.2.1.md">客户端身份验证</a></li>
<li>3.3. <a href="3.3.md">访问令牌范围</a><h1 id="3-1-_授权端点">3.1. 授权端点</h1>
授权端点用于与资源所有者交互获取授权许可。 授权服务器必须先验证资源所有者的身份。 授权服务器对资源所有者进行身份验证的方式（例如，用户名和密码登录、会话cookies）超出了本规范的范围。</li>
</ul>
<p>客户端通过何种方式获得授权端点的位置超出了本文档范围，但该位置通常在服务文档中提供。</p>
<p>端点URI可以包含“application/x-www-form-urlencoded”格式（按<a href="../AppendixB/b.md">附录B</a>）的查询部分（<a href="http://tools.ietf.org/html/rfc3986#section-3.4" title="Uniform Resource Identifier (URI): Generic Syntax 3.4节" target="_blank" rel="external">RFC3986的3.4节</a>），当添加额外的查询参数时必须保留该部分。端点URI不得包含片段部分。</p>
<p>由于向授权端点的请求引起用户身份验证和明文凭据传输（在HTTP响应中），当向授权端点发送请求时，授权服务器必须要求如<a href="../Section01/1.6.md">1.6</a>节所述的TLS的使用。</p>
<p>授权服务器对于授权端点必须支持使用HTTP“GET”方法<a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a>，也可以支持使用“POST”的方法。</p>
<p>发送的没有值的参数必须被对待为好像它们在请求中省略了。授权服务器必须忽略不能识别的请求参数。 请求和响应参数不能包含超过一次。</p>
<ul>
<li>3.1.1. <a href="3.1.1.md">响应类型</a></li>
<li>3.1.2. <a href="3.1.2.md">重定向端点</a></li>
</ul>
<h1 id="3-1-1-_响应类型">3.1.1. 响应类型</h1>
<p>授权端点被授权码许可类型和隐式许可类型流程使用。客户端使用下列参数通知授权服务器期望的许可类型：</p>
<ul>
<li>response_type<br>必需的。其值必须是如<a href="../Section04/4.1.1.md">4.1.1</a>节所述用于请求授权码的“code”，如<a href="../Section04/4.2.1.md">4.2.1</a>节所述用于请求访问令牌的“token”（隐式许可）或者如<a href="../Section08/8.4.md">8.4</a>节所述的一个注册的扩展值之中的一个。</li>
</ul>
<p>扩展响应类型可以包含一个空格（%x20）分隔的值的列表，值的顺序并不重要（例如，响应类型“a b”与“b a”相同）。 这样的复合响应类型的含义由他们各自的规范定义。</p>
<p>如果授权请求缺少“response_type”参数，或者如果响应类型不被理解，授权服务器必须返回一个<a href="../Section04/4.1.2.1.md">4.1.2.1</a>所述的错误响应。</p>
<h1 id="3-1-2-_重定向端点">3.1.2. 重定向端点</h1>
<p>在完成与资源所有者的交互后，授权服务器引导资源所有者的用户代理返回到客户端。授权服务器重定向用户代理至客户端的重定向端点，该端点是事先在客户端注册过程中或者当发起授权请求时与授权服务器建立的。</p>
<p>重定向端点URI必须是如<a href="http://tools.ietf.org/html/rfc3986#section-3.4" title="Uniform Resource Identifier (URI): Generic Syntax 3.4节" target="_blank" rel="external">RFC3986的3.4节</a>所述的绝对URI。端点URI可以包含“application/x-www-form-urlencoded”格式（按<a href="../AppendixB/b.md">附录B</a>）的查询部分（<a href="http://tools.ietf.org/html/rfc3986#section-3.4" title="Uniform Resource Identifier (URI): Generic Syntax 3.4节" target="_blank" rel="external">RFC3986的3.4节</a>），当添加额外的查询参数时必须保留该部分。端点URI不得包含片段部分。</p>
<ul>
<li>3.1.2.1. <a href="3.1.2.1.md">端点请求的机密性</a></li>
<li>3.1.2.2. <a href="3.1.2.2.md">注册要求</a></li>
<li>3.1.2.3. <a href="3.1.2.3.md">动态配置</a></li>
<li>3.1.2.4. <a href="3.1.2.4.md">无效端点</a></li>
<li>3.1.2.5. <a href="3.1.2.5.md">端点内容</a></li>
</ul>
<h1 id="3-1-2-1-_端点请求的机密性">3.1.2.1. 端点请求的机密性</h1>
<p>当所请求的响应类型是“code”或“token”时，或者当重定向请求将引起在蜜柑凭据通过公开网络传输时，重定向端点应该要求使用<a href="../Section01/1.6.md">1.6</a>节所述的TLS。本规范没有强制使用TLS，因为在撰写本规范时，要求客户端部署TLS对于许多客户端开发者是一严重的困难。如果TLS不可用，授权服务器应该在重定向之前警告资源所有者有关非安全端点（例如，在授权请求期间现实一条信息）。</p>
<p>缺乏传输层安全可能对客户端及它被授权访问的受保护资源的安全具有严重影响。当授权过程用作一种客户端委托的对最终用户认证（例如，第三方登录服务）的形式时，使用传输层安全尤其关键。</p>
<h1 id="3-1-2-2-_注册要求">3.1.2.2. 注册要求</h1>
<p>授权服务器必须要求下列客户端注册它们的重定向端点：</p>
<ul>
<li>公开客户端。</li>
<li>采用隐式许可类型的机密客户端。</li>
</ul>
<p>授权服务器应该要求所有客户端在使用授权端点前注册它们的重定向端点。</p>
<p>授权服务器应该要求客户端提供完整的重定向URI（客户端可以使用“state”请求参数实现每请求自定义）。如果要求完整的重定向URI注册不可行，授权服务器应该要求注册URI方案、授权和路径（当请求授权时只允许客户端动态改变重定向URI的查询部分）。</p>
<p>授权服务器可以允许客户端注册多个重定向端点。</p>
<p>缺少重定向URI注册的要求，可能使攻击者如<a href="../Section10/10.15.md">10.15</a>所述将授权端点用作自由重定向端点。</p>
<h1 id="3-1-2-3-_动态配置">3.1.2.3. 动态配置</h1>
<p>如果多个重定向URI被注册，或者如果只有部分重定向URI被注册，或者如果没有重定向URI被注册，客户端都必须使用“redirect_uri”请求参数在授权请求中包含重定向URI。</p>
<p>当重定向URI被包含在授权请求中时，若有任何重定向URI被注册，授权服务器必须将接收到的值与至少一个已注册的重定向URI（或URI部分）按<a href="http://tools.ietf.org/html/rfc3986#section-6" title="Uniform Resource Identifier (URI): Generic Syntax 6节" target="_blank" rel="external">RFC3986第6节</a>所述进行比较并匹配。如果客户端注册包含了完整的重定向URI，授权服务器必须使用<a href="http://tools.ietf.org/html/rfc3986#section-6.2.1" title="Uniform Resource Identifier (URI): Generic Syntax 6.2.1节" target="_blank" rel="external">RFC3986第6.2.1节</a>中定义的简单字符串比较法比对这两个URI 。</p>
<h1 id="3-1-2-4-_无效端点">3.1.2.4. 无效端点</h1>
<p>如果由于缺失、无效或不匹配的重定向URI而验证失败，授权服务器应该通知资源所有者该错误且不能向无效的重定向URI自动重定向用户代理。</p>
<h1 id="3-1-2-5-_端点内容">3.1.2.5. 端点内容</h1>
<p>向客户端端点的重定向请求通常会引起由用户代理处理的HTML文档响应。如果HTML响应直接作为重定向请求的服务结果，任何包含在HTML文档中的脚本将执行，并具有对重定向URI和其包含的凭据的完全访问权限。</p>
<p>客户端不应该在重定向端点的响应中包含任何第三方的脚本（例如，第三方分析、社交插件、广告网络）。相反，它应该从URI中提取凭据并向另一个端点重定向用户代理而不暴露凭据（在URI中或其他地方）。如果包含第三方脚本，客户端必须确保它自己的脚本（用于从URI中提取凭据并从URI中删除）将首先执行。</p>
<h1 id="3-2-_令牌端点">3.2. 令牌端点</h1>
<p>客户端通过提交它的授权许可或刷新令牌使用令牌端点获取访问令牌。令牌端点被用于除了隐式许可类型（因为访问令牌是直接颁发的）外的每种授权许可中。</p>
<p>客户端通过何种方式获得令牌端点的位置超出了本文档范围，但该位置通常在服务文档中提供。</p>
<p>端点URI可以包含“application/x-www-form-urlencoded”格式（按<a href="../AppendixB/b.md">附录B</a>）的查询部分（<a href="http://tools.ietf.org/html/rfc3986#section-3.4" title="Uniform Resource Identifier (URI): Generic Syntax 3.4节" target="_blank" rel="external">RFC3986的3.4节</a>），当添加额外的查询参数时必须保留该部分。端点URI不得包含片段部分。</p>
<p>由于向令牌端点的请求引起明文凭据的传输（在HTTP请求和响应中），当向令牌端点发送请求时，授权服务器必须要求如<a href="../Section01/1.6.md">1.6</a>节所述的TLS的使用。</p>
<p>当发起访问令牌请求时，客户端必须使用HTTP“POST”方法。</p>
<p>发送的没有值的参数必须被对待为好像它们在请求中省略了。授权服务器必须忽略不能识别的请求参数。请求和响应参数不能包含超过一次。</p>
<ul>
<li>3.2.1. <a href="3.2.1.md">客户端身份验证</a></li>
</ul>
<h1 id="3-2-1-_客户端身份验证">3.2.1. 客户端身份验证</h1>
<p>在向令牌端点发起请求时，机密客户端或其他被颁发客户端凭据的客户端必须如<a href="../Section02/2.3.md">2.3</a>节所述与授权服务器进行身份验证。客户端身份验证用于：</p>
<ul>
<li>实施刷新令牌和授权码到它们被颁发给的客户端的绑定。当授权码在不安全通道上向重定向端点传输时，或者 当重定向URI没有被完全注册时，客户端身份验证是关键的。</li>
<li>通过禁用客户端或者改变其凭据从被入侵的客户端恢复，从而防止攻击者滥用被盗的刷新令牌。改变单套客户端凭据显然快于撤销一整套刷新令牌。</li>
<li>实现身份验证管理的最佳实践，要求定期凭证轮转。轮转一整套刷新令牌可能是艰巨的，而轮转单组客户端凭据显然更容易。</li>
</ul>
<p>在向令牌端点发送请求时，客户端可以使用“client_id”请求参数标识自己。向令牌端点的“authorization_code”和“grant_type”请求中，未经身份验证的客户端必须发送它的“client_id”，以防止自己无意中接受了本打算给具有另一个“client_id”的客户端的代码。这保护了客户端免于被替换认证码。（它没有对手保护起源提供额外的安全。）</p>
<h1 id="3-3-_访问令牌范围">3.3. 访问令牌范围</h1>
<p>授权端点和令牌端点允许客户端使用“scope”请求参数指定访问请求的范围。反过来，授权服务器使用“scope”响应参数通知客户端颁发的访问令牌的范围。</p>
<p>范围参数的值表示为以空格分隔，大小写敏感的字符串。 由授权服务器定义该字符串。如果该值包含多个空格分隔的字符串，他们的顺序并不重要且每个字符串为请求的范围添加一个额外的访问区域。</p>
<p>  scope = scope-token *( SP scope-token )<br>  scope-token = 1*( %x21 / %x23-5B / %x5D-7E )</p>
<p>基于授权服务器的策略或资源拥有者的指示，授权服务器可以全部或部分地忽略客户端请求的范围。如果颁发的访问令牌范围和客户端请求的范围不同，授权服务器必须包含“scope”响应参数通知客户端实际许可的范围。</p>
<p>在请求授权时如果客户端忽略了范围参数，授权服务器必须要么使用预定义的默认值处理请求，要么使请求失败以指出无效范围。授权服务器应该记录它的范围需求和默认值（如果已定义）。</p>
<h1 id="4-_获得授权">4. 获得授权</h1>
<p>为了请求访问令牌，客户端从资源所有者获得授权。授权表现为授权许可的形式，客户端用它请求访问令牌。OAuth定义了四种许可类型：授权码、隐式许可、资源所有者密码凭据和客户端凭据。它还提供了扩展机制定义其他许可类型。</p>
<ul>
<li>4.1. <a href="4.1.md">授权码许可</a></li>
<li>4.1.1. <a href="4.1.1.md">授权请求</a></li>
<li>4.1.2. <a href="4.1.2.md">授权响应</a></li>
<li>4.1.3. <a href="4.1.3.md">访问令牌请求</a></li>
<li>4.1.4. <a href="4.1.4.md">访问令牌响应</a></li>
<li>4.2. <a href="4.2.md">隐式许可</a></li>
<li>4.2.1. <a href="4.2.1.md">授权请求</a></li>
<li>4.2.2. <a href="4.2.2.md">访问令牌响应</a></li>
<li>4.3. <a href="4.3.md">资源所有者密码凭据许可</a></li>
<li>4.3.1. <a href="4.3.1.md">授权请求和响应</a></li>
<li>4.3.2. <a href="4.3.2.md">访问令牌请求</a></li>
<li>4.3.3. <a href="4.3.3.md">访问令牌响应</a></li>
<li>4.4. <a href="4.4.md">客户端凭证许可</a></li>
<li>4.4.1. <a href="4.4.1.md">授权请求和响应</a></li>
<li>4.4.2. <a href="4.4.2.md">访问令牌请求</a></li>
<li>4.4.3. <a href="4.4.3.md">访问令牌响应</a></li>
<li><p>4.5. <a href="4.5.md">扩展许可</a></p>
<h1 id="4-1-_授权码许可">4.1. 授权码许可</h1>
<p>授权码许可类型用于获得访问令牌和刷新令牌并未机密客户端进行了优化。由于这是一个基于重定向的流程，客户端必须能够与资源所有者的用户代理（通常是Web浏览器）进行交互并能够接收来自授权服务器的传入请求（通过重定向）。</p>
<p>   +----------+<br>   | Resource |<br>   |   Owner  |<br>   |          |<br>   +----------+</p>
<pre><code>    ^
    <span class="string">|</span>
   (B)
</code></pre><p>   +----|-----+          Client Identifier      +---------------+<br>   |         -+----(A)-- &amp; Redirection URI ----&gt;|               |<br>   |  User-   |                                 | Authorization |<br>   |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |<br>   |          |                                 |               |<br>   |         -+----(C)-- Authorization Code ---&lt;|               |<br>   +-|----|---+                                 +---------------+</p>
<pre><code> <span class="string">|    |                                         ^      v</span>
(A)  (C)                                        <span class="string">|      |</span>
 <span class="string">|    |                                         |      |</span>
 ^    v                                         <span class="string">|      |</span>
</code></pre><p>   +---------+                                      |      |<br>   |         |&gt;---(D)-- Authorization Code ---------&#39;      |<br>   |  Client |          &amp; Redirection URI                  |<br>   |         |                                             |<br>   |         |&lt;---(E)----- Access Token -------------------&#39;<br>   +---------+       (w/ Optional Refresh Token)<br>注：说明步骤（A）、（B）和（C）的直线因为通过用户代理而被分为两部分。<br>图3：授权码流程</p>
</li>
</ul>
<p>在图3中所示的流程包括以下步骤：</p>
<ul>
<li>（A）客户端通过向授权端点引导资源所有者的用户代理开始流程。客户端包括它的客户端标识、请求范围、本地状态和重定向URI，一旦访问被许可（或拒绝）授权服务器将传送用户代理回到该URI。</li>
<li>（B）授权服务器验证资源拥有者的身份（通过用户代理），并确定资源所有者是否授予或拒绝客户端的访问请求。</li>
<li>（C）假设资源所有者许可访问，授权服务器使用之前（在请求时或客户端注册时）提供的重定向URI重定向用户代理回到客户端。重定向URI包括授权码和之前客户端提供的任何本地状态。</li>
<li>（D）客户端通过包含上一步中收到的授权码从授权服务器的令牌端点请求访问令牌。当发起请求时，客户端与授权服务器进行身份验证。客户端包含用于获得授权码的重定向URI来用于验证。</li>
<li><p>（E）授权服务器对客户端进行身份验证，验证授权代码，并确保接收的重定向URI与在步骤（C）中用于重定向客户端的URI相匹配。如果通过，授权服务器响应返回访问令牌与可选的刷新令牌。</p>
</li>
<li><p>4.1.1. <a href="4.1.1.md">授权请求</a></p>
</li>
<li>4.1.2. <a href="4.1.2.md">授权响应</a></li>
<li>4.1.3. <a href="4.1.3.md">访问令牌请求</a></li>
<li>4.1.4. <a href="4.1.4.md">访问令牌响应</a><h1 id="4-1-1-_授权请求">4.1.1. 授权请求</h1>
客户端通过按<a href="../AppendixB/b.md">附录B</a>使用“application/x-www-form-urlencoded”格式向授权端点URI的查询部分添加下列参数构造请求URI：</li>
<li>response_type<br>必需的。值必须被设置为“code”。</li>
<li>client_id<br>必需的。如<a href="../Section02/2.2.md">2.2</a>节所述的客户端标识。</li>
<li>redirect_uri<br>可选的。如<a href="../Section03/3.1.2.md">3.1.2</a>节所述。</li>
<li>scope<br>可选的。如3.3节所述的访问请求的范围。</li>
<li>state<br>推荐的。客户度用于维护请求和回调之间的状态的不透明的值。当重定向用户代理回到客户端时，授权服务器包含此值。该参数应该用于防止如<a href="../Section10/10.12.md">10.12</a>所述的跨站点请求伪造。</li>
</ul>
<p>客户端使用HTTP重定向响应向构造的URI定向资源所有者，或者通过经由用户代理至该URI的其他可用方法。<br>例如，客户端使用TLS定向用户代理发起下述HTTP请求（额外的换行仅用于显示目的）：</p>
<pre><code>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;<span class="keyword">state</span>=xyz&amp;redirect_uri=https<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2Fclient</span><span class="variable">%2Eexample</span><span class="variable">%2Ecom</span><span class="variable">%2Fcb</span> HTTP/<span class="number">1.1</span>
Host: server.example.com
</code></pre><p>授权服务器验证该请求，确保所有需要的参数已提交且有效。如果请求是有效的，授权服务器对资源所有者进行身份验证并获得授权决定（通过询问资源所有者或通过经由其他方式确定批准）。</p>
<p>当确定决定后，授权服务器使用HTTP重定向响应向提供的客户端重定向URI定向用户代理，或者通过经由用户代理至该URI的其他可行方法。</p>
<h1 id="4-1-2-_授权响应">4.1.2. 授权响应</h1>
<p>如果资源所有者许可访问请求，授权服务器颁发授权码，通过按<a href="../AppendixB/b.md">附录B</a>使用“application/x-www-form-urlencoded”格式向重定向URI的查询部分添加下列参数传递授权码至客户端：</p>
<ul>
<li>code<br>必需的。授权服务器生成的授权码。授权码必须在颁发后很快过期以减小泄露风险。推荐的最长的授权码生命周期是10分钟。客户端不能使用授权码超过一次。如果一个授权码被使用一次以上，授权服务器必须拒绝该请求并应该撤销（如可能）先前发出的基于该授权码的所有令牌。授权码与客户端标识和重定向URI绑定。</li>
<li>state<br>必需的，若“state”参数在客户端授权请求中提交。从客户端接收的精确值。</li>
</ul>
<p>例如，授权服务器通过发送以下HTTP响应重定向用户代理：</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">302</span> Found</span>
<span class="attribute">Location</span>: <span class="string">https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</span>
</code></pre><p>客户端必须忽略无法识别的响应参数。本规范未定义授权码字符串大小。客户端应该避免假设代码值的长度。授权服务器应记录其发放的任何值的大小。</p>
<ul>
<li>4.1.2.1. <a href="4.1.2.1.md">错误响应</a><h1 id="4-1-2-1-_错误响应">4.1.2.1. 错误响应</h1>
如果由于缺失、无效或不匹配的重定向URI而请求失败，或者如果客户端表示缺失或无效，授权服务器应该通知资源所有者该错误且不能向无效的重定向URI自动重定向用户代理。</li>
</ul>
<p>如果资源所有者拒绝访问请求，或者如果请求因为其他非缺失或无效重定向URI原因而失败，授权服务器通过按<a href="../AppendixB/b.md">附录B</a>使用“application/x-www-form-urlencoded”格式向重定向URI的查询部分添加下列参数通知客户端：</p>
<ul>
<li><p>error<br>必需的。下列ASCII[USASCII]错误代码之一：</p>
<ul>
<li>invalid_request<br>请求缺少必需的参数、包含无效的参数值、包含一个参数超过一次或其他不良格式。</li>
<li>unauthorized_client<br>客户端未被授权使用此方法请求授权码。</li>
<li>access_denied<br>资源所有者或授权服务器拒绝该请求。</li>
<li>unsupported_response_type<br>授权服务器不支持使用此方法获得授权码。</li>
<li>invalid_scope<br>请求的范围无效，未知的或格式不正确。</li>
<li>server_error<br>授权服务器遇到意外情况导致其无法执行该请求。（此错误代码是必要的，因为500内部服务器错误HTTP状态代码不能由HTTP重定向返回给客户端）。</li>
<li>temporarily_unavailable<br>授权服务器由于暂时超载或服务器维护目前无法处理请求。（此错误代码是必要的，因为503服务不可用HTTP状态代码不可以由HTTP重定向返回给客户端）。</li>
</ul>
<p>“error”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。</p>
</li>
<li>error_description<br>可选的。提供额外信息的人类可读的ASCII[USASCII]文本，用于协助客户端开发人员理解所发生的错误。<br>“error_description”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。</li>
<li>error_uri<br>可选的。指向带有有关错误的信息的人类可读网页的URI，用于提供客户端开发人员关于该错误的额外信息。<br>“error_uri”参数值必须符合URI参考语法，因此不能包含集合％x21/%x23-5B /％x5D-7E以外的字符。</li>
<li>state<br>必需的，若“state”参数在客户端授权请求中提交。从客户端接收的精确值。</li>
</ul>
<p>例如，授权服务器通过发送以下HTTP响应重定向用户代理：</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">302</span> Found</span>
<span class="attribute">Location</span>: <span class="string">https://client.example.com/cb?error=access_denied&amp;state=xyz</span>
</code></pre><h1 id="4-1-3-_访问令牌请求">4.1.3. 访问令牌请求</h1>
<p>客户端通过使用按<a href="../AppendixB/b.md">附录B</a>“application/x-www-form-urlencoded”格式在HTTP请求实体正文中发送下列UTF-8字符编码的参数向令牌端点发起请求：</p>
<ul>
<li>grant_type<br>必需的。值必须被设置为“authorization_code”。</li>
<li>code<br>从授权服务器收到的授权码。</li>
<li>redirect_uri<br>必需的，若“redirect_uri”参数如<a href="../Section04/4.1.1.md">4.1.1</a>节所述包含在授权请求中，且他们的值必须相同。</li>
<li>client_id<br>必需的，如果客户端没有如<a href="../Section03/3.2.1.md">3.2.1</a>节所述与授权服务器进行身份认证。</li>
</ul>
<p>如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如<br>  必需的，如果客户端没有如<a href="../Section03/3.2.1.md">3.2.1</a>节所述与授权服务器进行身份验证。</p>
<p>例如，客户端使用TLS发起如下的HTTP请求（额外的换行符仅用于显示目的）：</p>
<pre><code>POST /token HTTP/<span class="number">1.1</span>
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/<span class="keyword">x</span>-www-form-urlencoded
grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2Fclient</span><span class="variable">%2Eexample</span><span class="variable">%2Ecom</span><span class="variable">%2Fcb</span>
</code></pre><p>授权服务器必须：</p>
<ul>
<li>要求机密客户端或任何被颁发了客户端凭据（或有其他身份验证要求）的客户端进行客户端身份验证，</li>
<li>若包括了客户端身份验证，验证客户端身份，</li>
<li>确保授权码颁发给了通过身份验证的机密客户端，或者如果客户端是公开的，确保代码颁发给了请求中的“client_id”，</li>
<li>验证授权码是有效的，并</li>
<li>确保给出了“redirect_uri”参数，若“redirect_uri”参数如<a href="../Section04/4.1.1.md">4.1.1</a>所述包含在初始授权请求中，且若包含，确保它们的值是相同的。<h1 id="4-1-4-_访问令牌响应">4.1.4. 访问令牌响应</h1>
如果访问令牌请求是有效的且被授权，授权服务器如5.1节所述颁发访问令牌以及可选的刷新令牌。如果请求客户端身份验证失败或无效，授权服务器如5.2节所述的返回错误响应。</li>
</ul>
<p>一个样例成功响应：</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
<span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">no</span>-store
<span class="keyword">Pragma</span>: <span class="keyword">no</span>-<span class="keyword">cache</span>
{
  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,
  <span class="string">"token_type"</span>:<span class="string">"example"</span>,
  <span class="string">"expires_in"</span>:<span class="number">3600</span>,
  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,
  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span>
}</span>
</code></pre><h1 id="4-2-_隐式许可">4.2. 隐式许可</h1>
<p>隐式授权类型被用于获取访问令牌（它不支持发行刷新令牌），并对知道操作具体重定向URI的公共客户端进行优化。这些客户端通常在浏览器中使用诸如JavaScript的脚本语言实现。</p>
<p>由于这是一个基于重定向的流程，客户端必须能够与资源所有者的用户代理（通常是Web浏览器）进行交互并能够接收来自授权服务器的传入请求（通过重定向）。</p>
<p>不同于客户端分别请求授权和访问令牌的授权码许可类型，客户端收到访问令牌作为授权请求的结果。</p>
<p>隐式许可类型不包含客户端身份验证而依赖于资源所有者在场和重定向URI的注册。因为访问令牌被编码到重定向URI中，它可能会暴露给资源所有者和其他驻留在相同设备上的应用。</p>
<pre><code> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span> <span class="comment">Resource</span> <span class="comment">|</span>
 <span class="comment">|</span>  <span class="comment">Owner</span>   <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
      <span class="comment">^</span>
      <span class="comment">|</span>
     <span class="comment">(B)</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>          <span class="comment">Client</span> <span class="comment">Identifier</span>     <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>         <span class="literal">-</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(A)</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">&amp;</span> <span class="comment">Redirection</span> <span class="comment">URI</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>  <span class="comment">User</span><span class="literal">-</span>   <span class="comment">|</span>                                <span class="comment">|</span> <span class="comment">Authorization</span> <span class="comment">|</span>
 <span class="comment">|</span>  <span class="comment">Agent</span>  <span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(B)</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">User</span> <span class="comment">authenticates</span> <span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>     <span class="comment">Server</span>    <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>                                <span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(C)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Redirection</span> <span class="comment">URI</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&lt;<span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>          <span class="comment">with</span> <span class="comment">Access</span> <span class="comment">Token</span>     <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>          <span class="comment">|</span>            <span class="comment">in</span> <span class="comment">Fragment</span>
 <span class="comment">|</span>          <span class="comment">|</span>                                <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>          <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(D)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Redirection</span> <span class="comment">URI</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>   <span class="comment">Web</span><span class="literal">-</span><span class="comment">Hosted</span>  <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>          <span class="comment">without</span> <span class="comment">Fragment</span>      <span class="comment">|</span>     <span class="comment">Client</span>    <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>                                <span class="comment">|</span>    <span class="comment">Resource</span>   <span class="comment">|</span>
 <span class="comment">|</span>     <span class="comment">(F)</span>  <span class="comment">|</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">(E)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Script</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&lt;<span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>                                <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="literal">+</span><span class="literal">-</span><span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
   <span class="comment">|</span>    <span class="comment">|</span>
  <span class="comment">(A)</span>  <span class="comment">(G)</span> <span class="comment">Access</span> <span class="comment">Token</span>
   <span class="comment">|</span>    <span class="comment">|</span>
   <span class="comment">^</span>    <span class="comment">v</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>         <span class="comment">|</span>
 <span class="comment">|</span>  <span class="comment">Client</span> <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
</code></pre><p>注：说明步骤（A）和（B）的直线因为通过用户代理而被分为两部分。</p>
<p>图4：隐式许可流程</p>
<p>图4中的所示流程包含以下步骤：</p>
<ul>
<li>（A）客户端通过向授权端点引导资源所有者的用户代理开始流程。客户端包括它的客户端标识、请求范围、本地状态和重定向URI，一旦访问被许可（或拒绝）授权服务器将传送用户代理回到该URI。</li>
<li>（B）授权服务器验证资源拥有者的身份（通过用户代理），并确定资源所有者是否授予或拒绝客户端的访问请求。</li>
<li>（C）假设资源所有者许可访问，授权服务器使用之前（在请求时或客户端注册时）提供的重定向URI重定向用户代理回到客户端。重定向URI在URI片段中包含访问令牌。</li>
<li>（D）用户代理顺着重定向指示向Web托管的客户端资源发起请求（按<a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a>该请求不包含片段）。用户代理在本地保留片段信息。</li>
<li>（E）Web托管的客户端资源返回一个网页（通常是带有嵌入式脚本的HTML文档），该网页能够访问包含用户代理保留的片段的完整重定向URI并提取包含在片段中的访问令牌（和其他参数）。</li>
<li>（F）用户代理在本地执行Web托管的客户端资源提供的提取访问令牌的脚本。</li>
<li>（G）用户代理传送访问令牌给客户端。</li>
</ul>
<p>参见<a href="../Section01/1.2.3.md">1.3.2</a>节和第<a href="../Section09/9.md">9</a>节了解使用隐式许可的背景。</p>
<p>参见<a href="../Section10/10.3.md">10.3</a>节和<a href="../Section10/10.16.md">10.16</a>节了解当使用隐式许可时的重要安全注意事项。</p>
<ul>
<li>4.2.1. <a href="4.2.1.md">授权请求</a></li>
<li>4.2.2. <a href="4.2.2.md">访问令牌响应</a></li>
</ul>
<h1 id="4-2-1-_授权请求">4.2.1. 授权请求</h1>
<p>客户端通过按<a href="../AppendixB/b.md">附录B</a>使用“application/x-www-form-urlencoded”格式向授权端点URI的查询部分添加下列参数构造请求URI：</p>
<ul>
<li>response_type<br>必需的。值必须设置为“token”。</li>
<li>client_id<br>必需的。如<a href="../Section02/2.2.md">2.2</a>节所述的客户端标识。</li>
<li>redirect_uri<br>可选的。如<a href="../Section03/3.1.2.md">3.1.2</a>节所述。</li>
<li>scope<br>可选的。如<a href="../Section03/3.3.md">3.3</a>节所述的访问请求的范围。</li>
<li>state<br>推荐的。客户度用于维护请求和回调之间的状态的不透明的值。当重定向用户代理回到客户端时，授权服务器包含此值。该参数应该用于防止如<a href="../Section10/10.12.md">10.12</a>所述的跨站点请求伪造。</li>
</ul>
<p>客户端使用HTTP重定向响应向构造的URI定向资源所有者，或者通过经由用户代理至该URI的其他可用方法。</p>
<p>例如，客户端使用TLS定向用户代理发起下述HTTP请求（额外的换行仅用于显示目的）：</p>
<pre><code>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;<span class="keyword">state</span>=xyz&amp;redirect_uri=https<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2Fclient</span><span class="variable">%2Eexample</span><span class="variable">%2Ecom</span><span class="variable">%2Fcb</span> HTTP/<span class="number">1.1</span>
Host: server.example.com
</code></pre><p>授权服务器验证该请求，确保所有需要的参数已提交且有效。授权服务器必须验证它将重定向访问令牌的重定向URI与如<a href="../Section03/3.1.2.md">3.1.2</a>节所述的客户端注册的重定向URI匹配。</p>
<p>如果请求是有效的，授权服务器对资源所有者进行身份验证并获得授权决定（通过询问资源所有者或通过经由其他方式确定批准）。</p>
<p>当确定决定后，授权服务器使用HTTP重定向响应向提供的客户端重定向URI定向用户代理，或者通过经由用户代理至该URI的其他可行方法。</p>
<h1 id="4-2-2-_访问令牌响应">4.2.2. 访问令牌响应</h1>
<p>如果资源所有者许可访问请求，授权服务器颁发访问令牌，通过使用按<a href="../AppendixB/b.md">附录B</a>的“application/x-www-form-urlencoded”格式向重定向URI的片段部分添加下列参数传递访问令牌至客户端：</p>
<ul>
<li>access_token<br>必需的。授权服务器颁发的访问令牌。</li>
<li>token_type<br>必需的。如<a href="../Section07/7.1.md">7.1</a>节所述的颁发的令牌的类型。值是大小写敏感的。</li>
<li>expires_in<br>推荐的。以秒为单位的访问令牌生命周期。例如，值“3600”表示访问令牌将在从生成响应时的1小时后到期。如果省略，则授权服务器应该通过其他方式提供过期时间，或者记录默认值。</li>
<li>scope<br>可选的，若与客户端请求的范围相同；否则，是必需的。如<a href="../Section03/3.3.md">3.3</a>节所述的访问令牌的范围。</li>
<li>state<br>必需的，若“state”参数在客户端授权请求中提交。从客户端接收的精确值。授权服务器不能颁发刷新令牌。</li>
</ul>
<p>例如，授权服务器通过发送以下HTTP响应重定向用户代理：（额外的换行符仅用于显示目的）：</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">302</span> Found</span>
<span class="attribute">Location</span>: <span class="string">http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span>
</code></pre><p>开发人员应注意，一些用户代理不支持在HTTP“Location”HTTP响应标头字段中包含片段组成部分。这些客户端需要使用除了3xx重定向响应以外的其他方法来重定向客户端——-例如，返回一个HTML页面，其中包含一个具有链接到重定向URI的动作的“继续”按钮。</p>
<p>客户端必须忽略无法识别的响应参数。本规范未定义授权码字符串大小。客户端应该避免假设代码值的长度。 授权服务器应记录其发放的任何值的大小。</p>
<ul>
<li>4.2.2.1. <a href="4.2.2.1.md">错误响应</a><h1 id="4-2-2-1-_错误响应">4.2.2.1. 错误响应</h1>
如果由于缺失、无效或不匹配的重定向URI而请求失败，或者如果客户端表示缺失或无效，授权服务器应该通知资源所有者该错误且不能向无效的重定向URI自动重定向用户代理。</li>
</ul>
<p>如果资源所有者拒绝访问请求，或者如果请求因为其他非缺失或无效重定向URI原因而失败，授权服务器通过按<a href="../AppendixB/b.md">附录B</a>使用“application/x-www-form-urlencoded”格式向重定向URI的片段部分添加下列参数通知客户端：</p>
<ul>
<li><p>error<br>必需的。下列ASCII[USASCII]错误代码之一：</p>
<ul>
<li>invalid_request<br>请求缺少必需的参数、包含无效的参数值、包含一个参数超过一次或其他不良格式。</li>
<li>unauthorized_client<br>客户端未被授权使用此方法请求授权码。</li>
<li>access_denied<br>资源所有者或授权服务器拒绝该请求。</li>
<li>unsupported_response_type<br>授权服务器不支持使用此方法获得授权码。</li>
<li>invalid_scope<br>请求的范围无效，未知的或格式不正确。</li>
<li>server_error<br>授权服务器遇到意外情况导致其无法执行该请求。（此错误代码是必要的，因为500内部服务器错误HTTP状态代码不能由HTTP重定向返回给客户端）。</li>
<li>temporarily_unavailable<br>授权服务器由于暂时超载或服务器维护目前无法处理请求。 （此错误代码是必要的，因为503服务不可用HTTP状态代码不可以由HTTP重定向返回给客户端）。</li>
</ul>
<p>“error”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。</p>
</li>
<li><p>error_description<br>可选的。提供额外信息的人类可读的ASCII[USASCII]文本，用于协助客户端开发人员理解所发生的错误。</p>
<p>“error_description”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。</p>
</li>
<li><p>error_uri<br>可选的。指向带有有关错误的信息的人类可读网页的URI，用于提供客户端开发人员关于该错误的额外信息。</p>
<p>“error_uri”参数值必须符合URI参考语法，因此不能包含集合％x21/%x23-5B /％x5D-7E以外的字符。</p>
</li>
<li>state<br>必需的，若“state”参数在客户端授权请求中提交。从客户端接收的精确值。</li>
</ul>
<p>例如，授权服务器通过发送以下HTTP响应重定向用户代理：</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">302</span> Found</span>
<span class="attribute">Location</span>: <span class="string">https://client.example.com/cb#error=access_denied&amp;state=xyz</span>
</code></pre><h1 id="4-3-_资源所有者密码凭据许可">4.3. 资源所有者密码凭据许可</h1>
<p>资源所有者密码凭据许可类型适合于资源所有者与客户端具有信任关系的情况，如设备操作系统或高级特权应用。当启用这种许可类型时授权服务器应该特别关照且只有当其他流程都不可用时才可以。</p>
<p>这种许可类型适合于能够获得资源所有者凭据（用户名和密码，通常使用交互的形式）的客户端。通过转换已存储的凭据至访问令牌，它也用于迁移现存的使用如HTTP基本或摘要身份验证的直接身份验证方案的客户端至OAuth。</p>
<pre><code> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span> <span class="comment">Resource</span> <span class="comment">|</span>
 <span class="comment">|</span>  <span class="comment">Owner</span>   <span class="comment">|</span>
 <span class="comment">|</span>          <span class="comment">|</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
      <span class="comment">v</span>
      <span class="comment">|</span>    <span class="comment">Resource</span> <span class="comment">Owner</span>
     <span class="comment">(A)</span> <span class="comment">Password</span> <span class="comment">Credentials</span>
      <span class="comment">|</span>
      <span class="comment">v</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                  <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>         <span class="comment">|</span>&gt;<span class="literal">-</span><span class="literal">-</span><span class="comment">(B)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Resource</span> <span class="comment">Owner</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>         <span class="comment">Password</span> <span class="comment">Credentials</span>     <span class="comment">|</span> <span class="comment">Authorization</span> <span class="comment">|</span>
 <span class="comment">|</span> <span class="comment">Client</span>  <span class="comment">|</span>                                  <span class="comment">|</span>     <span class="comment">Server</span>    <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="comment">(C)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&lt;<span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>    <span class="comment">(w/</span> <span class="comment">Optional</span> <span class="comment">Refresh</span> <span class="comment">Token)</span>   <span class="comment">|</span>               <span class="comment">|</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                  <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
</code></pre><p>图5：资源所有者密码凭据流程</p>
<p>图5中的所示流程包含以下步骤：</p>
<ul>
<li>（A）资源所有者提供给客户端它的用户名和密码。</li>
<li>（B）通过包含从资源所有者处接收到的凭据，客户端从授权服务器的令牌端点请求访问令牌。当发起请求时，客户端与授权服务器进行身份验证。</li>
<li><p>（C）授权服务器对客户端进行身份验证，验证资源所有者的凭证，如果有效，颁发访问令牌。</p>
</li>
<li><p>4.3.1. <a href="4.3.1.md">授权请求和响应</a></p>
</li>
<li>4.3.2. <a href="4.3.2.md">访问令牌请求</a></li>
<li>4.3.3. <a href="4.3.3.md">访问令牌响应</a><h1 id="4-3-1-_授权请求和响应">4.3.1. 授权请求和响应</h1>
客户端获得资源所有者凭据所通过的方式超出了本规范的范围。一旦获得访问令牌，客户端必须丢弃凭据。<h1 id="4-3-2-_访问令牌请求">4.3.2. 访问令牌请求</h1>
客户端通过使用按<a href="../AppendixB/b.md">附录B</a>“application/x-www-form-urlencoded”格式在HTTP请求实体正文中发送下列UTF-8字符编码的参数向令牌端点发起请求：</li>
<li>grant_type<br>必需的。值必须设置为“password”。</li>
<li>username<br>必需的。资源所有者的用户名。</li>
<li>password<br>必需的。资源所有者的密码。</li>
<li>scope<br>可选的。如<a href="../Section03/3.3.md">3.3</a>节所述的访问请求的范围。<br>如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如<a href="(../Section03/3.2.1.md">3.2.1</a>)节所述与授权服务器进行身份验证。</li>
</ul>
<p>例如，客户端使用传输层安全发起如下HTTP请求（额外的换行仅用于显示目的）：</p>
<pre><code>POST /token HTTP/<span class="number">1.1</span>
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
<span class="variable">grant_type=</span>password&amp;<span class="variable">username=</span>johndoe&amp;<span class="variable">password=</span>A3ddj3w
</code></pre><p>授权服务器必须：</p>
<ul>
<li>要求机密客户端或任何被颁发了客户端凭据（或有其他身份验证要求）的客户端进行客户端身份验证，</li>
<li>若包括了客户端身份验证，验证客户端身份，并</li>
<li>使用它现有的密码验证算法验证资源所有者的密码凭据。</li>
</ul>
<p>由于这种访问令牌请求使用了资源所有者的密码，授权服务器必须保护端点防止暴力攻击（例如，使用速率限制或生成警报）。 </p>
<h1 id="4-3-3-_访问令牌响应">4.3.3. 访问令牌响应</h1>
<p>如果访问令牌请求是有效的且被授权，授权服务器如<a href="../Section05/5.1.md">5.1</a>节所述颁发访问令牌以及可选的刷新令牌。如果请求客户端身份验证失败或无效，授权服务器如<a href="../Section05/5.2.md">5.2</a>节所述的返回错误响应。<br>一个样例成功响应：</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
<span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">no</span>-store
<span class="keyword">Pragma</span>: <span class="keyword">no</span>-<span class="keyword">cache</span>
{
  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,
  <span class="string">"token_type"</span>:<span class="string">"example"</span>,
  <span class="string">"expires_in"</span>:<span class="number">3600</span>,
  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,
  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span>
}</span>
</code></pre><h1 id="4-4-_客户端凭据许可">4.4. 客户端凭据许可</h1>
<p>当客户端请求访问它所控制的，或者事先与授权服务器协商（所采用的方法超出了本规范的范围）的其他资源所有者的受保护资源，客户端可以只使用它的客户端凭据（或者其他受支持的身份验证方法）请求访问令牌。</p>
<p>客户端凭据许可类型必须只能由机密客户端使用。</p>
<pre><code> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                  <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
 <span class="comment">|</span>         <span class="comment">|</span>                                  <span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>&gt;<span class="literal">-</span><span class="literal">-</span><span class="comment">(A)</span><span class="literal">-</span> <span class="comment">Client</span> <span class="comment">Authentication</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">Authorization</span> <span class="comment">|</span>
 <span class="comment">|</span> <span class="comment">Client</span>  <span class="comment">|</span>                                  <span class="comment">|</span>     <span class="comment">Server</span>    <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>&lt;<span class="literal">-</span><span class="literal">-</span><span class="comment">(B)</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Access</span> <span class="comment">Token</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&lt;<span class="comment">|</span>               <span class="comment">|</span>
 <span class="comment">|</span>         <span class="comment">|</span>                                  <span class="comment">|</span>               <span class="comment">|</span>
 <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>                                  <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>
</code></pre><p>图6：客户端凭证流程</p>
<p>图6中的所示流程包含以下步骤：</p>
<ul>
<li>（A）客户端与授权服务器进行身份验证并向令牌端点请求访问令牌。</li>
<li><p>（B）授权服务器对客户端进行身份验证，如果有效，颁发访问令牌。</p>
</li>
<li><p>4.4.1. <a href="4.4.1.md">授权请求和响应</a></p>
</li>
<li>4.4.2. <a href="4.4.2.md">访问令牌请求</a></li>
<li>4.4.3. <a href="4.4.3.md">访问令牌响应</a><h1 id="4-4-1-_授权请求和响应">4.4.1. 授权请求和响应</h1>
由于客户端身份验证被用作授权许可，所以不需要其他授权请求。<h1 id="4-4-2-_访问令牌请求">4.4.2. 访问令牌请求</h1>
客户端通过使用按附录B“application/x-www-form-urlencoded”格式在HTTP请求实体正文中发送下列UTF-8字符编码的参数向令牌端点发起请求：</li>
<li>grant_type<br>必需的。值必须设置为“client_credentials”。</li>
<li>scope<br>可选的。如<a href="../Section03/3.3.md">3.3</a>节所述的访问请求的范围。</li>
</ul>
<p>客户端必须如<a href="../Section03/3.2.1.md">3.2.1</a>所述与授权服务器进行身份验证。</p>
<p>例如，客户端使用传输层安全发起如下HTTP请求（额外的换行仅用于显示目的）：</p>
<pre><code>POST /token HTTP/<span class="number">1.1</span>
<span class="label">Host:</span> server.example.com
<span class="label">Authorization:</span> Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/<span class="built_in">x</span>-www-form-urlencoded
grant_type=client_credentials
</code></pre><p>授权服务器必须对客户端进行身份验证。</p>
<h1 id="4-4-3-_访问令牌响应">4.4.3. 访问令牌响应</h1>
<p>如果访问令牌请求是有效的且被授权，授权服务器如<a href="../Section05/5.1.md">5.1</a>节所述颁发访问令牌以及可选的刷新令牌。刷新令牌不应该包含在内。 如果请求因客户端身份验证失败或无效，授权服务器如<a href="../Section05/5.2.md">5.2</a>节所述的返回错误响应。</p>
<p>一个样例成功响应：</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
<span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">no</span>-store
<span class="keyword">Pragma</span>: <span class="keyword">no</span>-<span class="keyword">cache</span>
{
  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,
  <span class="string">"token_type"</span>:<span class="string">"example"</span>,
  <span class="string">"expires_in"</span>:<span class="number">3600</span>， <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span>
}</span>
</code></pre><h1 id="4-5-_扩展许可">4.5. 扩展许可</h1>
<p>通过使用绝对URI作为令牌端点的“grant_type”参数的值指定许可类型，并通过添加任何其他需要的参数，客户端使用扩展许可类型。</p>
<p>例如，采用[OAuth-SAML]定义的安全断言标记语言（SAML）2.0断言许可类型请求访问令牌，客户端可以使用TLS发起如下的HTTP请求（额外的换行仅用于显示目的）：</p>
<pre><code>POST /token HTTP/<span class="number">1.1</span>
Host: server.example.com
Content-Type: application/x-www-form-urlencoded
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2bearer&amp;assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU[<span class="keyword">...</span>为简洁起见省略<span class="keyword">...</span>]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
</code></pre><p>如果访问令牌请求是有效的且被授权，授权服务器如<a href="../Section05/5.1.md">5.1</a>节所述颁发访问令牌以及可选的刷新令牌。如果请求因客户端身份验证失败或无效，授权服务器如<a href="../Section05/5.2.md">5.2</a>节所述的返回错误响应。</p>
<h1 id="5-_颁发访问令牌">5. 颁发访问令牌</h1>
<p>如果访问令牌请求是有效的且被授权，授权服务器如5.1节所述颁发访问令牌以及可选的刷新令牌。如果请求因客户端身份验证失败或无效，授权服务器如5.2节所述的返回错误响应。</p>
<ul>
<li>5.1. <a href="5.1.md">成功响应</a></li>
<li>5.2. <a href="5.2.md">错误响应</a><h1 id="5-1-_成功的响应">5.1. 成功的响应</h1>
授权服务器颁发访问令牌和可选的刷新令牌，通过向HTTP响应实体正文中添加下列参数并使用200（OK）状态码构造响应：</li>
<li>access_token<br>必需的。授权服务器颁发的访问令牌。</li>
<li>token_type<br>必需的。如<a href="../Section07/7.1.md">7.1</a>节所述的颁发的令牌的类型。值是大小写敏感的。</li>
<li>expires_in<br>推荐的。以秒为单位的访问令牌生命周期。例如，值“3600”表示访问令牌将在从生成响应时的1小时后到期。如果省略，则授权服务器应该通过其他方式提供过期时间，或者记录默认值。</li>
<li>refresh_token<br>可选的。刷新令牌，可以用于如第<a href="../Section06/6.md">6</a>节所述使用相同的授权许可获得新的访问令牌。</li>
<li>scope<br>可选的，若与客户端请求的范围相同；否则，必需的。如<a href="../Section03/3.3.md">3.3</a>节所述的访问令牌的范围。</li>
</ul>
<p>这些参数使用<a href="http://tools.ietf.org/html/rfc4627" title="JSON" target="_blank" rel="external">RFC4627</a>定义的“application/json”媒体类型包含在HTTP响应实体正文中。通过将每个参数添加到最高结构级别， 参数被序列化为JavaScript对象表示法（JSON）的结构。参数名称和字符串值作为JSON字符串类型包含。数值的值作为JSON数字类型包含。参数顺序无关并可以变化。</p>
<p>在任何包含令牌、凭据或其他敏感信息的响应中，授权服务器必须在其中包含值为“no-store”的HTTP“Cache-Control”响应头部域<a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a>，和值为“no-cache”的“Pragma”响应头部域<a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a>。例如：</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
<span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">no</span>-store
<span class="keyword">Pragma</span>: <span class="keyword">no</span>-<span class="keyword">cache</span>
{
  <span class="string">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,
  <span class="string">"token_type"</span>:<span class="string">"example"</span>,
  <span class="string">"expires_in"</span>:<span class="number">3600</span>,
  <span class="string">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,
  <span class="string">"example_parameter"</span>:<span class="string">"example_value"</span>
}</span>
</code></pre><p>客户端必须忽略响应中不能识别的值的名称。令牌和从授权服务器接收到的值的大小未定义。客户端应该避免对值的大小做假设。授权服务器应记录其发放的任何值的大小。</p>
<h1 id="5-2-_错误响应">5.2. 错误响应</h1>
<p>授权服务器使用HTTP 400（错误请求）状态码响应，在响应中包含下列参数：</p>
<ul>
<li><p>error<br>必需的。下列ASCII[USASCII]错误代码之一：</p>
<ul>
<li>invalid_request<br>请求缺少必需的参数、包含不支持的参数值（除了许可类型）、重复参数、包含多个凭据、采用超过一种客户端身份验证机制或其他不规范的格式。</li>
<li>invalid_client<br>客户端身份验证失败（例如，未知的客户端，不包含客户端身份验证，或不支持的身份验证方法）。授权服务器可以返回HTTP 401（未授权）状态码来指出支持的HTTP身份验证方案。如果客户端试图通过“Authorization”请求标头域进行身份验证，授权服务器必须响应HTTP 401（未授权）状态码，并包含与客户端使用的身份验证方案匹配的“WWW-Authenticate”响应标头字段。</li>
<li>invalid_grant<br>提供的授权许可（如授权码、资源所有者凭据）或刷新令牌无效、过期、吊销、与在授权请求使用的重定向URI不匹配或颁发给另一个客户端。</li>
<li>unauthorized_client<br>进行身份验证的客户端没有被授权使用这种授权许可类型。</li>
<li>unsupported_grant_type<br>授权许可类型不被授权服务器支持。</li>
<li>invalid_scope<br>请求的范围无效、未知的、格式不正确或超出资源所有者许可的范围。</li>
</ul>
<p>“error”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。</p>
</li>
<li>error_description<br>可选的。提供额外信息的人类可读的ASCII[USASCII]文本，用于协助客户端开发人员理解所发生的错误。“error_description”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。</li>
<li>error_uri<br>可选的。指向带有有关错误的信息的人类可读网页的URI，用于提供客户端开发人员关于该错误的额外信息。“error_uri”参数值必须符合URI参考语法，因此不能包含集合％x21/%x23-5B /％x5D-7E以外的字符。</li>
</ul>
<p>这些参数使用<a href="http://tools.ietf.org/html/rfc4627" title="JSON" target="_blank" rel="external">RFC4627</a>定义的“application/json”媒体类型包含在HTTP响应实体正文中。通过将每个参数添加到最高结构级别， 参数被序列化为JavaScript对象表示法（JSON）的结构。参数名称和字符串值作为JSON字符串类型包含。数值的值作为JSON数字类型包含。参数顺序无关并可以变化。例如：</p>
<pre><code>HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
<span class="operator"><span class="keyword">Cache</span>-Control: <span class="keyword">no</span>-store
<span class="keyword">Pragma</span>: <span class="keyword">no</span>-<span class="keyword">cache</span>
{
  <span class="string">"error"</span>:<span class="string">"invalid_request"</span>
}</span>
</code></pre><h1 id="6-_刷新访问令牌">6. 刷新访问令牌</h1>
<p>若授权服务器给客户端颁发了刷新令牌，客户端通过使用按<a href="../AppendixB/b.md">附录B</a>“application/x-www-form-urlencoded”格式在HTTP请求实体正文中发送下列UTF-8字符编码的参数向令牌端点发起刷新请求：</p>
<ul>
<li>grant_type<br>必需的。值必须设置为“refresh_token”。</li>
<li>refresh_token<br>必需的。颁发给客户端的刷新令牌。</li>
<li>scope<br>可选的。如<a href="../Section03/3.3.md">3.3</a>节所述的访问请求的范围。请求的范围不能包含任何不是由资源所有者原始许可的范围，若省略，被视为与资源所有者原始许可的范围相同。</li>
</ul>
<p>因为刷新令牌通常是用于请求额外的访问令牌的持久凭证，刷新令牌绑定到被它被颁发给的客户端。如果客户端类型是机密的或客户端被颁发了客户端凭据（或选定的其他身份验证要求），客户端必须如<a href="../Section03/3.2.1.md">3.2.1</a>节所述与授权服务器进行身份验证。</p>
<p>例如，客户端使用传输层安全发起如下HTTP请求（额外的换行仅用于显示目的）：</p>
<pre><code>POST /token HTTP/<span class="number">1.1</span>
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
<span class="variable">grant_type=</span>refresh_token&amp;<span class="variable">refresh_token=</span>tGzv3JOkF0XG5Qx2TlKWIA
</code></pre><p>授权服务器必须：</p>
<ul>
<li>要求机密客户端或任何被颁发了客户端凭据（或有其他身份验证要求）的客户端进行客户端身份验证，</li>
<li>若包括了客户端身份验证，验证客户端身份并确保刷新令牌是被颁发给进行身份验证的客户端的，并</li>
<li>验证刷新令牌。</li>
</ul>
<p>如果有效且被授权，授权服务器如<a href="../Section05/5.1.md">5.1</a>节所述颁发访问令牌。如果请求因验证失败或无效，授权服务器<a href="../Section05/5.2.md">5.2</a>节所述返回错误响应。</p>
<p>授权服务器可以颁发新的刷新令牌，在这种情况下，客户端必须放弃旧的刷新令牌，替换为新的刷新令牌。在向客户端颁发新的刷新令牌后授权服务器可以撤销旧的刷新令牌。若颁发了新的刷新令牌，刷新令牌的范围必须与客户端包含在请求中的刷新令牌的范围相同。</p>
<h1 id="7-_访问受保护资源">7. 访问受保护资源</h1>
<p>通过向资源服务器出示访问令牌，客户端访问受保护资源。资源服务器必须验证访问令牌，并确保它没有过期且其范围涵盖了请求的资源。资源服务器用于验证访问令牌的方法（以及任何错误响应）超出了本规范的范围，但一般包括资源服务器和授权服务器之间的互动或协调。</p>
<p>客户端使用访问令牌与资源服务器进行证认的方法依赖于授权服务器颁发的访问令牌的类型。通常，它涉及到使用具有所采用的访问令牌类型的规范定义的身份验证方案(如<a href="http://tools.ietf.org/html/rfc6750" title="The OAuth 2.0 Authorization Framework: Bearer Token Usage" target="_blank" rel="external">RFC6750</a>)的HTTP“Authorization”的请求标头字段<a href="http://tools.ietf.org/html/rfc2617" title="HTTP Authentication: Basic and Digest Access Authentication" target="_blank" rel="external">RFC2617</a>。</p>
<ul>
<li>7.1. <a href="7.1.md">访问令牌类型</a></li>
<li>7.2. <a href="7.2.md">错误响应</a></li>
</ul>
<h1 id="7-1-_访问令牌类型">7.1. 访问令牌类型</h1>
<p>访问令牌的类型给客户端提供了成功使用该访问令牌（和类型指定的属性）发起受保护资源请求所需的信息 若客户端不理解令牌类型，则不能使用该访问令牌。</p>
<p>例如，<a href="http://tools.ietf.org/html/rfc6750" title="The OAuth 2.0 Authorization Framework: Bearer Token Usage" target="_blank" rel="external">RFC6750</a>定义的“bearer”令牌类型简单的在请求中包含访问令牌字符串来使用：</p>
<pre><code><span class="request">GET <span class="string">/resource/1</span> HTTP/1.1</span>
<span class="attribute">Host</span>: <span class="string">example.com</span>
<span class="attribute">Authorization</span>: <span class="string">Bearer F_9.B5f-4.1JqM</span>
</code></pre><p>而[OAuth-HTTP-MAC]定义的“mac”令牌类型通过与许可类型一起颁发用于对HTTP请求中某些部分签名的消息认证码（MAC）的密钥来使用。</p>
<pre><code><span class="request">GET <span class="string">/resource/1</span> HTTP/1.1</span>
<span class="attribute">Host</span>: <span class="string">example.com</span>
<span class="attribute">Authorization</span>: <span class="string">MAC id="h480djs93hd8",nonce="274312:dj83hs9s",mac="kDZvddkndxvhGRXZhvuDjEWhGeE="</span>
</code></pre><p>提供上面的例子仅作说明用途。建议开发人员在使用前查阅<a href="http://tools.ietf.org/html/rfc6750" title="The OAuth 2.0 Authorization Framework: Bearer Token Usage" target="_blank" rel="external">RFC6750</a>和[OAuth-HTTP-MAC]规范。</p>
<p>每一种访问令牌类型的定义指定与“access_token”响应参数一起发送到客户端的额外属性。它还定义了HTTP验证方法当请求受保护资源时用于包含访问令牌。</p>
<h1 id="7-2-_错误响应">7.2. 错误响应</h1>
<p>如果资源访问请求失败，资源服务器应该通知客户端该错误。虽然规定这些错误响应超出了本规范的范围，但是本文档在<a href="../Section11/11.4.md">11.4</a>节建立了一张公共注册表，用作OAuth令牌身份验证方案之间分享的错误值。</p>
<p>主要为OAuth令牌身份验证设计的新身份验证方案应该定义向客户端提供错误状态码的机制，其中允许的错误值限于本规范建立的错误注册表中。</p>
<p>这些方案可以限制有效的错误代码是注册值的子集。如果错误代码使用命名参数返回，该参数名称应该是“error”。</p>
<p>其他能够被用于OAuth令牌身份验证的方案，但不是主要为此目的而设计的，可以帮顶他们的错误值到相同方式的注册表项。</p>
<p>新的认证方案也可以选择指定使用“error_description”和&quot;error_uri&quot;参数，用于以本文档中用法相同的方式的返回错误信息。</p>
<h1 id="8-_可扩展性">8. 可扩展性</h1>
<ul>
<li>8.1. <a href="8.1.md">定义访问令牌类型</a></li>
<li>8.2. <a href="8.2.md">定义新的端点参数</a></li>
<li>8.3. <a href="8.3.md">定义新的授权许可类型</a></li>
<li>8.4. <a href="8.4.md">定义新的授权端点响应类型</a></li>
<li>8.5. <a href="8.5.md">定义其他错误代码</a><h1 id="8-1-_定义访问令牌类型">8.1. 定义访问令牌类型</h1>
访问令牌类型可以用以下两种方法之一来定义：在访问令牌类型注册表中注册（按<a href="../Section11/11.1.md">11.1</a>节中的过程）的，或者通过使用一个唯一的绝对URI作为它的名字。</li>
</ul>
<p>采用URI命名的类型应该限定于特定供应商的实现，它们不是普遍适用的并且特定于使用它们的资源服务器的实现细节。</p>
<p>所有其他类型都必须注册。类型名称必需符合type-name ANBF。如果类型定义包含了一种新的HTTP身份验证方案，该类型名称应该与该HTTP身份验证方案名称一致（如<a href="http://tools.ietf.org/html/rfc2617" title="HTTP Authentication: Basic and Digest Access Authentication" target="_blank" rel="external">RFC2617</a>定义）。令牌类型“example”被保留用于样例中。</p>
<pre><code><span class="class"><span class="keyword">type</span>-<span class="title">name</span>  </span>= <span class="number">1</span>*name-<span class="built_in">char</span>
name-<span class="built_in">char</span>  = <span class="string">"-"</span> / <span class="string">"."</span> / <span class="string">"_"</span> / DIGIT / ALPHA
</code></pre><h1 id="8-2-_定义新的端点参数">8.2. 定义新的端点参数</h1>
<p>用于授权端点或令牌端点的新的请求或响应参数按照<a href="../Section11/11.2.md">11.2</a>节中的过程在OAuth参数注册表中定义和注册。</p>
<p>参数名称必须符合param-name ABNF，并且参数值的语法必须是明确定义的（例如，使用ABNF，或现有参数的语法的引用）。</p>
<pre><code>param-name  = <span class="number">1</span>*name-<span class="keyword">char</span>
name-<span class="keyword">char</span>   = <span class="string">"-"</span> <span class="regexp">/ "." /</span> <span class="string">"_"</span> <span class="regexp">/ DIGIT /</span> ALPHA
</code></pre><p>不是普遍适用的并且特定于使用它们的授权服务器的实现细节的未注册的特定供应商的参数扩展应该采用特定供应商的前缀（例如，以“companyname_”开头），从而不会与其他已注册的值冲突。</p>
<h1 id="8-3-_定义新的授权许可类型">8.3. 定义新的授权许可类型</h1>
<p>新的授权许可类型可以通过赋予它们一个“grant_type”参数使用的唯一的绝对URI来定义。如果扩展许可类型需要其他令牌端点参数，它们必须如<a href="../Section11/11.2.md">11.2</a>节所述在OAuth参数注册表中注册。</p>
<h1 id="8-4-_定义新的授权端点响应类型">8.4. 定义新的授权端点响应类型</h1>
<p>用于授权端点的新的响应类型按照<a href="../Section11/11.3.md">11.3</a>节中的过程在授权端点响应类型注册表中定义和注册。响应类型名称必须符合response-type ABNF。</p>
<pre><code><span class="built_in">response</span>-type  = <span class="built_in">response</span>-name *( SP <span class="built_in">response</span>-name )
<span class="built_in">response</span>-name  = <span class="number">1</span>*<span class="built_in">response</span>-char
<span class="built_in">response</span>-char  = <span class="string">"_"</span> / DIGIT / ALPHA
</code></pre><p>如果响应类型包含一个或多个空格字符（%x20），它被看作是一个空格分隔的值列表，其中的值的顺序不重要。只有一种值的顺序可以被注册，它涵盖了相同的值的集合的所有其他排列。</p>
<p>例如，响应类型“token code”未由本规范定义。然而，一个扩展可以定义和注册“token code”响应类型。 一旦注册，相同的组合“code token”不能被注册，但是这两个值都可以用于表示相同的响应类型。</p>
<h1 id="8-5-_定义其他错误代码">8.5. 定义其他错误代码</h1>
<p>在协议扩展（例如，访问令牌类型、扩展参数或扩展许可类型等）需要其他错误代码用于授权码许可错误响应（<a href="../Section04/4.1.2.1.md">4.1.2.1</a>节）、隐式许可错误响应（<a href="../Section04/4.2.2.1.md">4.2.2.1</a>节）、令牌错误响应（<a href="../Section5.2.md">5.2</a>节）或资源访问错误响应（<a href="../Section07/7.2.md">7.2</a>节）的情况下，这些错误代码可以被定义。</p>
<p>如果用于与它们配合的扩展是已注册的访问令牌类型，已注册的端点参数或者扩展许可类型，扩展错误代码必须被注册。用于未注册扩展的错误代码可以被注册。</p>
<p>错误代码必须符合的error ABNF，且可能的话应该以一致的名称作前缀。例如，一个表示给扩展参数“example”设置了无效值的错误应该被命名为“example_invalid”。</p>
<pre><code> <span class="keyword">error</span>      = <span class="number">1</span>*<span class="keyword">error</span>-<span class="built_in">char</span>
 <span class="keyword">error</span>-<span class="built_in">char</span> = %x20-<span class="number">21</span> / %x23-<span class="number">5</span>B / %x5D-<span class="number">7</span>E
</code></pre><h1 id="9-_本机应用程序">9. 本机应用程序</h1>
<p>本机应用程序是安装和执行在资源所有者使用的设备上的客户端（例如，桌面程序，本机移动应用）。本机应用程序需要关于安全、平台能力和整体最终用户体验的特别注意事项。</p>
<p>授权端点需要在客户端和资源所有者用户代理之间进行交互。本机应用程序可以调用外部的用户代理，或在应用程序中嵌入用户代理。例如：</p>
<ul>
<li>外部用户代理-本机应用程序可以捕获来自授权服务器的响应。它可以使用带有操作系统已注册方案的重定向URI调用客户端作为处理程序，手动复制粘贴凭据，运行本地Web服务器，安装用户代理扩展，或者通过提供重定向URI来指定客户端控制下的服务器托管资源，反过来使响应对本机应用程序可用。</li>
<li>嵌入式用户代理-通过监视资源加载过程中发生的状态变化或者访问用户代理的cookies存储，本机应用程序直接与嵌入式用户代理通信，获得响应。<br>当在外部或嵌入式用户代理中选择时，开发者应该考虑如下：</li>
<li>外部用户代理可能会提高完成率，因为资源所有者可能已经有了与授权服务器的活动会话，避免了重新进行身份验证的需要。它提供了熟悉的最终用户体验和功能。资源所有者可能也依赖于用户代理特性或扩展帮助他进行身份验证（例如密码管理器、两步设备读取器）</li>
<li>嵌入式用户代理可能会提供更好的可用性，因为它避免了切换上下文和打开新窗口的需要。</li>
<li>嵌入式用户代理构成了安全挑战，因为资源所有者在一个未识别的窗口中进行身份验证，无法获得在大多数外部用户代理中的可视的保护。嵌入式用户代理教育用户信任未标识身份验证请求（使钓鱼攻击更易于实施）。<br>当在隐式许可类型和授权码许可类型中选择时，下列应该被考虑：</li>
<li>使用授权码许可类型的本机应用程序应该这么做而不需使用用户凭据，因为本机应用程序无力保持客户端凭据的机密性。</li>
<li>当使用隐式许可类型流程时，刷新令牌不会返回，这就要求一旦访问令牌过期就要重复授权过程。</li>
</ul>
<h1 id="10-_安全考量">10. 安全考量</h1>
<p>作为一个灵活的可扩展的框架，OAuth的安全性考量依赖于许多因素。 以下小节提为实现者提供了聚焦在<a href="../Section02/2.1.md">2.1</a>节所述的三种客户端配置上的安全指南：Web应用、基于用户代理的应用和本地应用程序。</p>
<p>全面的OAuth安全模型和分析以及该协议设计的背景在[OAuth-THREATMODE]中提供。</p>
<ul>
<li>10.1. <a href="10.1.md">客户端身份验证</a></li>
<li>10.2. <a href="10.2.md">客户端仿冒</a></li>
<li>10.3. <a href="10.3.md">访问令牌</a></li>
<li>10.4. <a href="10.4.md">刷新令牌</a></li>
<li>10.5. <a href="10.5.md">授权码</a></li>
<li>10.6. <a href="10.6.md">授权码重定向URI操纵</a></li>
<li>10.7. <a href="10.7.md">资源拥有者密码凭据</a></li>
<li>10.8. <a href="10.8.md">请求机密性</a></li>
<li>10.9. <a href="10.9.md">确保端点真实性</a></li>
<li>10.10. <a href="10.10.md">凭据猜测攻击</a></li>
<li>10.11. <a href="10.11.md">钓鱼攻击</a></li>
<li>10.12. <a href="10.12.md">跨站请求伪造</a></li>
<li>10.13. <a href="10.13.md">点击劫持</a></li>
<li>10.14. <a href="10.14.md">代码注入和输入验证</a></li>
<li>10.15. <a href="10.15.md">自由重定向</a></li>
<li>10.16. <a href="10.16.md">隐式流程中滥用访问令牌假冒资源所有者</a><h1 id="10-1-_客户端身份验证">10.1. 客户端身份验证</h1>
授权服务器为进行客户端身份验证的目的，为Web应用客户端创建客户端凭据。授权服务器被鼓励考虑比客户端密码更强的客户端身份验证手段。Web应用程序客户端必须确保客户端密码和其他客户端凭据的机密性。</li>
</ul>
<p>授权不得向本地应用程序或基于用户代理的应用客户端颁发客户端密码或其他客户端凭据用于客户端验证目的。授权服务器可以颁发客户端密码或其他凭据给专门的设备上特定安装的本地应用程序客户端。</p>
<p>当客户端身份验证不可用时，授权服务器应该采用其他方式来验证客户端的身份-例如，通过要求客户端重定向URI的注册或者引入资源所有者来确认身份。当请求资源所有者授权时，有效的重定向URI是不足以验证客户端的身份，但可以用来防止在获得资源所有者授权后将凭据传递给假冒的客户端。</p>
<p>授权服务器必须考虑与未进行身份验证的客户端交互的安全实现并采取措施限制颁发给这些客户端的其他凭据（如刷新令牌）的潜在泄露。</p>
<h1 id="10-2-_客户端仿冒">10.2. 客户端仿冒</h1>
<p>如果被仿冒的客户端不能，或无法保持其客户端凭据保密。恶意客户端可能冒充其他客户端，并获得对受保护资源的访问权限。</p>
<p>授权服务器任何可能的时候必须验证客户端身份。如果授权服务器由于客户端的性质无法对客户端进行身份验证，授权服务器必须要求注册任何用于接收授权响应的重定向URI并且应该利用其他手段保护资源所有者防止这样的潜在仿冒客户端。例如，授权服务器可以引入资源所有者来帮助识别客户端和它的来源。</p>
<p>授权服务器应该实施显式的资源所有者身份验证并且提供给资源所有者有关客户端及其请求的授权范围和生命周期的信息。由资源所有者在当前客户端上下文中审查信息并授权或拒绝该请求。</p>
<p>授权服务器未对客户端进行身份验证（没有活动的资源所有者交互）或未依靠其他手段确保重复的请求来自于原始客户端而非冒充者时，不应该自动处理重复的授权请求。</p>
<h1 id="10-3-_访问令牌">10.3. 访问令牌</h1>
<p>访问令牌凭据（以及任何机密的访问令牌属性）在传输和储存时必须保持机密性，并只与授权服务器、访问令牌生效的资源服务器和访问令牌被颁发的客户端共享。访问令牌凭据必须只能使用带有<a href="http://tools.ietf.org/html/rfc2818" title="HTTP Over TLS" target="_blank" rel="external">RFC2818</a>定义的服务器身份验证的<a href="../Section01/1.6.md">1.6</a>节所述的TLS 传输。</p>
<p>当使用隐式授权许可类型时，访问令牌在URI片段中传输，这可能泄露访问令牌给未授权的一方。</p>
<p>授权服务器必须确保访问令牌不能被生成、修改或被未授权一方猜测而产生有效的访问令牌。</p>
<p>客户端应该为最小范围的需要请求访问令牌。授权服务器在选择如何兑现请求的范围时应该将客户端身份考虑在内，且可以颁发具有比请求的更少的权限的访问令牌。</p>
<p>本规范未给资源服务器提供任何方法来确保特定的客户端提交给它的访问令牌是授权服务器颁发给此客户端的。</p>
<h1 id="10-4-_刷新令牌">10.4. 刷新令牌</h1>
<p>授权服务器可以给Web应用客户端和本机应用程序客户端颁发刷新令牌。</p>
<p>刷新令牌在传输和储存时必须保持机密性，并只与授权服务器和刷新令牌被颁发的客户端共享。授权服务器必须维护刷新令牌和它被颁发给的客户端之间的绑定。刷新令牌必须只能使用带有<a href="http://tools.ietf.org/html/rfc2818" title="HTTP Over TLS" target="_blank" rel="external">RFC2818</a>定义的服务器身份验证的<a href="../Section01/1.6.md">1.6</a>所述的TLS 传输。<br>授权服务器必须验证刷新令牌和客户端身份之间的绑定，无论客户端身份是否能被验证。当无法进行客户端身份验证时，授权服务器应该采取其他手段检测刷新令牌滥用。</p>
<p>例如，授权服务器可以使用刷新令牌轮转机制，随着每次访问令牌刷新响应，新的刷新令牌被颁发。以前的刷新令牌被作废但是由授权服务器保留。如果刷新令牌被泄露，随后同时被攻击者和合法客户端使用，他们中一人将提交被作废的刷新令牌，这将通知入侵给授权服务器。</p>
<p>授权服务器必须确保刷新令牌不能被生成、修改或被未授权一方猜测而产生有效的刷新令牌。</p>
<h1 id="10-5-_授权码">10.5. 授权码</h1>
<p>授权码的传输应该建立在安全通道上，客户端应该要求在它的重定向URI上使用TLS，若该URI指示了一个网络资源。 由于授权码由用户代理重定向传输，它们可能潜在地通过用户代理历史记录和HTTP参照标头被泄露。</p>
<p>授权码明以纯文本承载凭据使用，用于验证在授权服务器许可权限的资源所有者就是返回到客户端完成此过程的相同的资源所有者。因此，如果客户端依赖于授权码作为它自己的资源所有者身份验证，客户端重定向端点必须要求使用TLS。</p>
<p>授权码必须是短暂的且是单用户的。如果授权服务器观察到多次以授权码交换访问令牌的尝试，授权服务器应该试图吊销所有基于泄露的授权码而颁发的访问令牌。</p>
<p>如果客户端可以进行身份验证，授权服务器必须验证客户端身份，并确保授权码颁发给了同一个客户端。</p>
<h1 id="10-6-_授权码重定向URI伪造">10.6. 授权码重定向URI伪造</h1>
<p>当使用授权码许可类型请求授权时，客户端可以通过“redirect_uri”参数指定重定向URI。 如果攻击者能够伪造重定向URI的值，这可能导致授权服务器向攻击者控制的URI重定向带有授权码的资源所有者用户代理。</p>
<p>攻击者可以在合法客户端上创建一个帐户，并开始授权流程。当攻击者的用户代理被发送到授权服务器来许可访问权限时，攻击者抓取合法客户端提供的授权URI并用攻击者控制下的URI替换客户端的重定向URI。 攻击者然后欺骗受害者顺着仿冒的链接来对合法客户端授权访问权限。</p>
<p>一旦在授权服务器——受害者被唆使代表一个合法的被信任的客户端使用正常有效的请求——授权该请求时。受害者然后带着授权码重定向到受攻击者控制的端点。通过使用客户端提交的原始重定向URI向客户端发送授权码，攻击者完成授权流程。客户端用授权码交换访问令牌并与将它与攻击者的客户端账号关联，该账户现在能获得受害者授权的（通过客户端）对访问受保护资源的访问权限。</p>
<p>为了防止这种攻击，授权服务器必须确保用于获得授权码的重定向URI与当用授权码交换访问令牌时提供的重定向URI相同。授权服务器必须要求公共客户端，并且应该要求机密客户注册它们的重定向URI。如果在请求中提供一个重定向URI，授权服务器必须验证对注册的值。如果在请求中提供了重定向URI，授权服务器必须对比已注册的。<br>10.7. 资源所有者密码凭据</p>
<p>资源所有者密码凭据许可类型通常用于遗留或迁移原因。它降低了由客户端存储用户名和密码的整体风险，但并没有消除泄露高度特权的凭证给客户端的需求。</p>
<p>这种许可类型比其他许可类型承载了更高的风险，因为它保留了本协议寻求避免的密码反模式。客户端可能滥用密码或密码可能会无意中被泄露给攻击者（例如，通过客户端保存的日志文件或其他记录）。</p>
<p>此外，由于资源拥有者对授权过程没有控制权（在转手它的凭据给客户端后资源所有者的参与结束），客户端可以获得比资源所有者预期的具有更大范围的访问令牌。授权服务器应该考虑由这种许可类型颁发的访问令牌的范围和寿命。</p>
<p>授权服务器和客户端应该尽量减少这种许可类型的使用，并尽可能采用其他许可类型。</p>
<h1 id="10-8-_请求机密性">10.8. 请求机密性</h1>
<p>访问令牌、刷新令牌、资源所有者密码和客户端凭据不能以明文传输。授权码不应该以明文传输。</p>
<p>“state”和“scope”参数不应该包含敏感的客户端或资源所有者的纯文本信息，因为它们可能在不安全的通道上被传输或被不安全地存储。</p>
<h1 id="10-9-_确保端点真实性">10.9. 确保端点真实性</h1>
<p>为了防止中间人攻击，授权服务器必须对任何被发送到授权和令牌端点的请求要求<a href="http://tools.ietf.org/html/rfc2818" title="HTTP Over TLS" target="_blank" rel="external">RFC2818</a>中定义的具有服务器身份验证的TLS 的使用。客户端必须按<a href="http://tools.ietf.org/html/rfc6125" title="Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)" target="_blank" rel="external">RFC6125</a>定义且按照它服务器身份进行身份验证的需求验证授权服务器的的TLS证书。</p>
<h1 id="10-10-_凭据猜测攻击">10.10. 凭据猜测攻击</h1>
<p>授权服务器必须防止攻击者猜测访问令牌、授权码、刷新令牌、资源所有者密码和客户端凭据。</p>
<p>攻击者猜测已生成令牌（和其它不打算被最终用户掌握的凭据）的概率必须小于或等于2 ^（-128），并且应该小于或等于2 ^（-160）。</p>
<p>授权服务器必须采用其他手段来保护打算给最终用户使用的凭据。</p>
<h1 id="10-11-_钓鱼攻击">10.11. 钓鱼攻击</h1>
<p>本协议或类似协议的广泛部署，可能导致最终用户变成习惯于被重定向到要求输入他们的密码的网站的做法。</p>
<p>如果最终用户在输入他们的凭据前不注意辨别这些网站的真伪，这将使攻击者利用这种做法窃取资源所有者的密码成为可能。</p>
<p>服务提供者应尝试教育最终用户有关钓鱼攻击构成的风险，并且应该为最终用户提供使确认它们的站点的真伪变得简单的机制。客户端开发者应该考虑他们如何与用户代理（例如，外部的和嵌入式的）交互的安全启示以及最终用户辨别授权服务器真伪的能力。</p>
<p>为了减小钓鱼攻击的风险，授权服务器必须要求在用于最终用户交互的每个端点上使用TLS。</p>
<h1 id="10-12-_跨站请求伪造">10.12. 跨站请求伪造</h1>
<p>跨站请求伪造（CSRF）是一种漏洞利用，攻击者致使受害的最终用户按恶意URI（例如以误导的链接、图片或重定向提供给用户代理）到达受信任的服务器（通常由存在有效的会话Cookie而建立）。</p>
<p>针对客户端的重定向URI的CSRF攻击允许攻击者注入自己的授权码或访问令牌，这将导致在客户端中使用与攻击者的受保护资源关联的访问令牌而非受害者的（例如，保存受害者的银行账户信息到攻击者控制的受保护资源）。</p>
<p>客户端必须为它的重定向URI实现CSRF保护。这通常通过要求向重定向URI端点发送的任何请求包含该请求对用户代理身份认证状态的绑定值（例如，用于对用户代理进行身份验证的会话Cookie的哈希值）来实现。客户端应该使用“state”请求参数在发起授权请求时向授权服务器传送该值。</p>
<p>一旦从最终用户获得授权，授权服务器重定向最终用户的用户代理带着要求的包含在“state”参数中的绑定值回到客户端。 通过该绑定值与用户代理的身份验证状态的匹配，绑定值使客户端能够验证请求的有效性。用于CSRF保护的绑定值必须包含不可猜测的值（如<a href="10.10.md">10.10</a>节所述）且用户代理的身份验证状态（例如会话Cookie、HTML5本地存储）必须保存在只能被客户端和用户代理访问的地方（即通过同源策略保护）。</p>
<p>针对授权服务器的授权端点的CSRF攻击可能导致攻击者获得最终用户为恶意客户端的授权而不牵涉或警告最终用户。</p>
<p>授权服务器必须为它的授权端点实现CSRF保护并且确保在资源所有者未意识到且无显式同意时恶意客户端不能获得授权。</p>
<h1 id="10-13-_点击劫持">10.13. 点击劫持</h1>
<p>在点击劫持攻击中，攻击者注册一个合法客户端然后构造一个恶意站点，在一个透明的覆盖在一组虚假按钮上面的嵌入框架中加载授权服务器的授权端点Web页面，这些按钮被精心构造恰好放置在授权页面上的重要按钮下方。当最终用户点击了一个误导的可见的按钮时，最终用户实际上点击了授权页面上一个不可见的按钮（例如“授权”按钮）。 这允许攻击者欺骗资源所有者许可它的客户端最终用户不知晓的访问权限。</p>
<p>为了防止这种形式的攻击，在请求最终用户授权时本机应用程序应该使用外部浏览器而非应用程序中嵌入的浏览器。 对于大多数较新的浏览器，避免嵌入框架可以由授权服务器使用（非标准的）“x-frame-options”标头实施。 该标头可以有两个值，“deny”和“sameorigin”，它将阻止任何框架，或按不同来源的站点分别构造框架。 对于较旧的浏览器，JavaScript框架破坏技术可以使用，但可能不会在所有的浏览器中生效。</p>
<h1 id="10-14-_代码注入和输入验证">10.14. 代码注入和输入验证</h1>
<p>代码注入攻击当程序使用的输入或其他外部变量未清洗而导致对程序逻辑的修改时发生。 这可能允许攻击者对应用程序的设备或它的数据的访问权限，导致服务拒绝或引入许多的恶意副作用。</p>
<p>授权服务器和客户端必须清洗（并在可能的情况下验证）收到的任何值--特别是，“state”和“redirect_uri”参数的值。</p>
<h1 id="10-15-_自由重定向器">10.15. 自由重定向器</h1>
<p>授权服务器、授权端点和客户端重定向端点可能被不当配置，被作为自由重定向器。自由重定向器是一个使用参数自动地向参数值指定而无任何验证的地址重定向用户代理的端点。</p>
<p>自由重定向器可被用于钓鱼攻击，或者被攻击者通过使用熟悉的受信任的目标地址的URI授权部分使最终用户访问恶意站点。此外，如果授权服务器允许客户端只注册部分的重定向URI，攻击者可以使用客户端操作的自由重定向器构造重定向URI，这将跳过授权服务器验证但是发送授权码或访问令牌给攻击者控制下的端点。</p>
<h1 id="10-16-_在隐式流程中滥用访问令牌假冒资源所有者">10.16. 在隐式流程中滥用访问令牌假冒资源所有者</h1>
<p>对于使用隐式流程的公共客户端，本规范没有为客户端提供任何方法来决定访问令牌颁发给的是什么样的客户端。</p>
<p>资源所有者可能通过给攻击者的恶意客户端许可访问令牌自愿委托资源的访问权限。这可能是由于钓鱼或一些其他借口。攻击者也可能通过其他机制窃取令牌。 攻击者然后可能会尝试通过向合法公开客户端提供该访问令牌假冒资源拥有者。</p>
<p>在隐式流程（response_type=token）中，攻击者可以轻易转换来自授权服务器的响应中的令牌，用事先颁发给攻击者的令牌替换真实的访问令牌。</p>
<p>依赖于在返回通道中传递访问令牌识别客户端用户的与本机应用程序通信的服务器可能由攻击者创建能够注入随意的窃取的访问令牌的危险的程序被类似地危及。</p>
<p>任何做出只有资源所有者能够提交给它有效的为资源的访问令牌的假设的公共客户端都是易受这种类型的攻击的。</p>
<p>这种类型的攻击可能在合法的客户端上泄露有关资源所有者的信息给攻击者（恶意客户端）。这也将允许攻击者在合法客户端上用和资源所有者相同的权限执行操作，该资源所有者最初许可了访问令牌或授权码。</p>
<p>客户端对资源拥有者进行身份验证超出了本规范的范围。任何使用授权过程作为客户端对受委托的最终用户进行身份验证的形式的规范（例如，第三方登录服务）不能在没有其他的客户端能够判断访问令牌是否颁发是颁发给它使用的安全机制的情况下使用隐式流程（例如，限制访问令牌的受众）。</p>
<h1 id="11-_IANA考量">11. IANA考量</h1>
<ul>
<li>11.1. <a href="11.1.md">OAuth访问令牌类型注册表</a></li>
<li>11.1.1. <a href="11.1.1.md">注册模板</a></li>
<li>11.2. <a href="11.2.md">OAuth参数注册表</a></li>
<li>11.2.1. <a href="11.2.1md">注册模板</a></li>
<li>11.2.2. <a href="11.2.2.md">初始注册表内容</a></li>
<li>11.3. <a href="11.3.md">OAuth授权端点响应类型注册表</a></li>
<li>11.3.1. <a href="11.3.1.md">注册模板</a></li>
<li>11.3.2. <a href="11.3.2.md">初始注册表内容</a></li>
<li>11.4. <a href="11.4.md">OAuth扩展错误注册表</a></li>
<li>11.4.1. <a href="11.4.1.md">注册模板</a><h1 id="11-1-_OAuth访问令牌类型注册表">11.1. OAuth访问令牌类型注册表</h1>
本规范建立OAuth访问令牌类型注册表。</li>
</ul>
<p>在oauth-ext-review@ietf.org邮件列表上的两周的审查期后，根据一位或多位指定的专家的建议下，按规范需求（<a href="http://tools.ietf.org/html/rfc5226" title="Guidelines for Writing an IANA Considerations Section in RFCs" target="_blank" rel="external">RFC5226</a>）注册访问令牌类型。然而，为允许发表之前的值的分配，指定的专家（们）一旦他们对这样的规范即将发布感到满意可以同意注册。</p>
<p>注册请求必须使用正确的主题（例如“访问令牌类型example”的请求）发送到oauth-ext-review@ietf.org邮件列表来审查和评论。</p>
<p>在审查期间，指定的专家（们）将同意或拒绝该注册请求，向审查列表和IANA通报该决定。拒绝应该包含解释，并且可能的话，包含如何使请求成功的建议。</p>
<p>IANA必须只接受来自指定的专家（们）的注册表更新并且应该引导所有注册请求至审查邮件列表。</p>
<ul>
<li>11.1.1. <a href="11.1.1.md">注册模板</a></li>
</ul>
<h1 id="11-1-1-_注册模板">11.1.1. 注册模板</h1>
<ul>
<li><p>Type name：</p>
<p>请求的名称（例如，“example”）。</p>
</li>
<li><p>Additional Token Endpoint Response Parameters:</p>
<p>随“access_token”参数一起返回的其他响应参数。 新的参数都必须如<a href="11.2.md">11.2</a>节所述在OAuth参数注册表中分别注册。</p>
</li>
<li><p>HTTP Authentication Scheme(s):</p>
<p>HTTP身份验证方案名称，如果有的话，用于使用这种类型的访问令牌对受保护资源进行身份验证。</p>
</li>
<li><p>Change controller：</p>
<p>对于标准化过程的RFC，指定为“IETF”。 对于其他，给出负责的部分的名称。 其他细节（例如，邮政地址，电子邮件地址，主页URI）也可以包括在内。</p>
</li>
<li><p>Specification document(s):</p>
<p>指定参数的文档的引用文献，最好包括可以用于检索文档副本的URI。 相关章节的指示也可以包含但不是必需的。</p>
<h1 id="11-2-_OAuth参数注册表">11.2. OAuth参数注册表</h1>
<p>本规范建立OAuth参数注册表。</p>
</li>
</ul>
<p>在oauth-ext-review@ietf.org邮件列表上的两周的审查期后，根据一位或多位指定的专家的建议下，按规范需求（<a href="http://tools.ietf.org/html/rfc5226" title="Guidelines for Writing an IANA Considerations Section in RFCs" target="_blank" rel="external">RFC5226</a>）注册列入授权端点请求、授权端点响应、令牌端点请求或令牌端点响应的其他参数。然而，为允许发表之前的值的分配，指定的专家（们）一旦他们对这样的规范即将发布感到满意可以同意注册。</p>
<p>注册请求必须使用正确的主题（例如，参数“example”的请求）发送到oauth-ext-review@ietf.org邮件列表来审查和评论。</p>
<p>在审查期间，指定的专家（们）将同意或拒绝该注册请求，向审查列表和IANA通报该决定。拒绝应该包含解释，并且可能的话，包含如何使请求成功的建议。</p>
<p>IANA必须只接受来自指定的专家（们）的注册表更新并且应该引导所有注册请求至审查邮件列表。</p>
<ul>
<li>11.2.1. <a href="11.2.1md">注册模板</a></li>
<li>11.2.2. <a href="11.2.2.md">初始注册表内容</a></li>
</ul>
<h1 id="11-2-1-_注册模板">11.2.1. 注册模板</h1>
<ul>
<li><p>Parameter name:</p>
<p>请求的名称（例如，“example”）。</p>
</li>
<li><p>Parameter usage location:</p>
<p>参数可以使用的位置。 可能的位置为授权请求、授权响应、令牌请求或令牌响应。</p>
</li>
<li><p>Change controller:</p>
<p>对于标准化过程的RFC，指定为“IETF”。对于其他，给出负责的部分的名称。其他细节（例如，邮政地址，电子邮件地址，主页URI）也可以包括在内。</p>
</li>
<li><p>Specification document(s):</p>
<p>指定参数的文档的引用文献，最好包括可以用于检索文档副本的URI。相关章节的指示也可以包含但不是必需的。</p>
<h1 id="11-2-2-_最初的注册表内容">11.2.2. 最初的注册表内容</h1>
<p>OAuth参数注册表中的初始内容：</p>
</li>
<li>Parameter name: client_id</li>
<li>Parameter usage location: authorization request, token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: client_secret</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: response_type</li>
<li>Parameter usage location: authorization request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: redirect_uri</li>
<li>Parameter usage location: authorization request, token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: scope</li>
<li>Parameter usage location: authorization request, authorization response, token request, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: state</li>
<li>Parameter usage location: authorization request, authorization response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: code</li>
<li>Parameter usage location: authorization response, token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: error_description</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: error_uri</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: grant_type</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: access_token</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: token_type</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: expires_in</li>
<li>Parameter usage location: authorization response, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: username</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: password</li>
<li>Parameter usage location: token request</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Parameter name: refresh_token</li>
<li>Parameter usage location: token request, token response</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<h1 id="11-3-_OAuth授权端点响应类型注册表">11.3. OAuth授权端点响应类型注册表</h1>
<p>本规范建立OAuth授权端点响应类型注册表。</p>
<p>在oauth-ext-review@ietf.org邮件列表上的两周的审查期后，根据一位或多位指定的专家的建议下，按规范需求（<a href="http://tools.ietf.org/html/rfc5226" title="Guidelines for Writing an IANA Considerations Section in RFCs" target="_blank" rel="external">RFC5226</a>）注册授权端点使用的其他响应类型。然而，为允许发表之前的值的分配，指定的专家（们）一旦他们对这样的规范即将发布感到满意可以同意注册。</p>
<p>注册请求必须使用正确的主题（例如“响应类型example”的请求）发送到oauth-ext-review@ietf.org邮件列表来审查和评论。</p>
<p>在审查期间，指定的专家（们）将同意或拒绝该注册请求，向审查列表和IANA通报该决定。</p>
<p>IANA必须只接受来自指定的专家（们）的注册表更新并且应该引导所有注册请求至审查邮件列表。</p>
<ul>
<li>11.3.1. <a href="11.3.1.md">注册模板</a></li>
<li>11.3.2. <a href="11.3.2.md">初始注册表内容</a></li>
</ul>
<h1 id="11-3-1-_注册模板">11.3.1. 注册模板</h1>
<ul>
<li><p>Response type name:</p>
<p>请求的名称（例如，“example”）。</p>
</li>
<li><p>Change controller:</p>
<p>对于标准化过程的RFC，指定为“IETF”。对于其他，给出负责的部分的名称。其他细节（例如，邮政地址，电子邮件地址，主页URI）也可以包括在内。</p>
</li>
<li><p>Specification document(s):</p>
<p>指定参数的文档的引用文献，最好包括可以用于检索文档副本的URI。相关章节的指示也可以包含但不是必需的</p>
<h1 id="11-3-2-_最初的注册表内容">11.3.2. 最初的注册表内容</h1>
<p>OAuth授权端点响应类型注册表的初始内容：</p>
</li>
<li>Response type name: code</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<ul>
<li>Response type name: token</li>
<li>Change controller: IETF</li>
<li>Specification document(s): <a href="../index.md" title="RFC 6749">RFC 6749</a></li>
</ul>
<h1 id="11-4-_OAuth扩展错误注册表">11.4. OAuth扩展错误注册表</h1>
<p>本规范建立OAuth扩展错误注册表。</p>
<p>在oauth-ext-review@ietf.org邮件列表上的两周的审查期后，根据一位或多位指定的专家的建议下，按规范需求（<a href="http://tools.ietf.org/html/rfc5226" title="Guidelines for Writing an IANA Considerations Section in RFCs" target="_blank" rel="external">RFC5226</a>）注册与其他协议扩展（例如，扩展的许可类型、访问令牌类型或者扩展参数）一起使用的其他错误代码。然而，为允许发表之前的值的分配，指定的专家（们）一旦他们对这样的规范即将发布感到满意可以同意注册。</p>
<p>注册请求必须使用正确的主题（例如“错误代码example”的请求）发送到oauth-ext-review@ietf.org邮件列表来审查和评论。</p>
<p>在审查期间，指定的专家（们）将同意或拒绝该注册请求，向审查列表和IANA通报该决定。拒绝应该包含解释，并且可能的话，包含如何使请求成功的建议。</p>
<p>IANA必须只接受来自指定的专家（们）的注册表更新并且应该引导所有注册请求至审查邮件列表。</p>
<ul>
<li>11.4.1. <a href="11.4.1.md">注册模板</a></li>
</ul>
<h1 id="11-4-1-_注册模板">11.4.1. 注册模板</h1>
<ul>
<li><p>Error name:</p>
<p>请求的名称（例如，“example”）。错误名称的值<br>不能包含集合%x20-21 /%x23-5B /%x5D-7E以外的字符。</p>
</li>
<li><p>Error usage location:</p>
<p>错误使用的位置。可能的位置是授权代码许可错误响应（<a href="../Section04/4.1.2.1.md">4.1.2.1</a>节），隐式许可错误响应（<a href="../Section04/4.2.2.1.md">4.2.2.1</a>节），令牌错误响应（<a href="../Section05/5.2.md">5.2</a>节），或资源访问错误的响应（<a href="../Section07/7.2.md">7.2</a>节）。</p>
</li>
<li><p>Related protocol extension:</p>
<p>与错语代码一起使用的扩展许可类型、访问令牌类型或扩展参数的名称。</p>
</li>
<li><p>Change controller:</p>
<p>对于标准化过程的RFC，指定为“IETF”。对于其他，给出负责的部分的名称。其他细节（例如，邮政地址，电子邮件地址，主页URI）也可以包括在内。</p>
</li>
<li><p>Specification document(s):</p>
<p>指定参数的文档的引用文献，最好包括可以用于检索文档副本的URI。相关章节的指示也可以包含但不是必需的。</p>
</li>
</ul>
<h1 id="12-_参考文献">12. 参考文献</h1>
<ul>
<li>12.1. <a href="12.1.md">规范性文献</a></li>
<li>12.2. <a href="12.2.md">参考性文献</a><h1 id="12-1-_规范性参考文件">12.1. 规范性参考文件</h1>
</li>
<li><a href="http://tools.ietf.org/html/rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels" target="_blank" rel="external">RFC2119</a><br>Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement Levels&quot;, BCP 14,RFC 2119, March 1997.</li>
<li><a href="http://tools.ietf.org/html/rfc2246" title="TLS协议1.0版" target="_blank" rel="external">RFC2246</a><br>Dierks, T. and C. Allen, &quot;The TLS Protocol Version 1.0&quot;, RFC 2246, January 1999.</li>
<li><a href="http://tools.ietf.org/html/rfc2616" title="HTTP/1/1" target="_blank" rel="external">RFC2616</a><br>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;, RFC 2616, June 1999.</li>
<li><a href="http://tools.ietf.org/html/rfc2617" title="HTTP Authentication: Basic and Digest Access Authentication" target="_blank" rel="external">RFC2617</a><br>Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;, RFC 2617, June 1999.</li>
<li><a href="http://tools.ietf.org/html/rfc2818" title="HTTP Over TLS" target="_blank" rel="external">RFC2818</a><br>Rescorla, E., &quot;HTTP Over TLS&quot;, RFC 2818, May 2000.</li>
<li>[RFC3629]<br>Yergeau, F., &quot;UTF-8, a transformation format of ISO 10646&quot;, STD 63, RFC 3629, November 2003.</li>
<li><a href="http://tools.ietf.org/html/rfc3986" title="Uniform Resource Identifier (URI): Generic Syntax" target="_blank" rel="external">RFC3986</a><br>Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform Resource Identifier (URI): Generic Syntax&quot;, STD 66, RFC 3986, January 2005.</li>
<li><a href="http://tools.ietf.org/html/rfc4627" title="JSON" target="_blank" rel="external">RFC4627</a><br>Crockford, D., &quot;The application/json Media Type for JavaScript Object Notation (JSON)&quot;, RFC 4627, July 2006.</li>
<li><a href="http://tools.ietf.org/html/rfc4949" title="Internet Security Glossary, Version 2" target="_blank" rel="external">RFC4949</a><br>Shirey, R., &quot;Internet Security Glossary, Version 2&quot;, RFC 4949, August 2007.</li>
<li><a href="http://tools.ietf.org/html/rfc5226" title="Guidelines for Writing an IANA Considerations Section in RFCs" target="_blank" rel="external">RFC5226</a><br>Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an IANA Considerations Section in RFCs&quot;, BCP 26,RFC 5226, May 2008.</li>
<li><a href="http://tools.ietf.org/html/rfc5234" title="Augmented BNF for Syntax Specifications: ABNF" target="_blank" rel="external">RFC5234</a><br>Crocker, D. and P. Overell, &quot;Augmented BNF for Syntax Specifications: ABNF&quot;, STD 68, RFC 5234, January 2008.</li>
<li><a href="http://tools.ietf.org/html/rfc5246" title="传输层安全（TLS）协议1.2版" target="_blank" rel="external">RFC5246</a><br>Dierks, T. and E. Rescorla, &quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;, RFC 5246, August 2008.</li>
<li><a href="http://tools.ietf.org/html/rfc6125" title="Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)" target="_blank" rel="external">RFC6125</a><br>Saint-Andre, P. and J. Hodges, &quot;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)&quot;, RFC 6125, March 2011.</li>
<li>[USASCII]<br>American National Standards Institute, &quot;Coded Character Set -- 7-bit American Standard Code for Information Interchange&quot;, ANSI X3.4, 1986.</li>
<li>[W3C.REC-html401-19991224]<br>Raggett, D., Le Hors, A., and I. Jacobs, &quot;HTML 4.01 Specification&quot;, World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, <a href="http://www.w3.org/TR/1999/REC-html401-19991224" target="_blank" rel="external">http://www.w3.org/TR/1999/REC-html401-19991224</a>.</li>
<li>[W3C.REC-xml-20081126]<br>Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, &quot;Extensible Markup Language (XML) 1.0 (Fifth Edition)&quot;, World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, <a href="http://www.w3.org/TR/2008/REC-xml-20081126" target="_blank" rel="external">http://www.w3.org/TR/2008/REC-xml-20081126</a>.<h1 id="12-2-_参考性引用文献">12.2. 参考性引用文献</h1>
</li>
<li>[OAuth-HTTP-MAC]<br>Hammer-Lahav, E., Ed., &quot;HTTP Authentication: MAC Access Authentication&quot;, Work in Progress, February 2012.</li>
<li>[OAuth-SAML2]<br>Campbell, B. and C. Mortimore, &quot;SAML 2.0 Bearer Assertion Profiles for OAuth 2.0&quot;, Work in Progress, September 2012.</li>
<li>[OAuth-THREATMODEL]<br>Lodderstedt, T., Ed., McGloin, M., and P. Hunt, &quot;OAuth 2.0 Threat Model and Security Considerations&quot;, Work in Progress, October 2012.</li>
<li>[OAuth-WRAP]<br>Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, &quot;OAuth Web Resource Authorization Profiles&quot;, Work in Progress, January 2010.</li>
<li><a href="http://tools.ietf.org/html/rfc5849" title="OAuth 1.0协议" target="_blank" rel="external">RFC5849</a><br>Hammer-Lahav, E., &quot;The OAuth 1.0 Protocol&quot;, RFC 5849, April 2010.</li>
<li><a href="http://tools.ietf.org/html/rfc6750" title="The OAuth 2.0 Authorization Framework: Bearer Token Usage" target="_blank" rel="external">RFC6750</a><br>Jones, M. and D. Hardt, &quot;The OAuth 2.0 Authorization Framework: Bearer Token Usage&quot;, RFC 6750, October 2012.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自 <a href="https://github.com/jeansfish/RFC6749.zh-cn" target="_blank" rel="external">RFC 6749-OAuth 2.0授权框架简体中文翻译</a><br>]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Spring 5 新功能：函数式 Web 框架]]></title>
    <link href="http://colobu.com/2017/04/26/new-in-spring-5-functional-web-framework/"/>
    <id>http://colobu.com/2017/04/26/new-in-spring-5-functional-web-framework/</id>
    <published>2017-04-26T09:30:03.000Z</published>
    <updated>2017-04-26T09:51:33.000Z</updated>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework" target="_blank" rel="external">New in Spring 5: Functional Web Framework</a> by<br>中文翻译: <a href="https://www.oschina.net/translate/new-in-spring-5-functional-web-framework" target="_blank" rel="external">Spring 5 新功能：函数式 Web 框架</a> by 开源中国</p>
<p>就像在昨天Juergen发布的<a href="https://spring.io/blog/2016/09/21/spring-framework-5-0-m2-released" target="_blank" rel="external">博客</a>的一样，Spring 5.0框架第二个里程碑版本中介绍了一个新的函数式web框架。在这篇文章中，我将更详细的介绍这个框架。</p>
<p>紧记该函数式web框架是在Spring5.0第一个里程碑版本基础上构建的。并且我们依旧提供基于注解的请求处理（例如@Controller,@RequestMapping)，关于基于注解的请求处理部分的相关信息请查阅关于Spring5.0<a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1" target="_blank" rel="external">第一个里程碑版本</a>的博客。</p>
<a id="more"></a>
<h3 id="示例">示例</h3>
<p>我们选用示例程序作为开始。下面是一个响应资源库用于暴露Person对象。这个响应资源库与传统的无响应资源库类似，除了Flux<person>对应传统的 List<person>，Mono<person>对应传统的 Person对象。Mono<void>作为完成标识：用于指示保存工作完成.更多Reactor 类型信息请查阅 <a href="https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code" target="_blank" rel="external">Dave发布的博客</a></void></person></person></person></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> </span>{</div><div class="line">  Mono&lt;Person&gt; getPerson(<span class="keyword">int</span> id);</div><div class="line">  Flux&lt;Person&gt; allPeople();</div><div class="line">  Mono&lt;Void&gt; savePerson(Mono&lt;Person&gt; person);}</div></pre></td></tr></table></figure>

<p>这里我们介绍如何使用新的函数式web框架暴露资源库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route = route(GET(<span class="string">"/person/{id}"</span>),</div><div class="line">  request -&gt; {</div><div class="line">    Mono&lt;Person&gt; person = Mono.justOrEmpty(request.pathVariable(<span class="string">"id"</span>))</div><div class="line">      .map(Integer::valueOf)</div><div class="line">      .then(repository::getPerson);</div><div class="line">    <span class="keyword">return</span> Response.ok().body(fromPublisher(person, Person.class));</div><div class="line">  })</div><div class="line">  .and(route(GET(<span class="string">"/person"</span>),</div><div class="line">    request -&gt; {</div><div class="line">      Flux&lt;Person&gt; people = repository.allPeople();</div><div class="line">      <span class="keyword">return</span> Response.ok().body(fromPublisher(people, Person.class));</div><div class="line">    }))</div><div class="line">  .and(route(POST(<span class="string">"/person"</span>),</div><div class="line">    request -&gt; {</div><div class="line">      Mono&lt;Person&gt; person = request.body(toMono(Person.class));</div><div class="line">      <span class="keyword">return</span> Response.ok().build(repository.savePerson(person));</div><div class="line">    }));</div></pre></td></tr></table></figure>

<p>这里我们介绍如何运行它，下面是Reactor Netty的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);</div><div class="line">ReactorHttpHandlerAdapter adapter =</div><div class="line">  <span class="keyword">new</span> ReactorHttpHandlerAdapter(httpHandler);</div><div class="line">HttpServer server = HttpServer.create(<span class="string">"localhost"</span>, <span class="number">8080</span>);</div><div class="line">server.startAndAwait(adapter);</div></pre></td></tr></table></figure>

<p>最后要做的是，进行一次尝试请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl <span class="string">'http://localhost:8080/person/1'</span></div><div class="line">{<span class="string">"name"</span>:<span class="string">"John Doe"</span>,<span class="string">"age"</span>:<span class="number">42</span>}</div></pre></td></tr></table></figure>

<p>上面的介绍覆盖了很多内容，下面让我们深入挖掘下！</p>
<h3 id="核心组件">核心组件</h3>
<p>我将通过依次介绍<code>HandlerFunction</code>,<code>RouterFunction</code>以及<code>FilterFunction</code> 等核心组件来介绍整个框架。这三个接口以及本文中其他类型都可以在<a href="http://docs.spring.io/spring/docs/5.0.0.M2/javadoc-api/org/springframework/web/reactive/function/package-summary.html" target="_blank" rel="external">org.springframework.web.reactive.function</a>包中找到。</p>
<h4 id="HandlerFunction">HandlerFunction</h4>
<p>新框架的起点是HandlerFunction<t>，其实质是Function<request, response<t="">&gt;，其中的Request 和 Response都是新定义的不可变接口，提供了基础的对JDK8优化的HTTP消息描述DSL。有一个便捷的构造Response实例的构造器，与ResponseEntity中的十分相似。注解方式中与HandlerFunction相对应的是@RequestMapping所注解的方法。</request,></t></p>
<p>如下是“Hello World”的处理方法，它返回了状态为200，body为字符串的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HandlerFunction&lt;String&gt; helloWorld =</div><div class="line">  request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>));</div></pre></td></tr></table></figure>

<p>如上，构建于Reactor之上的处理方法是完全的响应式的（reactive），它们可以接受Flux、Mono或者其他相应流（<a href="http://www.reactive-streams.org/" target="_blank" rel="external">Reactive Streams</a>）的发布者作为返回类型的参数。</p>
<p>需要注意的是处理方法本身是没有副作用的，因为它将response作为返回值，而不是作为参数（对比Servlet.service(ServletRequest,ServletResponse)，其实质是BiConsumer<servletrequest,servletresponse>）。无副作用的方法有很多好处：更有利于<a href="http://programmers.stackexchange.com/questions/15269/why-are-side-effects-considered-evil-in-functional-programming" target="_blank" rel="external">测试、构建和优化</a>。</servletrequest,servletresponse></p>
<h4 id="RouterFunction">RouterFunction</h4>
<p>入站请求是由RouterFunction<t>，(即Function<request, optional<handlerfunction<t="">&gt;)路由到HandlerFunction中去的。当满足条件匹配时，路由方法会执行处理方法，否则会返回一个空结果。路由方法与@RequestMapping注解的作用相似。但是，还有一个显著的区别：用注解时路由会被限制到注解的value所能表达的范围，处理这些方法的覆盖是困难的；当用路由方法的时候，代码就在那里，可以轻松的覆盖或替换。</request,></t></p>
<p>如下是一个路由方法的例子，包含了一个行内的处理方法。这里看起来有一点冗余，不必担心，因为后面我们将会将它变得精简。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; helloWorldRoute = </div><div class="line">  request -&gt; {</div><div class="line">    <span class="keyword">if</span> (request.path().equals(<span class="string">"/hello-world"</span>)) {</div><div class="line">      <span class="keyword">return</span> Optional.of(r -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">      <span class="keyword">return</span> Optional.empty();</div><div class="line">    }</div><div class="line">  };</div></pre></td></tr></table></figure>

<p>一般不用写完整的路由方法，而是静态引入RouterFunctions.route()，这样就可以用请求判断式（RequestPredicate） (即 Predicate<request>)和处理方法（HandlerFunction）创建路由方法了。如果判断式判断成功则返回处理方法，否则返回空结果。如下是用route方法方式重写上面的例子：</request></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; helloWorldRoute =</div><div class="line">  RouterFunctions.route(request -&gt; request.path().equals(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div></pre></td></tr></table></figure>

<p>静态引入RequestPredicates.*后就可以使用那些常用的判断式了，如匹配路径、HTTP方法、content-type等。这样上面的例子将会变得更精简：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; helloWorldRoute =</div><div class="line">  RouterFunctions.route(RequestPredicates.path(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div></pre></td></tr></table></figure>

<h4 id="组合函数">组合函数</h4>
<p>两个路由方法可以被组合成一个新的路由方法，可以路由任意处理方法：如果第一个路由不匹配则执行第二个。可以通过调用RouterFunction.and()方法实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(path(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)))</div><div class="line">  .and(route(path(<span class="string">"/the-answer"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"42"</span>))));</div></pre></td></tr></table></figure>

<p>上面的例子如果路径匹配/hello-world会返回“Hello World”，如果匹配/the-answer则返回“42”。如果都不匹配则返回一个空的Optional对象。注意，组合的路由是按顺序执行的，所以应该将更通用的方法放到更明确的方法的前面。</p>
<p>请求判断式也是可以组合的，通过调研and或者or方法。正如预期的一样：and表示给定的两个判断式同时满足则组合判断式满足，or则表示任意判断式满足。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(method(HttpMethod.GET).and(path(<span class="string">"/hello-world"</span>)), </div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)))</div><div class="line">  .and(route(method(HttpMethod.GET).and(path(<span class="string">"/the-answer"</span>)), </div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"42"</span>))));</div></pre></td></tr></table></figure>

<p>实际上，RequestPredicates中的大部分判断式都是组合的！比如RequestPredicates.GET(String)是RequestPredicates.method(HttpMethod)和RequestPredicates.path(String)的组合。所以上面的例子可以重写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)))</div><div class="line">  .and(route(GET(<span class="string">"/the-answer"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="number">42</span>))));</div></pre></td></tr></table></figure>

<h4 id="方法引用">方法引用</h4>
<p>此外，目前为止我们的处理方法都是行内的lambda表达式。尽管这样很适合于实例和简短的例子，但是当结合请求路由和请求处理两个关注点时，可能就有变“混乱”的趋势了。所以我们将尝试将他们简化。首先，创建一个包含处理逻辑的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class DemoHandler {</div><div class="line">  <span class="keyword">public</span> Response&lt;String&gt; <span class="title">helloWorld</span>(Request request) {</div><div class="line">    <span class="keyword">return</span> Response.ok().body(fromObject(<span class="string">"Hello World"</span>));</div><div class="line">  }</div><div class="line">  <span class="keyword">public</span> Response&lt;String&gt; <span class="title">theAnswer</span>(Request request) {</div><div class="line">    <span class="keyword">return</span> Response.ok().body(fromObject(<span class="string">"42"</span>));</div><div class="line">  }}</div></pre></td></tr></table></figure>

<p>注意，这两个方法的签名都是和处理方法兼容的。这样就可以方法引用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DemoHandler handler = <span class="keyword">new</span> DemoHandler(); <span class="comment">// or obtain via DI</span></div><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>), handler::helloWorld)</div><div class="line">  .and(route(GET(<span class="string">"/the-answer"</span>), handler::theAnswer));</div></pre></td></tr></table></figure>

<h4 id="FilterFunction">FilterFunction</h4>
<p>由路由器函数进行映射的路由可以通过调用 RouterFunction.filter(FilterFunction<t, r="">) 来进行过滤, 这里的 FilterFunction<t,r> 其实就是一个 BiFunction<request, handlerfunction<t="">, Response<r>&gt;。函数的处理器（handler）参数代表的就是整个链条中的下一项: 这是一个典型的 HandlerFunction, 但如果附加了多个过滤器的话，它也能够是另外的一个 FilterFunction。让我们向路由添加一个日志过滤器：</r></request,></t,r></t,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;?&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>), handler::helloWorld)</div><div class="line">  .and(route(GET(<span class="string">"/the-answer"</span>), handler::theAnswer))</div><div class="line">  .filter((request, next) -&gt; {</div><div class="line">    System.out.println(<span class="string">"Before handler invocation: "</span> + request.path());</div><div class="line">    Response&lt;?&gt; response = next.handle(request);</div><div class="line">    Object body = response.body();</div><div class="line">    System.out.println(<span class="string">"After handler invocation: "</span> + body);</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>注意这里对下一个处理器的调用时可选的。这个在安全或者缓存的场景中是很有用的 (例如只在用户拥有足够的权限时才调用 next)。</p>
<p>因为 route 是一个没有被绑定的路由器函数，我们就得知道接下来的处理会返回什么类型的响应消息。这就是为什么我们在过滤器中要以一个 Response&lt;?&gt; 结束, 那样它就会可能有一个 String 类型的响应消息体。我们可以通过使用 RouterFunction.andSame() 而不是 and() 来完成这件事情。这个组合方法要求路由器函数参数是同一个类型。例如，我们可以让所有的响应消息变成小写的文本形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RouterFunction&lt;String&gt; route =</div><div class="line">  route(GET(<span class="string">"/hello-world"</span>), handler::helloWorld)</div><div class="line">  .andSame(route(GET(<span class="string">"/the-answer"</span>), handler::theAnswer))</div><div class="line">  .filter((request, next) -&gt; {</div><div class="line">    Response&lt;String&gt; response = next.handle(request);</div><div class="line">    String newBody = response.body().toUpperCase();</div><div class="line">    <span class="keyword">return</span> Response.from(response).body(fromObject(newBody));</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>使用注解的话，类似的功能可以使用 @ControllerAdvice 或者是一个 ServletFilter 来实现。</p>
<h4 id="运行服务器">运行服务器</h4>
<p>所有这些都很不错，不过仍然有一块欠缺：我们如何实际地将这些函数在一个 HTTP 服务器中跑起来呢? 答案毋庸置疑，那就是通过调用另外的一个函数。 你可以通过使用 RouterFunctions.toHttpHandler() 来将一个路由器函数转换成 HttpHandler。HttpHandler 是 Spring 5.0 M1 中引入的一个响应式抽象: 它能让你运行许多的响应式运行时: Reactor Netty, RxNetty, Servlet 3.1+, 以及 Undertow。在本示例中，我们已经展示了在 Reactor Netty 中运行一个路由会是什么样子的。对于 Tomcat 来说则是像下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);</div><div class="line">HttpServlet servlet = <span class="keyword">new</span> ServletHttpHandlerAdapter(httpHandler);</div><div class="line">Tomcat server = <span class="keyword">new</span> Tomcat();</div><div class="line">Context rootContext = server.addContext(<span class="string">""</span>,</div><div class="line">  System.getProperty(<span class="string">"java.io.tmpdir"</span>));</div><div class="line">Tomcat.addServlet(rootContext, <span class="string">"servlet"</span>, servlet);  </div><div class="line">rootContext.addServletMapping(<span class="string">"/"</span>, <span class="string">"servlet"</span>);</div><div class="line">tomcatServer.start();</div></pre></td></tr></table></figure>

<p>需要注意的意见事情就是上面的东西并不依赖于一个 Spring 应用程序上下文。就跟 JdbcTemplate 以及其它 Spring 的工具类那样, 要不要使用应用程序上下文是可以选的: 你可以将你的处理器和路由器函数在一个上下文中进行绑定，但并不是必须的。<br>还要注意的就是你也可以将一个路由器函数转换到一个 HandlerMapping中去，那样就它可以在一个 DispatcherHandler (可能是跟响应式的 @Controllers 并行)中运行了。</p>
<h3 id="总结">总结</h3>
<p>至此便结束了对 Spring 新函数式 web 框架的介绍。让我简单小结一下：</p>
<ul>
<li>handler function 处理request, 返回response，</li>
<li>router function 把请求路由到handler function，并可与其他router function组合，</li>
<li>router function可以被 filter function过滤处理，</li>
<li>router function 可以运行在一个响应式web运行时框架中。</li>
</ul>
<p>为了给你一个更全面的理解，我创建了一个简单的function web framework例子，你可以在github上找到<a href="https://github.com/poutsma/web-function-sample" target="_blank" rel="external">它</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文原文：<a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework" target="_blank" rel="external">New in Spring 5: Functional Web Framework</a> by<br>中文翻译: <a href="https://www.oschina.net/translate/new-in-spring-5-functional-web-framework" target="_blank" rel="external">Spring 5 新功能：函数式 Web 框架</a> by 开源中国</p>
<p>就像在昨天Juergen发布的<a href="https://spring.io/blog/2016/09/21/spring-framework-5-0-m2-released" target="_blank" rel="external">博客</a>的一样，Spring 5.0框架第二个里程碑版本中介绍了一个新的函数式web框架。在这篇文章中，我将更详细的介绍这个框架。</p>
<p>紧记该函数式web框架是在Spring5.0第一个里程碑版本基础上构建的。并且我们依旧提供基于注解的请求处理（例如@Controller,@RequestMapping)，关于基于注解的请求处理部分的相关信息请查阅关于Spring5.0<a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1" target="_blank" rel="external">第一个里程碑版本</a>的博客。</p>
]]>
    
    </summary>
    
      <category term="Spring" scheme="http://colobu.com/tags/Spring/"/>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tc: 模拟网络异常的工具]]></title>
    <link href="http://colobu.com/2017/04/21/tc-introduction/"/>
    <id>http://colobu.com/2017/04/21/tc-introduction/</id>
    <published>2017-04-21T06:34:24.000Z</published>
    <updated>2017-04-21T07:59:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/2017/04/21/tc-introduction/network.png" alt=""></p>
<p>Linux Traffic Control (tc)的扩展 Network Emulation (netem)可以很方便的模拟网络不好的情况，一般新的linux内核中(&gt;= 2.6)已经内置了这个工具，可以方便的进行测试。</p>
<p>本文罗列了了 <code>tc</code>的常用的模拟命令， 以备将来使用的时候查询。</p>
<p>主要参考了Linux基金会的官方介绍: <a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="external">netem</a><br><a id="more"></a></p>
<h3 id="监控网卡。">监控网卡。</h3>
<p>首先要查看你的网卡信息，如: <code>eth0</code>，然后将这个网卡加入监控列表 <code>sudo tc qdisc add dev eth0 root netem</code>。 </p>
<p>如果不想再监控，可以移除这个网卡 <code>sudo tc qdisc del dev eth0 root netem</code></p>
<p>如果想查看监控列表， 可以使用 <code>tc -s qdisc</code>。</p>
<p><code>qdisc</code>是<code>queueing discipline</code>的缩写。</p>
<h3 id="模拟网络延迟">模拟网络延迟</h3>
<h4 id="固定延迟">固定延迟</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root netem delay <span class="number">100</span>ms</div></pre></td></tr></table></figure>

<p>每个包都固定延迟 <code>100</code>毫秒， 设置好后你可以使用<code>ping</code>命令测试。</p>
<h4 id="固定延迟+小随机值">固定延迟+小随机值</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">10</span>ms</div></pre></td></tr></table></figure>

<p>延迟时间变成了 <code>100ms ± 10ms</code>。</p>
<h4 id="固定延迟+小随机值+相关系数">固定延迟+小随机值+相关系数</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">10</span>ms <span class="number">25</span>%</div></pre></td></tr></table></figure>

<blockquote>
<p>This causes the added delay to be 100ms ± 10ms with the next random element depending 25% on the last one. This isn&#39;t true statistical correlation, but an approximation.</p>
</blockquote>
<h4 id="遵循正态分布的延迟">遵循正态分布的延迟</h4>
<p>典型情况下延迟并不是均分分布的，而是遵循类似正态分布的规律。所以你可以使用某种分布模拟延迟。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">20</span>ms distribution normal</div></pre></td></tr></table></figure>

<p>分布为<code>normal</code>、 <code>pareto</code>、 <code>paretonormal</code>等。</p>
<h3 id="模拟丢包">模拟丢包</h3>
<p>随机丢弃一些包， 丢弃比率可以设置。丢失比最小为 <code>232 = 0.0000000232%</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem loss <span class="number">0.1</span>%</div></pre></td></tr></table></figure>

<p>上述命令会随机丢弃千分之一的包。</p>
<p>你还可以增加一个相关参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem loss <span class="number">0.3</span>% <span class="number">25</span>%</div></pre></td></tr></table></figure>

<p>丢弃率为千分之三， 后一个的丢弃的可能性和前一个的可能性的25%相关：</p>
<p>Prob<sub>n</sub> = .25 <em> Prob<sub>n-1</sub> + .75 </em> Random</p>
<h3 id="模拟包重复">模拟包重复</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem duplicate <span class="number">1</span>%</div></pre></td></tr></table></figure>

<p>类似丢包的命令，上面命令产生百分之一的重复包。</p>
<h3 id="模拟错误包">模拟错误包</h3>
<p>模拟随机噪音(错误包)， 这个功能在 2.6.16以及以后的版本中才加入。它会在包中随机位置更改一个bit。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem corrupt <span class="number">0.1</span>%</div></pre></td></tr></table></figure>

<h3 id="模拟包乱序">模拟包乱序</h3>
<p>1） 方式一<br>使用 gap。 第5th包（5、10、15、20）立即发送，其它的包会延迟10毫秒。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem gap <span class="number">5</span> delay <span class="number">10</span>ms</div></pre></td></tr></table></figure>

<p>2） 方式二<br>方式一乱序方式是固定的，可以预测的。方式二引入随机性：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">10</span>ms reorder <span class="number">25</span>% <span class="number">50</span>%</div></pre></td></tr></table></figure>

<p>25%的包会立即发送， 其它的包会延迟10毫秒。相关系数为50%。</p>
<p>新版的netem的包延迟设置也可能导致包乱序，如果包延迟的有一定的随机性的话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay <span class="number">100</span>ms <span class="number">75</span>ms</div></pre></td></tr></table></figure>

<p>因为延迟时间在<code>100ms ± 75ms</code>返回内， 就有可能第二包的延迟比第一个包的延迟小，先发出去。</p>
<h3 id="控制包速(带宽)">控制包速(带宽)</h3>
<p>没有直接命令，需要两条命令配合使用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tc qdisc add dev eth0 root handle 1:0 netem delay 100ms</span></div><div class="line"><span class="comment"># tc qdisc add dev eth0 parent 1:1 handle 10: tbf rate 256kbit buffer 1600 limit 3000</span></div><div class="line"><span class="comment"># tc -s qdisc ls dev eth0</span></div><div class="line">qdisc netem <span class="number">1</span>: limit <span class="number">1000</span> delay <span class="number">100.0</span>ms</div><div class="line"> Sent <span class="number">0</span> bytes <span class="number">0</span> pkts (dropped <span class="number">0</span>, overlimits <span class="number">0</span> )</div><div class="line">qdisc tbf <span class="number">10</span>: rate <span class="number">256</span>Kbit burst <span class="number">1599</span>b lat <span class="number">26.6</span>ms</div><div class="line"> Sent <span class="number">0</span> bytes <span class="number">0</span> pkts (dropped <span class="number">0</span>, overlimits <span class="number">0</span> )</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/2017/04/21/tc-introduction/network.png" alt=""></p>
<p>Linux Traffic Control (tc)的扩展 Network Emulation (netem)可以很方便的模拟网络不好的情况，一般新的linux内核中(&gt;= 2.6)已经内置了这个工具，可以方便的进行测试。</p>
<p>本文罗列了了 <code>tc</code>的常用的模拟命令， 以备将来使用的时候查询。</p>
<p>主要参考了Linux基金会的官方介绍: <a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="external">netem</a><br>]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go HTTP Redirect的知识点总结]]></title>
    <link href="http://colobu.com/2017/04/19/go-http-redirect/"/>
    <id>http://colobu.com/2017/04/19/go-http-redirect/</id>
    <published>2017-04-19T08:28:01.000Z</published>
    <updated>2017-04-20T06:10:21.000Z</updated>
    <content type="html"><![CDATA[<p>HTTP 规范中定义了返回码为 <code>3xx</code> 代表客户端需要做一些额外的工作来完成请求，大部分<code>3xx</code>用来做转发(redirect)。</p>
<p>状态码的详细说明可以参照规范或者 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" target="_blank" rel="external">wikipedia</a>、<a href="https://zh.wikipedia.org/wiki/HTTP状态码#3xx" target="_blank" rel="external">维基百科</a>, 以下是代码的简短介绍。</p>
<ul>
<li>300 Multiple Choices: 返回多个可供选择的资源</li>
<li>301 Moved Permanently: 请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一</li>
<li>302 Found: 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求,HTTP 1.0中的意义是<code>Moved Temporarily</code>,但是很多浏览器的实现是按照303的处实现的，所以HTTP 1.1中增加了 303和307的状态码来区分不同的行为</li>
<li>303 See Other (since HTTP/1.1): 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源</li>
<li>304 Not Modified (RFC 7232): 请求的资源没有改变</li>
<li>305 Use Proxy (since HTTP/1.1): 被请求的资源必须通过指定的代理才能被访问</li>
<li>306 Switch Proxy: 在最新版的规范中，306状态码已经不再被使用</li>
<li>307 Temporary Redirect (since HTTP/1.1): 请求的资源现在临时从不同的URI响应请求,和303不同，它还是使用原先的Method</li>
<li>308 Permanent Redirect (RFC 7538): 请求的资源已永久移动到新位置,并且新请求的Method不能改变</li>
</ul>
<p>Go 的 http 库在实现的过程中也在不断的完成和修改其中的Bug,在 1.8版本中解决了前面版本中实现的问题 (你可以在 Go issues中搜索 redirect 来查看相关的issue)。 本文梳理了 Go 中 Redirect 的相关知识，以便你在遇到转发的问题时心中有数。</p>
<a id="more"></a>
<h3 id="转发策略和默认转发次数。">转发策略和默认转发次数。</h3>
<p><a href="">http.Client</a>包含一个<code>CheckRedirect</code>字段，用来定义转发的策略，如果你没有设置，则默认使用<code>defaultCheckRedirect</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *Client) checkRedirect(req *Request, via []*Request) error {</div><div class="line">	fn := c.CheckRedirect</div><div class="line">	<span class="keyword">if</span> fn == <span class="constant">nil</span> {</div><div class="line">		fn = defaultCheckRedirect</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> fn(req, via)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个函数会在执行转发之前被调用,可以看到这个函数如果返回err,则不再进行转发了。<br>这个函数的第一个参数<code>req</code>是即将转发使用的request，第二个参数 <code>via</code>已经请求的requests。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> {</div><div class="line">    ……</div><div class="line">    <span class="comment">//需要转发</span></div><div class="line">    {</div><div class="line">        ……</div><div class="line">        err = c.checkRedirect(req, reqs)</div><div class="line">		<span class="keyword">if</span> err == ErrUseLastResponse {</div><div class="line">			<span class="keyword">return</span> resp, <span class="constant">nil</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="comment">//discard previous response</span></div><div class="line">        ……</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			ue := uerr(err)</div><div class="line">			ue.(*url.Error).URL = loc</div><div class="line">			<span class="keyword">return</span> resp, ue</div><div class="line">		}</div><div class="line">    }</div><div class="line"></div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>默认的转发策略是最多10次转发， 避免转发次数过高或者死循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> defaultCheckRedirect(req *Request, via []*Request) error {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(via) &gt;=<span class="number"> 10</span> {</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"stopped after 10 redirects"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你要实现不同的转发策略，你需要定义自己的<code>CheckRedirect</code>。</p>
<h3 id="转发安全">转发安全</h3>
<p>1）当转发的request中包含安全的信息Header时， 比如<code>Authorization</code>、<code>WWW-Authenticate</code>、<code>Cookie</code>等Header,如果是跨域，则这些头部不会被复制到新的请求中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> shouldCopyHeaderOnRedirect(headerKey <span class="typename">string</span>, initial, dest *url.URL) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">switch</span> CanonicalHeaderKey(headerKey) {</div><div class="line">	<span class="keyword">case</span> <span class="string">"Authorization"</span>, <span class="string">"Www-Authenticate"</span>, <span class="string">"Cookie"</span>, <span class="string">"Cookie2"</span>:</div><div class="line">		ihost := strings.ToLower(initial.Host)</div><div class="line">		dhost := strings.ToLower(dest.Host)</div><div class="line">		<span class="keyword">return</span> isDomainOrSubdomain(dhost, ihost)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>2）如果设置了一个非空的 cookie Jar, 转发响应会修改 cookie jar中的值，但是下一次转发的时候， <code>Cookie</code>header会被处理，忽略那些变动的cookie.</p>
<p>  when forwarding the &quot;Cookie&quot; header with a non-nil cookie Jar.<br>  Since each redirect may mutate the state of the cookie jar,<br>  a redirect may possibly alter a cookie set in the initial request.<br>  When forwarding the &quot;Cookie&quot; header, any mutated cookies will be omitted,<br>  with the expectation that the Jar will insert those mutated cookies<br>  with the updated values (assuming the origin matches).<br>  If Jar is nil, the initial cookies are forwarded without change.</p>
<p>  具体的你可以查看 <code>makeHeadersCopier</code>的实现。<br>  可以看到每次redirect会删除上次的Redirect造成的变动，再恢复原始的请求的Coookie。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">if</span> c.Jar != <span class="constant">nil</span> && icookies != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">var</span> changed <span class="typename">bool</span></div><div class="line">	resp := req.Response <span class="comment">// The response that caused the upcoming redirect</span></div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> resp.Cookies() {</div><div class="line">		<span class="keyword">if</span> _, ok := icookies[c.Name]; ok {</div><div class="line">			<span class="built_in">delete</span>(icookies, c.Name)</div><div class="line">			changed = <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> changed {</div><div class="line">		ireqhdr.Del(<span class="string">"Cookie"</span>)</div><div class="line">		<span class="keyword">var</span> ss []<span class="typename">string</span></div><div class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> icookies {</div><div class="line">			<span class="keyword">for</span> _, c := <span class="keyword">range</span> cs {</div><div class="line">				ss = <span class="built_in">append</span>(ss, c.Name+<span class="string">"="</span>+c.Value)</div><div class="line">			}</div><div class="line">		}</div><div class="line">		sort.Strings(ss) <span class="comment">// Ensure deterministic headers</span></div><div class="line">		ireqhdr.Set(<span class="string">"Cookie"</span>, strings.Join(ss, <span class="string">"; "</span>))</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Copy the initial request's Header values</span></div><div class="line"><span class="comment">// (at least the safe ones).</span></div><div class="line"><span class="keyword">for</span> k, vv := <span class="keyword">range</span> ireqhdr {</div><div class="line">	<span class="keyword">if</span> shouldCopyHeaderOnRedirect(k, preq.URL, req.URL) {</div><div class="line">		req.Header[k] = vv</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="转发规则">转发规则</h3>
<p>当服务器返回一个转发response的时候， client首先使用<code>CheckRedirect</code>函数检查是否要进行转发。</p>
<p>默认会处理下列请求：</p>
<ul>
<li>301 (Moved Permanently)</li>
<li>302 (Found)</li>
<li>303 (See Other)</li>
<li>307 (Temporary Redirect)</li>
<li>308 (Permanent Redirect)</li>
</ul>
<p>如果需要转发， 对于<code>301</code>、<code>302</code>、<code>303</code>的状态码， 接下来转发的请求会将请求<strong>Method</strong>转换成<code>GET</code> method (如果原始请求Method是<code>HEAD</code>则不变，还是<code>HEAD</code>)， 而且body为空， 尽管原始的请求可能包含body。 对于<code>307</code>、<code>308</code>状态码，接下来转发的请求的<strong>Method</strong>没有变化，和原始的请求保持一致， 并且还是使用原始的body内容来发送转发请求。</p>
<p>代码处理的逻辑是由<code>redirectBehavior</code>函数实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> redirectBehavior(reqMethod <span class="typename">string</span>, resp *Response, ireq *Request) (redirectMethod <span class="typename">string</span>, shouldRedirect, includeBody <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">switch</span> resp.StatusCode {</div><div class="line">	<span class="keyword">case</span><span class="number"> 301</span>,<span class="number"> 302</span>,<span class="number"> 303</span>:</div><div class="line">		redirectMethod = reqMethod</div><div class="line">		shouldRedirect = <span class="constant">true</span></div><div class="line">		includeBody = <span class="constant">false</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> reqMethod != <span class="string">"GET"</span> && reqMethod != <span class="string">"HEAD"</span> {</div><div class="line">			redirectMethod = <span class="string">"GET"</span></div><div class="line">		}</div><div class="line">	<span class="keyword">case</span><span class="number"> 307</span>,<span class="number"> 308</span>:</div><div class="line">		redirectMethod = reqMethod</div><div class="line">		shouldRedirect = <span class="constant">true</span></div><div class="line">		includeBody = <span class="constant">true</span></div><div class="line"></div><div class="line">	</div><div class="line">		<span class="keyword">if</span> resp.Header.Get(<span class="string">"Location"</span>) == <span class="string">""</span> {</div><div class="line">			shouldRedirect = <span class="constant">false</span></div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> ireq.GetBody == <span class="constant">nil</span> && ireq.outgoingLength() !=<span class="number"> 0</span> {</div><div class="line">			shouldRedirect = <span class="constant">false</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> redirectMethod, shouldRedirect, includeBody</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上是介绍的http Redirect相关的内容，它们主要是客户端的代码逻辑。 下面两节介绍一下与http redirect有一点点关系的内容。</p>
<h3 id="RedirectHandler">RedirectHandler</h3>
<p>http定义了一个便利类型: <a href="https://golang.org/pkg/net/http/#RedirectHandler" target="_blank" rel="external">RedirectHandler</a>, 它是一个预定义的http handler,可以将指定的请求转发到指定的url中， 主要就是使用设定的 url 和 status code 设置 response 的 Location。</p>
<p>它用作服务器端的开发中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> RedirectHandler(url <span class="typename">string</span>, code <span class="typename">int</span>) Handler</div></pre></td></tr></table></figure>

<p>注意 code应该是 <code>3xx</code>的状态码， 通常是<code>StatusMovedPermanently</code>, <code>StatusFound</code> 或者 <code>StatusSeeOther</code>。</p>
<h3 id="RoundTripper">RoundTripper</h3>
<p><a href="https://golang.org/pkg/net/http/#RoundTripper" target="_blank" rel="external">RoundTripper</a>也用作客户端的开发。</p>
<p>RoundTripper代表一次http 的请求。 当使用redirect的时候，你可能redirect多次，也就是执行了n次的http请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> {</div><div class="line">        RoundTrip(*Request) (*Response, error)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>DefaultTransport</code>是默认RoundTripper的实现。它建立网络连接，并且会缓存以便后续的请求重用。它会使用<code>$HTTP_PROXY</code>和<code>$NO_PROXY</code> (或者 $http_proxy， $no_proxy)环境变量来设置代理.</p>
<p>其它的RoundTripper的实现还有<code>NewFileTransport</code>创建的RoundTripper,用来服务文件系统，将文件系统映射成http的处理方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &Transport{</div><div class="line">        Proxy: ProxyFromEnvironment,</div><div class="line">        DialContext: (&net.Dialer{</div><div class="line">                Timeout:  <span class="number"> 30</span> * time.Second,</div><div class="line">                KeepAlive:<span class="number"> 30</span> * time.Second,</div><div class="line">                DualStack: <span class="constant">true</span>,</div><div class="line">        }).DialContext,</div><div class="line">        MaxIdleConns:         <span class="number"> 100</span>,</div><div class="line">        IdleConnTimeout:      <span class="number"> 90</span> * time.Second,</div><div class="line">        TLSHandshakeTimeout:  <span class="number"> 10</span> * time.Second,</div><div class="line">        ExpectContinueTimeout:<span class="number"> 1</span> * time.Second,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当<code>Redirect</code>的时候，默认转发是http库自动帮你实现的，如果你想对于转发过程做深入的跟踪的话(简单跟踪可以使用<a href="https://golang.org/pkg/net/http/httptrace/" target="_blank" rel="external">httptrace</a>),你可以自定义一个RoundTripper,比如下面的这个：</p>
<figure class="highlight go"><figcaption><span>http://stackoverflow.com/questions/24577494/how-to-get-the-http-redirect-status-codes-in-golang</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> LogRedirects <span class="keyword">struct</span> {</div><div class="line">    Transport http.RoundTripper</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l LogRedirects) RoundTrip(req *http.Request) (resp *http.Response, err error) {</div><div class="line">    t := l.Transport</div><div class="line">    <span class="keyword">if</span> t == <span class="constant">nil</span> {</div><div class="line">        t = http.DefaultTransport</div><div class="line">    }</div><div class="line">    resp, err = t.RoundTrip(req)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    <span class="keyword">switch</span> resp.StatusCode {</div><div class="line">    <span class="keyword">case</span> http.StatusMovedPermanently, http.StatusFound, http.StatusSeeOther, http.StatusTemporaryRedirect:</div><div class="line">        log.Println(<span class="string">"Request for"</span>, req.URL, <span class="string">"redirected with status"</span>, resp.StatusCode)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>创建<code>Client</code>的时候可以使用下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client := &http.Client{Transport: LogRedirects{}}</div></pre></td></tr></table></figure>

<p>这样每次转发过程我们都可以追踪。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTTP 规范中定义了返回码为 <code>3xx</code> 代表客户端需要做一些额外的工作来完成请求，大部分<code>3xx</code>用来做转发(redirect)。</p>
<p>状态码的详细说明可以参照规范或者 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" target="_blank" rel="external">wikipedia</a>、<a href="https://zh.wikipedia.org/wiki/HTTP状态码#3xx" target="_blank" rel="external">维基百科</a>, 以下是代码的简短介绍。</p>
<ul>
<li>300 Multiple Choices: 返回多个可供选择的资源</li>
<li>301 Moved Permanently: 请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一</li>
<li>302 Found: 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求,HTTP 1.0中的意义是<code>Moved Temporarily</code>,但是很多浏览器的实现是按照303的处实现的，所以HTTP 1.1中增加了 303和307的状态码来区分不同的行为</li>
<li>303 See Other (since HTTP/1.1): 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源</li>
<li>304 Not Modified (RFC 7232): 请求的资源没有改变</li>
<li>305 Use Proxy (since HTTP/1.1): 被请求的资源必须通过指定的代理才能被访问</li>
<li>306 Switch Proxy: 在最新版的规范中，306状态码已经不再被使用</li>
<li>307 Temporary Redirect (since HTTP/1.1): 请求的资源现在临时从不同的URI响应请求,和303不同，它还是使用原先的Method</li>
<li>308 Permanent Redirect (RFC 7538): 请求的资源已永久移动到新位置,并且新请求的Method不能改变</li>
</ul>
<p>Go 的 http 库在实现的过程中也在不断的完成和修改其中的Bug,在 1.8版本中解决了前面版本中实现的问题 (你可以在 Go issues中搜索 redirect 来查看相关的issue)。 本文梳理了 Go 中 Redirect 的相关知识，以便你在遇到转发的问题时心中有数。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gRPC的那些事 - interceptor]]></title>
    <link href="http://colobu.com/2017/04/17/dive-into-gRPC-interceptor/"/>
    <id>http://colobu.com/2017/04/17/dive-into-gRPC-interceptor/</id>
    <published>2017-04-17T04:42:32.000Z</published>
    <updated>2017-04-17T05:41:16.000Z</updated>
    <content type="html"><![CDATA[<p>gRPC-Go 增加了拦截器(interceptor)的功能， 就像Java Servlet中的 filter一样，可以对RPC的请求和响应进行拦截处理，而且既可以在客户端进行拦截，也可以对服务器端进行拦截。</p>
<p>利用拦截器，可以对gRPC进行扩展，利用社区的力量将gRPC发展壮大，也可以让开发者更灵活地处理gRPC流程中的业务逻辑。下面列出了利用拦截器实现的一些功能框架：<br><a id="more"></a></p>
<ol>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware" target="_blank" rel="external">Go gRPC Middleware</a>:提供了拦截器的interceptor链式的功能，可以将多个拦截器组合成一个拦截器链，当然它还提供了其它的功能，所以以gRPC中间件命名。</li>
<li><a href="https://github.com/kazegusuri/grpc-multi-interceptor" target="_blank" rel="external">grpc-multi-interceptor</a>: 是另一个interceptor链式功能的库，也可以将单向的或者流式的拦截器组合。</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/auth" target="_blank" rel="external">grpc_auth</a>: 身份验证拦截器</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/tags" target="_blank" rel="external">grpc_ctxtags</a>: 为上下文增加<code>Tag</code> map对象</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/logging/zap" target="_blank" rel="external">grpc_zap</a>: 支持<code>zap</code>日志框架</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/logging/logrus" target="_blank" rel="external">grpc_logrus</a>: 支持<code>logrus</code>日志框架</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-prometheus" target="_blank" rel="external">grpc_prometheus</a>: 支持 <code>prometheus</code></li>
<li><a href="https://github.com/grpc-ecosystem/grpc-opentracing/tree/master/go/otgrpc" target="_blank" rel="external">otgrpc</a>: 支持opentracing/zipkin</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/tracing/opentracing" target="_blank" rel="external">grpc_opentracing</a>:支持opentracing/zipkin</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/retry" target="_blank" rel="external">grpc_retry</a>: 为客户端增加重试的功能</li>
<li><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/validator" target="_blank" rel="external">grpc_validator</a>: 为服务器端增加校验的功能</li>
<li><a href="https://github.com/mercari/go-grpc-interceptor/tree/master/xrequestid" target="_blank" rel="external">xrequestid</a>: 将request id 设置到context中</li>
<li><a href="https://github.com/mercari/go-grpc-interceptor/tree/master/acceptlang" target="_blank" rel="external">go-grpc-interceptor</a>: 解析<code>Accept-Language</code>并设置到context</li>
<li><a href="https://github.com/mercari/go-grpc-interceptor/tree/master/requestdump" target="_blank" rel="external">requestdump</a>: 输出request/response</li>
</ol>
<p>也有其它一些文章介绍的利用拦截器的例子，如下面的两篇文章：<br><a href="https://texlution.com/post/oauth-and-grpc-go/" target="_blank" rel="external">Introduction to OAuth on gRPC</a>、<a href="https://segmentfault.com/a/1190000007997759" target="_blank" rel="external">gRPC实践 拦截器 Interceptor</a></p>
<p>相信会有更多有趣的拦截器被贡献出来。</p>
<p>注意，服务器只能配置一个 unary interceptor和 stream interceptor，否则会报错，客户端也是，虽然不会报错，但是只有最后一个才起作用。 如果你想配置多个，可以使用前面提到的拦截器链或者自己实现一个。</p>
<p>实现拦截器麻烦吗？一点都不麻烦，相反，非常的简单。</p>
<p>对于服务器端的单向调用的拦截器，只需定义一个<code>UnaryServerInterceptor</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="keyword">func</span>(ctx context.Context, req <span class="keyword">interface</span>{}, info *UnaryServerInfo, handler UnaryHandler) (resp <span class="keyword">interface</span>{}, err error)</div></pre></td></tr></table></figure>

<p>对于服务器端stream调用的拦截器，只需定义一个<code>StreamServerInterceptor</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> StreamServerInterceptor <span class="keyword">func</span>(srv <span class="keyword">interface</span>{}, ss ServerStream, info *StreamServerInfo, handler StreamHandler) error</div></pre></td></tr></table></figure>

<p>方法的参数中包含了上下文，请求和stream以及要调用对象的信息。</p>
<p>对于客户端的单向的拦截，只需定义一个``方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> UnaryClientInterceptor <span class="keyword">func</span>(ctx context.Context, method <span class="typename">string</span>, req, reply <span class="keyword">interface</span>{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error</div></pre></td></tr></table></figure>

<p>对于客户端的stream的拦截，只需定义一个``方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> StreamClientInterceptor <span class="keyword">func</span>(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="typename">string</span>, streamer Streamer, opts ...CallOption) (ClientStream, error)</div></pre></td></tr></table></figure>

<p>你可以查看上面提到的一些开源的拦截器的实现，它们的实现都不是太复杂，下面我们以一个简单的例子来距离，在方法调用的前后打印一个log。</p>
<p><strong>Server端的拦截器</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"flag"</span></div><div class="line"></div><div class="line">	pb <span class="string">"github.com/smallnest/grpc/a/pb"</span></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/reflection"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	port = flag.String(<span class="string">"p"</span>, <span class="string">":8972"</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {</div><div class="line">	<span class="keyword">return</span> &pb.HelloReply{Message: <span class="string">"Hello "</span> + in.Name}, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, *port)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</div><div class="line">	}</div><div class="line">	s := grpc.NewServer(grpc.StreamInterceptor(StreamServerInterceptor),</div><div class="line">		grpc.UnaryInterceptor(UnaryServerInterceptor))</div><div class="line">	pb.RegisterGreeterServer(s, &server{})</div><div class="line"></div><div class="line">	reflection.Register(s)</div><div class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> UnaryServerInterceptor(ctx context.Context, req <span class="keyword">interface</span>{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (<span class="keyword">interface</span>{}, error) {</div><div class="line">	log.Printf(<span class="string">"before handling. Info: %+v"</span>, info)</div><div class="line">	resp, err := handler(ctx, req)</div><div class="line">	log.Printf(<span class="string">"after handling. resp: %+v"</span>, resp)</div><div class="line">	<span class="keyword">return</span> resp, err</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// StreamServerInterceptor is a gRPC server-side interceptor that provides Prometheus monitoring for Streaming RPCs.</span></div><div class="line"><span class="keyword">func</span> StreamServerInterceptor(srv <span class="keyword">interface</span>{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {</div><div class="line">	log.Printf(<span class="string">"before handling. Info: %+v"</span>, info)</div><div class="line">	err := handler(srv, ss)</div><div class="line">	log.Printf(<span class="string">"after handling. err: %v"</span>, err)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>grpc.NewServer</code>可以将拦截器作为参数传入，在提供服务的时候，我们可以看到拦截器打印出log:</p>
<figure class="highlight log"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">20</span> before handling. <span class="constant">Info</span><span class="symbol">:</span> &{<span class="constant">Server</span><span class="symbol">:</span><span class="number">0x17309c8</span> <span class="constant">FullMethod</span><span class="symbol">:/pb</span>.<span class="constant">Greeter</span>/<span class="constant">SayHello</span>}</div><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span><span class="symbol">:</span><span class="number">34</span><span class="symbol">:</span><span class="number">20</span> after handling. <span class="symbol">resp:</span> &<span class="constant">HelloReply</span>{<span class="constant">Message</span><span class="symbol">:Hello</span> world,}</div></pre></td></tr></table></figure>

<p><strong>客户端的拦截器</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="comment">//"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line"></div><div class="line">	pb <span class="string">"github.com/smallnest/grpc/a/pb"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	address = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"address"</span>)</div><div class="line">	name    = flag.String(<span class="string">"n"</span>, <span class="string">"world"</span>, <span class="string">"name"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	<span class="comment">// 连接服务器</span></div><div class="line">	conn, err := grpc.Dial(*address, grpc.WithInsecure(), grpc.WithUnaryInterceptor(UnaryClientInterceptor),</div><div class="line">		grpc.WithStreamInterceptor(StreamClientInterceptor))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"faild to connect: %v"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	c := pb.NewGreeterClient(conn)</div><div class="line"></div><div class="line">	r, err := c.SayHello(context.Background(), &pb.HelloRequest{Name: *name})</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</div><div class="line">	}</div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, r.Message)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> UnaryClientInterceptor(ctx context.Context, method <span class="typename">string</span>, req, reply <span class="keyword">interface</span>{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {</div><div class="line">	log.Printf(<span class="string">"before invoker. method: %+v, request:%+v"</span>, method, req)</div><div class="line">	err := invoker(ctx, method, req, reply, cc, opts...)</div><div class="line">	log.Printf(<span class="string">"after invoker. reply: %+v"</span>, reply)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> StreamClientInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method <span class="typename">string</span>, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {</div><div class="line">	log.Printf(<span class="string">"before invoker. method: %+v, StreamDesc:%+v"</span>, method, desc)</div><div class="line">	clientStream, err := streamer(ctx, desc, cc, method, opts...)</div><div class="line">	log.Printf(<span class="string">"before invoker. method: %+v"</span>, method)</div><div class="line">	<span class="keyword">return</span> clientStream, err</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<code>grpc.WithUnaryInterceptor</code>、<code>grpc.WithStreamInterceptor</code>可以将拦截器传递给<code>Dial</code>做参数。在客户端调用的时候，可以查看拦截器输出的日志:</p>
<figure class="highlight log"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">20</span> before invoker. <span class="function"><span class="keyword">method</span>:</span> /pb.Greeter/SayHello, request:&HelloRequest<span class="comment">{Name:world,}</span></div><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">20</span> after invoker. reply: &HelloReply<span class="comment">{Message:Hello world,}</span></div><div class="line"><span class="number">2017</span>/<span class="number">04</span>/<span class="number">17</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">20</span> Greeting: Hello world</div></pre></td></tr></table></figure>

<p>通过这个简单的例子，你可以很容易的了解拦截器的开发。unary和stream两种类型的拦截器可以根据你的gRPC server/client实现的不同，有选择的实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>gRPC-Go 增加了拦截器(interceptor)的功能， 就像Java Servlet中的 filter一样，可以对RPC的请求和响应进行拦截处理，而且既可以在客户端进行拦截，也可以对服务器端进行拦截。</p>
<p>利用拦截器，可以对gRPC进行扩展，利用社区的力量将gRPC发展壮大，也可以让开发者更灵活地处理gRPC流程中的业务逻辑。下面列出了利用拦截器实现的一些功能框架：<br>]]>
    
    </summary>
    
      <category term="gRPC" scheme="http://colobu.com/tags/gRPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go Web 框架性能比拼 2017 春季版]]></title>
    <link href="http://colobu.com/2017/04/07/go-webframework-benchmark-2017-Spring/"/>
    <id>http://colobu.com/2017/04/07/go-webframework-benchmark-2017-Spring/</id>
    <published>2017-04-07T05:04:22.000Z</published>
    <updated>2017-04-17T02:05:28.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://colobu.com/2016/04/06/the-fastest-golang-web-framework/" target="_blank" rel="external">谁是最快的Go Web框架?</a>, 这是我去年发布的Go web 框架的评测。现在一年过去了，有些框架因为缺乏维护而被放弃了，又有新的轮子被创造出来，既有的轮子也在不停的演化升级，来去之间，Go的版本也已经升级的1.8了。 青年节前， <a href="https://github.com/kirillDanshin" target="_blank" rel="external">kirillDanshin</a>提了一个issue,希望能更新最新的测试结果，现在这篇文章就记录了最新的测试结果。</p>
<a id="more"></a>
<p><strong>测试环境</strong></p>
<ul>
<li>CPU:      Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz, 32 cores</li>
<li>Memory:   32G</li>
<li>Go:       1.8.0</li>
<li>OS:       CentOS 7 / 3.10.0-229.el7.x86_64</li>
</ul>
<p>所有的评测的 web 框架都已经更新到 2017-04-01 的最新版本。</p>
<p><strong>说明</strong><br>Julien Schmidt实现的 <a href="https://github.com/julienschmidt/go-http-routing-benchmark" target="_blank" rel="external">go-http-routing-benchmark</a> 是对 router的一个评测，但是作为完整的web框架，从接收用户请求到发送给客户端／浏览器，中间会经过多个组件的处理， router的性能影响到底在整体的web请求处理中影像多大呢？看测试结果。</p>
<p>本项目的代码在 <a href="https://github.com/smallnest/go-web-framework-benchmark" target="_blank" rel="external">go-web-framework-benchmark</a>, 你可以查看，也欢迎提 pull request。</p>
<p>测试中的 <strong>gear</strong> 测试代码有问题，没有加上router中间件， 你可以在这次测试中忽略它的benchmark。参看 <a href="https://github.com/smallnest/go-web-framework-benchmark/pull/33" target="_blank" rel="external"># 33</a></p>
<h3 id="模拟业务不同的处理时间框架的性能">模拟业务不同的处理时间框架的性能</h3>
<p>使用 5000 个客户端模拟请求，比较各web框架在不同的处理时间下的性能。</p>
<h4 id="1、0ms">1、0ms</h4>
<p><code>0ms</code>模拟理想的业务处理。在这种处理时间下， 每个请求基本只耗费小于1毫秒的处理时间，这是理想的极端的情况，比如访问内存中缓存的对象就返回。 </p>
<p><img src="benchmark.png" alt="吞吐率"></p>
<p><img src="benchmark_latency.png" alt="延迟"></p>
<p><img src="benchmark_alloc.png" alt="对象分配"></p>
<h4 id="2、10ms">2、10ms</h4>
<p><code>10ms</code>模拟比较好的业务处理。在这种情况下，服务器只需在极短的情况下(10ms)处理完请求，如果业务不是太复杂，没有访问本地磁盘、数据库或者其它远程服务的情况下，比较符合这种测试。</p>
<p><img src="benchmark10.png" alt="吞吐率"></p>
<p><img src="benchmark_latency10.png" alt="延迟"></p>
<p><img src="benchmark_alloc10.png" alt="对象分配"></p>
<h4 id="3、100ms">3、100ms</h4>
<p><code>100ms</code>模拟一般的业务处理。一般接收请求后，可能访问本地磁盘上的文件、数据库或者调用一个或多个远程服务，在这种情况下，完成一次请求可能要花费较少的时间。</p>
<p><img src="benchmark100.png" alt="吞吐率"></p>
<p><img src="benchmark_latency100.png" alt="延迟"></p>
<p><img src="benchmark_alloc100.png" alt="对象分配"></p>
<h3 id="pipelining">pipelining</h3>
<p>这个测试是模拟在 <a href="https://en.wikipedia.org/wiki/HTTP_pipelining" target="_blank" rel="external">pipelining</a> 情况下 web 框架的表现。</p>
<p>HTTP管线化（HTTP pipelining）是将多个HTTP请求（request）整批提交的技术，而在发送过程中不需先等待服务端的回应。<br>请求结果管线化使得 HTML 网页加载时间动态提升，特别是在具体有高延迟的连接环境下，如卫星上网。在宽带连接中，加速不是那么显著的，因为需要服务器端应用 HTTP/1.1 协议:服务器端必须按照客户端的请求顺序恢复请求，这样整个连接还是先进先出的，对头阻塞（HOL blocking）可能会发生，造成延迟。未来的 HTTP/2.0 或者SPDY中的异步操作将会解决这个问题。因为它可能将多个 HTTP 请求填充在一个TCP数据包内，HTTP 管线化需要在网络上传输较少的 TCP 数据包，减少了网络负载。</p>
<p><img src="pipelining.png" alt="来自 wikipedia"></p>
<p>下图是使用 5000 客户端 测试不同的处理时间的性能比较图。</p>
<p><img src="benchmark-pipeline.png" alt=""></p>
<h3 id="并发">并发</h3>
<p>下面这组测试是在业务处理时间限定在<code>30ms</code>的情况下， 使用100、1000、5000的并发client的吞吐情况。</p>
<h4 id="1、100并发">1、100并发</h4>
<p><img src="concurrency100.png" alt="吞吐率"></p>
<p><img src="concurrency_latency100.png" alt="延迟"></p>
<h4 id="2、1000并发">2、1000并发</h4>
<p><img src="concurrency1000.png" alt="吞吐率"></p>
<p><img src="concurrency_latency1000.png" alt="延迟"></p>
<h4 id="3、5000并发">3、5000并发</h4>
<p><img src="concurrency5000.png" alt="吞吐率"></p>
<p><img src="concurrency_latency5000.png" alt="延迟"></p>
<h3 id="总结">总结</h3>
<p>Go Web框架目前已经非常多了，不断的有人造轮子，这是Go Web的设计简单易扩展有关。如果我觉得官方的路由不方便，我就可以很容易的再造一个轮子，这也是go web 框架／router泛滥的缘故， 以至于有人呼吁不要再早轮子了。</p>
<p>从目前既有的web框架看，根据框架的低层看，可以分为两类。一类是基于官方 <code>net/http</code>标准库开发的web框架，一类是基于<code>fasthttp</code>开发的标准库框架。很明显基于<code>fasthttp</code>有更好的性能，但是这类框架也有它们的缺点，不完全支持HTTP协议，比如不支持<code>HEAD</code>，不支持 HTTP2， 各有优缺点，如何选择交给使用者，结合自己实际的情况来选择。比如Echo框架，在最新版中就把对<code>fasthttp</code>的支持去掉了。</p>
<p>另外，julienschmidt的<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="external">httprouter</a>有着良好的性能，这也是很几个web框架的路由器使用它的原因。</p>
<p>为什么没有关注量很高<a href="https://github.com/kataras/iris" target="_blank" rel="external">iris</a>？这是一个复杂而又有争议的问题，参照<a href="https://github.com/smallnest/go-web-framework-benchmark/issues/29" target="_blank" rel="external">issue #29</a>、<a href="https://github.com/smallnest/go-web-framework-benchmark/pull/16" target="_blank" rel="external">issue #16</a>， 暂时把iris去掉了。</p>
<p>测试代码和最新结果都在 <a href="https://github.com/smallnest/go-web-framework-benchmark" target="_blank" rel="external">go-web-framework-benchmark</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://colobu.com/2016/04/06/the-fastest-golang-web-framework/" target="_blank" rel="external">谁是最快的Go Web框架?</a>, 这是我去年发布的Go web 框架的评测。现在一年过去了，有些框架因为缺乏维护而被放弃了，又有新的轮子被创造出来，既有的轮子也在不停的演化升级，来去之间，Go的版本也已经升级的1.8了。 青年节前， <a href="https://github.com/kirillDanshin" target="_blank" rel="external">kirillDanshin</a>提了一个issue,希望能更新最新的测试结果，现在这篇文章就记录了最新的测试结果。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gRPC的那些事 - streaming]]></title>
    <link href="http://colobu.com/2017/04/06/dive-into-gRPC-streaming/"/>
    <id>http://colobu.com/2017/04/06/dive-into-gRPC-streaming/</id>
    <published>2017-04-06T03:40:26.000Z</published>
    <updated>2017-04-17T04:44:11.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.grpc.io" target="_blank" rel="external">gRPC</a>是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。 gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。 客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。</p>
<p>gRPC具有以下重要特征：<br>强大的IDL特性 RPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议，性能出众，得到了广泛的应用。<br>支持多种语言 支持C++、Java、Go、Python、Ruby、C#、Node.js、Android Java、Objective-C、PHP等编程语言。 3.基于HTTP/2标准设计</p>
<p><img src="/2017/04/06/dive-into-gRPC-streaming/gRPC.png" alt=""></p>
<p>gRPC已经应用在Google的云服务和对外提供的API中。</p>
<p>gRPC开发起来非常的简单，你可以阅读 一个 <a href="https://github.com/smallnest/grpc-examples/tree/master/helloworld" target="_blank" rel="external">helloworld 的例子</a>来了解它的基本开发流程 (本系列文章以Go语言的开发为例)。</p>
<p>最基本的开发步骤是定义 <code>proto</code> 文件， 定义请求 Request 和 响应 Response 的格式，然后定义一个服务 Service， Service可以包含多个方法。</p>
<p>基本的gRPC开发很多文章都介绍过了，官方也有相关的文档，这个系列的文章也就不介绍这些基础的开发，而是想通过代码演示gRPC更深入的开发。 作为这个系列的第一篇文章，想和大家分享一下gRPC流式开发的知识。</p>
<p>gRPC的流可以分为三类， 客户端流式发送、服务器流式返回以及客户端／服务器同时流式处理, 也就是单向流和双向流。 下面针对这三种情况分别通过例子介绍。</p>
<a id="more"></a>
<h3 id="服务器流式响应">服务器流式响应</h3>
<p>通过使用流(streaming)，你可以向服务器或者客户端发送批量的数据， 服务器和客户端在接收这些数据的时候，可以不必等所有的消息全收到后才开始响应，而是接收到第一条消息的时候就可以及时的响应， 这显然比以前的类HTTP 1.1的方式更快的提供响应，从而提高性能。</p>
<p>比如有一批记录个人收入数据，客户端流式发送给服务器，服务器计算出每个人的个人所得税，将结果流式发给客户端。这样客户端的发送可以和服务器端的计算并行之行，从而减少服务的延迟。这只是一个简单的例子，你可以利用流来实现RPC调用的异步执行，将客户端的调用和服务器端的执行并行的处理，</p>
<p>当前gRPC通过 HTTP2 协议传输，可以方便的实现 streaming 功能。 如果你对gRPC如何通过 HTTP2 传输的感兴趣， 你可以阅读这篇文章 <a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="external">gRPC over HTTP2</a>, 它描述了 gRPC 通过 HTTP2 传输的低层格式。Request 和 Response 的格式如下：</p>
<ul>
<li>Request → Request-Headers *Length-Prefixed-Message EOS</li>
<li>Response → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only</li>
</ul>
<p>要实现服务器的流式响应，只需在<code>proto</code>中的方法定义中将响应前面加上<code>stream</code>标记， 如下图中<code>SayHello1</code>方法，<code>HelloReply</code>前面加上<code>stream</code>标识。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">package pb;</div><div class="line"></div><div class="line">import "github.com/gogo/protobuf/gogoproto/gogo.proto";</div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">  // Sends a greeting</div><div class="line">  rpc SayHello1 (HelloRequest) returns (stream HelloReply) {}</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">  string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">  string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子中我使用<a href="https://github.com/gogo/protobuf" target="_blank" rel="external">gogo</a>来生成更有效的protobuf代码，当然你也可以使用原生的工具生成。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GOGO_ROOT=<span class="variable">${GOPATH}</span>/src/github.com/gogo/protobuf</div><div class="line">protoc -I.:<span class="variable">${GOPATH}</span>/src  --gogofaster_out=plugins=grpc:. helloworld.proto</div></pre></td></tr></table></figure>

<p>生成的代码就已经包含了流的处理，所以和普通的gRPC代码差别不是很大， 只需要注意的服务器端代码的实现要通过流的方式发送响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *server) SayHello1(in *pb.HelloRequest, gs pb.Greeter_SayHello1Server) error {</div><div class="line">	name := in.Name</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 100</span>; i++ {</div><div class="line">		gs.Send(&pb.HelloReply{Message: <span class="string">"Hello "</span> + name + strconv.Itoa(i)})</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>和普通的gRPC有什么区别？</p>
<p>普通的gRPC是直接返回一个<code>HelloReply</code>对象，而流式响应你可以通过<code>Send</code>方法返回多个<code>HelloReply</code>对象，对象流序列化后流式返回。</p>
<p>查看它低层的实现其实是使用<code>ServerStream.SendMsg</code>实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Greeter_SayHello1Server <span class="keyword">interface</span> {</div><div class="line">	Send(*HelloReply) error</div><div class="line">	grpc.ServerStream</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> (x *greeterSayHello1Server) Send(m *HelloReply) error {</div><div class="line">	<span class="keyword">return</span> x.ServerStream.SendMsg(m)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于客户端，我们需要关注两个方面有没有变化， 一是发送请求，一是读取响应。下面是客户端的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   conn, err := grpc.Dial(*address, grpc.WithInsecure())</div><div class="line">   <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">   	log.Fatalf(<span class="string">"faild to connect: %v"</span>, err)</div><div class="line">   }</div><div class="line">   <span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">   c := pb.NewGreeterClient(conn)</div><div class="line"></div><div class="line">stream, err := c.SayHello1(context.Background(), &pb.HelloRequest{Name: *name})</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> {</div><div class="line">	reply, err := stream.Recv()</div><div class="line">	<span class="keyword">if</span> err == io.EOF {</div><div class="line">		<span class="keyword">break</span></div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, reply.Message)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>发送请求看起来没有太大的区别，只是返回结果不再是一个单一的<code>HelloReply</code>对象，而是一个<code>Stream</code>。这和服务器端代码正好对应，通过调用<code>stream.Recv()</code>返回每一个<code>HelloReply</code>对象， 直到出错或者流结束(io.EOF)。</p>
<p>可以看出，生成的代码提供了往/从流中方便的发送／读取对象的能力，而这一切， gRPC都帮你生成好了。</p>
<h3 id="客户端流式发送">客户端流式发送</h3>
<p>客户端也可以流式的发送对象，当然这些对象也和上面的一样，都是同一类型的对象。</p>
<p>首先还是要在<code>proto</code>文件中定义，与上面的定义类似，在请求的前面加上<code>stream</code>标识。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">package pb;</div><div class="line"></div><div class="line">import "github.com/gogo/protobuf/gogoproto/gogo.proto";</div><div class="line">option (gogoproto.unmarshaler_all) = true;</div><div class="line"></div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">  rpc SayHello2 (stream HelloRequest) returns (HelloReply) {}</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">  string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">  string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意这里我们只标记了请求是流式的， 响应还是以前的样子。</p>
<p>生成相关的代码后， 客户端的代码为:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> sayHello2(c pb.GreeterClient) {</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	stream, err := c.SayHello2(context.Background())</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 100</span>; i++ {</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		stream.Send(&pb.HelloRequest{Name: *name + strconv.Itoa(i)})</div><div class="line">	}</div><div class="line"></div><div class="line">	reply, err := stream.CloseAndRecv()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"Greeting: %s"</span>, reply.Message)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的调用<code>c.SayHello2</code>并没有直接穿入请求参数，而是返回一个<code>stream</code>，通过这个<code>stream</code>的<code>Send</code>发送，我们可以将对象流式发送。这个例子中我们发送了100个请求。 </p>
<p>客户端读取的方法是<code>stream.CloseAndRecv()</code>,读取完毕会关闭这个流的发送，这个方法返回最终结果。注意客户端只负责关闭流的发送。</p>
<p>服务器端的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *server) SayHello2(gs pb.Greeter_SayHello2Server) error {</div><div class="line">	<span class="keyword">var</span> names []<span class="typename">string</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		in, err := gs.Recv()</div><div class="line">		<span class="keyword">if</span> err == io.EOF {</div><div class="line">			gs.SendAndClose(&pb.HelloReply{Message: <span class="string">"Hello "</span> + strings.Join(names, <span class="string">","</span>)})</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		}</div><div class="line">		names = <span class="built_in">append</span>(names, in.Name)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>服务器端收到每条消息都进行了处理，这里的处理简化为增加到一个slice中。一旦它检测的客户端关闭了流的发送，它则把最终结果发送给客户端，通过关闭这个流。流的关闭通过<code>io.EOF</code>这个error来区分。</p>
<h3 id="双向流">双向流</h3>
<p>将上面两个例子整合，就是双向流的例子。 客户端流式发送，服务器端流式响应，所有的发送和读取都是流式处理的。</p>
<p><code>proto</code>中的定义如下, 请求和响应的前面都加上了<code>stream</code>标识:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">package pb;</div><div class="line"></div><div class="line">import "github.com/gogo/protobuf/gogoproto/gogo.proto";</div><div class="line"></div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">  rpc SayHello3 (stream HelloRequest) returns (stream HelloReply) {}</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">  string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">  string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> sayHello3(c pb.GreeterClient) {</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line"></div><div class="line">	stream, err := c.SayHello3(context.Background())</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> i <span class="typename">int64</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		stream.Send(&pb.HelloRequest{Name: *name + strconv.FormatInt(i,<span class="number"> 10</span>)})</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to send: %v"</span>, err)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		reply, err := stream.Recv()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">		log.Printf(<span class="string">"Greeting: %s"</span>, reply.Message)</div><div class="line">		i++</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过<code>stream.Send</code>发送请求，通过<code>stream.Recv</code>读取响应。客户端可以通过<code>CloseSend</code>方法关闭发送流。</p>
<p>服务器端代码也是通过<code>Send</code>发送响应，通过<code>Recv</code>响应:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *server) SayHello3(gs pb.Greeter_SayHello3Server) error {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		in, err := gs.Recv()</div><div class="line">		<span class="keyword">if</span> err == io.EOF {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Printf(<span class="string">"failed to recv: %v"</span>, err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		}</div><div class="line"></div><div class="line">		gs.Send(&pb.HelloReply{Message: <span class="string">"Hello "</span> + in.Name})</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这基本上&quot;退化&quot;成一个TCP的client和server的架构。</p>
<p>在实际的应用中，你可以根据你的场景来使用单向流还是双向流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.grpc.io" target="_blank" rel="external">gRPC</a>是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。 gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。 客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。</p>
<p>gRPC具有以下重要特征：<br>强大的IDL特性 RPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议，性能出众，得到了广泛的应用。<br>支持多种语言 支持C++、Java、Go、Python、Ruby、C#、Node.js、Android Java、Objective-C、PHP等编程语言。 3.基于HTTP/2标准设计</p>
<p><img src="/2017/04/06/dive-into-gRPC-streaming/gRPC.png" alt=""></p>
<p>gRPC已经应用在Google的云服务和对外提供的API中。</p>
<p>gRPC开发起来非常的简单，你可以阅读 一个 <a href="https://github.com/smallnest/grpc-examples/tree/master/helloworld" target="_blank" rel="external">helloworld 的例子</a>来了解它的基本开发流程 (本系列文章以Go语言的开发为例)。</p>
<p>最基本的开发步骤是定义 <code>proto</code> 文件， 定义请求 Request 和 响应 Response 的格式，然后定义一个服务 Service， Service可以包含多个方法。</p>
<p>基本的gRPC开发很多文章都介绍过了，官方也有相关的文档，这个系列的文章也就不介绍这些基础的开发，而是想通过代码演示gRPC更深入的开发。 作为这个系列的第一篇文章，想和大家分享一下gRPC流式开发的知识。</p>
<p>gRPC的流可以分为三类， 客户端流式发送、服务器流式返回以及客户端／服务器同时流式处理, 也就是单向流和双向流。 下面针对这三种情况分别通过例子介绍。</p>
]]>
    
    </summary>
    
      <category term="gRPC" scheme="http://colobu.com/tags/gRPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]gRPC服务发现&负载均衡]]></title>
    <link href="http://colobu.com/2017/03/25/grpc-naming-and-load-balance/"/>
    <id>http://colobu.com/2017/03/25/grpc-naming-and-load-balance/</id>
    <published>2017-03-25T15:26:42.000Z</published>
    <updated>2017-04-05T08:06:34.000Z</updated>
    <content type="html"><![CDATA[<p>原文出处: <a href="https://segmentfault.com/a/1190000008672912" target="_blank" rel="external">gRPC服务发现&amp;负载均衡</a>, 作者: <a href="https://segmentfault.com/u/softfn" target="_blank" rel="external">softfn</a>。</p>
<p>构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p>
<a id="more"></a>
<h4 id="1、集中式LB（Proxy_Model）">1、集中式LB（Proxy Model）</h4>
<p><img src="1.png" alt=""></p>
<p>在服务消费者和服务提供者之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询（Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。 该方案主要问题：</p>
<ol>
<li>单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障影响整个系统；</li>
<li>服务消费方、提供方之间增加了一级，有一定性能开销。</li>
</ol>
<h4 id="2、进程内LB（Balancing-aware_Client）">2、进程内LB（Balancing-aware Client）</h4>
<p><img src="2.png" alt=""></p>
<p>针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。该方案主要问题：</p>
<ol>
<li>开发成本，该方案将服务调用方集成到客户端的进程里头，如果有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本；</li>
<li>另外生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，升级较复杂。</li>
</ol>
<h4 id="3、独立_LB_进程（External_Load_Balancing_Service）">3、独立 LB 进程（External Load Balancing Service）</h4>
<p><img src="3.png" alt=""></p>
<p>该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。<br>不同之处是将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。<br>该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。</p>
<h4 id="gRPC服务发现及负载均衡实现">gRPC服务发现及负载均衡实现</h4>
<p>gRPC开源组件官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。</p>
<p><img src="4.png" alt=""></p>
<p>其基本实现原理：</p>
<ol>
<li>服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。</li>
<li>客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略。</li>
<li>负载均衡策略为每个服务器地址创建一个子通道（channel）。</li>
<li>当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。</li>
</ol>
<p>根据gRPC官方提供的设计思路，基于进程内LB方案（即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制），结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。接下来以GO语言为例，简单介绍下基于Etcd3的关键代码实现：</p>
<h5 id="1）命名解析实现：resolver-go">1）命名解析实现：resolver.go</h5>
<figure class="highlight go"><figcaption><span>resolver.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> etcdv3</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"errors"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"strings"</span></div><div class="line"></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"google.golang.org/grpc/naming"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// resolver is the implementaion of grpc.naming.Resolver</span></div><div class="line"><span class="keyword">type</span> resolver <span class="keyword">struct</span> {</div><div class="line">    serviceName <span class="typename">string</span> <span class="comment">// service name to resolve</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// NewResolver return resolver with service name</span></div><div class="line"><span class="keyword">func</span> NewResolver(serviceName <span class="typename">string</span>) *resolver {</div><div class="line">    <span class="keyword">return</span> &resolver{serviceName: serviceName}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Resolve to resolve the service from etcd, target is the dial address of etcd</span></div><div class="line"><span class="comment">// target example: "http://127.0.0.1:2379,http://127.0.0.1:12379,http://127.0.0.1:22379"</span></div><div class="line"><span class="keyword">func</span> (re *resolver) Resolve(target <span class="typename">string</span>) (naming.Watcher, error) {</div><div class="line">    <span class="keyword">if</span> re.serviceName == <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span>, errors.New(<span class="string">"grpclb: no service name provided"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// generate etcd client</span></div><div class="line">    client, err := etcd3.New(etcd3.Config{</div><div class="line">        Endpoints: strings.Split(target, <span class="string">","</span>),</div><div class="line">    })</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"grpclb: creat etcd3 client failed: %s"</span>, err.Error())</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return watcher</span></div><div class="line">    <span class="keyword">return</span> &watcher{re: re, client: *client}, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="2）服务发现实现：watcher-go">2）服务发现实现：watcher.go</h5>
<figure class="highlight go"><figcaption><span>watcher.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> etcdv3</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc/naming"</span></div><div class="line">    <span class="string">"github.com/coreos/etcd/mvcc/mvccpb"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// watcher is the implementaion of grpc.naming.Watcher</span></div><div class="line"><span class="keyword">type</span> watcher <span class="keyword">struct</span> {</div><div class="line">    re            *resolver <span class="comment">// re: Etcd Resolver</span></div><div class="line">    client        etcd3.Client</div><div class="line">    isInitialized <span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Close do nothing</span></div><div class="line"><span class="keyword">func</span> (w *watcher) Close() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Next to return the updates</span></div><div class="line"><span class="keyword">func</span> (w *watcher) Next() ([]*naming.Update, error) {</div><div class="line">    <span class="comment">// prefix is the etcd prefix/value to watch</span></div><div class="line">    prefix := fmt.Sprintf(<span class="string">"/%s/%s/"</span>, Prefix, w.re.serviceName)</div><div class="line"></div><div class="line">    <span class="comment">// check if is initialized</span></div><div class="line">    <span class="keyword">if</span> !w.isInitialized {</div><div class="line">        <span class="comment">// query addresses from etcd</span></div><div class="line">        resp, err := w.client.Get(context.Background(), prefix, etcd3.WithPrefix())</div><div class="line">        w.isInitialized = <span class="constant">true</span></div><div class="line">        <span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">            addrs := extractAddrs(resp)</div><div class="line">            <span class="comment">//if not empty, return the updates or watcher new dir</span></div><div class="line">            <span class="keyword">if</span> l := <span class="built_in">len</span>(addrs); l !=<span class="number"> 0</span> {</div><div class="line">                updates := <span class="built_in">make</span>([]*naming.Update, l)</div><div class="line">                <span class="keyword">for</span> i := <span class="keyword">range</span> addrs {</div><div class="line">                    updates[i] = &naming.Update{Op: naming.Add, Addr: addrs[i]}</div><div class="line">                }</div><div class="line">                <span class="keyword">return</span> updates, <span class="constant">nil</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// generate etcd Watcher</span></div><div class="line">    rch := w.client.Watch(context.Background(), prefix, etcd3.WithPrefix())</div><div class="line">    <span class="keyword">for</span> wresp := <span class="keyword">range</span> rch {</div><div class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wresp.Events {</div><div class="line">            <span class="keyword">switch</span> ev.Type {</div><div class="line">            <span class="keyword">case</span> mvccpb.PUT:</div><div class="line">                <span class="keyword">return</span> []*naming.Update{ {Op: naming.Add, Addr: <span class="typename">string</span>(ev.Kv.Value)} }, <span class="constant">nil</span></div><div class="line">            <span class="keyword">case</span> mvccpb.DELETE:</div><div class="line">                <span class="keyword">return</span> []*naming.Update{ {Op: naming.Delete, Addr: <span class="typename">string</span>(ev.Kv.Value)} }, <span class="constant">nil</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> extractAddrs(resp *etcd3.GetResponse) []<span class="typename">string</span> {</div><div class="line">    addrs := []<span class="typename">string</span>{}</div><div class="line"></div><div class="line">    <span class="keyword">if</span> resp == <span class="constant">nil</span> || resp.Kvs == <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> addrs</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> resp.Kvs {</div><div class="line">        <span class="keyword">if</span> v := resp.Kvs[i].Value; v != <span class="constant">nil</span> {</div><div class="line">            addrs = <span class="built_in">append</span>(addrs, <span class="typename">string</span>(v))</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> addrs</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="3）服务注册实现：register-go">3）服务注册实现：register.go</h5>
<figure class="highlight go"><figcaption><span>register.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> etcdv3</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"strings"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Prefix should start and end with no slash</span></div><div class="line"><span class="keyword">var</span> Prefix = <span class="string">"etcd3_naming"</span></div><div class="line"><span class="keyword">var</span> client etcd3.Client</div><div class="line"><span class="keyword">var</span> serviceKey <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> stopSignal = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>,<span class="number"> 1</span>)</div><div class="line"></div><div class="line"><span class="comment">// Register</span></div><div class="line"><span class="keyword">func</span> Register(name <span class="typename">string</span>, host <span class="typename">string</span>, port <span class="typename">int</span>, target <span class="typename">string</span>, interval time.Duration, ttl <span class="typename">int</span>) error {</div><div class="line">    serviceValue := fmt.Sprintf(<span class="string">"%s:%d"</span>, host, port)</div><div class="line">    serviceKey = fmt.Sprintf(<span class="string">"/%s/%s/%s"</span>, Prefix, name, serviceValue)</div><div class="line"></div><div class="line">    <span class="comment">// get endpoints for register dial address</span></div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    client, err := etcd3.New(etcd3.Config{</div><div class="line">        Endpoints: strings.Split(target, <span class="string">","</span>),</div><div class="line">    })</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"grpclb: create etcd3 client failed: %v"</span>, err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        <span class="comment">// invoke self-register with ticker</span></div><div class="line">        ticker := time.NewTicker(interval)</div><div class="line">        <span class="keyword">for</span> {</div><div class="line">            <span class="comment">// minimum lease TTL is ttl-second</span></div><div class="line">            resp, _ := client.Grant(context.TODO(), <span class="typename">int64</span>(ttl))</div><div class="line">            <span class="comment">// should get first, if not exist, set it</span></div><div class="line">            _, err := client.Get(context.Background(), serviceKey)</div><div class="line">            <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                <span class="keyword">if</span> err == rpctypes.ErrKeyNotFound {</div><div class="line">                    <span class="keyword">if</span> _, err := client.Put(context.TODO(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != <span class="constant">nil</span> {</div><div class="line">                        log.Printf(<span class="string">"grpclb: set service '%s' with ttl to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    log.Printf(<span class="string">"grpclb: service '%s' connect to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// refresh set to true for not notifying the watcher</span></div><div class="line">                <span class="keyword">if</span> _, err := client.Put(context.Background(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != <span class="constant">nil</span> {</div><div class="line">                    log.Printf(<span class="string">"grpclb: refresh service '%s' with ttl to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">select</span> {</div><div class="line">            <span class="keyword">case</span> &lt;-stopSignal:</div><div class="line">                <span class="keyword">return</span></div><div class="line">            <span class="keyword">case</span> &lt;-ticker.C:</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// UnRegister delete registered service from etcd</span></div><div class="line"><span class="keyword">func</span> UnRegister() error {</div><div class="line">    stopSignal &lt;- <span class="constant">true</span></div><div class="line">    stopSignal = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>,<span class="number"> 1</span>) <span class="comment">// just a hack to avoid multi UnRegister deadlock</span></div><div class="line">    <span class="keyword">var</span> err error;</div><div class="line">    <span class="keyword">if</span> _, err := client.Delete(context.Background(), serviceKey); err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"grpclb: deregister '%s' failed: %s"</span>, serviceKey, err.Error())</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        log.Printf(<span class="string">"grpclb: deregister '%s' ok."</span>, serviceKey)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="4）接口描述文件：helloworld-proto">4）接口描述文件：helloworld.proto</h5>
<figure class="highlight protobuf"><figcaption><span>helloworld.proto</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">syntax = "proto3";</div><div class="line"></div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = "com.midea.jr.test.grpc";</div><div class="line">option java_outer_classname = "HelloWorldProto";</div><div class="line">option objc_class_prefix = "HLW";</div><div class="line"></div><div class="line">package helloworld;</div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter {</div><div class="line">    //   Sends a greeting</div><div class="line">    rpc SayHello (HelloRequest) returns (HelloReply) {</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">// The request message containing the user's name.</div><div class="line">message HelloRequest {</div><div class="line">    string name = 1;</div><div class="line">}</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply {</div><div class="line">    string message = 1;</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="5）实现服务端接口：helloworldserver-go">5）实现服务端接口：helloworldserver.go</h5>
<figure class="highlight go"><figcaption><span>helloworldserver.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"flag"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"os/signal"</span></div><div class="line">    <span class="string">"syscall"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc"</span></div><div class="line"></div><div class="line">    grpclb <span class="string">"com.midea/jr/grpclb/naming/etcd/v3"</span></div><div class="line">    <span class="string">"com.midea/jr/grpclb/example/pb"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    serv = flag.String(<span class="string">"service"</span>, <span class="string">"hello_service"</span>, <span class="string">"service name"</span>)</div><div class="line">    port = flag.Int(<span class="string">"port"</span>,<span class="number"> 50001</span>, <span class="string">"listening port"</span>)</div><div class="line">    reg = flag.String(<span class="string">"reg"</span>, <span class="string">"http://127.0.0.1:2379"</span>, <span class="string">"register etcd address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    flag.Parse()</div><div class="line"></div><div class="line">    lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">"0.0.0.0:%d"</span>, *port))</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    err = grpclb.Register(*serv, <span class="string">"127.0.0.1"</span>, *port, *reg, time.Second<span class="number">*10</span>,<span class="number"> 15</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">    signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGHUP, syscall.SIGQUIT)</div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        s := &lt;-ch</div><div class="line">        log.Printf(<span class="string">"receive signal '%v'"</span>, s)</div><div class="line">        grpclb.UnRegister()</div><div class="line">        os.Exit<span class="number">(1</span>)</div><div class="line">    }()</div><div class="line"></div><div class="line">    log.Printf(<span class="string">"starting hello service at %d"</span>, *port)</div><div class="line">    s := grpc.NewServer()</div><div class="line">    pb.RegisterGreeterServer(s, &server{})</div><div class="line">    s.Serve(lis)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></div><div class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></div><div class="line"><span class="keyword">func</span> (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {</div><div class="line">    fmt.Printf(<span class="string">"%v: Receive is %s\n"</span>, time.Now(), in.Name)</div><div class="line">    <span class="keyword">return</span> &pb.HelloReply{Message: <span class="string">"Hello "</span> + in.Name}, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="6）实现客户端接口：helloworldclient-go">6）实现客户端接口：helloworldclient.go</h5>
<figure class="highlight go"><figcaption><span>helloworldclient.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"flag"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    grpclb <span class="string">"com.midea/jr/grpclb/naming/etcd/v3"</span></div><div class="line">    <span class="string">"com.midea/jr/grpclb/example/pb"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc"</span></div><div class="line">    <span class="string">"strconv"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    serv = flag.String(<span class="string">"service"</span>, <span class="string">"hello_service"</span>, <span class="string">"service name"</span>)</div><div class="line">    reg = flag.String(<span class="string">"reg"</span>, <span class="string">"http://127.0.0.1:2379"</span>, <span class="string">"register etcd address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    flag.Parse()</div><div class="line">    r := grpclb.NewResolver(*serv)</div><div class="line">    b := grpc.RoundRobin(r)</div><div class="line"></div><div class="line">    ctx, _ := context.WithTimeout(context.Background(),<span class="number"> 10</span>*time.Second)</div><div class="line">    conn, err := grpc.DialContext(ctx, *reg, grpc.WithInsecure(), grpc.WithBalancer(b))</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    ticker := time.NewTicker<span class="number">(1</span> * time.Second)</div><div class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C {</div><div class="line">        client := pb.NewGreeterClient(conn)</div><div class="line">        resp, err := client.SayHello(context.Background(), &pb.HelloRequest{Name: <span class="string">"world "</span> + strconv.Itoa(t.Second())})</div><div class="line">        <span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">            fmt.Printf(<span class="string">"%v: Reply is %s\n"</span>, t, resp.Message)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h5 id="7）运行测试">7）运行测试</h5>
<p>1、运行3个服务端S1、S2、S3，1个客户端C，观察各服务端接收的请求数是否相等？<br><img src="5.png" alt=""></p>
<p>2、关闭1个服务端S1，观察请求是否会转移到另外2个服务端？<br><img src="6.png" alt=""></p>
<p>3、重新启动S1服务端，观察另外2个服务端请求是否会平均分配到S1？<br><img src="7.png" alt=""><br><img src="8.png" alt=""></p>
<p>4、关闭Etcd3服务器，观察客户端与服务端通信是否正常？ 关闭通信仍然正常，但新服务端不会注册进来，服务端掉线了也无法摘除掉。</p>
<p>5、重新启动Etcd3服务器，服务端上下线可自动恢复正常。</p>
<p>6、关闭所有服务端，客户端请求将被阻塞。</p>
<h4 id="参考">参考</h4>
<ol>
<li><a href="http://www.grpc.io/docs/" target="_blank" rel="external">http://www.grpc.io/docs/</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md" target="_blank" rel="external">https://github.com/grpc/grpc/blob/master/doc/load-balancing.md</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文出处: <a href="https://segmentfault.com/a/1190000008672912" target="_blank" rel="external">gRPC服务发现&amp;负载均衡</a>, 作者: <a href="https://segmentfault.com/u/softfn" target="_blank" rel="external">softfn</a>。</p>
<p>构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：</p>
]]>
    
    </summary>
    
      <category term="gRPC" scheme="http://colobu.com/tags/gRPC/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Go Slice 秘籍]]></title>
    <link href="http://colobu.com/2017/03/22/Slice-Tricks/"/>
    <id>http://colobu.com/2017/03/22/Slice-Tricks/</id>
    <published>2017-03-22T11:50:03.000Z</published>
    <updated>2017-03-22T12:17:19.000Z</updated>
    <content type="html"><![CDATA[<p>这是 Golang官方的一个总结: <a href="https://github.com/golang/go/wiki/SliceTricks" target="_blank" rel="external">SliceTricks</a></p>
<p>由于引入了内建的<code>append</code>的方法， 包<code>container/vector</code>的很多方法都被移除了，可以被内建的<code>append</code>和<code>copy</code>方法代替。</p>
<p>下面是栈vector的操作方法的实现，使用slice实现相关的操作。<br><a id="more"></a></p>
<h3 id="AppendVector">AppendVector</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a, b...)</div></pre></td></tr></table></figure>

<h3 id="Copy">Copy</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</div><div class="line"><span class="built_in">copy</span>(b, a)</div><div class="line"><span class="comment">// 如果a不为空，也可以用下面的方式</span></div><div class="line">b = <span class="built_in">append</span>([]T(<span class="constant">nil</span>), a...)</div></pre></td></tr></table></figure>

<h3 id="Cut">Cut</h3>
<p>切掉一段数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</div></pre></td></tr></table></figure>

<h3 id="Delete">Delete</h3>
<p>删除一个元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], a[i<span class="number">+1</span>:]...)</div><div class="line"><span class="comment">// or</span></div><div class="line">a = a[:i+<span class="built_in">copy</span>(a[i:], a[i<span class="number">+1</span>:])]</div></pre></td></tr></table></figure>

<h3 id="Delete，但不保持原来顺序">Delete，但不保持原来顺序</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a[i] = a[<span class="built_in">len</span>(a<span class="number">)-1</span>] </div><div class="line">a = a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<p><strong>注意</strong>:如果元素是一个指针，或者是一个包含指针字段的struct，上面的<code>cut</code>、<code>delete</code>实现可能会有潜在的内存泄漏的问题。一些元素的值可能会被<code>a</code>一直引用而不被释放，下面的代码可以解决这个问题。</p>
<blockquote>
<h3 id="Cut-1">Cut</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">copy</span>(a[i:], a[j:])</div><div class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ {</div><div class="line">	a[k] = <span class="constant">nil</span> <span class="comment">// or the zero value of T</span></div><div class="line">}</div><div class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</div></pre></td></tr></table></figure>



<blockquote>
<h3 id="Delete-1">Delete</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">copy</span>(a[i:], a[i<span class="number">+1</span>:])</div><div class="line">a[<span class="built_in">len</span>(a<span class="number">)-1</span>] = <span class="constant">nil</span> <span class="comment">// or the zero value of T</span></div><div class="line">a = a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<blockquote>
<h3 id="Delete，但不保持原来顺序-1">Delete，但不保持原来顺序</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[i] = a[<span class="built_in">len</span>(a<span class="number">)-1</span>]</div><div class="line">a[<span class="built_in">len</span>(a<span class="number">)-1</span>] = <span class="constant">nil</span></div><div class="line">a = a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<h3 id="Expand">Expand</h3>
<p>插入一段到中间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(<span class="built_in">make</span>([]T, j), a[i:]...)...)</div></pre></td></tr></table></figure>

<h3 id="Extend">Extend</h3>
<p>插入一段到尾部</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a, <span class="built_in">make</span>([]T, j)...)</div></pre></td></tr></table></figure>

<h3 id="Insert">Insert</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T{x}, a[i:]...)...)</div></pre></td></tr></table></figure>

<p><strong>注意</strong>: 第二个<code>append</code>会使用它底层的存储创建一个新的slice，然后复制<code>a[i:]</code>到这个slice,然后把这个slice再复制回<code>s</code>。 新的slice的创建和第二次copy可以使用下面的方式来避免：</p>
<blockquote>
<h3 id="Insert-1">Insert</h3>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = <span class="built_in">append</span>(s,<span class="number"> 0</span>)</div><div class="line"><span class="built_in">copy</span>(s[i<span class="number">+1</span>:], s[i:])</div><div class="line">s[i] = x</div></pre></td></tr></table></figure>

<h3 id="InsertVector">InsertVector</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(b, a[i:]...)...)</div></pre></td></tr></table></figure>

<h3 id="Pop">Pop</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x, a = a[<span class="built_in">len</span>(a<span class="number">)-1</span>], a[:<span class="built_in">len</span>(a<span class="number">)-1</span>]</div></pre></td></tr></table></figure>

<h3 id="Push">Push</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>(a, x)</div></pre></td></tr></table></figure>

<h3 id="Shift">Shift</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x, a := a<span class="number">[0</span>], a<span class="number">[1</span>:]</div></pre></td></tr></table></figure>

<h3 id="Unshift">Unshift</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = <span class="built_in">append</span>([]T{x}, a...)</div></pre></td></tr></table></figure>

<h2 id="其它技巧">其它技巧</h2>
<h3 id="无额外对象分配的filter">无额外对象分配的filter</h3>
<p>这个技巧利用了slice会共享它的底层的数据存储和容量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b := a[<span class="number">:0</span>]</div><div class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a {</div><div class="line">	<span class="keyword">if</span> f(x) {</div><div class="line">		b = <span class="built_in">append</span>(b, x)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="反转">反转</h3>
<p>将slice中的元素反转。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)<span class="number">/2</span><span class="number">-1</span>; i &gt;=<span class="number"> 0</span>; i-- {</div><div class="line">	opp := <span class="built_in">len</span>(a<span class="number">)-1</span>-i</div><div class="line">	a[i], a[opp] = a[opp], a[i]</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的代码类似，只不过使用了两个索引变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> left, right :=<span class="number"> 0</span>, <span class="built_in">len</span>(a<span class="number">)-1</span>; left &lt; right; left, right = left<span class="number">+1</span>, right<span class="number">-1</span> {</div><div class="line">	a[left], a[right] = a[right], a[left]</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这是 Golang官方的一个总结: <a href="https://github.com/golang/go/wiki/SliceTricks" target="_blank" rel="external">SliceTricks</a></p>
<p>由于引入了内建的<code>append</code>的方法， 包<code>container/vector</code>的很多方法都被移除了，可以被内建的<code>append</code>和<code>copy</code>方法代替。</p>
<p>下面是栈vector的操作方法的实现，使用slice实现相关的操作。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Protobuf3 语法指南]]></title>
    <link href="http://colobu.com/2017/03/16/Protobuf3-language-guide/"/>
    <id>http://colobu.com/2017/03/16/Protobuf3-language-guide/</id>
    <published>2017-03-16T04:59:21.000Z</published>
    <updated>2017-03-16T11:52:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/logos/protobuf.png" alt=""></p>
<p>以前我翻译了 <a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">Protobuf2 语法指南</a>，现在 <a href="http://blog.csdn.net/u011518120" target="_blank" rel="external">千念飞羽</a>把protobuf3的语法指南也翻译了，我也转载一下，读者可以有个参考。 译文地址是: <a href="http://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="external">Protobuf3语言指南</a>。</p>
<a id="more"></a>
<blockquote>
<p>英文原文：<br><a href="https://developers.google.com/protocol-buffers/docs/proto3?hl=zh-cn#generating" target="_blank" rel="external">Language Guide (proto3)</a><br>中文出处：<br><a href="http://www.open-open.com/home/space.php?uid=37924&amp;do=blog&amp;id=5873" target="_blank" rel="external">Protobuf语言指南</a><br><a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">[译]Protobuf 语法指南</a><br>中文出处是proto2的译文，proto3的英文出现后在原来基础上增改了，水平有限，还请指正</p>
</blockquote>
<p>这个指南描述了如何使用Protocol buffer 语言去描述你的protocol buffer 数据， 包括 .proto文件符号和如何从.proto文件生成类。包含了proto2版本的protocol buffer语言：对于老版本的proto3 符号，请见<a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn" target="_blank" rel="external">Proto2 Language Guide</a>（以及<a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">中文译本</a>，抄了很多这里的感谢下老版本的翻译者）</p>
<p>本文是一个参考指南——如果要查看如何使用本文中描述的多个特性的循序渐进的例子，请在教程中查找需要的语言的教程。</p>
<h2 id="定义一个消息类型">定义一个消息类型</h2>
<p>先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">syntax = <span class="string">"proto3"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。这个指定语法行必须是文件的非空非注释的第一个行。</li>
<li>SearchRequest消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。</li>
</ul>
<h3 id="指定字段类型">指定字段类型</h3>
<p>在上面的例子中，所有字段都是标量类型：两个整型（page_number和result_per_page），一个string类型（query）。当然，你也可以为字段指定其他的合成类型，包括枚举（enumerations）或其他消息类型。</p>
<h3 id="分配标识号">分配标识号</h3>
<p>正如你所见，在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p>
<p>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]（ (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)）的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。</p>
<h3 id="指定字段规则">指定字段规则</h3>
<p>所指定的消息字段修饰符必须是如下之一：</p>
<ul>
<li>singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。</li>
<li>repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。</li>
</ul>
<p>在proto3中，repeated的标量域默认情况虾使用packed。</p>
<p>你可以了解更多的pakced属性在<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn#packed" target="_blank" rel="external">Protocol Buffer 编码</a></p>
<h3 id="添加更多消息类型">添加更多消息类型</h3>
<p>在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line"> ...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="添加注释">添加注释</h3>
<p>向.proto文件添加注释，可以使用C/C++/Java风格的双斜杠（//） 语法格式，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="保留标识符（Reserved）">保留标识符（Reserved）</h3>
<p>如果你通过删除或者注释所有域，以后的用户在更新这个类型的时候可能重用这些标识号。如果你使用旧版本加载相同的.proto文件会导致严重的问题，包括数据损坏、隐私错误等等。现在有一种确保不会发生这种情况的方法就是为字段tag（reserved name可能会JSON序列化的问题）指定<code>reserved</code>标识符，protocol buffer的编译器会警告未来尝试使用这些域标识符的用户。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>{</div><div class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</div><div class="line">  reserved <span class="string">"foo"</span>, <span class="string">"bar"</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注：不要在同一行reserved声明中同时声明域名字和tag number。</p>
<h3 id="从-proto文件生成了什么？">从.proto文件生成了什么？</h3>
<p>当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。</p>
<ul>
<li>对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。</li>
<li>对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。</li>
<li>对go来说，编译器会位每个消息类型生成了一个.pd.go文件。</li>
<li>对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。</li>
<li>javaNano来说，编译器输出类似域java但是没有Builder类</li>
<li>对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。</li>
<li>对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。<br>你可以从如下的文档链接中获取每种语言更多API(proto3版本的内容很快就公布)。<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API Reference</a></li>
</ul>
<h2 id="标量数值类型">标量数值类型</h2>
<p>一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：</p>
<table><thead><tr><th>.proto Type</th><th align="center">Notes</th><th align="right">C++ Type</th><th>Java Type</th><th>Python Type[2]</th><th>Go Type</th><th>Ruby Type</th><th>C# Type</th><th>PHP Type</th></tr></thead><tbody><tr><td>double</td><td align="center"></td><td align="right">double</td><td>double</td><td>float</td><td>float64</td><td>Float</td><td>double</td><td>float</td></tr><tr><td>float</td><td align="center"></td><td align="right">float</td><td>float</td><td>float</td><td>float32</td><td>Float</td><td>float</td><td>float</td></tr><tr><td>int32</td><td align="center">使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td><td align="right">int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr><tr><td>uint32</td><td align="center">使用变长编码</td><td align="right">uint32</td><td>int</td><td>int/long</td><td>uint32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>uint</td><td>integer</td></tr><tr><td>uint64</td><td align="center">使用变长编码</td><td align="right">uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string</td></tr><tr><td>sint32</td><td align="center">使用变长编码，这些编码在负值时比int32高效的多</td><td align="right">int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr><tr><td>sint64</td><td align="center">使用变长编码，有符号的整型值。编码时比通常的int64高效。</td><td align="right">int64</td><td>long</td><td>int/long</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string</td></tr><tr><td>fixed32</td><td align="center">总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td><td align="right">uint32</td><td>int</td><td>int</td><td>uint32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>uint</td><td>integer</td></tr><tr><td>fixed64</td><td align="center">总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td><td align="right">uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string</td></tr><tr><td>sfixed32</td><td align="center">总是4个字节</td><td align="right">int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr><tr><td>sfixed64</td><td align="center">总是8个字节</td><td align="right">int64</td><td>long</td><td>int/long</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string</td></tr><tr><td>bool</td><td align="center"></td><td align="right">bool</td><td>boolean</td><td>bool</td><td>bool</td><td>TrueClass/FalseClass</td><td>bool</td><td>boolean</td></tr><tr><td>string</td><td align="center">一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td><td align="right">string</td><td>String</td><td>str/unicode</td><td>string</td><td>String (UTF-8)</td><td>string</td><td>string</td></tr><tr><td>bytes</td><td align="center">可能包含任意顺序的字节数据。</td><td align="right">string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>String (ASCII-8BIT)</td><td>ByteString</td><td>string</td></tr></tbody></table>


<p>你可以在文章<a href="https://developers.google.com/protocol-buffers/docs/encoding?hl=zh-cn" target="_blank" rel="external">Protocol Buffer 编码</a>中，找到更多“序列化消息时各种类型如何编码”的信息。</p>
<ol>
<li>在java中，无符号32位和64位整型被表示成他们的整型对应形式，最高位被储存在标志位中。</li>
<li>对于所有的情况，设定值会执行类型检查以确保此值是有效。</li>
<li>64位或者无符号32位整型在解码时被表示成为ilong，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。</li>
<li>python中string被表示成在解码时表示成unicode。但是一个ASCIIstring可以被表示成str类型。</li>
<li>Integer在64位的机器上使用，string在32位机器上使用</li>
</ol>
<h2 id="默认值">默认值</h2>
<p>当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：</p>
<ul>
<li>对于string，默认是一个空string</li>
<li>对于bytes，默认是一个空的bytes</li>
<li>对于bool，默认是false</li>
<li>对于数值类型，默认是0</li>
<li>对于枚举，默认是第一个定义的枚举值，必须为0;</li>
<li>对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide</li>
</ul>
<p>对于可重复域的默认值是空（通常情况下是对应语言中空列表）。</p>
<p><em>注：对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值（例如，例如boolean值是否被设置为false）还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息域被设置为标志位，这个值不应该被序列化传输。</em></p>
<p>查看<a href="https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn" target="_blank" rel="external">generated code guide</a>选择你的语言的默认值的工作细节。</p>
<h2 id="枚举">枚举</h2>
<p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。</p>
<p>在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>{</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>{</div><div class="line"><span class="constant">    UNIVERSAL</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">    WEB</span> = <span class="number">1</span>;</div><div class="line"><span class="constant">    IMAGES</span> = <span class="number">2</span>;</div><div class="line"><span class="constant">    LOCAL</span> = <span class="number">3</span>;</div><div class="line"><span class="constant">    NEWS</span> = <span class="number">4</span>;</div><div class="line"><span class="constant">    PRODUCTS</span> = <span class="number">5</span>;</div><div class="line"><span class="constant">    VIDEO</span> = <span class="number">6</span>;</div><div class="line">  }</div><div class="line"><span class="constant">  Corpus corpus</span> = <span class="number">4</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如你所见，Corpus枚举的第一个常量映射为0：每个枚举类型必须将其第一个类型映射为0，这是因为：</p>
<ul>
<li>必须有有一个0值，我们可以用这个0值作为默认值。</li>
<li>这个零值必须为第一个元素，为了兼容proto2语义，枚举类的第一个值总是默认值。</li>
</ul>
<p>你可以通过将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true，否则编译器会在别名的地方产生一个错误信息。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAllowingAlias</span> </span>{</div><div class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</div><div class="line"><span class="constant">  UNKNOWN</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">  STARTED</span> = <span class="number">1</span>;</div><div class="line"><span class="constant">  RUNNING</span> = <span class="number">1</span>;</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> </span>{</div><div class="line"><span class="constant">  UNKNOWN</span> = <span class="number">0</span>;</div><div class="line"><span class="constant">  STARTED</span> = <span class="number">1</span>;</div><div class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>
<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。</p>
<p>关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference/overview.html" target="_blank" rel="external">generated code guide</a>。</p>
<h2 id="使用其他消息类型">使用其他消息类型</h2>
<p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</div><div class="line">  <span class="built_in">string</span> url = <span class="number">1</span>;</div><div class="line">  <span class="built_in">string</span> title = <span class="number">2</span>;</div><div class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="导入定义">导入定义</h3>
<p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</div></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是新的proto</span></div><div class="line"><span class="comment">// All definitions are moved here</span></div></pre></td></tr></table></figure>



<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是久的proto</span></div><div class="line"><span class="comment">// 这是所有客户端正在导入的包</span></div><div class="line"><span class="keyword">import</span> public <span class="string">"new.proto"</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">"other.proto"</span>;</div></pre></td></tr></table></figure>



<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端proto</span></div><div class="line"><span class="keyword">import</span> <span class="string">"old.proto"</span>;</div><div class="line"><span class="comment">// 现在你可以使用新旧两种包的proto定义了。</span></div></pre></td></tr></table></figure>

<p>通过在编译器命令行参数中使用-I/--proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。</p>
<h3 id="使用proto2消息类型">使用proto2消息类型</h3>
<p>在你的proto3消息中导入proto2的消息类型也是可以的，反之亦然，然后proto2枚举不可以直接在proto3的标识符中使用（如果仅仅在proto2消息中使用是可以的）。</p>
<h2 id="嵌套类型">嵌套类型</h2>
<p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>{</div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>{</div><div class="line">    <span class="built_in">string</span> url = <span class="number">1</span>;</div><div class="line">    <span class="built_in">string</span> title = <span class="number">2</span>;</div><div class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SomeOtherMessage</span> </span>{</div><div class="line"><span class="constant">  SearchResponse.Result result</span> = <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>{                  <span class="comment">// Level 0</span></div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>{  <span class="comment">// Level 1</span></div><div class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></div><div class="line">      <span class="built_in">int64</span> ival = <span class="number">1</span>;</div><div class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>{  <span class="comment">// Level 1</span></div><div class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>{   <span class="comment">// Level 2</span></div><div class="line">      <span class="built_in">int32</span> ival = <span class="number">1</span>;</div><div class="line">      <span class="built_in">bool</span>  booly = <span class="number">2</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="更新一个消息类型">更新一个消息类型</h2>
<p>如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。</p>
<ul>
<li>不要更改任何已有的字段的数值标识。</li>
<li>如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）</li>
<li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li>
<li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li>
<li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li>
<li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li>
<li>枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的</li>
</ul>
<h2 id="Any">Any</h2>
<p>Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入<code>import google/protobuf/any.proto</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/any.proto"</span>;</div><div class="line"></div><div class="line">message ErrorStatus {</div><div class="line">  <span class="typename">string</span> message =<span class="number"> 1</span>;</div><div class="line">  repeated google.protobuf.Any details =<span class="number"> 2</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于给定的消息类型的默认类型URL是type.googleapis.com/packagename.messagename。</p>
<p>不同语言的实现会支持动态库以线程安全的方式去帮助封装或者解封装Any值。例如在java中，Any类型会有特殊的<code>pack()</code>和<code>unpack()</code>访问器，在C++中会有<code>PackFrom()</code>和<code>UnpackTo()</code>方法。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></div><div class="line"><span class="constant">NetworkErrorDetails details</span> = ...;</div><div class="line"><span class="constant">ErrorStatus status;</span></div><div class="line">status.add_details()-&gt;PackFrom(details);</div><div class="line"></div><div class="line">// Reading an arbitrary message from Any.</div><div class="line">ErrorStatus status = ...;</div><div class="line">for (const Any& detail : status.details()) {</div><div class="line">  if (detail.Is&lt;NetworkErrorDetails&gt;()) {</div><div class="line"><span class="constant">    NetworkErrorDetails network_error;</span></div><div class="line">    detail.UnpackTo(&network_error);</div><div class="line">    ... processing network_error ...</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前，用于Any类型的动态库仍在开发之中<br>如果你已经很熟悉<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">proto2语法</a>，使用Any替换<a href="https://developers.google.com/protocol-buffers/docs/proto#extensions" target="_blank" rel="external">扩展</a>。</p>
<h2 id="Oneof">Oneof</h2>
<p>如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存.</p>
<p>Oneof字段就像可选字段， 除了它们会共享内存， 至多一个字段会被设置。 设置其中一个字段会清除其它字段。 你可以使用<code>case()</code>或者<code>WhichOneof()</code> 方法检查哪个oneof字段被设置， 看你使用什么语言了.</p>
<h3 id="使用Oneof">使用Oneof</h3>
<p>为了在.proto定义Oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>{</div><div class="line">  oneof test_oneof {</div><div class="line">    <span class="built_in">string</span> name = <span class="number">4</span>;</div><div class="line"><span class="constant">    SubMessage sub_message</span> = <span class="number">9</span>;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字.</p>
<p>在产生的代码中, oneof字段拥有同样的 getters 和setters， 就像正常的可选字段一样. 也有一个特殊的方法来检查到底那个字段被设置. 你可以在相应的语言<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API指南</a>中找到oneof API介绍.</p>
<h3 id="Oneof_特性">Oneof 特性</h3>
<ul>
<li>设置oneof会自动清楚其它oneof字段的值. 所以设置多次后，只有最后一次设置的字段有值.</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SampleMessage message;</span></div><div class="line">message.set_name("name");</div><div class="line">CHECK(message.has_name());</div><div class="line">message.mutable_sub_message();   // Will clear name field.</div><div class="line">CHECK(!message.has_name());</div></pre></td></tr></table></figure>

<ul>
<li>如果解析器遇到同一个oneof中有多个成员，只有最会一个会被解析成消息。</li>
<li>oneof不支持repeated.</li>
<li>反射API对oneof 字段有效.</li>
<li>如果使用C++,需确保代码不会导致内存泄漏. 下面的代码会崩溃， 因为sub_message 已经通过set_name()删除了</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SampleMessage message;</span></div><div class="line">SubMessage* sub_message = <span class="class"><span class="keyword">message</span>.<span class="title">mutable_sub_message</span>();</span></div><div class="line">message.set_name("name");      // Will delete sub_message</div><div class="line">sub_message-&gt;set_...            // Crashes here</div></pre></td></tr></table></figure>

<ul>
<li>在C++中，如果你使用Swap()两个oneof消息，每个消息，两个消息将拥有对方的值，例如在下面的例子中，msg1会拥有sub_message并且msg2会有name。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="constant">SampleMessage msg1;</span></div><div class="line">msg1.set_name("name");</div><div class="line">SampleMessage msg2;</div><div class="line">msg2.mutable_sub_message();</div><div class="line">msg1.swap(&msg2);</div><div class="line">CHECK(msg1.has_sub_message());</div><div class="line">CHECK(msg2.has_name());</div></pre></td></tr></table></figure>

<h3 id="向后兼容性问题">向后兼容性问题</h3>
<p>当增加或者删除oneof字段时一定要小心. 如果检查oneof的值返回None/NOT_SET, 它意味着oneof字段没有被赋值或者在一个不同的版本中赋值了。 你不会知道是哪种情况，因为没有办法判断如果未识别的字段是一个oneof字段。</p>
<p>Tag 重用问题：</p>
<ul>
<li><strong>将字段移入或移除oneof</strong>：在消息被序列号或者解析后，你也许会失去一些信息（有些字段也许会被清除）</li>
<li><strong>删除一个字段或者加入一个字段</strong>：在消息被序列号或者解析后，这也许会清除你现在设置的oneof字段</li>
<li><strong>分离或者融合oneof</strong>：行为与移动常规字段相似。</li>
</ul>
<h2 id="Map">Map</h2>
<p>如果你希望创建一个关联映射，protocol buffer提供了一种快捷的语法：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map&lt;key_type, value_type&gt; map_field = N;</div></pre></td></tr></table></figure>

<p>其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。</p>
<p>例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">3</span>;</div></pre></td></tr></table></figure>

<ul>
<li>Map的字段可以是repeated。</li>
<li>序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map</li>
<li>当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</li>
<li>从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</li>
</ul>
<p>生成map的API现在对于所有proto3支持的语言都可用了，你可以从<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API指南</a>找到更多信息。</p>
<h3 id="向后兼容性问题-1">向后兼容性问题</h3>
<p>map语法序列化后等同于如下内容，因此即使是不支持map语法的protocol buffer实现也是可以处理你的数据的：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">MapFieldEntry</span> </span>{</div><div class="line">  key_type key = <span class="number">1</span>;</div><div class="line">  value_type value = <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</div></pre></td></tr></table></figure>

<h2 id="Package">Package</h2>
<p>当然可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突。如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> foo.bar;</div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>{ ... }</div></pre></td></tr></table></figure>

<p>在其他的消息格式定义中可以使用包名+消息名的方式来定义域的类型，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message Foo {</div><div class="line">  ...</div><div class="line">  required foo.bar.Open open =<span class="number"> 1</span>;</div><div class="line">  ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>包的声明符会根据使用语言的不同影响生成的代码。</p>
<ul>
<li>对于C++，产生的类会被包装在C++的命名空间中，如上例中的Open会被封装在 foo::bar空间中； - 对于Java，包声明符会变为java的一个包，除非在.proto文件中提供了一个明确有java_package；</li>
<li>对于 Python，这个包声明符是被忽略的，因为Python模块是按照其在文件系统中的位置进行组织的。</li>
<li>对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。</li>
<li>对于Ruby，生成的类可以被包装在内置的Ruby名称空间中，转换成Ruby所需的大小写样式 （首字母大写；如果第一个符号不是一个字母，则使用PB_前缀），例如Open会在Foo::Bar名称空间中。</li>
<li>对于javaNano包会使用Java包，除非你在你的文件中显式的提供一个option java_package。</li>
<li>对于C#包可以转换为PascalCase后作为名称空间，除非你在你的文件中显式的提供一个option csharp_namespace，例如，Open会在Foo.Bar名称空间中</li>
</ul>
<h3 id="包及名称的解析">包及名称的解析</h3>
<p>Protocol buffer语言中类型名称的解析与C++是一致的：首先从最内部开始查找，依次向外进行，每个包会被看作是其父类包的内部类。当然对于 （foo.bar.Baz）这样以“.”分隔的意味着是从最外围开始的。</p>
<p>ProtocolBuffer编译器会解析.proto文件中定义的所有类型名。 对于不同语言的代码生成器会知道如何来指向每个具体的类型，即使它们使用了不同的规则。</p>
<h2 id="定义服务(Service)">定义服务(Service)</h2>
<p>如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>{</div><div class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最直观的使用protocol buffer的RPC系统是<a href="https://github.com/grpc/grpc-experiments" target="_blank" rel="external">gRPC</a>,一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。</p>
<p>如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从<a href="https://developers.google.com/protocol-buffers/docs/proto#services" target="_blank" rel="external">proto2语言指南</a>中找到更多信息</p>
<p>还有一些第三方开发的PRC实现使用Protocol Buffer。参考<a href="https://github.com/google/protobuf/blob/master/docs/third_party.md" target="_blank" rel="external">第三方插件wiki</a>查看这些实现的列表。</p>
<h2 id="JSON_映射">JSON 映射</h2>
<p>Proto3 支持JSON的编码规范，使他更容易在不同系统之间共享数据，在下表中逐个描述类型。</p>
<p>如果JSON编码的数据丢失或者其本身就是null，这个数据会在解析成protocol buffer的时候被表示成默认值。如果一个字段在protocol buffer中表示为默认值，体会在转化成JSON的时候编码的时候忽略掉以节省空间。具体实现可以提供在JSON编码中可选的默认值。</p>
<table><thead><tr><th>proto3</th><th>JSON</th><th>JSON示例</th><th>注意</th></tr></thead><tbody><tr><td>message</td><td>object</td><td>{“fBar”: v, “g”: null, …}</td><td>产生JSON对象，消息字段名可以被映射成lowerCamelCase形式，并且成为JSON对象键，null被接受并成为对应字段的默认值</td></tr><tr><td>enum</td><td>string</td><td>“FOO_BAR”</td><td>枚举值的名字在proto文件中被指定</td></tr><tr><td>map</td><td>object</td><td>{“k”: v, …}</td><td>所有的键都被转换成string</td></tr><tr><td>repeated V</td><td>array</td><td>[v, …]</td><td>null被视为空列表</td></tr><tr><td>bool</td><td>true, false</td><td>true, false</td><td></td></tr><tr><td>string</td><td>string</td><td>“Hello World!”</td><td></td></tr><tr><td>bytes</td><td>base64 string</td><td>“YWJjMTIzIT8kKiYoKSctPUB+”</td><td></td></tr><tr><td>int32, fixed32, uint32</td><td>number</td><td>1, -10, 0</td><td>JSON值会是一个十进制数，数值型或者string类型都会接受</td></tr><tr><td>int64, fixed64, uint64</td><td>string</td><td>“1”, “-10”</td><td>JSON值会是一个十进制数，数值型或者string类型都会接受</td></tr><tr><td>float, double</td><td>number</td><td>1.1, -10.0, 0, “NaN”, “Infinity”</td><td>JSON值会是一个数字或者一个指定的字符串如”NaN”,”infinity”或者”-Infinity”，数值型或者字符串都是可接受的，指数符号也可以接受</td></tr><tr><td>Any</td><td>object</td><td>{“@type”: “url”, “f”: v, … }</td><td>如果一个Any保留一个特上述的JSON映射，则它会转换成一个如下形式：<code>{&quot;@type&quot;: xxx, &quot;value&quot;: yyy}</code>否则，该值会被转换成一个JSON对象，<code>@type</code>字段会被插入所指定的确定的值</td></tr><tr><td>Timestamp</td><td>string</td><td>“1972-01-01T10:00:20.021Z”</td><td>使用RFC 339，其中生成的输出将始终是Z-归一化啊的，并且使用0，3，6或者9位小数</td></tr><tr><td>Duration</td><td>string</td><td>“1.000340012s”, “1s”</td><td>生成的输出总是0，3，6或者9位小数，具体依赖于所需要的精度，接受所有可以转换为纳秒级的精度</td></tr><tr><td>Struct</td><td>object</td><td>{ … }</td><td>任意的JSON对象，见struct.proto</td></tr><tr><td>Wrapper types</td><td>various types</td><td>2, “2”, “foo”, true, “true”, null, 0, …</td><td>包装器在JSON中的表示方式类似于基本类型，但是允许nulll，并且在转换的过程中保留null</td></tr><tr><td>FieldMask</td><td>string</td><td>“f.fooBar,h”</td><td>见fieldmask.proto</td></tr><tr><td>ListValue</td><td>array</td><td>[foo, bar, …]</td><td></td></tr><tr><td>Value</td><td>value</td><td></td><td>任意JSON值</td></tr><tr><td>NullValue</td><td>null</td><td></td><td>JSON null</td></tr></tbody></table>

<h2 id="选项">选项</h2>
<p>定义.proto文件时能够标注一系列的option。Option并不改变整个文件声明的含义，但却能够影响特定环境下处理方式。完整的可用选项可以在<code>google/protobuf/descriptor.proto</code>找到。</p>
<p>一些选项是文件级别的，意味着它可以作用于最外范围，不包含在任何消息内部、enum或服务定义中。一些选项是消息级别的，意味着它可以用在消息定义的内部。当然有些选项可以作用在域、enum类型、enum值、服务类型及服务方法中。到目前为止，并没有一种有效的选项能作用于所有的类型。</p>
<p>如下就是一些常用的选项：</p>
<ul>
<li>java_package (文件选项) :这个选项表明生成java类所在的包。如果在.proto文件中没有明确的声明java_package，就采用默认的包名。当然了，默认方式产生的 java包名并不是最好的方式，按照应用名称倒序方式进行排序的。如果不需要产生java代码，则该选项将不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> java_package = <span class="string">"com.example.foo"</span>;</div></pre></td></tr></table></figure>

<ul>
<li>java_outer_classname (文件选项): 该选项表明想要生成Java类的名称。如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"Ponycopter"</span>;</div></pre></td></tr></table></figure>

<ul>
<li>optimize_for(文件选项): 可以被设置为 SPEED, CODE_SIZE,或者LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成： <ul>
<li>SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</li>
<li>CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多， 但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的 应用中。</li>
<li>LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一 些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</li>
</ul>
</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</div></pre></td></tr></table></figure>

<ul>
<li>cc_enable_arenas(文件选项):对于C++产生的代码启用arena allocation</li>
<li>objc_class_prefix(文件选项):设置Objective-C类的前缀，添加到所有Objective-C从此.proto文件产生的类和枚举类型。没有默认值，所使用的前缀应该是苹果推荐的3-5个大写字符，注意2个字节的前缀是苹果所保留的。</li>
<li>deprecated(字段选项):如果设置为true则表示该字段已经被废弃，并且不应该在新的代码中使用。在大多数语言中没有实际的意义。在java中，这回变成@Deprecated注释，在未来，其他语言的代码生成器也许会在字标识符中产生废弃注释，废弃注释会在编译器尝试使用该字段时发出警告。如果字段没有被使用你也不希望有新用户使用它，尝试使用保留语句替换字段声明。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</div></pre></td></tr></table></figure>

<h3 id="自定义选项">自定义选项</h3>
<p>ProtocolBuffers允许自定义并使用选项。该功能应该属于一个高级特性，对于大部分人是用不到的。如果你的确希望创建自己的选项，请参看 Proto2 Language Guide。注意创建自定义选项使用了拓展，拓展只在proto3中可用。</p>
<h2 id="生成访问类">生成访问类</h2>
<p>可以通过定义好的.proto文件来生成Java,Python,C++, Ruby, JavaNano, Objective-C,或者C# 代码，需要基于.proto文件运行protocol buffer编译器protoc。如果你没有安装编译器，下载安装包并遵照README安装。对于Go,你还需要安装一个特殊的代码生成器插件。你可以通过GitHub上的protobuf库找到安装过程</p>
<p>通过如下方式调用protocol编译器：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</div></pre></td></tr></table></figure>

<ul>
<li>IMPORT_PATH声明了一个.proto文件所在的解析import具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以多次调用--proto_path，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是--proto_path的简化形式。</li>
<li>当然也可以提供一个或多个输出路径： <ul>
<li>--cpp_out 在目标目录DST_DIR中产生C++代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated" target="_blank" rel="external">C++代码生成参考</a>中查看更多。</li>
<li>--java_out 在目标目录DST_DIR中产生Java代码，可以在 <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="external">Java代码生成参考</a>中查看更多。</li>
<li>--python_out 在目标目录 DST_DIR 中产生Python代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated" target="_blank" rel="external">Python代码生成参考</a>中查看更多。</li>
<li>--go_out 在目标目录 DST_DIR 中产生Go代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" target="_blank" rel="external">GO代码生成参考</a>中查看更多。</li>
<li>--ruby_out在目标目录 DST_DIR 中产生Ruby代码，参考正在制作中。</li>
<li>--javanano_out在目标目录DST_DIR中生成JavaNano，JavaNano代码生成器有一系列的选项用于定制自定义生成器的输出：你可以通过生成器的<a href="https://github.com/google/protobuf/tree/master/javanano" target="_blank" rel="external">README</a>查找更多信息，JavaNano参考正在制作中。</li>
<li>--objc_out在目标目录DST_DIR中产生Object代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/objective-c-generated" target="_blank" rel="external">Objective-C代码生成参考</a>中查看更多。</li>
<li>--csharp_out在目标目录DST_DIR中产生Object代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/csharp-generated" target="_blank" rel="external">C#代码生成参考</a>中查看更多。</li>
<li>--php_out在目标目录DST_DIR中产生Object代码，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/php-generated" target="_blank" rel="external">PHP代码生成参考</a>中查看更多。</li>
</ul>
</li>
</ul>
<p>作为一个方便的拓展，如果DST_DIR以.zip或者.jar结尾，编译器会将输出写到一个ZIP格式文件或者符合JAR标准的.jar文件中。注意如果输出已经存在则会被覆盖，编译器还没有智能到可以追加文件。 </p>
<ul>
<li>你必须提议一个或多个.proto文件作为输入，多个.proto文件可以只指定一次。虽然文件路径是相对于当前目录的，每个文件必须位于其IMPORT_PATH下，以便每个文件可以确定其规范的名称。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/logos/protobuf.png" alt=""></p>
<p>以前我翻译了 <a href="http://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="external">Protobuf2 语法指南</a>，现在 <a href="http://blog.csdn.net/u011518120" target="_blank" rel="external">千念飞羽</a>把protobuf3的语法指南也翻译了，我也转载一下，读者可以有个参考。 译文地址是: <a href="http://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="external">Protobuf3语言指南</a>。</p>
]]>
    
    </summary>
    
      <category term="protobuf" scheme="http://colobu.com/tags/protobuf/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为 Go Mutex 实现 TryLock 方法]]></title>
    <link href="http://colobu.com/2017/03/09/implement-TryLock-in-Go/"/>
    <id>http://colobu.com/2017/03/09/implement-TryLock-in-Go/</id>
    <published>2017-03-09T07:31:15.000Z</published>
    <updated>2017-03-09T09:49:54.000Z</updated>
    <content type="html"><![CDATA[<p>Go标准库的<code>sync/Mutex</code>、<code>RWMutex</code>实现了<code>sync/Locker</code>接口， 提供了<code>Lock()</code>和<code>UnLock()</code>方法，可以获取锁和释放锁，我们可以方便的使用它来控制我们对共享资源的并发控制上。</p>
<p>但是标准库中的<code>Mutex.Lock</code>的锁被获取后，如果在未释放之前再调用<code>Lock</code>则会被阻塞住，这种设计在有些情况下可能不能满足我的需求。有时候我们想尝试获取锁，如果获取到了，没问题继续执行，如果获取不到，我们不想阻塞住，而是去调用其它的逻辑，这个时候我们就想要<code>TryLock</code>方法了。</p>
<p>虽然很早(13年)就有人给Go开发组提需求了，但是这个请求并没有纳入官方库中，最终在官方库的清理中被关闭了，也就是官方库目前不会添加这个方法。<br><a id="more"></a></p>
<p>顺便说一句， <code>sync/Mutex</code>的源代码实现可以访问<a href="https://golang.org/src/sync/mutex.go" target="_blank" rel="external">这里</a>，它应该是实现了一种自旋(spin)加休眠的方式实现， 有兴趣的读者可以阅读源码，或者阅读相关的文章，比如 <a href="http://www.pydevops.com/2016/11/21/go-mutex-源码剖析/" target="_blank" rel="external">Go Mutex 源码剖析</a>。这不是本文要介绍的内容，读者可以找一些资料来阅读。</p>
<p>好了，转入正题，看看几种实现<code>TryLock</code>的方式吧。</p>
<h3 id="使用_unsafe_操作指针">使用 <code>unsafe</code> 操作指针</h3>
<p>如果你查看<code>sync/Mutex</code>的代码，会发现<code>Mutext</code>的数据结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	state <span class="typename">int32</span></div><div class="line">	sema  <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它使用<code>state</code>这个32位的整数来标记锁的占用，所以我们可以使用<code>CAS</code>来尝试获取锁。</p>
<p>代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mutexLocked =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.Mutex)),<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用起来和标准库的<code>Mutex</code>用法一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> m Mutex</div><div class="line"></div><div class="line">	m.Lock()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		m.Lock()</div><div class="line">	}()</div><div class="line"></div><div class="line">	time.Sleep(time.Second)</div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//false</span></div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">// false</span></div><div class="line">	m.Unlock()</div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//true</span></div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//false</span></div><div class="line">	m.Unlock()</div><div class="line">	fmt.Printf(<span class="string">"TryLock: %t\n"</span>, m.TryLock()) <span class="comment">//true</span></div><div class="line">	m.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>TryLock</code>不是检查锁的状态，而是<strong>尝试获取</strong>锁，所以<code>TryLock</code>返回true的时候事实上这个锁已经被获取了。</p>
<h3 id="实现自旋锁">实现自旋锁</h3>
<p>上面一节给了我们启发，利用 <code>uint32</code>和<code>CAS</code>操作我们可以一个自定义的锁:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SpinLock <span class="keyword">struct</span> {</div><div class="line">	f <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *SpinLock) Lock() {</div><div class="line">	<span class="keyword">for</span> !sl.TryLock() {</div><div class="line">		runtime.Gosched()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *SpinLock) Unlock() {</div><div class="line">	atomic.StoreUint32(&sl.f,<span class="number"> 0</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *SpinLock) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapUint32(&sl.f,<span class="number"> 0</span>,<span class="number"> 1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整体来看，它好像是标准库的一个精简版，没有休眠和唤醒的功能。</p>
<p>当然这个自旋锁可以在大并发的情况下CPU的占用率可能比较高，这是因为它的<code>Lock</code>方法使用了自旋的方式，如果别人没有释放锁，这个循环会一直执行，速度可能更快但CPU占用率高。</p>
<p>当然这个版本还可以进一步的优化，尤其是在复制的时候。下面是一个优化的版本:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> spinLock <span class="typename">uint32</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *spinLock) Lock() {</div><div class="line">	<span class="keyword">for</span> !atomic.CompareAndSwapUint32((*<span class="typename">uint32</span>)(sl),<span class="number"> 0</span>,<span class="number"> 1</span>) {</div><div class="line">		runtime.Gosched() <span class="comment">//without this it locks up on GOMAXPROCS &gt; 1</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *spinLock) Unlock() {</div><div class="line">	atomic.StoreUint32((*<span class="typename">uint32</span>)(sl),<span class="number"> 0</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (sl *spinLock) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapUint32((*<span class="typename">uint32</span>)(sl),<span class="number"> 0</span>,<span class="number"> 1</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> SpinLock() sync.Locker {</div><div class="line">	<span class="keyword">var</span> lock spinLock</div><div class="line">	<span class="keyword">return</span> &lock</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用_channel_实现">使用 channel 实现</h3>
<p>另一种方式是使用channel:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ChanMutex <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *ChanMutex) Lock() {</div><div class="line">	ch := (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(*m)</div><div class="line">	ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *ChanMutex) Unlock() {</div><div class="line">	ch := (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(*m)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-ch:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *ChanMutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	ch := (<span class="keyword">chan</span> <span class="keyword">struct</span>{})(*m)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>有兴趣的同学可以关注我的同事写的库 <a href="https://github.com/lrita/gosync" target="_blank" rel="external">lrita/gosync</a>。</p>
<h3 id="性能比较">性能比较</h3>
<p>首先看看上面三种方式和标准库中的<code>Mutex</code>、<code>RWMutex</code>的<code>Lock</code>和<code>Unlock</code>的性能比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BenchmarkMutex_LockUnlock<span class="number">-4</span>         <span class="number">	100000000</span>	       <span class="number"> 16.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkRWMutex_LockUnlock<span class="number">-4</span>       <span class="number">	50000000</span>	       <span class="number"> 36.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkUnsafeMutex_LockUnlock<span class="number">-4</span>   <span class="number">	100000000</span>	       <span class="number"> 16.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkChannMutex_LockUnlock<span class="number">-4</span>    <span class="number">	20000000</span>	       <span class="number"> 65.6</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkSpinLock_LockUnlock<span class="number">-4</span>      <span class="number">	100000000</span>	       <span class="number"> 18.6</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<p>可以看到单线程(goroutine)的情况下｀spinlock｀并没有比标准库好多少，反而差一点,并发测试的情况比较好，如下表中显示，这是符合预期的。</p>
<p><code>unsafe</code>方式和标准库差不多。</p>
<p><code>channel</code>方式的性能就比较差了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BenchmarkMutex_LockUnlock_C<span class="number">-4</span>         <span class="number">	20000000</span>	       <span class="number"> 75.3</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkRWMutex_LockUnlock_C<span class="number">-4</span>       <span class="number">	20000000</span>	      <span class="number"> 100</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkUnsafeMutex_LockUnlock_C<span class="number">-4</span>   <span class="number">	20000000</span>	       <span class="number"> 75.3</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkChannMutex_LockUnlock_C<span class="number">-4</span>    <span class="number">	10000000</span>	      <span class="number"> 231</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkSpinLock_LockUnlock_C<span class="number">-4</span>      <span class="number">	50000000</span>	       <span class="number"> 32.3</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<p>再看看三种实现<code>TryLock</code>方法的锁的性能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BenchmarkUnsafeMutex_Trylock<span class="number">-4</span>        <span class="number">	50000000</span>	       <span class="number"> 34.0</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkChannMutex_Trylock<span class="number">-4</span>         <span class="number">	20000000</span>	       <span class="number"> 83.8</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div><div class="line">BenchmarkSpinLock_Trylock<span class="number">-4</span>           <span class="number">	50000000</span>	       <span class="number"> 30.9</span> ns/op	      <span class="number"> 0</span> B/op	      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<p>本文参考了下面的文章和开源项目：</p>
<ol>
<li><a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">https://github.com/golang/go/issues/6123</a></li>
<li><a href="https://github.com/LK4D4/trylock/blob/master/trylock.go" target="_blank" rel="external">https://github.com/LK4D4/trylock/blob/master/trylock.go</a></li>
<li><a href="https://github.com/OneOfOne/go-utils/blob/master/sync/spinlock.go" target="_blank" rel="external">https://github.com/OneOfOne/go-utils/blob/master/sync/spinlock.go</a></li>
<li><a href="http://codereview.stackexchange.com/questions/60332/is-my-spin-lock-implementation-correct" target="_blank" rel="external">http://codereview.stackexchange.com/questions/60332/is-my-spin-lock-implementation-correct</a></li>
<li><a href="https://github.com/lrita/gosync" target="_blank" rel="external">https://github.com/lrita/gosync</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go标准库的<code>sync/Mutex</code>、<code>RWMutex</code>实现了<code>sync/Locker</code>接口， 提供了<code>Lock()</code>和<code>UnLock()</code>方法，可以获取锁和释放锁，我们可以方便的使用它来控制我们对共享资源的并发控制上。</p>
<p>但是标准库中的<code>Mutex.Lock</code>的锁被获取后，如果在未释放之前再调用<code>Lock</code>则会被阻塞住，这种设计在有些情况下可能不能满足我的需求。有时候我们想尝试获取锁，如果获取到了，没问题继续执行，如果获取不到，我们不想阻塞住，而是去调用其它的逻辑，这个时候我们就想要<code>TryLock</code>方法了。</p>
<p>虽然很早(13年)就有人给Go开发组提需求了，但是这个请求并没有纳入官方库中，最终在官方库的清理中被关闭了，也就是官方库目前不会添加这个方法。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谁吃了我的Linux内存?]]></title>
    <link href="http://colobu.com/2017/03/07/what-is-in-linux-cached/"/>
    <id>http://colobu.com/2017/03/07/what-is-in-linux-cached/</id>
    <published>2017-03-07T08:16:42.000Z</published>
    <updated>2017-03-07T12:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/2017/03/07/what-is-in-linux-cached/atemyram.png" alt="图片来自 [linuxatemyram](http://www.linuxatemyram.com)"></p>
<p>一个经常被问的Linux问题：为啥我的Linux系统没运行多少程序，显示的可用内存这么少？其实Linux与Win的内存管理不同，会尽量缓存内存以提高读写性能，通常叫做Cache Memory。</p>
<p>比较老的文件都会介绍Linux的cache占用很多没关系，因为Linux尽可能利用内存进行缓存，但是缓存的回收也是需要资源的，比较好的一篇文章是Poor Zorro写的<a href="http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/" target="_blank" rel="external">Linux内存中的Cache真的能被回收么？</a>。</p>
<a id="more"></a>
<p>虽然大部分情况下我们看到cache很高没有问题，但是我们还是想弄清楚到底是哪个程序把cache弄的那么高，这居然不是一件容易的事。</p>
<p>内核的模块在分配资源的时候，为了提高效率和资源的利用率，都是透过slab来分配的。slab为结构性缓存占用内存，该项也经常占用很大的内存。不过借助slabtop工具，我们可以很方便的显示内核片缓存信息，该工具可以更直观的显示/proc/slabinfo下的内容。</p>
<p><code>slabtop -s c</code>显示了一台机器缓存中占用对象的情况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Active / Total Objects (% used)    : <span class="number">856448</span> / <span class="number">873737</span> (<span class="number">98.0</span>%)</div><div class="line"> Active / Total Slabs (% used)      : <span class="number">19737</span> / <span class="number">19737</span> (<span class="number">100.0</span>%)</div><div class="line"> Active / Total Caches (% used)     : <span class="number">67</span> / <span class="number">89</span> (<span class="number">75.3</span>%)</div><div class="line"> Active / Total Size (% used)       : <span class="number">141806.80</span>K / <span class="number">145931.33</span>K (<span class="number">97.2</span>%)</div><div class="line"> Minimum / Average / Maximum Object : <span class="number">0.01</span>K / <span class="number">0.17</span>K / <span class="number">8.00</span>K</div><div class="line"></div><div class="line">  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME</div><div class="line"><span class="number">416949</span> <span class="number">416949</span> <span class="number">100</span>%    <span class="number">0.10</span>K  <span class="number">10691</span>	 <span class="number">39</span>     <span class="number">42764</span>K buffer_head</div><div class="line">  <span class="number">5616</span>   <span class="number">5545</span>  <span class="number">98</span>%    <span class="number">2.00</span>K    <span class="number">351</span>	 <span class="number">16</span>     <span class="number">11232</span>K kmalloc-<span class="number">2048</span></div><div class="line">  <span class="number">9114</span>   <span class="number">8990</span>  <span class="number">98</span>%    <span class="number">1.02</span>K    <span class="number">294</span>	 <span class="number">31</span>	 <span class="number">9408</span>K ext4_inode_cache</div><div class="line"> <span class="number">12404</span>  <span class="number">12404</span> <span class="number">100</span>%    <span class="number">0.57</span>K    <span class="number">443</span>	 <span class="number">28</span>	 <span class="number">7088</span>K radix_tree_node</div><div class="line"> <span class="number">10800</span>  <span class="number">10731</span>  <span class="number">99</span>%    <span class="number">0.58</span>K    <span class="number">400</span>	 <span class="number">27</span>	 <span class="number">6400</span>K inode_cache</div><div class="line"> <span class="number">31290</span>  <span class="number">29649</span>  <span class="number">94</span>%    <span class="number">0.19</span>K    <span class="number">745</span>	 <span class="number">42</span>	 <span class="number">5960</span>K dentry</div><div class="line">  <span class="number">3552</span>   <span class="number">3362</span>  <span class="number">94</span>%    <span class="number">1.00</span>K    <span class="number">111</span>	 <span class="number">32</span>	 <span class="number">3552</span>K kmalloc-<span class="number">1024</span></div><div class="line">  <span class="number">1100</span>   <span class="number">1055</span>  <span class="number">95</span>%    <span class="number">2.84</span>K    <span class="number">100</span>	 <span class="number">11</span>	 <span class="number">3200</span>K task_struct</div><div class="line">  <span class="number">1649</span>   <span class="number">1481</span>  <span class="number">89</span>%    <span class="number">1.88</span>K     <span class="number">97</span>	 <span class="number">17</span>	 <span class="number">3104</span>K TCP</div><div class="line"> <span class="number">27000</span>  <span class="number">27000</span> <span class="number">100</span>%    <span class="number">0.11</span>K    <span class="number">750</span>	 <span class="number">36</span>	 <span class="number">3000</span>K sysfs_dir_cache</div><div class="line">  <span class="number">1380</span>   <span class="number">1269</span>  <span class="number">91</span>%    <span class="number">2.06</span>K     <span class="number">92</span>	 <span class="number">15</span>	 <span class="number">2944</span>K sighand_cache</div></pre></td></tr></table></figure>

<p>虽然上面的命令现实了cache中slab的情况，但是还是没有显示什么程序占用的cache。</p>
<p><a href="https://code.google.com/p/linux-ftools/" target="_blank" rel="external">linux-ftools</a>这个工具可以显示某个文件占用的cache的情况, fincore是它其中的一个工具：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">fincore [options] files...</div><div class="line"></div><div class="line">  <span class="variable">--pages=</span><span class="constant">false</span>      Do not print pages</div><div class="line">  --summarize        When comparing multiple files, print a summary report</div><div class="line">  --only-cached      Only print stats for files that are actually <span class="keyword">in</span> cache.</div><div class="line"></div><div class="line">root@xxxxxx:/var/lib/mysql/blogindex<span class="comment"># fincore --pages=false --summarize --only-cached * </span></div><div class="line">stats for CLUSTER_LOG_2010_05_21.MYI: file <span class="variable">size=</span><span class="number">93840384</span> , total <span class="variable">pages=</span><span class="number">22910</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">0.004365</span> </div><div class="line">stats for CLUSTER_LOG_2010_05_22.MYI: file <span class="variable">size=</span><span class="number">417792</span> , total <span class="variable">pages=</span><span class="number">102</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">0.980392</span> </div><div class="line">stats for CLUSTER_LOG_2010_05_23.MYI: file <span class="variable">size=</span><span class="number">826368</span> , total <span class="variable">pages=</span><span class="number">201</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">0.497512</span> </div><div class="line">stats for CLUSTER_LOG_2010_05_24.MYI: file <span class="variable">size=</span><span class="number">192512</span> , total <span class="variable">pages=</span><span class="number">47</span> , cached <span class="variable">pages=</span><span class="number">1</span> , cached <span class="variable">size=</span><span class="number">4096</span>, cached <span class="variable">perc=</span><span class="number">2.127660</span> </div><div class="line">stats for CLUSTER_LOG_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">345088</span> , total <span class="variable">pages=</span><span class="number">84</span> , cached <span class="variable">pages=</span><span class="number">43</span> , cached <span class="variable">size=</span><span class="number">176128</span>, cached <span class="variable">perc=</span><span class="number">51.190476</span> </div><div class="line">stats for CLUSTER_LOG_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">1478552</span> , total <span class="variable">pages=</span><span class="number">360</span> , cached <span class="variable">pages=</span><span class="number">97</span> , cached <span class="variable">size=</span><span class="number">397312</span>, cached <span class="variable">perc=</span><span class="number">26.944444</span> </div><div class="line">stats for CLUSTER_LOG_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">205824</span> , total <span class="variable">pages=</span><span class="number">50</span> , cached <span class="variable">pages=</span><span class="number">29</span> , cached <span class="variable">size=</span><span class="number">118784</span>, cached <span class="variable">perc=</span><span class="number">58.000000</span> </div><div class="line">stats for COMMENT_CONTENT_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">100051968</span> , total <span class="variable">pages=</span><span class="number">24426</span> , cached <span class="variable">pages=</span><span class="number">10253</span> , cached <span class="variable">size=</span><span class="number">41996288</span>, cached <span class="variable">perc=</span><span class="number">41.975764</span> </div><div class="line">stats for COMMENT_CONTENT_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">716369644</span> , total <span class="variable">pages=</span><span class="number">174894</span> , cached <span class="variable">pages=</span><span class="number">79821</span> , cached <span class="variable">size=</span><span class="number">326946816</span>, cached <span class="variable">perc=</span><span class="number">45.639645</span> </div><div class="line">stats for COMMENT_CONTENT_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">56832000</span> , total <span class="variable">pages=</span><span class="number">13875</span> , cached <span class="variable">pages=</span><span class="number">5365</span> , cached <span class="variable">size=</span><span class="number">21975040</span>, cached <span class="variable">perc=</span><span class="number">38.666667</span> </div><div class="line">stats for FEED_CONTENT_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">1001518080</span> , total <span class="variable">pages=</span><span class="number">244511</span> , cached <span class="variable">pages=</span><span class="number">98975</span> , cached <span class="variable">size=</span><span class="number">405401600</span>, cached <span class="variable">perc=</span><span class="number">40.478751</span> </div><div class="line">stats for FEED_CONTENT_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">9206385684</span> , total <span class="variable">pages=</span><span class="number">2247652</span> , cached <span class="variable">pages=</span><span class="number">1018661</span> , cached <span class="variable">size=</span><span class="number">4172435456</span>, cached <span class="variable">perc=</span><span class="number">45.321117</span> </div><div class="line">stats for FEED_CONTENT_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">638005248</span> , total <span class="variable">pages=</span><span class="number">155763</span> , cached <span class="variable">pages=</span><span class="number">52912</span> , cached <span class="variable">size=</span><span class="number">216727552</span>, cached <span class="variable">perc=</span><span class="number">33.969556</span> </div><div class="line">stats for FEED_CONTENT_2010_06_04.frm: file <span class="variable">size=</span><span class="number">9840</span> , total <span class="variable">pages=</span><span class="number">2</span> , cached <span class="variable">pages=</span><span class="number">3</span> , cached <span class="variable">size=</span><span class="number">12288</span>, cached <span class="variable">perc=</span><span class="number">150.000000</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_03.MYI: file <span class="variable">size=</span><span class="number">1035290624</span> , total <span class="variable">pages=</span><span class="number">252756</span> , cached <span class="variable">pages=</span><span class="number">108563</span> , cached <span class="variable">size=</span><span class="number">444674048</span>, cached <span class="variable">perc=</span><span class="number">42.951700</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_04.MYD: file <span class="variable">size=</span><span class="number">55619712720</span> , total <span class="variable">pages=</span><span class="number">13579031</span> , cached <span class="variable">pages=</span><span class="number">6590322</span> , cached <span class="variable">size=</span><span class="number">26993958912</span>, cached <span class="variable">perc=</span><span class="number">48.533080</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_04.MYI: file <span class="variable">size=</span><span class="number">659397632</span> , total <span class="variable">pages=</span><span class="number">160985</span> , cached <span class="variable">pages=</span><span class="number">54304</span> , cached <span class="variable">size=</span><span class="number">222429184</span>, cached <span class="variable">perc=</span><span class="number">33.732335</span> </div><div class="line">stats for PERMALINK_CONTENT_2010_06_04.frm: file <span class="variable">size=</span><span class="number">10156</span> , total <span class="variable">pages=</span><span class="number">2</span> , cached <span class="variable">pages=</span><span class="number">3</span> , cached <span class="variable">size=</span><span class="number">12288</span>, cached <span class="variable">perc=</span><span class="number">150.000000</span> </div><div class="line">---</div><div class="line">total cached size: <span class="number">32847278080</span></div></pre></td></tr></table></figure>

<p>fincore的工作原理是将指定的文件的相应inode data与kernel的 page cache table做对比，如果page cache table有这个inode 信息，就找该inode对应的data block的大小。因为kernel的page cache table只存储data block的引用而不是文件名，即文件的inode信息。所以并没有任何一个工具运行一次就可以找出所有的文件使用缓存的情况。</p>
<p>所以使用linux-fincore只能加文件名，来判断该文件是否被缓存，如果缓存，大小是多少。问题是你不能随便猜哪个文件是否被缓存吧。</p>
<p><a href="http://shanker.blog.51cto.com" target="_blank" rel="external">shanker</a>提供了一个办法，那就查看哪些进程使用的物理内存最多，就找到该进程打开的文件，然后用fincore查看这些文件的缓存使用率。</p>
<p>这个办法在大部分情况下都可以找到占用cache较多的程序和进程。<br>他的这个脚本如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment">#Author: Shanker</span></div><div class="line"><span class="comment">#Time: 2016/06/08</span></div><div class="line"><span class="comment">#set -e</span></div><div class="line"><span class="comment">#set -u</span></div><div class="line"><span class="comment">#you have to install linux-fincore</span></div><div class="line"><span class="keyword">if</span> [ ! <span class="operator">-f</span> /usr/local/bin/linux-fincore ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"You haven't installed linux-fincore yet"</span></div><div class="line">    <span class="keyword">exit</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="comment">#find the top 10 processs' cache file</span></div><div class="line">ps <span class="operator">-e</span> -o pid,rss|sort -nk2 -r|head -<span class="number">10</span> |awk <span class="string">'{print $1}'</span>&gt;/tmp/cache.pids</div><div class="line"><span class="comment">#find all the processs' cache file</span></div><div class="line"><span class="comment">#ps -e -o pid&gt;/tmp/cache.pids</span></div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.files ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.files is exist, removing now "</span></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.files</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</div><div class="line"><span class="keyword">do</span></div><div class="line">    lsof -p <span class="variable">$line</span> <span class="number">2</span>&gt;/dev/null|awk <span class="string">'{print $9}'</span> &gt;&gt;/tmp/cache.files </div><div class="line"><span class="keyword">done</span>&lt;/tmp/cache.pids</div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.fincore ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.fincore is exist, removing now"</span></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.fincore</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/cache.files`</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> [ <span class="operator">-f</span> <span class="variable">$i</span> ]</div><div class="line">    <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="variable">$i</span> &gt;&gt;/tmp/cache.fincore</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line">linux-fincore <span class="operator">-s</span>  `cat /tmp/cache.fincore`</div><div class="line">rm <span class="operator">-f</span> /tmp/cache.{pids,files,fincore}</div></pre></td></tr></table></figure>

<p>比较遗憾的是，linux-ftools看起来不再维护了。我在我的服务器也没有编译好这个程序，所以还得想办法。</p>
<p>后来找到<a href="https://github.com/tobert/pcstat" target="_blank" rel="external">pcstat</a>这个工具，功能和linux-ftools一样，使用Go开发。<br>然后我修改了Shanker的脚本，让它使用pcstat进行处理，可以很好的找到cache占用的情况。</p>
<p>修改的脚本如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="comment">#you have to install pcstat</span></div><div class="line"><span class="keyword">if</span> [ ! <span class="operator">-f</span> /data0/brokerproxy/pcstat ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"You haven't installed pcstat yet"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"run \"go get github.com/tobert/pcstat\" to install"</span></div><div class="line">    <span class="keyword">exit</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#find the top 10 processs' cache file</span></div><div class="line">ps <span class="operator">-e</span> -o pid,rss|sort -nk2 -r|head -<span class="number">10</span> |awk <span class="string">'{print $1}'</span>&gt;/tmp/cache.pids</div><div class="line"><span class="comment">#find all the processs' cache file</span></div><div class="line"><span class="comment">#ps -e -o pid&gt;/tmp/cache.pids</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.files ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.files is exist, removing now "</span></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.files</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</div><div class="line"><span class="keyword">do</span></div><div class="line">    lsof -p <span class="variable">$line</span> <span class="number">2</span>&gt;/dev/null|awk <span class="string">'{print $9}'</span> &gt;&gt;/tmp/cache.files </div><div class="line"><span class="keyword">done</span>&lt;/tmp/cache.pids</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="operator">-f</span> /tmp/cache.pcstat ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"the cache.pcstat is exist, removing now"</span></div><div class="line"></div><div class="line">    rm <span class="operator">-f</span> /tmp/cache.pcstat</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/cache.files`</div><div class="line"><span class="keyword">do</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> [ <span class="operator">-f</span> <span class="variable">$i</span> ]</div><div class="line">    <span class="keyword">then</span></div><div class="line"></div><div class="line">        <span class="built_in">echo</span> <span class="variable">$i</span> &gt;&gt;/tmp/cache.pcstat</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line">/data0/brokerproxy/pcstat  `cat /tmp/cache.pcstat`</div><div class="line"></div><div class="line">rm <span class="operator">-f</span> /tmp/cache.{pids,files,pcstat}</div></pre></td></tr></table></figure>

<p>显示结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+------------------------------------------+----------------+------------+-----------+---------+</div><div class="line"><span class="string">| Name                                     | Size (bytes)   | Pages      | Cached    | Percent |</span></div><div class="line"><span class="string">|------------------------------------------+----------------+------------+-----------+---------|</span></div><div class="line"><span class="string">| /data0/abcasyouknow/0307/abc             | 10060771       | 2457       | 2457      | 100.000 |</span></div><div class="line"><span class="string">| /data0/abcasyouknow/0307/logs/abc.log    | 1860           | 1          | 1         | 100.000 |</span></div><div class="line"><span class="string">| /data0/abcasyouknow/0307/logs/uuid.log   | 326326364      | 79670      | 79670     | 100.000 |</span></div><div class="line"><span class="string">| /usr/bin/bash                            | 960384         | 235        | 194       | 082.553 |</span></div><div class="line"><span class="string">| /usr/lib/locale/locale-archive           | 106065056      | 25895      | 211       | 000.815 |</span></div><div class="line"><span class="string">| /usr/lib64/libnss_files-2.17.so          | 58288          | 15         | 15        | 100.000 |</span></div><div class="line"><span class="string">| /usr/lib64/libc-2.17.so                  | 2107760        | 515        | 336       | 065.243 |</span></div><div class="line"><span class="string">| /usr/lib64/libdl-2.17.so                 | 19512          | 5          | 5         | 100.000 |</span></div><div class="line"><span class="string">| /usr/lib64/libtinfo.so.5.9               | 174520         | 43         | 42        | 097.674 |</span></div><div class="line"><span class="string">| /usr/lib64/ld-2.17.so                    | 164336         | 41         | 41        | 100.000 |</span></div><div class="line"><span class="string">| /usr/lib64/gconv/gconv-modules.cache     | 26254          | 7          | 7         | 100.000 |</span></div><div class="line">+------------------------------------------+----------------+------------+-----------+---------+</div></pre></td></tr></table></figure>

<p>可以看到 uuid.log占用cache比较多。我的程序中这个文件是打开的，一直往里面写日志，Linux应该是把它缓存了。</p>
<p><strong>参考文档</strong></p>
<ol>
<li><a href="https://code.google.com/p/linux-ftools/" target="_blank" rel="external">https://code.google.com/p/linux-ftools/</a></li>
<li><a href="https://github.com/tobert/pcstat" target="_blank" rel="external">https://github.com/tobert/pcstat</a></li>
<li><a href="http://shanker.blog.51cto.com/1189689/1787378" target="_blank" rel="external">http://shanker.blog.51cto.com/1189689/1787378</a></li>
<li><a href="http://www.linuxatemyram.com" target="_blank" rel="external">http://www.linuxatemyram.com</a></li>
<li><a href="http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/" target="_blank" rel="external">http://colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/</a></li>
<li><a href="http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/" target="_blank" rel="external">http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/2017/03/07/what-is-in-linux-cached/atemyram.png" alt="图片来自 [linuxatemyram](http://www.linuxatemyram.com)"></p>
<p>一个经常被问的Linux问题：为啥我的Linux系统没运行多少程序，显示的可用内存这么少？其实Linux与Win的内存管理不同，会尽量缓存内存以提高读写性能，通常叫做Cache Memory。</p>
<p>比较老的文件都会介绍Linux的cache占用很多没关系，因为Linux尽可能利用内存进行缓存，但是缓存的回收也是需要资源的，比较好的一篇文章是Poor Zorro写的<a href="http://liwei.life/2016/04/26/linux内存中的cache真的能被回收么？/" target="_blank" rel="external">Linux内存中的Cache真的能被回收么？</a>。</p>
]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
