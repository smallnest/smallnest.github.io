<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2023-09-27T05:59:41.373Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[何时以及如何高效的使用经典的bpf, 它能到来什么好处？]]></title>
    <link href="https://colobu.com/2023/09/27/when-and-how-to-use-classical-bpf/"/>
    <id>https://colobu.com/2023/09/27/when-and-how-to-use-classical-bpf/</id>
    <published>2023-09-27T05:17:17.000Z</published>
    <updated>2023-09-27T05:59:08.193Z</updated>
    <content type="html"><![CDATA[<p>Classical BPF(cBPF, 伯克利包过滤器)是一种用来过滤网络数据包的技术。它像一个钩子一样挂载在网络栈的关键路径上,可以在数据包<strong>进入</strong>协议栈之前,根据预设规则来过滤或处理网络数据包。</p>
<a id="more"></a>
<p>相比于一般的软件包过滤方案,Classical BPF有以下优点:</p>
<ul>
<li>效率高:因为它运行在内核空间,可以避免不必要的内核态和用户态切换,也省去多次数据复制的开销。</li>
<li>安全:它不能随意访问系统内存或修改数据包,只能根据规则过滤,不会引起安全隐患。</li>
<li>灵活:过滤规则可以动态更新,使包过滤功能更加灵活。</li>
</ul>
<p>Classical BPF通常应用于网络监控、防火墙、流量控制等场景。它为包过滤提供了一个高效、安全、灵活的解决方案。但功能较为受限,只能过滤包不能修改。</p>
<p>我在百度做了三年多的网络监控了，我们会使用各种各样的方式来监控整个百度的物理网络，这些监控方式不同于普通的TCP Server/Client或者 UDP程序，一般我们会采用raw socket的方式来做包的探测和网络监控，为了高效的使用raw socket,避免把内核协议层的所有包都复制到应用层，我们会使用cBPF对收到的包进行过滤，我们只从内核层复制特定类型的包到应用层， 比如只复制UDP协议目的端口在20000 ~ 21000的数据包。 </p>
<p>怎么做到呢？就是使用cBPF。</p>
<p>我在先前的文章<a href="https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/" target="_blank" rel="external">使用BPF, 将Go网络程序的吞吐提升8倍</a>举了一个使用cBPF的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">cc := conn.(*net.IPConn)</div><div class="line">cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">pconn := ipv4.NewPacketConn(conn)</div><div class="line"><span class="keyword">var</span> assembled []bpf.RawInstruction</div><div class="line"><span class="keyword">if</span> assembled, err = bpf.Assemble(filter); err != <span class="constant">nil</span> {</div><div class="line">	log.Print(err)</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div><div class="line">pconn.SetBPF(assembled)</div><div class="line">handleConn(conn)</div></pre></td></tr></table></figure>

<p>可以使用<code>ipv4.PacketConn</code>的<code>SetBPF</code>方法设置过滤器:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">// 加载目的端口</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val: <span class="typename">uint32</span>(*port), SkipFalse:<span class="number"> 1</span>}, <span class="comment">// 如果目的端口 != 8972，则跳过一行，到了最后一，包丢弃了instruction</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},                                      <span class="comment">// 返回 0xffff，接收包</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">//  返回0字节, 代表忽略这个包</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们根据IP协议进行简单的分析。这里我们没有做过多的兼容检查，因为我们自己知道我们处理的是IPv4的包，而且包中也没有Option选项:<br><img src="IPv4_Packet.png" alt=""></p>
<p>IP的头部20个字节，payload是UDP包：<br><img src="udp.jpg" alt=""></p>
<p>可以看到UDP的前两个字节是源端口， 接下来两个字节是目的端口。</p>
<p>所以从IP header开始，第22 ~ 24字节是目的端口，所以<code>bpf.LoadAbsolute{Off: 22, Size: 2},</code>就是把这两个字节读取出来，和我们的值进行比较，看看是不是我们期望的值。</p>
<p>那么如果想使用<code>cBPF</code>,就得会写<code>bpf.Instruction</code>, 你得熟悉各种协议，以及bpf的指令。<br>不想学啊！累，麻烦！易出错！不好调试!</p>
<p>没关系，我写了一个库，只要你会使用tcpdump/wireshark,会使用他们的过滤器写法，就能写出相应的指令来。</p>
<p>比如 <code>tcpdump -i any -nn -vvvv tcp port 8080</code>这样一个命令，它的过滤器是<code>tcp port 8080</code>, 你这个使用这个库的下面的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raws, err := ParseTcpdumpFitlerExpr(layers.LinkTypeIPv4, <span class="string">"tcp port 8080"</span>)</div></pre></td></tr></table></figure>

<p>调用这个函数你会得到编译好的指令<code>[]bpf.RawInstruction</code>，然后调用<code>pconn.SetBPF(raws)</code>就可以了。</p>
<p>如果，你想得到它的Go代码形式，你可以调用<code>s = CreateInstructionsFromExpr(layers.LinkTypeIPv4, &quot;dst host 8.8.8.8 and icmp&quot;)</code>,<br>它会过滤只保留目的IP地址是<code>8.8.8.8</code>并且是icmp的包，生成的指令如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filter = []bpf.Instruction {</div><div class="line">        	bpf.LoadConstant{Dst:<span class="number"> 0</span>,Val:<span class="number"> 0</span>},</div><div class="line">        	bpf.LoadAbsolute{Off:<span class="number"> 16</span>,Size:<span class="number"> 4</span>},</div><div class="line">        	bpf.JumpIf{Cond:<span class="number"> 1</span>,Val:<span class="number"> 134744072</span>,SkipTrue:<span class="number"> 3</span>} <span class="comment">//  134744072 = 0x8080808,</span></div><div class="line">        	bpf.LoadAbsolute{Off:<span class="number"> 9</span>,Size:<span class="number"> 1</span>},</div><div class="line">        	bpf.JumpIf{Cond:<span class="number"> 1</span>,Val:<span class="number"> 1</span>,SkipTrue:<span class="number"> 1</span>},</div><div class="line">        	bpf.RetConstant{Val:<span class="number"> 0</span>x1},</div><div class="line">        	bpf.RetConstant{Val:<span class="number"> 0</span>x0},</div><div class="line">        }</div></pre></td></tr></table></figure>

<p><code>bpf.LoadAbsolute{Off: 16,Size: 4},</code>是加载IP头中的目的IP地址，检查是不是等于<code>8.8.8.8</code>，如果是，则检查协议(odd:9)是不是ICMP(icmp的协议号是1)。</p>
<p>所以即使你不熟悉各种协议，根据tcpdump的过滤表达式也能生成编译好的bpf代码，或者得到Go语言的代码片段。</p>
<p>对了，这个库是<a href="https://github.com/smallnest/qianmo/blob/master/bpf.go" target="_blank" rel="external">阡陌</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Classical BPF(cBPF, 伯克利包过滤器)是一种用来过滤网络数据包的技术。它像一个钩子一样挂载在网络栈的关键路径上,可以在数据包<strong>进入</strong>协议栈之前,根据预设规则来过滤或处理网络数据包。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从头再读取 io.Reader: 覆水难收？]]></title>
    <link href="https://colobu.com/2023/09/24/reread-the-io-Reader/"/>
    <id>https://colobu.com/2023/09/24/reread-the-io-Reader/</id>
    <published>2023-09-24T14:17:38.000Z</published>
    <updated>2023-09-27T05:14:41.340Z</updated>
    <content type="html"><![CDATA[<p>前几天，我们百度的同学分享了Go标准库中一段好玩的好玩的代码， <code>net/http/response.go</code>中一段检查HTTP的headser中<code>Content-Length</code>未设置的情况下，对<code>http.Body</code>的有趣的处理。</p>
<a id="more"></a>
<p>我们知道<code>io.Reader</code>提供了<code>Read</code>方法，并没有将读取的数据再塞回去的方法，而且对于流式的Reader,也绝无可能将数据塞回去。就像覆水难收一样，泼出去的水，没办法收回来了。</p>
<p>如果我们想从Reader读取一部分字节，做一些处理(一般是做一些检查)，然后想再让调用者从头开始读取咋办？</p>
<p><code>net/http/response.go</code>中就有这么一段代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Clone it, so we can modify r1 as needed.</span></div><div class="line">r1 := <span class="built_in">new</span>(Response)</div><div class="line">*r1 = *r</div><div class="line"><span class="keyword">if</span> r1.ContentLength ==<span class="number"> 0</span> && r1.Body != <span class="constant">nil</span> {</div><div class="line">	<span class="comment">// Is it actually 0 length? Or just unknown?</span></div><div class="line">	<span class="keyword">var</span> buf <span class="number">[1</span>]<span class="typename">byte</span></div><div class="line">	n, err := r1.Body.Read(buf[:])</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> && err != io.EOF {</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> n ==<span class="number"> 0</span> {</div><div class="line">		<span class="comment">// Reset it to a known zero reader, in case underlying one</span></div><div class="line">		<span class="comment">// is unhappy being read repeatedly.</span></div><div class="line">		r1.Body = NoBody</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		r1.ContentLength =<span class="number"> -1</span></div><div class="line">		r1.Body = <span class="keyword">struct</span> {</div><div class="line">			io.Reader</div><div class="line">			io.Closer</div><div class="line">		}{</div><div class="line">			io.MultiReader(bytes.NewReader(buf[<span class="number">:1</span>]), r.Body),</div><div class="line">			r.Body,</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码主要是针对响应(Response)对象做了一次克隆(Clone),目的是为了能够安全地修改响应对象,而不影响原始的响应对象。</p>
<p>具体来看:</p>
<ol>
<li>r1 := new(Response) 创建一个新的响应对象</li>
<li>r1 = r 让r1成为原始响应r的克隆</li>
<li>接下来判断如果响应内容长度r1.ContentLength == 0 且响应体r1.Body != nil</li>
<li>这说明内容长度标记为0,但实际上响应体不为空。这种情况下无法确定内容究竟是0长度还是长度未知。</li>
<li>所以读取1字节到buf,以判断响应体是否真是0长度。</li>
<li>如果读取到EOF,说明响应体确实长度为0,将Body重置为NoBody。</li>
<li>否则说明长度未知,将ContentLength设置为-1,并用MultiReader将已读取的1字节内容和原Body组合,作为新Body。</li>
<li>这样通过克隆的响应对象r1,可以安全地修改ContentLength和Body,而不影响原始响应对象r。</li>
</ol>
<p>这段代码通过克隆请求对象,巧妙地处理了内容长度标记为0但实际有内容的情况,避免了对原始响应对象的修改。</p>
<p>它先读取了1个字节，来判断Body是否为空，不为空在通过<code>io.MultiReader(bytes.NewReader(buf[:1]), r.Body),</code>把这一个字节和原来的io.Reader(<code>r.Body</code>)在捏合在一起，形成一个新的io.Reader。</p>
<p>通过<code>io.MultiReader</code>新建一个 io.Reader,就可以把已读取的字节和剩余未读取的字节组合起来，形成都未读取的Reader。</p>
<p>标准库<code>net/http/transfer.go</code>中也有一段相同的逻辑处理。</p>
<p>这让我想起了<a href="https://github.com/soheilhy/cmux" target="_blank" rel="external">soheilhy/cmux</a>, <a href="http://rpcx.io" target="_blank" rel="external">rpcx</a>最早使用它在一个端口上提供不同传输的协议。</p>
<p>cmux也是预先读取一部分数据，和预先配置的Matcher进行匹配，如果匹配成功，比如HTTP1.1协议，那么这个连接后续就按照HTTP1.1协议进行解析。那么预先读取的这些字节也得交给解析器从头开始解析，否则数据就缺失了，那么它是怎么实现的呢？</p>
<p>cmux使用老二另外一个方法，它创建了一个bufferedReader:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> bufferedReader <span class="keyword">struct</span> {</div><div class="line">	source     io.Reader</div><div class="line">	buffer     bytes.Buffer</div><div class="line">	bufferRead <span class="typename">int</span></div><div class="line">	bufferSize <span class="typename">int</span></div><div class="line">	sniffing   <span class="typename">bool</span></div><div class="line">	lastErr    error</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当连接开始在侦探和哪个Matcher匹配的时候， conn连接会把数据写入到这个buffer中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (s *bufferedReader) Read(p []<span class="typename">byte</span>) (<span class="typename">int</span>, error) {</div><div class="line">	<span class="keyword">if</span> s.bufferSize &gt; s.bufferRead { <span class="comment">// buffer中有未读的数据，先读取这个</span></div><div class="line">		bn := <span class="built_in">copy</span>(p, s.buffer.Bytes()[s.bufferRead:s.bufferSize])</div><div class="line">		s.bufferRead += bn</div><div class="line">		<span class="keyword">return</span> bn, s.lastErr</div><div class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> !s.sniffing && s.buffer.Cap() !=<span class="number"> 0</span> {</div><div class="line">		s.buffer = bytes.Buffer{}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 从原始的conn中读取</span></div><div class="line">	sn, sErr := s.source.Read(p)</div><div class="line">	<span class="keyword">if</span> sn &gt;<span class="number"> 0</span> && s.sniffing { <span class="comment">// 如果还在侦探状态，把读取的数据写入到buffer中</span></div><div class="line">		s.lastErr = sErr</div><div class="line">		<span class="keyword">if</span> wn, wErr := s.buffer.Write(p[:sn]); wErr != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> wn, wErr</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sn, sErr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦侦探完成(match一个协议)，那么就会把读取的指针置为最开始的地方，从头开始读取，根据上面的方法的逻辑，读取完buffer就从原始conn中读取，也不会再往buffer中写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *MuxConn) doneSniffing() {</div><div class="line">	m.buf.reset(<span class="constant">false</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *bufferedReader) reset(snif <span class="typename">bool</span>) {</div><div class="line">	s.sniffing = snif</div><div class="line">	s.bufferRead =<span class="number"> 0</span> <span class="comment">// 退回到原点，从最开始的数据开始读</span></div><div class="line">	s.bufferSize = s.buffer.Len() <span class="comment">// 已读取的数据</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过这种方式，也实现了预读取的功能。</p>
<p>看起来，在Go语言中，还真的能覆水再回收。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天，我们百度的同学分享了Go标准库中一段好玩的好玩的代码， <code>net/http/response.go</code>中一段检查HTTP的headser中<code>Content-Length</code>未设置的情况下，对<code>http.Body</code>的有趣的处理。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更精准的时延：使用软件时间戳和硬件时间戳]]></title>
    <link href="https://colobu.com/2023/09/24/precise-rtt-for-ping/"/>
    <id>https://colobu.com/2023/09/24/precise-rtt-for-ping/</id>
    <published>2023-09-24T07:05:41.000Z</published>
    <updated>2023-09-24T08:54:38.332Z</updated>
    <content type="html"><![CDATA[<p>在我上一篇文章<a href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/" target="_blank" rel="external">mping: 使用新的icmp库实现探测和压测工具</a>文章中，介绍了使用新的第三方库icmpx使用ping的功能,实现了mping这样一个高性能的探测和压测工具，并且还计算了往返时延指标(RTT, Round Trip Time)。</p>
<p>有时候，我们在做应用开发的时候，比如微服务调用的时候，也常常会计算程序的延时(latency)。</p>
<a id="more"></a>
<h2 id="网络时延">网络时延</h2>
<p>一般情况下，我们通过在应用层读取时间戳，计算两个时间戳的延时($t1 - t0$)，就可以得到时延，就足够了。通过观察这个数据，我们可以看到网络的时延情况(latency)和抖动(jitter)。但是有时候,我们想知道物理网络传输网络的时延是多少，比如北京A机房到B机房的时延，如果通过应用层的时间戳来计算，误差就太大了。为什么呢？</p>
<p>我们知道，当你的服务器和另外一个服务器通讯的时候，包(packet)其实经过了很漫长的链路，从你的应用程序写入本机的buffer,到本机协议栈的处理，网卡处理、网线、机房的各种网络设备、骨干网、再到对端机房、网卡、协议栈、应用程序，经过了很多很多的环节，如果还经过了云网络的话，会更复杂。其中应用层到网卡处理这一段时间，可能会因为CPU的处理能力、服务器负载、网络处理的能力，导致有比较大的耗时，如果在应用层计算网络两点之间的网络时延的话，不能正确得到两点之间的时延或者RTT。</p>
<p>一般来说，光信号在光纤中的传输速度大约为20万公里/秒，所以理论上每100公里的物理网络时延大约为0.5毫秒。但光信号在光纤上的传播时延会受到光纤材质、组件损耗、连接损耗等因素的影响,会比理论值稍大一些。另外在运营商实际网络中,还需要考虑路由器处理带来的转发时延的影响。</p>
<p>北京到广州的全程大约为2200公里。按照理论计算时延11毫秒， RTT的话需要来回的时延，所以是22毫秒，但是实际是，我使用我在北京的一个腾讯云的服务器ping广州的一台机器，时延大约38.9毫秒：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ubuntu@lab:~$ ping <span class="number">221.4</span>.<span class="number">66.66</span></div><div class="line">PING <span class="number">221.4</span>.<span class="number">66.66</span> (<span class="number">221.4</span>.<span class="number">66.66</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">251</span> time=<span class="number">38.8</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">221.4</span>.<span class="number">66.66</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">251</span> time=<span class="number">38.9</span> ms</div></pre></td></tr></table></figure>

<p>这个指标对于物理网络建设以及准备使用云设施的服务器来说，非常的重要，毕竟越短的时延会给我们带来更好的性能。同时如果更好的更准确的计算这个时延也很重要了。</p>
<h2 id="软件时间戳和硬件时间戳">软件时间戳和硬件时间戳</h2>
<p>我们可以通过软件时间戳或者硬件时间戳，更精确的计算包的进入发送和接收的时间戳，去掉应用层或者协议栈层带来的误差。</p>
<p>如果硬件和驱动程序支持,网卡会在发送和接收数据包时,使用硬件计数器向数据包的时间戳字段写入一个高精度时间戳。</p>
<p>如果硬件不支持，Linux也实现实现一个软件的时间戳，协议栈处理收到和发出的包时写入一个高精度时间戳。</p>
<p><img src="timestamp.png" alt=""></p>
<ul>
<li><p>软件时间戳(Software Timestamp)<br>通过软件方式获取时间和写入数据包的时间戳。相比硬件时间戳,软件时间戳有以下特点:</p>
<ul>
<li>获取时间和写入时间戳的过程在软件层完成,不需要硬件支持。</li>
<li>时间精度较低,通常只能达到毫秒级。硬件时间戳可以达到微秒或纳秒级精度。</li>
<li>时间同步不够精确。受到软件运行开销、系统调度等因素影响。</li>
<li>对系统资源占用较大,会增加中断开销。</li>
<li>只能标记退出和进入协议栈的时间,不能精确标记发送和接收时刻。</li>
<li>不同设备之间时间同步困难,容易产生时间偏差。</li>
</ul>
</li>
<li><p>硬件时间戳(Hardware Timestamp)<br>通过硬件芯片中的计数器来获取时间和写入数据包时间戳。相比软件时间戳,硬件时间戳具有以下优点:</p>
<ul>
<li>时间精度高,可以达到纳秒或皮秒级,满足对实时性要求较高的场景。</li>
<li>时间捕获精确,可以准确标记数据包的发送时刻和接收时刻。</li>
<li>对系统资源占用少,减少了中断开销。</li>
<li>不同设备之间时间同步容易,通过协议如PTP实现同步精度高。</li>
<li>不受软件运行开销等影响,时间戳更准确。</li>
</ul>
</li>
</ul>
<p>可以通过 <code>ethtool -T &lt;网络接口名&gt;</code>来查看机器对软硬件时间戳的支持情况。比如下面这台机器软硬件时间戳都不支持<br><img src="ethtool1.png" alt=""></p>
<p>下面这台机器只支持软件时间戳：<br><img src="ethtool2.png" alt=""></p>
<p>下面这台机器支持软硬件时间戳：<br><img src="ethtool3.png" alt=""></p>
<h2 id="使用软硬件时间戳">使用软硬件时间戳</h2>
<p>Linux内核对软硬件时间戳的支持是渐进的。</p>
<p>软件时间戳(Software Timestamping)自2.6内核开始支持,通过调用clock_gettime()等时间系统调用可以获取software timestamp，timestamp精度可以达到纳秒级。但软件时间戳易受到系统调度、中断等影响,精度较差。</p>
<p>硬件时间戳(Hardware Timestamping)自3.5内核开始引入PTP硬件时间戳支持,主要应用于高精度时间同步，能够直接读取网络卡、FPGA等硬件计数器的值作为时间戳，精度可以达到纳秒甚至皮秒级。但需要硬件支持,且对驱动和读数有一定要求。</p>
<p>接下来我对mping工具进行改造，让它：</p>
<ul>
<li>如果client支持硬件时间戳，那么则使用硬件时间戳</li>
<li>如果client不支持硬件时间戳，退而求其次，使用软件时间戳</li>
<li>如果client软硬件时间戳都不支持，那么则使用应用程序的时间戳</li>
</ul>
<p>接下来我边讲解代码的同时，边讲解如何使用软硬件时间戳的。</p>
<p>因为需要对socket进行底层的设置和读写，所以使用icmpx这个库已经不合适了，我把原来的mping项目转换回<code>conn, err := net.ListenPacket(&quot;ip4:icmp&quot;, &quot;0.0.0.0&quot;)</code>的形式，这样我们就可以得到socket的文件描述符进行开启软硬件时间戳的设置，并且可以读取这些时间戳了。</p>
<h3 id="创建连接">创建连接</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> openConn() (*net.IPConn, error) {</div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:icmp"</span>, <span class="string">"0.0.0.0"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line"></div><div class="line">	ipconn := conn.(*net.IPConn)</div><div class="line">	f, err := ipconn.File()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> f.Close()</div><div class="line"></div><div class="line">	fd := <span class="typename">int</span>(f.Fd())</div><div class="line"></div><div class="line">	flags := unix.SOF_TIMESTAMPING_SYS_HARDWARE | unix.SOF_TIMESTAMPING_RAW_HARDWARE | unix.SOF_TIMESTAMPING_SOFTWARE | unix.SOF_TIMESTAMPING_RX_HARDWARE | unix.SOF_TIMESTAMPING_RX_SOFTWARE |</div><div class="line">		unix.SOF_TIMESTAMPING_TX_HARDWARE | unix.SOF_TIMESTAMPING_TX_SOFTWARE |</div><div class="line">		unix.SOF_TIMESTAMPING_OPT_CMSG | unix.SOF_TIMESTAMPING_OPT_TSONLY</div><div class="line">	<span class="keyword">if</span> err := syscall.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_TIMESTAMPING, flags); err != <span class="constant">nil</span> {</div><div class="line">		supportTxTimestamping = <span class="constant">false</span></div><div class="line">		supportRxTimestamping = <span class="constant">false</span></div><div class="line">		<span class="keyword">if</span> err := syscall.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_TIMESTAMPNS,<span class="number"> 1</span>); err == <span class="constant">nil</span> {</div><div class="line">			supportRxTimestamping = <span class="constant">true</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">return</span> ipconn, <span class="constant">nil</span></div><div class="line">	}</div><div class="line">	timeout := syscall.Timeval{Sec:<span class="number"> 1</span>, Usec:<span class="number"> 0</span>}</div><div class="line">	<span class="keyword">if</span> err := syscall.SetsockoptTimeval(fd, unix.SOL_SOCKET, unix.SO_RCVTIMEO, &timeout); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> err := syscall.SetsockoptTimeval(fd, unix.SOL_SOCKET, unix.SO_SNDTIMEO, &timeout); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ipconn, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>首先我们要先创建一个icmp conn对象，通过<code>net.ListenPacket(&quot;ip4:icmp&quot;, &quot;0.0.0.0&quot;)</code>即可获得。</li>
<li>然后得到它的文件描述符(通过<code>File.Fd</code>方法)，也有通过<code>Control</code>方法得到socket的文件描述符的:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connFd <span class="typename">int</span></div><div class="line">err = conn.Control(<span class="keyword">func</span>(fd <span class="typename">uintptr</span>) {</div><div class="line">    connFd = <span class="typename">int</span>(fd) </div><div class="line">})</div></pre></td></tr></table></figure>

<p>两种方法都可以。</p>
<ul>
<li>接下来我们通过<code>SetsockoptInt</code>设置读取软硬件时间戳。 软硬件的标志都设置上，发送和接收的时间戳都设置上。你可以想想，发送的软硬件时间戳我们咋获取？应用程序把外放数据写入到缓冲区就返回了，那个时候它是得不到软硬件时间戳的。通过设置<code>SOF_TIMESTAMPING_OPT_CMSG</code>,可以在在网卡发送外发数据时，把软件或者硬件的时间戳写如到MSG_ERRQUEUE，你可以后续读取到这个时间戳。</li>
</ul>
<p>这里不会主动帮你开启硬件时间戳。如果你的硬件支持，但是没有开启的话，你可以手动开始硬件时间戳。</p>
<p>这里如果当前的操作系统不支持<code>SO_TIMESTAMPING</code>的话，那么尝试设置<code>SO_TIMESTAMPNS</code>, SO_TIMESTAMPNS自2.6以来就开始支持了。</p>
<h3 id="发送时读取发送的时间戳">发送时读取发送的时间戳</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">         ......</div><div class="line">_, err = conn.WriteTo(data, target)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div><div class="line"></div><div class="line">rs := &Result{</div><div class="line">	txts:   ts,</div><div class="line">	target: target.IP.String(),</div><div class="line">	seq:    seq,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> supportTxTimestamping {</div><div class="line">	<span class="keyword">if</span> txts, err := getTxTs(fd); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">if</span> strings.HasPrefix(err.Error(), <span class="string">"resource temporarily unavailable"</span>) {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"failed to get TX timestamp: %s"</span>, err)</div><div class="line">		rs.txts = txts</div><div class="line">	}</div><div class="line">}</div><div class="line">         ......</div><div class="line"></div><div class="line">         <span class="keyword">func</span> getTxTs(socketFd <span class="typename">int</span>) (<span class="typename">int64</span>, error) {</div><div class="line">             pktBuf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line">             oob := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line">             _, oobn, _, _, err := syscall.Recvmsg(socketFd, pktBuf, oob, syscall.MSG_ERRQUEUE)</div><div class="line">             <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                 <span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">             }</div><div class="line">             <span class="keyword">return</span> getTsFromOOB(oob, oobn)</div><div class="line">         }</div></pre></td></tr></table></figure>

<p>每写完一个数据包，则尝试从这个socket中读取发送时的软硬件时间戳，通过<code>Recvmsg</code>系统调用从<code>MSG_ERRQUEUE</code>获取。</p>
<h3 id="接收时读取软硬件时间戳">接收时读取软硬件时间戳</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  ......</div><div class="line">  _ = conn.SetReadDeadline(time.Now().Add<span class="number">(10</span> * time.Millisecond))</div><div class="line">n, oobn, _, ra, err := conn.ReadMsgIP(pktBuf, oob)</div><div class="line"></div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> rxts <span class="typename">int64</span></div><div class="line"><span class="keyword">if</span> supportRxTimestamping {</div><div class="line">	<span class="keyword">if</span> rxts, err = getTsFromOOB(oob, oobn); err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get RX timestamp: %s"</span>, err)</div><div class="line">	}</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	rxts = time.Now().UnixNano()</div><div class="line">}</div><div class="line">      ......</div></pre></td></tr></table></figure>

<p><code>conn.ReadMsgIP</code>会返回Out-Of-Band的数据，接收时的软件或者硬件时间戳就写入到这里面，我们通过<code>getTsFromOOB</code>方法解析:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> getTsFromOOB(oob []<span class="typename">byte</span>, oobn <span class="typename">int</span>) (<span class="typename">int64</span>, error) {</div><div class="line">	cms, err := syscall.ParseSocketControlMessage(oob[:oobn])</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> _, cm := <span class="keyword">range</span> cms {</div><div class="line">		<span class="keyword">if</span> cm.Header.Level == syscall.SOL_SOCKET && cm.Header.Type == syscall.SO_TIMESTAMPING {</div><div class="line">			<span class="keyword">var</span> t unix.ScmTimestamping</div><div class="line">			<span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(cm.Data), binary.LittleEndian, &t); err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(t.Ts); i++ {</div><div class="line">				<span class="keyword">if</span> t.Ts[i].Nano() &gt;<span class="number"> 0</span> {</div><div class="line">					<span class="keyword">return</span> t.Ts[i].Nano(), <span class="constant">nil</span></div><div class="line">				}</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">return</span><span class="number"> 0</span>, ErrStampNotFund</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">if</span> cm.Header.Level == syscall.SOL_SOCKET && cm.Header.Type == syscall.SCM_TIMESTAMPNS {</div><div class="line">			<span class="keyword">var</span> t unix.Timespec</div><div class="line">			<span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(cm.Data), binary.LittleEndian, &t); err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span><span class="number"> 0</span>, err</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> t.Nano(), <span class="constant">nil</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span>, ErrStampNotFund</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果是时间戳的数据, Level是SOL_SOCKET, Type是SO_TIMESTAMPING或者老版本的SCM_TIMESTAMPNS。</p>
<p>我们需要一个<code>unix.ScmTimestamping</code>数据类型反序列这个数据，它包含长度是3的一个数据。一般软件时间戳放入到第一个元素中，硬件时间戳放入到第三个，但是至少会有一个元素包含时间戳，我们依次遍历，看看哪一个时间戳设置了就用哪一个。</p>
<p>这个mping的例子演示了使用软硬件时间戳精确计算时延的例子，使用软硬件时间戳还可以实现更精确的时间服务PTP。 mping的代码可以从<a href="https://github.com/smallnest/mping/blob/master/ping.go" target="_blank" rel="external">github</a>上获取到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我上一篇文章<a href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/" target="_blank" rel="external">mping: 使用新的icmp库实现探测和压测工具</a>文章中，介绍了使用新的第三方库icmpx使用ping的功能,实现了mping这样一个高性能的探测和压测工具，并且还计算了往返时延指标(RTT, Round Trip Time)。</p>
<p>有时候，我们在做应用开发的时候，比如微服务调用的时候，也常常会计算程序的延时(latency)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PGO: 为你的Go程序提效5%]]></title>
    <link href="https://colobu.com/2023/09/13/pgo/"/>
    <id>https://colobu.com/2023/09/13/pgo/</id>
    <published>2023-09-13T13:52:13.000Z</published>
    <updated>2023-09-27T05:14:41.339Z</updated>
    <content type="html"><![CDATA[<p>PGO （基于profile指导的优化） 在Go 1.20 中还属于预览状态， 在Go 1.21中已经生产可用了， 未来 PGO 还有很宏伟的<a href="https://github.com/golang/go/issues/62463#issuecomment-1709485195" target="_blank" rel="external">目标</a>，但是现在已经可以很好的帮助我们提高程序的性能呢，根据程序的不同，可能会带来2% ~ 7%的提升，不要小看这个提升，如果你是在大厂做优化的专家，可以这样计算: “我厂大概有 10万Go实例，每个实例平均占用16个核，通过我们的优化，程序性能平均提升5%, 大约节省9万个核，每年为公司节省数亿元的成本”。</p>
<p>最近看到两篇关于PGO的文章：<a href="https://landontclipp.github.io/blog/2023/08/25/profile-guided-optimizations-in-go/#viewing-the-assembly" target="_blank" rel="external">Profile Guided Optimizations in Go</a> 和 Go官方的博客 <a href="https://go.dev/blog/pgo" target="_blank" rel="external">Profile-guided optimization in Go 1.21</a>。相比较而言， Go官方这篇文章简单明了，而且把·细节也交代的明明白白，所以我就把这篇文章翻译过来，我感觉我自己写也没有官方这篇写的明白，翻译过来就好了。</p>
<p>以下是译文：<br><a id="more"></a></p>
<p>2023年初,Go 1.20发布了基于profile指导的优化(PGO)的预览版本,供用户进行测试。在解决了预览版本中已知的限制,并借助社区反馈和贡献进行了进一步锤炼后,Go 1.21中的PGO功能已准备好用于广泛的生产环境!有关完整文档,请参阅<a href="https://go.dev/doc/pgo" target="_blank" rel="external">用户指南</a>。</p>
<p>下面我们将通过一个示例来演示如何使用PGO提高应用程序的性能。在深入示例之前,什么是“基于profile指导的优化”?</p>
<p>当你构建一个Go二进制文件时,Go编译器会执行优化,试图生成性能最佳的二进制文件。例如,常量传播(<code>constant propagation</code>)可以在编译时计算常量表达式的值,避免了运行时的计算开销。逃逸分析(<code>Escape analysis</code>)可以避免为局部作用域的对象分配堆内存,从而避免GC的开销。内联(<code>Inlining</code>)会将简单函数的函数体拷贝到调用者中,这通常可以在调用者中启用进一步的优化(例如额外的常量传播或更好的逃逸分析)。去虚拟化(<code>Devirtualization</code>)会将接口值上的间接调用(如果可以静态确定其类型)转换为对具体方法的直接调用(这通常可以内联该调用)。</p>
<p>Go在每个版本中都在提升优化,但这并非易事。一些优化是可调的,但是编译器不能对每项优化都“turn it up to 11” (英语典故，形容把某事物调到极限状态或者超出常规限度),因为过于激进的优化实际上可能会损害性能或者导致过长的构建时间。其他优化需要编译器对函数中的“常见路径”和“非常见路径”做出判断。编译器必须根据静态启发式方法进行最佳猜测,因为它无法知道运行时哪些分支更常见。</p>
<p>或者编译器可以做到吗?</p>
<p>没有关于代码在生产环境中的使用方式的确定信息,编译器只能对包的源代码进行操作。但是我们确实有一个工具来评估生产行为: profile (剖析，又叫性能分析,后面我们保持英文不翻译）。如果我们向编译器提供一个profile,它可以做出更明智的决定:更积极地优化使用最频繁的函数,或更准确地选择常见情况。</p>
<p>使用应用程序行为的profile进行编译器优化称为基于profile指导的优化 (PGO)(也称为性能分析引导优化、反馈导向优化(FDO))。</p>
<h2 id="示例">示例</h2>
<p>好的,让我们构建一个将Markdown转换为HTML的服务:用户将Markdown源上传到/render,它会返回HTML转换结果。我们可以使用<code>gitlab.com/golang-commonmark/markdown</code>来轻松实现这一功能。</p>
<h3 id="搭建">搭建</h3>
<p>创建一个文件夹并执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go mod init example.com/markdown</div><div class="line">$ go get gitlab.com/golang-commonmark/markdown@bf3e522c626a</div></pre></td></tr></table></figure>

<p>创建 main.go 文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"bytes"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    _ <span class="string">"net/http/pprof"</span></div><div class="line"></div><div class="line">    <span class="string">"gitlab.com/golang-commonmark/markdown"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> render(w http.ResponseWriter, r *http.Request) {</div><div class="line">    <span class="keyword">if</span> r.Method != <span class="string">"POST"</span> {</div><div class="line">        http.Error(w, <span class="string">"Only POST allowed"</span>, http.StatusMethodNotAllowed)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    src, err := io.ReadAll(r.Body)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"error reading body: %v"</span>, err)</div><div class="line">        http.Error(w, <span class="string">"Internal Server Error"</span>, http.StatusInternalServerError)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    md := markdown.New(</div><div class="line">        markdown.XHTMLOutput(<span class="constant">true</span>),</div><div class="line">        markdown.Typographer(<span class="constant">true</span>),</div><div class="line">        markdown.Linkify(<span class="constant">true</span>),</div><div class="line">        markdown.Tables(<span class="constant">true</span>),</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="keyword">var</span> buf bytes.Buffer</div><div class="line">    <span class="keyword">if</span> err := md.Render(&buf, src); err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"error converting markdown: %v"</span>, err)</div><div class="line">        http.Error(w, <span class="string">"Malformed markdown"</span>, http.StatusBadRequest)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> _, err := io.Copy(w, &buf); err != <span class="constant">nil</span> {</div><div class="line">        log.Printf(<span class="string">"error writing response: %v"</span>, err)</div><div class="line">        http.Error(w, <span class="string">"Internal Server Error"</span>, http.StatusInternalServerError)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    http.HandleFunc(<span class="string">"/render"</span>, render)</div><div class="line">    log.Printf(<span class="string">"Serving on port 8080..."</span>)</div><div class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>构建并运行这个服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go build -o markdown.nopgo.exe</div><div class="line">$ ./markdown.nopgo.exe</div><div class="line"><span class="number">2023</span>/<span class="number">08</span>/<span class="number">23</span> <span class="number">03</span>:<span class="number">55</span>:<span class="number">51</span> Serving on port <span class="number">8080</span>...</div></pre></td></tr></table></figure>

<p>好的,我们可以从另一个终端发送一些Markdown过来试试。我们可以使用Go项目中的<code>README.md</code>作为示例文档:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl -o README.md -L <span class="string">"https://raw.githubusercontent.com/golang/go/c16c2c49e2fa98ae551fc6335215fadd62d33542/README.md"</span></div><div class="line">$ curl --data-binary @README.md http://localhost:<span class="number">8080</span>/render</div><div class="line">&lt;h1&gt;The Go Programming Language&lt;/h1&gt;</div><div class="line">&lt;p&gt;Go is an open <span class="built_in">source</span> programming language that makes it easy to build simple,</div><div class="line">reliable, and efficient software.&lt;/p&gt;</div><div class="line">...</div></pre></td></tr></table></figure>

<h3 id="获取profile">获取profile</h3>
<p>既然我们已经有了一个工作的服务,让我们收集一个profile并用PGO重新构建,看看是否可以获得更好的性能。</p>
<p>在main.go中,我们导入了<code>net/http/pprof</code>,它会自动在服务器上添加一个<code>/debug/pprof/profile</code>地址来获取CPU profile。</p>
<p>通常你想要从生产环境中收集profile,这样编译器可以获得生产环境中的代表性行为视图。由于这个示例没有“生产”环境,我创建了一个简单的程序来在收集profile时生成压测负载。获取并启动负载生成器(确保服务器仍在运行!):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go run github.com/prattmic/markdown-pgo/load@latest</div></pre></td></tr></table></figure>

<p>在负载生成器运行时,从服务器下载一个性能分析:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -o cpu.pprof <span class="string">"http://localhost:8080/debug/pprof/profile?seconds=30"</span></div></pre></td></tr></table></figure>

<p>一旦profile下载完成,终止负载生成器和服务器。</p>
<h3 id="使用profile">使用profile</h3>
<p>Go工具链如果在main包目录中找到名为default.pgo的概要文件，就会自动启用PGO。或者, 在go build中使用<code>-pgo</code>标志接受一个文件路径作为PGO要使用的profile路径。</p>
<p>我们建议将profile文件提交到你的仓库中。将profile文件与源代码一起存储可以确保用户只需获取仓库(通过版本控制系统或go get)就可以自动访问profile文件,并且可以保证构建是可重现的。</p>
<p>让我们构建它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mv cpu.pprof <span class="keyword">default</span>.pgo</div><div class="line">$ <span class="keyword">go</span> build -o markdown.withpgo.exe</div></pre></td></tr></table></figure>

<p>我们可以通过go version检查PGO是否在构建中被启用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go version -m markdown.withpgo.exe</div><div class="line">./markdown.withpgo.exe: go1.<span class="number">21.0</span></div><div class="line">...</div><div class="line">        build   -pgo=/tmp/pgo121/default.pgo</div></pre></td></tr></table></figure>

<h3 id="评估">评估</h3>
<p>我们将使用负载生成器的Go基准测试版本来评估PGO对性能的影响。</p>
<p>首先,我们为没有使用PGO优化的服务器进行基准测试。启动那个服务器:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./markdown.nopgo.exe</div></pre></td></tr></table></figure>

<p>在服务运行时，执行几次基准测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/prattmic/markdown-pgo@latest</div><div class="line">$ go test github.com/prattmic/markdown-pgo/load -bench=. -count=<span class="number">40</span> -source $(<span class="built_in">pwd</span>)/README.md &gt; nopgo.txt</div></pre></td></tr></table></figure>

<p>一旦完成,终止原始服务器并启动带PGO的版本:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./markdown.withpgo.exe</div></pre></td></tr></table></figure>

<p>在服务运行时，也执行同样次数的基准测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/prattmic/markdown-pgo/load -bench=. -count=<span class="number">40</span> -source $(<span class="built_in">pwd</span>)/README.md &gt; withpgo.txt</div></pre></td></tr></table></figure>

<p>一旦完成，比较两次的测试结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ go install golang.org/x/perf/cmd/benchstat@latest</div><div class="line">$ benchstat nopgo.txt withpgo.txt</div><div class="line">goos: linux</div><div class="line">goarch: amd64</div><div class="line">pkg: github.com/prattmic/markdown-pgo/load</div><div class="line">cpu: Intel(R) Xeon(R) W-<span class="number">2135</span> CPU @ <span class="number">3.70</span>GHz</div><div class="line">        │  nopgo.txt  │            withpgo.txt             │</div><div class="line">        │   sec/op    │   sec/op     vs base               │</div><div class="line">Load-<span class="number">12</span>   <span class="number">374.5</span>µ ± <span class="number">1</span>%   <span class="number">360.2</span>µ ± <span class="number">0</span>%  -<span class="number">3.83</span>% (p=<span class="number">0.000</span> n=<span class="number">40</span>)</div></pre></td></tr></table></figure>

<p>新的版本大约快了3.8%! 在Go 1.21中,启用PGO后,工作负载的CPU使用率通常可以提高2%到7%。profile文件其实包含了大量关于应用程序行为的信息,Go 1.21只是开始利用这些信息进行有限的几项优化。随着编译器的更多部分利用PGO,未来的版本将继续改进性能。</p>
<h2 id="后续步骤">后续步骤</h2>
<p>在这个示例中,收集profile文件后,我们使用与原始构建完全相同的源代码重新构建了服务器。在实际场景中,代码都在不断开发。所以我们可能会从运行上周代码的生产环境收集profile文件,并用它来构建今天的源代码。这完全没问题!Go中的PGO可以毫无问题地处理源代码的细微变更。当然,随着时间推移,源代码会越来越不相同,所以定期更新profile文件仍然很重要。</p>
<p>关于使用PGO的更多信息、最佳实践和需要注意的警告,请参阅<a href="https://go.dev/doc/pgo" target="_blank" rel="external">基于profile指导的优化用户指南</a>。如果您好奇咋优化的,请继续阅读!</p>
<h2 id="原理剖析">原理剖析</h2>
<p>为了更好地理解是什么让这个应用程序变得更快，让我们深入了解一下性能是如何改进的。我们将查看两种不同的PGO驱动的优化。</p>
<h3 id="内联">内联</h3>
<p>为了观察内联优化的改进，让我们分别分析这个Markdown应用程序在使用PGO和不使用PGO时的情况。</p>
<p>我将使用一种称为差异性分析的技术进行比较，其中我们收集两个不同的性能分析数据（一个使用PGO，一个不使用PGO），然后进行比较。对于差异性分析，重要的是两个profile数据代表了相同数量的工作量，而不是相同数量的时间。因此，我已经调整了服务器以自动收集性能分析数据，还调整了负载生成器以发送固定数量的请求，然后退出服务器。</p>
<p>我已经对服务器进行了更改，依然收集到的profile数据,代码可以在<a href="https://github.com/prattmic/markdown-pgo找到。负载生成器使用了参数`-count=300000" target="_blank" rel="external">https://github.com/prattmic/markdown-pgo找到。负载生成器使用了参数`-count=300000</a> -quit`来运行。</p>
<p>作为一个快速的一致性检查，让我们来看一下处理所有 300,000 个请求所需的总CPU时间：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -top cpu.nopgo.pprof | grep <span class="string">"Total samples"</span></div><div class="line">Duration: <span class="number">116.92</span>s, Total samples = <span class="number">118.73</span>s (<span class="number">101.55</span>%)</div><div class="line">$ go tool pprof -top cpu.withpgo.pprof | grep <span class="string">"Total samples"</span></div><div class="line">Duration: <span class="number">113.91</span>s, Total samples = <span class="number">115.03</span>s (<span class="number">100.99</span>%)</div></pre></td></tr></table></figure>

<p>CPU时间从约118秒下降到约115秒，下降了约3%。这与我们的基准测试结果一致，这是这些profile数据具有代表性的一个好现象。</p>
<p>现在我们可以打开一个差异性分析数据来寻找节省的部分：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -diff_base cpu.nopgo.pprof cpu.withpgo.pprof</div><div class="line">File: markdown.profile.withpgo.exe</div><div class="line">Type: cpu</div><div class="line">Time: Aug <span class="number">28</span>, <span class="number">2023</span> at <span class="number">10</span>:<span class="number">26</span>pm (EDT)</div><div class="line">Duration: <span class="number">230.82</span>s, Total samples = <span class="number">118.73</span>s (<span class="number">51.44</span>%)</div><div class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top -cum</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">0.10</span>s, <span class="number">0.084</span>% of <span class="number">118.73</span>s total</div><div class="line">Dropped <span class="number">268</span> nodes (cum &lt;= <span class="number">0.59</span>s)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">668</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">    -<span class="number">0.03</span>s <span class="number">0.025</span>% <span class="number">0.025</span>%     -<span class="number">2.56</span>s  <span class="number">2.16</span>%  gitlab.com/golang-commonmark/markdown.ruleLinkify</div><div class="line">     <span class="number">0.04</span>s <span class="number">0.034</span>% <span class="number">0.0084</span>%     -<span class="number">2.19</span>s  <span class="number">1.84</span>%  net/http.(*conn).serve</div><div class="line">     <span class="number">0.02</span>s <span class="number">0.017</span>% <span class="number">0.025</span>%     -<span class="number">1.82</span>s  <span class="number">1.53</span>%  gitlab.com/golang-commonmark/markdown.(*Markdown).Render</div><div class="line">     <span class="number">0.02</span>s <span class="number">0.017</span>% <span class="number">0.042</span>%     -<span class="number">1.80</span>s  <span class="number">1.52</span>%  gitlab.com/golang-commonmark/markdown.(*Markdown).Parse</div><div class="line">    -<span class="number">0.03</span>s <span class="number">0.025</span>% <span class="number">0.017</span>%     -<span class="number">1.71</span>s  <span class="number">1.44</span>%  runtime.mallocgc</div><div class="line">    -<span class="number">0.07</span>s <span class="number">0.059</span>% <span class="number">0.042</span>%     -<span class="number">1.62</span>s  <span class="number">1.36</span>%  net/http.(*ServeMux).ServeHTTP</div><div class="line">     <span class="number">0.04</span>s <span class="number">0.034</span>% <span class="number">0.0084</span>%     -<span class="number">1.58</span>s  <span class="number">1.33</span>%  net/http.serverHandler.ServeHTTP</div><div class="line">    -<span class="number">0.01</span>s <span class="number">0.0084</span>% <span class="number">0.017</span>%     -<span class="number">1.57</span>s  <span class="number">1.32</span>%  main.render</div><div class="line">     <span class="number">0.01</span>s <span class="number">0.0084</span>% <span class="number">0.0084</span>%     -<span class="number">1.56</span>s  <span class="number">1.31</span>%  net/http.HandlerFunc.ServeHTTP</div><div class="line">    -<span class="number">0.09</span>s <span class="number">0.076</span>% <span class="number">0.084</span>%     -<span class="number">1.25</span>s  <span class="number">1.05</span>%  runtime.newobject</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">1.41</span>s, <span class="number">1.19</span>% of <span class="number">118.73</span>s total</div><div class="line">Dropped <span class="number">268</span> nodes (cum &lt;= <span class="number">0.59</span>s)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">668</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">    -<span class="number">0.46</span>s  <span class="number">0.39</span>%  <span class="number">0.39</span>%     -<span class="number">0.91</span>s  <span class="number">0.77</span>%  runtime.scanobject</div><div class="line">    -<span class="number">0.40</span>s  <span class="number">0.34</span>%  <span class="number">0.72</span>%     -<span class="number">0.40</span>s  <span class="number">0.34</span>%  runtime.nextFreeFast (inline)</div><div class="line">     <span class="number">0.36</span>s   <span class="number">0.3</span>%  <span class="number">0.42</span>%      <span class="number">0.36</span>s   <span class="number">0.3</span>%  gitlab.com/golang-commonmark/markdown.performReplacements</div><div class="line">    -<span class="number">0.35</span>s  <span class="number">0.29</span>%  <span class="number">0.72</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%  runtime.writeHeapBits.flush</div><div class="line">     <span class="number">0.32</span>s  <span class="number">0.27</span>%  <span class="number">0.45</span>%      <span class="number">0.67</span>s  <span class="number">0.56</span>%  gitlab.com/golang-commonmark/markdown.ruleReplacements</div><div class="line">    -<span class="number">0.31</span>s  <span class="number">0.26</span>%  <span class="number">0.71</span>%     -<span class="number">0.29</span>s  <span class="number">0.24</span>%  runtime.writeHeapBits.write</div><div class="line">    -<span class="number">0.30</span>s  <span class="number">0.25</span>%  <span class="number">0.96</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%  runtime.deductAssistCredit</div><div class="line">     <span class="number">0.29</span>s  <span class="number">0.24</span>%  <span class="number">0.72</span>%      <span class="number">0.10</span>s <span class="number">0.084</span>%  gitlab.com/golang-commonmark/markdown.ruleText</div><div class="line">    -<span class="number">0.29</span>s  <span class="number">0.24</span>%  <span class="number">0.96</span>%     -<span class="number">0.29</span>s  <span class="number">0.24</span>%  runtime.(*mspan).base (inline)</div><div class="line">    -<span class="number">0.27</span>s  <span class="number">0.23</span>%  <span class="number">1.19</span>%     -<span class="number">0.42</span>s  <span class="number">0.35</span>%  bytes.(*Buffer).WriteRune</div></pre></td></tr></table></figure>

<p>当指定 pprof -diff_base 时，pprof 中显示的值是两个配置文件之间的差异。因此，例如，使用 PGO 的 runtime.scanobject 的 CPU 使用时间比没有使用的少 0.46 秒。另一方面，gitlab.com/golang-commonmark/markdown.performReplacements 的 CPU 使用时间多了 0.36 秒。在差异性配置文件中，我们通常想要看绝对值（flat 和 cum 列），因为百分比没有意义。</p>
<p>top -cum 显示了累积变化最大的顶级差异。也就是说，一个函数及其所有传递调用者的 CPU 差异。这通常会显示我们程序调用图中最外层的帧，例如 main 或另一个 goroutine 入口点。在这里，我们可以看到大部分节省来自处理 HTTP 请求的 ruleLinkify 部分。</p>
<p>top 显示仅限于函数本身变化的顶级差异。这通常会显示我们程序调用图中的内部帧，这里正在进行大部分实际的工作。在这里我们可以看到，个别节省主要来自 runtime 函数。</p>
<p>都是些啥，让我们挑几个看看它们的调用栈:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">pprof) peek scanobject$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.86</span>s <span class="number">94.51</span>% |   runtime.gcDrain</div><div class="line">                                            -<span class="number">0.09</span>s  <span class="number">9.89</span>% |   runtime.gcDrainN</div><div class="line">                                             <span class="number">0.04</span>s  <span class="number">4.40</span>% |   runtime.markrootSpans</div><div class="line">    -<span class="number">0.46</span>s  <span class="number">0.39</span>%  <span class="number">0.39</span>%     -<span class="number">0.91</span>s  <span class="number">0.77</span>%                | runtime.scanobject</div><div class="line">                                            -<span class="number">0.19</span>s <span class="number">20.88</span>% |   runtime.greyobject</div><div class="line">                                            -<span class="number">0.13</span>s <span class="number">14.29</span>% |   runtime.heapBits.nextFast (inline)</div><div class="line">                                            -<span class="number">0.08</span>s  <span class="number">8.79</span>% |   runtime.heapBits.next</div><div class="line">                                            -<span class="number">0.08</span>s  <span class="number">8.79</span>% |   runtime.spanOfUnchecked (inline)</div><div class="line">                                             <span class="number">0.04</span>s  <span class="number">4.40</span>% |   runtime.heapBitsForAddr</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.10</span>% |   runtime.findObject</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek gcDrain$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                               -<span class="number">1</span>s   <span class="number">100</span>% |   runtime.gcBgMarkWorker.func2</div><div class="line">     <span class="number">0.15</span>s  <span class="number">0.13</span>%  <span class="number">0.13</span>%        -<span class="number">1</span>s  <span class="number">0.84</span>%                | runtime.gcDrain</div><div class="line">                                            -<span class="number">0.86</span>s <span class="number">86.00</span>% |   runtime.scanobject</div><div class="line">                                            -<span class="number">0.18</span>s <span class="number">18.00</span>% |   runtime.(*gcWork).balance</div><div class="line">                                            -<span class="number">0.11</span>s <span class="number">11.00</span>% |   runtime.(*gcWork).tryGet</div><div class="line">                                             <span class="number">0.09</span>s  <span class="number">9.00</span>% |   runtime.pollWork</div><div class="line">                                            -<span class="number">0.03</span>s  <span class="number">3.00</span>% |   runtime.(*gcWork).tryGetFast (inline)</div><div class="line">                                            -<span class="number">0.03</span>s  <span class="number">3.00</span>% |   runtime.markroot</div><div class="line">                                            -<span class="number">0.02</span>s  <span class="number">2.00</span>% |   runtime.wbBufFlush</div><div class="line">                                             <span class="number">0.01</span>s  <span class="number">1.00</span>% |   runtime/internal/atomic.(*Bool).Load (inline)</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.00</span>% |   runtime.gcFlushBgCredit</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.00</span>% |   runtime/internal/atomic.(*Int64).Add (inline)</div><div class="line">----------------------------------------------------------+-------------</div></pre></td></tr></table></figure>

<p>所以 runtime.scanobject 最终来自 runtime.gcBgMarkWorker。Go GC 指南告诉我们，runtime.gcBgMarkWorker 是垃圾收集器的一部分，所以 runtime.scanobject 的节省必定是 GC 的节省。那么 nextFreeFast 和其他的运行时函数呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">(pprof) peek nextFreeFast$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.40</span>s   <span class="number">100</span>% |   runtime.mallocgc (inline)</div><div class="line">    -<span class="number">0.40</span>s  <span class="number">0.34</span>%  <span class="number">0.34</span>%     -<span class="number">0.40</span>s  <span class="number">0.34</span>%                | runtime.nextFreeFast</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek writeHeapBits</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.37</span>s   <span class="number">100</span>% |   runtime.heapBitsSetType</div><div class="line">                                                 <span class="number">0</span>     <span class="number">0</span>% |   runtime.(*mspan).initHeapBits</div><div class="line">    -<span class="number">0.35</span>s  <span class="number">0.29</span>%  <span class="number">0.29</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%                | runtime.writeHeapBits.flush</div><div class="line">                                            -<span class="number">0.02</span>s  <span class="number">5.41</span>% |   runtime.arenaIndex (inline)</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.29</span>s   <span class="number">100</span>% |   runtime.heapBitsSetType</div><div class="line">    -<span class="number">0.31</span>s  <span class="number">0.26</span>%  <span class="number">0.56</span>%     -<span class="number">0.29</span>s  <span class="number">0.24</span>%                | runtime.writeHeapBits.write</div><div class="line">                                             <span class="number">0.02</span>s  <span class="number">6.90</span>% |   runtime.arenaIndex (inline)</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek heapBitsSetType$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.82</span>s   <span class="number">100</span>% |   runtime.mallocgc</div><div class="line">    -<span class="number">0.12</span>s   <span class="number">0.1</span>%   <span class="number">0.1</span>%     -<span class="number">0.82</span>s  <span class="number">0.69</span>%                | runtime.heapBitsSetType</div><div class="line">                                            -<span class="number">0.37</span>s <span class="number">45.12</span>% |   runtime.writeHeapBits.flush</div><div class="line">                                            -<span class="number">0.29</span>s <span class="number">35.37</span>% |   runtime.writeHeapBits.write</div><div class="line">                                            -<span class="number">0.03</span>s  <span class="number">3.66</span>% |   runtime.readUintptr (inline)</div><div class="line">                                            -<span class="number">0.01</span>s  <span class="number">1.22</span>% |   runtime.writeHeapBitsForAddr (inline)</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">(pprof) peek deductAssistCredit$</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">3.72</span>s, <span class="number">3.13</span>% of <span class="number">118.73</span>s total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                            -<span class="number">0.37</span>s   <span class="number">100</span>% |   runtime.mallocgc</div><div class="line">    -<span class="number">0.30</span>s  <span class="number">0.25</span>%  <span class="number">0.25</span>%     -<span class="number">0.37</span>s  <span class="number">0.31</span>%                | runtime.deductAssistCredit</div><div class="line">                                            -<span class="number">0.07</span>s <span class="number">18.92</span>% |   runtime.gcAssistAlloc</div><div class="line">----------------------------------------------------------+-------------</div></pre></td></tr></table></figure>

<p>看起来 nextFreeFast 和前10名中的其他一些最终来自 runtime.mallocgc，GC指南告诉我们这是内存分配器。</p>
<p>GC和分配器的成本降低表明我们总体上分配的较少。让我们看看heap profile文件以获取更深入的了解：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -sample_index=alloc_objects -diff_base heap.nopgo.pprof heap.withpgo.pprof</div><div class="line">File: markdown.profile.withpgo.exe</div><div class="line">Type: alloc_objects</div><div class="line">Time: Aug <span class="number">28</span>, <span class="number">2023</span> at <span class="number">10</span>:<span class="number">28</span>pm (EDT)</div><div class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">12044903</span>, <span class="number">8.29</span>% of <span class="number">145309950</span> total</div><div class="line">Dropped <span class="number">60</span> nodes (cum &lt;= <span class="number">726549</span>)</div><div class="line">Showing top <span class="number">10</span> nodes out of <span class="number">58</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">  -<span class="number">4974135</span>  <span class="number">3.42</span>%  <span class="number">3.42</span>%   -<span class="number">4974135</span>  <span class="number">3.42</span>%  gitlab.com/golang-commonmark/mdurl.Parse</div><div class="line">  -<span class="number">4249044</span>  <span class="number">2.92</span>%  <span class="number">6.35</span>%   -<span class="number">4249044</span>  <span class="number">2.92</span>%  gitlab.com/golang-commonmark/mdurl.(*URL).String</div><div class="line">   -<span class="number">901135</span>  <span class="number">0.62</span>%  <span class="number">6.97</span>%    -<span class="number">977596</span>  <span class="number">0.67</span>%  gitlab.com/golang-commonmark/puny.mapLabels</div><div class="line">   -<span class="number">653998</span>  <span class="number">0.45</span>%  <span class="number">7.42</span>%    -<span class="number">482491</span>  <span class="number">0.33</span>%  gitlab.com/golang-commonmark/markdown.(*StateInline).PushPending</div><div class="line">   -<span class="number">557073</span>  <span class="number">0.38</span>%  <span class="number">7.80</span>%    -<span class="number">557073</span>  <span class="number">0.38</span>%  gitlab.com/golang-commonmark/linkify.Links</div><div class="line">   -<span class="number">557073</span>  <span class="number">0.38</span>%  <span class="number">8.18</span>%    -<span class="number">557073</span>  <span class="number">0.38</span>%  strings.genSplit</div><div class="line">   -<span class="number">436919</span>   <span class="number">0.3</span>%  <span class="number">8.48</span>%    -<span class="number">232152</span>  <span class="number">0.16</span>%  gitlab.com/golang-commonmark/markdown.(*StateBlock).Lines</div><div class="line">   -<span class="number">408617</span>  <span class="number">0.28</span>%  <span class="number">8.77</span>%    -<span class="number">408617</span>  <span class="number">0.28</span>%  net/textproto.readMIMEHeader</div><div class="line">    <span class="number">401432</span>  <span class="number">0.28</span>%  <span class="number">8.49</span>%     <span class="number">499610</span>  <span class="number">0.34</span>%  bytes.(*Buffer).grow</div><div class="line">    <span class="number">291659</span>   <span class="number">0.2</span>%  <span class="number">8.29</span>%     <span class="number">291659</span>   <span class="number">0.2</span>%  bytes.(*Buffer).String (inline)</div></pre></td></tr></table></figure>

<p><code>-sample_index=alloc_objects</code> 选项为我们显示了分配的数量，而不考虑大小。这很有用，因为我们正在调查 CPU 使用率的降低，这往往更与分配的数量而不是大小相关。这里有相当多的减少，但让我们关注最大的减少，也就是 <code>mdurl.Parse</code>。</p>
<p>作为参考，让我们看一下这个函数在没有 PGO 的情况下的总分配数量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -sample_index=alloc_objects -top heap.nopgo.pprof | grep mdurl.Parse</div><div class="line">   <span class="number">4974135</span>  <span class="number">3.42</span>% <span class="number">68.60</span>%    <span class="number">4974135</span>  <span class="number">3.42</span>%  gitlab.com/golang-commonmark/mdurl.Parse</div></pre></td></tr></table></figure>

<p>在此之前的总数是<strong>4974135</strong>，这意味着 <code>mdurl.Parse</code> 已经消除了100%的分配！</p>
<p>回到另一个profile文件中(带pgo优化的)，让我们收集更多的上下文信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(pprof) peek mdurl.Parse</div><div class="line">Showing nodes accounting <span class="keyword">for</span> -<span class="number">12257184</span>, <span class="number">8.44</span>% of <span class="number">145309950</span> total</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</div><div class="line">----------------------------------------------------------+-------------</div><div class="line">                                          -<span class="number">2956806</span> <span class="number">59.44</span>% |   gitlab.com/golang-commonmark/markdown.normalizeLink</div><div class="line">                                          -<span class="number">2017329</span> <span class="number">40.56</span>% |   gitlab.com/golang-commonmark/markdown.normalizeLinkText</div><div class="line">  -<span class="number">4974135</span>  <span class="number">3.42</span>%  <span class="number">3.42</span>%   -<span class="number">4974135</span>  <span class="number">3.42</span>%                | gitlab.com/golang-commonmark/mdurl.Parse</div><div class="line">----------------------------------------------------------+-------------</div></pre></td></tr></table></figure>

<p>调用 mdurl.Parse 的是来自 markdown.normalizeLink 和 markdown.normalizeLinkText。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(pprof) list mdurl.Parse</div><div class="line">Total:<span class="number"> 145309950</span></div><div class="line">ROUTINE ======================== gitlab.com/golang-commonmark/mdurl.Parse in /usr/local/google/home/mpratt/<span class="keyword">go</span>/pkg/mod/gitlab.com/golang-commonmark/mdurl@v0<span class="number">.0.0</span><span class="number">-20191124015652</span><span class="number">-932350d1</span>cb84/parse</div><div class="line">.<span class="keyword">go</span></div><div class="line"> <span class="number"> -4974135</span>  <span class="number"> -4974135</span> (flat, cum) <span class="number"> 3.42</span>% of Total</div><div class="line">         .          .    <span class="number"> 60</span>:<span class="keyword">func</span> Parse(rawurl <span class="typename">string</span>) (*URL, error) {</div><div class="line">         .          .    <span class="number"> 61</span>:   n, err := findScheme(rawurl)</div><div class="line">         .          .    <span class="number"> 62</span>:   <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">         .          .    <span class="number"> 63</span>:           <span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">         .          .    <span class="number"> 64</span>:   }</div><div class="line">         .          .    <span class="number"> 65</span>:</div><div class="line"> <span class="number"> -4974135</span>  <span class="number"> -4974135</span>    <span class="number"> 66</span>:   <span class="keyword">var</span> url URL</div><div class="line">         .          .    <span class="number"> 67</span>:   rest := rawurl</div><div class="line">         .          .    <span class="number"> 68</span>:   hostless := <span class="constant">false</span></div><div class="line">         .          .    <span class="number"> 69</span>:   <span class="keyword">if</span> n &gt;<span class="number"> 0</span> {</div><div class="line">         .          .    <span class="number"> 70</span>:           url.RawScheme = rest[:n]</div><div class="line">         .          .    <span class="number"> 71</span>:           url.Scheme, rest = strings.ToLower(rest[:n]), rest[n<span class="number">+1</span>:]</div></pre></td></tr></table></figure>

<p>这些函数和调用者的完整源代码可以在以下位置找到：</p>
<ul>
<li><a href="https://gitlab.com/golang-commonmark/mdurl/-/blob/bd573caec3d827ead19e40b1f141a3802d956710/parse.go#L60" target="_blank" rel="external">mdurl.Parse</a></li>
<li><a href="https://gitlab.com/golang-commonmark/markdown/-/blob/fd7971701a0cab12e9347109a4c889f5c0a1a479/util.go#L53" target="_blank" rel="external">markdown.normalizeLink</a></li>
<li><a href="https://gitlab.com/golang-commonmark/markdown/-/blob/fd7971701a0cab12e9347109a4c889f5c0a1a479/util.go#L68" target="_blank" rel="external">markdown.normalizeLinkText</a></li>
</ul>
<p>所以这里发生了什么优化？在非 PGO 构建中，<code>mdurl.Parse</code> 被认为太大，不符合内联的条件。然而，因为我们的 PGO profile文件表明调用这个函数的操作是热点，所以编译器确实将它们内联了。我们可以从profile文件中的“(inline)”注解看到这一点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof -top cpu.nopgo.pprof | grep mdurl.Parse</div><div class="line">     <span class="number">0.36</span>s   <span class="number">0.3</span>% <span class="number">63.76</span>%      <span class="number">2.75</span>s  <span class="number">2.32</span>%  gitlab.com/golang-commonmark/mdurl.Parse</div><div class="line">$ go tool pprof -top cpu.withpgo.pprof | grep mdurl.Parse</div><div class="line">     <span class="number">0.55</span>s  <span class="number">0.48</span>% <span class="number">58.12</span>%      <span class="number">2.03</span>s  <span class="number">1.76</span>%  gitlab.com/golang-commonmark/mdurl.Parse (inline)</div></pre></td></tr></table></figure>

<p><code>mdurl.Parse</code> 在第 66 行创建了一个 URL 作为本地变量（<code>var url URL</code>），然后在第 145 行返回该变量的指针（<code>return &amp;url, nil</code>）。通常这需要将变量分配在堆上，因为对它的引用在函数返回之后仍然存在。然而，一旦 <code>mdurl.Parse</code> 被内联到 <code>markdown.normalizeLink</code> 中，编译器就可以观察到该变量并没有逃逸到 <code>normalizeLink</code> 之外，这允许编译器将其分配在栈上。<code>markdown.normalizeLinkText</code> 与 <code>markdown.normalizeLink</code> 类似。</p>
<p>配置文件中显示的第二大减小，来自 <code>mdurl.(*URL).String</code>，这是一个在内联之后消除了逃逸的类似案例。</p>
<p>在这些情况下，我们通过减少堆分配来提高性能。PGO 和编译器优化的部分威力在于，对分配的影响并不直接是由编译器的 PGO 实现。PGO 做的唯一改变就是允许将这些<strong>热点函数</strong>调用内联。所有对逃逸分析和堆分配的影响都是在构建时的标准优化。优化的逃逸行为是内联的引起的延伸效应，但这并非是唯一的效应。许多优化也可以利用内联。例如，当一些输入是常量时，常量传播可能能够在内联之后简化函数中的代码。</p>
<h3 id="去虚拟化">去虚拟化</h3>
<p>除了我们在上面的示例中看到的内联，PGO还可以驱动接口调用的有条件的去虚拟化。</p>
<p>在进行PGO驱动去虚拟化之前，让我们先步后并定义一下一般的“去虚拟化”。假设你的代码大概长这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f, _ := os.Open(<span class="string">"foo.txt"</span>)</div><div class="line"><span class="keyword">var</span> r io.Reader = f</div><div class="line">r.Read(b)</div></pre></td></tr></table></figure>

<p>这里我们对 <code>io.Reader</code> 接口方法 <code>Read</code> 进行了调用。由于接口可以有多个实现，因此编译器会生成一个间接函数调用，也就是说，它会在运行时从接口值中的类型查找正确的方法来调用。间接调用与直接调用相比有一点额外的运行时开销，但更重要的是，它们排除了一些编译器优化。例如，编译器无法对间接调用进行逃逸分析，因为它不知道具体的方法实现。</p>
<p>但是在上面的示例中，我们确实知道具体的方法实现。它一定是 <code>os.(*File).Read</code>，因为 <code>*os.File</code> 是唯一可能被赋值给 <code>r</code> 的类型。在这种情况下，编译器会进行去虚拟化，将间接调用 <code>io.Reader.Read</code> 替换为直接调用 <code>os.(*File).Read</code>，从而允许其他优化。</p>
<p>（你可能在想，“那段代码没用，为什么会有人这么写？”这是个好问题，但请注意，上面的代码可能是内联的结果。假设 f 被传入一个接受 <code>io.Reader</code> 参数的函数。一旦函数被内联，现在 io.Reader 就变成了具体的。）</p>
<p>PGO 驱动的去虚拟化将这个概念扩展到了具体类型在静态上未知，但分析可以显示，例如，<code>io.Reader.Read</code> 调用大多数时候是针对 <code>os.(*File).Read</code> 的情况。在这种情况下，PGO 可以将 <code>r.Read(b)</code> 替换为类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> f, ok := r.(*os.File); ok {</div><div class="line">    f.Read(b)</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    r.Read(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是说，我们添加了一个针对最可能出现的实体类型的运行时检查，如果是的话，我们使用具体的调用，否则就回退到标准的间接调用。这里的优点是，常见的路径（使用 *os.File）可以被内联并应用额外的优化，但我们仍然保留了一个回退路径，因为配置文件并不能保证这种情况总是出现。</p>
<p>在我们对 markdown 服务器的分析中，我们没有看到 PGO 驱动的去虚拟化的优化，但我们也看到了优化最大的地方。PGO（以及大多数编译器优化）通常从许多不同地方的非常小的改进中获得其利益的累计，所以可能发生的事情比我们看到的还要多。</p>
<p>内联和去虚拟化是 Go 1.21 中可用的两种 PGO 驱动优化，但正如我们已经看到的，它们常常触发额外的优化。此外，Go 的未来版本将继续通过附加优化来改善 PGO。</p>
<p>未来可期。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>PGO （基于profile指导的优化） 在Go 1.20 中还属于预览状态， 在Go 1.21中已经生产可用了， 未来 PGO 还有很宏伟的<a href="https://github.com/golang/go/issues/62463#issuecomment-1709485195" target="_blank" rel="external">目标</a>，但是现在已经可以很好的帮助我们提高程序的性能呢，根据程序的不同，可能会带来2% ~ 7%的提升，不要小看这个提升，如果你是在大厂做优化的专家，可以这样计算: “我厂大概有 10万Go实例，每个实例平均占用16个核，通过我们的优化，程序性能平均提升5%, 大约节省9万个核，每年为公司节省数亿元的成本”。</p>
<p>最近看到两篇关于PGO的文章：<a href="https://landontclipp.github.io/blog/2023/08/25/profile-guided-optimizations-in-go/#viewing-the-assembly" target="_blank" rel="external">Profile Guided Optimizations in Go</a> 和 Go官方的博客 <a href="https://go.dev/blog/pgo" target="_blank" rel="external">Profile-guided optimization in Go 1.21</a>。相比较而言， Go官方这篇文章简单明了，而且把·细节也交代的明明白白，所以我就把这篇文章翻译过来，我感觉我自己写也没有官方这篇写的明白，翻译过来就好了。</p>
<p>以下是译文：<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Linux tracepoints、perf 和 eBPF 跟踪包的旅程]]></title>
    <link href="https://colobu.com/2023/09/11/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/"/>
    <id>https://colobu.com/2023/09/11/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/</id>
    <published>2023-09-11T14:09:17.000Z</published>
    <updated>2023-09-24T07:01:49.818Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.yadutaf.fr/2017/07/28/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/" target="_blank" rel="external">Tracing a packet journey using Linux tracepoints, perf and eBPF</a></p>
<p>很久以来我一直在寻找一个底层的Linux网络调试工具。<br>我一直在寻找一个低级的Linux网络调试工具已经有一段时间了。Linux 允许使用虚拟接口(virtual interface)和网络命名空间(network namespace)的组合来构建直接在主机上运行的复杂网络。当出现问题时，故障排除相当乏味。如果这是 L3 路由问题，mtr则很有可能会有所帮助。但是，如果这是一个较低层的问题，我通常会手动检查每个接口/网桥/网络命名空间/iptables并启动几个tcpdump，以尝试了解正在发生的事情。如果您事先不了解网络设置，这可能感觉像走迷宫。</p>
<a id="more"></a>
<p>我需要的是一个工具，可以告诉我 “嘿，哥们，我已经看到了你的数据包：它已经这样消失了，在这个接口上，在这个网络命名空间中”。</p>
<p>基本上，我需要的是在L2上的mtr。</p>
<p>没有这样的工具？让我们白手起家建一个！</p>
<p>在这篇文章的最后，我们将有一个简单易用的底层数据包跟踪器。如果您 ping 本地 Docker 容器，它将显示如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div></pre></td></tr></table></figure>

<h2 id="追踪救援_(Tracing_to_the_rescue)">追踪救援 (Tracing to the rescue)</h2>
<p>走出迷宫的一种方法是探索。这就是你走出迷宫时所做的。另一种走出迷宫的方法是改变你的观点，从上帝的视角，观察那些知道这条路的人所走的路。</p>
<p>在 Linux 术语中，这意味着转向内核视角，其中网络命名空间只是标签，而不是“容器”1。在内核中，数据包、接口等是普通的可观察对象。</p>
<p>在这篇文章中，我将重点介绍 2 个跟踪工具： perf 和 eBPF。</p>
<h2 id="介绍_perf_和_eBPF">介绍 perf 和 eBPF</h2>
<p>perf是 Linux 上每个性能相关分析的基准工具。它是在与 Linux 内核相同的源代码树中开发的，必须针对您将用于跟踪的内核进行专门编译。它可以跟踪内核以及用户程序。它还可以通过采样或使用跟踪点来工作。可以将其视为比strace的巨大超集，且开销要低得多的。本文我们只以非常简单的方式使用它。如果您想了解更多有关 perf 的知识 ，我强烈建议您访问 Brendan Gregg 的<a href="http://www.brendangregg.com/perf.html" target="_blank" rel="external">博客</a>。</p>
<p>eBPF 是 Linux 内核相对最近才添加的功能。顾名思义,这是BPF字节码(即“伯克利数据包过滤器”,用于在BSD家族系统上过滤数据包)的扩展版本。在 Linux上,如果满足一些安全标准,它也可以用来在运行时内核中安全地运行与平台无关的代码。例如,在程序运行之前会验证内存访问,并且必须能证明该程序会在受限的时间内结束。即使程序本身是安全的并且总是会终止,如果内核无法证明这一点,该程序也会被拒绝。</p>
<p>这样的程序可以用作QOS的网络分类器,非常底层的网络和过滤可以使用eXpress数据平面(XDP),这些程序作为跟踪代理以及许多其他场景。跟踪探针可以附加到<code>/proc/kallsyms</code>中的任意函数或任何跟踪点。在这篇文章中,我将重点介绍附加到跟踪点(tracepoint)的跟踪代理。</p>
<p>有关附加到内核函数的跟踪探针的示例或作为更详细的介绍,请阅读我之前关于eBPF的<a href="https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/" target="_blank" rel="external">文章</a>。</p>
<h2 id="实验室设置">实验室设置</h2>
<p>对于这篇文章,我们需要perf和一些用于eBPF的工具。由于我不是手写汇编代码的忠实拥趸,所以这里我将使用<a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc</a>。这是一个强大且灵活的工具,允许你用受限的C语言编写内核探针,并在用户空间用Python进行检测。对于生产环境来说可能过重,但对于开发非常完美!</p>
<p>在这里我重述在Ubuntu 17.04(Zesty)上的安装说明,这是我笔记本电脑所使用的操作系统。从其他发行版到“perf”的说明不应该有太大的差异,而特定的bcc安装说明可以在<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md" target="_blank" rel="external">github</a>上找到。</p>
<blockquote>
<p>注意:将eBPF附加到跟踪点至少需要Linux内核版本高于4.7。</p>
</blockquote>
<p>安装 perf:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 安装</div><div class="line"><span class="built_in">sudo</span> apt install linux-tools-generic</div><div class="line"></div><div class="line"><span class="comment"># 测试</span></div><div class="line">perf</div></pre></td></tr></table></figure>

<p>如果看到错误信息,很可能是你的内核最近更新了但是操作系统还没有重启。</p>
<p>安装 bcc:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装原来</span></div><div class="line"><span class="built_in">sudo</span> apt install bison build-essential cmake flex git libedit-dev python zlib1g-dev libelf-dev libllvm4.<span class="number">0</span> llvm-dev libclang-dev luajit luajit-<span class="number">5.1</span>-dev</div><div class="line"></div><div class="line"><span class="comment"># 获取bcc源代码</span></div><div class="line">git clone https://github.com/iovisor/bcc.git</div><div class="line"></div><div class="line"><span class="comment"># 编译并安装</span></div><div class="line">mkdir bcc/build</div><div class="line"><span class="built_in">cd</span> bcc/build</div><div class="line">cmake .. -DCMAKE_INSTALL_PREFIX=/usr</div><div class="line">make</div><div class="line"><span class="built_in">sudo</span> make install</div></pre></td></tr></table></figure>

<h2 id="寻找好的跟踪点,也就是“用_perf_手动跟踪数据包的旅程”">寻找好的跟踪点,也就是“用 perf 手动跟踪数据包的旅程”</h2>
<p>有多种方法可以找到好的跟踪点。在这篇文章的早期版本中,我从 veth 驱动的代码开始,并从那里追踪函数调用来找到要跟踪的函数。虽然它确实导致了可以接受的结果,但我无法捕获所有的包。的确,所有数据包共同经过的路径都在未导出的(内联或静态)方法中。这就是我意识到 Linux 有跟踪点并决定重写这篇文章及相关代码使用跟踪点而不是函数。这很令人沮丧,但对我来说也更有趣。</p>
<p>我废话太多了，言归正传。</p>
<p>我们的目标是跟踪数据包所经历的路径。根据它们所经过的接口, 它们经过的跟踪点可能会有所不同(剧透:它们确实不同)。</p>
<p>为了找到合适的跟踪点,我在使用 perf trace时 ping了2个内部目的IP和2个外部的目的IP：</p>
<ul>
<li>localhost,IP 为 127.0.0.1</li>
<li>一个“无辜的” Docker 容器,IP 为 172.17.0.2</li>
<li>通过 USB 共享网络的我的手机,IP 为 192.168.42.129</li>
<li>通过 WiFi 的我的手机,IP 为 192.168.43.1</li>
</ul>
<p><code>perf trace</code> 是 perf 命令的一个子命令,默认情况下会产生类似于strace的输出(开销更小)。我们可以轻松地调整它,隐藏系统调用本身,只打印“net”类别的事件。例如,跟踪ping一个IP为172.17.0.2的Docker容器看起来像这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> perf trace --no-syscalls --event <span class="string">'net:*'</span> ping <span class="number">172.17</span>.<span class="number">0.2</span> -c1 &gt; /dev/null</div><div class="line">     <span class="number">0.000</span> net:net_dev_queue:dev=docker0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.008</span> net:net_dev_start_xmit:dev=docker0 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988700 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">0</span> len=<span class="number">98</span> data_len=<span class="number">0</span> network_offset=<span class="number">14</span> transport_offset_valid=<span class="number">1</span> transport_offset=<span class="number">34</span> tx_flags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_segs=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.014</span> net:net_dev_queue:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.016</span> net:net_dev_start_xmit:dev=veth79215ff queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988700 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">0</span> len=<span class="number">98</span> data_len=<span class="number">0</span> network_offset=<span class="number">14</span> transport_offset_valid=<span class="number">1</span> transport_offset=<span class="number">34</span> tx_flags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_segs=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.020</span> net:netif_rx:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.022</span> net:net_dev_xmit:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span> rc=<span class="number">0</span>)</div><div class="line">     <span class="number">0.024</span> net:net_dev_xmit:dev=docker0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">98</span> rc=<span class="number">0</span>)</div><div class="line">     <span class="number">0.027</span> net:netif_receive_skb:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988700 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.044</span> net:net_dev_queue:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.046</span> net:net_dev_start_xmit:dev=eth0 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988b00 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">0</span> len=<span class="number">98</span> data_len=<span class="number">0</span> network_offset=<span class="number">14</span> transport_offset_valid=<span class="number">1</span> transport_offset=<span class="number">34</span> tx_flags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_segs=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.048</span> net:netif_rx:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.050</span> net:net_dev_xmit:dev=eth0 skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">98</span> rc=<span class="number">0</span>)</div><div class="line">     <span class="number">0.053</span> net:netif_receive_skb:dev=veth79215ff skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.060</span> net:netif_receive_skb_entry:dev=docker0 napi_id=<span class="number">0</span>x3 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff96d481988b00 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">2</span> <span class="built_in">hash</span>=<span class="number">0</span>x00000000 l4_<span class="built_in">hash</span>=<span class="number">0</span> len=<span class="number">84</span> data_len=<span class="number">0</span> truesize=<span class="number">768</span> mac_header_valid=<span class="number">1</span> mac_header=-<span class="number">14</span> nr_frags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div><div class="line">     <span class="number">0.061</span> net:netif_receive_skb:dev=docker0 skbaddr=<span class="number">0</span>xffff96d481988b00 len=<span class="number">84</span>)</div></pre></td></tr></table></figure>

<p>仅保留事件名称和 skbaddr，这看起来更具可读性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">net_dev_queue           dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_start_xmit      dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_queue           dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_start_xmit      dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">netif_rx                dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_xmit            dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">net_dev_xmit            dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line">netif_receive_skb       dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988700</div><div class="line"></div><div class="line">net_dev_queue           dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">net_dev_start_xmit      dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_rx                dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">net_dev_xmit            dev=eth0        skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_receive_skb       dev=veth79215ff skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_receive_skb_entry dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988b00</div><div class="line">netif_receive_skb       dev=docker0     skbaddr<span class="number">=0</span>xffff96d481988b00</div></pre></td></tr></table></figure>

<p>这里有几点需要说明。最明显的是<code>skbaddr</code>在中间发生了变化,但其他时候保持不变, 这是发生中echo reply数据包作为对该echo request(ping)的回复生成时。在其他时间,同一网络数据包在接口之间移动,希望没有复制。复制是昂贵的...</p>
<p>另一个有趣的点是,我们明确看到数据包经过docker0网桥,然后是veth的主机端,在我的例子中是veth79215ff,最后是veth的容器端,假装是eth0。我们还没有看到网络命名空间,但它已经给出了很好的概览。</p>
<p>最后,在看到eth0上的数据包之后,我们按相反顺序看到了跟踪点。这不是响应,而是传输的最终目的路径。</p>
<p>通过在4种目标场景中重复类似的过程,我们可以选择最合适的跟踪点来跟踪数据包的旅程。我选择了其中的4个:</p>
<ul>
<li><code>net_dev_queue</code></li>
<li><code>netif_receive_skb_entry</code></li>
<li><code>netif_rx</code></li>
<li><code>napi_gro_receive_entry</code></li>
</ul>
<p>采用这4个跟踪点将按顺序为我提供跟踪事件,没有重复,节省了一些去重工作。仍然是一个非常好的选择。</p>
<p>我们可以轻松地对这个选择进行双重检查,像这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> perf trace --no-syscalls           \</div><div class="line">  --event <span class="string">'net:net_dev_queue'</span>           \</div><div class="line">  --event <span class="string">'net:netif_receive_skb_entry'</span> \</div><div class="line">  --event <span class="string">'net:netif_rx'</span>                \</div><div class="line">  --event <span class="string">'net:napi_gro_receive_entry'</span>  \</div><div class="line">  ping <span class="number">172.17</span>.<span class="number">0.2</span> -c1 &gt; /dev/null</div><div class="line">     <span class="number">0.000</span> net:net_dev_queue:dev=docker0 skbaddr=<span class="number">0</span>xffff8e847720a900 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.010</span> net:net_dev_queue:dev=veth7781d5c skbaddr=<span class="number">0</span>xffff8e847720a900 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.014</span> net:netif_rx:dev=eth0 skbaddr=<span class="number">0</span>xffff8e847720a900 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.034</span> net:net_dev_queue:dev=eth0 skbaddr=<span class="number">0</span>xffff8e849cb8<span class="built_in">cd</span>00 len=<span class="number">98</span>)</div><div class="line">     <span class="number">0.036</span> net:netif_rx:dev=veth7781d5c skbaddr=<span class="number">0</span>xffff8e849cb8<span class="built_in">cd</span>00 len=<span class="number">84</span>)</div><div class="line">     <span class="number">0.045</span> net:netif_receive_skb_entry:dev=docker0 napi_id=<span class="number">0</span>x1 queue_mapping=<span class="number">0</span> skbaddr=<span class="number">0</span>xffff8e849cb8<span class="built_in">cd</span>00 vlan_tagged=<span class="number">0</span> vlan_proto=<span class="number">0</span>x0000 vlan_tci=<span class="number">0</span>x0000 protocol=<span class="number">0</span>x0800 ip_summed=<span class="number">2</span> <span class="built_in">hash</span>=<span class="number">0</span>x00000000 l4_<span class="built_in">hash</span>=<span class="number">0</span> len=<span class="number">84</span> data_len=<span class="number">0</span> truesize=<span class="number">768</span> mac_header_valid=<span class="number">1</span> mac_header=-<span class="number">14</span> nr_frags=<span class="number">0</span> gso_size=<span class="number">0</span> gso_<span class="built_in">type</span>=<span class="number">0</span>)</div></pre></td></tr></table></figure>

<p>任务完成!</p>
<p>如果你想更进一步,探索可用网络跟踪点的列表,你可以使用 perf list:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> perf list <span class="string">'net:*'</span></div></pre></td></tr></table></figure>

<p>这应该会返回一个像<code>net:netif_rx</code>这样的跟踪点名称列表。冒号前的部分(&#39;net&#39;)是事件类别;冒号后的是该类别中的事件名称。</p>
<h2 id="使用eBPF_/_bcc编写自定义跟踪器">使用eBPF / bcc编写自定义跟踪器</h2>
<p>对大多数情况来说,这已经远远超出需求了。如果你读这篇文章是为了学习如何在Linux系统上跟踪数据包的旅程,你已经获取了所有需要的信息。但是,如果你想更深入地研究,运行自定义过滤器,跟踪更多的数据,如数据包经过的网络命名空间或源和目的IP,请继续跟我走。</p>
<p>从Linux内核4.7开始,可以将eBPF程序附加到内核跟踪点上。在此之前,构建此跟踪器的唯一替代方法是将探针附加到导出的内核符号上。尽管这种方法可行,但它有一些缺点:</p>
<ul>
<li>内核内部API不稳定。跟踪点是稳定的(尽管数据结构不一定是...)。</li>
<li>出于性能考虑,大多数网络内部函数是内联的或静态的。它们都不能被探测。</li>
<li>找到所有这些函数的潜在调用点很麻烦,有时在这一阶段不可用所需的所有数据。</li>
</ul>
<p>本文的早期版本尝试使用kprobes,它们更易于使用,但结果却是不完整的。</p>
<p>现在，让我们坦诚一点，通过跟踪点访问数据要比使用它们的 kprobe 对应物要繁琐得多。虽然我尽量保持这篇文章尽可能易懂，但您可能希望从我<a href="https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/" target="_blank" rel="external">先前的一篇文章</a>开始。</p>
<p>撇开这个声明，让我们从一个简单的 Hello World 程序开始介绍。在这个 Hello World 示例中，每当我们选择的 4 个跟踪点之一被触发时（net_dev_queue、netif_receive_skb_entry、netif_rx 和 napi_gro_receive_entry），我们将建立一个事件。为了在这个阶段保持简单，我们将发送程序的 comm，即一个 16 个字符的字符串，基本上是程序的名称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bcc/proto.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;linux/sched.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Event structure</span></div><div class="line"><span class="keyword">struct</span> route_evt_t {</div><div class="line">        <span class="keyword">char</span> comm[TASK_COMM_LEN];</div><div class="line">};</div><div class="line">BPF_PERF_OUTPUT(route_evt);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> do_trace(<span class="keyword">void</span>* ctx, <span class="keyword">struct</span> sk_buff* skb)</div><div class="line">{</div><div class="line">    <span class="comment">// Built event for userland</span></div><div class="line">    <span class="keyword">struct</span> route_evt_t evt = {};</div><div class="line">    bpf_get_current_comm(evt.comm, TASK_COMM_LEN);</div><div class="line"></div><div class="line">    <span class="comment">// Send event to userland</span></div><div class="line">    route_evt.perf_submit(ctx, &evt, <span class="keyword">sizeof</span>(evt));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * Attach to Kernel Tracepoints</div><div class="line">  */</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, netif_rx) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, net_dev_queue) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, napi_gro_receive_entry) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div><div class="line"></div><div class="line">TRACEPOINT_PROBE(net, netif_receive_skb_entry) {</div><div class="line">    <span class="keyword">return</span> do_trace(args, (<span class="keyword">struct</span> sk_buff*)args-&gt;skbaddr);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个代码片段会连接到“net”类别的 4 个跟踪点，加载<code>skbaddr</code>字段，并将其传递给通用部分，目前通用部分仅加载程序名称。如果您想知道这个 <code>args-&gt;skbaddr</code> 是从哪里来的（我很高兴您这样想），<code>args</code> 结构是由 <code>bcc</code> 为您生成的，每当您使用 TRACEPOINT_PROBE 定义一个跟踪点时，它都会为您生成。由于它是即时生成的，没有简单的方法来查看它的定义，但是有更好的方法。我们可以直接查看来自内核的数据源。幸运的是，每个跟踪点都有一个 <code>/sys/kernel/debug/tracing/events</code> 条目。例如，对于 net:netif_rx，您可以只运行命令 <code>cat /sys/kernel/debug/tracing/events/net/netif_rx/format</code>，这应该会输出类似于以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">name: netif_rx</div><div class="line">ID: <span class="number">1183</span></div><div class="line">format:</div><div class="line">	field:unsigned short common_<span class="built_in">type</span>;         offset:<span class="number">0</span>; size:<span class="number">2</span>; signed:<span class="number">0</span>;</div><div class="line">	field:unsigned char common_flags;         offset:<span class="number">2</span>; size:<span class="number">1</span>; signed:<span class="number">0</span>;</div><div class="line">	field:unsigned char common_preempt_count; offset:<span class="number">3</span>; size:<span class="number">1</span>; signed:<span class="number">0</span>;</div><div class="line">	field:int common_pid;                     offset:<span class="number">4</span>; size:<span class="number">4</span>; signed:<span class="number">1</span>;</div><div class="line"></div><div class="line">	field:void * skbaddr;         offset:<span class="number">8</span>;  size:<span class="number">8</span>; signed:<span class="number">0</span>;</div><div class="line">	field:unsigned int len;       offset:<span class="number">16</span>; size:<span class="number">4</span>; signed:<span class="number">0</span>;</div><div class="line">	field:__data_loc char[] name; offset:<span class="number">20</span>; size:<span class="number">4</span>; signed:<span class="number">1</span>;</div><div class="line"></div><div class="line">print fmt: <span class="string">"dev=%s skbaddr=%p len=%u"</span>, __get_str(name), REC-&gt;skbaddr, REC-&gt;len</div></pre></td></tr></table></figure>

<p>您可能会注意到记录末尾的打印 fmt 行。这正是 <code>perf trace</code> 用来生成其输出的内容。</p>
<p>有了底层基础代码，并且你已了解了它，我们可以将其包装在一个 Python 脚本中，以显示 eBPF 探针发送的每个事件的一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> inet_ntop</div><div class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</div><div class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> ct</div><div class="line"></div><div class="line">bpf_text = <span class="string">'''&lt;SEE CODE SNIPPET ABOVE&gt;'''</span></div><div class="line"></div><div class="line">TASK_COMM_LEN = <span class="number">16</span> <span class="comment"># linux/sched.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteEvt</span><span class="params">(ct.Structure)</span>:</span></div><div class="line">    _fields_ = [</div><div class="line">        (<span class="string">"comm"</span>,    ct.c_char * TASK_COMM_LEN),</div><div class="line">    ]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">event_printer</span><span class="params">(cpu, data, size)</span>:</span></div><div class="line">    <span class="comment"># Decode event</span></div><div class="line">    event = ct.cast(data, ct.POINTER(RouteEvt)).contents</div><div class="line"></div><div class="line">    <span class="comment"># Print event</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"Just got a packet from %s"</span> % (event.comm)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    b = BPF(text=bpf_text)</div><div class="line">    b[<span class="string">"route_evt"</span>].open_perf_buffer(event_printer)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        b.kprobe_poll()</div></pre></td></tr></table></figure>

<p>您现在可以测试它了。您需要以 root 权限运行。</p>
<blockquote>
<p>请注意：在这个阶段我们没有对包进行筛选。即使是网络使用很低情况也可能会让你的终端刷屏</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$&gt; <span class="built_in">sudo</span> python ./tracepkt.py</div><div class="line">...</div><div class="line">Just got a packet from ping6</div><div class="line">Just got a packet from ping6</div><div class="line">Just got a packet from ping</div><div class="line">Just got a packet from irq/<span class="number">46</span>-iwlwifi</div><div class="line">...</div></pre></td></tr></table></figure>

<p>在这种情况下，您可以看到我正在使用 ping 和 ping6，WiFi 驱动程序刚刚接收了一些数据包。在这种情况下，这是echo reply。</p>
<p>现在让我们开始添加一些有用的数据/筛选条件。</p>
<p>在本文中，我不会重点关注性能。这将更好地展示 eBPF 的功能和限制。要使它（明显）更快，我们可以使用数据包大小作为筛选，假设没有设置“奇怪的” IP 选项。使用这个示例程序会减慢您的网络流量。</p>
<blockquote>
<p>请注意：为了限制此帖子的长度，我将在此处专注于 C/eBPF 部分。我会在帖子末尾放置完整源代码的链接。</p>
</blockquote>
<h2 id="添加网络接口信息">添加网络接口信息</h2>
<p>首先，您可以安全地删除“comm”资源、加载和 sched.h 标头。在这里它没有真正用处，抱歉。</p>
<p>然后，您可以包含 <code>net/inet_sock.h</code>，以便我们有必要的声明，并向事件结构中添加 <code>char ifname[IFNAMSIZ];</code>。</p>
<p>现在，我们将从设备结构中加载设备名称。这很有趣，因为这是一个实际有用的信息，并且在可管理的范围内演示了加载任何数据的技术：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 得到设备指针</span></div><div class="line"><span class="keyword">struct</span> net_device *dev;</div><div class="line">bpf_probe_read(&dev, <span class="keyword">sizeof</span>(skb-&gt;dev), ((<span class="keyword">char</span>*)skb) + offsetof(typeof(*skb), dev));</div><div class="line"></div><div class="line"><span class="comment">// 加载网络接口名称</span></div><div class="line">bpf_probe_read(&evt.ifname, IFNAMSIZ, dev-&gt;name);</div></pre></td></tr></table></figure>

<p>您可以测试它，它可以正常工作。但不要忘记在 Python 部分添加相关的代码 :)</p>
<p>好的，它是如何工作的呢？为了加载接口名称，我们需要接口设备结构。我将从最后一个语句开始解释，因为它最容易理解，前一个实际上只是更复杂的版本。它使用 bpf_probe_read 从 dev-&gt;name 读取长度为 IFNAMSIZ 的数据，并将其复制到 evt.ifname。第一行遵循完全相同的逻辑。它将 <code>skb-&gt;dev</code> 指针的值加载到 <code>dev</code> 中。不幸的是，我没有找到另一种在没有 <code>offsetof / typeof</code> 花招的情况下加载字段地址的方法。</p>
<p>作为提醒，eBPF 的目标是允许对内核进行安全脚本化。这意味着禁止随机内存访问。所有内存访问必须经过验证。除非您访问的内存位于堆栈上，否则需要使用 bpf_probe_read 读取访问器。这使得代码阅读/编写起来很繁琐，但也使其更安全。bpf_probe_read 在内核中的 bpf_trace.c 中定义。其中有一些有趣的部分：</p>
<ol>
<li>它类似于 memcpy。请注意复制对性能的成本。</li>
<li>如果出现错误，它将返回一个初始化为 0 的缓冲区并返回一个错误。它不会崩溃或停止程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> member_read(destination, source_struct, source_member)                 \</span></div><div class="line"> <span class="keyword">do</span>{                                                                          \</div><div class="line">   bpf_probe_read(                                                            \</div><div class="line">     destination,                                                             \</div><div class="line">     <span class="keyword">sizeof</span>(source_struct-&gt;source_member),                                    \</div><div class="line">     ((<span class="keyword">char</span>*)source_struct) + offsetof(typeof(*source_struct), source_member) \</div><div class="line">   );                                                                         \</div><div class="line"> } <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>

<p>这使得我们可以编写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">member_read(&dev, skb, dev);</div></pre></td></tr></table></figure>

<p>好极了!</p>
<h2 id="添加网络命名空间_ID">添加网络命名空间 ID</h2>
<p>这可能是最有价值的信息。就其本身而言，它是所有这些努力的正当理由。不幸的是，这也是最难加载的。</p>
<p>命名空间标识符可以从以下两个地方加载：</p>
<ul>
<li>socket&#39;sk&#39; 结构</li>
<li>设备 &#39;dev&#39; 结构</li>
</ul>
<p>最初，我使用套接字结构，因为这是我在编写 <a href="https://github.com/iovisor/bcc/blob/master/tools/solisten.py" target="_blank" rel="external">solisten.py</a> 时使用的结构。不过，不知为何，一旦数据包跨越命名空间边界，命名空间标识符就不再可读。该字段全为0，这是一个明显的无效内存访问的指示器（请记住 bpf_probe_read 在出现错误时的工作原理），并且破坏了整个目的。</p>
<p>幸运的是，设备方法有效。可以将其看作是询问数据包在哪个接口上以及接口属于哪个命名空间的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> net* net;</div><div class="line"></div><div class="line"><span class="comment">// Get netns id. Equivalent to: evt.netns = dev-&gt;nd_net.net-&gt;ns.inum</span></div><div class="line">possible_net_t *skc_net = &dev-&gt;nd_net;</div><div class="line">member_read(&net, skc_net, net);</div><div class="line"><span class="keyword">struct</span> ns_common* ns = member_address(net, ns);</div><div class="line">member_read(&evt.netns, ns, inum);</div></pre></td></tr></table></figure>

<p>使用以下附加宏以提高可读性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">define</span> member_address(source_struct, source_member) \</span></div><div class="line">({                                                   \</div><div class="line">  <span class="keyword">void</span>* __ret;                                       \</div><div class="line">  __ret = (<span class="keyword">void</span>*) (((<span class="keyword">char</span>*)source_struct) + offsetof(typeof(*source_struct), source_member)); \</div><div class="line">  __ret;                                             \</div><div class="line">})</div></pre></td></tr></table></figure>

<p>将这些部分组合在一起，然后... 完成！</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$&gt; <span class="built_in">sudo</span> python ./tracepkt.py</div><div class="line">[  <span class="number">4026531957</span>]          docker0</div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6</div><div class="line">[  <span class="number">4026532258</span>]             eth0</div><div class="line">[  <span class="number">4026532258</span>]             eth0</div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6</div><div class="line">[  <span class="number">4026531957</span>]          docker0</div></pre></td></tr></table></figure>

<p>如果您向 Docker 容器发送 ping，您应该会看到这个。数据包通过本地的 docker0 桥接器传递，然后移动到 veth 对，跨越了网络命名空间边界，回复沿着完全相反的路径返回。</p>
<p>回复这确实是一个棘手的问题！</p>
<h2 id="更进一步：只跟踪request_reply_和_echo_reply_数据包">更进一步：只跟踪request reply 和 echo reply 数据包</h2>
<p>作为奖励，我们还将加载数据包的 IP 地址。无论如何，我们都必须读取 IP 标头。我将在这里坚持使用 IPv4，但相同的逻辑适用于IPv6。</p>
<p>坏消息是，没有什么是真正简单的。请记住，我们正在处理内核，在网络路径中。某些数据包尚未打开。这意味着某些标头偏移仍未初始化。我们将不得不计算它的所有，从 MAC 标头到 IP 标头，最后到 ICMP 标头。</p>
<p>让我们先轻轻松松地加载 MAC 标头地址，并推导出 IP 标头地址。我们不会加载 MAC 标头本身，而是假设它的长度为 14 字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Compute MAC header address</span></div><div class="line"><span class="keyword">char</span>* head;</div><div class="line">u16 mac_header;</div><div class="line"></div><div class="line">member_read(&head,       skb, head);</div><div class="line">member_read(&mac_header, skb, mac_header);</div><div class="line"></div><div class="line"><span class="comment">// Compute IP Header address</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MAC_HEADER_SIZE 14;</span></div><div class="line"><span class="keyword">char</span>* ip_header_address = head + mac_header + MAC_HEADER_SIZE;</div></pre></td></tr></table></figure>

<p>这基本上意味着 IP 标头从 <code>skb-&gt;head + skb-&gt;mac_header + MAC_HEADER_SIZE;</code> 开始。</p>
<p>现在，我们可以解码 IP 标头中的 IP 版本，即第一个字节的前 4 位，确保它是 IPv4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载ip的版本</span></div><div class="line">u8 ip_version;</div><div class="line">bpf_probe_read(&ip_version, <span class="keyword">sizeof</span>(u8), ip_header_address);</div><div class="line">ip_version = ip_version &gt;&gt; <span class="number">4</span> & <span class="number">0xf</span>;</div><div class="line"></div><div class="line"><span class="comment">// 过滤 IPv4 packets</span></div><div class="line"><span class="keyword">if</span> (ip_version != <span class="number">4</span>) {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，我们加载完整的 IP 标头，提取 IP 地址以使 Python 信息更有用，确保下一个标头是 ICMP，并推导出 ICMP 标头偏移量。下面是所有这些操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Load IP Header</span></div><div class="line"><span class="keyword">struct</span> iphdr iphdr;</div><div class="line">bpf_probe_read(&iphdr, <span class="keyword">sizeof</span>(iphdr), ip_header_address);</div><div class="line"></div><div class="line"><span class="comment">// Load protocol and address</span></div><div class="line">u8 icmp_offset_from_ip_header = iphdr.ihl * <span class="number">4</span>;</div><div class="line">evt.saddr[<span class="number">0</span>] = iphdr.saddr;</div><div class="line">evt.daddr[<span class="number">0</span>] = iphdr.daddr;</div><div class="line"></div><div class="line"><span class="comment">// Filter ICMP packets</span></div><div class="line"><span class="keyword">if</span> (iphdr.protocol != IPPROTO_ICMP) {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后，我们可以加载 ICMP 标头本身，确保这是一个echo request of reply，并从中加载 id 和 seq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Compute ICMP header address and load ICMP header</span></div><div class="line"><span class="keyword">char</span>* icmp_header_address = ip_header_address + icmp_offset_from_ip_header;</div><div class="line"><span class="keyword">struct</span> icmphdr icmphdr;</div><div class="line">bpf_probe_read(&icmphdr, <span class="keyword">sizeof</span>(icmphdr), icmp_header_address);</div><div class="line"></div><div class="line"><span class="comment">// Filter ICMP echo request and echo reply</span></div><div class="line"><span class="keyword">if</span> (icmphdr.type != ICMP_ECHO && icmphdr.type != ICMP_ECHOREPLY) {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Get ICMP info</span></div><div class="line">evt.icmptype = icmphdr.type;</div><div class="line">evt.icmpid   = icmphdr.un.echo.id;</div><div class="line">evt.icmpseq  = icmphdr.un.echo.sequence;</div><div class="line"></div><div class="line"><span class="comment">// Fix endian</span></div><div class="line">evt.icmpid  = be16_to_cpu(evt.icmpid);</div><div class="line">evt.icmpseq = be16_to_cpu(evt.icmpseq);</div></pre></td></tr></table></figure>

<p>这就是全部内容！</p>
<p>如果您想从特定 ping 实例中过滤 ICMP，您可以假定 evt.icmpid 是 Linux 的 ping 的 PID。</p>
<h2 id="是时候展示了！">是时候展示了！</h2>
<p>启动程序，然后在另一个终端中运行一些 &quot;ping&quot; 命令，观察结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 localhost</span></div><div class="line">[  <span class="number">4026531957</span>]               lo request <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]               lo request <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]               lo   reply <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]               lo   reply <span class="comment">#20212.001 127.0.0.1 -&gt; 127.0.0.1</span></div></pre></td></tr></table></figure>

<p>一个 ICMP echo request由进程 20212 发送（Linux 的 ping 中的 ICMP id）通过回环接口发送，传递到完全相同的回环接口，其中生成并发送回一个echo reply。回环接口既是发出接口也是接收接口。</p>
<p>那么 WiFi 网关呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 192.168.43.1</span></div><div class="line">[  <span class="number">4026531957</span>]           wlp2s0 request <span class="comment">#20710.001 192.168.43.191 -&gt; 192.168.43.1</span></div><div class="line">[  <span class="number">4026531957</span>]           wlp2s0   reply <span class="comment">#20710.001 192.168.43.1 -&gt; 192.168.43.191</span></div></pre></td></tr></table></figure>

<p>在这种情况下，echo request和echo reply通过 WiFi 接口进行。很容易。</p>
<p>稍微不相关的一点是，还记得当我们只打印拥有数据包的进程的“comm”时吗？在这种情况下，echo request将属于 ping 进程，而reply将属于 WiFi 驱动程序，因为在 Linux 视角下，WiFi 驱动程序是生成回复的进程。</p>
<p>最后一个，也是我个人最喜欢的，ping 一个 Docker 容器。这不是因为 Docker，而是因为它最好地展示了 eBPF 的强大之处。它允许构建了一个类似于 &quot;x-ray&quot; 的工具，用于分析 ping。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping -4 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0 request <span class="comment">#17146.001 172.17.0.1 -&gt; 172.17.0.2</span></div><div class="line">[  <span class="number">4026532258</span>]             eth0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]      vetha373ab6   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div><div class="line">[  <span class="number">4026531957</span>]          docker0   reply <span class="comment">#17146.001 172.17.0.2 -&gt; 172.17.0.1</span></div></pre></td></tr></table></figure>

<p>经过一些处理，现在看起来如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       Host netns           | Container netns</div><div class="line">+---------------------------+-----------------+</div><div class="line">| docker0 ---&gt; veth0e65931 ---&gt; eth0          |</div><div class="line">+---------------------------+-----------------+</div></pre></td></tr></table></figure>

<h2 id="最后的话">最后的话</h2>
<p>eBPF/bcc使我们能够编写一系列新的工具，用于深度故障排除、跟踪和追踪先前无法通过内核补丁到达的地方的问题。跟踪点也非常方便，因为它们为我们提供了有趣的位置的良好提示，消除了繁琐阅读内核代码的需要，并可以放置在从 kprobe 中无法访问的代码部分，例如内联或静态函数。</p>
<p>要进一步深入，我们可以添加 IPv6 支持。这很容易做到，我将把它作为读者的练习留下。理想情况下，我希望能够衡量性能的影响。但是这篇帖子已经非常长了。通过跟踪路由和 iptables 决策以及 ARP 数据包，改进这个工具可能会很有趣。所有这些将使这个工具成为像我这样的人的完美“X光”数据包跟踪器，有时需要应对复杂的Linux网络设置。</p>
<p>正如承诺的那样，您可以在Github上查看完整的代码（带有IPv6支持）：<a href="https://github.com/yadutaf/tracepkt" target="_blank" rel="external">https://github.com/yadutaf/tracepkt</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://blog.yadutaf.fr/2017/07/28/tracing-a-packet-journey-using-linux-tracepoints-perf-ebpf/" target="_blank" rel="external">Tracing a packet journey using Linux tracepoints, perf and eBPF</a></p>
<p>很久以来我一直在寻找一个底层的Linux网络调试工具。<br>我一直在寻找一个低级的Linux网络调试工具已经有一段时间了。Linux 允许使用虚拟接口(virtual interface)和网络命名空间(network namespace)的组合来构建直接在主机上运行的复杂网络。当出现问题时，故障排除相当乏味。如果这是 L3 路由问题，mtr则很有可能会有所帮助。但是，如果这是一个较低层的问题，我通常会手动检查每个接口/网桥/网络命名空间/iptables并启动几个tcpdump，以尝试了解正在发生的事情。如果您事先不了解网络设置，这可能感觉像走迷宫。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mping: 使用新的icmp库实现探测和压测工具]]></title>
    <link href="https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/"/>
    <id>https://colobu.com/2023/09/10/mping-a-multi-targets-high-frequency-pressure-measuring-and-detection-tool/</id>
    <published>2023-09-10T14:02:15.000Z</published>
    <updated>2023-09-24T07:01:49.816Z</updated>
    <content type="html"><![CDATA[<p>项目地址： <a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a></p>
<p>最近在网络探测的分析中，需要做一个使用ICMP协议进行压测的工具， ping或者fping多多少少都不满足需求，所以需要自己写一个。</p>
<p>使用<a href="https://pkg.go.dev/golang.org/x/net/icmp" target="_blank" rel="external">golang.org/x/net/icmp</a>很容易的实现基于ICMP的工具， <a href="https://github.com/go-ping/ping" target="_blank" rel="external">go-ping</a>就算了，既缺乏维护性能也不佳。所以我最初使用Go官方扩展库实现了这个工具，不过这几天我看到Matt Layher刚推出一个新的ICMP库：<a href="https://github.com/mdlayher/icmpx" target="_blank" rel="external">mdlayher/icmpx</a>， 我决定尝试一下。Matt Layher 是Go网络编程的专家，写了好几个网络相关的库，所以我对他的库还是蛮有信心的。</p>
<a id="more"></a>
<p>而且我在使用这个库的过程中，给他提了一个需求，希望能增加设置TOS的功能，他当天就给加上了，少有的活跃和友善的开源作者。</p>
<p>这个库的使用也非常简单，<code>ReadFrom</code>用来读，<code>WriteTo</code>用来发， <code>Close</code>用来关闭， <code>SetTOS</code>是我提的一个需求，可以设置TOS值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IPv4Conn</div><div class="line">    <span class="keyword">func</span> ListenIPv4(ifi *net.Interface, cfg IPv4Config) (*IPv4Conn, error)</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) Close() error</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) ReadFrom(ctx context.Context) (*icmp.Message, netip.Addr, error)</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) SetTOS(tos <span class="typename">int</span>) error</div><div class="line">    <span class="keyword">func</span> (c *IPv4Conn) WriteTo(ctx context.Context, msg *icmp.Message, dst netip.Addr) error</div></pre></td></tr></table></figure>

<p>当然它还有对应的IPv6版本，功能类似，我们就不介绍了，本文只介绍IPv4的功能。</p>
<p>先前我在我的网站和公众号发表过一篇文章<a href="https://colobu.com/2023/04/26/write-the-ping-tool-in-Go/" target="_blank" rel="external">使用Go实现ping工具</a>,介绍了几种实现ping的方式，这一次，我使用另外一个方法，使用一个新的ICMP库，实现一个真正落地使用的工具。</p>
<p>我把这个工具的实现分为四个部分：</p>
<ul>
<li>主程序：  程序的入口，主要解析各种参数</li>
<li>发送函数：发送ICMP数据</li>
<li>接收函数：接收ICMP回包</li>
<li>统计输出：输出每个周期的丢包率和时延</li>
</ul>
<p>接下来我分别介绍。这个程序的代码在 <a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a></p>
<h2 id="主程序入口">主程序入口</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	count        = pflag.IntP(<span class="string">"count"</span>, <span class="string">"c"</span>,<span class="number"> 0</span>, <span class="string">"count, 0 means non-setting"</span>)</div><div class="line">	tos          = pflag.IntP(<span class="string">"tos"</span>, <span class="string">"z"</span>,<span class="number"> 0</span>, <span class="string">"tos, 0 means non-setting"</span>)</div><div class="line">	packetSize   = pflag.IntP(<span class="string">"size"</span>, <span class="string">"s"</span>,<span class="number"> 64</span>, <span class="string">"packet size"</span>)</div><div class="line">	timeout      = pflag.DurationP(<span class="string">"timeout"</span>, <span class="string">"t"</span>, time.Second, <span class="string">"timeout"</span>)</div><div class="line">	rate         = pflag.IntP(<span class="string">"rate"</span>, <span class="string">"r"</span>,<span class="number"> 100</span>, <span class="string">"rate, 100 means 100 packets per second for each target"</span>)</div><div class="line">	delay        = pflag.IntP(<span class="string">"delay"</span>, <span class="string">"d"</span>,<span class="number"> 3</span>, <span class="string">"delay seconds"</span>)</div><div class="line">	bitflipCheck = pflag.BoolP(<span class="string">"bitflip"</span>, <span class="string">""</span>, <span class="constant">false</span>, <span class="string">"check bitflip"</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>它包含几个参数，使用 <code>github.com/spf13/pflag</code>进行解析。之所以不使用标准库的<code>flag</code>解析， 是因为<code>pflag</code>更强大，支持短参数和长参数，支持将参数放在最后面，更符合Linux ping/traceroute的参数样式。</p>
<ul>
<li>count: 你可以持续进行探测，也可以使用<code>-c</code>指定发多少包后退出。</li>
<li>tos: 可以指定网络的优先级，针对不同的优先级进行探测和压测。</li>
<li>size: 指定包的大小。这里的包大小其实指的是payload, 不包含ICMP、IP以及以上的包头</li>
<li>timeout: 指定发送数据的超时时间</li>
<li>rate: 发包的频率， 也就是 pps (packet/second)</li>
<li>delay: 最大延迟时间，超过这个时间的包就丢弃了</li>
<li>bitflip: 检查经过的物理链路中是否有改包的行为。 芯片的老化、bug、或者电磁辐射等等有可能把链路中的一个或者几个比特位进行修改，网络和服务器可能能通过CRC检查到，但是由于CRC的缺陷也可能检查不到，导致落盘的数据是错误的。从业屙屎多年来我也经历过几起。</li>
</ul>
<p>这是参数的设置，也你也可以把它当做一个需求，想一想程序该怎么实现。</p>
<p>这个程序还需要一个参数，也就是要探测的目的地址。</p>
<p>mping支持同时探测多个目的地址。目的地址可以是域名，也可以是网段，比如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> ./mping -r <span class="number">100</span> <span class="number">8.8</span>.<span class="number">8.8</span>/<span class="number">30</span>,<span class="number">8.8</span>.<span class="number">4.4</span>,github.com</div></pre></td></tr></table></figure>

<p>因为我们使用了底层的socket编程方式，所以需要 root 用户才能执行这个程序， 或者 root用户使用 <code>setcap cap_net_raw=+ep ./mping</code> 设置权限后， 普通用户也能执行。</p>
<p>具体的参数检查和处理我就不赘述了，比较简单，大家可以看项目中的源代码。总是我们会把目的地址拆解成一组具体的 IP地址，放在变量<code>targetAddrs []string</code>中。</p>
<p>接下来我们看看是怎么收发包的。</p>
<h2 id="发包">发包</h2>
<p>因为icmpx这个包它要求传入一个网络接口，这是有点讨厌的地方，我们不得不使用<a href="https://github.com/smallnest/qianmo" target="_blank" rel="external">qianmo</a>库获得一个网络接口。这例其实是有点小缺陷的，如果你所在的探测服务器有多个IP地址，每个地址有不同的路由，这里找到的网络接口可能不是你想要的。更好的解决办法根据目的地址，找到本地对应的IP和网络接口。但是如果目的地址有多个，使用不同的网络接口的话，处理起来有很麻烦，所以这里我们从简处理了。</p>
<p>找到网络接口后就可以创建 <code>icmpx.IPv4Conn</code>对象了，创建好后我们可以设置TOS值，本文就省略了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   addrs := qianmo.NonLoopbackAddrs()</div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(addrs) ==<span class="number"> 0</span> {</div><div class="line">	<span class="keyword">return</span> errors.New(<span class="string">"no non-loopback address"</span>)</div><div class="line">}</div><div class="line"></div><div class="line">iface, err := qianmo.InterfaceByIP(addrs<span class="number">[0</span>])</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get interface by ip: %w"</span>, err)</div><div class="line">}</div><div class="line"></div><div class="line">conn, err := icmpx.ListenIPv4(iface, icmpx.IPv4Config{</div><div class="line">	Filter: icmpx.IPv4AllowOnly(ipv4.ICMPTypeEchoReply),</div><div class="line">})</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line"><span class="keyword">go</span> send(conn) <span class="comment">// 发包</span></div><div class="line"><span class="keyword">go</span> printStat() <span class="comment">// 定期统计输出</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> read(conn) <span class="comment">// 读包</span></div></pre></td></tr></table></figure>

<p>这个<code>icmpx.IPv4Conn</code>我们既用它发包，也用来收包。</p>
<p>注意在创建IPv4Conn的时候我们增加了一个filter,我们只接收<code>ipv4.ICMPTypeEchoReply</code>回包。 在网络环境中，服务器总是有一些ICMP包的干扰，通过这个filter,我们可以筛选出我们所关注的ICMP包。</p>
<p>最主要的发送逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> send(conn *icmpx.IPv4Conn) {</div><div class="line">	<span class="keyword">defer</span> connOnce.Do(<span class="keyword">func</span>() { conn.Close() })</div><div class="line"></div><div class="line">    <span class="comment">// 限流器，按照我们需要的速率发送</span></div><div class="line">	limiter := ratelimit.New(*rate, ratelimit.Per(time.Second))</div><div class="line"></div><div class="line">	...... <span class="comment">// 准备发送的数据</span></div><div class="line"></div><div class="line">	sentPackets :=<span class="number"> 0</span></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		seq++ <span class="comment">// 用来将发送的包和回来的包匹配</span></div><div class="line">		ts := time.Now().UnixNano()</div><div class="line">		binary.LittleEndian.PutUint64(data[<span class="built_in">len</span>(msgPrefix):], <span class="typename">uint64</span>(ts)) <span class="comment">// 把发送时的时间戳放入payload, 以便计算时延</span></div><div class="line"></div><div class="line">        <span class="comment">// 发送的icmp包</span></div><div class="line">		req := &icmp.Message{</div><div class="line">			Type: ipv4.ICMPTypeEcho,</div><div class="line">			Body: &icmp.Echo{</div><div class="line">				ID:   <span class="typename">int</span>(id),</div><div class="line">				Seq:  <span class="typename">int</span>(seq),</div><div class="line">				Data: data,</div><div class="line">			},</div><div class="line">		}</div><div class="line"></div><div class="line"></div><div class="line">		limiter.Take() <span class="comment">// 获取一个令牌，开始发包</span></div><div class="line">		<span class="keyword">for</span> _, target := <span class="keyword">range</span> targetAddrs { <span class="comment">//对每一个目标，都使用这个conn发送</span></div><div class="line">			key := ts / <span class="typename">int64</span>(time.Second)</div><div class="line">			stat.Add(key, &Result{ <span class="comment">// 统计发包</span></div><div class="line">				ts:     ts,</div><div class="line">				target: target,</div><div class="line">				seq:    seq,</div><div class="line">			})</div><div class="line"></div><div class="line">			ctx, cancel := context.WithTimeout(context.Background(), *timeout)</div><div class="line">			err := conn.WriteTo(ctx, req, netip.MustParseAddr(target)) <span class="comment">// 写入</span></div><div class="line">			cancel()</div><div class="line">			<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		......</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里有几个技巧：</p>
<ul>
<li>包payload我们加了前缀<code>smallnest</code>, 以便检查回包是否合法</li>
<li>ICMP Echo包中的id 一般我们设置为程序的进程号</li>
<li>ICMP Echo包中的seq我们递增，收到回包后我们可以把回包和发送的包做匹配</li>
<li>使用限流器控制发送的速率</li>
<li>发送的payload加上了发送的时间戳，收到回包后可以计算时延(latency)</li>
<li>发送的payload使用随机数据填充，收到包后检查数据，看看有没有改包行为</li>
</ul>
<p>发送使用了一个goroutine。</p>
<h2 id="接收">接收</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> read(conn *icmpx.IPv4Conn) error {</div><div class="line">	<span class="keyword">defer</span> connOnce.Do(<span class="keyword">func</span>() { conn.Close() })</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		ctx, cancel := context.WithTimeout(context.Background(), time.Second*time.Duration((*delay)))</div><div class="line">        <span class="comment">// 读取ICMP返回的包</span></div><div class="line">		msg, addr, err := conn.ReadFrom(ctx)</div><div class="line">		cancel()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">		}</div><div class="line">        </div><div class="line">        ......</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> pkt := msg.Body.(<span class="keyword">type</span>) {</div><div class="line">		<span class="keyword">case</span> *icmp.Echo:</div><div class="line">			<span class="keyword">if</span> <span class="typename">uint16</span>(pkt.ID) != id { <span class="comment">// 检查id</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(pkt.Data) &lt; <span class="built_in">len</span>(msgPrefix<span class="number">)+8</span> {</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line">			<span class="keyword">if</span> !bytes.HasPrefix(pkt.Data, msgPrefix) { <span class="comment">//检查前缀是否匹配</span></div><div class="line">				<span class="keyword">continue</span></div><div class="line">			}</div><div class="line"></div><div class="line">			ts := <span class="typename">int64</span>(binary.LittleEndian.Uint64(pkt.Data[<span class="built_in">len</span>(msgPrefix):])) <span class="comment">// 获取时间戳</span></div><div class="line">			key := ts / <span class="typename">int64</span>(time.Second)</div><div class="line"></div><div class="line">			bitflip := <span class="constant">false</span></div><div class="line">			<span class="keyword">if</span> *bitflipCheck { <span class="comment">// 检查是否有改包</span></div><div class="line">				bitflip = !bytes.Equal(pkt.Data[<span class="built_in">len</span>(msgPrefix<span class="number">)+8</span>:], payload)</div><div class="line">			}</div><div class="line">			stat.Add(key, &Result{ <span class="comment">// 统计回包</span></div><div class="line">				ts:       ts,</div><div class="line">				target:   target,</div><div class="line">				latency:  time.Now().UnixNano() - ts,</div><div class="line">				received: <span class="constant">true</span>,</div><div class="line">				seq:      <span class="typename">uint16</span>(pkt.Seq),</div><div class="line">				bitflip:  bitflip,</div><div class="line">			})</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接收也很检查，就是收到包后各种检查，确保收到的包和发送包是匹配的。</p>
<p>可以看到，我们使用<code>icmpx</code>这个库的时候，相对Go官方的icmp库，处理起来相对就简单了。</p>
<h2 id="统计">统计</h2>
<p>最后一个部分就是统计了。我们收发包已经完成，那么我们希望每秒能在命令行中打印出每一秒的统计信息，包括发送了多少包，丢弃了多少包，丢包率是多少，时延是多少。</p>
<p>我们的统计方法是这样子的：</p>
<ul>
<li>每个周期(1秒)的数据放入一个篮子中(Bucket)</li>
<li>每一秒检查前面 delay 秒的bucket,统计这个篮子内的发包丢包情况</li>
<li>篮子中的数据使用map对象保存， key是 target-seq, 收到的回包数据会覆盖发包数据，如果没有被覆盖，那么检查请求的包就知道丢包了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> printStat() {</div><div class="line">	delayInSeconds := <span class="typename">int64</span>(*delay) <span class="comment">// 5s</span></div><div class="line">	ticker := time.NewTicker(time.Second)</div><div class="line">	<span class="keyword">var</span> lastKey <span class="typename">int64</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> ticker.C {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> bucket.Key &lt;= time.Now().UnixNano()/<span class="typename">int64</span>(time.Second)-delayInSeconds {</div><div class="line">			pop := stat.Pop().(*Bucket)</div><div class="line">			......</div><div class="line"></div><div class="line">			targetResult := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]*TargetResult)</div><div class="line"></div><div class="line">			<span class="keyword">for</span> _, r := <span class="keyword">range</span> pop.Value {</div><div class="line">				target := r.target</div><div class="line"></div><div class="line">				tr := targetResult[target]</div><div class="line">				<span class="keyword">if</span> tr == <span class="constant">nil</span> {</div><div class="line">					tr = &TargetResult{}</div><div class="line">					targetResult[target] = tr</div><div class="line">				}</div><div class="line"></div><div class="line">				tr.latency += r.latency <span class="comment">// 把时延加在一起，输出的时候算平均值</span></div><div class="line"></div><div class="line">				<span class="keyword">if</span> r.received { <span class="comment">// 如果是回包，回包数加一</span></div><div class="line">					tr.received++ </div><div class="line">				} <span class="keyword">else</span> { <span class="comment">// 否则丢包数加一</span></div><div class="line">					tr.loss++</div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> *bitflipCheck && r.bitflip { <span class="comment">// 改包的数</span></div><div class="line">					tr.bitflipCount++</div><div class="line">				}</div><div class="line"></div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> target, tr := <span class="keyword">range</span> targetResult {</div><div class="line">				......</div><div class="line"></div><div class="line">				<span class="keyword">if</span> *bitflipCheck {</div><div class="line">					...... <span class="comment">// 输出统计信息</span></div><div class="line">                    log.Printf(<span class="string">"%s: sent:%d, recv:%d,  loss rate: %.2f%%, latency: %v, bitflip: %d\n"</span>, target, total, tr.received, lossRate<span class="number">*100</span>, time.Duration(tr.latency/<span class="typename">int64</span>(tr.received)), tr.bitflipCount)</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">                    ...... <span class="comment">// 输出统计信息</span></div><div class="line">				}</div><div class="line">			}</div><div class="line"></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样，我们的mping工具就开发完成了，看看它的功能吧：<br><img src="mping.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目地址： <a href="https://github.com/smallnest/mping" target="_blank" rel="external">mping</a></p>
<p>最近在网络探测的分析中，需要做一个使用ICMP协议进行压测的工具， ping或者fping多多少少都不满足需求，所以需要自己写一个。</p>
<p>使用<a href="https://pkg.go.dev/golang.org/x/net/icmp" target="_blank" rel="external">golang.org/x/net/icmp</a>很容易的实现基于ICMP的工具， <a href="https://github.com/go-ping/ping" target="_blank" rel="external">go-ping</a>就算了，既缺乏维护性能也不佳。所以我最初使用Go官方扩展库实现了这个工具，不过这几天我看到Matt Layher刚推出一个新的ICMP库：<a href="https://github.com/mdlayher/icmpx" target="_blank" rel="external">mdlayher/icmpx</a>， 我决定尝试一下。Matt Layher 是Go网络编程的专家，写了好几个网络相关的库，所以我对他的库还是蛮有信心的。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 1.21 中的泛型推断]]></title>
    <link href="https://colobu.com/2023/08/18/go1-21-generics/"/>
    <id>https://colobu.com/2023/08/18/go1-21-generics/</id>
    <published>2023-08-18T00:50:46.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://encore.dev/blog/go1.21-generics" target="_blank" rel="external">understanding Go 1.21 generics type inference</a></p>
<p>Go 1.21 已经发布了，带来了一系列的改进，例如更好的泛型类型推断（本文的内容）;新的内置函数<code>min`</code>,<code>max</code>和<code>clear`</code>;以及标准库中的几个新软件包（<code>maps`</code>,<code>slices`</code>,<code>cmp`</code>,<code>log/slog</code>和<code>testing/slogtest`</code>)。在<a href="https://golang.org/doc/go1.21" target="_blank" rel="external">这里</a>阅读完整的发行说明。</p>
<p>至少对我们Encore来说，特别感兴趣的是对泛型类型推断的改进，因为它会影响Encore的静态分析的工作方式。但是，我们认为发行说明很难理解，因此本文通过更多解释和示例介绍这次的变更。</p>
<p>我们也刚刚发布了支持 Go 1.21 的 Encore v1.24，所以这是尝试这些新变化的好方法。</p>
<a id="more"></a>
<h2 id="部分实例化的泛型函数">部分实例化的泛型函数</h2>
<p>来自 Go 1.21 发行说明：</p>
<blockquote>
<p>现在可以使用本身（可能部分实例化）泛型函数的参数调用（可能部分实例化的泛型）函数。编译器将尝试推断被调用方缺少的类型参数（as before），对于每个未完全实例化的泛型函数的参数，将尝试推断其缺少的类型参数（new）。典型的用例是对在容器上运行的泛型函数的调用（例如<code>slices.IndexFunc</code>），其中函数参数也可以是泛型的，并且被调用函数的类型参数及其参数是从容器类型推断出来的。</p>
</blockquote>
<p>啥意思？</p>
<p>考虑一个函数，该函数需要传入一个值并报告它是否为零值：。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> IsZero[T comparable](a T) <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>在 Go 1.21 之前，将这样的函数作为参数传递给另一个（泛型或非泛型）函数需要你显式指定类型参数，即使从上下文中很明显能看出类型。<br>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Any reports whether fn returns true for any number in the slice.</span></div><div class="line"><span class="keyword">func</span> Any(numbers []<span class="typename">int</span>, fn <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">bool</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> numbers {</div><div class="line">		<span class="keyword">if</span> fn(v) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>fn处理numbers,只要有一个是true,Any就返回true</p>
</blockquote>
<p>使用Go 1.21，您现在就可以这些写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numbers := []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line"></div><div class="line"><span class="comment">// Go 1.21</span></div><div class="line">anyZeroes := Any(numbers, IsZero)</div><div class="line"></div><div class="line"><span class="comment">// Go 1.21之前，你不得不这样写</span></div><div class="line">anyZeroes := Any(numbers, IsZero[<span class="typename">int</span>])</div></pre></td></tr></table></figure>

<p>如发行说明所示，这也适用于泛型函数。所以你也可以写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Go 1.21</span></div><div class="line">firstZeroIndex := slices.IndexFunc(numbers, IsZero)</div><div class="line"></div><div class="line"><span class="comment">// Go 1.21之前，你不得不这样写</span></div><div class="line">firstZeroIndex := slices.IndexFunc(numbers, IsZero[<span class="typename">int</span>])</div></pre></td></tr></table></figure>

<p>Go 1.21可以从类型<code>numbers</code>推断<code>IsZero</code>是<code>IsZero[int]</code> ,即使<code>slices.IndexFunc</code>是一个泛型函数。</p>
<p>发行说明中在同一段落继续讲到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">更一般地说，如果可以从赋值推断类型参数，则在将泛型函数分配给变量或作为结果值返回时，现在可以在没有显式实例化的情况下使用泛型函数。</div></pre></td></tr></table></figure>

<p>这意味着以下内容现在有效（在 Go 1.21 之前，您需要显式指定类型参数）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IsZero 被推断为 IsZero[string]，因为根据类型func(a string) bool可以推断出</span></div><div class="line"><span class="keyword">var</span> isZeroString <span class="keyword">func</span>(a <span class="typename">string</span>) <span class="typename">bool</span> = IsZero</div><div class="line"></div><div class="line"><span class="keyword">func</span> IsNilPointerFactory[T any] <span class="keyword">func</span>() <span class="keyword">func</span>(val *T) <span class="typename">bool</span> {</div><div class="line">  <span class="comment">// IsZero 是 IsZero[*T]， 因为根据返回值func(val *T) bool可以推断出来</span></div><div class="line">  <span class="keyword">return</span> IsZero</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="接口赋值推断">接口赋值推断</h2>
<p>Go 1.21 还改进了泛型接口类型的类型推断。从发行说明：</p>
<blockquote>
<p>类型推断现在还会在将值分配给接口时考虑方法：方法签名中使用的类型参数的类型参数可以从匹配方法的相应参数类型推断出来。</p>
</blockquote>
<p>这是啥意思呢？请考虑以下泛型接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RandomElementer[T any] <span class="keyword">interface</span> {</div><div class="line">    <span class="comment">// 返回一个随机的元素，如果集合为空，返回(zero, false)</span></div><div class="line">	RandomElement() (T, <span class="typename">bool</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后考虑一个泛型的帮助程序函数，该函数调用某个集合，但如果集合为空，则会panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 必须返回一个元素，如果集合为空,则panic</span></div><div class="line"><span class="keyword">func</span> MustRandom[T any](collection RandomElementer[T]) T {</div><div class="line">	val, ok := collection.RandomElement()</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"collection is empty"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> val</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在 Go 1.21 中，现在可以调用接口类型，并且接口类型将从参数中推断出来。考虑以下两种类型，一种泛型的，一种不是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyList 泛型集合.</span></div><div class="line"><span class="keyword">type</span> MyList[T any] []T</div><div class="line"><span class="keyword">func</span> (l MyList[T]) RandomElement() (T, <span class="typename">bool</span>) { <span class="comment">/* ... */</span> }</div><div class="line"></div><div class="line"><span class="comment">// IPSet 代表一个IP集合，非泛型的</span></div><div class="line"><span class="keyword">type</span> IPSet <span class="keyword">map</span>[netip.Addr]<span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> (s IPSet) RandomElement() (netip.Addr, <span class="typename">bool</span>) { <span class="comment">/* ... */</span> }</div></pre></td></tr></table></figure>

<p>这些现在（Go1.21）可以像这样使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">randomInt := MustRandom(MyList[<span class="typename">int</span>]{})</div><div class="line">randomIP := MustRandom(IPSet{})</div><div class="line"></div><div class="line"><span class="comment">// Go 1.20或者以前，你不得不写成如下的方式</span></div><div class="line">randomInt := MustRandom[<span class="typename">int</span>](MyList[<span class="typename">int</span>]{})</div><div class="line">randomIP := MustRandom[netip.Addr](IPSet{})</div></pre></td></tr></table></figure>

<p>优秀！继续前进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同样，由于类型参数必须实现其相应约束的所有方法，因此类型参数和约束的方法匹配，这可能导致推断其他类型参数。</div></pre></td></tr></table></figure>

<p>这基本上意味着上述类型推断也扩展到采用额外类型的函数。 例如，<code>MustRandom</code>签名可以重写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> MustRandom[R RandomElementer[T], T any](collection R) T</div></pre></td></tr></table></figure>

<p>当调用<code>MustRandom(IPSet{})</code>时,Go 1.21 在调用时正确推断<code>R</code>和<code>T</code>。</p>
<h2 id="非类型化常量的类型推断">非类型化常量的类型推断</h2>
<blockquote>
<p>如果将多个不同类型的非类型化常量参数（如非类型化 int 和非类型化浮点常量）传递给具有相同（未另行指定）类型参数类型的参数，这不会报错，类型推断现在使用与具有非类型化常量操作数的运算符相同的方法确定类型。此更改使从非类型常量参数推断的类型与常量表达式的类型一致</p>
</blockquote>
<p>Go 具有非类型常量的概念，并且表达式的类型<code>a+b</code>是从常量值<code>a</code>和<code>b</code>推断出来的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x =<span class="number"> 1</span> +<span class="number"> 2</span>   <span class="comment">// x 是int</span></div><div class="line"><span class="keyword">var</span> y =<span class="number"> 1</span> +<span class="number"> 2.5</span> <span class="comment">// y 是 float64</span></div></pre></td></tr></table></figure>

<p>现在考虑编写一个行为类似于内置运算符<code>+</code>的泛型函数<code>Add</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Add[T <span class="typename">int</span> | <span class="typename">float64</span>](a, b T) T {</div><div class="line">  <span class="keyword">return</span> a + b</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在 Go 1.21 中，这与您所期望的完全一样工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = Add<span class="number">(1</span>,<span class="number"> 2</span>)   <span class="comment">// x 是 int</span></div><div class="line"><span class="keyword">var</span> y = Add<span class="number">(1</span>,<span class="number"> 2.5</span>) <span class="comment">// y 是 float64</span></div></pre></td></tr></table></figure>

<p>在 Go 1.20 中，相同的代码无法编译，因为类型推断将分别考虑每个参数。它将推断 1的类型是int, 然后无法与2.5的类型float64统一，从而导致错误“default type float64 of 2.5 does not match inferred type int for T”。</p>
<h2 id="总结">总结</h2>
<p>这就是 Go 1.21 中对泛型类型推断的更改程度。希望这些示例有助于使更改更易于理解;反正经过摸索我更容易理解了，家人们如果理解了请在页面一键三连。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://encore.dev/blog/go1.21-generics" target="_blank" rel="external">understanding Go 1.21 generics type inference</a></p>
<p>Go 1.21 已经发布了，带来了一系列的改进，例如更好的泛型类型推断（本文的内容）;新的内置函数<code>min`</code>,<code>max</code>和<code>clear`</code>;以及标准库中的几个新软件包（<code>maps`</code>,<code>slices`</code>,<code>cmp`</code>,<code>log/slog</code>和<code>testing/slogtest`</code>)。在<a href="https://golang.org/doc/go1.21" target="_blank" rel="external">这里</a>阅读完整的发行说明。</p>
<p>至少对我们Encore来说，特别感兴趣的是对泛型类型推断的改进，因为它会影响Encore的静态分析的工作方式。但是，我们认为发行说明很难理解，因此本文通过更多解释和示例介绍这次的变更。</p>
<p>我们也刚刚发布了支持 Go 1.21 的 Encore v1.24，所以这是尝试这些新变化的好方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真实世界的Go设计模式 - 对象池模式]]></title>
    <link href="https://colobu.com/2023/08/08/go-design-pattern-pool/"/>
    <id>https://colobu.com/2023/08/08/go-design-pattern-pool/</id>
    <published>2023-08-07T16:27:13.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p><strong>对象池</strong>（object pool pattern）是一种设计模式。一个<strong>对象池</strong>包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。<br><a id="more"></a></p>
<p>若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的效能提升。从池子中取得对象的时间是可预测的，但新建一个实例所需的时间是不确定。</p>
<p>另外，利用对象池，我们可以重用对象，减少对象的分配，对于垃圾回收的编程语言，也是一种提高性能的手段。</p>
<p>sync.Pool是Go标准库sync包中的一个非常有用的结构,它可以用来管理和重用临时对象,以减少对象频繁分配和回收的开销。</p>
<p>sync.Pool的主要特点包括:</p>
<ul>
<li>Pool维护一个可存储和共享临时对象的集合,这些对象无需频繁地申请和回收内存。</li>
<li>Pool通过New字段指定一个函数,用来生成新对象放入pool中。</li>
<li>通过Get方法可以从pool中获得一个可重用对象,使用后调用Put方法将其放回pool。</li>
<li>对象在不再需要时不会立即销毁,而是被保留在Pool中以便后续重用。</li>
<li>Pool会根据需求自动调整对象个数,会定期GC不再使用的对象。</li>
<li>每个P都有一个本地pool,goroutine优先从本地pool获取和放回对象。</li>
</ul>
<p>通过重用对象,可以减少内存分配和垃圾回收的开销,特别适合用于管理许多临时对象的场景,如处理大量并发请求时的缓冲、连接等。</p>
<p>比如net/rpc包就使用了链表来管理常用的Response、Request等对象的重用。</p>
<p>Go标准库database/sql包实现了一个连接池,可以重用数据库连接。使用DB.Conn()获取连接对象,操作完成后调用conn.Close()将其放回池中。该连接池默认最大空闲连接数2,可以通过SetMaxIdleConns进行调整。</p>
<p><a href="https://github.com/fatih/pool" target="_blank" rel="external">fatih/pool</a> 也是一个常用的网络连接池。</p>
<p>还有一类是goroutine pool,也又叫做worker pool的，这类的库就很多的，而且还有人源源不断的造轮子。比如常用的比如：</p>
<ul>
<li><p><a href="https://github.com/Jeffail/tunny" target="_blank" rel="external">Jeffail/tunny</a></p>
</li>
<li><p><a href="https://github.com/panjf2000/ants" target="_blank" rel="external">panjf2000/ants</a></p>
</li>
<li><p><a href="https://github.com/ivpusic/grpool" target="_blank" rel="external">ivpusic/grpool</a></p>
</li>
<li><p><a href="https://github.com/alitto/pond" target="_blank" rel="external">alitto/pond</a></p>
</li>
</ul>
<p>因为使用channel + goroutine很容易实现goroutine pool,所以也有很多关注度不高的轮子，都是作者针对自己的需求定制和改造的。使用也很方便。</p>
<p>Go标准库还有一个实验性的包<code>arena</code>,本来就在Go 1.20中就要推出的，但是在实现的过程中发现有问题，就一直没有暴露出来。<a href="https://github.com/golang/go/issues/51317" target="_blank" rel="external">proposal: arena: new package providing memory arenas </a>这个提案详细介绍了内容。你也可以把它看成是一个内存池，从其中产生的对象不会被垃圾回收掉，能够提升程序的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>对象池</strong>（object pool pattern）是一种设计模式。一个<strong>对象池</strong>包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真实世界的Go设计模式 - 原型模式]]></title>
    <link href="https://colobu.com/2023/08/07/go-design-pattern-prototype/"/>
    <id>https://colobu.com/2023/08/07/go-design-pattern-prototype/</id>
    <published>2023-08-07T15:28:50.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>*原型模式(Prototype Pattern)是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p>
<p>如果你有一个对象，并希望生成与其完全相同或者类似的一个复制品，你该如何实现呢？首先你必须新建一个属于相同类的对象，或者类似的对象，然后你必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。在Go生态圈中，我们常常使用下面的库来做这份工作。</p>
<a id="more"></a>
<ul>
<li><a href="https://github.com/jinzhu/copier" target="_blank" rel="external">jinzhu/copier</a>: 张金柱提供的一个优秀的复制库。  </li>
<li><a href="https://github.com/switchupcb/copygen" target="_blank" rel="external">switchupcb/copygen</a>： 看Readme用起来就非常的复杂，不过它通过生成代码的方式，而不是reflect方式，理论上来说性能应该更好一些。</li>
<li><a href="https://github.com/jmattheis/goverter" target="_blank" rel="external">jmattheis/goverter</a>： 这个看起来比copygen好多了，我们只需需要定义一个转换接口，然后让它自动生成转换的代码。</li>
</ul>
<p>当然你也可以自己实现转换的方法，最简单的方式就是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newValue = value</div><div class="line"><span class="keyword">var</span> newValue = *valuePointer</div></pre></td></tr></table></figure>

<p>但是这种复制也有一些局限性，比如在一些字段复制的值要进行调整，新的对象中有些字段不需要设置等等，所以一般我们有预见对象需要复制(克隆)的话，我们一般会为这个对象类型实现<code>Clone</code>方法，通过这种方式我们实现原型模式。</p>
<p>实际上，Go标准库有很多实现原型模式的例子。</p>
<h2 id="strings-Clone">strings.Clone</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Clone(s <span class="typename">string</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>Clone返回字符串s的一个全新副本。它保证将字符串s复制到一个新的分配空间中,当只保留一个大字符串的一小部分子串时,这可能非常重要。使用Clone可以帮助这些程序减少内存使用或者说避免内存泄露。</p>
<h2 id="maps-Clone">maps.Clone</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Clone[M ~<span class="keyword">map</span>[K]V, K comparable, V any](m M) M</div></pre></td></tr></table></figure>

<p>Clone返回m的一个副本。这是一个浅克隆:新键和值是使用普通赋值设置的。</p>
<h2 id="http-Transport-Clone">http.Transport.Clone</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (t *Transport) Clone() *Transport</div></pre></td></tr></table></figure>

<p>Clone返回t的导出字段的深度拷贝。</p>
<h2 id="arena-Clone">arena.Clone</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Clone[T any](s T) T</div></pre></td></tr></table></figure>

<p>Clone方法返回一个s的浅拷贝，此拷贝的对象不再在arena中分配。</p>
<blockquote>
<p>arena 包还不成熟</p>
</blockquote>
<h2 id="slog-Record-Clone">slog.Record.Clone</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (r Record) Clone() Record</div></pre></td></tr></table></figure>

<p>Clone返回一个没有共享状态的记录副本。原记录和克隆记录都可以修改,而不会相互影响。</p>
<p>此外，还有Go标准库还有很多类似的实现原型模式的例子，比如:</p>
<ul>
<li><p>cmd/distpack/archive.go: Archive.Clone</p>
</li>
<li><p>crypto/x509/cert_pool.go: CertPool.Clone</p>
</li>
<li><p>text/template/template.go: Template.Clone</p>
</li>
<li><p>html/template/template.go: Template.Clone</p>
</li>
<li><p>net/http/header.go: Header.Clone</p>
</li>
<li><p>net/http/request.go:Request.Clone</p>
</li>
<li><p>bytes.Clone</p>
</li>
<li><p>crypto/tls/common.go: Config.Clone</p>
</li>
<li><p>slices.Clone</p>
</li>
</ul>
<p>还有一些非导出的方法和函数。</p>
<p>总的来说，如果你想实现原型模式，那么最简单的方式就是为你的类型实现一个Clone方法，或者在你的包下实现一个clone函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>*原型模式(Prototype Pattern)是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。</p>
<p>如果你有一个对象，并希望生成与其完全相同或者类似的一个复制品，你该如何实现呢？首先你必须新建一个属于相同类的对象，或者类似的对象，然后你必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。在Go生态圈中，我们常常使用下面的库来做这份工作。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[原型模式补遗 - Go语言中的深度拷贝]]></title>
    <link href="https://colobu.com/2023/08/07/deep-copy-in-go/"/>
    <id>https://colobu.com/2023/08/07/deep-copy-in-go/</id>
    <published>2023-08-07T15:12:46.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>在前一篇<a href="https://colobu.com/2023/08/07/go-design-pattern-prototype/" target="_blank" rel="external">真实世界的Go设计模式 - 原型模式</a>一文中，我们介绍了gorm作者张金柱的另一个库<a href="https://github.com/jinzhu/copier" target="_blank" rel="external">jinzhu/copier</a>,它提供了对象数据深度复制的能力。<br><a id="more"></a></p>
<p>在和网友的交流中，有网友提到金柱的那个库不支持any类型的深度复制，也提到也有叫做DeepCopy库支持，但又不支持指针深度拷贝。真的是这么样，或者说当前还有这种现象么？我写了一个测试程序，分别对指针、map、slice和接口进行了测试，发现这些库其实都支持了各种类型的深度复制。代码太长我就不专门贴在这里了，大家可以访问下面的网址查看测试代码：<a href="https://go.dev/play/p/WoringjBHeZ" target="_blank" rel="external">https://go.dev/play/p/WoringjBHeZ</a> .</p>
<p>当然，对于<code>jinzhu/copier</code>,你需要显示指定深度拷贝参数，否则使用默认的Copy还是不能够复制接口、map等对象。<code>jinzhu/copier</code>还提供不同类型的对象之间的复制，功能更强大，代码也就更复杂。</p>
<p>这些深度拷贝的库如下：</p>
<ul>
<li><a href="https://github.com/jinzhu/copier" target="_blank" rel="external">jinzhu/copier</a></li>
<li><a href="https://github.com/barkimedes/go-deepcopy" target="_blank" rel="external">barkimedes/go-deepcopy</a></li>
<li><a href="https://github.com/mohae/deepcopy" target="_blank" rel="external">mohae/deepcopy</a></li>
</ul>
<p>相比较而言，<code>mohae/deepcopy</code>的代码也更简洁易懂，也被将近一万多个github项目锁使用。<br>唯一比较遗憾的是，这个项目将近6年没有更新了，一方面说明稳定，另一方面也说明Go的一些新的特性也没有应用在它的方面，设置它连个go.mod都没有。</p>
<p>我复制了这个项目，准备维护下去。你可以关注 <a href="https://github.com/smallnest/deepcopy" target="_blank" rel="external">smallnest/deepcopy</a>。</p>
<p>目前我为它增加了泛型的支持, 避免了手工的type assertion，也增加channel的复制能力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cpy := deepcopy.Copy[T](orig)</div></pre></td></tr></table></figure>

<p>所以一个完整的例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">complexData := ComplexStruct{</div><div class="line">	ID:         <span class="number"> 1</span>,</div><div class="line">	Name:        <span class="string">"Complex Object"</span>,</div><div class="line">	Description: <span class="string">"A struct with various types for JSON benchmarking"</span>,</div><div class="line">	IsEnabled:   <span class="constant">true</span>,</div><div class="line">	Count:      <span class="number"> 5</span>,</div><div class="line">	Price:      <span class="number"> 99.99</span>,</div><div class="line">	Tags:        []<span class="typename">string</span>{<span class="string">"tag1"</span>, <span class="string">"tag2"</span>, <span class="string">"tag3"</span>},</div><div class="line">	CreatedAt:   <span class="string">"2023-08-07T12:34:56Z"</span>,</div><div class="line">	Options:     <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">bool</span>{<span class="string">"option1"</span>: <span class="constant">true</span>, <span class="string">"option2"</span>: <span class="constant">false</span>, <span class="string">"option3"</span>: <span class="constant">true</span>},</div><div class="line">	Nested: NestedStruct{</div><div class="line">		Field1:<span class="number"> 42</span>,</div><div class="line">		Field2: <span class="string">"Nested Field"</span>,</div><div class="line">		ItemAStruct: ItemAStruct{</div><div class="line">			ItemID:  <span class="number"> 100</span>,</div><div class="line">			ItemName: <span class="string">"Item A"</span>,</div><div class="line">		},</div><div class="line">		ItemBStruct: &ItemBStruct{</div><div class="line">			ItemType: <span class="string">"Item Type"</span>,</div><div class="line">			ItemFrom: <span class="string">"Item From"</span>,</div><div class="line">		},</div><div class="line">	},</div><div class="line">	Items: []ItemStruct{</div><div class="line">		{ItemID:<span class="number"> 101</span>, ItemName: <span class="string">"Item 1"</span>},</div><div class="line">		{ItemID:<span class="number"> 102</span>, ItemName: <span class="string">"Item 2"</span>},</div><div class="line">	},</div><div class="line">	ExtraData: json.RawMessage(<span class="string">`{"key": "value"}`</span>),</div><div class="line">	Handler:   <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {},</div><div class="line">	Opts: <span class="keyword">map</span>[<span class="typename">string</span>]any{</div><div class="line">		<span class="string">"opt1"</span>: <span class="string">"value1"</span>,</div><div class="line">		<span class="string">"opt2"</span>:<span class="number"> 2</span>,</div><div class="line">		<span class="string">"opt3"</span>: <span class="constant">true</span>,</div><div class="line">	},</div><div class="line">}</div><div class="line"></div><div class="line">   newData := Copy[ComplexStruct](complexData)</div></pre></td></tr></table></figure>

<p>channel类型只复制channel类型和它的容量，并没有复制channel中的元素：一是并没有方式直接获取缓存在channel中的元素，二是channel中的元素总是在变化之中，复制过来的元素也许在channel中已经被取走了。它也没有复制channel的状态，原channel被close了，复制的新channel也没有被close。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在前一篇<a href="https://colobu.com/2023/08/07/go-design-pattern-prototype/" target="_blank" rel="external">真实世界的Go设计模式 - 原型模式</a>一文中，我们介绍了gorm作者张金柱的另一个库<a href="https://github.com/jinzhu/copier" target="_blank" rel="external">jinzhu/copier</a>,它提供了对象数据深度复制的能力。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真实世界的Go设计模式 - 单例模式 和 惰性初始化模式]]></title>
    <link href="https://colobu.com/2023/07/27/go-design-patterns-singleton/"/>
    <id>https://colobu.com/2023/07/27/go-design-patterns-singleton/</id>
    <published>2023-07-27T14:52:48.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>在面向对象编程语言中，单例模式(Singleton pattern)确保一个类只有一个实例，并提供对该实例的全局访问。</p>
<p>那么Go语言中，单例模式确认一个类型只有一个实例，并提供对改实例的全局访问，一般就是直接访问全局变量即可。<br><a id="more"></a></p>
<p>比如Go标准库中的<code>os.Stdin</code>、<code>os.Stdout</code>、<code>os.Stderr</code>分别代表标准输入、标准输出和标准错误输出。它们是<code>*os.File</code>类型的全局变量，可以在程序中直接使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	Stdin  = NewFile(<span class="typename">uintptr</span>(syscall.Stdin), <span class="string">"/dev/stdin"</span>)</div><div class="line">	Stdout = NewFile(<span class="typename">uintptr</span>(syscall.Stdout), <span class="string">"/dev/stdout"</span>)</div><div class="line">	Stderr = NewFile(<span class="typename">uintptr</span>(syscall.Stderr), <span class="string">"/dev/stderr"</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>又比如io包下的EOF:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</div></pre></td></tr></table></figure>

<p>Go标准库中有很多这样的单例的实现，又比如<code>http.DefaultClient</code>、<code>http.DefaultServeMux</code>、<code>http.DefaultTransport</code>、<code>net.IPv4zero</code>都是单例对象。</p>
<p>有时候，有人也认为是单例模式也是反模式。</p>
<blockquote>
<p>反模式(Anti-pattern)是一种在软件工程中常见的概念,主要指在软件设计、开发中要避免使用的模式或实践。</p>
<p>反模式的一些主要特征包括:</p>
<ul>
<li>它通常是初学者常犯的错误或陷阱。</li>
<li>它反映了一种看似可行但实际上低效或错误的解决方案。</li>
<li>使用反模式可能在短期内出现类似解决问题的效果,但长期来看会适得其反。</li>
<li>它通常是一个坏的或劣质的设计,不符合最佳实践。</li>
<li>存在一个更好的、可替代的解决方案。</li>
</ul>
<p>一些常见的反模式示例:</p>
<ul>
<li>复制-粘贴编程:为了重复使用代码,直接复制粘贴,而不创建函数或模块。</li>
<li>上帝对象:一个巨大的包含全部功能的复杂对象。</li>
<li>依赖注入滥用:即使简单的对象也进行依赖注入,增加了复杂性。</li>
<li>自我封装:通过封装无谓的细节来增加类的复杂性。</li>
<li>过度抽象和设计：代码缺乏可读性</li>
</ul>
</blockquote>
<p>为什么这么说呢，加入两个goroutine同时使用<code>http.DefaultClient</code>, 其中一个goroutine修改了这个client的一些字段，也会影响到第二个goroutine的使用。</p>
<p>而且这些单例都是可修改对象，第三库甚至偷偷修改了这个变量的值，你都不会发现，比如你想连接本地的53端口，查询一些域名，但是可能被别人劫持到它的服务器上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/miekg/dns"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 单例对象被修改，实际可能在一个第三包的init函数中写了下面这一行</span></div><div class="line">	net.IPv4zero = net.IPv4<span class="number">(8</span>,<span class="number"> 8</span>,<span class="number"> 8</span>,<span class="number"> 8</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 设置DNS服务器地址</span></div><div class="line">	dnsServer := net.JoinHostPort(net.IPv4zero.String(), <span class="string">"53"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 创建DNS客户端</span></div><div class="line">	c := <span class="built_in">new</span>(dns.Client)</div><div class="line"></div><div class="line">	<span class="comment">// 构建DNS请求消息</span></div><div class="line">	msg := <span class="built_in">new</span>(dns.Msg)</div><div class="line">	msg.SetQuestion(dns.Fqdn(<span class="string">"rpcx.io"</span>), dns.TypeA)</div><div class="line"></div><div class="line">	<span class="comment">// 发送DNS请求消息</span></div><div class="line">	resp, _, err := c.Exchange(msg, dnsServer)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error sending DNS request:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 解析DNS响应消息</span></div><div class="line">	ipAddr, err := parseDNSResponse(resp)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Println(<span class="string">"Error parsing DNS response:"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 输出查询结果</span></div><div class="line">	fmt.Println(<span class="string">"IPv4 Address for google.com:"</span>, ipAddr)</div><div class="line">}</div><div class="line"><span class="keyword">func</span> parseDNSResponse(resp *dns.Msg) (<span class="typename">string</span>, error) {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(resp.Answer) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"No answer in DNS response"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, ans := <span class="keyword">range</span> resp.Answer {</div><div class="line">		<span class="keyword">if</span> a, ok := ans.(*dns.A); ok {</div><div class="line">			<span class="keyword">return</span> a.A.String(), <span class="constant">nil</span></div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"No A record found in DNS response"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>本来我想查询本机的dns服务器，结果却被劫持到谷歌的<code>8.8.8.8</code> DNS服务器上进行查询了。</p>
<p>惰性初始模式(Lazy initialization, 懒汉式初始化)推迟对象的创建、数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。<strong>惰性初始</strong>是一种拖延战术。在第一次需求出现以前，先延迟创建对象、计算值或其它昂贵的代码片段。</p>
<p>一句话，也就是延迟初始化。</p>
<p>如果你是Java程序员，面试的时候大概率会被问到单例的模式的实现，就像问茴香豆的茴字有几个写法。Java中大概有下面几种单例的实现：</p>
<ul>
<li><p>饿汉式（Eager Initialization）</p>
</li>
<li><p>懒汉式（Lazy Initialization）</p>
</li>
<li><p>双重检查锁（Double-Checked Locking）</p>
</li>
<li><p>静态内部类（Static Inner Class）</p>
</li>
<li><p>枚举单例（Enum Singleton）</p>
</li>
</ul>
<p>后面四种都属于惰性初始模式，在实例被第一次使用才会初始化。</p>
<p>Rust语言中常使用<code>lazy_static</code> 宏来实现惰性初始模式实现单例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">lazy_static! {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> SINGLETON: Mutex&lt;Singleton&gt; = Mutex::new(Singleton::new());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Singleton {</div><div class="line">    <span class="comment">// Add fields and methods as needed</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Singleton {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Self {</div><div class="line">        Singleton {</div><div class="line">            <span class="comment">// Initialize fields</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而在Go标准库中，可以使用<code>sync.Once</code>来实现惰性初始单例模式。比如<code>os/user</code>获取当前用户的时候，只需执行一次耗时的系统调用，后续就直接从第一次初始化的结果中获取，即使第一次查询失败：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Current() (*User, error) {</div><div class="line">	cache.Do(<span class="keyword">func</span>() { cache.u, cache.err = current() })</div><div class="line">	<span class="keyword">if</span> cache.err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, cache.err</div><div class="line">	}</div><div class="line">	u := *cache.u <span class="comment">// copy</span></div><div class="line">	<span class="keyword">return</span> &u, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// cache of the current user</span></div><div class="line"><span class="keyword">var</span> cache <span class="keyword">struct</span> {</div><div class="line">	sync.Once</div><div class="line">	u   *User</div><div class="line">	err error</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在即将发布的Go 1.21中，sync.Once又多了三个兄弟：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceFunc(f <span class="keyword">func</span>()) <span class="keyword">func</span>()</div><div class="line"><span class="keyword">func</span> OnceValue(f <span class="keyword">func</span>() T) <span class="keyword">func</span>() T</div><div class="line"><span class="keyword">func</span> OnceValues(f <span class="keyword">func</span>() (T1, T2)) <span class="keyword">func</span>() (T1, T2)</div></pre></td></tr></table></figure>

<p>它们是基于sync.Once实现的辅助函数，比如Current就可以使用OnceValues改写，有兴趣的同学可以试试。</p>
<p>这三个新函数的讲解可以阅读我先前的一篇文章：<a href="https://colobu.com/2023/05/29/extends-sync-Once/" target="_blank" rel="external">sync.Once的新扩展 (colobu.com)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在面向对象编程语言中，单例模式(Singleton pattern)确保一个类只有一个实例，并提供对该实例的全局访问。</p>
<p>那么Go语言中，单例模式确认一个类型只有一个实例，并提供对改实例的全局访问，一般就是直接访问全局变量即可。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真实世界的Go设计模式 - Builder设计模式]]></title>
    <link href="https://colobu.com/2023/07/25/go-design-patterns-builder/"/>
    <id>https://colobu.com/2023/07/25/go-design-patterns-builder/</id>
    <published>2023-07-25T15:39:01.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>中文翻译成 建造者模式、生成器模式。</p>
<p>一个遵循《设计模式》一书臆造出来的例子如： <a href="https://refactoring.guru/design-patterns/builder/go/example" target="_blank" rel="external">Builder in Go / Design Patterns (refactoring.guru)</a>，复杂又难以理解。</p>
<a id="more"></a>
<p>在Go标准库中，一个常见的实现了Builder设计模式的例子是<code>strings.Builder</code>。<code>strings.Builder</code>类型提供了一种构建字符串的有效方式，特别是当您需要在循环中动态构建字符串时，这样可以避免不必要的内存分配和拷贝。</p>
<p>实现<code>strings.Builder</code>的关键点是使用了可变长度的缓冲区来存储字符串，并在构建过程中动态地增加其大小，以适应不断增长的字符串。下面是一个简单的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	builder := strings.Builder{}</div><div class="line"></div><div class="line">	<span class="comment">// 添加字符串片段到构建器</span></div><div class="line">	builder.WriteString(<span class="string">"Hello, "</span>)</div><div class="line">	builder.WriteString(<span class="string">"World!"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 获取构建好的字符串</span></div><div class="line">	result := builder.String()</div><div class="line"></div><div class="line">	fmt.Println(result) <span class="comment">// 输出: Hello, World!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们首先使用<code>strings.Builder{}</code>创建了一个新的构建器。然后，通过调用<code>WriteString()</code>方法，我们可以向构建器添加字符串片段。最后，通过调用<code>String()</code>方法，我们可以获得构建好的最终字符串。</p>
<p>这里值得注意的是，<code>strings.Builder</code>在内部使用了一个可变长度的<code>[]byte</code>缓冲区，它会根据需要自动增长。这样，在构建字符串时，<code>strings.Builder</code>会根据当前缓冲区的大小和新添加的字符串片段的长度来决定是否需要扩展缓冲区的大小，从而避免了频繁的内存分配和拷贝操作。</p>
<p>这种实现方式在构建大型字符串时非常高效，因为它最小化了内存分配和拷贝的开销，同时还能提供简洁而灵活的API来构建字符串。这是Go标准库中使用Builder设计模式的一个很好的例子。</p>
<p>在地道的Go语言中，很少看到真正明显的使用Builder进行构建对象的例子。第一，Go一般直接New一个对象，传入相应的值进行字段的设置，相当的简洁粗暴，第二，Go的风格是很少使用方法链式调用(<strong>Method Chaining</strong>),而是使用功能选项风格(functional option)。链式调用是很好实现Builder的一种方式。</p>
<p>比如下面这个例子，我们对<code>*http.Request</code>进行包装，生成一个新的支持链式构建的<code>Request</code>。在创建一个新的<code>Request</code>的时候，我们使用链式调用进行初始化，增加了<code>Cookie</code>和查询参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> chaining</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> {</div><div class="line">	*http.Request</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 使用链式调用创建一个GET请求</span></div><div class="line">	request, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"https://www.example.com"</span>, <span class="constant">nil</span>)</div><div class="line"></div><div class="line">	req := &Request{request}</div><div class="line"></div><div class="line">	req.WithHeader(<span class="string">"User-Agent"</span>, <span class="string">"MyCustomUserAgent"</span>).</div><div class="line">		WithCookie(&http.Cookie{Name: <span class="string">"session"</span>, Value: <span class="string">"abc123"</span>}).</div><div class="line">		WithQueryParam(<span class="string">"key"</span>, <span class="string">"value"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 打印构建好的请求</span></div><div class="line">	fmt.Println(request)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// WithHeader 添加请求头</span></div><div class="line"><span class="keyword">func</span> (r *Request) WithHeader(key, value <span class="typename">string</span>) *Request {</div><div class="line">	r.Header.Add(key, value)</div><div class="line">	<span class="keyword">return</span> r</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// WithCookie 添加Cookie</span></div><div class="line"><span class="keyword">func</span> (r *Request) WithCookie(cookie *http.Cookie) *Request {</div><div class="line">	r.AddCookie(cookie)</div><div class="line">	<span class="keyword">return</span> r</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// WithQueryParam 添加URL查询参数</span></div><div class="line"><span class="keyword">func</span> (r *Request) WithQueryParam(key, value <span class="typename">string</span>) *Request {</div><div class="line">	query := r.URL.Query()</div><div class="line">	query.Add(key, value)</div><div class="line">	r.URL.RawQuery = query.Encode()</div><div class="line">	<span class="keyword">return</span> r</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，这种方式在Go生态圈中还是比较少用的，比如<code>*http.Request</code>还是通过逐步调用进行一步步的构建。</p>
<p>现在在Go生态圈流行一种叫functional option的创建模式。这个想法最早来自于Rob Pike的<a href="[command center: Self-referential functions and the design of options](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Self-referential functions and the design of options</a>)，后来不知道怎么被大佬们介绍就流行起来了。Go一般创建对象会使用以下几个方式：</p>
<ul>
<li><p>New(x int, y stirng, z S)：选项太多时参数太长。</p>
</li>
<li><p>NewXXX(...)、NewYYY(...)、NewZZZ(...):为每个配置选项声明一个新的构造函数，多个选项同时支持时方法太多。</p>
</li>
<li><p>New(config Config):定义一个配置对象，这是在很多选项的情况很多gopher采用的一种方式</p>
</li>
<li><p>New(options ...func(*Server))： 使用功能选项WithHost、WithPort、WithTimeout等作为opton</p>
</li>
<li><p>链式构建：如上面的例子，Go生态圈中少用</p>
</li>
</ul>
<p>我看到功能选项有被滥用的趋势，也有人建议我开发的rpcx框架中使用功能选项模式，我拒绝了，因为简单的一个字段的赋值就使用功能选项，我个人认为有点大材小用了，但是我也没有大张旗鼓的去写文章去批判它，我怕会被它的拥趸群起攻之。选择自己喜欢的就好。所以etcd的作者就同时使用了两种方式，萝卜白菜，各取所爱：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> New(cfg Config) (*Client, error)</div><div class="line"><span class="keyword">func</span> NewCtxClient(ctx context.Context, opts ...Option) *Client</div></pre></td></tr></table></figure>

<p>写于 7.26凌晨</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>中文翻译成 建造者模式、生成器模式。</p>
<p>一个遵循《设计模式》一书臆造出来的例子如： <a href="https://refactoring.guru/design-patterns/builder/go/example" target="_blank" rel="external">Builder in Go / Design Patterns (refactoring.guru)</a>，复杂又难以理解。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[真实世界的Go设计模式 - 工厂模式]]></title>
    <link href="https://colobu.com/2023/07/24/go-design-patterns-factory/"/>
    <id>https://colobu.com/2023/07/24/go-design-patterns-factory/</id>
    <published>2023-07-24T14:37:23.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>工厂模式(Factory pattern)是一种创建型模式，就是用来创建新对象的一种设计模式,它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>23种设计模式中包含抽象工厂模式，工厂方法模式，其他也有人总结出简单工厂模式。这个工厂大量的依赖接口、抽象类和具体的类实现。在Go中，才不会有这么复杂的工厂创建模式，Go中最常见的工厂模式类似简单工厂模式，而且一般都是通过<code>New</code>或者<code>NewXXX</code>来实现。</p>
<a id="more"></a>
<p>比如我们要实现一个存储数据结构，它可能是基于内存的存储，也可能是一个基于磁盘的存储，抑或者是一个基于临时文件的存储,不管怎么样，我们先定义一个<code>Store</code>接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> data</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"io"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> {</div><div class="line">    Open(<span class="typename">string</span>) (io.ReadWriteCloser, error)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>再定义不同的Store实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> data</div><div class="line"></div><div class="line"><span class="keyword">type</span> StorageType <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    DiskStorage StorageType =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span></div><div class="line">    TempStorage</div><div class="line">    MemoryStorage</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewStore(t StorageType) Store {</div><div class="line">    <span class="keyword">switch</span> t {</div><div class="line">    <span class="keyword">case</span> MemoryStorage:</div><div class="line">        <span class="keyword">return</span> newMemoryStorage( <span class="comment">/*...*/</span> )</div><div class="line">    <span class="keyword">case</span> DiskStorage:</div><div class="line">        <span class="keyword">return</span> newDiskStorage( <span class="comment">/*...*/</span> )</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> newTempStorage( <span class="comment">/*...*/</span> )</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s, _ := data.NewStore(data.MemoryStorage)</div><div class="line">f, _ := s.Open(<span class="string">"file"</span>)</div><div class="line"></div><div class="line">n, _ := f.Write([]<span class="typename">byte</span>(<span class="string">"data"</span>))</div><div class="line"><span class="keyword">defer</span> f.Close()</div></pre></td></tr></table></figure>

<p>(以上例子摘自<a href="https://github.com/tmrts/go-patterns" target="_blank" rel="external">https://github.com/tmrts/go-patterns</a>)</p>
<p>更进一步，甚至我们都不会创建一个接口，比如Go标准库的<code>net/http.NewRequestWithContext</code>,用来创建一个<code>*http.Request</code>对象。</p>
<p>根据body类型的不同它会创建不同的<code>request.GetBody</code>，这里没有使用接口，一个struct足够了，因为<code>GetBody</code>是一个函数指针，你可以根据参数的不同生成不同的Request。这里充分利用了Go的type switch、func pointer等特性，不用生成复杂的接口和具体类。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewRequestWithContext(ctx context.Context, method, url <span class="typename">string</span>, body io.Reader) (*Request, error) {</div><div class="line">	...</div><div class="line">	</div><div class="line">	u.Host = removeEmptyPort(u.Host)</div><div class="line">	req := &Request{</div><div class="line">		ctx:        ctx,</div><div class="line">		Method:     method,</div><div class="line">		URL:        u,</div><div class="line">		Proto:      <span class="string">"HTTP/1.1"</span>,</div><div class="line">		ProtoMajor:<span class="number"> 1</span>,</div><div class="line">		ProtoMinor:<span class="number"> 1</span>,</div><div class="line">		Header:     <span class="built_in">make</span>(Header),</div><div class="line">		Body:       rc,</div><div class="line">		Host:       u.Host,</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> body != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">switch</span> v := body.(<span class="keyword">type</span>) {</div><div class="line">		<span class="keyword">case</span> *bytes.Buffer:</div><div class="line">			req.ContentLength = <span class="typename">int64</span>(v.Len())</div><div class="line">			buf := v.Bytes()</div><div class="line">			req.GetBody = <span class="keyword">func</span>() (io.ReadCloser, error) {</div><div class="line">				r := bytes.NewReader(buf)</div><div class="line">				<span class="keyword">return</span> io.NopCloser(r), <span class="constant">nil</span></div><div class="line">			}</div><div class="line">		<span class="keyword">case</span> *bytes.Reader:</div><div class="line">			req.ContentLength = <span class="typename">int64</span>(v.Len())</div><div class="line">			snapshot := *v</div><div class="line">			req.GetBody = <span class="keyword">func</span>() (io.ReadCloser, error) {</div><div class="line">				r := snapshot</div><div class="line">				<span class="keyword">return</span> io.NopCloser(&r), <span class="constant">nil</span></div><div class="line">			}</div><div class="line">		<span class="keyword">case</span> *strings.Reader:</div><div class="line">			req.ContentLength = <span class="typename">int64</span>(v.Len())</div><div class="line">			snapshot := *v</div><div class="line">			req.GetBody = <span class="keyword">func</span>() (io.ReadCloser, error) {</div><div class="line">				r := snapshot</div><div class="line">				<span class="keyword">return</span> io.NopCloser(&r), <span class="constant">nil</span></div><div class="line">			}</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> req.GetBody != <span class="constant">nil</span> && req.ContentLength ==<span class="number"> 0</span> {</div><div class="line">			req.Body = NoBody</div><div class="line">			req.GetBody = <span class="keyword">func</span>() (io.ReadCloser, error) { <span class="keyword">return</span> NoBody, <span class="constant">nil</span> }</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> req, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>一个更好的例子就是<code>database/sql</code>下的<code>Open方法</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Open(driverName, dataSourceName <span class="typename">string</span>) (*DB, error)</div></pre></td></tr></table></figure>

<p>你子需要提供不同的数据库类型名，以及dcn，就能生成一个对应的<code>*DB</code>对象，注意DB是struct,并没有定义一个 <code>DB</code>类型的接口。</p>
<p>它的具体实现是这样的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Open(driverName, dataSourceName <span class="typename">string</span>) (*DB, error) {</div><div class="line">	driversMu.RLock()</div><div class="line">	driveri, ok := drivers[driverName]</div><div class="line">	driversMu.RUnlock()</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"sql: unknown driver %q (forgotten import?)"</span>, driverName)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> driverCtx, ok := driveri.(driver.DriverContext); ok {</div><div class="line">		connector, err := driverCtx.OpenConnector(dataSourceName)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> OpenDB(connector), <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> OpenDB(dsnConnector{dsn: dataSourceName, driver: driveri}), <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它会从一个表(<code>drivers</code>)找到对应的工厂(driver), 然后调用这个工厂的<code>OpenConnector</code>得到一个连接器(或者直接生成一个dsnConnector)，最后调用<code>OpenDB</code>创建DB对象。</p>
<p>不同的数据库类型可以通过<code>Register(name string, driver driver.Driver)</code>注册特定的数据库驱动，比如mysql的驱动：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	sql.Register(<span class="string">"mysql"</span>, &MySQLDriver{})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>clickhouse驱动：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	<span class="keyword">var</span> debugf = <span class="keyword">func</span>(format <span class="typename">string</span>, v ...any) {}</div><div class="line">	sql.Register(<span class="string">"clickhouse"</span>, &stdDriver{debugf: debugf})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>针对这种有具体的不同实现的场景，Go的套路经常是用一个<strong>表</strong>来注册不同的实现，创建的时候查找找到相应的实现方式。如果rpcx微服务框架在支持不同的连接协议时，也是通过查找找到相应的创建方法创建连接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	makeListeners[<span class="string">"tcp"</span>] = tcpMakeListener(<span class="string">"tcp"</span>)</div><div class="line">	makeListeners[<span class="string">"tcp4"</span>] = tcpMakeListener(<span class="string">"tcp4"</span>)</div><div class="line">	makeListeners[<span class="string">"tcp6"</span>] = tcpMakeListener(<span class="string">"tcp6"</span>)</div><div class="line">	makeListeners[<span class="string">"http"</span>] = tcpMakeListener(<span class="string">"tcp"</span>)</div><div class="line">	makeListeners[<span class="string">"ws"</span>] = tcpMakeListener(<span class="string">"tcp"</span>)</div><div class="line">	makeListeners[<span class="string">"wss"</span>] = tcpMakeListener(<span class="string">"tcp"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *Server) makeListener(network, address <span class="typename">string</span>) (ln net.Listener, err error) {</div><div class="line">	ml := makeListeners[network]</div><div class="line">	<span class="keyword">if</span> ml == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"can not make listener for %s"</span>, network)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"wss"</span> && s.tlsConfig == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, errors.New(<span class="string">"must set tlsconfig for wss"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ml(s, address)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>工厂模式(Factory pattern)是一种创建型模式，就是用来创建新对象的一种设计模式,它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>23种设计模式中包含抽象工厂模式，工厂方法模式，其他也有人总结出简单工厂模式。这个工厂大量的依赖接口、抽象类和具体的类实现。在Go中，才不会有这么复杂的工厂创建模式，Go中最常见的工厂模式类似简单工厂模式，而且一般都是通过<code>New</code>或者<code>NewXXX</code>来实现。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[100个Go编程错误小抄]]></title>
    <link href="https://colobu.com/2023/07/18/cheatsheet-of-100-go-mistakes/"/>
    <id>https://colobu.com/2023/07/18/cheatsheet-of-100-go-mistakes/</id>
    <published>2023-07-18T14:08:21.000Z</published>
    <updated>2023-09-24T07:01:49.790Z</updated>
    <content type="html"><![CDATA[<p>这是针对《100 Go mistakes and how to avoid them》 一书的总结。作者能总结出100条易犯的错误很不容易，最接近这个数目的是<a href="https://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a>,没想到那已经是9年前的文章了。</p>
<a id="more"></a>
<p><img src="100gomistakes.jpg" alt=""></p>
<p>我把它整理成小抄的形式，更容易快速预览，适合紧张忙碌的996的码农们。第一列是作者总结的错误，后面一列加上我个人的经验，一句话经验。</p>
<p><img src="100gomistakes.png" alt=""></p>
<p>pdf格式下载请点击 <a href="https://colobu.com/2023/07/18/cheatsheet-of-100-go-mistakes/100gomistakes.pdf" target="_blank" rel="external">小抄下载</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是针对《100 Go mistakes and how to avoid them》 一书的总结。作者能总结出100条易犯的错误很不容易，最接近这个数目的是<a href="https://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a>,没想到那已经是9年前的文章了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么说并发编程很难？]]></title>
    <link href="https://colobu.com/2023/07/16/why-conucrrent-programming-is-hard/"/>
    <id>https://colobu.com/2023/07/16/why-conucrrent-programming-is-hard/</id>
    <published>2023-07-16T15:30:06.000Z</published>
    <updated>2023-09-24T07:01:49.818Z</updated>
    <content type="html"><![CDATA[<p>最近看到一本关于算法的新书，买过来学习。<br>这本书中有一道并发问题，也是我先前多次分过的一道题：水分子的产生：<br><a id="more"></a></p>
<p><img src="problem.jpg" alt=""></p>
<p>这是一道并发题，在《The Little Book of Semaphores》v2.2.1 2006年版本中就有这道题(&quot;Building H2O&quot;),而且据作者说这道题已经在伯克利大学的操作系统课程中十余年了，看起来是Andrews的并发编程的一道练习题。</p>
<p>这道题也被收编到leetcode的并发题中：<a href="https://leetcode.cn/problems/building-h2o/" target="_blank" rel="external">H2O 生成</a>。题目和这本书中的内容一样，是一道标记为中等难度的题目。</p>
<p>所以说这道题至少存在30年了，理论上大家对这道题目研究的就是透透的。</p>
<p>书中的解答和力扣中国的评论区解答的第一名是类似的,这是书上的解答：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">H2O</span>() {</div><div class="line">    </div><div class="line">}</div><div class="line"> <span class="keyword">private</span> Semaphore h = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</div><div class="line"> <span class="keyword">private</span> Semaphore o = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span>(Runnable releaseHydrogen) <span class="keyword">throws</span> InterruptedException {</div><div class="line">	h.acquire(<span class="number">1</span>);</div><div class="line">    releaseHydrogen.run();</div><div class="line">    o.release(<span class="number">1</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span>(Runnable releaseOxygen) <span class="keyword">throws</span> InterruptedException {</div><div class="line">    o.acquire(<span class="number">2</span>);</div><div class="line">	releaseOxygen.run();</div><div class="line">    h.release(<span class="number">2</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先这个解答有一个明显的瑕疵：<code>private Semaphore o = new Semaphore(2);</code>这一句应该初始化为0，而不是2，否则氧原子初始的时候毫无顾忌的就执行，一下释放四个氢原子。这是问题一。</p>
<p>力扣中国评论区第一名初始化就是正确的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="title">H2O</span>() {</div><div class="line">    </div><div class="line">}</div><div class="line"> <span class="keyword">private</span> Semaphore h = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</div><div class="line"> <span class="keyword">private</span> Semaphore o = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"></div><div class="line"> ......</div></pre></td></tr></table></figure>

<p>这个代码看起来非常的简洁清爽，而且易懂，如果你提交代码，很快就通过，而且时间花费也很好，但是这个解答就对么？</p>
<p>回顾一下这个题目，其中有一条要求，就是<strong>每个水分子的原子必须来自不同的线程</strong>。</p>
<p>但是上面的Java实现，两个氢原子可能来自同一个线程，违反了“三三成组”的原则。 </p>
<p>可是为什么答案还能提交通过呢？只能说力扣的测试集设置的不好，它并没有区分H来自哪个线程，只要输出&quot;HHO&quot;的组合就算通过了。</p>
<p>一个修改版Java代码实现如下，代码也不复杂，增加了一个phaser同步原语：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line">class H2O {</div><div class="line">    <span class="keyword">private</span> Semaphore semO;</div><div class="line">    <span class="keyword">private</span> Semaphore semH;</div><div class="line">    <span class="keyword">private</span> Phaser phaser;</div><div class="line">    <span class="keyword">public</span> <span class="title">H2O</span>() {</div><div class="line">        semO = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line">        semH = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</div><div class="line">        phaser = <span class="keyword">new</span> Phaser(<span class="number">3</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span>(Runnable releaseHydrogen) <span class="keyword">throws</span> InterruptedException {</div><div class="line">        semH.acquire();</div><div class="line">        releaseHydrogen.run();</div><div class="line">        phaser.arriveAndAwaitAdvance();</div><div class="line">        semH.release();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span>(Runnable releaseOxygen) <span class="keyword">throws</span> InterruptedException {</div><div class="line">        semO.acquire();</div><div class="line">        releaseOxygen.run();</div><div class="line">        phaser.arriveAndAwaitAdvance();</div><div class="line">        semO.release();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以你看，即使是一个存在了30年的并发老题，要想写对也不容易。</p>
<p>我在百度也Review了几十个同学的good coder题，发现有至少一半以上的同学都出现过并发的问题，所以虽然说使用Go、Java语言很容易写并发程序，但是能写好确实是意见比较困难的事。</p>
<p>重点来了，这里我给大家推荐我的一本即将上线的新书<a href="https://cpgo.colobu.com/" target="_blank" rel="external">《深入理解Go并发编程》</a>，经过了4年多的沉淀和积累，厚积薄发，全面介绍Go并发编程方方面面，敬请期待。</p>
<p><img src="cpgo.png" alt=""></p>
<p>在这本书中，也剖析了这道题，并给出了Go语言的一个解法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> water</div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"github.com/marusama/cyclicbarrier"</span></div><div class="line">    <span class="string">"golang.org/x/sync/semaphore"</span></div><div class="line">)</div><div class="line"><span class="keyword">type</span> H2O <span class="keyword">struct</span> {</div><div class="line">    semaH *semaphore.Weighted</div><div class="line">    semaO *semaphore.Weighted</div><div class="line">    b     cyclicbarrier.CyclicBarrier</div><div class="line">}</div><div class="line"><span class="keyword">func</span> New() *H2O {</div><div class="line">    <span class="keyword">return</span> &H2O{</div><div class="line">        semaH: semaphore.NewWeighted<span class="number">(2</span>),</div><div class="line">        semaO: semaphore.NewWeighted<span class="number">(1</span>),</div><div class="line">        b:     cyclicbarrier.New<span class="number">(3</span>),</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (h2o *H2O) hydrogen(releaseHydrogen <span class="keyword">func</span>()) {</div><div class="line">    h2o.semaH.Acquire(context.Background(),<span class="number"> 1</span>)</div><div class="line">    <span class="comment">// releaseHydrogen() 输出一个H</span></div><div class="line">    releaseHydrogen()</div><div class="line">    h2o.b.Await(context.Background())</div><div class="line">    h2o.semaH.Release<span class="number">(1</span>)</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (h2o *H2O) oxygen(releaseOxygen <span class="keyword">func</span>()) {</div><div class="line">    h2o.semaO.Acquire(context.Background(),<span class="number"> 1</span>)</div><div class="line">    <span class="comment">// releaseOxygen() 输出一个O</span></div><div class="line">    releaseOxygen()</div><div class="line">    h2o.b.Await(context.Background())</div><div class="line">    h2o.semaO.Release<span class="number">(1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>最近看到一本关于算法的新书，买过来学习。<br>这本书中有一道并发问题，也是我先前多次分过的一道题：水分子的产生：<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MPTCP: 一个在 Go 1.21中的被忽略的新特性]]></title>
    <link href="https://colobu.com/2023/07/03/mptcp-a-go-1-21-new-feature/"/>
    <id>https://colobu.com/2023/07/03/mptcp-a-go-1-21-new-feature/</id>
    <published>2023-07-02T16:23:42.000Z</published>
    <updated>2023-09-24T07:01:49.817Z</updated>
    <content type="html"><![CDATA[<p>Go 1.21 再有两三个月就发布了，很多同学都已经总结了Go 1.21的新特性了，为新的Go版本的到来造势，但是我还没看到有同学专门介绍Go 1.21为网络库新增加的一个特性，所以我专门新开一篇专门来介绍。</p>
<a id="more"></a>
<p>关于MPTCP这个新特性，专门有一个issue (<a href="https://github.com/golang/go/issues/56539" target="_blank" rel="external">#56539</a>)跟进和讨论。它是一个对TCP的单路径的扩展，由<a href="https://www.rfc-editor.org/rfc/rfc8684.html" target="_blank" rel="external">RFC8684</a>规范来定义。</p>
<p>多路径传输控制协议（Multipath TCP，简称MPTCP）是一种在传输层的协议，旨在增强传统的单路径TCP协议，使其能够在多个网络路径上同时传输数据。MPTCP允许同时利用多条路径进行数据传输，提供更高的带宽、更好的负载均衡和更高的可靠性。<br>传统的TCP协议是为单路径设计的，它通过在端到端之间的单个连接上进行数据传输。而MPTCP通过引入额外的功能，使得一个TCP连接可以同时在多个网络路径上运行。<br>MPTCP的工作原理如下：</p>
<ol>
<li><strong>建立连接</strong>：MPTCP的连接建立过程与传统的TCP类似，但在初始握手时，双方会交换能力选项，以确定是否支持MPTCP。</li>
<li><strong>子流建立</strong>：一旦MPTCP连接建立，它可以启动多个子流（subflow），每个子流通过不同的网络路径传输数据。这些子流可以通过不同的IP地址和端口号来标识。</li>
<li><strong>路径管理</strong>：MPTCP使用路径管理机制来选择和管理多个网络路径。它可以根据路径的质量、延迟、带宽等指标进行路径选择，并根据网络条件动态地调整路径的使用。</li>
<li><strong>数据传输</strong>：MPTCP将数据分割成适当大小的数据块，并在不同的子流上发送。接收端会根据数据块的序列号和数据块所属的子流来重新组装数据。</li>
</ol>
<p>MPTCP的优点包括：</p>
<ul>
<li><strong>带宽增强</strong>：MPTCP可以同时利用多个路径的带宽，从而提供更高的总体带宽。</li>
<li><strong>负载均衡</strong>：MPTCP可以根据路径质量和可用带宽动态地调整数据传输，实现负载均衡，提高网络资源利用率。</li>
<li><strong>容错性</strong>：由于数据可以通过多个路径传输，MPTCP可以提供更好的容错性。即使某个路径出现故障，数据仍然可以通过其他可用路径进行传输。</li>
<li><strong>移动性支持</strong>：MPTCP可以在移动设备切换网络时维持连接，无需重新建立连接，提供更平滑的移动体验。</li>
</ul>
<p>MPTCP已经成为一项标准化的协议，它被广泛应用于多路径传输场景，例如<strong>数据中心内部通信</strong>、<strong>无线网络</strong>和<strong>移动网络</strong>等。</p>
<p>比如apple官方文档指出：</p>
<blockquote>
<p>iOS 支持 Multipath TCP (MPTCP)，并且允许 iPhone 或 iPad 通过蜂窝数据连接建立与目标主机的备份 TCP 连接。<br>iPhone 和 iPad 在具有有效的蜂窝数据连接的情况下使用 MPTCP 来建立两个连接：</p>
<ul>
<li>通过 Wi-Fi 的主要 TCP 连接</li>
<li>通过蜂窝数据的备用连接</li>
</ul>
<p>如果 Wi-Fi 不可用或无响应，iOS 会使用蜂窝数据连接。<br><a href="https://support.apple.com/zh-cn/HT201373" target="_blank" rel="external">https://support.apple.com/zh-cn/HT201373</a></p>
</blockquote>
<p>小红帽的官方帮助文档也对MPTCP进行了专门的<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/getting-started-with-multipath-tcp_configuring-and-managing-networking#understanding-mptcp_getting-started-with-multipath-tcp" target="_blank" rel="external">介绍</a>。</p>
<p>MPTCP在Linux内核中得到广泛支持，并且已经成为Linux内核的一部分。ChatGPT说从Linux内核版本3.6开始，MPTCP就被纳入主线内核，用户可以通过配置和使用MPTCP功能,但是<a href="https://www.mptcp.dev/" target="_blank" rel="external">MPTCP社区网站</a>说MPTCP v1是5.6才开始支持。<br>Linux发行版如Ubuntu、Fedora和Debian等通常默认包含MPTCP支持。自Linux 5.19开始，MPTCP包含以下的特性：</p>
<ul>
<li>支持<code>socket</code>系统调用中设置<code>IPPROTO_MPTCP</code>协议</li>
<li>如果对方或中间设备不支持 MPTCP，则从 MPTCP 回退到 TCP</li>
<li>使用内核内或用户空间路径管理器进行路径管理</li>
<li>同样使用 TCP 套接字的套接字选项</li>
<li>调试功能，包括 MIB 计数器、诊断支持（使用ss命令）和跟踪点</li>
</ul>
<p>经过Go社区和MPTCP社区同学的努力，在Go 1.21版本中终于找到和实现一个方便支持MPTCP方式，总结来说，就是下面的四个方法。</p>
<p>对于TCP client，你可以通过下面的方法设置以及检查是否支持MPTCP:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (*Dialer) SetMultipathTCP(enabled <span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span> (*Dialer) MultipathTCP() <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>对于TCP server，你可以通过下面的方法设置以及检查是否支持MPTCP:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (*ListenConfig) SetMultipathTCP(enabled <span class="typename">bool</span>)</div><div class="line"><span class="keyword">func</span> (*ListenConfig) MultipathTCP() <span class="typename">bool</span></div></pre></td></tr></table></figure>

<p>所以对于一个系统，客户端和服务器端都需要进行设置，才能保证MPTCP启作用。</p>
<p>我以一个简单的例子演示如何使用MPTCP。</p>
<p>服务器端代码如下，为Listener启用mptcp，和客户端建立的连接可能支持mptcp,也可能退化成普通的tcp：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"errors"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">":8080"</span>, <span class="string">"service address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	lc := &net.ListenConfig{}</div><div class="line">	<span class="keyword">if</span> lc.MultipathTCP() { <span class="comment">// 默认mptcp是禁用的</span></div><div class="line">		<span class="built_in">panic</span>(<span class="string">"MultipathTCP should be off by default"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	lc.SetMultipathTCP(<span class="constant">true</span>) <span class="comment">// 主动启用mptcp</span></div><div class="line"></div><div class="line">	ln, err := lc.Listen(context.Background(), <span class="string">"tcp"</span>, *addr) <span class="comment">// 正常tcp监听</span></div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		conn, err := ln.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">			isMultipathTCP, err := conn.(*net.TCPConn).MultipathTCP() <span class="comment">// 检查连接是否支持了mptcp</span></div><div class="line">			fmt.Printf(<span class="string">"accepted connection from %s with mptcp: %t, err: %v\n"</span>, conn.RemoteAddr(), isMultipathTCP, err)</div><div class="line"></div><div class="line">			<span class="keyword">for</span> {</div><div class="line">				buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line">				n, err := conn.Read(buf)</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					<span class="keyword">if</span> errors.Is(err, io.EOF) {</div><div class="line">						<span class="keyword">return</span></div><div class="line">					}</div><div class="line">					<span class="built_in">panic</span>(err)</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> _, err := conn.Write(buf[:n]); err != <span class="constant">nil</span> {</div><div class="line">					<span class="built_in">panic</span>(err)</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端代码如下，我们为dialer启用了mptcp,并且检查建立好的连接是否真的支持mptcp,因为客户端或服务器不支持mptcp的话，就退化成普通的tcp了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"127.0.0.1:8080"</span>, <span class="string">"service address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	d := &net.Dialer{}</div><div class="line">	<span class="keyword">if</span> d.MultipathTCP() { <span class="comment">// 默认不启用</span></div><div class="line">		<span class="built_in">panic</span>(<span class="string">"MultipathTCP should be off by default"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	d.SetMultipathTCP(<span class="constant">true</span>) <span class="comment">// 主动启用</span></div><div class="line">	<span class="keyword">if</span> !d.MultipathTCP() { <span class="comment">// 已经设置dial的时候使用mptcp</span></div><div class="line">		<span class="built_in">panic</span>(<span class="string">"MultipathTCP is not on after having been forced to on"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	c, err := d.Dial(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	<span class="keyword">defer</span> c.Close()</div><div class="line"></div><div class="line">	tcp, ok := c.(*net.TCPConn)</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"struct is not a TCPConn"</span>)</div><div class="line">	}</div><div class="line">	mptcp, err := tcp.MultipathTCP() <span class="comment">// 建立的连接是否真的支持mptcp</span></div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"outgoing connection from %s with mptcp: %t\n"</span>, *addr, mptcp)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !mptcp { <span class="comment">// 不支持mptcp, panic</span></div><div class="line">		<span class="built_in">panic</span>(<span class="string">"outgoing connection is not with MPTCP"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		snt := []<span class="typename">byte</span>(<span class="string">"MPTCP TEST"</span>)</div><div class="line">		<span class="keyword">if</span> _, err := c.Write(snt); err != <span class="constant">nil</span> {</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		}</div><div class="line">		b := <span class="built_in">make</span>([]<span class="typename">byte</span>, <span class="built_in">len</span>(snt))</div><div class="line">		<span class="keyword">if</span> _, err := c.Read(b); err != <span class="constant">nil</span> {</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		fmt.Println(<span class="typename">string</span>(b))</div><div class="line"></div><div class="line">		time.Sleep(time.Second)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.21 再有两三个月就发布了，很多同学都已经总结了Go 1.21的新特性了，为新的Go版本的到来造势，但是我还没看到有同学专门介绍Go 1.21为网络库新增加的一个特性，所以我专门新开一篇专门来介绍。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[替换标准库的map实现，SwissTable更快？]]></title>
    <link href="https://colobu.com/2023/06/29/replace-std-map-faster/"/>
    <id>https://colobu.com/2023/06/29/replace-std-map-faster/</id>
    <published>2023-06-28T22:05:13.000Z</published>
    <updated>2023-09-24T07:01:49.817Z</updated>
    <content type="html"><![CDATA[<p>在最新的一期Go开发团队的每周会议中，他们讨论了Google3再评估SwissTable的性能，或许值得跟进，替换标准库的map。</p>
<blockquote>
<ul>
<li>SwissTable<ul>
<li>[MichaelP]: Google3 may want to do some benchmarking on this. Maps are used heavily in google3. This may be of value to us.</li>
<li>So this may be worth investing in.</li>
</ul>
</li>
</ul>
</blockquote>
<a id="more"></a>
<p>可能有的同学不了解SwissTable (或者叫Swiss Tables)是啥?Google3又是啥？</p>
<p>Google3或许谷歌内部的同学比较熟悉，但是外部很少介绍这个概念的。<code>Google3</code>指的就是谷歌的那个大单体代码仓库(monorepo),谷歌95%的代码都在这个大仓库下，除了Chrome 和 Android等特殊的一些项目。</p>
<p>SwissTable是谷歌开源的一个哈希表(hash table、map)的实现，在cppcon 2017大会上公布<a href="https://www.youtube.com/watch?v=ncHmEUmJZf4" target="_blank" rel="external">出来</a>，Google内部大量采用它替换<code>std:unordered_map</code>,精巧的设计使的它非常的高效，它也被port到其他语言，比如Rust语言中有一个库<a href="https://crates.io/crates/hashbrown" target="_blank" rel="external">hashbrown</a>就是根据SwissTable实现的，并且在Rust 1.36中开始替换标准库的HashMap。</p>
<p>官方文档和一些开发者的介绍SwissTable的优点，比如</p>
<ul>
<li><a href="https://abseil.io/about/design/swisstables" target="_blank" rel="external">Swiss Tables Design Notes</a></li>
<li><a href="https://faultlore.com/blah/hashbrown-tldr/" target="_blank" rel="external">Swisstable, a Quick and Dirty Description</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/485294786" target="_blank" rel="external">Swisstable：C++中比std::unordered_map更快的hash表</a></li>
</ul>
<p>所以Go开发团队也开始关注SwissTable,或许在将来的某个版本实现它并替换标准库的map,毕竟这些基础的数据类型和算法的提升会帮助千千万万使用Go做开发的项目，比如排序算法吧，去年字节的同学提交了一个pdqsort算法，替换了标准库中的排序算法，现在又有人提出了<a href="https://github.com/golang/go/issues/61027" target="_blank" rel="external">dual-pivot quicksort</a>,据测试性能更好更简洁，大家对几十年来一直使用的这些人基础算法和数据结构还是孜孜不倦的进行优化。</p>
<p>虽然Go开发团队目前也只是关注和讨论SwissTable,将来也未必实现，但是社区最近也有人自己实现了SwissTable: <a href="https://github.com/dolthub/swiss" target="_blank" rel="external">swiss</a>。</p>
<p>我在去年的一篇文章中<a href="https://colobu.com/2022/12/21/use-the-builtin-map-hasher/" target="_blank" rel="external">机智！生抠 map的哈希函数</a>,就介绍这位作者的<a href="https://github.com/dolthub/maphash" target="_blank" rel="external">maphash</a>,看样子作者一直在为他的SwissTable做准备，今年他就提交了SwissTable的Go语言实现，其中计算哈希的方法就是使用他的maphash。</p>
<p>作者专门写了一篇文章介绍他的<a href="https://www.dolthub.com/blog/2023-03-28-swiss-map/" target="_blank" rel="external">swiss</a>设计，我们至少可以从这个库中了解Go语言如何设计SwissTable,也有在一些优化场景下你可以私用这个库替换内建的map,正如作者那样。</p>
<p>内建的map采用开放寻址法(<code>open-hashing</code>，也叫拉链法),哈希值冲突(哈希值一样)的键值对会被放在一个桶中，查找的时候，先根据哈希值找到对应的桶，然后再遍历桶中的元素，找到对应的值，当然这里面还是有一些优化的，通过额外的bit做更快的检查，内建的map细节可以参看2016 GopherCon大会的分享：<a href="https://youtu.be/Tl7mi9QmLns?t=596" target="_blank" rel="external">Inside the Map Implementation</a>。</p>
<p>SwissTable 使用一种称为“封闭哈希”（<code>Closed Hashing</code>,也叫开地址法）的不同哈希方案。每一个哈希值都会有一个自己的槽(<code>slot</code>),槽的选择是由哈希值决定，最简单的方式就是从<code>hash(key) mod size</code>的槽开始查找，一直往后查找，直到直到对应的键或者空的槽(不存在的 key),这也是开地址法常见的套路。SwissTable也是和内建的map一样采用短哈希(<code>short hash</code>),以便支持快速检查，但是它的元数据却是独立存储的，和哈希值存储分开。</p>
<p>使用这种方式，对CPU的cache更友好，更重要的是，可以通过SSE 指令并行比较 16 个短哈希。</p>
<p>因为find方法是其他方法<code>Get()</code>、 <code>Has()</code>、 <code>Put()</code>、<code>Delete()</code>的基础，它要查找对应的槽位，所以我们看看swiss这个库它是如何实现上面的逻辑的(伪代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m Map) find(key) (slot <span class="typename">int</span>, ok <span class="typename">bool</span>) {</div><div class="line">    h1, h2 := hashOf(key)            <span class="comment">// 高低 hash bit，类似内建的map的处理，实现短地址</span></div><div class="line">    s := modulus(h1, <span class="built_in">len</span>(m.keys)<span class="number">/16</span>) <span class="comment">// 计算探测开始的位置</span></div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        <span class="comment">// 使用SSE指令实现的探针， 使用h2进行短地址匹配</span></div><div class="line">        matches := matchH2(m.metadata[s:s<span class="number">+16</span>], h2)</div><div class="line">        <span class="keyword">for</span> _, idx := <span class="keyword">range</span> matches {</div><div class="line">            <span class="keyword">if</span> m.keys[idx] == key { </div><div class="line">                <span class="keyword">return</span> idx, <span class="constant">true</span> <span class="comment">// 找到，返回对应的槽位</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// 利用SSE指令，寻找空槽位</span></div><div class="line">        matches = matchEmpty(m.metadata[s:s<span class="number">+16</span>])</div><div class="line">        <span class="keyword">for</span> _, idx := <span class="keyword">range</span> matches {</div><div class="line">            <span class="keyword">return</span> idx, <span class="constant">false</span> <span class="comment">// 发现空槽位，返回</span></div><div class="line">        }</div><div class="line">        s +=<span class="number"> 16</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个库还提供了benchmark的代码，我们在Apple M2和虚机上分别测试它和内建map的性能。</p>
<figure class="highlight sh"><figcaption><span>Apple M1</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">goos: darwin</div><div class="line">goarch: arm64</div><div class="line">pkg: github.com/dolthub/swiss</div><div class="line"></div><div class="line">BenchmarkStringMaps/n=<span class="number">16</span>/runtime_map-<span class="number">8</span>         	<span class="number">190298112</span>	         <span class="number">6.716</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">16</span>/swiss.Map-<span class="number">8</span>           	<span class="number">114514650</span>	         <span class="number">9.000</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">128</span>/runtime_map-<span class="number">8</span>        	<span class="number">181336688</span>	         <span class="number">6.934</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">128</span>/swiss.Map-<span class="number">8</span>          	<span class="number">124560243</span>	        <span class="number">13.63</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">1024</span>/runtime_map-<span class="number">8</span>       	<span class="number">100000000</span>	        <span class="number">10.09</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">1024</span>/swiss.Map-<span class="number">8</span>         	<span class="number">100000000</span>	        <span class="number">11.27</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">8192</span>/runtime_map-<span class="number">8</span>       	<span class="number">60224208</span>	        <span class="number">19.38</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">8192</span>/swiss.Map-<span class="number">8</span>         	<span class="number">88910022</span>	        <span class="number">13.28</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">131072</span>/runtime_map-<span class="number">8</span>     	<span class="number">53933996</span>	        <span class="number">22.12</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">131072</span>/swiss.Map-<span class="number">8</span>       	<span class="number">76083596</span>	        <span class="number">16.36</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">16</span>/runtime_map-<span class="number">8</span>          	<span class="number">262228116</span>	         <span class="number">4.678</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">16</span>/swiss.Map-<span class="number">8</span>            	<span class="number">227993193</span>	         <span class="number">5.439</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">128</span>/runtime_map-<span class="number">8</span>         	<span class="number">242425221</span>	         <span class="number">4.708</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">128</span>/swiss.Map-<span class="number">8</span>           	<span class="number">185926908</span>	         <span class="number">5.876</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">1024</span>/runtime_map-<span class="number">8</span>        	<span class="number">173284822</span>	         <span class="number">6.709</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">1024</span>/swiss.Map-<span class="number">8</span>          	<span class="number">186861410</span>	         <span class="number">6.550</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">8192</span>/runtime_map-<span class="number">8</span>        	<span class="number">71231763</span>	        <span class="number">16.57</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">8192</span>/swiss.Map-<span class="number">8</span>          	<span class="number">139595205</span>	         <span class="number">8.635</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">131072</span>/runtime_map-<span class="number">8</span>      	<span class="number">64039132</span>	        <span class="number">19.05</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">131072</span>/swiss.Map-<span class="number">8</span>        	<span class="number">100000000</span>	        <span class="number">11.56</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">PASS</div><div class="line">ok  	github.com/dolthub/swiss	<span class="number">33.538</span>s</div></pre></td></tr></table></figure>



<figure class="highlight sh"><figcaption><span>Linux</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">goos: linux</div><div class="line">goarch: amd64</div><div class="line">pkg: github.com/dolthub/swiss</div><div class="line">cpu: Intel(R) Xeon(R) Platinum <span class="number">8255</span>C CPU @ <span class="number">2.50</span>GHz</div><div class="line"></div><div class="line">BenchmarkStringMaps/n=<span class="number">16</span>/runtime_map-<span class="number">2</span>         	<span class="number">97587910</span>	        <span class="number">12.65</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">16</span>/swiss.Map-<span class="number">2</span>           	<span class="number">61206505</span>	        <span class="number">19.38</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">128</span>/runtime_map-<span class="number">2</span>        	<span class="number">92861481</span>	        <span class="number">13.35</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">128</span>/swiss.Map-<span class="number">2</span>          	<span class="number">58353951</span>	        <span class="number">20.83</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">1024</span>/runtime_map-<span class="number">2</span>       	<span class="number">51516268</span>	        <span class="number">22.70</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">1024</span>/swiss.Map-<span class="number">2</span>         	<span class="number">51832698</span>	        <span class="number">23.09</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">8192</span>/runtime_map-<span class="number">2</span>       	<span class="number">40324459</span>	        <span class="number">29.54</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">8192</span>/swiss.Map-<span class="number">2</span>         	<span class="number">45826951</span>	        <span class="number">26.19</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">131072</span>/runtime_map-<span class="number">2</span>     	<span class="number">26659296</span>	        <span class="number">43.71</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkStringMaps/n=<span class="number">131072</span>/swiss.Map-<span class="number">2</span>       	<span class="number">30621675</span>	        <span class="number">39.84</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">16</span>/runtime_map-<span class="number">2</span>          	<span class="number">128090280</span>	         <span class="number">9.332</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">16</span>/swiss.Map-<span class="number">2</span>            	<span class="number">87047056</span>	        <span class="number">15.01</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">128</span>/runtime_map-<span class="number">2</span>         	<span class="number">125906628</span>	         <span class="number">9.837</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">128</span>/swiss.Map-<span class="number">2</span>           	<span class="number">79239448</span>	        <span class="number">15.52</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">1024</span>/runtime_map-<span class="number">2</span>        	<span class="number">65208208</span>	        <span class="number">17.22</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">1024</span>/swiss.Map-<span class="number">2</span>          	<span class="number">77075527</span>	        <span class="number">15.81</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">8192</span>/runtime_map-<span class="number">2</span>        	<span class="number">48505800</span>	        <span class="number">25.28</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">8192</span>/swiss.Map-<span class="number">2</span>          	<span class="number">64617066</span>	        <span class="number">18.19</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">131072</span>/runtime_map-<span class="number">2</span>      	<span class="number">36938596</span>	        <span class="number">32.38</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkInt64Maps/n=<span class="number">131072</span>/swiss.Map-<span class="number">2</span>        	<span class="number">41026358</span>	        <span class="number">28.41</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div></pre></td></tr></table></figure>

<p>可以看到，在key的数量比较少时,swiss并不能发挥它的SSE指令的优势，但是在key值非常多的情况下， swiss优势明显。<br>前面也介绍了作者的maphash库，在一些支持AES指令平台上，可以利用硬件的能力，更快的计算哈希值。</p>
<p>不止如此，swiss在内存占用上也有它的优点。根据作者的测试,swiss可以更节省内存：<br><img src="chunk-index-memory.jpg" alt=""></p>
<p>内建的map在键的数量增大时，内存会呈现阶梯状的上升，原因在于大家普遍采用的bit-hacking优化模式，为了提高求余数的方法，一般除数都会采用2的指数，因此key数量增大时需要扩展内存时，分配的内存会翻倍。所以你看到Go内建的map的内存会呈现阶梯状的增大，有时候非常的浪费。</p>
<p>swiss库采用了<a href="https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/" target="_blank" rel="external">Daniel Lemire</a>提出的一个快速求余(更准确的说，是modulo reduction)的算法，这个想法看似简单，但实际上非常巧妙 <code>(x * N) / 232</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fastModN(x, n <span class="typename">uint32</span>) <span class="typename">uint32</span> {</div><div class="line">    <span class="keyword">return</span> <span class="typename">uint32</span>((<span class="typename">uint64</span>(x) * <span class="typename">uint64</span>(n)) &gt;&gt;<span class="number"> 32</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个方法限制n的类型是<code>uint32</code>,最大支持 <code>2 ^ 32</code>，又因为每个桶16个元素，所以swiss库最大支持<code>2 ^ 36</code>个元素，对于绝大部分场景，它足够了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在最新的一期Go开发团队的每周会议中，他们讨论了Google3再评估SwissTable的性能，或许值得跟进，替换标准库的map。</p>
<blockquote>
<ul>
<li>SwissTable<ul>
<li>[MichaelP]: Google3 may want to do some benchmarking on this. Maps are used heavily in google3. This may be of value to us.</li>
<li>So this may be worth investing in.</li>
</ul>
</li>
</ul>
</blockquote>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个泛型的有序Go Map实现]]></title>
    <link href="https://colobu.com/2023/06/18/a-generic-sortedmap-in-go/"/>
    <id>https://colobu.com/2023/06/18/a-generic-sortedmap-in-go/</id>
    <published>2023-06-18T14:14:51.000Z</published>
    <updated>2023-09-24T07:01:49.789Z</updated>
    <content type="html"><![CDATA[<p>我们知道， Go内建的map类型对于插入的元素并没有保持它们的插入顺序，遍历的时候也故意设置成<a href="https://github.com/golang/go/issues/6719" target="_blank" rel="external">随机的</a>。因此，如果我们想让map保持元素的插入顺序，需要借助第三方的库才行，今天就给大家介绍一个这样的库<a href="https://rpcx.io/r/12DuBuGc8O5" target="_blank" rel="external">OrderedMap</a>。</p>
<p>其实在其他编程语言中，也有类似的数据结构，比如java中的 <a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/LinkedHashMap.html" target="_blank" rel="external">LinkedHashMap</a>, python中的<code>OrderedDict</code>。</p>
<p>本文介绍如何使用Go语言实现这样的一种数据类型。注意我们要实现的是OrderedMap, 不是SortedMap或者TreeMap，SortedMap遍历的时候是按照Key的排序顺序遍历的，我们可以通过先获取所有的key并排序，再逐个访问对应的值。</p>
<p>但是OrderedMap遍历的时候要是保持插入的顺序，这怎么办到的呢？</p>
<a id="more"></a>
<p>我们看看OrderedMap的功能，既要有HashMap的功能，可以快速得到一个键值对，又要保持插入顺序，那么我们可以通过组合的方式实现。</p>
<ul>
<li>HashMap的功能： 通过内建的map实现</li>
<li>保持插入顺序： 本来可以通过<code>container/list</code>实现，但是为了支持泛型，我们使用 <code>github.com/smallnest/exp/container/list</code>实现。</li>
</ul>
<p>下面就是<code>OrderedMap</code>数据结构，它包含<code>entries</code>和<code>list</code>两个字段。<code>entries</code>是一个map，它的值类型是<code>*Entry</code>; <code>list</code>中的元素是<code>*Entry</code>，和map中的值指向同一个元素:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> OrderedMap[K comparable, V any] <span class="keyword">struct</span> {</div><div class="line">	entries <span class="keyword">map</span>[K]*Entry[K, V]</div><div class="line">	list    *list.List[*Entry[K, V]]</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中<code>Entry</code>的定义如下,除了包含Key和Value值，它还包含一个list的Element元素，这样它就实现了一个双线链表，每个Entry都可以找到对它的前驱和后继： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Entry is a key-value pair in OrderedMap.</span></div><div class="line"><span class="keyword">type</span> Entry[K comparable, V any] <span class="keyword">struct</span> {</div><div class="line">	Key   K</div><div class="line">	Value V</div><div class="line"></div><div class="line">	element *list.Element[*Entry[K, V]]</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Next returns a pointer to the next entry.</span></div><div class="line"><span class="keyword">func</span> (e *Entry[K, V]) Next() *Entry[K, V] {</div><div class="line">	entry := e.element.Next()</div><div class="line">	<span class="keyword">if</span> entry == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> entry.Value</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Prev returns a pointer to the previous entry.</span></div><div class="line"><span class="keyword">func</span> (e *Entry[K, V]) Prev() *Entry[K, V] {</div><div class="line">	entry := e.element.Prev()</div><div class="line">	<span class="keyword">if</span> entry == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> entry.Value</div><div class="line">}</div></pre></td></tr></table></figure>

<p>增加和删除的时候，我们就需要对这两个字段都进行操作，才能保持一致性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *OrderedMap[K, V]) Set(key K, value V) (val V, existed <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">if</span> entry, existed := m.entries[key]; existed { <span class="comment">// 如果key存在，就是更新</span></div><div class="line">		oldValue := entry.Value</div><div class="line">		entry.Value = value</div><div class="line">		<span class="keyword">return</span> oldValue, <span class="constant">true</span></div><div class="line">	}</div><div class="line"></div><div class="line">	entry := &Entry[K, V]{</div><div class="line">		Key:   key,</div><div class="line">		Value: value,</div><div class="line">	}</div><div class="line">	entry.element = m.list.PushBack(entry) <span class="comment">// 加入到链表</span></div><div class="line">	m.entries[key] = entry <span class="comment">// 加入到map中</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> value, <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *OrderedMap[K, V]) Delete(key K) (val V, existed <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">if</span> entry, existed := m.entries[key]; existed { <span class="comment">// 如果存在</span></div><div class="line">		m.list.Remove(entry.element) <span class="comment">// 从链表中移除</span></div><div class="line">		<span class="built_in">delete</span>(m.entries, key) <span class="comment">// 从map中删除</span></div><div class="line">		<span class="keyword">return</span> entry.Value, <span class="constant">true</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>查找的时候直接查找map就可以了，性能没有损失:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *OrderedMap[K, V]) Get(key K) (val V, existed <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">if</span> entry, existed := m.entries[key]; existed {</div><div class="line">		<span class="keyword">return</span> entry.Value, <span class="constant">true</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>遍历的时候，遍历链表结构，因为它保持了插入顺序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *OrderedMap[K, V]) Range(f <span class="keyword">func</span>(key K, value V) <span class="typename">bool</span>) {</div><div class="line">	list := m.list</div><div class="line">	<span class="keyword">for</span> e := list.Front(); e != <span class="constant">nil</span>; e = e.Next() {</div><div class="line">		<span class="keyword">if</span> e.Value != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">if</span> ok := f(e.Value.Key, e.Value.Value); !ok {</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是这个数据结构最主要的方法，当然它还提供更多的方法，比如最老值、最新值、随机遍历等，如果你有相应的需求场景，可以考虑使用它。</p>
<p><img src="sortedmap.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们知道， Go内建的map类型对于插入的元素并没有保持它们的插入顺序，遍历的时候也故意设置成<a href="https://github.com/golang/go/issues/6719" target="_blank" rel="external">随机的</a>。因此，如果我们想让map保持元素的插入顺序，需要借助第三方的库才行，今天就给大家介绍一个这样的库<a href="https://rpcx.io/r/12DuBuGc8O5" target="_blank" rel="external">OrderedMap</a>。</p>
<p>其实在其他编程语言中，也有类似的数据结构，比如java中的 <a href="https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/LinkedHashMap.html" target="_blank" rel="external">LinkedHashMap</a>, python中的<code>OrderedDict</code>。</p>
<p>本文介绍如何使用Go语言实现这样的一种数据类型。注意我们要实现的是OrderedMap, 不是SortedMap或者TreeMap，SortedMap遍历的时候是按照Key的排序顺序遍历的，我们可以通过先获取所有的key并排序，再逐个访问对应的值。</p>
<p>但是OrderedMap遍历的时候要是保持插入的顺序，这怎么办到的呢？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让 sync.Map  支持泛型]]></title>
    <link href="https://colobu.com/2023/06/11/make-sync-Map-to-generic/"/>
    <id>https://colobu.com/2023/06/11/make-sync-Map-to-generic/</id>
    <published>2023-06-11T13:46:30.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>渐渐地， Go泛型越来越多应用的Go的标准库中了。一些标准库的类型，比如<code>container/heap</code>、<code>container/list</code>、<code>container/ring</code>、<code>math</code>都是有机会支持泛型的，但是考虑到Go向下兼容的情况，这些包可能不会直接修改，最可能就是新建一些并发的包，或者放在扩展包中。</p>
<p>本篇文章将讲一个相对复杂的例子，也就是对<code>sync.Map</code>的修改，让它支持泛型。</p>
<a id="more"></a>
<h2 id="找出变换量，将其改变为type_parameter">找出变换量，将其改变为type parameter</h2>
<p><code>sync.Map</code>是一种map，所以它遵循map的K-V的映射关系。键是一种可以比较的类型，以便进行是否相等的检查，值是任意类型。内建的map类型在变量定义的时候就执行了键和值的类型，也算是最初级的泛型，sync.Map的键和值是any类型的，但实际上键是comparable类型才可以。下面这个代码能编译，但是运行时会出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m sync.Map</div><div class="line"></div><div class="line">key := <span class="keyword">func</span>() {}</div><div class="line">m.Store(key, <span class="string">"value"</span>)</div></pre></td></tr></table></figure>

<p>键的类型和值的类型是变化量，可以更改成类型参数，所以我们先对这两个变化量下手，修改成类型参数。</p>
<p>标准库中主要使用两个map对象做read和dirty数据中的存储，所以我们使用类型参数创建这两个map对象。<br>entry也改成泛型的支持。</p>
<div class="tabs">  
  <div class="tab">
    <input class="tab-radio" type="radio" id="tab-1" name="tab-group-1" checked>
    <label class="tab-label" for="tab-1">支持泛型的sync.Map</label>    
    <div class="tab-panel">
      <div class="tab-content">        

<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Map[K comparable, V any] <span class="keyword">struct</span> { <span class="comment">// 定义K,V 类型参数</span></div><div class="line">	mu sync.Mutex</div><div class="line"></div><div class="line">	read atomic.Pointer[readOnly[K, V]] <span class="comment">// readonly 也支持泛型，因为它内部也是使用了一个map</span></div><div class="line"></div><div class="line">	dirty <span class="keyword">map</span>[K]*entry[V] <span class="comment">// map改造成泛型</span></div><div class="line"></div><div class="line">	misses <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> readOnly[K comparable, V any] <span class="keyword">struct</span> {</div><div class="line">	m       <span class="keyword">map</span>[K]*entry[V] <span class="comment">// 这个改成泛型</span></div><div class="line">	amended <span class="typename">bool</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> expunged = unsafe.Pointer(<span class="built_in">new</span>(any)) <span class="comment">// 一个特殊的标记为删除的值</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> entry[V any] <span class="keyword">struct</span> {</div><div class="line">	p atomic.Pointer[V] <span class="comment">// 泛型类型，atomic.Pointer支持泛型</span></div><div class="line">}</div></pre></td></tr></table></figure>

 </div>
  </div>
</div>
<div class="tab">
  <input class="tab-radio" type="radio" id="tab-2" name="tab-group-1" checked>
  <label class="tab-label" for="tab-2">标准库中的sync.Map</label>    
  <div class="tab-panel">
    <div class="tab-content">

<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> {</div><div class="line">	mu Mutex</div><div class="line"></div><div class="line">	read atomic.Pointer[readOnly]</div><div class="line">	dirty <span class="keyword">map</span>[any]*entry</div><div class="line"></div><div class="line">	misses <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> {</div><div class="line">	m       <span class="keyword">map</span>[any]*entry</div><div class="line">	amended <span class="typename">bool</span> </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> expunged = <span class="built_in">new</span>(any)</div><div class="line"></div><div class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> {</div><div class="line">	p atomic.Pointer[any]</div><div class="line">}</div></pre></td></tr></table></figure>

	  </div>
    </div>
  </div>       
</div>

<p>基本上我们通过少量的修改，把sync.Map的相关的类型都改成了支持泛型的类型的类型。</p>
<h2 id="改造方法支持泛型">改造方法支持泛型</h2>
<p>相关的类型改造成支持泛型后，编译就过不去了，因为相关的方法也需要修改。</p>
<p><img src="syncmap.jpg" alt=""></p>
<p>泛型函数比如<code>newEntry</code>编译器或者编辑器中报错说是entry是泛型的，我们根据这个提示改成泛型的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> newEntry[V any](i V) *entry[V] {</div><div class="line">	e := &entry[V]{}</div><div class="line">	e.p.Store(&i)</div><div class="line">	<span class="keyword">return</span> e</div><div class="line">}</div></pre></td></tr></table></figure>

<p>泛型方法中我们把Receiver的类型改成<code>Map[K, V]</code>,最好是把<code>(m *Map)</code>全部替换一遍。返回值<code>readonly</code>也改成泛型类型的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map[K, V]) loadReadOnly() readOnly[K, V] {</div><div class="line">	<span class="keyword">if</span> p := m.read.Load(); p != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> *p</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> readOnly[K, V]{}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来改造Load方法， 将其中的Key和Value类型从any类型改成K,V类型参数。<br>这里一个小机器就是源标准库中有可能返回nil值，改成返回V类型的零值，V类型的零值有三种方式创建出来，我们使用<code>var zero V</code>创建零值：</p>
<div class="tabs">  
  <div class="tab">
    <input class="tab-radio" type="radio" id="tab-3" name="tab-group-2" checked>
    <label class="tab-label" for="tab-3">支持泛型的sync.Map</label>    
    <div class="tab-panel">
      <div class="tab-content">

<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map[K, V]) Load(key K) (value V, ok <span class="typename">bool</span>) {</div><div class="line">	read := m.loadReadOnly()</div><div class="line">	e, ok := read.m[key]</div><div class="line">	<span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div><div class="line">		read = m.loadReadOnly()</div><div class="line">		e, ok = read.m[key]</div><div class="line">		<span class="keyword">if</span> !ok && read.amended {</div><div class="line">			e, ok = m.dirty[key]</div><div class="line">			<span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></div><div class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></div><div class="line">			<span class="comment">// map.</span></div><div class="line">			m.missLocked()</div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">var</span> zero V</div><div class="line">		<span class="keyword">return</span> zero, <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> e.load()</div><div class="line">}</div></pre></td></tr></table></figure>

     
 </div>
  </div>
</div>
<div class="tab">
  <input class="tab-radio" type="radio" id="tab-4" name="tab-group-2" checked>
  <label class="tab-label" for="tab-4">标准库中的sync.Map</label>    
  <div class="tab-panel">
    <div class="tab-content">

<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Load(key any) (value any, ok <span class="typename">bool</span>) {</div><div class="line">	read := m.loadReadOnly()</div><div class="line">	e, ok := read.m[key]</div><div class="line">	<span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div><div class="line">		<span class="comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span></div><div class="line">		<span class="comment">// blocked on m.mu. (If further loads of the same key will not miss, it's</span></div><div class="line">		<span class="comment">// not worth copying the dirty map for this key.)</span></div><div class="line">		read = m.loadReadOnly()</div><div class="line">		e, ok = read.m[key]</div><div class="line">		<span class="keyword">if</span> !ok && read.amended {</div><div class="line">			e, ok = m.dirty[key]</div><div class="line">			<span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></div><div class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></div><div class="line">			<span class="comment">// map.</span></div><div class="line">			m.missLocked()</div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> e.load()</div><div class="line">}</div></pre></td></tr></table></figure>

	  </div>
    </div>
  </div>       
</div>

<p>接下来我再介绍一个棘手的改造情况。<br><code>load</code>方法中会判断<code>p == expunged</code>, <code>expunged</code>是一个特殊的值，用来标记为被删除还没有被清理掉。但是这个时候p的类型是<code>*V</code>, p的类型是<code>unsafe.Pointer(new(interface{}))</code>,类型不一样，指向的值也不一样。</p>
<p>改如何改造呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *entry) load() (value any, ok <span class="typename">bool</span>) {</div><div class="line">	p := e.p.Load()</div><div class="line">	<span class="keyword">if</span> p == <span class="constant">nil</span> || p == expunged {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> *p, <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以使用<code>unsafe.Pointer(p) == expunged</code>转为相同的类型，首先类型相同，另外我，们还是使用<code>unsafe.Pointer(new(interface{}))</code>来标记被删除的键:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *entry[V]) load() (value V, ok <span class="typename">bool</span>) {</div><div class="line">	p := e.p.Load()</div><div class="line">	<span class="keyword">if</span> p == <span class="constant">nil</span> || unsafe.Pointer(p) == expunged {</div><div class="line">		<span class="keyword">var</span> zero V</div><div class="line">		<span class="keyword">return</span> zero, <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> *p, <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在<code>unexpungeLocked</code>方法中，我们强制把<code>expunged</code>转换成<code>*V</code>,尽管它底层指向的是一个<code>any</code>,反正部门也不会更改<code>expunged</code>的值，这种强制转换也没有啥风险。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *entry[V]) unexpungeLocked() (wasExpunged <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">return</span> e.p.CompareAndSwap((*V)(expunged), <span class="constant">nil</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>剩下的方法就用同样的方式进行改造，甚至可以通过批量替换的方式处理，最终我们把整个sync.Map改造成支持泛型了。</p>
<p>最终形成的代码如下：<br><a href="https://github.com/smallnest/gofer/blob/master/syncx/sync_map.go" target="_blank" rel="external">generic sync map</a></p>
<p>把官方的测试代码复制过来测试，没有问题。</p>
<h2 id="性能">性能</h2>
<p>最后大家比较关注的就是这一顿骚操作能不能带来性能的提升呢？功能的提升是显而易见的，我们输入的参数和返回值都是一个特定的类型，不需要做type assert了。</p>
<p>还是改造官方标准库对sync.Map的bench代码，我们增加一个这个泛型类型的支持，为了公平期间我们使用的key和value都是int类型。相关的代码可以看<a href="https://github.com/smallnest/gofer/blob/master/syncx/map_bench_test.go" target="_blank" rel="external">map_bench_test.go</a>。</p>
<p>测试结果如下,可以看到绝大部分场景下我们的泛型Map要比标准库中的sync.Map要快，只有在<code>BenchmarkMapCompareAndSwapNoExistingKey</code>和<code>BenchmarkMapCompareAndSwapValueNotEqual</code>两个场景下比sync.Map慢，并且慢很多，待我找找原因，如果有分析结果会在另一篇文章中介绍。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">BenchmarkMapLoadMostlyHits/*syncx.SyncMap[int,int]-<span class="number">8</span>         	<span class="number">319121388</span>	         <span class="number">3.725</span> ns/op</div><div class="line">BenchmarkMapLoadMostlyHits/*syncx.Map[int,int]-<span class="number">8</span>             	<span class="number">897178652</span>	         <span class="number">2.491</span> ns/op</div><div class="line">BenchmarkMapLoadMostlyMisses/*syncx.SyncMap[int,int]-<span class="number">8</span>       	<span class="number">478179013</span>	         <span class="number">2.426</span> ns/op</div><div class="line">BenchmarkMapLoadMostlyMisses/*syncx.Map[int,int]-<span class="number">8</span>           	<span class="number">866405142</span>	         <span class="number">2.315</span> ns/op</div><div class="line">BenchmarkMapLoadOrStoreBalanced/*syncx.SyncMap[int,int]-<span class="number">8</span>    	 <span class="number">5727007</span>	       <span class="number">223.4</span> ns/op</div><div class="line">BenchmarkMapLoadOrStoreBalanced/*syncx.Map[int,int]-<span class="number">8</span>        	 <span class="number">8712914</span>	       <span class="number">171.7</span> ns/op</div><div class="line">BenchmarkMapLoadOrStoreUnique/*syncx.SyncMap[int,int]-<span class="number">8</span>      	 <span class="number">2843049</span>	       <span class="number">405.7</span> ns/op</div><div class="line">BenchmarkMapLoadOrStoreUnique/*syncx.Map[int,int]-<span class="number">8</span>          	 <span class="number">4316347</span>	       <span class="number">321.8</span> ns/op</div><div class="line">BenchmarkMapLoadOrStoreCollision/*syncx.SyncMap[int,int]-<span class="number">8</span>   	<span class="number">312317070</span>	         <span class="number">3.799</span> ns/op</div><div class="line">BenchmarkMapLoadOrStoreCollision/*syncx.Map[int,int]-<span class="number">8</span>       	<span class="number">1000000000</span>	         <span class="number">1.800</span> ns/op</div><div class="line">BenchmarkMapLoadAndDeleteBalanced/*syncx.SyncMap[int,int]-<span class="number">8</span>  	<span class="number">242927908</span>	         <span class="number">4.978</span> ns/op</div><div class="line">BenchmarkMapLoadAndDeleteBalanced/*syncx.Map[int,int]-<span class="number">8</span>      	<span class="number">656539690</span>	         <span class="number">3.040</span> ns/op</div><div class="line">BenchmarkMapLoadAndDeleteUnique/*syncx.SyncMap[int,int]-<span class="number">8</span>    	<span class="number">599912763</span>	         <span class="number">1.958</span> ns/op</div><div class="line">BenchmarkMapLoadAndDeleteUnique/*syncx.Map[int,int]-<span class="number">8</span>        	<span class="number">1000000000</span>	         <span class="number">1.186</span> ns/op</div><div class="line">BenchmarkMapLoadAndDeleteCollision/*syncx.SyncMap[int,int]-<span class="number">8</span> 	<span class="number">361118110</span>	         <span class="number">3.283</span> ns/op</div><div class="line">BenchmarkMapLoadAndDeleteCollision/*syncx.Map[int,int]-<span class="number">8</span>     	<span class="number">669603936</span>	         <span class="number">2.184</span> ns/op</div><div class="line">BenchmarkMapRange/*syncx.SyncMap[int,int]-<span class="number">8</span>                  	  <span class="number">744468</span>	      <span class="number">1594</span> ns/op</div><div class="line">BenchmarkMapRange/*syncx.Map[int,int]-<span class="number">8</span>                      	  <span class="number">887029</span>	      <span class="number">1378</span> ns/op</div><div class="line">BenchmarkMapAdversarialAlloc/*syncx.SyncMap[int,int]-<span class="number">8</span>       	 <span class="number">8579004</span>	       <span class="number">139.1</span> ns/op</div><div class="line">BenchmarkMapAdversarialAlloc/*syncx.Map[int,int]-<span class="number">8</span>           	<span class="number">10151095</span>	       <span class="number">117.4</span> ns/op</div><div class="line">BenchmarkMapAdversarialDelete/*syncx.SyncMap[int,int]-<span class="number">8</span>      	<span class="number">28653038</span>	        <span class="number">42.42</span> ns/op</div><div class="line">BenchmarkMapAdversarialDelete/*syncx.Map[int,int]-<span class="number">8</span>          	<span class="number">37976685</span>	        <span class="number">31.75</span> ns/op</div><div class="line">BenchmarkMapDeleteCollision/*syncx.SyncMap[int,int]-<span class="number">8</span>        	<span class="number">688516219</span>	         <span class="number">1.797</span> ns/op</div><div class="line">BenchmarkMapDeleteCollision/*syncx.Map[int,int]-<span class="number">8</span>            	<span class="number">1000000000</span>	         <span class="number">1.288</span> ns/op</div><div class="line">BenchmarkMapSwapCollision/*syncx.SyncMap[int,int]-<span class="number">8</span>          	 <span class="number">8715524</span>	       <span class="number">137.1</span> ns/op</div><div class="line">BenchmarkMapSwapCollision/*syncx.Map[int,int]-<span class="number">8</span>              	<span class="number">10524654</span>	       <span class="number">114.5</span> ns/op</div><div class="line">BenchmarkMapSwapMostlyHits/*syncx.SyncMap[int,int]-<span class="number">8</span>         	<span class="number">61979068</span>	        <span class="number">20.24</span> ns/op</div><div class="line">BenchmarkMapSwapMostlyHits/*syncx.Map[int,int]-<span class="number">8</span>             	<span class="number">100000000</span>	        <span class="number">14.85</span> ns/op</div><div class="line">BenchmarkMapSwapMostlyMisses/*syncx.SyncMap[int,int]-<span class="number">8</span>       	 <span class="number">2543487</span>	       <span class="number">471.1</span> ns/op</div><div class="line">BenchmarkMapSwapMostlyMisses/*syncx.Map[int,int]-<span class="number">8</span>           	 <span class="number">3203072</span>	       <span class="number">374.4</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapCollision/*syncx.SyncMap[int,int]-<span class="number">8</span>         	<span class="number">74106286</span>	        <span class="number">17.56</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapCollision/*syncx.Map[int,int]-<span class="number">8</span>             	 <span class="number">2704873</span>	       <span class="number">448.8</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapNoExistingKey/*syncx.SyncMap[int,int]-<span class="number">8</span>     	<span class="number">560624862</span>	         <span class="number">2.116</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapNoExistingKey/*syncx.Map[int,int]-<span class="number">8</span>         	<span class="number">1000000000</span>	         <span class="number">1.417</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapValueNotEqual/*syncx.SyncMap[int,int]-<span class="number">8</span>     	<span class="number">264941869</span>	         <span class="number">4.297</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapValueNotEqual/*syncx.Map[int,int]-<span class="number">8</span>         	 <span class="number">5341881</span>	       <span class="number">225.9</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapMostlyHits/*syncx.SyncMap[int,int]-<span class="number">8</span>        	<span class="number">74957446</span>	        <span class="number">15.56</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapMostlyHits/*syncx.Map[int,int]-<span class="number">8</span>            	<span class="number">188375540</span>	         <span class="number">8.393</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapMostlyMisses/*syncx.SyncMap[int,int]-<span class="number">8</span>      	<span class="number">215614034</span>	         <span class="number">5.475</span> ns/op</div><div class="line">BenchmarkMapCompareAndSwapMostlyMisses/*syncx.Map[int,int]-<span class="number">8</span>          	<span class="number">514081917</span>	         <span class="number">2.111</span> ns/op</div><div class="line">BenchmarkMapCompareAndDeleteCollision/*syncx.SyncMap[int,int]-<span class="number">8</span>       	<span class="number">100000000</span>	        <span class="number">11.49</span> ns/op</div><div class="line">BenchmarkMapCompareAndDeleteCollision/*syncx.Map[int,int]-<span class="number">8</span>           	<span class="number">221624979</span>	        <span class="number">10.07</span> ns/op</div><div class="line">BenchmarkMapCompareAndDeleteMostlyHits/*syncx.SyncMap[int,int]-<span class="number">8</span>      	<span class="number">55139349</span>	        <span class="number">21.67</span> ns/op</div><div class="line">BenchmarkMapCompareAndDeleteMostlyHits/*syncx.Map[int,int]-<span class="number">8</span>          	<span class="number">129426009</span>	        <span class="number">12.53</span> ns/op</div><div class="line">BenchmarkMapCompareAndDeleteMostlyMisses/*syncx.SyncMap[int,int]-<span class="number">8</span>    	<span class="number">500900576</span>	         <span class="number">2.476</span> ns/op</div><div class="line">BenchmarkMapCompareAndDeleteMostlyMisses/*syncx.Map[int,int]-<span class="number">8</span>        	<span class="number">486840268</span>	         <span class="number">2.307</span> ns/op</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>渐渐地， Go泛型越来越多应用的Go的标准库中了。一些标准库的类型，比如<code>container/heap</code>、<code>container/list</code>、<code>container/ring</code>、<code>math</code>都是有机会支持泛型的，但是考虑到Go向下兼容的情况，这些包可能不会直接修改，最可能就是新建一些并发的包，或者放在扩展包中。</p>
<p>本篇文章将讲一个相对复杂的例子，也就是对<code>sync.Map</code>的修改，让它支持泛型。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sync.Once的新扩展]]></title>
    <link href="https://colobu.com/2023/05/29/extends-sync-Once/"/>
    <id>https://colobu.com/2023/05/29/extends-sync-Once/</id>
    <published>2023-05-29T14:06:47.000Z</published>
    <updated>2023-09-24T07:01:49.815Z</updated>
    <content type="html"><![CDATA[<p>在Go 1.21中， 增加了和sync.Once有关的三个函数。sync.Once本身实现就非常简单了，新增加的这三个函数到底是干啥的？让我们一起来看看。</p>
<a id="more"></a>
<h2 id="sync-Once">sync.Once</h2>
<p>我们常常使用sync.Once实现单例模式，它也非常的高效。</p>
<p>下面的代码是官方的一个例子，运行它可以看到<code>onceBody</code>函数只会被执行一次:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> once sync.Once</div><div class="line">	onceBody := <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"Only once"</span>)</div><div class="line">	}</div><div class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			once.Do(onceBody)</div><div class="line">			done &lt;- <span class="constant">true</span></div><div class="line">		}()</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		&lt;-done</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="OnceFunc">OnceFunc</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceFunc(f <span class="keyword">func</span>()) <span class="keyword">func</span>()</div></pre></td></tr></table></figure>

<p><code>OnceFunc</code>返回一个可以并发调用的函数，它可以被调用多次。即使返回的函数被调用多次，<code>f</code>也只会被调用一次。</p>
<p>下面的代码<code>onceBody</code>只被执行了一次：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	onceBody := <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"Only once"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	foo := sync.OnceFunc(onceBody)</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		foo()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="OnceValue">OnceValue</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceValue[T any](f <span class="keyword">func</span>() T) <span class="keyword">func</span>() T</div></pre></td></tr></table></figure>

<p><code>OnceValue</code>返回一个函数， 这个函数会返回f的返回值。多次调用都会返回同一个值。</p>
<p>下面的代码中,<code>randvalue</code>只会被执行一次，返回结果记做<code>n</code>的话， 并且每次调用bar函数都会返回<code>n</code>。bar可以并发的被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">randvalue := <span class="keyword">func</span>() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> rand.Int()</div><div class="line">}</div><div class="line">bar := sync.OnceValue(randvalue)</div><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">	fmt.Println(bar())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同时，可以看到在标准库中，泛型越来越被使用。</p>
<h2 id="OnceValues">OnceValues</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> OnceValues[T1, T2 any](f <span class="keyword">func</span>() (T1, T2)) <span class="keyword">func</span>() (T1, T2)</div></pre></td></tr></table></figure>

<p><code>OnceValues</code>和<code>OnceValue</code>的功能类似，只不过返回两个参数，仅此而已。</p>
<p>综述一下：</p>
<ul>
<li>这三个函数返回的函数被调用的时候，分别返回0个、1个、2个返回值。</li>
<li>返回的函数可以被并发的调用。 </li>
<li>如果f被执行的时候panic, 返回的函数被调用的时候也会panic,panic的值和f的panic一样。</li>
</ul>
<p>稍微展开讲一下tuple。</p>
<p>如果想返回更多的返回值，自己模仿构造一个，或者把多个返回值封装到一个对象中。</p>
<p>很多年前，我记得看一篇文章介绍某种编程语言的tuple是硬编码的， 两个元素的tuple、三个元素的tuple、四个元素的tuple等，忘记是哪个语言了。<br>所以你也可以模仿它。</p>
<p><a href="https://github.com/barweiss/go-tuple" target="_blank" rel="external">go-tuple</a>就是这样实现的一个go语言的tuple,最多支持9个元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T9</div><div class="line"><span class="keyword">func</span> FromArray9(arr <span class="number">[9</span>]any) (T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9], error)</div><div class="line"><span class="keyword">func</span> FromArray9X(arr <span class="number">[9</span>]any) T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]</div><div class="line"><span class="keyword">func</span> FromSlice9(values []any) (T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9], error)</div><div class="line"><span class="keyword">func</span> FromSlice9X(values []any) T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]</div><div class="line"><span class="keyword">func</span> New9(v1 Ty1, v2 Ty2, v3 Ty3, v4 Ty4, v5 Ty5, v6 Ty6, v7 Ty7, v8 Ty8, v9 Ty9) T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]</div><div class="line"><span class="keyword">func</span> (t T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]) Array() <span class="number">[9</span>]any</div><div class="line"><span class="keyword">func</span> (t T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]) GoString() <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> (t T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]) Len() <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> (t T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]) Slice() []any</div><div class="line"><span class="keyword">func</span> (t T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]) String() <span class="typename">string</span></div><div class="line"><span class="keyword">func</span> (t T9[Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9]) Values() (Ty1, Ty2, Ty3, Ty4, Ty5, Ty6, Ty7, Ty8, Ty9)</div></pre></td></tr></table></figure>

<p>顺便说一下，上面我介绍的Go 1.21新增的三个内建函数之一的<code>clear</code>,清除map的时候，只是把map置空，并不会shrink map， 你可以看例子： <a href="https://go.dev/play/p/quVwNvAZAGJ?v=gotip" target="_blank" rel="external">https://go.dev/play/p/quVwNvAZAGJ?v=gotip</a> 或者相关讨论 <a href="https://github.com/golang/go/issues/56351" target="_blank" rel="external">https://github.com/golang/go/issues/56351</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Go 1.21中， 增加了和sync.Once有关的三个函数。sync.Once本身实现就非常简单了，新增加的这三个函数到底是干啥的？让我们一起来看看。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
