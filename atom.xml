<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2022-06-05T11:19:21.360Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用BPF, 将Go网络程序的吞吐提升8倍]]></title>
    <link href="https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/"/>
    <id>https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/</id>
    <published>2022-06-05T09:05:09.000Z</published>
    <updated>2022-06-05T11:18:34.897Z</updated>
    <content type="html"><![CDATA[<p>经典的bpf(classical Berkeley Packet Filter) 是非常好用的一个技术，在一些特殊的Go底层网络编程的场合，可以很好的提高性能。<br><a id="more"></a></p>
<h2 id="背景">背景</h2>
<p>先前我开发过一个Go UDP应用程序， 客户端和服务端通过UDP程序，通过raw socket进行通讯。程序的目的比较特殊，这里我以一个简单的程序为例介绍。</p>
<p>事实上，我说我使用rawsocket方式并不严谨，我并不是采用下面的方式实现socket并进行通讯的(链路层的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fd, err:= syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW,syscall.ETH_P_ALL)</div><div class="line"><span class="keyword">if</span> (err != <span class="constant">nil</span>) {</div><div class="line">    fmt.Println(<span class="string">"Error: "</span> + err.Error())</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line">fmt.Println(<span class="string">"Obtained fd "</span>, fd)</div><div class="line"><span class="keyword">defer</span> syscall.Close(fd)</div></pre></td></tr></table></figure>

<p>也不是采用下面的rawsocket方式(IP层的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    fd, e := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_UDP)</div><div class="line">    <span class="keyword">if</span> e != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(<span class="string">"Problem @ location 1"</span>)</div><div class="line">    }</div><div class="line">    addr := syscall.SockaddrInet4{</div><div class="line">        Port:<span class="number"> 27289</span>,</div><div class="line">        Addr: <span class="number">[4</span>]<span class="typename">byte</span><span class="number">{127</span>,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 1</span>},</div><div class="line">    }</div><div class="line">    p := pkt()</div><div class="line">    err = syscall.Sendto(fd, p,<span class="number"> 0</span>, &addr)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(<span class="string">"Sendto:"</span>, err)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而是直接采用Go标准库中封装好的方法<code>net.ListenPacket(&quot;ip4:udp&quot;, addr)</code>在IP层进行包的发送和接收。</p>
<p>我通过封装自定义的UDP层的数据结构，实现自定义的包的发送和接收，进行网络的监控。</p>
<p>也许有人说使用标准库的UDPConn不就行了。如果是普通的UDP程序，的确没问题，如果对于一些特殊的需求，比如监听1000个UDP端口，有上万个节点定时的发送监控的数据，我们不太可能建立1000*1万个UDPConn,所以这里我采用rawsocket通讯的方式。</p>
<p>RawSocket是是标准Berkeley socket的一部分，我们使用Go的标准库开发网络程序时，大部分场景都是使用封装好的数据报类型(UDPConn)或者流类型(TCPConn),但是如果想做更底层的一些网络编程的话，就需要使用到RawSocket了，比如更底层的TCP、UDP网络控制、ICMP、ARP等协议。不同的操作系统可能实现的RawSocket也不同，这里我们以Linux环境为例。</p>
<p>Linux man手册对RawSocket相关知识做了详细的介绍:<a href="https://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="external">socket(2)</a>、<a href="https://man7.org/linux/man-pages/man7/packet.7.html" target="_blank" rel="external">packet(7) </a>、<a href="https://man7.org/linux/man-pages/man7/raw.7.html" target="_blank" rel="external">raw(7)</a>,本文不再做转述，这也不是本文的重点。</p>
<p>依照Linux文档，Linux 服务器中收到的包既=会传给内核网络模块，也会传给RawSocket。所以你使用RawSocket的时候有时候需要注意，比如你在处理TCP的包时，可能Linux内核的网络程序已经把这个包处理了。</p>
<blockquote>
<p>Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or TCP which have a protocol module in the kernel.  In this case, the packets are passed to both the kernel module and the raw socket(s).  This should not be relied upon in portable programs, many other BSD socket implementation have limitations here.</p>
</blockquote>
<p>如果没有特殊的需求，我们直接就使用<a href="https://pkg.go.dev/net#ListenPacket" target="_blank" rel="external">net.ListenPacket</a>是实现一个RawSocket的程序。这个方法的签名如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ListenPacket(network, address <span class="typename">string</span>) (PacketConn, error)</div></pre></td></tr></table></figure>

<p>其中第一个参数<code>network</code>可以是<code>udp</code>、<code>udp4</code>、<code>udp6</code>、<code>unixgram</code>，也是可以<code>ip</code>、<code>ip4</code>、<code>ip6</code>加冒号再加一个协议号或者协议名，比如<code>ip:1</code>、<code>ip:icmp</code>，就可以你也处理什么协议。</p>
<h2 id="演示程序">演示程序</h2>
<h3 id="服务端程序">服务端程序</h3>
<p>服务端程序我们使用<code>conn, err := net.ListenPacket(&quot;ip4:udp&quot;, *addr)</code>监听本地地址上所有的UDP包，并启动一个goroutine去处理。处理程序中应该还有一个判断，就是检查UDP的端口是不是我们处理的端口，因为这里<code>net.ListenPacket</code>监听的是本地所有的UDP,可能有很多无用的UDP包都传入到用户态的程序中了。</p>
<p>这里我们使用gopacket对各种协议层的包的定义，方便解析(或创建)TCP/IP各层的网络协议。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">	<span class="string">"golang.org/x/net/bpf"</span></div><div class="line">	<span class="string">"golang.org/x/net/ipv4"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"s"</span>, <span class="string">"localhost"</span>, <span class="string">"server address"</span>)</div><div class="line">	port = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	stat         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">	lastStatTime = <span class="typename">int64</span><span class="number">(0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	cc := conn.(*net.IPConn)</div><div class="line">	cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">	cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	handleConn(conn)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.PacketConn) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">		n, remoteaddr, err := conn.ReadFrom(buffer)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		buffer = buffer[:n]</div><div class="line"></div><div class="line">		packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">		<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">		<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line">			udp, _ := udpLayer.(*layers.UDP)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">				data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>), <span class="typename">uint16</span>(udp.DstPort), <span class="typename">uint16</span>(udp.SrcPort), app.Payload())</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteaddr); err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">					conn.Close()</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="客户端程序">客户端程序</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, <span class="string">"127.0.0.1"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>),<span class="number"> 8972</span>,<span class="number"> 0</span>, []<span class="typename">byte</span>(<span class="string">"hello"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	remoteAddr := &net.IPAddr{IP: net.ParseIP(<span class="string">"127.0.0.1"</span>)}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteAddr); err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">		conn.Close()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	n, _, err := conn.ReadFrom(buffer)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	buffer = buffer[:n]</div><div class="line"></div><div class="line">	packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">	<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">	<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">			fmt.Printf(<span class="string">"reply: %s\n"</span>, app.Payload())</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端程序这里做了简化，写入一个<code>hello</code>,并读取服务端的返回。我们在做性能测试的时候，会使用循环不断的写入一个seq号，并检查服务端是否返回这个seq，以便计算丢包性能。并且还使用一个限流器进行限流，测试在一定的RPS情况下的丢包率。</p>
<h3 id="辅助方法">辅助方法</h3>
<p>下面是<code>EncodeUDPPacket</code>方法，用来产生一个UDP的包数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> codec</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> EncodeUDPPacket(localIP, remoteIP net.IP, localPort, remotePort <span class="typename">uint16</span>, payload []<span class="typename">byte</span>) ([]<span class="typename">byte</span>, error) {</div><div class="line">	ip := &layers.IPv4{</div><div class="line">		Version: <span class="number"> 4</span>,</div><div class="line">		TTL:     <span class="number"> 128</span>,</div><div class="line">		SrcIP:    localIP,</div><div class="line">		DstIP:    remoteIP,</div><div class="line">		Protocol: layers.IPProtocolUDP,</div><div class="line">	}</div><div class="line">	udp := &layers.UDP{</div><div class="line">		SrcPort: layers.UDPPort(localPort),</div><div class="line">		DstPort: layers.UDPPort(remotePort),</div><div class="line">	}</div><div class="line">	udp.SetNetworkLayerForChecksum(ip)</div><div class="line"></div><div class="line">	buf := gopacket.NewSerializeBuffer()</div><div class="line">	opts := gopacket.SerializeOptions{</div><div class="line">		ComputeChecksums: <span class="constant">true</span>,</div><div class="line">		FixLengths:       <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	err := gopacket.SerializeLayers(buf, opts, udp, gopacket.Payload(payload))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> buf.Bytes(), err</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="性能问题">性能问题</h2>
<p>虽然上面的程序运行的很好，但是在并发量比较大的情况，会有一些问题。</p>
<p>上面我们启动了一个goroutine去读取这个包，这里是一个性能瓶颈，最终服务端只能使用一个核去处理RawSocket的包。</p>
<p>即使创建多个goroutine去读取这个PacketConn,也是没有用的，因为这个PacketConn是唯一的，它是一个瓶颈，多个goroutine有时候还不如一个goroutine去读取更好。</p>
<p>那么能不能调用多次<code>net.ListenPacket(&quot;ip4:udp&quot;, *addr)</code>,生成多个RawSocket并发的去处理呢？</p>
<p>貌似看起来可以，但是实际上，这多个RawSocket都会读取到相同的UDPPacket，而不是负载均衡平摊到多个Socket上。所以多个RawSocket不但没用，反而更加耗费服务器的资源了。</p>
<p>实际测试也就能达到2~3万的吞吐，并发量再高就出现丢包的情况了。</p>
<p>但是没有办法了么？</p>
<p>也不是。这里我们可以看到，主要性能瓶颈是我们上面的程序没有办法做到负载均衡，利用多核的能力并发的去处理。第二个性能瓶颈就是程序监听了本机所有的UDP的packet,交给用户态程序筛选去处理，这里面有很多我们不需要的包。</p>
<p>这两个性能问题我们都可以通过BPF进行处理。</p>
<h2 id="BPF进行包过滤">BPF进行包过滤</h2>
<p>经典的BPF早在1994就出现了，虽然大家现在都在谈论扩展的BPF(eBPF),但是经典的BPF依然可以发挥它的威力。</p>
<p>你可能没有在编程中应用过BPF,但是我相信你在实际工作中一定和它发生过什么。</p>
<p>比如你使用tcpdump在监听网络的传输情况时，经常会加上过滤手段，比如下面的命令是只监听tcp协议的8080端口:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -nn -vvvv -i any <span class="string">"tcp port 8080"</span></div></pre></td></tr></table></figure>

<p>tcpdump其实就是把<code>tcp port 8080</code>生成过滤器，在内核中对包进行过滤，只把过滤后的包打筛选出来。</p>
<p>其实你可以通过下面的命令查看编译的过滤的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@lab ~]<span class="comment"># tcpdump -d "tcp port 8080"</span></div><div class="line">(<span class="number">000</span>) ldh      [<span class="number">12</span>]</div><div class="line">(<span class="number">001</span>) jeq      <span class="comment">#0x86dd          jt 2	jf 8</span></div><div class="line">(<span class="number">002</span>) ldb      [<span class="number">20</span>]</div><div class="line">(<span class="number">003</span>) jeq      <span class="comment">#0x6             jt 4	jf 19</span></div><div class="line">(<span class="number">004</span>) ldh      [<span class="number">54</span>]</div><div class="line">(<span class="number">005</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 6</span></div><div class="line">(<span class="number">006</span>) ldh      [<span class="number">56</span>]</div><div class="line">(<span class="number">007</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 19</span></div><div class="line">(<span class="number">008</span>) jeq      <span class="comment">#0x800           jt 9	jf 19</span></div><div class="line">(<span class="number">009</span>) ldb      [<span class="number">23</span>]</div><div class="line">(<span class="number">010</span>) jeq      <span class="comment">#0x6             jt 11	jf 19</span></div><div class="line">(<span class="number">011</span>) ldh      [<span class="number">20</span>]</div><div class="line">(<span class="number">012</span>) jset     <span class="comment">#0x1fff          jt 19	jf 13</span></div><div class="line">(<span class="number">013</span>) ldxb     <span class="number">4</span>*([<span class="number">14</span>]&<span class="number">0</span>xf)</div><div class="line">(<span class="number">014</span>) ldh      [x + <span class="number">14</span>]</div><div class="line">(<span class="number">015</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 16</span></div><div class="line">(<span class="number">016</span>) ldh      [x + <span class="number">16</span>]</div><div class="line">(<span class="number">017</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 19</span></div><div class="line">(<span class="number">018</span>) ret      <span class="comment">#262144</span></div><div class="line">(<span class="number">019</span>) ret      <span class="comment">#0</span></div></pre></td></tr></table></figure>

<p>这代表什么意思的？BPF定义了有限一些指令，可以在VM中，对包进行过滤.<br>第一行是加载包的偏移量(offset 12个字节)，第二行是检查是否是IPV6，如果是跳到<code>002</code>,如果不是跳到<code>008</code>。我们关注一下IPV4。<br><code>008</code>那一行是判断是否是ipv4，如果是跳到<code>009</code>。<code>009</code>加载偏移量23处的一个字节，它是ip proto,<code>010</code>行判断ip proto是否是TCP,如果是跳到<code>011</code>。<br>接下来判断flags，以便确定数据的地址。<br><code>014</code>行和<code>016</code>行是读取TCP协议中的源端口和目的端口，如果等于<code>8080</code>(<code>0x1f90</code>),则最大返回包大小262144个字节，否则就丢弃这个包。</p>
<p>当然tcpdump的生成的代码相当的严谨了我我们实际写的时候，如果确定是ipv4的包，包也没什么扩展的话，写出的代码要比这个简单。但是我们实际在应用BPF的时候不妨采用tcpdump生成的代码，不会出错。</p>
<p>使用<code>-dd</code>可以显示成c代码片段，使用<code>-ddd</code>显示为十进制数。我们看一下<code>-dd</code>的效果，因为这个结果我们可以用来转换成Go的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@lab ~]# tcpdump -dd <span class="string">"tcp port 8080"</span></div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000c },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 6</span>,<span class="number"> 0</span>x000086dd },</div><div class="line">{<span class="number"> 0</span>x30,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000014 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 15</span>,<span class="number"> 0</span>x00000006 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000036 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 12</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000038 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 10</span>,<span class="number"> 11</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 10</span>,<span class="number"> 0</span>x00000800 },</div><div class="line">{<span class="number"> 0</span>x30,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000017 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 8</span>,<span class="number"> 0</span>x00000006 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000014 },</div><div class="line">{<span class="number"> 0</span>x45,<span class="number"> 6</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001fff },</div><div class="line">{<span class="number"> 0</span>xb1,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000e },</div><div class="line">{<span class="number"> 0</span>x48,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000e },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 2</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x48,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000010 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 1</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x6,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00040000 },</div><div class="line">{<span class="number"> 0</span>x6,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000000 },</div></pre></td></tr></table></figure>

<p>实际上，<a href="https://pkg.go.dev/golang.org/x/net/bpf" target="_blank" rel="external">x/net/bpf</a>提供了相应的方法，可以更容易的编写BPF程序，序列化和反序列化。比如编写一个过滤出目的端口等于8972的所有的包，我们可以简单写成如下的格式(考虑到简单形式，我们只考虑了IPV4和普通IP包的形式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">//加载目的端口到寄存器</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val:<span class="number"> 8972</span>, SkipFalse:<span class="number"> 1</span>}, <span class="comment">// 如果值等于8972的话,执行下一行，否则跳过下一行</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},   <span class="comment">// 返回这个包的最多0xffff的字节的数据</span></div><div class="line"></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">// 返回零个字节，也就是忽略这个包</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以写一个程序，把tcpdump生成的代码转换成bpf的RawInstruction指令:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> parse(data <span class="typename">string</span>) (raws []bpf.RawInstruction) {</div><div class="line">	lines := strings.Split(data, <span class="string">"\n"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, line := <span class="keyword">range</span> lines {</div><div class="line">		line = strings.TrimSpace(line)</div><div class="line">		<span class="keyword">if</span> line == <span class="string">""</span> {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		line = strings.TrimPrefix(line, <span class="string">"{"</span>)</div><div class="line">		line = strings.TrimSuffix(line, <span class="string">" },"</span>)</div><div class="line">		items := strings.Split(line, <span class="string">","</span>)</div><div class="line">		<span class="comment">// assert len(items) == 4</span></div><div class="line"></div><div class="line">		raw := bpf.RawInstruction{</div><div class="line">			Op: <span class="typename">uint16</span>(numToInteger(items<span class="number">[0</span>])),</div><div class="line">			Jt: <span class="typename">uint8</span>(numToInteger(items<span class="number">[1</span>])),</div><div class="line">			Jf: <span class="typename">uint8</span>(numToInteger(items<span class="number">[2</span>])),</div><div class="line">			K:  <span class="typename">uint32</span>(numToInteger(items<span class="number">[3</span>])),</div><div class="line">		}</div><div class="line"></div><div class="line">		raws = <span class="built_in">append</span>(raws, raw)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> raws</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> numToInteger(s <span class="typename">string</span>) <span class="typename">int</span> {</div><div class="line">	s = strings.TrimSpace(s)</div><div class="line">	<span class="keyword">if</span> strings.HasPrefix(s, <span class="string">"0x"</span>) {</div><div class="line">		s := strings.Replace(s, <span class="string">"0x"</span>, <span class="string">""</span>,<span class="number"> -1</span>)</div><div class="line">		result, _ := strconv.ParseInt(s,<span class="number"> 16</span>,<span class="number"> 64</span>)</div><div class="line">		<span class="keyword">return</span> <span class="typename">int</span>(result)</div><div class="line">	}</div><div class="line"></div><div class="line">	result, _ := strconv.ParseInt(s,<span class="number"> 10</span>,<span class="number"> 64</span>)</div><div class="line">	<span class="keyword">return</span> <span class="typename">int</span>(result)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>好了所有这一切都准备好了，背景知识介绍了，当前的RawSocket程序的性能瓶颈也介绍了，那么如果解决性能瓶颈呢。</p>
<p>第一个性能瓶颈我们可以生成多个goroutine，每个goroutine负责过滤一部分的包，这样就实现了负载均衡。比如根据客户端的IP进行过滤，或者服务端监听1000个端口，每个goroutine只负责一部分的端口。而可以根据客户端的源端口进行过滤等等。总是，通过BPF过滤，一个goroutine只负责一部分的packet，实现了多核的处理。</p>
<p>第二个瓶颈随着第一个问题也迎刃而解。因为BPF只过滤我们的特定的端口，其它端口的UDP包不会从内核态复制到用户态，减少了无用包的处理。</p>
<p>要为标准库的PacketConn设置BPF过滤，也有多种办法，比如调用<code>syscall.SetsockoptInt</code>进行设置。但是<a href="https://pkg.go.dev/golang.org/x/net/ipv4#PacketConn.SetBPF" target="_blank" rel="external">golang.org/x/net/ipv4</a>提供了SetBPF方法，我们可以直接将标准库的PacketConn转换成ipv4.PacketConn,再进行设置。</p>
<p>比如上面的server程序，我们可以修改为使用BPF在内核态过滤:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">	<span class="string">"golang.org/x/net/bpf"</span></div><div class="line">	<span class="string">"golang.org/x/net/ipv4"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"s"</span>, <span class="string">"localhost"</span>, <span class="string">"server address"</span>)</div><div class="line">	port = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	stat         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">	lastStatTime = <span class="typename">int64</span><span class="number">(0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	cc := conn.(*net.IPConn)</div><div class="line">	cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">	cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	pconn := ipv4.NewPacketConn(conn)</div><div class="line">	<span class="keyword">var</span> assembled []bpf.RawInstruction</div><div class="line">	<span class="keyword">if</span> assembled, err = bpf.Assemble(filter); err != <span class="constant">nil</span> {</div><div class="line">		log.Print(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	pconn.SetBPF(assembled)</div><div class="line"></div><div class="line">	handleConn(conn)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.PacketConn) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">		n, remoteaddr, err := conn.ReadFrom(buffer)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		buffer = buffer[:n]</div><div class="line"></div><div class="line">		packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">		<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">		<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line">			udp, _ := udpLayer.(*layers.UDP)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">				data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>), <span class="typename">uint16</span>(udp.DstPort), <span class="typename">uint16</span>(udp.SrcPort), app.Payload())</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteaddr); err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">					conn.Close()</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">// load the destination port</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val: <span class="typename">uint32</span>(*port), SkipFalse:<span class="number"> 1</span>}, <span class="comment">// if Val != 8972 skip next instruction</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},                                      <span class="comment">// return 0xffff bytes (or less) from packet</span></div><div class="line"></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">// return 0 bytes, effectively ignore this packet</span></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>经典的bpf(classical Berkeley Packet Filter) 是非常好用的一个技术，在一些特殊的Go底层网络编程的场合，可以很好的提高性能。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[想学习k8s但没有环境？使用minikube轻松搭建一个]]></title>
    <link href="https://colobu.com/2022/06/02/setup-a-k8s-cluster-with-minikube/"/>
    <id>https://colobu.com/2022/06/02/setup-a-k8s-cluster-with-minikube/</id>
    <published>2022-06-02T07:37:14.000Z</published>
    <updated>2022-06-03T09:35:15.901Z</updated>
    <content type="html"><![CDATA[<p><a href="https://kubernetes.io/" target="_blank" rel="external">Kubernetes</a>（常简称为K8s）是用于自动部署、扩展和管理“容器化（containerized）应用程序”的开源系统。该系统由Google设计并捐赠给Cloud Native Computing Foundation（今属Linux基金会）来使用。</p>
<p>它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。 它支持一系列容器工具，包括Docker等。</p>
<p>Kubernetes（在希腊语意为“舵手”或“驾驶员”）由Joe Beda、Brendan Burns和Craig McLuckie创立，并由其他谷歌工程师，包括Brian Grant和Tim Hockin等进行加盟创作，并由谷歌在2014年首次对外宣布 。 该系统的开发和设计都深受谷歌的Borg系统的影响，其许多顶级贡献者之前也是Borg系统的开发者。在谷歌内部，Kubernetes的原始代号曾经是Seven，即星际迷航中的Borg（博格人）。Kubernetes标识中舵轮有七个轮辐就是对该项目代号的致意。</p>
<p>Kuberbetes一直是IT行业炽手可热的技术，很多同学都想学习它，但是刚想上手遇到了一个麻烦，需要搭建一个k8s的集群。虽然云服务提供商比如阿里云、百度云都提供了k8s集群的服务，但是还需要花一笔钱去购买服务和节点。如何在自己的机器上搭建一个k8s集群学习呢？本文给你介绍一种使用minikube搭建一个k8s测试集群的方法。</p>
<a id="more"></a>
<h2 id="安装">安装</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="external">minikube</a> 主要基于运行一个单节点 Kubernetes 集群，以便支持在本地机器上的 VM 内进行开发。它支持虚拟机驱动程序，如 VirtualBox、HyperV、KVM2。由于 Minikube 是 Kubernetes 体系中相对成熟的解决方案，支持的功能列表非常令人印象深刻。这些功能是负载均衡器、多集群、节点端口、持久卷、入口、仪表板或容器运行时。</p>
<p>基于 Minikube 开源工具，使得开发、运维人员及 DevOps 工程师能够快速在本地搭建 Kubernetes 单节点集群环境，毕竟，Minikube 对软硬件资源没有太高的要求，方便技术人员学习与实践，以及进行日常的项目开发。</p>
<p>运行minikube,你至少需要:</p>
<ul>
<li>2 CPU或者更多</li>
<li>2GB 内存</li>
<li>20GB 磁盘空间</li>
<li>互联网</li>
<li>容器或者虚机管理器如: Docker, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware Fusion/Workstation</li>
</ul>
<p>我使用的MacBook Pro M1的苹果本，并且机器上已经安装Docker,所以这些需求都满足。如果你是Linux或者Windows，也可以安装，只不过你需要下载相应的安装程序。<br>本文以我的环境为例进行介绍。</p>
<p>对于MacOS,你可以有两种方式进行安装。<br>一种是手工安装方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64</div><div class="line">sudo <span class="operator"><span class="keyword">install</span> minikube-darwin-amd64 /usr/<span class="keyword">local</span>/<span class="keyword">bin</span>/minikube</span></div></pre></td></tr></table></figure>

<p>如果你因为一些原因没有办法下载这个文件，也可以到github网站上下载<a href="https://github.com/kubernetes/minikube/releases/tag/v1.25.2" target="_blank" rel="external">二进制文件</a>，放到/usr/local/bin/minikube中。</p>
<p>第二种方式就是使用brew命令安装:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">brew <span class="operator"><span class="keyword">install</span> minikube</span></div><div class="line"></div><div class="line">// 查看minikube安装在哪里</div><div class="line">➜  ~ which minikube</div><div class="line">/usr/<span class="keyword">local</span>/<span class="keyword">bin</span>/minikube</div></pre></td></tr></table></figure>

<h2 id="启动">启动</h2>
<p>接下来就是启动minikube。</p>
<p>执行下面的命令就可以启动:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minikube start</div></pre></td></tr></table></figure>

<p>第一次启动需要下载k8s依赖的各种镜像，可能因为墙的原因，一些镜像会拉不下来安装失败。</p>
<p>我采用的方法是从阿里云拉取镜像，再重新打tag到对应的k8s依赖的镜像，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">docker pull <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy</span>:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:<span class="filename">v1.22.3 k8s.gcr.io/kube-proxy</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:<span class="filename">v1.8.4</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:<span class="filename">v1.8.4 k8s.gcr.io/coredns/coredns</span>:<span class="filename">v1.8.4</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:<span class="filename">v1.22.3 k8s.gcr.io/kube-scheduler</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner:v5</div><div class="line">docker tag <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner</span>:v5 <span class="filename">gcr.io/k8s-minikube/storage-provisioner</span>:v5</div><div class="line"></div><div class="line">docker pull <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver</span>:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:<span class="filename">v1.22.3 k8s.gcr.io/kube-apiserver</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:<span class="number">3.5</span><span class="number">.0</span>-<span class="number">0</span></div><div class="line">docker tag <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd</span>:<span class="number">3.5</span><span class="number">.0</span>-<span class="number">0</span>  <span class="filename">k8s.gcr.io/etcd</span>:<span class="number">3.5</span><span class="number">.0</span>-<span class="number">0</span></div><div class="line"></div><div class="line">docker pull <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager</span>:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:<span class="filename">v1.22.3 k8s.gcr.io/kube-controller-manager</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:<span class="number">3.5</span></div><div class="line">docker tag <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/pause</span>:<span class="number">3.5</span>  <span class="filename">k8s.gcr.io/pause</span>:<span class="number">3.5</span></div></pre></td></tr></table></figure>

<p>手工把这些镜像拉到本地后，再执行<code>minikube start</code>就顺利启动成功了。</p>
<p>我还在网上看到另外一种启动方式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minikube <span class="operator"><span class="keyword">start</span> <span class="comment">--image-mirror-country='cn'</span></span></div></pre></td></tr></table></figure>

<p>我觉得这是一种更简捷的方式，不过我已经安装好了，所以这种方式我没有试过，你可以试试。</p>
<p>minikube命令提供了非常多的配置参数，比如：</p>
<p>--driver=<strong><em> 从1.5.0版本开始，Minikube缺省使用系统优选的驱动来创建Kubernetes本地环境，比如您已经安装过Docker环境，minikube 将使用 docker 驱动<br>--cpus=2: 为minikube虚拟机分配CPU核数<br>--memory=4096mb: 为minikube虚拟机分配内存数<br>--registry-mirror=</em></strong> 为 Docker daemon 配置镜像加速，比如<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="external">阿里云镜像服务</a><br>--kubernetes-version=***: minikube 虚拟机将使用的 kubernetes 版本</p>
<p>现在，你就可以打开Kubernetes控制台了: <code>minikube dashboard</code></p>
<p><img src="dashboard.png" alt=""></p>
<p>现在，一个本地测试用的k8s集群就搭建好了。</p>
<p>如果你暂时不用，可以调用<code>minikube stop</code>暂停，等需要的时候再启动。</p>
<h2 id="插件">插件</h2>
<p>你现在可以直接使用<code>kubectl</code>命令快速创建、更新和删除Kubernetes 对象。你可以自由自在的在自己的集群中学习、测试k8s的技术了。</p>
<p>minikube也提供了很多插件,比如istio、ingress、helm-tiller等等。随着你对k8s的掌握程度，可以逐步的安装测试这些扩展的功能。<br>插件列表如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">➜  ~ minikube addons list</div><div class="line"><span class="string">|-----------------------------|----------|--------------|-----------------------|</span></div><div class="line"><span class="string">|         ADDON NAME          | PROFILE  |    STATUS    |      MAINTAINER       |</span></div><div class="line"><span class="string">|-----------------------------|----------|--------------|-----------------------|</span></div><div class="line"><span class="string">| ambassador                  | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| auto-pause                  | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| csi-hostpath-driver         | minikube | disabled     | kubernetes            |</span></div><div class="line"><span class="string">| dashboard                   | minikube | enabled ✅   | kubernetes            |</span></div><div class="line"><span class="string">| default-storageclass        | minikube | enabled ✅   | kubernetes            |</span></div><div class="line"><span class="string">| efk                         | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| freshpod                    | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| gcp-auth                    | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| gvisor                      | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| helm-tiller                 | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| ingress                     | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| ingress-dns                 | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| istio                       | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| istio-provisioner           | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| kubevirt                    | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| logviewer                   | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| metallb                     | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| metrics-server              | minikube | disabled     | kubernetes            |</span></div><div class="line"><span class="string">| nvidia-driver-installer     | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| nvidia-gpu-device-plugin    | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| olm                         | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| pod-security-policy         | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| portainer                   | minikube | disabled     | portainer.io          |</span></div><div class="line"><span class="string">| registry                    | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| registry-aliases            | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| registry-creds              | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| storage-provisioner         | minikube | enabled ✅   | kubernetes            |</span></div><div class="line"><span class="string">| storage-provisioner-gluster | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| volumesnapshots             | minikube | disabled     | kubernetes            |</span></div><div class="line"><span class="string">|-----------------------------|----------|--------------|-----------------------|</span></div></pre></td></tr></table></figure>

<p>启用某个插件可以用下面的命令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ minikube addons enable ingress</div><div class="line">💡  After the addon <span class="keyword">is</span> enabled, please run <span class="string">"minikube tunnel"</span> <span class="keyword">and</span> your ingress resources would be available at <span class="string">"127.0.0.1"</span></div><div class="line">    ▪ <span class="keyword">Using</span> image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1<span class="number">.1</span><span class="number">.1</span></div><div class="line">    ▪ <span class="keyword">Using</span> image k8s.gcr.io/ingress-nginx/controller:v1<span class="number">.0</span><span class="number">.4</span></div><div class="line">    ▪ <span class="keyword">Using</span> image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1<span class="number">.1</span><span class="number">.1</span></div><div class="line">🔎  Verifying ingress addon...</div></pre></td></tr></table></figure>

<h2 id="k8s集群初步">k8s集群初步</h2>
<p>既然我们搭建好了一个k8s集群,我们不妨使用它部署一下应用和服务。</p>
<p>我们以rpcx微服务框架的一个hello world程序为例。</p>
<h3 id="部署一个rpcx服务端的应用">部署一个rpcx服务端的应用</h3>
<p>rpcx服务端的程序很简单:</p>
<figure class="highlight go"><figcaption><span>server.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/server"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">"addr"</span>, <span class="string">":8972"</span>, <span class="string">"server address"</span>)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// the second parameter is not a pointer</span></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(ctx context.Context, args example.Args, reply *example.Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	fmt.Println(<span class="string">"C="</span>, reply.C)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line">	<span class="comment">// s.Register(new(Arith), "")</span></div><div class="line">	s.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith), <span class="string">""</span>)</div><div class="line">	err := s.Serve(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>写一个Docker文件，编译并生成镜像:</p>
<figure class="highlight Dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">FROM golan<span class="variable">g:1</span>.<span class="number">18</span>-alpine <span class="keyword">as</span> builder</div><div class="line">WORKDIR /usr/src/app</div><div class="line">ENV GOPROXY=http<span class="variable">s:</span>//goproxy.<span class="keyword">cn</span></div><div class="line">RUN sed -<span class="keyword">i</span> <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories && \</div><div class="line">  apk <span class="built_in">add</span> --<span class="keyword">no</span>-cache <span class="keyword">ca</span>-certificates tzdata</div><div class="line">COPY ./<span class="keyword">go</span>.<span class="keyword">mod</span> ./</div><div class="line">COPY ./<span class="keyword">go</span>.sum ./</div><div class="line">RUN <span class="keyword">go</span> <span class="keyword">mod</span> download</div><div class="line">COPY . .</div><div class="line">RUN CGO_ENABLED=<span class="number">0</span> <span class="keyword">go</span> build -ldflags <span class="string">"-s -w"</span> -<span class="keyword">o</span> rpcx_server </div><div class="line"></div><div class="line">FROM scratch <span class="keyword">as</span> runner</div><div class="line">COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/<span class="built_in">localtime</span></div><div class="line">COPY --from=builder /etc/ssl/certs/<span class="keyword">ca</span>-certificates.crt /etc/ssl/certs/</div><div class="line">COPY --from=builder /usr/src/app/rpcx_server /<span class="keyword">opt</span>/app/</div><div class="line"></div><div class="line">EXPOSE <span class="number">8972</span></div><div class="line"></div><div class="line">CMD [<span class="string">"/opt/app/rpcx_server"</span>]</div></pre></td></tr></table></figure>

<p>生成镜像（我还把它推到了docker平台）:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker build . -t smallnest/rpcx-server-demo:<span class="number">0.1</span>.<span class="number">0</span></div><div class="line">docker push smallnest/rpcx-server-demo:<span class="number">0.1</span>.<span class="number">0</span></div></pre></td></tr></table></figure>

<p>接下来就是写部署文件了,使用我们的镜像，副本数为3:</p>
<figure class="highlight yaml"><figcaption><span>rpcx-server-demo.yaml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">apiVersion: apps/v1</div><div class="line">kind: <span class="type">Deployment</span></div><div class="line">metadata:</div><div class="line">  name: rpcx-server-demo-deployment</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: rpcx-server-demo</div><div class="line">  replicas: <span class="number">3</span></div><div class="line">  <span class="keyword">template</span>:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: rpcx-server-demo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: rpcx-server-demo</div><div class="line">        image: smallnest/rpcx-server-demo:<span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></div><div class="line">        ports:</div><div class="line">        - containerPort: <span class="number">8972</span></div></pre></td></tr></table></figure>

<p>接下了再定义服务,把我们的这个微服务暴露成k8s的一个服务:</p>
<figure class="highlight yaml"><figcaption><span>rpcx-server-demo-service.yaml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: rpcx-<span class="keyword">server</span>-demo-service	<span class="preprocessor">#Service 的名称</span></div><div class="line">  labels:     	<span class="preprocessor">#Service 自己的标签</span></div><div class="line">    app: rpcx-<span class="keyword">server</span>-demo	<span class="preprocessor">#为该 Service 设置 key 为 app，value 为 rpcx-server-demo 的标签</span></div><div class="line">spec:	    <span class="preprocessor">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span></div><div class="line">  selector:	    <span class="preprocessor">#标签选择器</span></div><div class="line">    app: rpcx-<span class="keyword">server</span>-demo	<span class="preprocessor">#选择包含标签 app:rpcx-server-demo 的 Pod</span></div><div class="line">  ports:</div><div class="line">  - name: rpcx-<span class="keyword">server</span>-demo-port	<span class="preprocessor">#端口的名字</span></div><div class="line">    protocol: TCP	    <span class="preprocessor">#协议类型 TCP/UDP</span></div><div class="line">    port: <span class="number">9981</span>	        <span class="preprocessor">#集群内的其他容器组可通过 9981 端口访问 Service</span></div><div class="line">    targetPort: <span class="number">8972</span>	<span class="preprocessor">#将请求转发到匹配 Pod 的 8972 端口</span></div></pre></td></tr></table></figure>

<p>最后执行下面的命令发布应用和服务:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl apply <span class="operator">-f</span> rpcx-server-demo.yaml</div><div class="line">kubectl apply <span class="operator">-f</span> rpcx-server-demo-service.yaml</div></pre></td></tr></table></figure>

<p>可以查看发布的应用和服务:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl get pods</div><div class="line">NAME                                           READY   STATUS    RESTARTS       AGE</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">42</span>wbm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">499</span>gm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc<span class="operator">-s</span>6gh9   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">25</span>h ago)    <span class="number">103</span>d</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl get svc</div><div class="line">NAME                       TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE</div><div class="line">kubernetes                 ClusterIP   <span class="number">10.96</span>.<span class="number">0.1</span>     &lt;none&gt;        <span class="number">443</span>/TCP    <span class="number">114</span>d</div><div class="line">rpcx-server-demo-service   ClusterIP   <span class="number">10.98</span>.<span class="number">134.3</span>   &lt;none&gt;        <span class="number">9981</span>/TCP   <span class="number">103</span>d</div></pre></td></tr></table></figure>

<h3 id="部署rpcx客户端的应用">部署rpcx客户端的应用</h3>
<p>类似的，我们也部署rpcx客户端的程序，它会调用我们刚才部署rpcx服务。</p>
<figure class="highlight go"><figcaption><span>client.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/protocol"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/client"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	port := os.Getenv(<span class="string">"RPCX_SERVER_DEMO_SERVICE_PORT"</span>)</div><div class="line">	addr := strings.TrimPrefix(port, <span class="string">"tcp://"</span>)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"dial "</span>, addr)</div><div class="line"></div><div class="line">	d, _ := client.NewPeer2PeerDiscovery(<span class="string">"tcp@"</span>+addr, <span class="string">""</span>)</div><div class="line">	opt := client.DefaultOption</div><div class="line">	opt.SerializeType = protocol.JSON</div><div class="line"></div><div class="line">	xclient := client.NewXClient(<span class="string">"Arith"</span>, client.Failtry, client.RandomSelect, d, opt)</div><div class="line">	<span class="keyword">defer</span> xclient.Close()</div><div class="line"></div><div class="line">	args := example.Args{</div><div class="line">		A:<span class="number"> 10</span>,</div><div class="line">		B:<span class="number"> 20</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		reply := &example.Reply{}</div><div class="line">		err := xclient.Call(context.Background(), <span class="string">"Mul"</span>, args, reply)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatalf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">		}</div><div class="line"></div><div class="line">		log.Printf(<span class="string">"%d * %d = %d"</span>, args.A, args.B, reply.C)</div><div class="line"></div><div class="line">		time.Sleep(time.Second)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编写一个Dockerfile文件，以便生成镜像:</p>
<figure class="highlight Dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FROM golan<span class="variable">g:1</span>.<span class="number">18</span>-alpine <span class="keyword">as</span> builder</div><div class="line">WORKDIR /usr/src/app</div><div class="line">ENV GOPROXY=http<span class="variable">s:</span>//goproxy.<span class="keyword">cn</span></div><div class="line">RUN sed -<span class="keyword">i</span> <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories && \</div><div class="line">  apk <span class="built_in">add</span> --<span class="keyword">no</span>-cache <span class="keyword">ca</span>-certificates tzdata</div><div class="line">COPY ./<span class="keyword">go</span>.<span class="keyword">mod</span> ./</div><div class="line">COPY ./<span class="keyword">go</span>.sum ./</div><div class="line">RUN <span class="keyword">go</span> <span class="keyword">mod</span> download</div><div class="line">COPY . .</div><div class="line">RUN CGO_ENABLED=<span class="number">0</span> <span class="keyword">go</span> build -ldflags <span class="string">"-s -w"</span> -<span class="keyword">o</span> rpcx_client </div><div class="line"></div><div class="line">FROM busybox <span class="keyword">as</span> runner</div><div class="line">COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/<span class="built_in">localtime</span></div><div class="line">COPY --from=builder /etc/ssl/certs/<span class="keyword">ca</span>-certificates.crt /etc/ssl/certs/</div><div class="line">COPY --from=builder /usr/src/app/rpcx_client /<span class="keyword">opt</span>/app/</div><div class="line"></div><div class="line">CMD [<span class="string">"/opt/app/rpcx_client"</span>]</div></pre></td></tr></table></figure>

<p>编译生成镜像：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker build . -t smallnest/rpcx-<span class="keyword">client</span>-demo:<span class="number">0.1</span><span class="number">.0</span></div><div class="line">docker push smallnest/rpcx-<span class="keyword">client</span>-demo:<span class="number">0.1</span><span class="number">.0</span></div></pre></td></tr></table></figure>

<p>编写yaml文件:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apiVersion: apps/v1</div><div class="line">kind: <span class="type">Deployment</span></div><div class="line">metadata:</div><div class="line">  name: rpcx-client-demo-deployment</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: rpcx-client-demo</div><div class="line">  replicas: <span class="number">1</span></div><div class="line">  <span class="keyword">template</span>:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: rpcx-client-demo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: rpcx-client-demo</div><div class="line">        image: smallnest/rpcx-client-demo:<span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></div></pre></td></tr></table></figure>

<p>最后发布:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl apply <span class="operator">-f</span> rpcx-client-demo.yaml</div></pre></td></tr></table></figure>

<p>检查client是否发布成功了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl get pods</div><div class="line">NAME                                           READY   STATUS    RESTARTS       AGE</div><div class="line">rpcx-client-demo-deployment-<span class="number">699</span>bfb8799-wdsww   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">25</span>h ago)    <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">42</span>wbm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">499</span>gm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc<span class="operator">-s</span>6gh9   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">25</span>h ago)    <span class="number">103</span>d</div></pre></td></tr></table></figure>

<p>因为我们的副本数是1,所以这里只有一个节点。</p>
<p>查看客户端的输出，可以看到它调用服务成功了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl logs rpcx-client-demo-deployment-<span class="number">699</span>bfb8799-wdsww |more</div><div class="line">dial  <span class="number">10.98</span>.<span class="number">134.3</span>:<span class="number">9981</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">17</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">18</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">19</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">20</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">21</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">22</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">23</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">24</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://kubernetes.io/" target="_blank" rel="external">Kubernetes</a>（常简称为K8s）是用于自动部署、扩展和管理“容器化（containerized）应用程序”的开源系统。该系统由Google设计并捐赠给Cloud Native Computing Foundation（今属Linux基金会）来使用。</p>
<p>它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。 它支持一系列容器工具，包括Docker等。</p>
<p>Kubernetes（在希腊语意为“舵手”或“驾驶员”）由Joe Beda、Brendan Burns和Craig McLuckie创立，并由其他谷歌工程师，包括Brian Grant和Tim Hockin等进行加盟创作，并由谷歌在2014年首次对外宣布 。 该系统的开发和设计都深受谷歌的Borg系统的影响，其许多顶级贡献者之前也是Borg系统的开发者。在谷歌内部，Kubernetes的原始代号曾经是Seven，即星际迷航中的Borg（博格人）。Kubernetes标识中舵轮有七个轮辐就是对该项目代号的致意。</p>
<p>Kuberbetes一直是IT行业炽手可热的技术，很多同学都想学习它，但是刚想上手遇到了一个麻烦，需要搭建一个k8s的集群。虽然云服务提供商比如阿里云、百度云都提供了k8s集群的服务，但是还需要花一笔钱去购买服务和节点。如何在自己的机器上搭建一个k8s集群学习呢？本文给你介绍一种使用minikube搭建一个k8s测试集群的方法。</p>
]]>
    
    </summary>
    
      <category term="k8s" scheme="https://colobu.com/categories/k8s/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ebpf跟踪rpcx微服务]]></title>
    <link href="https://colobu.com/2022/05/22/use-ebpf-to-trace-rpcx-microservices/"/>
    <id>https://colobu.com/2022/05/22/use-ebpf-to-trace-rpcx-microservices/</id>
    <published>2022-05-22T08:34:29.000Z</published>
    <updated>2022-05-22T13:17:44.617Z</updated>
    <content type="html"><![CDATA[<p><a href="https://ebpf.io/zh-cn/" target="_blank" rel="external">ebpf</a>是一种创新的革命性技术，它能在内核中运行沙箱程序， 而无需修改内核源码或者加载内核模块。将 Linux 内核变成可编程之后，就能基于现有的（而非增加新的）抽象层来打造更加智能、 功能更加丰富的基础设施软件，而不会增加系统的复杂度，也不会牺牲执行效率和安全性。</p>
<p>BPF的第一个版本在1994年问世。我们在使用tcpdump工具编写规则的时候其实就使用到它了，该工具用于查看或”嗅探”网络数据包。</p>
<a id="more"></a>
<p><img src="ebpf.png" alt=""></p>
<p>使用ebpf技术，你可以从安全、跟踪&amp;性能分析、网络、观测&amp;监控等方向提供新的思路和技术：</p>
<ul>
<li>安全：可以从系统调用级、packet层、socket层进行安全检查，比如开发DDOS防护系统，编写防火墙程序。</li>
<li>网络：可以开发内核层高性能包处理程序，比如Cilium提供内核层的负载均衡，把service mesh往更深层推进，解决sidecar的性能问题。</li>
<li>跟踪&amp;性能分析: Linux提供多种类型的探针点(probe point),比如Kernel probes、perf events、Tracepoints、User-space probes、User statically defined tracepoints、XDP等等，我们可以编写probe程序收集这些探针点的信息，所以我们可以通过这种方式跟踪程序，分析性能。</li>
<li>观测&amp;监控: 对这些探针点的持续观测和监控，我们可以丰富我们的trace程序。关键是，我们不需要更改既有的程序，而是通过ebpf方法从其它程序进行观测。2014年，著名的内核黑客Alexei Starovoitov对BPF的功能进行了扩展。他增加了寄存器的数量和程序允许的大小，增加了JIT编译，并创建了一个用于检查程序是否安全的程序。然而，最令人印象深刻的是，新的BPF程序不仅能够在处理数据包时运行，而且能够响应其他内核事件，并在内核和用户空间之间来回传递信息。Alexei Starovoitov的新版本的BPF被称为eBPF（e代表扩展：extended）。但现在，它已经取代了所有旧版的BPF用法，并且已经变得非常流行，为了简单起见，它仍然被称为BPF。</li>
</ul>
<p><img src="functions.png" alt=""></p>
<p>你可以自己编写bpf程序，进行定制化的逻辑处理和分析，也可以使用大神们写好的工具，利用这些工具对程序进行通用的性能分析和跟踪。本文主要介绍使用一些工具对rpcx微服务程序进行通用的分析，既然是通用的，你可以可以对其它的Go程序进行分析，而且不仅限于Go程序，其它应用程序甚至内核你可以进行分析和跟踪。</p>
<p>自己编写bpf程序我准备再新开一篇文章介绍。</p>
<p>这一次主要介绍<a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc提供的相关工具</a>和<a href="https://github.com/iovisor/bpftrace" target="_blank" rel="external">bpftrace</a>。</p>
<p>bcc是用于创建基于eBPF的高效内核跟踪和操作程序的工具包，其中包括一些有用的命令行工具和示例。 BCC简化了用C进行内核检测的eBPF程序的编写，包括LLVM的包装器以及Python和Lua的前端。它还提供了用于直接集成到应用程序中的高级库。</p>
<p>bpftrace是Linux eBPF的高级跟踪语言。它的语言受awk和C以及DTrace和SystemTap等以前的跟踪程序的启发。 bpftrace使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p>
<h2 id="简单的_rpcx_微服务程序">简单的 rpcx 微服务程序</h2>
<p>既然要使用ebpf分析程序，首先我们要有一个程序。这里我选取了<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>一个最简单的例子，实现一个乘法的最小的微服务。</p>
<p>这个程序的代码可以在<a href="https://github.com/rpcxio/rpcx-examples/tree/master/102basic" target="_blank" rel="external">rpcx-examples-102basic</a>下载到。</p>
<p>服务端的程序如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/server"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"server address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// 使用ebpf跟踪这个服务调用</span></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(ctx context.Context, args example.Args, reply *example.Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	fmt.Println(<span class="string">"C="</span>, reply.C)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line">	s.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith), <span class="string">""</span>)</div><div class="line">	err := s.Serve(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>go build server.go</code>编译出<code>server</code>程序并运行(<code>./server</code>)。</p>
<p>客户端程序如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/protocol"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/client"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"server address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	d, _ := client.NewPeer2PeerDiscovery(<span class="string">"tcp@"</span>+*addr, <span class="string">""</span>)</div><div class="line">	opt := client.DefaultOption</div><div class="line">	opt.SerializeType = protocol.JSON</div><div class="line"></div><div class="line">	xclient := client.NewXClient(<span class="string">"Arith"</span>, client.Failtry, client.RandomSelect, d, opt)</div><div class="line">	<span class="keyword">defer</span> xclient.Close()</div><div class="line"></div><div class="line">	args := example.Args{</div><div class="line">		A:<span class="number"> 10</span>,</div><div class="line">		B:<span class="number"> 20</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		reply := &example.Reply{}</div><div class="line">		err := xclient.Call(context.Background(), <span class="string">"Mul"</span>, args, reply)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatalf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">		}</div><div class="line"></div><div class="line">		log.Printf(<span class="string">"%d * %d = %d"</span>, args.A, args.B, reply.C)</div><div class="line">		time.Sleep(time.Second)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端每一秒会调用<code>Arith.Mul</code>微服务一次，微服务的逻辑也很简单，就是执行乘法，并把结果返回给客户端。</p>
<h2 id="跟踪和分析微服务">跟踪和分析微服务</h2>
<p>作为演示，本文只跟踪服务端<code>Arith.Mul</code>调用情况。</p>
<p>bcc提供了很多的基于bpf的分析程序，如下图(大神Brendan Gregg整理的经典图)</p>
<p><img src="bcc_tracing_tools_early2019.png" alt=""><br><img src="bpftrace_tools_early2019.png" alt=""></p>
<p>这里我们会选取几个相关的工具演示如何使用这些工具分析运行中的程序。 注意是运行中的程序，我们并没有给程序添加额外的一些埋点。</p>
<h3 id="bcc套件">bcc套件</h3>
<p>首先你得安装bcc套件，而且你的Linux内核还要足够新，在一些大厂的机房内，还有一些内核版本的2.6.x服务器，这些老的内核服务器不能支持ebpf或者ebpf的新特性。</p>
<p>我是在我的阿里云的一台虚机上测试的，它的版本是:</p>
<ul>
<li>Linux lab 4.18.0-348.2.1.el8_5.x86_64</li>
<li>CentOS Stream release 8</li>
</ul>
<p>直接<code>yum install bcc-tools</code>就可以安装这些工具。 </p>
<p>如果你是其它的版本的操作系统，你可以参考bcc的安装文档进行安装: <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md" target="_blank" rel="external">bcc/INSTALL</a>。</p>
<p>在使用工具分析之前，你首先要知道你的微服务<code>Arith.Mul</code>在符号表中的名称，你可以使用objdump查询到:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># objdump -t server|grep Mul|grep main</span></div><div class="line"><span class="number">000000000075</span>a5e0 g     F .text	<span class="number">00000000000000</span>d0              main.(*Arith).Mul</div></pre></td></tr></table></figure>

<p>它的名称是<code>main.(*Arith).Mul</code>,下面我们会使用这个名称分析这个微服务。</p>
<p>确保刚才的服务器一直在运行中。</p>
<h4 id="funccount">funccount</h4>
<p>funccount 用来统计一段时间内某个函数的调用次数。</p>
<p>在server所在的目录下执行下面的命令(如果在不同的路径，你需要更改命令参数中程序的路径):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -d 10  './server:main.*.Mul'</span></div><div class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"b'./server:main.*.Mul'"</span><span class="keyword">...</span> Hit Ctrl-C to end.</div><div class="line"></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'main.(*Arith).Mul'</span>                       <span class="number">10</span></div><div class="line">Detaching...</div><div class="line">[root@lab server]<span class="comment">#</span></div></pre></td></tr></table></figure>

<p>这里我们设置观察时间是10秒，可以看到在这10秒内，这个函数被调用了10次。</p>
<p>它包含几个参数，比如你可以持续观察，每5秒输出一次结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -Ti 5  './server:main.*.Mul'</span></div><div class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"b'./server:main.*.Mul'"</span>... Hit Ctrl-C to end.</div><div class="line"></div><div class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">29</span></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'main.(*Arith).Mul'</span>                        <span class="number">5</span></div></pre></td></tr></table></figure>

<p>我们甚至可以用它进行Go GC相关函数的跟踪:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -d 10  './server:runtime.*.gc*'</span></div><div class="line">Tracing <span class="number">21</span> functions <span class="keyword">for</span> <span class="string">"b'./server:runtime.*.gc*'"</span>... Hit Ctrl-C to end.</div><div class="line"></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'runtime.(*gcControllerState).update'</span>        <span class="number">2</span></div><div class="line">b<span class="string">'runtime.mallocgc'</span>                       <span class="number">250</span></div></pre></td></tr></table></figure>

<p>抑或是跟踪Go运行时的调度:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -d 10  './server:runtime.schedule'</span></div><div class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"b'./server:runtime.schedule'"</span>... Hit Ctrl-C to end.</div><div class="line"></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'runtime.schedule'</span>                        <span class="number">20</span></div><div class="line">Detaching...</div></pre></td></tr></table></figure>

<h4 id="funclatency">funclatency</h4>
<p>funclatency统计函数的执行的耗时情况。<br>如果我们想分析<code>Arith.Mul</code>方法执行的情况，我们可以使用下面的命令，它会用直方图的形式展示这个函数调用的耗时分布:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@lab</span> server]<span class="comment"># funclatency -d 10  './server:main.*.Mul'</span></div><div class="line"><span class="constant">Tracing </span><span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"./server:main.*.Mul"</span>... <span class="constant">Hit Ctrl-C </span>to <span class="keyword">end</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="constant">Function </span>= b<span class="string">'main.(*Arith).Mul'</span> [<span class="number">359284</span>]</div><div class="line">     nsecs               <span class="symbol">:</span> count     distribution</div><div class="line">         <span class="number">0</span> -&gt; <span class="number">1</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">2</span> -&gt; <span class="number">3</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">4</span> -&gt; <span class="number">7</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">8</span> -&gt; <span class="number">15</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">16</span> -&gt; <span class="number">31</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">32</span> -&gt; <span class="number">63</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">64</span> -&gt; <span class="number">127</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">128</span> -&gt; <span class="number">255</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">256</span> -&gt; <span class="number">511</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">512</span> -&gt; <span class="number">1023</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">1024</span> -&gt; <span class="number">2047</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">2048</span> -&gt; <span class="number">4095</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">4096</span> -&gt; <span class="number">8191</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">8192</span> -&gt; <span class="number">16383</span>      <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">     <span class="number">16384</span> -&gt; <span class="number">32767</span>      <span class="symbol">:</span> <span class="number">7</span>        |****************************************|</div><div class="line">     <span class="number">32768</span> -&gt; <span class="number">65535</span>      <span class="symbol">:</span> <span class="number">3</span>        |*****************                       |</div><div class="line"></div><div class="line">avg = <span class="number">31978</span> nsecs, <span class="symbol">total:</span> <span class="number">319783</span> nsecs, <span class="symbol">count:</span> <span class="number">10</span></div></pre></td></tr></table></figure>

<p>我们统计了10秒的数据。可以看到期间这个函数被调用了10次。平均耗时31微秒。</p>
<p>如果我们想检查线上的程序有没有长尾的现象，使用这个工具很容易分析统计。</p>
<h4 id="funcslower">funcslower</h4>
<p>funcslower 这个工具可以跟踪内核和程序的执行慢的函数，比如使用下面的命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funcslower -u 10  './server:main.(*Arith).Mul'</span></div><div class="line">Tracing function calls slower than <span class="number">10</span> us... Ctrl+C to quit.</div><div class="line">COMM           PID    LAT(us)             RVAL FUNC</div><div class="line">server         <span class="number">359284</span>   <span class="number">44.75</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">server         <span class="number">359284</span>   <span class="number">30.97</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">server         <span class="number">359284</span>   <span class="number">33.38</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">server         <span class="number">359284</span>   <span class="number">31.28</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div></pre></td></tr></table></figure>

<p>你甚至可以打印出堆栈信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@lab server]funcslower -UK -u <span class="number">10</span>  <span class="string">'./server:main.(*Arith).Mul'</span></div><div class="line">Tracing function calls slower than <span class="number">10</span> us... Ctrl+C to quit.</div><div class="line">COMM           PID    LAT(us)             RVAL FUNC</div><div class="line">server         <span class="number">359284</span>   <span class="number">31.20</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">    b<span class="string">'runtime.call64.abi0'</span></div><div class="line">    b<span class="string">'runtime.reflectcall'</span></div><div class="line">    b<span class="string">'reflect.Value.call'</span></div><div class="line">    b<span class="string">'reflect.Value.Call'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*service).call'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*Server).handleRequest'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*Server).serveConn.func2'</span></div><div class="line">    b<span class="string">'runtime.goexit.abi0'</span></div><div class="line">server         <span class="number">359284</span>   <span class="number">32.23</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">    b<span class="string">'runtime.call64.abi0'</span></div><div class="line">    b<span class="string">'runtime.reflectcall'</span></div><div class="line">    b<span class="string">'reflect.Value.call'</span></div><div class="line">    b<span class="string">'reflect.Value.Call'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*service).call'</span></div></pre></td></tr></table></figure>

<h4 id="tcp_系列工具">tcp 系列工具</h4>
<p>bcc提供了一堆的对tcp的跟踪情况，我们可以针对不同的场景选择使用相应的工具。</p>
<ul>
<li>tools/tcpaccept: 跟踪TCP被动连接 (accept()). </li>
<li>tools/tcpconnect: 跟踪TCP主动的连接 (connect()).</li>
<li>tools/tcpconnlat: 跟踪TCP主动连接的延迟(connect()). </li>
<li>tools/tcpdrop: 跟踪内核的TCP包的丢包细节.</li>
<li>tools/tcplife: 跟踪TCP session(生命周期指标汇总).</li>
<li>tools/tcpretrans: 跟踪TCP重传.</li>
<li>tools/tcprtt: 跟踪TCP来回的耗时.</li>
<li>tools/tcpstates: 跟踪TCP session状态的改变.</li>
<li>tools/tcpsubnet: 按子网汇总和聚合TCP发送情况.</li>
<li>tools/tcpsynbl: 显示TCP SYN backlog的情况.</li>
<li>tools/tcptop: 按主机汇总TCP send/recv吞吐情况.</li>
<li>tools/tcptracer: 跟踪TCP 建立/关闭连接的情况 (connect(), accept(), close()).</li>
<li>tools/tcpcong: 跟踪TCP套接字拥塞控制状态持续时间.</li>
</ul>
<p>比如我们如果关注连接的建立情况，可以使用<code>tcptracer</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@lab lib]<span class="comment"># tcptracer</span></div><div class="line">Tracing TCP established connections. Ctrl-C to end.</div><div class="line">T  PID    COMM             IP SADDR            DADDR            SPORT  DPORT</div><div class="line">C  <span class="number">360005</span> client           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">43126</span>  <span class="number">8972</span></div><div class="line">X  <span class="number">360005</span> client           <span class="number">6</span>  [::<span class="number">1</span>]            [::<span class="number">1</span>]            <span class="number">43010</span>  <span class="number">8972</span></div><div class="line">A  <span class="number">359284</span> server           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">8972</span>   <span class="number">43126</span></div><div class="line">X  <span class="number">360005</span> client           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">43126</span>  <span class="number">8972</span></div><div class="line">X  <span class="number">359284</span> server           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">8972</span>   <span class="number">43126</span></div><div class="line">C  <span class="number">360009</span> client           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">43130</span>  <span class="number">8972</span></div><div class="line">X  <span class="number">360009</span> client           <span class="number">6</span>  [::<span class="number">1</span>]            [::<span class="number">1</span>]            <span class="number">43014</span>  <span class="number">8972</span></div><div class="line">A  <span class="number">359284</span> server           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">8972</span>   <span class="number">43130</span></div></pre></td></tr></table></figure>

<p>另外还有一堆的<code>xxxxsnoop</code>程序，可以对特定的系统调用进行跟踪。</p>
<h3 id="bpftrace">bpftrace</h3>
<p>有时候，我们想使用脚本实现一些定制化的跟踪，比如类似awk这样的工具，可以提供简单的脚本编写。</p>
<p>bpftrace就是这样的工具, 它使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p>
<p>bpftrace参考手册可以在<a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#20-override-override-return-value" target="_blank" rel="external">bpftrace reference_guide</a>找到。</p>
<p>以我们的<code>Arith.Mul</code>为例，我们可以使用下面的命令，在函数调用时加入探针，把输入的参数打印出来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@lab server]# bpftrace -e <span class="string">'uprobe:./server:main.*.Mul {printf("%s - %s: arg1: %d, arg2: %d\n", comm, func, arg0, arg1)}'</span></div><div class="line">Attaching<span class="number"> 1</span> probe...</div><div class="line">server - main.(*Arith).Mul: arg1:<span class="number"> 10</span>, arg2:<span class="number"> 20</span></div><div class="line">server - main.(*Arith).Mul: arg1:<span class="number"> 10</span>, arg2:<span class="number"> 20</span></div><div class="line">server - main.(*Arith).Mul: arg1:<span class="number"> 10</span>, arg2:<span class="number"> 20</span></div></pre></td></tr></table></figure>

<p>为什么arg0,arg1就能把参数打印出来呢？简单说，我们的微服务参数正好是两个int64的整数，正好对应arg0,arg1。</p>
<p>rpcx的服务返回值也是当做参数传入的，函数调用的时候还没有设置，所以你如果打印arg3并不是reply返回值。</p>
<p>这个时候我们需要移动探针，加一个偏移量，加多少的偏移量呢？通过反汇编我们看到加92时返回值已经赋值了，所以使用下面的命令就可以打印返回值了(这个时候第一个参数就被覆盖掉了):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@lab <span class="keyword">server</span>]<span class="preprocessor"># bpftrace -e 'uprobe:./server:main.*.Mul+92 {printf("%s - %s: reply: %d\n", comm, func, arg0)}'</span></div><div class="line">Attaching <span class="number">1</span> probe...</div><div class="line"><span class="keyword">server</span> - main.(*Arith).Mul: reply: <span class="number">200</span></div><div class="line"><span class="keyword">server</span> - main.(*Arith).Mul: reply: <span class="number">200</span></div><div class="line"><span class="keyword">server</span> - main.(*Arith).Mul: reply: <span class="number">200</span></div></pre></td></tr></table></figure>

<blockquote>
<p>Go自1.17开始已经改成了基于寄存器的调用惯例，所以这里使用了内建的arg0、arg1、..., 如果你使用更早的Go版本，这里你可以换成sarg0,sarg1,...试试(stack arguments)。</p>
</blockquote>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html" target="_blank" rel="external">https://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html</a></li>
<li><a href="https://golangexample.com/library-to-work-with-ebpf-programs-from-golang/" target="_blank" rel="external">https://golangexample.com/library-to-work-with-ebpf-programs-from-golang/</a></li>
<li><a href="https://tonybai.com/2020/12/25/bpf-and-go-modern-forms-of-introspection-in-linux/" target="_blank" rel="external">https://tonybai.com/2020/12/25/bpf-and-go-modern-forms-of-introspection-in-linux/</a></li>
<li><a href="https://networkop.co.uk/post/2021-03-ebpf-intro/" target="_blank" rel="external">https://networkop.co.uk/post/2021-03-ebpf-intro/</a></li>
<li><a href="https://medium.com/bumble-tech/bpf-and-go-modern-forms-of-introspection-in-linux-6b9802682223#db17" target="_blank" rel="external">https://medium.com/bumble-tech/bpf-and-go-modern-forms-of-introspection-in-linux-6b9802682223#db17</a></li>
<li><a href="https://blog.px.dev/ebpf-http-tracing/" target="_blank" rel="external">https://blog.px.dev/ebpf-http-tracing/</a></li>
<li><a href="https://www.ebpf.top/post/ebpf_and_go/" target="_blank" rel="external">https://www.ebpf.top/post/ebpf_and_go/</a></li>
<li><a href="https://www.ebpf.top/" target="_blank" rel="external">https://www.ebpf.top/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://ebpf.io/zh-cn/" target="_blank" rel="external">ebpf</a>是一种创新的革命性技术，它能在内核中运行沙箱程序， 而无需修改内核源码或者加载内核模块。将 Linux 内核变成可编程之后，就能基于现有的（而非增加新的）抽象层来打造更加智能、 功能更加丰富的基础设施软件，而不会增加系统的复杂度，也不会牺牲执行效率和安全性。</p>
<p>BPF的第一个版本在1994年问世。我们在使用tcpdump工具编写规则的时候其实就使用到它了，该工具用于查看或”嗅探”网络数据包。</p>
]]>
    
    </summary>
    
      <category term="go" scheme="https://colobu.com/tags/go/"/>
    
      <category term="ebpf" scheme="https://colobu.com/tags/ebpf/"/>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[atomic包的新变化]]></title>
    <link href="https://colobu.com/2022/05/06/changes-in-atomic-package/"/>
    <id>https://colobu.com/2022/05/06/changes-in-atomic-package/</id>
    <published>2022-05-06T00:59:12.000Z</published>
    <updated>2022-05-22T08:37:06.156Z</updated>
    <content type="html"><![CDATA[<p>Russ Cox在去年的系列<a href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/" target="_blank" rel="external">文章</a>中，提到对atomic包的改变，并且开了一个issue供大家<a href="https://github.com/golang/go/discussions/47141" target="_blank" rel="external">讨论</a>,现在他提交的改变已经merge到master分支，Go 1.19就会包含这些改变。</p>
<a id="more"></a>
<p>你也可以使用<a href="https://pkg.go.dev/golang.org/dl/gotip" target="_blank" rel="external">gotip</a>提前了解这些改变。</p>
<p>Russ Cox这次的提交只是对atomic补充了一些新的类型，这些类型是对基本类型(primitive type, 如bool、int32、int64、uint32、uint64、uintptr等)的一个包装，以便提供原子操作。</p>
<p>事实上，uber很早以前就提供类似的功能，也许你很早之前就使用过<a href="https://github.com/uber-go/atomic" target="_blank" rel="external">uber-go/atomic</a>这个库。</p>
<p>Russ Cox实现的方式也类似，毕竟，这个为基本类型实现包装器的套路还是比较固定的，但是实现上略微有些不同。</p>
<ul>
<li>Russ Cox在标准库中的实现<ul>
<li>嵌入<code>_ noCopy</code>,方便go vet等工具做data race检查</li>
<li>代码可以进行inline,提高性能</li>
</ul>
</li>
<li>Uber的实现<ul>
<li>嵌入<code>_ nocmp</code>,避免非原子比较</li>
<li>提供JSON Marshal/UnMarshal的功能，方便序列化</li>
<li>提供更多类型的包装器: <code>Duration</code>、<code>String</code>、<code>Time</code>、<code>Float64</code>、<code>Error</code></li>
</ul>
</li>
</ul>
<p>我们在这篇文章中主要介绍Russ Cox的实现，毕竟这是Go标准库中的改动，我多少要对这些改动有些印象，在我们将来的代码开发，或者看别人的代码时做到心中有数。</p>
<p>这次改动增加了bool、int32、int64、uint32、uint64、uintptr、Value、unsafe.Pointer类型的包装器：<code>Bool</code>、<code>Int32</code>、<code>Int64</code>、<code>Uint32</code>、<code>Uint64</code>、<code>Uintptr</code>、<code>Value</code>、<code>Pointer</code>。</p>
<p>所有这些类型都包含下面四个<strong>方法</strong>:</p>
<ul>
<li>CompareAndSwap(old, new *T) (swapped bool) : 执行CAS操作</li>
<li>Load() *T : 原子load对应的值</li>
<li>Store(val *T) : 将值val原子存储</li>
<li>Swap(new <em>T) (old </em>T)： 原子保存新值，并返回老的值</li>
</ul>
<p>针对不同的类型，可能还会有一些额外的方法，比如:</p>
<ul>
<li>Int32: <code>func (x *Int32) Add(delta int32) (new int32)</code></li>
<li>Int64: <code>func (x *Int64) Add(delta int64) (new int64)</code></li>
<li>Uint32: <code>func (x *Int64) Add(delta int64) (new int64)</code></li>
<li>Uint64: <code>func (x *Uint64) Add(delta uint64) (new uint64)</code></li>
<li>Uintptr: <code>func (x *Uintptr) Add(delta uintptr) (new uintptr)</code></li>
</ul>
<p>同样，针对<code>Uint32</code>、<code>Uint64</code>类型，只有Add方法，如果想减去一个正值c，就得利用Add加上一个负值（-c），可是delta的类型都是uxxx类型，怎么办呢？使用<code>^uint64(c-1)</code>或者<code>^uint32(c-1)</code>。</p>
<p>这些包装器和方法其实对应的是atomic的相应的函数，所以使用起来没什么难度:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i Int64</div><div class="line">i.Add<span class="number">(100</span>)</div><div class="line">i.Load()</div><div class="line">i.Store<span class="number">(200</span>)</div><div class="line">i.Swap<span class="number">(300</span>)</div><div class="line">I.CompareAndSwap<span class="number">(300</span><span class="number">,400</span>)</div></pre></td></tr></table></figure>

<p>你可以查看go doc了解更详细的信息: <a href="https://pkg.go.dev/sync/atomic@master" target="_blank" rel="external">sync/atomic</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Russ Cox在去年的系列<a href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/" target="_blank" rel="external">文章</a>中，提到对atomic包的改变，并且开了一个issue供大家<a href="https://github.com/golang/go/discussions/47141" target="_blank" rel="external">讨论</a>,现在他提交的改变已经merge到master分支，Go 1.19就会包含这些改变。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型的坏例子]]></title>
    <link href="https://colobu.com/2022/04/26/Crimes-with-Go-Generics/"/>
    <id>https://colobu.com/2022/04/26/Crimes-with-Go-Generics/</id>
    <published>2022-04-26T00:09:46.000Z</published>
    <updated>2022-05-22T08:37:06.156Z</updated>
    <content type="html"><![CDATA[<p>Go 1.18发布了第一版的Go泛型之后，大家开始对Go泛型进行了深入的研究，今天翻译的这一篇，是加拿大的Xe Iaso刚出炉的一篇有趣的<a href="https://christine.website/blog/gonads-2022-04-24" target="_blank" rel="external">文章</a>，对Go泛型的应用做了一些探索。</p>
<a id="more"></a>
<p>Go 1.18在语言中添加了泛型特性。允许您把你的类型作为参数，这样你可以创建复合类型（类型之外的类型）。这让你在使用Go的过程中可以有更多的表现力和清晰度。</p>
<p>然而，如果你正在寻找关于如何使用Go泛型的好主意，这篇文章不适合你。这里面满是坏主意。这篇文章全是不应该在生产环境中使用Go泛型的方法。不要将本文中的示例复制到生产中。通过阅读本文，您同意不将本文中的示例复制到生产中。</p>
<p>我已将本文的代码放在<a href="https://tulpa.dev/internal/gonads" target="_blank" rel="external">我的git服务器</a>上。我故意采取以下步骤以便代码难以在生产环境中使用：</p>
<ol>
<li>我在一个名为<code>internal</code>的gitea组织下创建了它。这将使您无法导入包，除非您是从我的gitea服务器上的repo使用它。该gitea服务器上的注册被禁用。有关内部包规则的更多信息，请参见<a href="https://go.dev/doc/go1.4#internalpackages" target="_blank" rel="external">此处</a>。</li>
<li>软件包文档包含一条神奇的注释，它会让staticcheck和其他linter 警告您正在使用的软件包已被弃用。</li>
</ol>
<h2 id="Queue[T]"><code>Queue[T]</code></h2>
<p>首先，让我们展示一下计算机科学中一个难题。让我们创建一个MPMS（multiple producer, multiple subscriber,多生产者、多消费者）队列,这是我们并发编程常见的一种数据结构。</p>
<p>首先，我们需要一个struct来包装一切。它看起来是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Queue[T any] <span class="keyword">struct</span> {</div><div class="line">  data <span class="keyword">chan</span> T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码创建了一个名为<code>Queue</code>的类型，它接受一个类型参数<code>T</code>。这个<code>T</code>可以是任何类型，但唯一要求是这个数据是一个Go类型。</p>
<p>您可以使用以下函数为<code>Queue[T]</code>实例创建一个小小的构造函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewQueue[T any](size <span class="typename">int</span>) Queue[T] {</div><div class="line">  <span class="keyword">return</span> Queue[T]{</div><div class="line">    data: <span class="built_in">make</span>(<span class="keyword">chan</span> T, size),</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，让我们在<code>Queue</code> struct上创建一些方法，当然也就是压入和弹出操作了。它们可能是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (q Queue[T]) Push(val T) {</div><div class="line">  q.data &lt;- val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (q Queue[T]) Pop() T {</div><div class="line">  <span class="keyword">return</span> &lt;-q.data</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这些方法将允许您将数据放在队列的末尾，然后从头部取出数据。你可以这样使用它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">q := NewQueue[<span class="typename">string</span>]<span class="number">(5</span>)</div><div class="line">q.Push(<span class="string">"hi there"</span>)</div><div class="line">str := q.Pop()</div><div class="line"><span class="keyword">if</span> str != <span class="string">"hi there"</span> {</div><div class="line">  <span class="built_in">panic</span>(<span class="string">"string is wrong"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前来说一切都好，但是有个小问题，当队列为空时，调用<code>Pop</code>时调用者会被阻塞在那里，我们可以使用<code>select - default</code>语句来实现非阻塞版本的<code>TrpPop</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> (q Queue[T]) TryPop() (T, <span class="typename">bool</span>) {</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> val := &lt;-q.data:</div><div class="line">    <span class="keyword">return</span> val, <span class="constant">true</span></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，不幸的事情发生了，上面的代码无法编译,出错信息如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cannot use <span class="constant">nil</span> as T value in <span class="keyword">return</span> statement</div></pre></td></tr></table></figure>

<p>在该代码中，<code>T</code>可以是任何值，包括可能不为nil的值。我们可以利用var语句来解决这个问题，它生成一个新变量，并将其初始化为该类型的零值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Zero[T any]() T {</div><div class="line">  <span class="keyword">var</span> zero T</div><div class="line">  <span class="keyword">return</span> zero</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以像下面一样使用这个返回零值的函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log.Printf(<span class="string">"%q"</span>, Zero[<span class="typename">string</span>]())</div><div class="line">log.Printf(<span class="string">"%v"</span>, Zero[<span class="typename">int</span>]())</div></pre></td></tr></table></figure>

<p>输出的结果可能如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2009</span><span class="regexp">/11/</span><span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> <span class="string">""</span></div><div class="line"><span class="number">2009</span><span class="regexp">/11/</span><span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div></pre></td></tr></table></figure>

<p>现在我们就可以改造<code>TryPop</code>的<code>default</code>分支了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (q Queue[T]) TryPop() (T, <span class="typename">bool</span>) {</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> val := &lt;-q.data:</div><div class="line">    <span class="keyword">return</span> val, <span class="constant">true</span></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">var</span> zero T</div><div class="line">    <span class="keyword">return</span> zero, <span class="constant">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后我们写一个单元测试来测试它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestQueue(t *testing.T) {</div><div class="line">  q := NewQueue[<span class="typename">int</span>]<span class="number">(5</span>)</div><div class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> <span class="built_in">make</span>([]<span class="keyword">struct</span>{},<span class="number"> 5</span>) {</div><div class="line">    q.Push(i)</div><div class="line">  }</div><div class="line">	</div><div class="line">  <span class="keyword">for</span> <span class="keyword">range</span> <span class="built_in">make</span>([]<span class="keyword">struct</span>{},<span class="number"> 5</span>) {</div><div class="line">    t.Log(q.Pop())</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Option[T]"><code>Option[T]</code></h2>
<p>使用Go时，人们会有很多原因使用指针值：</p>
<ul>
<li>指针值可能为零，因此可以表示该值可能不存在。</li>
<li>指针值只在内存中存储偏移量，因此传递该值会导致只复制指针，而不用复制传递的值。</li>
<li>传递给函数的指针值允许您在传递中改变值。否则Go将复制该值，您就可以随心所欲地对其进行更改，但所做的更改不会持续到函数调用之后。你可以认为这是“不可变的”，但它不像在Rust中函数传递那样严格。</li>
</ul>
<p><code>Optiion[T]</code>类型可以帮助我们对第一条约束创建一个容器：一个值可能不存在。我们可以这样定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Option[T any] <span class="keyword">struct</span> {</div><div class="line">  val *T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你需要为这个容器实现一组方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ErrOptionIsNone = errors.New(<span class="string">"gonads: Option[T] has no value"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o Option[T]) Take() (T, error) {</div><div class="line">  <span class="keyword">if</span> o.IsNone() {</div><div class="line">    <span class="keyword">var</span> zero T</div><div class="line">    <span class="keyword">return</span> zero, ErrOptionIsNone</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">return</span> *o.val, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Option[T]) Set(val T) {</div><div class="line">  o.val = &val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Option[T]) Clear() {</div><div class="line">  o.val = <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Some other functions that will be useful will be an IsSome function to tell if the Option contains a value. We can use this to also implement an IsNone function that will let you tell if that Option does not contain a value. They will look like this:</p>
<p>其他一些有用的函数包括<code>IsSome</code>函数，用于判断<code>Option</code>是否包含值。我们还可以为它实现一个<code>IsNone</code>函数，该函数将让您判断该<code>Option</code>是否不包含值。它们看起来是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (o Option[T]) IsSome() <span class="typename">bool</span> {</div><div class="line">  <span class="keyword">return</span> o.val != <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o Option[T]) IsNone() <span class="typename">bool</span> {</div><div class="line">  <span class="keyword">return</span> !o.IsSome()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当<code>Option</code>没有保存某个值时，我们可以说<code>Option</code>为空，我们可以使用<code>IsSome</code>来实现<code>IsNone</code>。</p>
<p>最后我们把这些都放在<code>Yank</code>函数中，它类似Rust语言中的<code>Option::unwrap()</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (o Option[T]) Yank() T {</div><div class="line">  <span class="keyword">if</span> o.IsNone() {</div><div class="line">    <span class="built_in">panic</span>(<span class="string">"gonads: Yank on None Option"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">return</span> *o.val</div><div class="line">}</div></pre></td></tr></table></figure>

<p>写个Go单元测试校验它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestOption(t *testing.T) {</div><div class="line">  o := NewOption[<span class="typename">string</span>]()</div><div class="line">  val, err := o.Take()</div><div class="line">  <span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">    t.Fatalf(<span class="string">"[unexpected] wanted no value out of Option[T], got: %v"</span>, val)</div><div class="line">  }</div><div class="line">    </div><div class="line">  o.Set(<span class="string">"hello friendos"</span>)</div><div class="line">  _, err = o.Take()</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    t.Fatalf(<span class="string">"[unexpected] wanted no value out of Option[T], got: %v"</span>, err)</div><div class="line">  }</div><div class="line">    </div><div class="line">  o.Clear()</div><div class="line">  <span class="keyword">if</span> o.IsSome() {</div><div class="line">    t.Fatal(<span class="string">"Option should have none, but has some"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>脱离本篇文章，我认为<code>Option[T]</code>, 但是它需要更进一步的工作和泛化（才能更好的应用在生产环境），这应当是Go核心团队去做的事情，而不是第三方自己去实现。</p>
</blockquote>
<h2 id="Thunk[T]"><code>Thunk[T]</code></h2>
<p>在计算机科学中，我们通常程序分成数值(value)和计算(computation)。通常我们会处理其中一个,或者另一个。但是有时候计算也可以被视为值，但这是非常罕见的。更为罕见的是，将部分完成的计算用作一个值。</p>
<p><code>thunk</code>是一种存储为值的部分计算。为了了解我所说的内容，让我们考虑一下这个JavaScript函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> add = (x, y) =&gt; x + y;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">2</span>)); <span class="comment">// 4</span></div></pre></td></tr></table></figure>

<p>上面的代码实现了一个<code>add</code>函数对象，需要两个参数，返回一个参数。很多场景下都会这么使用。但是如果我们只绑定一个参数，让另一个参数做变量，这会变得很困难。</p>
<p>我们可以这样实现<code>add</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> add = (x) =&gt; (y) =&gt; x + y;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)(<span class="number">2</span>)); <span class="comment">// 4</span></div></pre></td></tr></table></figure>

<p>它需要我们部分的实现<code>add</code>函数，比如<code>addTwo</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addTwo = add(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(addTwo(<span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>

<p>也可以用在不需要参数的函数中，这样实现了延迟计算:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> hypotenuse = (x, y) =&gt; <span class="built_in">Math</span>.sqrt(x * x + y * y);</div><div class="line"><span class="keyword">const</span> thunk = () =&gt; hypot(<span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>

<p>你可以传递<code>trunk</code>对象，而不必立即计算它，只有在需要的时候才去计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dominateWorld(thunk); <span class="comment">// thunk is passed as an unevaluated function</span></div></pre></td></tr></table></figure>

<p>现在我们使用Go来实现这个类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Thunk[T any] <span class="keyword">struct</span> {</div><div class="line">  doer <span class="keyword">func</span>() T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后使用<code>Force</code>函数强制<code>Trunk</code>进行计算:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (t Thunk[T]) Force() T {</div><div class="line">  <span class="keyword">return</span> t.doer()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是可行的，但是我们也可以比JavaScript示例更进一步。我们可以利用<code>Thunk[T]</code>容器来缓存<code>doer</code>函数的结果，这样多次调用它实际上只会返回一次相同的结果。</p>
<blockquote>
<p>请记住，这只适用于纯函数，或不修改外部世界的函数。这也不仅仅是全局变量，而是任何可以在任何地方修改任何状态的函数，包括网络和文件系统IO。(如果你不理解纯函数，可以搜索pure function了解更多)</p>
</blockquote>
<p>所以<code>Trunk[T]</code>可以实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Thunk[T any] <span class="keyword">struct</span> {</div><div class="line">  doer <span class="keyword">func</span>() T <span class="comment">// action being thunked</span></div><div class="line">  o    *Option[T] <span class="comment">// cache for complete thunk data</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Thunk[T]) Force() T {</div><div class="line">  <span class="keyword">if</span> t.o.IsSome() {</div><div class="line">    <span class="keyword">return</span> t.o.Yank()</div><div class="line">  }</div><div class="line">    </div><div class="line">  t.o.Set(t.doer())</div><div class="line">  <span class="keyword">return</span> t.o.Yank()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewThunk[T any](doer <span class="keyword">func</span>() T) *Thunk[T] {</div><div class="line">  <span class="keyword">return</span> &Thunk[T]{</div><div class="line">    doer: doer,</div><div class="line">    o:    NewOption[T](),</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在来一个复杂点的例子，我们用它实现斐波那契函数。斐波那契函数正规的例子如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Fib(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">  <span class="keyword">if</span> n &lt;=<span class="number"> 1</span> {</div><div class="line">    <span class="keyword">return</span> n</div><div class="line">  }</div><div class="line">    </div><div class="line">  <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们写一个单元测试看看它的时间花费:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestRecurFib(t *testing.T) {</div><div class="line">  t.Log(Fib<span class="number">(40</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行go test,结果如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go test -run RecurFib</div><div class="line"><span class="header">=== RUN   TestRecurFib</span></div><div class="line"><span class="code">    thunk_test.go:15: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestRecurFib (0.36s)</div></pre></td></tr></table></figure>

<p>然而，我们可以使用刚才实现的<code>Trunk[T]</code>实现它，不过更复杂了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestThunkFib(t *testing.T) {</div><div class="line">  cache := <span class="built_in">make</span>([]*Thunk[<span class="typename">int</span>],<span class="number"> 41</span>)</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> fib <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span></div><div class="line">  fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">if</span> cache[n].o.IsSome() {</div><div class="line">      <span class="keyword">return</span> *cache[n].o.val</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> cache {</div><div class="line">    i := i</div><div class="line">    cache[i] = NewThunk(<span class="keyword">func</span>() <span class="typename">int</span> { <span class="keyword">return</span> fib(i) })</div><div class="line">  }</div><div class="line">  cache<span class="number">[0</span>].o.Set<span class="number">(0</span>)</div><div class="line">  cache<span class="number">[1</span>].o.Set<span class="number">(1</span>)</div><div class="line">  </div><div class="line">  t.Log(cache<span class="number">[40</span>].Force())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>执行go test,.输出结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="header">=== RUN   TestThunkFib</span></div><div class="line"><span class="code">    thunk_test.go:36: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestThunkFib (0.60s)</div></pre></td></tr></table></figure>

<p>奇怪不？为什么更慢了?我们不是缓存了中间计算的结果了么？下面的代码是我们常见的优化，我们的版本和下面不是一样的么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestMemoizedFib(t *testing.T) {</div><div class="line">  mem := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{</div><div class="line">   <span class="number"> 0</span>:<span class="number"> 0</span>,</div><div class="line">   <span class="number"> 1</span>:<span class="number"> 1</span>,</div><div class="line">  }</div><div class="line">    </div><div class="line">  <span class="keyword">var</span> fib <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span></div><div class="line">  fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">if</span> result, ok := mem[n]; ok {</div><div class="line">      <span class="keyword">return</span> result</div><div class="line">    }</div><div class="line">        </div><div class="line">    result := fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">    mem[n] = result</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  }</div><div class="line">    </div><div class="line">  t.Log(fib<span class="number">(40</span>))</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go test -run Memoized</div><div class="line"><span class="header">=== RUN   TestMemoizedFib</span></div><div class="line"><span class="code">    thunk_test.go:35: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestMemoizedFib (0.00s)</div></pre></td></tr></table></figure>

<p>如果你把我们使用<code>Trunk[T]</code>的斐波那契函数改动如下，也是能快速跑完的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">  <span class="keyword">if</span> cache[n].o.IsSome() {</div><div class="line">    <span class="keyword">return</span> *cache[n].o.val</div><div class="line">  }</div><div class="line">  </div><div class="line">  result := fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">  cache[n].o.Set(result)</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="header">=== RUN   TestThunkFib</span></div><div class="line"><span class="code">    thunk_test.go:59: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestThunkFib (0.00s)</div></pre></td></tr></table></figure>

<p>要明确的是，这不是Go泛型的错。我几乎可以肯定的是，我糟糕的代码导致了速度大大降低。</p>
<blockquote>
<p>网友指出我的代码事实上是错误的，我的<code>fib</code>实现应该如下:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">  <span class="keyword">return</span> cache[n<span class="number">-1</span>].Force() + cache[n<span class="number">-2</span>].Force()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我很高兴Go语言添加了泛型。这肯定会让很多事情变得更容易，更富有表现力。我担心在学习Go泛型的过程会给人们带来很多麻烦，。泛型应在特定情况下使用，而不是被滥用。</p>
<p>我希望这是一个关于如何在Go中使用泛型的有趣研究，但请不要在生产中使用这些示例。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.18发布了第一版的Go泛型之后，大家开始对Go泛型进行了深入的研究，今天翻译的这一篇，是加拿大的Xe Iaso刚出炉的一篇有趣的<a href="https://christine.website/blog/gonads-2022-04-24" target="_blank" rel="external">文章</a>，对Go泛型的应用做了一些探索。</p>
]]>
    
    </summary>
    
      <category term="go" scheme="https://colobu.com/categories/go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Uber工程师对真实世界并发问题的研究]]></title>
    <link href="https://colobu.com/2022/04/07/A-Study-of-Real-World-Data-Races-in-Golang/"/>
    <id>https://colobu.com/2022/04/07/A-Study-of-Real-World-Data-Races-in-Golang/</id>
    <published>2022-04-07T00:16:19.000Z</published>
    <updated>2022-05-22T08:37:06.155Z</updated>
    <content type="html"><![CDATA[<p>今天Uber工程师放出一篇论文(<a href="https://arxiv.org/abs/2204.00764" target="_blank" rel="external">A Study of Real-World Data Races in Golang</a>)，作者是Uber的工程师Milind Chabbi和Murali Krishna Ramanathan，他们负责使用Go内建的data race detector在Uber内的落地，经过6个多月的研究分析，他们将data race detector成功落地，并基于对多个项目的分析，得出了一些有趣的结论。</p>
<a id="more"></a>
<p>我们知道，Go是Uber公司的主打编程语言。他们对Uber的2100个不同的微服务，4600万行Go代码的分析，发现了超过2000个的有数据竞争的bug, 修复了其中的1000多个，剩余的正在分析修复中。</p>
<p>谈起真实世界中的Go并发Bug,其实2019年我们华人学者的<a href="https://songlh.github.io/paper/go-study.pdf" target="_blank" rel="external">Understanding Real-World Concurrency Bugs in Go</a>论文可以说是开山之作，首次全面系统地分析了几个流行的大型Go项目的并发bug。今天谈的这一篇呢，是Uber工程师针对Uber的众多的Go代码做的分析。我猜他们可能是类似国内工程效能部的同学，所以这篇论文有一半的篇幅介绍Go data race detector是怎么落地的，这个我们就不详细讲了，这篇论文的另一半是基于对data race的分析，罗列出了常见的出现data race的场景，对我们Gopher同学来说，很有学习的意义，所以我晚上好好拜读了一下这篇论文，做一总结和摘要。</p>
<p>作为一个大厂，肯定不止一种开发语言，作者对Uber线上个编程语言(go、java、nodejs、python)进行分析，可以看到：</p>
<ol>
<li>相比较Java， 在Go语言中会更多的使用并发处理</li>
<li>同一个进程中，nodejs平均会启动16个线程，python会启动16-32个线程，java进程一般启动128-1024个线程，10%的Java程序启动4096个线程，7%的java程序启动8192个线程。Go程序一般启动1024-4096个goroutine,6%的Go程序启动8192个goroutine(原文是8102，我认为是一个笔误)，最大13万个。</li>
</ol>
<p>可以看到Go程序会比其它语言有更多的并发单元，更多的并发单元意味着存在着更多的并发bug。Uber代码库中都有哪些类的并发bug呢？</p>
<p>下面的介绍会很多的使用数据竞争概念(data race)，它是并发编程中常见的概念，有数据竞争，意味着有多个并发单元对同一个数据资源有并发的读写，至少有一个写，有可能会导致并发问题。</p>
<h2 id="透明地引用捕获_(Transparent_Capture-by-Reference)">透明地引用捕获 (Transparent Capture-by-Reference)</h2>
<p>直接翻译过来你可能觉得不知所云。Transparent是指没有显示的声明或者定义，就直接引用某些变量，很容易导致数据竞争。通过例子更容易理解。这是一大类，我们分成小类逐一介绍。</p>
<h3 id="循环变量的捕获">循环变量的捕获</h3>
<p>不得不说，这也是我最常犯的错误。虽然明明知道会有这样的问题，但是在开发的过程中，总是无意的犯这样的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _ , job := <span class="keyword">range</span> jobs {</div><div class="line"> <span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">   ProcessJob ( job )</div><div class="line"> }()</div><div class="line"> } <span class="comment">// end for</span></div></pre></td></tr></table></figure>

<p>比如这个简单的例子,job是索引变量，循环中启动了一个goroutine处理这个job。job变量就透明地被这个goroutine引用。</p>
<p>循环变量是唯一的，意味着启动的这个goroutine,有可能处理的都是同一个job,而并不是期望的没有一个job。</p>
<p>这个例子还很明显，有时候循环体内特别复杂，可能并不像这个例子那么容易发现。</p>
<h3 id="err变量被捕获">err变量被捕获</h3>
<p>下面这个例子，y,z的赋值时，会对同一个err进行写操作，也可能会导致数据竞争，产生并发问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">x , err := Foo ()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line"> <span class="keyword">var</span> y <span class="typename">int</span></div><div class="line"> y , err = Bar ()</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">  ...</div><div class="line">  }</div><div class="line">}()</div><div class="line"></div><div class="line"><span class="keyword">var</span> z <span class="typename">string</span></div><div class="line">z , err = Baz ()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="捕获命名的返回值">捕获命名的返回值</h3>
<p>下面这个例子定义了一个命名的返回值<code>result</code>。可以看到 <code>... = result</code>（读操作）和<code>return 20</code> (写操作)有数据竞争的问题，虽然<code>return 20</code>你并没有看到对result的赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NamedReturnCallee () ( result <span class="typename">int</span>) {</div><div class="line">  result =<span class="number"> 10</span></div><div class="line">  <span class="keyword">if</span> ... {</div><div class="line">    <span class="keyword">return</span> <span class="comment">// this has the effect of " return 10"</span></div><div class="line">  }</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">   ... = result <span class="comment">// read result</span></div><div class="line">  }()</div><div class="line">  <span class="keyword">return</span><span class="number"> 20</span> <span class="comment">// this is equivalent to result =20</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Caller () {</div><div class="line"> retVal := NamedReturnCallee ()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>defer</code>也会有类似的效果,下面这段代码对err有数据竞争问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">func</span> Redeem ( request Entity ) ( resp Response , err error )</div><div class="line">{</div><div class="line"> <span class="keyword">defer</span> <span class="keyword">func</span> () {</div><div class="line">  resp , err = c . Foo ( request , err )</div><div class="line"> }()</div><div class="line"> err = CheckRequest ( request )</div><div class="line"> ... <span class="comment">// err check but no return</span></div><div class="line"> <span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">  ProcessRequest ( request , err != <span class="constant">nil</span> )</div><div class="line"> }()</div><div class="line"> <span class="keyword">return</span> <span class="comment">// the defer function runs after here</span></div><div class="line"> }</div></pre></td></tr></table></figure>

<h2 id="Slice相关的数据竞争">Slice相关的数据竞争</h2>
<p>下面这个例子，<code>safeAppend</code>使用锁对<code>myResults</code>进行了保护，但是在每次循环调用<code>(uuid, myResults)</code>并没有读保护，也会有竞争问题，而且不容易发现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ProcessAll ( uuids [] <span class="typename">string</span> ) {</div><div class="line"> <span class="keyword">var</span> myResults [] <span class="typename">string</span></div><div class="line"> <span class="keyword">var</span> mutex sync . Mutex</div><div class="line"> safeAppend := <span class="keyword">func</span> ( res <span class="typename">string</span> ) {</div><div class="line"> mutex.Lock ()</div><div class="line">  myResults = <span class="built_in">append</span> ( myResults , res )</div><div class="line"> mutex.Unlock ()</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">for</span> _ , uuid := <span class="keyword">range</span> uuids {</div><div class="line"> <span class="keyword">go</span> <span class="keyword">func</span> ( id <span class="typename">string</span> , results [] <span class="typename">string</span> ) {</div><div class="line"> res := Foo ( id )</div><div class="line"> safeAppend ( res )</div><div class="line">  }( uuid , myResults ) <span class="comment">// slice read without holding lock</span></div><div class="line"> }</div><div class="line"> ...</div><div class="line"> }</div></pre></td></tr></table></figure>

<h2 id="非线程安全的map">非线程安全的map</h2>
<p>这个很常见了，几乎每个Gopher都曾犯过，犯过才意识到Go内建的map对象并不是线程安全的，需要加锁或者使用sync.Map等其它并发原语。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> processOrders ( uuids [] <span class="typename">string</span> ) error {</div><div class="line"><span class="keyword">var</span> errMap = <span class="built_in">make</span> ( <span class="keyword">map</span> [ <span class="typename">string</span> ] error )</div><div class="line"><span class="keyword">for</span> _ , uuid := <span class="keyword">range</span> uuids {</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span> ( uuid <span class="typename">string</span> ) {</div><div class="line">orderHandle , err := GetOrder ( uuid )</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">▶ errMap [ uuid ] = err</div><div class="line"><span class="keyword">return</span></div><div class="line">}</div><div class="line">...</div><div class="line">}( uuid )</div><div class="line"><span class="keyword">return</span> combineErrors ( errMap )</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="传值和传引用的误用">传值和传引用的误用</h2>
<p>Go标准库常见并发原语不允许在使用后Copy, go vet也能检查出来。比如下面的代码，两个goroutine想共享mutex,需要传递<code>&amp;mutex</code>,而不是<code>mutex</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="typename">int</span></div><div class="line"><span class="comment">// CriticalSection receives a copy of mutex .</span></div><div class="line"><span class="keyword">func</span> CriticalSection ( m sync . Mutex ) {</div><div class="line">m.Lock ()</div><div class="line"> a ++</div><div class="line">m.Unlock ()</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main () {</div><div class="line">mutex := sync . Mutex {}</div><div class="line"><span class="comment">// passes a copy of m to A .</span></div><div class="line"><span class="keyword">go</span> CriticalSection ( mutex )</div><div class="line"><span class="keyword">go</span> CriticalSection ( mutex )</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="混用消息传递和共享内存两种并发方式">混用消息传递和共享内存两种并发方式</h2>
<p>消息传递常用channel。下面的例子中，如果context因为超时或者主动cancel被取消的话，Start中的goroutine中的<code>f.ch &lt;- 1</code>可能会被永远阻塞，导致goroutine泄露。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ( f * Future ) Start () {</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">resp , err := f.f () <span class="comment">// invoke a registered function</span></div><div class="line"> f.response = resp</div><div class="line"> f.err = err</div><div class="line"> f.ch &lt;-<span class="number"> 1</span> <span class="comment">// may block forever !</span></div><div class="line">}()</div><div class="line">}</div><div class="line"><span class="keyword">func</span> ( f * Future ) Wait ( ctx context . Context ) error {</div><div class="line"><span class="keyword">select</span> {</div><div class="line"><span class="keyword">case</span> &lt;-f.ch :</div><div class="line"><span class="keyword">return</span> <span class="constant">nil</span></div><div class="line"><span class="keyword">case</span> &lt;- ctx.Done () :</div><div class="line"> f.err = ErrCancelled</div><div class="line"><span class="keyword">return</span> ErrCancelled</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="并发测试">并发测试</h2>
<p>Go的<code>testing.T.Parallel()</code>为单元测试提供了并发能力，或者开发者自己写一些并发的测试程序测试代码逻辑，在这些并发测试中，也是有可能导致数据竞争的。不要以为测试不会有数据竞争问题。</p>
<h2 id="不正确的锁调用">不正确的锁调用</h2>
<h3 id="为写操作申请读锁">为写操作申请读锁</h3>
<p>下面这个例子中，<code>g.ready</code>是写操作，可是这个函数调用的是读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ( g * HealthGate ) updateGate () {</div><div class="line">g.mutex.RLock ()</div><div class="line"><span class="keyword">defer</span> g.mutex.RUnlock ()</div><div class="line"><span class="comment">// ... several read - only operations ...</span></div><div class="line"><span class="keyword">if</span> ... {</div><div class="line"> g.ready = <span class="constant">true</span> <span class="comment">// Concurrent writes .</span></div><div class="line"> g.gate.Accept () <span class="comment">// More than one Accept () .</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="其它锁的问题">其它锁的问题</h3>
<p>你会发现，大家经常犯的一个“弱智”的问题，就是Mutex只有Lock或者只有Unlock,或者两个Lock,这类问题本来你认为绝不会出现的，在现实中却经常能看到。</p>
<p>还有使用<code>atomic</code>进行原子写，但是却没有原子读。</p>
<blockquote>
<p>我认为这里Uber工程师并没有全面详细的介绍使用锁常见的一些陷阱，推荐你学习极客时间中的<a href="https://time.geekbang.org/column/intro/355" target="_blank" rel="external">Go 并发编程实战课</a>课程，此课程详细介绍了每个并发原语的陷阱和死锁情况。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>总结一下，下表列出了基于语言类型统计的数据竞争bug数：</p>
<p><img src="2.png" alt=""></p>
<p>整体来看，锁的误用是最大的数据竞争的原因。并发访问slice和map也是很常见的数据竞争的原因。<br><img src="3.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天Uber工程师放出一篇论文(<a href="https://arxiv.org/abs/2204.00764" target="_blank" rel="external">A Study of Real-World Data Races in Golang</a>)，作者是Uber的工程师Milind Chabbi和Murali Krishna Ramanathan，他们负责使用Go内建的data race detector在Uber内的落地，经过6个多月的研究分析，他们将data race detector成功落地，并基于对多个项目的分析，得出了一些有趣的结论。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最常用的架构模式]]></title>
    <link href="https://colobu.com/2022/03/06/most-useful-software-architecture-patterns/"/>
    <id>https://colobu.com/2022/03/06/most-useful-software-architecture-patterns/</id>
    <published>2022-03-06T08:48:44.000Z</published>
    <updated>2022-03-06T09:46:52.573Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>观其设计知其人</p>
<p>A MAN is KNOWN by the DESIGN he keeps</p>
</blockquote>
<p>原文:<a href="https://shadman-jamil.medium.com/most-useful-software-architecture-patterns-68e171405292" target="_blank" rel="external">Most Useful Software Architecture Patterns</a> by Shadman Jamil</p>
<a id="more"></a>
<p><img src="Software-Architecture.png" alt=""></p>
<h2 id="分层模式_(Layered_Pattern_(n-tier))">分层模式 (Layered Pattern (n-tier))</h2>
<p>分层架构模式是最常见的模式之一。分层模式背后的理念是，具有相同功能的组件将被组织成水平层。因此，每一层在应用程序中都扮演着特定的角色。</p>
<p>在这种模式中，我们对应用程序可以拥有的层数没有限制。在这方面，我们还提倡关注点分离的概念。分层模式风格抽象了整个软件的视图；同时提供足够的细节，以了解各个层的角色和职责以及它们之间的关系。分层模式的典型实现如下：</p>
<ul>
<li>UI展示层(<strong>UI / Presentation Layer</strong>): 渲染并运行用户界面，向服务器应用程序发送请求。</li>
<li>应用层(<strong>Application Layer</strong>): 包含表示层、应用程序层、域对象层和持久化层。</li>
<li>域对象层/业务层(<strong>Domain / Business Layer</strong>): 该层包含所有业务逻辑、实体、事件和其他包含业务逻辑的对象类型。</li>
<li>数据库层(<strong>Database Layer</strong>): 这是数据层，用于持久化数据，应用服务器将使用这些数据。</li>
</ul>
<p><img src="layers.png" alt=""></p>
<p><strong>例子</strong>: 桌面应用程序、电子商务、web应用程序等。</p>
<blockquote>
<p>参考例子： <a href="https://github.com/bxcodec/go-clean-arch" target="_blank" rel="external">go-clean-arch</a></p>
</blockquote>
<h2 id="客户端-服务器模式_(Client-Server_Pattern)">客户端-服务器模式 (Client-Server Pattern)</h2>
<p>这是最简单的架构模式，由一台服务器和多个客户端组成。这种模式是一种分布式架构，在资源/服务的提供者（称为服务器）和服务请求者（称为客户端）之间划分任务/工作负载。</p>
<p>在客户端-服务器模式中，当客户端向服务器发送数据请求时，服务器接受请求的进程，并向客户机发送所需的数据。客户不共享他们的任何资源。</p>
<p><img src="client-server.png" alt=""></p>
<p><strong>例子</strong>: Email、文档共享、银行等</p>
<h2 id="事件总线模式_(Event-Bus_Pattern_(Event-Driven_Architecture))">事件总线模式 (Event-Bus Pattern (Event-Driven Architecture))</h2>
<p>该模式是一种分布式异步体系架构模式，用于创建高度可扩展的响应式应用程序。适用于从小型到复杂的各级应用程序技术栈。此模式的主要思想是异步传递和处理事件。</p>
<p>这个模式包含四个组件:</p>
<ol>
<li>事件源(Event Source)</li>
<li>事件监听器(Event Listener)</li>
<li>通道(Channel)</li>
<li>事件总线(Event Bus)</li>
</ol>
<p>源将消息发布到事件总线上的特定通道。监听器订阅特定的频道，监听器可以获取发布到其订阅的频道的消息。</p>
<p><img src="event-source.png" alt=""></p>
<p><strong>例子</strong>: 电子商务、手机应用程序、通知服务等</p>
<h2 id="代理人模式(Broker_Pattern)">代理人模式(Broker Pattern)</h2>
<p>此模式可用于构造具有通过远程服务调用进行交互的解耦组件的分布式系统。代理组件负责协调组件之间的通信；例如转发请求，以及传输结果和异常。</p>
<p><strong>服务器</strong>将其能力（服务和特性）发布给<strong>代理</strong>(Broker)。<strong>客户端</strong>向<strong>代理</strong>请求服务，然后<strong>代理</strong>将<strong>客户端</strong>的请求重定向到合适的服务。</p>
<p><img src="broker.png" alt=""></p>
<p><strong>例子</strong>: 消息Broker程序，如Apache ActiveMQ、Apache Kafka、RabbitMQ、JBOSS Messaging等</p>
<h2 id="微服务模式_(Microservices_Pattern)">微服务模式 (Microservices Pattern)</h2>
<p>在这种模式中，服务通过使用HTTP/REST等同步协议或AMQP（高级消息队列协议）等异步协议进行通信。服务可以独立开发和部署，每个服务都有自己的数据库。服务之间的数据一致性是通过使用Saga模式（一系列本地事务）来维护的。</p>
<p><img src="microservices.png" alt=""></p>
<p><strong>例子</strong>: 可以在许多用例上实现，尤其是广泛的数据管道处理上</p>
<h2 id="点对点模式_(Peer-to-Peer_Pattern)">点对点模式 (Peer-to-Peer Pattern)</h2>
<p>在通用客户端-服务器体系架构中，多个客户端与中央服务器通信。但P2P模式由分散的对等网络组成。</p>
<p>在这种模式中，节点的行为类似于客户端和服务器。对等点既可以作为客户端向其他对等点请求服务，也可以作为服务器向其他对等点提供服务。</p>
<p>P2P网络在节点之间分配工作负载，所有节点贡献并消耗网络中的资源，而不需要集中的服务器。对等方可能会随着时间动态地改变其角色。</p>
<p><img src="peer-2-peer.png" alt=""></p>
<p><strong>例子</strong>: 文件分享网络、多媒体协议PDTP,P2PTV、比特币、区块链等</p>
<h2 id="黑板模式(Blackboard_Pattern)">黑板模式(Blackboard Pattern)</h2>
<p>这种模式对于不知道确定性解决方案策略的问题很有用。</p>
<p>所有部件都可以接触到黑板。组件可能会产生新的数据对象，这些对象将被添加到黑板上。组件在黑板上寻找特定类型的数据，并通过与现有知识源的模式匹配找到这些数据。</p>
<p>这个模式包含三个组件：</p>
<ul>
<li>黑板(blackboard): 含解决方案空间中的对象的结构化全局内存</li>
<li>知识源(knowledge source:):具有自己表示形式的专用模块</li>
<li>控制组件(control component):选择、配置和执行模块。</li>
</ul>
<p><img src="blackboard.png" alt=""></p>
<p><strong>例子</strong>: 速度识别、蛋白质结构识别、声纳信号解释、机器学习程序等。</p>
<h2 id="组件模式_(Component-based_Pattern)">组件模式 (Component-based Pattern)</h2>
<p>基于组件的软件工程（Component-based software engineering，简称CBSE）或基于组件的开发（Component-Based Development，简称CBD）是针对系统的广泛功能，进行关注点分离的软件工程方式。此方式是以复用为基础的作法，定义、实现许多松耦合的独立组件（Component），再将组件组合成为系统。此作法的目的是希望在软件本身的短期益处以及开发软件组织的长期益处之间获取平衡。</p>
<p>一旦组件进行了划分，可以将组件分布式的开发部署，就会演化成面向服务或者微服务的架构。</p>
<p><img src="component-based.png" alt=""></p>
<p><strong>例子</strong>: 常见大型项目中或者单个服务中。</p>
<h2 id="管道模式_(Pipes_和_filters)">管道模式 (Pipes 和 filters)</h2>
<p>管道(pipeline)由一系列处理元素（进程、线程、协同程序、函数等）组成，每个元素的输出都是下一个元素的输入；这个名字类似于一个物理管道。通常在连续元素之间提供一定量的缓冲。在这些管道中流动的信息通常是记录流、字节流或比特流，管道中的元素可以称为过滤器(filter)；这也称为管道和过滤器设计模式。将元素连接到管道中类似于函数合成。</p>
<p>管道模式可以将数据的处理解耦，并且可以动态的增加或者删除特定的处理流程。每个处理单元可以结合下面插件模式，实现定制化。</p>
<p><img src="pipeline.png" alt=""></p>
<p><strong>例子</strong>: 多任务操作系统、数据处理程序等。</p>
<h2 id="插件模式">插件模式</h2>
<p>在计算技术中，插件（或插件、外接程序、外接程序、外接程序或外接程序）是一种软件组件，用于向现有计算机程序添加特定功能。当程序支持插件时，它会启用自定义功能。</p>
<p>插件模式可以方便对程序进行扩展，以及动态实现功能的开启和禁用等功能，方便进行定制化。</p>
<p><img src="plugin.png" alt=""></p>
<p><strong>例子</strong>: IDE程序如Eclipse，IDEA Intellj、网络应用程序入netty等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>观其设计知其人</p>
<p>A MAN is KNOWN by the DESIGN he keeps</p>
</blockquote>
<p>原文:<a href="https://shadman-jamil.medium.com/most-useful-software-architecture-patterns-68e171405292" target="_blank" rel="external">Most Useful Software Architecture Patterns</a> by Shadman Jamil</p>
]]>
    
    </summary>
    
      <category term="架构" scheme="https://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题: 大型理发店]]></title>
    <link href="https://colobu.com/2022/03/06/hilzers-barbershop-problem/"/>
    <id>https://colobu.com/2022/03/06/hilzers-barbershop-problem/</id>
    <published>2022-03-06T06:04:11.000Z</published>
    <updated>2022-03-06T08:19:05.176Z</updated>
    <content type="html"><![CDATA[<p>二月二理发店太火了，家家都爆满，这次我们来到Hilzer的理发店，这是一家比较大的理发店。</p>
<a id="more"></a>
<p>这家理发店有三位有经验的理发师，每个理发师都有自己独立的理发椅。等待区有一个四座的沙发，等待区还有站一些人等待。还有一个收银台。</p>
<ul>
<li>依照新冠疫情防控的要求，最多允许20个顾客进入。</li>
<li>如果有顾客，理发师优先从沙发上叫起等待最久的顾客开始理发；如果没有顾客，理发师则在自己的理发椅上睡觉</li>
<li>顾客来到后<ul>
<li>如果已经有20个顾客，则此顾客离开去其它理发店</li>
<li>如果理发师在睡觉，则叫起一位理发师开始理发</li>
<li>如果没有空闲的理发师，则选择沙发坐下</li>
<li>如果沙发已经坐满，则在休息去站着等待</li>
</ul>
</li>
<li>理完发后顾客去收银台去缴费，交完费后理发师把发票交给顾客。顾客就离开，而理发师则准备服务下一位顾客</li>
</ul>
<p>这一次理发店的问题比上一个<a href="https://colobu.com/2022/02/27/barbershop-problem/" target="_blank" rel="external">理发店问题</a>要复杂很多:</p>
<ul>
<li>等待区分为了站立区和沙发区</li>
<li>新增加了收银台，理发师和顾客需要付款和发票的相互等待</li>
<li>三位理发师</li>
</ul>
<p>这类问题使用信号量并发原语比较好，因为理发师、沙发等都是一定数量的资源。理发师和顾客之间缴费和发票之间的同步按理说使用channel比较合适，但是收银台只有一位收银员，还需要处理理发师、顾客和收银员之间的并发，所以我们可以把收银、开发票看成计数器是1的资源。</p>
<p>首先我们还是定义信号量和辅助方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Semaphore定义</span></div><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">	time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来我们定义所需的并发原语。</p>
<p>我们使用<code>customerMutex</code>这个排他锁来控制理发店的顾客数量。<br>使用<code>sofaSema</code>控制站立用户坐到沙发上以及理发师叫起等待的顾客。</p>
<p><code>paySema</code>用来让顾客去缴费，而<code>receiptSema</code>让理发师把发票送给顾客，顾客离开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 控制顾客的总数</span></div><div class="line">	customerMutex    sync.Mutex</div><div class="line">	customerMaxCount =<span class="number"> 20</span></div><div class="line">	customerCount    =<span class="number"> 0</span></div><div class="line"></div><div class="line">	<span class="comment">// 沙发的容量</span></div><div class="line">	sofaSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 4</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 三位理发师</span></div><div class="line">	barberSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 3</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 收银台</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 同时只有一对理发师和顾客结账</span></div><div class="line">	paySema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)</div><div class="line">	<span class="comment">// 顾客拿到发票才会离开，控制开票</span></div><div class="line">	receiptSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>接下来我们实现理发师的逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理发师工作</span></div><div class="line"><span class="keyword">func</span> barber(name <span class="typename">string</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(name + <span class="string">"老师尝试请求一个顾客"</span>)</div><div class="line">		sofaSema.Release() <span class="comment">// 等待沙发上等待最久的一位顾客</span></div><div class="line">		log.Println(name + <span class="string">"老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line"></div><div class="line">		log.Println(name + <span class="string">"老师理完发，等待顾客付款"</span>)</div><div class="line">		paySema.Acquire() <span class="comment">// 等待用户缴费</span></div><div class="line">		log.Println(name + <span class="string">"老师给付完款的顾客发票"</span>)</div><div class="line">		receiptSema.Release() <span class="comment">// 通知顾客发票开好</span></div><div class="line">		log.Println(name + <span class="string">"老师服务完一位顾客"</span>)</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来实现顾客的逻辑, 注意<code>customerCount</code>操作需要使用Mutex保护:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(500</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	customerMutex.Lock()</div><div class="line">	<span class="keyword">if</span> customerCount == customerMaxCount {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">		customerMutex.Unlock()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	customerCount++</div><div class="line">	customerMutex.Unlock()</div><div class="line"></div><div class="line">	log.Println(<span class="string">"一位顾客开始等沙发坐下"</span>)</div><div class="line">	sofaSema.Acquire()</div><div class="line">	log.Println(<span class="string">"一位顾客找到空闲沙发坐下,直到被理发师叫起理发"</span>)</div><div class="line"></div><div class="line">	paySema.Release()</div><div class="line">	log.Println(<span class="string">"一位顾客已付完钱"</span>)</div><div class="line">	receiptSema.Acquire()</div><div class="line">	log.Println(<span class="string">"一位顾客拿到发票，离开"</span>)</div><div class="line"></div><div class="line">	customerMutex.Lock()</div><div class="line">	customerCount--</div><div class="line">	customerMutex.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后把所有的逻辑串起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 托尼、凯文、艾伦理发师三巨头</span></div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Tony"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Kevin"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Allen"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> customers()</div><div class="line"></div><div class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">	&lt;-sigs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序观察并发的执行。</p>
<p>通过这个问题，我们可以好好的练习Semaphore的使用，以及两个goroutine之间信号的传递，控制并发程序的协作执行。</p>
<p>下一章你想了解什么样的经典并发问题呢？</p>
<h2 id="历史并发问题">历史并发问题</h2>
<ul>
<li><a href="https://colobu.com/2022/02/13/dining-philosophers-problem/" target="_blank" rel="external">哲学家就餐问题</a></li>
<li><a href="https://colobu.com/2019/07/23/concurrent-problem-h2o-factory/" target="_blank" rel="external">制造一氧化二氢</a></li>
<li><a href="https://colobu.com/2022/02/27/barbershop-problem/" target="_blank" rel="external">理发店的故事</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>二月二理发店太火了，家家都爆满，这次我们来到Hilzer的理发店，这是一家比较大的理发店。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题： 理发店的故事]]></title>
    <link href="https://colobu.com/2022/02/27/barbershop-problem/"/>
    <id>https://colobu.com/2022/02/27/barbershop-problem/</id>
    <published>2022-02-27T08:40:51.000Z</published>
    <updated>2022-02-27T10:12:01.956Z</updated>
    <content type="html"><![CDATA[<p>马上就二月二了，理发店就要忙活起来了，托尼、凯文、艾伦等老师的理发剪磨刀霍霍，把椅子擦亮，准备各位顾客的到来。</p>
<p><a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" target="_blank" rel="external">Sleeping barber problem</a>是一个经典的goroutine交互和并发控制的问题，可以很好的用来演示多写多读的并发问题(multiple writers multiple readers)。</p>
<a id="more"></a>
<p>理发店问题最早是由计算机科学先驱 Edsger Dijkstra 在1965指出的，在 Silberschatz 和 Galvin 的 Operating Systems Concepts一书中有此问题的变种。</p>
<p>这个问题是这样子的。<br>有这么一个理发店，有一位理发师和几个让顾客等待的座位：</p>
<ul>
<li>如果没有顾客，这位理发师就躺在理发椅上睡觉</li>
<li>顾客必须唤醒理发师让他开始理发</li>
<li>如果一位顾客到来，理发师正在理发<ul>
<li>如果还有顾客用来等待的座位，则此顾客坐下</li>
<li>如果座位都满了，则此顾客离开</li>
</ul>
</li>
<li>理发师理完头发后，需要检查是否还有等待的顾客<ul>
<li>如果有，则请一位顾客起来开始理发</li>
<li>如果没有，理发师则去睡觉</li>
</ul>
</li>
</ul>
<p>虽然条件很多，我们可以把它想象成为一个并发的queue。在当前的问题下，有多个并发写(multiple writer, 顾客)，一个并发读(single reader),对吧。</p>
<h2 id="使用sync-Cond实现">使用sync.Cond实现</h2>
<p>一般，先前，我们处理并发队列通过使用<a href="https://pkg.go.dev/sync#Cond" target="_blank" rel="external">sync.Cond</a>这个并发原语(在java语言中，我们一般使用wait/notify)。</p>
<p>就<code>sync.Cond</code>这个并发原语而言，它并不是一个很容易使用的对象。因为它还需要一个一个<code>sync.Locker</code>配合使用，并且相关的方法要么必须使用Locker、要么可以省略Locker，容易让人迷惑，等待的goroutine被唤醒时还需要检查判断条件，所以用起来总是需要小心翼翼地。</p>
<p>首先，我们定义一个Locker和一个Cond,并且定义顾客等待的座位数。<br>来了一位顾客，座位数加一，Tony老师叫起一位等待的顾客开始理发时，座位数减一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	seatsLock sync.Mutex</div><div class="line">	seats     <span class="typename">int</span></div><div class="line">	cond = sync.NewCond(&seatsLock)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>理发师的工作就是不断的检查是否有顾客等待，如果有，就交起一位顾客开始理发，理发耗时是随机的，理完再去叫下一位顾客。如果没有顾客，那么理发师就会被阻塞(开始睡觉)。<br>逐一这里Cond的使用方法，Wait之后需要for循环检查条件是否满足，并且Wait上下会有Locker的使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(<span class="string">"Tony老师尝试请求一个顾客"</span>)</div><div class="line">		seatsLock.Lock()</div><div class="line">		<span class="keyword">for</span> seats ==<span class="number"> 0</span> {</div><div class="line">			cond.Wait()</div><div class="line">		}</div><div class="line">		seats--</div><div class="line">		seatsLock.Unlock()</div><div class="line">		log.Println(<span class="string">"Tony老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>customers</code>模拟陆陆续续的顾客的到来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾客到来之后，先请求seatsLock， 避免多个顾客同时进来的并发竞争。然后他会检查是否有空闲的座位，如果有则坐下并通知理发师。此时理发师如果睡眠则会被唤醒，如果正在理发会忽略。<br>如果没有空闲的座位则离开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	seatsLock.Lock()</div><div class="line">	<span class="keyword">defer</span> seatsLock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> seats ==<span class="number"> 3</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	seats++</div><div class="line">	cond.Broadcast()</div><div class="line"></div><div class="line">	log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里简单的是由整数seats代表空闲的座位，实际处理这样的场景的时候，你可能会使用一个slice作为队列。</p>
<p>本身这个实现还是很简单的，但是Cond+Locker的使用方式还是感觉让人有那么一点不放心，事实上，很多这样的场景，我们可以使用channel来实现。</p>
<h2 id="使用Channel实现Semaphore">使用Channel实现Semaphore</h2>
<p>我们可以使用Channel实现一个Semaphore来解决理发店问题。Semaphore实现如下,和我们水分子生成的问题中的实现是类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) TryAcquire() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> s &lt;- <span class="keyword">struct</span>{}{}: <span class="comment">// 还有空位子</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>: <span class="comment">// 没有空位子了,离开</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了这个并发原语，我们就容易解决理发店问题了。注意这里我们实现了<code>TryAcquire</code>,就是为了顾客到来的是否检查有没有空闲的座位。<br>这里为什么不使用Go官方扩展的<code>semaphore.Weighted</code>并发原语呢，是因为<code>semaphore.Weighted</code>有个问题，在<code>Accquire</code>之前调用<code>Release</code>方法的话会panic，所以我们自己实现了一个。</p>
<p>我们定义了有三个等待座位的信号量。Tony老师先调用<code>Release</code>方法，也就是想从座位上请一位顾客过来理发，以便空出一个等待座位。如果没有顾客，Tony就会无奈的等待和睡觉了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seats = <span class="built_in">make</span>(Semaphore,<span class="number"> 3</span>)</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">    		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(<span class="string">"Tony老师尝试请求一个顾客"</span>)</div><div class="line">		seats.Release()</div><div class="line">		log.Println(<span class="string">"Tony老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾客的检查也更简单:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	<span class="keyword">if</span> ok := seats.TryAcquire(); ok {</div><div class="line">		log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，如果我们使用自定义的Semaphore话，代码会变得更加的简单。</p>
<p>那么这种channel实现的Semaphore有什么缺陷吗？那就是如果队列的长度太大的话，channel的容量就会很大。不过如果类型设置为strcut{}类型的话，就会节省很多的内存，所以一般也不会有什么问题，虽然比官方扩展的计数器方式的<code>semaphore.Weighted</code>多占用一些空间，但是占用的空间还是有限的。</p>
<p>更进一步，尽然我们要实现一个队列，其实可以通过这个channel来实现，把顾客类型替换struct{}类型，这样就没有额外多余的占用了。</p>
<h2 id="多理发师的情况">多理发师的情况</h2>
<p>更进一步，我们考虑多个理发师的情况。</p>
<p>多个理发师的问题其实就演变成了多写(multiple writer)多读(multiple reader)的场景了。</p>
<p>托尼、凯文和艾伦是理发界的三大巨头，我们演示三位理发师并发理发的场景，同时理发店的规模也扩大了，有10个可以等待的座位。</p>
<p>基于channel实现的Semaphore的解决方案，多个理发师的场景和单个理发师的场景是一样的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) TryAcquire() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> s &lt;- <span class="keyword">struct</span>{}{}: <span class="comment">// 还有空位子</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>: <span class="comment">// 没有空位子了,离开</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> seats = <span class="built_in">make</span>(Semaphore,<span class="number"> 10</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 托尼、凯文、艾伦理发师三巨头</span></div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Tony"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Kevin"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Allen"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> customers()</div><div class="line"></div><div class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">	&lt;-sigs</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">	time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber(name <span class="typename">string</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(name + <span class="string">"老师尝试请求一个顾客"</span>)</div><div class="line">		seats.Release()</div><div class="line">		log.Println(name + <span class="string">"老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	<span class="keyword">if</span> ok := seats.TryAcquire(); ok {</div><div class="line">		log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>全部经典并发问题的代码可以参考<a href="https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems" target="_blank" rel="external">smallnest/dive-to-gosync-workshop</a>。下一次我们再分析一个更加复杂的理发店问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>马上就二月二了，理发店就要忙活起来了，托尼、凯文、艾伦等老师的理发剪磨刀霍霍，把椅子擦亮，准备各位顾客的到来。</p>
<p><a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" target="_blank" rel="external">Sleeping barber problem</a>是一个经典的goroutine交互和并发控制的问题，可以很好的用来演示多写多读的并发问题(multiple writers multiple readers)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题: 哲学家就餐问题]]></title>
    <link href="https://colobu.com/2022/02/13/dining-philosophers-problem/"/>
    <id>https://colobu.com/2022/02/13/dining-philosophers-problem/</id>
    <published>2022-02-13T09:25:44.000Z</published>
    <updated>2022-02-24T09:36:34.503Z</updated>
    <content type="html"><![CDATA[<p>哲学家就餐问题是一个非常非常经典的问题，也是一个非常通用的研究并发编程中死锁现象的问题。</p>
<a id="more"></a>
<blockquote>
<p>为什么我们要研究经典的并发问题呢？这些经典问题是对现实中的计算机编程的抽象，代表了非常通用的计算机并发问题，计算机科学家对此进行了深入的研究，也总结出很多行之有效的解决办法。我们通过学习这些经典问题，可以将我们遇到的并发问题做对比，看不看是否是类似的问题，如何是相同的问题，可以使用前人总结的解决方案去解决。同时练习解决这些问题，也可以使我们学习和掌握并发原语和解决问题的技巧，举一反三去解决更多的并发问题。</p>
</blockquote>
<p>在1971年，著名的计算机科学家艾兹格·迪科斯彻(Edsger Dijkstra)提出了一个同步问题，即假设有五台计算机都试图访问五份共享的磁带驱动器。稍后，这个问题被托尼·霍尔(Tony Hoare)重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。</p>
<p>到了中国，哲学家就餐问题可以这样表述，假设因为新冠的原因，五位哲学家被隔离在一个房间里。这五位哲学家分别是孔子、庄子、墨子、孙子和老子，他们围坐在一个圆形的餐桌旁，餐桌上有无尽的可口的饭菜，不幸的是，出于环保的原因，只有五根筷子，每根筷子都位于两位哲学家之间。哲学家吃饭时，必须拿起自己左右两边的两根筷子才能吃饭，吃完饭后才放回筷子，这样其它哲学家可以再拿起筷子。</p>
<p>虽然隔离的日子比较寂寞，但是这些哲学家还是有事情可做，他们不断的冥想或者吃饭。饿了的时候就开始尝试拿起筷子，吃随机时间的饭菜，然后放下筷子开始冥想。冥想一段时间就饿了，又开始吃饭。所以他们总是处于冥想-饿了-吃饭-冥想这样的状态中。</p>
<p><img src="1.png" alt=""></p>
<p>这个哲学家很好的模拟了计算机并发编程中一定数量的资源和一定数量的持有者的并发问题，这类问题很大的一个问题就是死锁问题。</p>
<p>如果五位哲学家同时饿了，同时拿起左手边的那根筷子，你就会发现他们想去拿右边的筷子的时候，都没有办法拿起右边的筷子，因为右边那根筷子都被旁边的哲学家拿走了，所有的哲学家都处于等待状态而没有办法继续下去。对于程序来说，就是程序 hang死了，没有办法继续处理。</p>
<blockquote>
<p>如果这五位哲学家同时发现没有右边的筷子可用，他们同时放下左手的筷子，冥想5分钟再同时就餐，你会发现程序貌似还在进行，但是哲学家依然还是没有办法就餐，这种现象叫做死锁。在分布式一致性算法中在选主的时候也会有类似的现象，有些实现是通过随机休眠一定的时间，避免各个节点同时请求选主来避免。</p>
</blockquote>
<p>如果系统中只有一个线程，当然不会产生死锁。如果每个线程仅需求一种并发资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。如果你搜索Go官方的项目中的issue,可以看到几百个关于死锁的issue,足可以表明死锁是一个常见且并不容易处理的bug。</p>
<p><img src="2.png" alt=""></p>
<p>死锁的四个条件是：</p>
<ul>
<li><p><strong>禁止抢占</strong>（no preemption）：系统资源不能被强制从一个线程中退出。如果哲学家可以抢夺，那么大家都去抢别人的筷子，也会打破死锁的局面，但这是有风险的，因为可能孔子还没吃饭就被老子抢走了。计算机资源如果不是主动释放而是被抢夺有可能出现意想不到的现象。</p>
</li>
<li><p><strong>持有和等待</strong>（hold and wait）：一个线程在等待时持有并发资源。持有并发资源并还等待其它资源，也就是吃着碗里的望着锅里的。</p>
</li>
<li><p><strong>互斥</strong>（mutual exclusion）：资源只能同时分配给一个线程，无法多个线程共享。资源具有排他性，孔子和老子的关系再好，也不允许他们俩一起拿着一根筷同时吃。</p>
</li>
<li><p><strong>循环等待</strong>（circular waiting）：一系列线程互相持有其他进程所需要的资源。必须有一个循环依赖的关系。</p>
</li>
</ul>
<p>死锁只有在四个条件同时满足时发生，预防死锁必须至少破坏其中一项。</p>
<h2 id="模拟哲学家就餐问题">模拟哲学家就餐问题</h2>
<p>首先我们通过程序模拟哲学家就餐问题，看看程序在运行的是不是会产生死锁问题。</p>
<p>首先我们定义筷子对象和哲学家对象。其中筷子是并发资源，具有排他性，所以它包含一个锁，用来实现互斥，并且禁止抢占(其它非持有这根筷子的哲学家不能调用Unlock,只有持有这根筷子的哲学家才能调用Unlock)。</p>
<p>每个哲学家需要左手的筷子和右手的筷子，status代表哲学家的状态(冥想、饿了、就餐中)，他有一种状态就是持有一根筷子并请求另一根筷子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Chopstick 代表筷子.</span></div><div class="line"><span class="keyword">type</span> Chopstick <span class="keyword">struct</span>{ sync.Mutex }</div><div class="line"></div><div class="line"><span class="comment">// Philosopher 代表哲学家.</span></div><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>哲学家在隔离的房间就是不断的冥想、就餐、冥想、就餐...... 永无终日。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 随机暂停一段时</span></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">    time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 显示此哲学家的状态</span></div><div class="line"><span class="keyword">func</span> mark(p *Philosopher, action <span class="typename">string</span>) {</div><div class="line">    fmt.Printf(<span class="string">"%s开始%s\n"</span>, p.name, action)</div><div class="line">    p.status = fmt.Sprintf(<span class="string">"%s开始%s\n"</span>, p.name, action)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的mark用来在控制台输出此哲学家的状态，便于我们观察。</p>
<p>最后一步就是实现main函数，分配5根筷子和五个哲学家，让程序运行起来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">go</span> http.ListenAndServe(<span class="string">"localhost:8972"</span>, <span class="constant">nil</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 哲学家数量</span></div><div class="line">    count :=<span class="number"> 5</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建5根筷子</span></div><div class="line">    chopsticks := <span class="built_in">make</span>([]*Chopstick, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        chopsticks[i] = <span class="built_in">new</span>(Chopstick)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    names := []<span class="typename">string</span>{color.RedString(<span class="string">"孔子"</span>), color.MagentaString(<span class="string">"庄子"</span>), color.CyanString(<span class="string">"墨子"</span>), color.GreenString(<span class="string">"孙子"</span>), color.WhiteString(<span class="string">"老子"</span>)}</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">    &lt;-sigs</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"退出中... 每个哲学家的状态:"</span>)</div><div class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> philosophers {</div><div class="line">        fmt.Print(p.status)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序你会很快就发现这个程序会hang住，每个哲学家都处于拿到左手筷子等待右手筷子的状态。</p>
<p>在我们实际的应用中，死锁问题并不是这么容易的被发现的，很可能在一些非常特定的场景(也被称之为corner case)才会被触发和发现。</p>
<h2 id="解法一：限制就餐人数">解法一：限制就餐人数</h2>
<p>我们知道，解决死锁的问题就是破坏死锁形成的四个条件之一就可以。一般来说，禁止抢占和互斥是我们必须的条件，所以其它两个条件是我们重点突破的点。</p>
<p>针对哲学家就餐问题，如果我们限制最多允许四位哲学家同时就餐，就可以避免循环依赖的条件，因为依照抽屉原理，总是会有一位哲学家可以拿到两根筷子，所以程序可以运行下去。</p>
<p>针对限制特定数量资源的情况，最好用的并发原语就是信号量(Semaphore)。Go官方提供了一个扩展库，提供了一个Semaphore的实现：<a href="https://pkg.go.dev/golang.org/x/sync/semaphore" target="_blank" rel="external">semaphore/Weighted</a>。</p>
<p>我们把这个信号量初始值设置为4，代表最多允许同时4位哲学家就餐。把这个信号量传给哲学家对象，哲学家想就餐时就请求这个信号量，如果能得到一个许可，就可以就餐，吃完把许可释放回给信号量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line">    <span class="comment">// 信号量</span></div><div class="line">    sema *semaphore.Weighted</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.sema.Acquire(context.Background(),<span class="number"> 1</span>) <span class="comment">// 请求一个许可</span></div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">        p.sema.Release<span class="number">(1</span>) <span class="comment">// 释放许可给信号量</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 最多允许四个哲学家就餐</span></div><div class="line">    sema := semaphore.NewWeighted<span class="number">(4</span>)</div><div class="line">    <span class="comment">//</span></div><div class="line">    names := []<span class="typename">string</span>{color.RedString(<span class="string">"孔子"</span>), color.MagentaString(<span class="string">"庄子"</span>), color.CyanString(<span class="string">"墨子"</span>), color.GreenString(<span class="string">"孙子"</span>), color.WhiteString(<span class="string">"老子"</span>)}</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">            sema: sema,</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以运行这个程序，看看是否程序是否还会被hang住。</p>
<h2 id="解法二：奇偶资源">解法二：奇偶资源</h2>
<p>我们给每一位哲学家编号，从1到5, 如果我们规定奇数号的哲学家首先拿左手边的筷子，再拿右手边的筷子，偶数号的哲学家先拿右手边的筷子，再拿左手边的筷子， 释放筷子的时候按照相反的顺序，这样也可以避免出现循环依赖的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        <span class="keyword">if</span> p.ID<span class="number">%2</span> ==<span class="number"> 1</span> { <span class="comment">// 奇数</span></div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">            mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 再尝试放下左手边的筷子</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 先尝试拿起右手边的筷子</span></div><div class="line">            mark(p, <span class="string">"拿起右手筷子"</span>)</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 先尝试放下左手边的筷子</span></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 再尝试放下右手边的筷子</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            ID:   i +<span class="number"> 1</span>,</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序，你同样也会发现程序可以顺利执行下去，并不会出现死锁的现象。</p>
<h2 id="解法三：资源分级">解法三：资源分级</h2>
<p>另一个简单的解法是为资源（这里是筷子）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，筷子按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的筷子，再拿编号较高的。用完筷子后，他总是先放下编号较高的筷子，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的筷子时，只有编号最高的筷子留在桌上，从而第五位哲学家就不能使用任何一只筷子了。而且，只有一位哲学家能使用最高编号的筷子，所以他能使用两只筷子用餐。当他吃完后，他会先放下编号最高的筷子，再放下编号较低的筷子，从而让另一位哲学家拿起后边的这只开始吃东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        <span class="keyword">if</span> p.ID ==<span class="number"> 5</span> { <span class="comment">//</span></div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 先尝试拿起第1只筷子</span></div><div class="line">            mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 再尝试拿起第5只筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 先尝试放下第5只的筷子</span></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 再尝试放下第1只的筷子</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子(第n只)</span></div><div class="line">            mark(p, <span class="string">"拿起右手筷子"</span>)</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子(第n+1只)</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="解法四：引入服务生">解法四：引入服务生</h2>
<p>如果我们引入一个服务生，比如韩非子，由韩非子负责分配筷子，这样我们就可以将拿左手筷子和右手筷子看成一个原子操作，要么拿到筷子，要么等待，就可以破坏死锁的第二个条件(持有和等待)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line"></div><div class="line">    mu *sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.mu.Lock() <span class="comment">// 服务生控制</span></div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line">        p.mu.Unlock() </div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>完整代码可以参考 [dive-to-gosync-workshop(<a href="https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems" target="_blank" rel="external">https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems</a>)</p>
<p>下一篇我们讲解另外一个经典并发问题：一氧化二氢的生成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>哲学家就餐问题是一个非常非常经典的问题，也是一个非常通用的研究并发编程中死锁现象的问题。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyroscope: 一个简单易用的持续剖析平台]]></title>
    <link href="https://colobu.com/2022/01/27/pyroscope-a-continuous-profiling-platform/"/>
    <id>https://colobu.com/2022/01/27/pyroscope-a-continuous-profiling-platform/</id>
    <published>2022-01-27T10:56:27.000Z</published>
    <updated>2022-01-27T11:00:43.197Z</updated>
    <content type="html"><![CDATA[<p>开发人员常常需要跟踪生产环境中的应用程序的性能瓶颈，并试图找出造成瓶颈的根本原因。要做到这一点，他们通常会通过日志来收集这些信息。不幸的是，这种方法可能会很耗时，而且无法提供有关潜在问题的足够详细的信息。</p>
<p>一种现代且更先进的方法是应用和使用profiling技术和工具，突出显示最慢的应用程序代码和消耗大部分资源（如CPU和内存）的方法。持续分析(Continuous profiling)是在生产环境中持续    收集应用程序性能数据，并将这些数据提供给开发人员进行深入分析的过程。</p>
<p>通过，我们通过采集程序的指标，生成一个概要文件(Profile)进行单次的分析。Go语言提供了pprof工具，可以很方便的生成profile文件。你可以通过程序调用<a href="https://pkg.go.dev/runtime/pprof" target="_blank" rel="external">runtime/pprof</a>生成CPU、Heap等概要文件，也可以使用<a href="https://pkg.go.dev/net/http/pprof" target="_blank" rel="external">net/http/pprof</a>集成到web应用程序中，通过go tool pprof工具在命令行或者web页面中进行分析。</p>
<p>有时候，我们不能及时的进行pprof分析，故障可能消失了或者程序已经crash了。另外我们可能需要不同时段的profile进行对比，进行比较才能发现问题，比如内存泄露的问题。这个时候持续分析(continuous profiling)就很重要了。很多云服务厂商都提供持续分析的功能，比如<a href="https://www.datadoghq.com/dg/apm/ts/profiler/go-continuous-profiler-ts/?utm_source=advertisement&amp;utm_medium=search&amp;utm_campaign=dg-google-profiler-emea-goprofiling-tshirt&amp;utm_keyword=%2Bgo %2Bprofiling&amp;utm_matchtype=b&amp;utm_campaignid=15426873343&amp;utm_adgroupid=128217964697&amp;gclid=Cj0KCQiA_8OPBhDtARIsAKQu0gYymyElbglw_I7uZJkZ7ynxfzn1nVojVZJ9rkm_6_hbchG09w4CCmEaAkWfEALw_wcB" target="_blank" rel="external">Go Continuous Profiler | Datadog</a>、<a href="https://cloud.google.com/profiler/docs" target="_blank" rel="external">Cloud Profiler | Google Cloud</a>、<a href="https://aws.amazon.com/cn/codeguru/features/" target="_blank" rel="external">Amazon CodeGuru Profiler</a>等。</p>
<a id="more"></a>
<h2 id="Pyroscope简介">Pyroscope简介</h2>
<p>如果你想在自己的生产系统中使用持续分析，可以考虑<a href="https://pyroscope.io/" target="_blank" rel="external">Pyroscope</a>。</p>
<p>Pyroscope是一个开源的持续分析系统，使用Go语言实现。服务端使用web页面查看，提供丰富的分析的功能，客户端提供Go、Java、Python、Ruby、PHP、.NET等多种语言的支持，并且支持PUSH、PULL两种采集方式。</p>
<p><img src="0.svg" alt="deployment diagram"></p>
<p>首先，你需要部署一个Pyroscope server，它底层采用BadgerDB作为存储引擎，对profile数据进行了优化处理。</p>
<p>Pyroscope server负责接收(或者拉取，下面我们主要演示推的方式)agent上传的profile数据，并提供时间线界面，可以查看一段时间以内的profile数据。比如下图演示了一个<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>微服务程序12个小时的profile数据。</p>
<p><img src="1.png" alt="image-20220127133952215"></p>
<p>它既可以显示这一段时间内的火焰图，也可以显示排序表格展示，或者同时显示。这个火焰图可以看出耗时主要在微服务的方法调用和编解码上(除了Go运行时调度)。</p>
<p>你还可以选取不同的时间段进行比较, 左右的图形的时间只需在时间线上拖拽选取即可。</p>
<p><img src="2.png" alt="image-20220127134555179"></p>
<p>还可以进行diff查看，这个常常用在内存泄露的分析上。</p>
<p><img src="3.png" alt="image-20220127135630155"></p>
<h2 id="Pyroscope_server安装">Pyroscope server安装</h2>
<p>Pyroscope server端可以通过docker安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -p <span class="number">4040</span>:<span class="number">4040</span> pyroscope/pyroscope:latest server</div></pre></td></tr></table></figure>

<p>也可以在各中操作系统中直接安装。</p>
<p>比如Mac:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install pyroscope-io/brew/pyroscope</div><div class="line">brew services start pyroscope-server</div></pre></td></tr></table></figure>

<p>各Liunx发行版也方便安装，比如Cebtos:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://dl.pyroscope.io/release/pyroscope-<span class="number">0.8</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.rpm</div><div class="line"><span class="built_in">sudo</span> yum localinstall pyroscope-<span class="number">0.8</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.rpm</div><div class="line"><span class="built_in">sudo</span> systemctl start pyroscope-server</div><div class="line"><span class="built_in">sudo</span> systemctl enable pyroscope-server</div></pre></td></tr></table></figure>

<p>比如ubuntu:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://dl.pyroscope.io/release/pyroscope_0.<span class="number">8.0</span>_amd64.deb</div><div class="line"><span class="built_in">sudo</span> apt-get install ./pyroscope_0.<span class="number">8.0</span>_amd64.deb</div></pre></td></tr></table></figure>

<p>安装完成后，就可以通过web界面访问了: <a href="http://localhost:4040" target="_blank" rel="external">http://localhost:4040</a>, 你可以通过配置文件更改监听端口以及其它一些配置项。</p>
<h2 id="客户端集成">客户端集成</h2>
<p>上面已经提到，Pyroscope提供了好几种语言的agent sdk, 我们以Go  Push方式为例。在你需要持续分析的应用程序的开始加入agent的配置:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">pyroscope.Start(pyroscope.Config{</div><div class="line">    ApplicationName: <span class="string">"simple.golang.app"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// replace this with the address of pyroscope server</span></div><div class="line">    ServerAddress:   <span class="string">"http://pyroscope-server:4040"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// you can disable logging by setting this to nil</span></div><div class="line">    Logger:          pyroscope.StandardLogger,</div><div class="line"></div><div class="line">    <span class="comment">// by default all profilers are enabled,</span></div><div class="line">    <span class="comment">// but you can select the ones you want to use:</span></div><div class="line">    ProfileTypes: []pyroscope.ProfileType{</div><div class="line">      pyroscope.ProfileCPU,</div><div class="line">      pyroscope.ProfileAllocObjects,</div><div class="line">      pyroscope.ProfileAllocSpace,</div><div class="line">      pyroscope.ProfileInuseObjects,</div><div class="line">      pyroscope.ProfileInuseSpace,</div><div class="line">    },</div><div class="line">  })</div></pre></td></tr></table></figure>

<p>主要配置ApplicationName的名称，这个名称会显示在Pyroscope的服务端下拉框中。profile数据要发送到哪一个Pyroscope服务器上，你可以配置ServerAddress,以及通过ProfileTypes监控要监控的Profile项。</p>
<p>只需加上这几行启动程序后，你就可以在Pyroscope server的web界面上查看持续分析的数据了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开发人员常常需要跟踪生产环境中的应用程序的性能瓶颈，并试图找出造成瓶颈的根本原因。要做到这一点，他们通常会通过日志来收集这些信息。不幸的是，这种方法可能会很耗时，而且无法提供有关潜在问题的足够详细的信息。</p>
<p>一种现代且更先进的方法是应用和使用profiling技术和工具，突出显示最慢的应用程序代码和消耗大部分资源（如CPU和内存）的方法。持续分析(Continuous profiling)是在生产环境中持续    收集应用程序性能数据，并将这些数据提供给开发人员进行深入分析的过程。</p>
<p>通过，我们通过采集程序的指标，生成一个概要文件(Profile)进行单次的分析。Go语言提供了pprof工具，可以很方便的生成profile文件。你可以通过程序调用<a href="https://pkg.go.dev/runtime/pprof" target="_blank" rel="external">runtime/pprof</a>生成CPU、Heap等概要文件，也可以使用<a href="https://pkg.go.dev/net/http/pprof" target="_blank" rel="external">net/http/pprof</a>集成到web应用程序中，通过go tool pprof工具在命令行或者web页面中进行分析。</p>
<p>有时候，我们不能及时的进行pprof分析，故障可能消失了或者程序已经crash了。另外我们可能需要不同时段的profile进行对比，进行比较才能发现问题，比如内存泄露的问题。这个时候持续分析(continuous profiling)就很重要了。很多云服务厂商都提供持续分析的功能，比如<a href="https://www.datadoghq.com/dg/apm/ts/profiler/go-continuous-profiler-ts/?utm_source=advertisement&amp;utm_medium=search&amp;utm_campaign=dg-google-profiler-emea-goprofiling-tshirt&amp;utm_keyword=%2Bgo %2Bprofiling&amp;utm_matchtype=b&amp;utm_campaignid=15426873343&amp;utm_adgroupid=128217964697&amp;gclid=Cj0KCQiA_8OPBhDtARIsAKQu0gYymyElbglw_I7uZJkZ7ynxfzn1nVojVZJ9rkm_6_hbchG09w4CCmEaAkWfEALw_wcB" target="_blank" rel="external">Go Continuous Profiler | Datadog</a>、<a href="https://cloud.google.com/profiler/docs" target="_blank" rel="external">Cloud Profiler | Google Cloud</a>、<a href="https://aws.amazon.com/cn/codeguru/features/" target="_blank" rel="external">Amazon CodeGuru Profiler</a>等。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试官提问三个Go接口的概念， 10年gopher竟无言以对]]></title>
    <link href="https://colobu.com/2022/01/16/three-new-concepts-of-go-interface-since-1-18/"/>
    <id>https://colobu.com/2022/01/16/three-new-concepts-of-go-interface-since-1-18/</id>
    <published>2022-01-16T11:44:58.000Z</published>
    <updated>2022-01-16T14:00:52.957Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.18后， Go的interface的含义有所<a href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/" target="_blank" rel="external">变化</a>, 三个新的和Go接口有关的概念很多人还不知道: <code>type set</code>(类型集合)、<code>specific type</code>(特定类型)和<code>structural type</code>(结构类型)。</p>
<a id="more"></a>
<h2 id="type_set_(类型集合)">type set (类型集合)</h2>
<p>type set称之为类型集合，一些关注Go泛型的朋友其实也对此有些了解，它是Go 1.18新增加的一个概念。</p>
<p>Go 1.18之前，Go的接口代表了一组方法的集合(method set),凡是实现了这些方法集合的类型，都被称之为实现了这个接口。Go不像Java语言，需要显示地定义某个类实现某个接口，Go不需要这样，在Go中，只要一个类型实现了某个接口定义的所有方法，它就实现了这个接口，可以赋值给这个接口类型的变量，或者作为这个接口类型的方法的实参或者返回值，这种设计有时候也被叫做<code>鸭子类型</code>(duck typing)。只要它走起来像鸭子，叫起来像鸭子，那么它就是鸭子，这是一个很经典的对鸭子类型的描述。</p>
<p>在Go 1.18中，接口不再代表方法的集合了，而是代表类型的集合(type set)。只要某种类型在这个接口的类型集合中，那么我们就说这种类型实现了这个接口。如果这个接口被用作类型约束，那么在这个接口定义的类型集合中的任意一个元素，都可以实例化这个类型参数。</p>
<p>所以，实际上，为了支持接口作为类型约束的扩展，Go语言规范不得不重新定义接口的含义了，这也是类型集合出现的原因。</p>
<p>其实，接口的方法集的概念还在 一个接口的方法集是这个接口的类型集合中所有元素的方法集的<strong>交集</strong>。</p>
<p>r本文假定你对Go泛型有了一定的了解。假定你还不了解，那么你必须知道，Go 1.18中接口除了原先的方法元素还，还支持包含类型元素，类型元素可以是某个类型<code>T</code>、或者是近似类型<code>~T</code>,或者是它们的联合<code>int|int8|int16|int32|int64|~string</code>。</p>
<p>如果一个接口<code>I</code>嵌入了另外一个接口<code>E</code>,那么<code>I</code>的类型集是它显示定义的类型集合和嵌入的接口<code>E</code>的类型集合的交集。相当于<code>E</code>把接口<code>I</code>的类型集收窄了。</p>
<p>如何判断一个接口的类型集呢？请遵循下面的原则:</p>
<ul>
<li><p>空接口<code>any</code>、<code>interface{}</code>的类型集是所有类型的集合<br>所以像<code>int</code>、<code>string</code>、<code>strcut{}</code>、<code>MyStruct</code>、<code>func foobar()</code>、<code>chan int</code>、<code>map[int]string</code>、<code>[]int</code>等等都在空接口的类型集合中</p>
</li>
<li><p>非空接口的类型集合是接口元素的类型集合的交集<br>那么什么是接口元素的类型集合呢？参照下面的四条。<br>前面我们已经提到，接口元素包含类型元素和方法元素。</p>
<ul>
<li><p>一个方法的类型集合是定义这个方法的所有类型，也就是只要某个类型的方法集包含这个方法，那么它就属于这个方法的类型集合<br>比如接口中有<code>String() string</code>这样一个方法，那么所有实现这个方法的类型都属于<code>String() string</code>定义的类型集合，比如<code>net.IP</code>。</p>
</li>
<li><p>一个非接口类型的类型集合就是只包含这个类型的类型集合<br>比如<code>int</code>的类型集合只包含<code>int</code>这样一个元素。</p>
</li>
<li><p>近似元素<code>~T</code>的类型集合是所有底层类型为<code>T</code>的所有类型的集合</p>
</li>
</ul>
<p>比如<code>type MyInt int</code>中的<code>MyInt</code>就属于<code>~int</code>的类型集合</p>
<ul>
<li>联合元素<code>t1|t2|…|tn</code>的类型集合是这些联合元素类型集合的<strong>并集</strong></li>
</ul>
</li>
</ul>
<p>下面的例子列举了一些类型的集合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个集合的类型集合只有int这一种类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口代表所有底层为int类型的所有类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口代表底层为int，并且实现了String方法的所有类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">	String() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口的类型集合是空集，因为不可能一个元素既是int又是string类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">	<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Floats代表所有底层是浮点数的类型 (底层为float32或者float64)</span></div><div class="line"><span class="keyword">type</span> Floats <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">float32</span> | ~<span class="typename">float64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="specific_type_(特定类型)_和_specific_type_set">specific type (特定类型) 和 specific type set</h2>
<p>接口另外一个很重要的概念就是<code>specific type</code> (特定类型)。</p>
<p>只有包含类型元素的接口才定义了特定类型(可能是空的类型)。</p>
<p>如果不严格的讲，特定类型是出现在类型元素中定义的那些类型<code>T</code>、<code>~T</code>、<code>t1|t2|...|tn</code>中的<code>t1</code>、<code>t2</code>、<code>...</code>、<code>tn</code>。</p>
<p>更准确地说，对于给定的接口<code>I</code>，特定类型的集合对应于该接口代表的类型集合<strong>𝑅</strong>，这里要求<strong>𝑅</strong>是非空且有限的。否则，如果<strong>𝑅</strong>为空或无限，则接口没有特定类型。</p>
<p>对于一个给定的接口、类型元素或者类型，它代表的类型集合<strong>𝑅</strong>定义如下：</p>
<ul>
<li><p>对于一个没有任何类型元素的接口，它的<strong>𝑅</strong>是所有的元素(无限)。<br>所以它没有特定类型。</p>
</li>
<li><p>如果一个接口有类型元素，它的<strong>𝑅</strong>是它的元素代表的类型的交集<br>至于有没有特定类型要看<strong>𝑅</strong>是否是非空且有限。</p>
</li>
<li><p>对于一个非接口类型<code>T</code>,或者<code>~T</code>, 它的<strong>𝑅</strong>是包含类型<code>T</code>的集合</p>
</li>
<li><p>对于联合元素<code>t1|t2|…|tn</code>, 它的<strong>𝑅</strong>是这些项代表类型的<strong>并集</strong></p>
</li>
</ul>
<p>下面是特定类型的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Celsius <span class="typename">float32</span></div><div class="line"><span class="keyword">type</span> Kelvin  <span class="typename">float32</span></div><div class="line"></div><div class="line"><span class="keyword">interface</span>{}                    <span class="comment">// 无限，所以没有特定类型</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span> }               <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="typename">string</span> }           <span class="comment">// 特定类型是string</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>|~<span class="typename">string</span> }       <span class="comment">// 特定类型是int, string</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|Kelvin }    <span class="comment">// 特定类型是Celsius, Kelvin</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">float64</span>|any }       <span class="comment">// 没有特定类型，因为联合类型的代表类型是无限的</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; m() }          <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="typename">int</span>; m() }         <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; any }          <span class="comment">// 特定类型是int，int和any的交集</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; <span class="typename">string</span> }       <span class="comment">// 没有特定类型</span></div></pre></td></tr></table></figure>

<h2 id="type_set_vs_specific_type_set">type set vs specific type set</h2>
<p>类型集合和特定类型集合还是有区别的，从上面它们的定义可以看出来。</p>
<p><strong>一个接口即使类型为空，它的特定类型集合可能不为空。</strong><br>比如<code>interface{ int; m() }</code>,它的类型集合是空的(int没有实现m方法)，但是它的特定类型是<code>int</code>。</p>
<p><strong>一个接口即使有有限的特定类型，它的类型集合也可能是无限的</strong><br>比如<code>interface{ ~int; m() }</code>,它的特定类型是int，但是它的类型集合确是无限的(任何底层为int并且实现了方法m的类型都属于它的类型集合)</p>
<p>那么定义特定类型有什么用呢？</p>
<h2 id="特定类型的应用">特定类型的应用</h2>
<p>特定类型主要用于判断类型参数是否支持索引, 像<code>a[x]</code>这样的类型。</p>
<p>比如一个表达式<code>a[x]</code>, <code>a</code>这个实例的类型可能是数组、指向数组的指针、slice、字符串、map。</p>
<p>如果<code>a</code>的类型是类型参数<code>P</code>的话，那么我们的代码<code>a[x]</code>在什么条件下才不会编译出错？</p>
<p>要求的条件就和特定类型有关了：</p>
<ul>
<li>P必须有特定类型</li>
<li>对于P的特定类型的值a，支持<code>a[x]</code>这种索引写法</li>
<li>P的所有特定类型必须相同。在这里，string类型的元素类型是byte (<a href="https://github.com/golang/go/issues/49551" target="_blank" rel="external">https://github.com/golang/go/issues/49551</a>)</li>
<li>如果P的特定类型包含map类型的话，那么它的所有特定类型必须是map,而且所有的key的类型是相同的<br>所以有时候你定义了一个包含map、slice、string的联合元素接口的话，这个接口的实例你不能使用<code>a[x]</code>索引类型，元素的类型都是int</li>
<li><code>a[x]</code>是数组、slice、string的索引为x的元素，或者是map类型key为x的元素，a[x]的类型必须相同</li>
<li>如果P的特定类型包含string类型，那么不能给<code>a[x]</code>赋值(字符串是不可变的)</li>
</ul>
<p>特定类型还用作类型转化定义上。<br>对于一个变量<code>x</code>,如果它的类型是<code>V</code>, 要转换成的类型是<code>T</code>, 只要满足下面一条，x就可以转换成<code>T</code>类型:</p>
<ul>
<li><code>V</code>的每一个特定类型的值都可以转换成<code>T</code>的每一个特定类型</li>
<li>只有<code>V</code>是类型参数，<code>T</code>不是，那么<code>V</code>的每一个特定类型的值都可以转换成<code>T</code></li>
<li>只有<code>T</code>是类型参数，<code>x</code>可以转换成T的每一个特定类型</li>
</ul>
<p>一句话，是类型参数就满足每一个特定类型，不是类型参数就满足这个类型。</p>
<p>另外，对于类型参数，要调用内建的函数<code>len</code>、<code>cap</code>，必须要求它们的特定类型允许使用这些内建函数。</p>
<h2 id="structural_type_(结构类型)">structural type (结构类型)</h2>
<p>一个接口<code>T</code>要被成为结构化的(<code>structural</code>),需要满足下面的条件之一:</p>
<ol>
<li>存在一个单一的类型<code>U</code>,它是<code>T</code>的类型集合中的每一个元素相同的底层类型</li>
<li><code>T</code>的类型集合只包含chan类型，并且它们的元素类型都是<code>E</code>, 所有的chan的方向包含相同的方向(不一定要求完全相同)</li>
</ol>
<p>结构化类型包含一个结构类型，根据上面的条件不同，结构类型可能是:</p>
<ol>
<li>类型<code>U</code>, 或者</li>
<li>如果<code>T</code>只包含双向chan的话，结构类型为<code>chan E</code>,否则可能是<code>chan&lt;- E</code>或者<code>&lt;-chan E</code></li>
</ol>
<p>下面是包含结构类型的结构化接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span> }                          <span class="comment">// 结构类型为 int</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|Kelvin }               <span class="comment">// 结构类型为 float32</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="keyword">chan</span> <span class="typename">int</span> }                    <span class="comment">// 结构类型为 chan int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="keyword">chan</span> <span class="typename">int</span>|~<span class="keyword">chan</span>&lt;- <span class="typename">int</span> }        <span class="comment">// 结构类型为 chan&lt;- int</span></div><div class="line"><span class="keyword">interface</span>{ ~[]*data; String() <span class="typename">string</span> }    <span class="comment">// 结构类型为 *data</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的例子不包含结构类型，所以是非结构化接口</span></div><div class="line"><span class="keyword">interface</span>{}                               <span class="comment">// 没有固定单一的底层类型</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|<span class="typename">float64</span> }              <span class="comment">// 底层类型不相同</span></div><div class="line"><span class="keyword">interface</span>{ <span class="keyword">chan</span> <span class="typename">int</span> | <span class="keyword">chan</span>&lt;- <span class="typename">string</span> }     <span class="comment">// channel的元素类型不相同</span></div><div class="line"><span class="keyword">interface</span>{ &lt;-<span class="keyword">chan</span> <span class="typename">int</span> | <span class="keyword">chan</span>&lt;- <span class="typename">int</span> }      <span class="comment">// channel没有相同的方向</span></div></pre></td></tr></table></figure>

<p>在Go语言规范中，并没有对结构化接口有更多的介绍，如何使用，更多是是它内部获取底层的结构类型，以及做类型检查，比如下面的例子就会报<code>no structural type</code>编译错误:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> myByte1 []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | []<span class="typename">int</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j:k] <span class="comment">// 底层类型不一致</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | []<span class="typename">int</span> | <span class="typename">string</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j] </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面这个函数没问题，因为string的底层页被看做[]byte</span></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | myByte2 | <span class="typename">string</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j] </div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的代码也会报<code>M has no structural type</code>编译错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> multiMapOfInt <span class="keyword">interface</span> {</div><div class="line">	<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">float64</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">complex64</span>]<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> arraySummer[M multiMapOfInt](mp M) (sum <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> mp {</div><div class="line">		sum += v</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如下面大家使用Go泛型的时候常会犯的错误,虽然<code>[]byte</code>、<code>map[int]byte</code>、<code>string</code>都能range,而且key(index)、value类型都一样，但是也会报<code>R has no structural type</code>错误:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> rangeType <span class="keyword">interface</span> {</div><div class="line">	[]<span class="typename">byte</span> | <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">byte</span> | <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> rangeIt[R rangeType](r R) {</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> r {</div><div class="line">		fmt.Println(i, v)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	rangeIt(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">byte</span><span class="number">{1</span>:<span class="number"> 1</span>,<span class="number"> 2</span>:<span class="number"> 2</span>,<span class="number"> 3</span>:<span class="number"> 3</span>})</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.18后， Go的interface的含义有所<a href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/" target="_blank" rel="external">变化</a>, 三个新的和Go接口有关的概念很多人还不知道: <code>type set</code>(类型集合)、<code>specific type</code>(特定类型)和<code>structural type</code>(结构类型)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写可维护的Go代码]]></title>
    <link href="https://colobu.com/2022/01/15/Writing-maintainable-Go-code/"/>
    <id>https://colobu.com/2022/01/15/Writing-maintainable-Go-code/</id>
    <published>2022-01-15T04:54:58.000Z</published>
    <updated>2022-02-24T09:36:34.503Z</updated>
    <content type="html"><![CDATA[<p>编写可维护的代码是最基本的要求。清晰度、可读性和简单性都是保持代码可维护性的各个方面。它应该使某人加入您的项目或在有人离开后维护代码的过程变得容易。可维护性的衡量指标是代码更改的容易程度以及与这些更改引起的风险性。为了有效地编写Go程序，了解Go语言的属性和地道写法，并使用与命名、程序构建、格式等相关既定约定是至关重要。</p>
<p>以下是一些有助于编写可维护的Go代码的良好实践。</p>
<p>原文: <a href="https://jogendra.dev/writing-maintainable-go-code" target="_blank" rel="external">Writing maintainable Go code</a> by Jogendra.</p>
<a id="more"></a>
<p>保持小巧的<code>main</code>函数</p>
<p>&quot;<a href="https://go.dev/tour/basics/1" target="_blank" rel="external">Go之旅</a>&quot;中讲到：</p>
<blockquote>
<p>每个 Go 程序都由包组成。程序在包 <code>main</code> 中开会运行。</p>
</blockquote>
<p>包<strong>main</strong>是唯一的，那些导出名称(<code>exported name</code>)既不会导出，编译器也不会将其视为常规包; 相反，它将其编译为可执行程序。在包<strong>main</strong>中，<strong>main</strong>函数必须存在，它是 Go 程序的入口点。对软件包<code>main</code>和函数<code>main</code>的期望是它们尽可能少。</p>
<p><strong>main.main</strong>是单例的，仅被调用一次。你为它内部的代码编写测试也很困难，因此，强烈建议使用<em>main.main</em>仅仅启动程序，但不要在此包中编写业务逻辑。将启动程序和业务逻辑分别写在单独的包中可改进程序的结构和可维护性。</p>
<h2 id="使用有意义的名称">使用有意义的名称</h2>
<p>在 Go 中命名主要强调一致、简短和准确的名称，因为它们往往会提高代码的可读性。</p>
<p>Russ Cox的命名<a href="https://research.swtch.com/names" target="_blank" rel="external">理念</a>：</p>
<blockquote>
<p>一个名称的长度不应超过它的信息内容。对于一个局部变量，名称<code>i</code>和<code>index</code>或者<code>idx</code>携带同样的信息，而且更方便快速阅读。类似地，<code>i</code>和<code>j</code>这一对命名比索引变量<code>i1</code>和<code>i2</code>更好(更差的是<code>index1</code>和<code>index2</code>),在阅读代码的时候它们更容易区分。全局名称必须传达相对更多的信息，因为它们出现在更广泛的上下文中。即便如此，一个简短、准确的名字比冗长的名字更能说明问题：比较<a href="http://www.google.com/codesearch?q=acquire" target="_blank" rel="external"><code>acquire</code></a>和<a href="http://www.google.com/codesearch?q=take_?ownership" target="_blank" rel="external"><code>take_ownership</code></a>。让每个命名都能<a href="http://www.bartleby.com/141/strunk5.html#13" target="_blank" rel="external">区分</a>。</p>
</blockquote>
<p>Ken Thompson，Rob Pike，Robert Griesemer，Russ Cox，Ian Lance Taylor等人多年的编程经验和命名理念很可能激发了Go中的命名约定。<a href="https://talks.golang.org/2014/names.slide" target="_blank" rel="external">这是</a>安德鲁·格兰德（Andrew Gerrand）的一张幻灯片，其更深入地讨论了Go中的命名。</p>
<h2 id="代码分组">代码分组</h2>
<p>在函数（或方法）中，某些语句可能有关联。因此，建议将这些语句保留在单独的代码块中，用换行符分隔。分组使程序构造更好，并通过分隔相关部分来提高可读性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Creating new HTTP request with request body</span></div><div class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"https://api.example.com/endpoint"</span>, body)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// handle err</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Setting headers to HTTP request</span></div><div class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">req.Header.Set(<span class="string">"Authorization"</span>, <span class="string">"Bearer b7d03a6947b217efb6f3ec3bd3504582"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Executing the request</span></div><div class="line">resp, err := http.DefaultClient.Do(req)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// handle err</span></div><div class="line">}</div><div class="line"><span class="keyword">defer</span> resp.Body.Close()</div></pre></td></tr></table></figure>

<h2 id="撰写有意义的注释">撰写有意义的注释</h2>
<p>注释是理解现有代码的绝佳方式，它可以回答这段代码的作用，为什么会存在某些代码段以及为什么它是这样编写的。最好在编写代码时就编写注释，但更重要的是在更新代码时更新注释。代码更新可能会改变特定代码的实现目的，因此更新注释也至关重要的; 否则，它将造成困惑而不是在以后有所帮助。与其编写与代码相矛盾的注释还不如不写代码注释。您可以在 Go 中编写块注释或内联注释，你可以选择任何更适合您的代码的内容。</p>
<p>您使用该工具做检查在 Go 中你是否正确编写注释代码。<a href="https://blog.golang.org/godoc" target="_blank" rel="external">godoc</a>将从您的代码中提取注释，并为您的 Go 程序生成文档。Go 中的注释有几个不错的功能，请参阅<a href="https://blog.jbowen.dev/2019/09/the-magic-of-go-comments/" target="_blank" rel="external">Go代码注释的魔法</a>以详细了解。<code></code></p>
<p>知道不必写注释与知道应该写注释一样重要。最好避免过度注释代码，并将其留给其他程序员来理解Go。您应该避显而易见的注释，如果代码的可读性足够高，则不需要注释。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get country code from customer address.</span></div><div class="line">    countryCode := getCountryCode(address)</div><div class="line"></div><div class="line">    <span class="comment">// If country code is "IN", assign "India" as</span></div><div class="line">    <span class="comment">// country.</span></div><div class="line">    <span class="keyword">if</span> countryCode == <span class="string">"IN"</span> {</div><div class="line">        country = <span class="string">"India"</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里写的注释没啥意义，不会增加任何价值。</p>
<h2 id="不要重复">不要重复</h2>
<p>DRY（不要重复自己）是软件开发的一个原则，旨在减少软件模式的重复，用抽象代替它以避免冗余。</p>
<p>那么，代码重复又有什么问题呢？在有变更之前，没有太多问题。想象一下，在10个地方重复相同的代码，每当有小的变化时都要在所有10个地方做改变。如果代码仅存在于一个位置，则更容易维护代码，从而确保一致性。如果代码重复，您很有可能忘记更新其中一个副本，这意味着您在一个副本中修复的错误仍将存在于另一个副本中。</p>
<p>如果必须再次编写相同的代码，可以其移动到大多数<code>helper</code>函数所在的共享package中。通过删除重复的代码，您将拥有更少的代码，这些代码将更清晰，更易于维护。</p>
<p>缺少泛型（Go 1.17以及先前版本）可能会使 Go 代码在某些地方看起来重复。但是，随着Go 1.18正式支持泛型，将使编写通用代码变得更加简单，冗余更少，并且更易于维护。</p>
<p>但是，有时重复代码比试图强制抽象以免冗余会更简单，更容易理解。因此，更重要的是要知道在哪里应用 DRY，在哪里不应用 DRY，因为代码的可读性和易懂性胜过其他问题。</p>
<h2 id="Linting和样式指南">Linting和样式指南</h2>
<p>遵守编码标准使代码库保持一致，易于代码审查和维护。它使编码风格一致。通常，风格指南是有争议的，为了让人们遵守相同指南的最佳方法是为Go代码创建一个标准的风格指南。拥有风格指南不是最重要的，最重要的是让你的团队真正地使用它。市面上有许多开源的 linting 工具和样式指南，你可以从以此为基础并对其进行修改，使其适合你。</p>
<p>Go有一个在社区中普遍使用和接受的代码格式标准，尽管它不需要特殊的规则。Go 提供了这个<code>fmt</code>工具，鼓励和保护 Go 代码使用既定约定进行格式化。</p>
<p>许多编辑器支持在保存文件时调用文件格式化工具。或者，像 <a href="https://github.com/mvdan/gofumpt" target="_blank" rel="external">gofumpt</a>工具，提供更严格的格式化版本。该工具是 <code>gofmt</code>的修改分支，可用作<code>gofmt</code>原地替换。此外，这些工具还支持自定义源代码转换和添加自定义的规则。</p>
<p>如果您想遵循Go的社区风格指南，可以使用<a href="https://github.com/golang/lint" target="_blank" rel="external">golint</a>。该工具提供了有关代码样式的有用提示，还可以帮助查看Go的公认约定。这将极大地帮助加入项目的每个新开发人员。</p>
<h2 id="避免深度嵌套">避免深度嵌套</h2>
<p>过度的嵌套困扰着每个人。深度嵌套使得代码很难遵循设计逻辑。如果您正在执行代码审查或重新访问旧代码，具有大量嵌套的超大函数（或方法）会造成逻辑的混乱。此外，嵌套代码难以阅读; 嵌套越小，读者的认知负荷就越小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition1 {</div><div class="line">    <span class="keyword">if</span> condition2 {</div><div class="line">        <span class="keyword">if</span> condition3 {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> condition5 {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>开发人员可以通过多种方式避免这种情况。<a href="https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting" target="_blank" rel="external">这里是</a>一个很好的阅读材料。</p>
<h2 id="编写更好的函数">编写更好的函数</h2>
<p>避免编写较长的函数;函数越小越好。较长的函数可能难以读取、测试和维护。较长的函数通常具有较大的职责，因此建议将它们分解为较小的函数。通过分解较长的函数创建的较短的函数，可以服务更多的调用方。因为它们可以提供可管理的独立任务。</p>
<p>Unix管道的发明者、Unix的创始人之一道格·麦克罗伊（Doug McIlroy）说（Unix Philosophy）：</p>
<blockquote>
<p>让每个程序都做好一件事。要完成一项新工作，请重新构建，而不是通过添加新功能使旧程序复杂化。</p>
</blockquote>
<p>因此，分解函数以做好一件事确实与Unix哲学英雄相惜。</p>
<p>如前所述，命名对于可读性至关重要。好的函数名称比注释更好，它们与编写良好的注释或 API 文档一样有助于理解代码。尽量保留较少的功能参数。</p>
<h2 id="避免包(package)级别状态">避免包(package)级别状态</h2>
<p>在 Go 中，对于任何给定的导入路径，包的实例都是唯一一个(单例)。这意味着在包级别上，任何变量只有一个实例。包级别的变量在全局级别共享，这意味着所有访问者将共享同一个实例。函数<code>X</code>可以修改变量，函数<code>Y</code>可以读取修改后的值。</p>
<p>使用包级别的变量可能会产生许多影响：</p>
<ol>
<li>很难跟踪变量的修改位置以及跟踪访问变量的位置以做出任何决定。</li>
<li>包级变量导致紧密耦合; 一个角落的代码修改可能需要修改代码的另一个角落，这使得阅读、修改和单元测试代码变得更加困难。</li>
<li>它可能会导致争用条件等问题。</li>
</ol>
<p>但是，包级别常量的使用非常有用。因此，始终建议尽可能避免使用包级别状态(译者注: 可修改的变量)。若要减少耦合，请将相关变量移到所需的结构体的字段上。在结构体中定义依赖项和配置使其变得容易。接口的使用也非常有帮助。</p>
<h2 id="尽早返回并明智地使用条件">尽早返回并明智地使用条件</h2>
<p>条件语句是我们必须经常写的东西。它在代码是干净还是混乱方面发挥着重要作用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此代码的问题在于<code>else</code>语句在此处没有帮助;相反，它使代码变得混乱且可读性降低。相反，把它写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>译者注， 把它写成下面的方式更简洁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">return</span> n &lt;=<span class="number"> 12</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也经常会看到整个函数体都包在<code>if</code>语句里面,这也是不好的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        sum()</div><div class="line">        subtract()</div><div class="line">        multiply()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以翻转判断条件使代码更简洁可读:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) {</div><div class="line">    <span class="keyword">if</span> n &lt;=<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    sum()</div><div class="line">    subtract()</div><div class="line">    multiply()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="更经常的使用switch">更经常的使用<code>switch</code></h2>
<p><strong>switch</strong>语句是缩短 if-else 语句序列的最佳方式，有益于编写干净的程序。程序经常需要做比较判断，如果我们的程序使用了太多的<code>if-else</code>，会使代码凌乱且可读性较差。所以使用switch有很大帮助。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> transact(bank <span class="typename">string</span>) {</div><div class="line">    <span class="keyword">if</span> bank == <span class="string">"Citi"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #1: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"StandardChartered"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #2: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"HSBC"</span> || bank == <span class="string">"Deutsche"</span> || bank == <span class="string">"JPMorgan"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #3: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"NatWest"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #4: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #E: %s\n"</span>, bank)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这看起来很乱，对吧？现在让我们改用一个switch。以下代码如何以惯用方式重写相同的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> transact(bank <span class="typename">string</span>) {</div><div class="line">    <span class="keyword">switch</span> bank {</div><div class="line">    <span class="keyword">case</span> <span class="string">"Citi"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #1: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"StandardChartered"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #2: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"HSBC"</span>, <span class="string">"Deutsche"</span>, <span class="string">"JPMorgan"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #3: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"NatWest"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #4: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #E: %s\n"</span>, bank)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将来，如果添加新的银行，使用<code>switch-case</code>将更容易，更干净。</p>
<h2 id="持续的代码重构">持续的代码重构</h2>
<p>在大型代码库中，重构代码库结构至关重要。代码重构不时地提高代码的可读性和质量。这不是一次性的过程；团队应持续支付技术债务，以保持代码库正常。我曾学过“尽早重构，经常重构”（<code>refactor early, refactor often</code>），这对于编写可维护的Go代码非常有意义。随着时间的推移，包的代码数量和责任会变得越来越重，因此最好将一些包分解成更小的包，因为它们易于维护。重构包的另一个好理由是改进命名。包只包含与其功能相关的代码也是至关重要的。例如，Go把<code>os.SEEK_SET</code>、<code>os.SEEK_CUR</code>和 <code>os.SEEK_END</code>移动到<code>io.SeekStart</code>、<code>io.SeekCurrent</code>和 <code>io.SeekEnd</code>。包<code>io</code>更适合于组织涉及文件I/O的代码。将包分解成小的包也会使依赖关系变得轻量级。</p>
<h2 id="结论">结论</h2>
<p>随着时间和其他程序员在代码库上工作，我们更好地理解可维护性意味着什么。 编写可维护的代码并不复杂； 它需要每个贡献代码的人的知识、经验和仔细思考。 我们讨论的一组良好实践应该可以帮助您和团队更好地维护您的 Go 代码。</p>
<blockquote>
<p>原文 <a href="https://deepsource.io/learn/software-engineering-guide/writing-maintainable-go-code/" target="_blank" rel="external">Writing maintainable Go code - DeepSource Learn</a> by Jogendra</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写可维护的代码是最基本的要求。清晰度、可读性和简单性都是保持代码可维护性的各个方面。它应该使某人加入您的项目或在有人离开后维护代码的过程变得容易。可维护性的衡量指标是代码更改的容易程度以及与这些更改引起的风险性。为了有效地编写Go程序，了解Go语言的属性和地道写法，并使用与命名、程序构建、格式等相关既定约定是至关重要。</p>
<p>以下是一些有助于编写可维护的Go代码的良好实践。</p>
<p>原文: <a href="https://jogendra.dev/writing-maintainable-go-code" target="_blank" rel="external">Writing maintainable Go code</a> by Jogendra.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型编程: 支持特例化?]]></title>
    <link href="https://colobu.com/2022/01/11/go-generic-supports-specialization-no/"/>
    <id>https://colobu.com/2022/01/11/go-generic-supports-specialization-no/</id>
    <published>2022-01-11T00:14:53.000Z</published>
    <updated>2022-01-16T11:25:05.338Z</updated>
    <content type="html"><![CDATA[<p>一些编程语言如C++、Rust都是支持泛型特例化的，Go泛型支持吗？</p>
<a id="more"></a>
<p>所谓特例化(specialization)对泛型功能代码的扩展。比如对于泛型的函数，它的实现对于满足泛型参数的所有类型(type set)都是一样的，如果我们想对这些类型集(type set)中的一个，它的函数做特殊的实现，一些支持泛型特例化的语言是可以支持的，比如C++ template:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> fun(T a)</div><div class="line">{</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"template fun(): "</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;   <span class="comment">// 对int型特例化</span></div><div class="line"><span class="keyword">void</span> fun(<span class="keyword">int</span> a)</div><div class="line">{</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"specialized template fun for int type: "</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>fun</code>是一个函数模板,但是针对<code>int</code>类型，此函数有特殊的实现。</p>
<p>Rust也有类似的功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#![feature(min_specialization)]</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> Special</div><div class="line">{</div><div class="line">    x : usize,</div><div class="line">    y : usize</div><div class="line">}</div><div class="line"></div><div class="line">trait MyTrait</div><div class="line">{</div><div class="line">    fn myfunc(&self);</div><div class="line">}</div><div class="line"></div><div class="line">impl&lt;T&gt; MyTrait <span class="keyword">for</span> T</div><div class="line">{</div><div class="line">    <span class="keyword">default</span> fn myfunc(&self) { println!(<span class="string">"hi"</span>); }</div><div class="line">}</div><div class="line"></div><div class="line">impl MyTrait <span class="keyword">for</span> Special</div><div class="line">{</div><div class="line">    fn myfunc(&self) { println!(<span class="string">"I'm special"</span>); }</div><div class="line">}</div><div class="line"></div><div class="line">fn main() {</div><div class="line">    let spe = Special{</div><div class="line">        x: <span class="number">1</span>,</div><div class="line">        y: <span class="number">2</span>,</div><div class="line">    };</div><div class="line">    spe.myfunc();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>MyTrait</code>针对通用类型<code>T</code>有一个默认实现，但是针对特定的类型<code>Special</code>,有一个特定的实现。</p>
<p>其它编程语言当前还不支持特例化，但是可以通过方法重载实现类似的功能，如typescript、C#等。<br>另外复杂的特例化还包括部分特例化的特性。</p>
<p>那么问题来了，Go的泛型(类型参数)是否支持特例化呢？我们先写个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> {</div><div class="line">	next  *List[T]</div><div class="line">	value T</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l *List[T]) Len() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l *List[<span class="typename">string</span>]) Length() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们定义了一个泛型类型<code>List[T any]</code>, 包括它的一个泛型方法<code>Len() int</code>，接下来我们尝试定义一个“特例化”的方法<code>Length() int</code>。</p>
<p>编译一下，没问题，程序可以正常编译，难道Go泛型真的支持特例化吗？</p>
<p>我们再增加一个特例化泛型方法试试:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (l *List[<span class="typename">int</span>]) Size() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个时候再编译试试,编译出错:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cannot <span class="operator"><span class="keyword">use</span> <span class="number">0</span> (untyped <span class="built_in">int</span> constant) <span class="keyword">as</span> <span class="built_in">int</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="keyword">return</span> statement</span></div></pre></td></tr></table></figure>

<p>其实这个错误信息已经告诉我们了，这里的<code>int</code>并不是内建的整数类型，而是一个类型参数的名称，等价于我们常用的<code>T</code>、<code>K</code>、<code>V</code>。这里我们使用<code>int</code>作为类型参数的名称很有迷惑性。</p>
<p>所以答案也是很明确的，当前Go 1.18并不支持<strong>泛型特例化</strong>, 小心别掉到坑里了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些编程语言如C++、Rust都是支持泛型特例化的，Go泛型支持吗？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型编程: interface 不再是那个interface]]></title>
    <link href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/"/>
    <id>https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/</id>
    <published>2022-01-08T13:48:20.000Z</published>
    <updated>2022-01-14T11:10:58.895Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.18 支持泛型后， Go interface 的意义已经彻彻底底的改变了，除了先前代表的方法集的意义外，还被用作泛型的类型约束(type constraint)的功能, interface已经不再是以前那个单纯的少年了。</p>
<a id="more"></a>
<p>在Go 1.17.x以及以前的版本中，interface是这样定义的：</p>
<blockquote>
<p>An interface type specifies a <strong>method set</strong> called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
<p>接口类型定义了一个方法集合，称之为接口(interface)。接口类型的变量可以存储任意的实现这个方法集合的类型，这种类型是此interface的超集。这种类型被称为实现了接口。接口类型的变量如果未初始化则它的值为nil。</p>
</blockquote>
<p>在Go 1.18中，interface定义改变了：</p>
<blockquote>
<p>An interface type defines a <strong>type set</strong>. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
<p>接口类型定义了一个类型集合。接口类型的变量可以存储这个接口类型集合的任意一种类型的实例值。这种类型被称之为实现了这个接口。接口类型的变量如果未初始化则它的值为nil。</p>
</blockquote>
<p>所以一句话，先前接口定义了方法集合，现在接口定义了类型集合。接口的用途也进行了扩展。</p>
<p>interface的定义也扩展了。先前，接口定义只能包含方法元素(method element):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> {</div><div class="line">	Read([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</div><div class="line">	Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</div><div class="line">	Close() error</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在接口定义除了方法元素外，还可以包含类型元素:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing all types with underlying type int.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing all types with underlying type int which implement the String method.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">	String() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing an empty type set: there is no type that is both an int and a string.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">	<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>类型元素包含类型(<code>T</code>)或者近似类型(<code>~T</code>)或者联合(union)元素(<code>A|B|C|~D</code>)。</p>
<p>但是，因为接口的定义和含义改变了，所以接口在使用的时候也有一些些不同。本文通过实例一一介绍。</p>
<p>首先记住一点，Go 1.17.x 及以前的版本中接口的使用方法在Go 1.18中照样使用，使用方法不变。变得是接口有类型元素或者做类型约束时的一些限制。</p>
<h3 id="近似元素的类型T必须是底层类型(underlying_type)自己，而且不能是接口类型">近似元素的类型<code>T</code>必须是底层类型(underlying type)自己，而且不能是接口类型</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误的定义!</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> I0 <span class="keyword">interface</span> {</div><div class="line">	~MyInt <span class="comment">// 错误! MyInt不是underlying type, int才是</span></div><div class="line">	~error <span class="comment">// 错误! error是接口</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素不能是类型参数(type_parameter)">联合(union)类型元素不能是类型参数(type parameter)</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误, interface{ K }中K是类型参数</span></div><div class="line"><span class="keyword">func</span> I1[K any, V <span class="keyword">interface</span>{ K }]() {</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误, interface{ nt | K }中K 是类型参数</span></div><div class="line"><span class="keyword">func</span> I2[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | K }]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素的非接口元素必须是两两不相交">联合(union)类型元素的非接口元素必须是两两不相交</h3>
<p>两两不相交意思是两两的交集是空集，比如 <code>int|string</code>的交集是空集，而<code>int|~int</code>的交集是<code>int</code>。</p>
<p>联合类型中的非接口元素必须是两两不相交的。</p>
<p>下面的定义没问题，因为any等价于<code>interface{}</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> I3[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | any }]() {</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误！ int和!int相交</span></div><div class="line"><span class="keyword">func</span> I4[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | ~<span class="typename">int</span> }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面的定义没有问题。因为int和MyInt是两个类型，不相交</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> I5[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | MyInt }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! int和~MyInt相交，交集是int</span></div><div class="line"><span class="keyword">func</span> I6[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | ~MyInt }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! int和MyInt2是相同类型，相交</span></div><div class="line"><span class="keyword">type</span> MyInt2 = <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> I7[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | MyInt2 }]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素如果包含多于一个元素，不能包含包含非空方法的接口类型，也不能是comparable或者嵌入comparable">联合(union)类型元素如果包含多于一个元素，不能包含包含非空方法的接口类型，也不能是comparable或者嵌入comparable</h3>
<p>这条规则定义了接口作为类型元素的一些限制.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译没问题，只包含一个元素</span></div><div class="line"><span class="keyword">func</span> I9[K <span class="keyword">interface</span>{ io.Reader }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误!不能编译。因为包含了两个元素，而且无论是`io.Reader`还是`io.Writer`都包含方法</span></div><div class="line"><span class="keyword">func</span> I10[K <span class="keyword">interface</span>{ io.Reader | io.Writer }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 编译正常，因为这是正常的接口，没有联合元素</span></div><div class="line"><span class="keyword">func</span> I11[K <span class="keyword">interface</span> {</div><div class="line">	io.Reader</div><div class="line">	io.Writer</div><div class="line">}]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 联合类型多于一个元素，并且io.Reader包含方法</span></div><div class="line"><span class="keyword">func</span> I12[K <span class="keyword">interface</span>{ io.Reader | <span class="typename">int</span> }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且不能是comparable</span></div><div class="line"><span class="keyword">func</span> I13[K comparable | <span class="typename">int</span>]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且元素不能嵌入comparable</span></div><div class="line"><span class="keyword">func</span> I14[K <span class="keyword">interface</span>{ comparable } | <span class="typename">int</span>]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="包含非接口类型元素、近似元素和联合类型只能用作类型参数，或者其它用作约束接口的元素">包含非接口类型元素、近似元素和联合类型只能用作类型参数，或者其它用作约束接口的元素</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line"></div><div class="line">    <span class="comment">// 以下编译没问题 </span></div><div class="line">	_ <span class="keyword">interface</span>{}</div><div class="line">	_ <span class="keyword">interface</span>{ m() }</div><div class="line">	_ <span class="keyword">interface</span>{ io.Reader }</div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		io.Reader</div><div class="line">		io.Writer</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 以下不能编译，接口不能用作变量实例类型</span></div><div class="line">	_ <span class="keyword">interface</span>{ <span class="typename">int</span> }</div><div class="line">	_ <span class="keyword">interface</span>{ ~<span class="typename">int</span> }</div><div class="line">	_ <span class="keyword">interface</span>{ MyInt }</div><div class="line">	A <span class="keyword">interface</span> {</div><div class="line">   	  <span class="typename">int</span></div><div class="line">	  m()</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 可以编译</span></div><div class="line">	_ <span class="keyword">struct</span>{ i <span class="typename">int</span> }</div><div class="line">    <span class="comment">// 下面一行不能编译,因为~int不能作为字段的类型</span></div><div class="line">	_ <span class="keyword">struct</span>{ i ~<span class="typename">int</span> }</div><div class="line">    <span class="comment">// 下面一行不能编译，因为constraints.Ordered只能用作类型约束</span></div><div class="line">	_ <span class="keyword">struct</span>{ i constraints.Ordered }</div><div class="line"></div><div class="line">    <span class="comment">// 下面两行能够编译，因为它们是接口类型，并且类型元素也是普通接口</span></div><div class="line">    _ <span class="keyword">interface</span>{ any }</div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		<span class="keyword">interface</span> {</div><div class="line">			any</div><div class="line">			m()</div><div class="line">		}</div><div class="line">	}</div><div class="line">    <span class="comment">// 不能编译，因为接口部署普通接口，而是类型约束</span></div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		<span class="keyword">interface</span> {</div><div class="line">			<span class="typename">int</span>|~<span class="typename">int</span></div><div class="line">			m()</div><div class="line">		}</div><div class="line">	}</div><div class="line">)</div></pre></td></tr></table></figure>

<h3 id="接口类型不定递归嵌入">接口类型不定递归嵌入</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误! 不能自己嵌入自己</span></div><div class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> {</div><div class="line">	Node</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! Tree不能通过TreeNode嵌入自己</span></div><div class="line"><span class="keyword">type</span> Tree <span class="keyword">interface</span> {</div><div class="line">	TreeNode</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> TreeNode <span class="keyword">interface</span> {</div><div class="line">	Tree</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.18 支持泛型后， Go interface 的意义已经彻彻底底的改变了，除了先前代表的方法集的意义外，还被用作泛型的类型约束(type constraint)的功能, interface已经不再是以前那个单纯的少年了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译] go fuzzing]]></title>
    <link href="https://colobu.com/2022/01/03/go-fuzzing/"/>
    <id>https://colobu.com/2022/01/03/go-fuzzing/</id>
    <published>2022-01-03T13:40:09.000Z</published>
    <updated>2022-01-03T14:28:09.864Z</updated>
    <content type="html"><![CDATA[<p>Go fuzzing(模糊测试)是Go 1.18发布的另一个非常重要的特性，因为Go泛型已经把大家的目光都吸引过去了，导致go fuzzing这个特性有些人还不是太了解。Go官方发布了一个文档，介绍了Go Fuzzing技术。<br><a href="https://tip.golang.org/doc/fuzz/" target="_blank" rel="external">Go Fuzzing</a></p>
<a id="more"></a>
<p>Go 自 1.18开始在标准工具链中开始支持模糊测试(fuzzing)。</p>
<h2 id="概览">概览</h2>
<p>Fuzzing 是一种自动化的测试技术， 它不断的创建输入用来测试程序的bug。 Go fuzzing使用覆盖率智能指导遍历被模糊化测试的代码，发现缺陷并报告给用户。由于模糊测试可以达到人类经常忽略的边缘场景，因此它对于发现安全漏洞和缺陷特别有价值。</p>
<p>下面是一个模糊测试的示例，突出标识了它的主要组件。<br><img src="example.png" alt=""></p>
<h2 id="编写并运行模糊测试">编写并运行模糊测试</h2>
<h3 id="必备条件">必备条件</h3>
<p>Below are rules that fuzz tests must follow.</p>
<p>下面是模糊测试必须遵循的规则：</p>
<ul>
<li>模糊测试必须是一个名称类似<code>FuzzXxx</code>的函数，仅仅接收一个<code>*testing.F</code>类型的参数,没有返回值</li>
<li>模糊测试必须在<code>*_test.go</code>文件中才能运行</li>
<li>Fuzz target(模糊目标)必须是对<code>(*testing.F).Fuzz</code>的方法调用，参数是一个函数，并且此函数的第一个参数是<code>*testing.T</code>,然后是模糊参数(<code>fuzzing argument</code>)，没有返回值</li>
<li>一个模糊测试中必须只有一个模糊目标</li>
<li>所有的种子语料库(<code>seed corpus</code>)必须具有与模糊参数相同的类型,顺序相同。对<code>(*testing.F).Add</code>的调用也是如此, 同样也适用模糊测试中的testdata/fuzz中的语料文件</li>
<li>模糊参数只能是下面的类型<ul>
<li>string, []byte</li>
<li>int, int8, int16, int32/rune, int64</li>
<li>uint, uint8/byte, uint16, uint32, uint64</li>
<li>float32, float64</li>
<li>bool</li>
</ul>
</li>
</ul>
<h3 id="建议">建议</h3>
<p>下面的建议可以帮助你应付大部分的模糊测试：</p>
<ul>
<li>Fuzzing应该在支持覆盖率检测的平台上运行（目前是AMD64和ARM64），这样语料库可以在运行时有意义地增长，并且在进行Fuzzing时可以覆盖更多的代码。</li>
<li>模糊目标应该是快速的和确定性的，这样模糊引擎可以有效地工作，并且新的故障和代码覆盖率可以很容易地重现。</li>
<li>由于模糊目标是在多个工作进程之间以不确定的顺序并行调用的，因此模糊目标的状态不应持续到每次调用结束后，并且模糊目标的行为不应依赖于全局状态。</li>
</ul>
<h3 id="定制">定制</h3>
<p>默认的go命令满足大部分模糊化测试场景，所以典型的一个模糊化运行命令应该如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go test -fuzz={FuzzTestName}</div></pre></td></tr></table></figure>

<p>但是go命令提供一些定制化的参数来运行模糊测试，它们在<a href="https://pkg.go.dev/cmd/go" target="_blank" rel="external">cmd/go</a>文档中都有介绍。</p>
<p>这里重点说几个:</p>
<p>-fuzztime:  执行的模糊目标在退出的时候要执行的总时间或者迭代次数，默认是用不结束<br>-fuzzminimizetime: 模糊目标在每次最少尝试时要执行的时间或者迭代次数，默认是60秒。你可以禁用最小化尝试，只需把这个参数设置为0<br>-parallel: 同时执行的模糊化数量，默认是<code>$GOMAXPROCS</code>。当前进行模糊化测试时设置-cpu无效果</p>
<h2 id="其它资源">其它资源</h2>
<ul>
<li><strong>教程</strong><ul>
<li>如果想了解Go模糊化介绍性的文章，请参考<a href="https://go.dev/blog/fuzz-beta" target="_blank" rel="external">the blog post</a></li>
<li>更多教程正在准备中</li>
</ul>
</li>
<li><strong>文档</strong><ul>
<li><code>testing</code> 包描述了模糊测试中用到的<code>testing.F</code>类型</li>
<li><code>cmd/go</code> 描述了和模糊测试相关的参数</li>
</ul>
</li>
<li><strong>技术细节</strong><ul>
<li><a href="https://golang.org/s/draft-fuzzing-design" target="_blank" rel="external">Design draft</a></li>
<li><a href="https://golang.org/issue/44551" target="_blank" rel="external">提案</a></li>
</ul>
</li>
</ul>
<h2 id="术语">术语</h2>
<ul>
<li>corpus entry: 语料库条目，可以在模糊化测试时使用。它可以是一个特殊格式的文件，也可以是<code>(*testing.F).Add</code>方法的调用</li>
<li>coverage guidance: 一种模糊化方法，它使用代码覆盖范围的扩展来确定哪些语料库条目值得保留以备将来使用。</li>
<li>fuzz target: 模糊测试的函数，在模糊化过程中对语料库条目和生成的值执行模糊测试。通过将函数传递给<code>(*testing.F).Fuzz</code>来提供模糊测试</li>
<li>fuzz test: 一个test文件中的函数，格式为<code>FuzzXxx(*testing.F)</code>,用来执行模糊测试</li>
<li>fuzzing: 一种自动测试类型，它不断地修改程序的输入，以发现代码可能易受影响的问题，如bug或漏洞。</li>
<li>fuzzing arguments: 被传递到模糊目标的类型，并且可以被mutator修改变异</li>
<li>fuzzing engine: 一种管理模糊化的工具，包括维护语料库、调用变体、识别新覆盖范围和报告失败。</li>
<li>generated corpus: 语料库在模糊化过程中由模糊引擎随时间进行维护，以跟踪进度。它存储在<code>$GOCACHE/fuzz</code>中。</li>
<li>mutator: 模糊处理时使用的一种工具，它在将语料库条目传递给模糊目标之前对其进行随机操作。</li>
<li>package: 同一个文件夹下源代码的集合，会被编译在一起。Go代码组织的<a href="https://tip.golang.org/ref/spec#Packages" target="_blank" rel="external">方式</a>。ation.</li>
<li>seed corpus: 用户提供的用于模糊测试的语料库，可用于指导模糊引擎。它由模糊测试中的<code>f.Add</code>调用提供的语料库条目和包中<code>testdata/fuzz/{FuzzTestName}</code>目录中的文件组成。</li>
<li>test file: 格式为<code>xxx_test.go</code>类型的文件，包含测试、benchmark和模糊测试代码</li>
<li>vulnerability: 代码中的安全敏感弱点，可被攻击者利用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go fuzzing(模糊测试)是Go 1.18发布的另一个非常重要的特性，因为Go泛型已经把大家的目光都吸引过去了，导致go fuzzing这个特性有些人还不是太了解。Go官方发布了一个文档，介绍了Go Fuzzing技术。<br><a href="https://tip.golang.org/doc/fuzz/" target="_blank" rel="external">Go Fuzzing</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型不支持泛型方法，这是一个悲伤的故事]]></title>
    <link href="https://colobu.com/2021/12/22/no-parameterized-methods/"/>
    <id>https://colobu.com/2021/12/22/no-parameterized-methods/</id>
    <published>2021-12-22T00:25:06.000Z</published>
    <updated>2021-12-22T06:37:46.594Z</updated>
    <content type="html"><![CDATA[<p>根据Go 泛型提案的描述，Go不支持泛型方法:<a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md#no-parameterized-methods" target="_blank" rel="external">No parameterized methods</a>。主要原因Go泛型的处理是在编译的时候实现的，泛型方法在编译的时候，如果没有上下文的分析推断，很难判断泛型方案该如何实例化，甚至判断不了，导致目前(Go 1.18)Go实现中不支持泛型方案。</p>
<p>不过，泛型方法的缺失，多多少少给程序员带来一丝丝的忧伤的情绪，在一些场景之下，使用起来特别不方便。我最近看到了几个因为缺乏泛型方法导致的问题，在本文中总结一下，和大家探讨。</p>
<p>有一点点让人欣慰的是，Ian Lance Taylor和Ian Lance Taylor并没有把话说绝，说不定在某个版本中，泛型方法又支持了:</p>
<blockquote>
<p>So while parameterized methods seem clearly useful at first glance, we would have to decide what they mean and how to implement that.</p>
</blockquote>
<a id="more"></a>
<h2 id="为啥当前Go泛型不好实现泛型方法?">为啥当前Go泛型不好实现泛型方法?</h2>
<p>考虑下面一个例子，一共有四个package:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p1</div><div class="line"></div><div class="line"><span class="comment">// S 是一个普通的struct,但是包含一个泛型方法Identity.</span></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// Identity 一个泛型方法，支持任意类型.</span></div><div class="line"><span class="keyword">func</span> (S) Identity[T any](v T) T { <span class="keyword">return</span> v }</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p2</div><div class="line"></div><div class="line"><span class="comment">// HasIdentity 定义了一个接口，支持任意实现了泛型方法Identity的类型.</span></div><div class="line"><span class="keyword">type</span> HasIdentity <span class="keyword">interface</span> {</div><div class="line">	Identity[T any](T) T</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p3</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"p2"</span></div><div class="line"></div><div class="line"><span class="comment">// CheckIdentity 是一个普通函数，检查实参是不是实现了HasIdentity接口，如果是，则调用这个接口的泛型方法Identity.</span></div><div class="line"><span class="keyword">func</span> CheckIdentity(v <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">if</span> vi, ok := v.(p2.HasIdentity); ok {</div><div class="line">		<span class="keyword">if</span> got := vi.Identity[<span class="typename">int</span>]<span class="number">(0</span>); got !=<span class="number"> 0</span> {</div><div class="line">			<span class="built_in">panic</span>(got)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p4</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"p1"</span></div><div class="line">	<span class="string">"p3"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// CheckSIdentity 传参S给CheckIdentity.</span></div><div class="line"><span class="keyword">func</span> CheckSIdentity() {</div><div class="line">	p3.CheckIdentity(p1.S{})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一切看起来都没有问题，但是问题是<code>package p3</code>不知道<code>p1.S</code>类型，整个程序中如果也没有其它地方调用<code>p1.S.Identity</code>,依照现在的Go编译器的实现，是没有办法为<code>p1.S.Identity[int]</code>生成对应的代码的。</p>
<p>是的，如果go编译器做的比较复杂，在编译的时候这个场景是可以识别出来的，但是它需要遍历整体的程序调用链以便生成全部可能的泛型方法，对编译时间和编译器复杂性带来很大的调整。另外一点，如果代码中通过反射调用的话，编译器可能会遗漏一些泛型方法的实现，这就很要命了。</p>
<p>如果在运行时实现呢？就需要JIT或者反射等技术，这会造成运行时性能的下降。</p>
<p>很难实现啊？如果规定泛型方法不能实现接口呢？那么这类的泛型方法的存在的意义是什么呢？</p>
<p>所以目前没有太好的手段去实现泛型方法，暂时搁置了。</p>
<p>如果真的有必要，你可以通过实现泛型函数来实现泛型方法，把方法的receiver当成第一个参数传递过去。</p>
<p>这可以解决一部分问题，但是在使用的过程中多多少少有些麻烦。</p>
<p>因为泛型方法的缺乏，大家在开始使用泛型的时候就遇到了麻烦，最近连续看到多篇关于这方面的问题，比如下面几个。</p>
<h2 id="Facilitator模式_by_rakyll">Facilitator模式 by rakyll</h2>
<p>昨天rakyll写了一篇文章<a href="https://rakyll.org/generics-facilititators/" target="_blank" rel="external">https://rakyll.org/generics-facilititators/</a>,介绍她遇到的困难以及解决方式。这也是促进我把这几天看到的case总结的原因。</p>
<p>如果你熟悉其它编程语言，在使用orm框架的时候，可能见过下面类似的代码，实现泛型方法进行某种对象的查询:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db, err := database.Connect(<span class="string">"...."</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatal(err)</div><div class="line">}</div><div class="line"></div><div class="line">all, err := db.All[Person](ctx) <span class="comment">// Reads all person entities</span></div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatal(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为Go缺乏泛型方法的实现，你不能实现泛型<code>All</code>方法，那么怎么实现呢？一种方式是实现<code>All</code>函数，另一种实现是实现rakyll称之为的<code>Facilitator模式</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> database</div><div class="line"></div><div class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span>{ ... }</div><div class="line"></div><div class="line"><span class="keyword">type</span> Querier[T any] <span class="keyword">struct</span> {</div><div class="line">	client *Client</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewQuerier[T any](c *Client) *Querier[T] {</div><div class="line">	<span class="keyword">return</span> &Querier[T]{</div><div class="line">		client: c,</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (q *Querier[T]) All(ctx context.Context) ([]T, error) {</div><div class="line">	<span class="comment">// implementation</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (q *Querier[T]) Filter(ctx context.Context, filter ...Filter) ([]T, error) {</div><div class="line">	<span class="comment">// implementation</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数实现让人感觉到一种无力感，一种缺乏归宿感，一种没有对象的感觉，而这种实现呢，生成了特定类型的Querier[T],<code>All</code>方法就有泛型的感觉了(虽然实际是Receiver泛型)</p>
<h2 id="泛型signleflight">泛型signleflight</h2>
<p>有些同学熟悉Go官方扩展库<a href="golang.org/x/sync/singleflight">x/sync/singleflight</a>，这个库很好的解决大并发的时候并发访问的问题，常常用在cache访问和微服务访问的处理之中。</p>
<p>为了支持任意类型，它内部的实现是使用<code>interface{}</code>(<code>any</code>)类型来表示和处理的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g Group</div><div class="line">v, _, _ := g.Do(<span class="string">"key"</span>, <span class="keyword">func</span>() (<span class="keyword">interface</span>{}, error) {</div><div class="line">    <span class="keyword">return</span> <span class="string">"bar"</span>, <span class="constant">nil</span></div><div class="line">})</div><div class="line">useString(v.(<span class="typename">string</span>))</div></pre></td></tr></table></figure>

<p>五天前，有人把它改造成泛型的方式:<a href="https://github.com/marwan-at-work/singleflight" target="_blank" rel="external">marwan-at-work/singleflight</a>，上面的代码使用起来改变成如下方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g Group[<span class="typename">string</span>]</div><div class="line">v, _, _ := g.Do(<span class="string">"key"</span>, <span class="keyword">func</span>() (<span class="typename">string</span>, error) {</div><div class="line">    <span class="keyword">return</span> <span class="string">"bar"</span>, <span class="constant">nil</span></div><div class="line">})</div><div class="line">useString(v)</div></pre></td></tr></table></figure>

<p>相当于把Group改造成泛型类型，而不是实现泛型方法<code>Do</code>(当然目前Go泛型也实现不了)。</p>
<p>这个处理和上面rakyll处理方式类型，都是生成泛型类型，通过Receiver实现泛型的方法的处理。</p>
<p>不过对于这种方式，有一点不好的地方就是每种类型你都得生成一个特别的对象，略显麻烦。</p>
<h2 id="map_reduce">map reduce</h2>
<p>更早时候关于泛型的讨论，有人提出泛型方法的缺乏导致Go实现map reduce类似的库的困难，具体在哪里提到的我已经忘记了。</p>
<p>比如下面的实现一个iter的map reduce:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (i *iter[T any]) <span class="keyword">map</span>[K ~<span class="typename">string</span>](mapFn <span class="keyword">func</span>(t T) K) *iter[K]</div></pre></td></tr></table></figure>

<p>这种情况下用户想传入任意的<code>K</code>,把原先<code>T</code>类型的iter转换成<code>K</code>类型的iter,这种就不想其它支持泛型语言那么好实现了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据Go 泛型提案的描述，Go不支持泛型方法:<a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md#no-parameterized-methods" target="_blank" rel="external">No parameterized methods</a>。主要原因Go泛型的处理是在编译的时候实现的，泛型方法在编译的时候，如果没有上下文的分析推断，很难判断泛型方案该如何实例化，甚至判断不了，导致目前(Go 1.18)Go实现中不支持泛型方案。</p>
<p>不过，泛型方法的缺失，多多少少给程序员带来一丝丝的忧伤的情绪，在一些场景之下，使用起来特别不方便。我最近看到了几个因为缺乏泛型方法导致的问题，在本文中总结一下，和大家探讨。</p>
<p>有一点点让人欣慰的是，Ian Lance Taylor和Ian Lance Taylor并没有把话说绝，说不定在某个版本中，泛型方法又支持了:</p>
<blockquote>
<p>So while parameterized methods seem clearly useful at first glance, we would have to decide what they mean and how to implement that.</p>
</blockquote>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go并发编程一年回顾(2021)]]></title>
    <link href="https://colobu.com/2021/11/09/the-state-of-go-sync-2021/"/>
    <id>https://colobu.com/2021/11/09/the-state-of-go-sync-2021/</id>
    <published>2021-11-09T06:37:32.000Z</published>
    <updated>2021-11-10T00:35:33.185Z</updated>
    <content type="html"><![CDATA[<p>去年的时候我写了一篇<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/" target="_blank" rel="external">Go并发编程一年回顾</a>,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。</p>
<a id="more"></a>
<h2 id="TryLock终于要发布">TryLock终于要发布</h2>
<p>很久以来(可以追溯到2013年<a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">#6123</a>),就有人提议给Mutex增加TryLock的方法，被大佬们无情的拒绝了，断断续续，断断续续的一直有人提议需要这个方法，如今到了2021年，Go team大佬们终于松口了，增加了相应的方法(<a href="https://github.com/golang/go/issues/45435" target="_blank" rel="external">#45435</a>)。</p>
<p>一句话来说，Mutex增加了TryLock， 尝试获取锁, RWMutex 增加了 TryLock和TryRLock方法，尝试获取写锁和读锁。它们都返回bool类型。如果返回true,代表已经获取到了相应的锁，如果返回false,则表示没有获取到相应的锁。</p>
<p>本质上，要实现这些方法并不麻烦，接下来我们看看相应的实现(去除了race代码)。</p>
<p>首先是Mutex.TryLock:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&m.state,<span class="number"> 0</span>, mutexLocked) {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是利用aromic.CAS操作state字段，如果当前没有被锁或者没有等待锁的情况，就可以成功获取到锁。不会尝试spin和与等待者竞争。</p>
<p>不要吐槽上面的代码风格，可能你觉得不应该写成下面的方式吗？原因在于我删除了race代码，那些代码块中包含race代码，所以不能像下面一样简写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32(&m.state,<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>读写锁有些麻烦，因为它有读锁和写锁两种情况。</p>
<p>首先看RWMutex.TryLock(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (rw *RWMutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> !rw.w.TryLock() {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !atomic.CompareAndSwapInt32(&rw.readerCount,<span class="number"> 0</span>, -rwmutexMaxReaders) {</div><div class="line">        rw.w.Unlock()</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先底层的Mutex.TryLock,尝试获取w字段的锁,如果成功，需要检查当前的Reader, 如果没有reader,则成功, 如果此时不幸还有reader没有释放读锁，那么尝试Lock也是不成功的,返回false。注意返回之前一定要把rw.w的锁释放掉。</p>
<p>接下来看RWMutex.TryRLock(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (rw *RWMutex) TryRLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		c := atomic.LoadInt32(&rw.readerCount)</div><div class="line">		<span class="keyword">if</span> c &lt;<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&rw.readerCount, c, c<span class="number">+1</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码首先检查readerCount,如果为负值，说明有writer，此时直接返回false。</p>
<p>如果没有writer, 则使用atomic.CAS把reader加1, 如果成功，返回。如果不成功，那么此时可能有其它reader加入，或者也可能有writer加入，因为不能判断是reader还是writer加入，那么就用一个for循环再重试。</p>
<p>如果是writer加入，那么下一次循环c可能就是负数，直接返回false,如果刚才是有reader加入，那么它再尝试加1就好了。</p>
<p>以上就是新增的代码，不是特别复杂。Go team不情愿的把这几个方法加上了, 同时有很贴心的提示(恐吓):</p>
<blockquote>
<p>Note that while correct uses of TryLock do exist, they are rare,<br>and use of TryLock is often a sign of a deeper problem<br> in a particular use of mutexes. </p>
</blockquote>
<h2 id="WaitGroup的字段变化">WaitGroup的字段变化</h2>
<p>先前，WaitGroup类型使用<code>[3]uint32</code>作为<code>state1</code>字段的类型，在64位和32位编译器情况下，这个字段的byte的意义是不同的，主要是为了对齐。虽然使用一个字段很&quot;睿智&quot;,但是阅读起来却很费劲，现在，Go team把它改成了两个字段，根据对齐规则，64位编译器会对齐相应字段，讲真的，我们不差那4个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></div><div class="line">	<span class="comment">// compilers only guarantee that 64-bit fields are 32-bit aligned.</span></div><div class="line">	<span class="comment">// For this reason on 32 bit architectures we need to check in state()</span></div><div class="line">	<span class="comment">// if state1 is aligned or not, and dynamically "swap" the field order if</span></div><div class="line">	<span class="comment">// needed.</span></div><div class="line">	state1 <span class="typename">uint64</span></div><div class="line">	state2 <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// state returns pointers to the state and sema fields stored within wg.state*.</span></div><div class="line"><span class="keyword">func</span> (wg *WaitGroup) state() (statep *<span class="typename">uint64</span>, semap *<span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">if</span> unsafe.Alignof(wg.state1) ==<span class="number"> 8</span> || <span class="typename">uintptr</span>(unsafe.Pointer(&wg.state1))<span class="number">%8</span> ==<span class="number"> 0</span> {</div><div class="line">		<span class="comment">// state1 is 64-bit aligned: nothing to do.</span></div><div class="line">		<span class="keyword">return</span> &wg.state1, &wg.state2</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="comment">// state1 is 32-bit aligned but not 64-bit aligned: this means that</span></div><div class="line">		<span class="comment">// (&state1)+4 is 64-bit aligned.</span></div><div class="line">		state := (*<span class="number">[3</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&wg.state1))</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&state<span class="number">[1</span>])), &state<span class="number">[0</span>]</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>64位对齐情况下state1和state2意义很明确，如果不是64位对齐，还得巧妙的转换一下。</p>
<h2 id="Pool中使用fastrandn替换fastrand">Pool中使用fastrandn替换fastrand</h2>
<p>Go运行时中提供了<code>fastrandn</code>方法，要比<code>fastrand() % n</code>快很多，相关的文章可以看下面中的注释中的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> fastrand() <span class="typename">uint32</span> {</div><div class="line">	mp := getg().m</div><div class="line">	<span class="comment">// Implement wyrand: https://github.com/wangyi-fudan/wyhash</span></div><div class="line">	<span class="keyword">if</span> goarch.IsAmd64|goarch.IsArm64|goarch.IsPpc64|</div><div class="line">		goarch.IsPpc64le|goarch.IsMips64|goarch.IsMips64le|</div><div class="line">		goarch.IsS390x|goarch.IsRiscv64 ==<span class="number"> 1</span> {</div><div class="line">		mp.fastrand +=<span class="number"> 0</span>xa0761d6478bd642f</div><div class="line">		hi, lo := math.Mul64(mp.fastrand, mp.fastrand<span class="number">^0</span>xe7037ed1a0b428db)</div><div class="line">		<span class="keyword">return</span> <span class="typename">uint32</span>(hi ^ lo)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Implement xorshift64+</span></div><div class="line">	t := (*<span class="number">[2</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&mp.fastrand))</div><div class="line">	s1, s0 := t<span class="number">[0</span>], t<span class="number">[1</span>]</div><div class="line">	s1 ^= s1 &lt;&lt;<span class="number"> 17</span></div><div class="line">	s1 = s1 ^ s0 ^ s1&gt;<span class="number">&gt;7</span> ^ s0&gt;<span class="number">&gt;16</span></div><div class="line">	t<span class="number">[0</span>], t<span class="number">[1</span>] = s0, s1</div><div class="line">	<span class="keyword">return</span> s0 + s1</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> fastrandn(n <span class="typename">uint32</span>) <span class="typename">uint32</span> {</div><div class="line">	<span class="comment">// This is similar to fastrand() % n, but faster.</span></div><div class="line">	<span class="comment">// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/</span></div><div class="line">	<span class="keyword">return</span> <span class="typename">uint32</span>(<span class="typename">uint64</span>(fastrand()) * <span class="typename">uint64</span>(n) &gt;&gt;<span class="number"> 32</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以sync.Pool中使用<code>fastrandn</code>做了一点点修改，用来提高性能。好卷啊，这一点点性能都来压榨,关键，这还是开启race才会执行的代码。</p>
<h2 id="sync-Value增加了Swap和CompareAndSwap两个便利方法">sync.Value增加了Swap和CompareAndSwap两个便利方法</h2>
<p>如果使用sync.Value,这两个方法的逻辑经常会用到，现在这两个方法已经添加到标准库中了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (v *Value) Swap(<span class="built_in">new</span> <span class="keyword">interface</span>{}) (old <span class="keyword">interface</span>{}) </div><div class="line"><span class="keyword">func</span> (v *Value) CompareAndSwap(old, <span class="built_in">new</span> <span class="keyword">interface</span>{}) (swapped <span class="typename">bool</span>)</div></pre></td></tr></table></figure>

<p>Go 1.18中虽然实现了泛型，但是一些库的修改有可能在将来的版本中实现了。在泛型推出来之后，atomic对类型的支持会有大大的加强，所以将来Value这个类型有可能退出历史舞台，很少被使用了。(参考Russ Cox的文章<a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>)</p>
<p>整体来说，Go的并发相关的库比较稳定，并没有大的变化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去年的时候我写了一篇<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/" target="_blank" rel="external">Go并发编程一年回顾</a>,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型系列：再简化，省略接口]]></title>
    <link href="https://colobu.com/2021/10/24/go-generic-eliding-interface/"/>
    <id>https://colobu.com/2021/10/24/go-generic-eliding-interface/</id>
    <published>2021-10-24T09:27:08.000Z</published>
    <updated>2021-10-28T04:19:25.403Z</updated>
    <content type="html"><![CDATA[<p>这是Go泛型系列文章。</p>
<p>其它Go泛型文章：</p>
<ul>
<li><a href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/" target="_blank" rel="external">Go泛型是怎么实现的?</a></li>
<li><a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a></li>
</ul>
<a id="more"></a>
<p>如果你一直关注Go泛型的设计和实现，一定知道Go泛型代码实现是通过类型参数(type parameter)实现的，当运行泛型代码时，类型参数(type parameter)由类型参数（type argument）替代。(很遗憾parameter和argument都被翻译成了中文参数)</p>
<p>类型参数(type parameter)也有类型，也就是描述这个参数类型行为的元数据，被成为约束(constraint)。最通用的约束就是内建的<code>any</code>类型，它代表任意的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Print[T any](s []T) {</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</div><div class="line">		fmt.Println(v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Go泛型设计中， 约束是通过接口类型来实现的(<code>interface</code>)。因为接口类型和约束的功能黑类似，就是限定type argument必须实现type parameter的约束(方法集)。当然，为了实现泛型的功能，除了方法集之外，Go还对用来当做约束的接口做了扩展，定义了类型集(<code>type set</code>)的概念,比如下面是约束代表一个type argument可以是int、int8、int16、int32或int64的类型，是并(<code>union</code>)的关系，所以使用<code>|</code>符号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span> | <span class="typename">int8</span> | <span class="typename">int16</span> | <span class="typename">int32</span> | <span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>更进一步，Go还定义了<code>~</code>的符号，代表只要底层类型都是某个特定类型就可以，所以上面的例子可以写的更通用一些:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span> | ~<span class="typename">int8</span> | ~<span class="typename">int16</span> | ~<span class="typename">int32</span> | ~<span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样<code>type MyInt int</code>定义的<code>MyInt</code>类型的实例也满足这个约束。</p>
<h2 id="constraints_包">constraints 包</h2>
<p>Go目前的实现新增加一个package,叫做<code>constraints</code>,用来定义内建的约束,比如常见的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span> | ~<span class="typename">int8</span> | ~<span class="typename">int16</span> | ~<span class="typename">int32</span> | ~<span class="typename">int64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">uint</span> | ~<span class="typename">uint8</span> | ~<span class="typename">uint16</span> | ~<span class="typename">uint32</span> | ~<span class="typename">uint64</span> | ~<span class="typename">uintptr</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</div><div class="line">	Signed | Unsigned</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">float32</span> | ~<span class="typename">float64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Complex <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">complex64</span> | ~<span class="typename">complex128</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> {</div><div class="line">	Integer | Float | ~<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至 Russ Cox、Ian Lance Taylor他们 提议和讨论为 slice、map、chan增加必要的约束，因为它们太常用了，标准库中都可以用到。(<a href="https://github.com/golang/go/discussions/47203" target="_blank" rel="external">#47203</a>、<a href="https://github.com/golang/go/discussions/47319" target="_blank" rel="external">#47319</a>、<a href="https://github.com/golang/go/discussions/47330" target="_blank" rel="external">47330#</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Slice[Elem any] <span class="keyword">interface</span> {</div><div class="line">	~[]Elem</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Map[Key comparable, Val any] <span class="keyword">interface</span> {</div><div class="line">	~<span class="keyword">map</span>[Key]Val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Chan[Elem any] <span class="keyword">interface</span> {</div><div class="line">	~<span class="keyword">chan</span> Elem</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>Rob Pike 最近新提交了一个issue,建议在Go 1.18中不要对标准库增加泛型的支持<a href="https://github.com/golang/go/issues/48918" target="_blank" rel="external">#48918</a>。离Go 1.18发布就四个月了，很多实现还在摸索之中，这是大师给出的一个很中肯的建议，建议相关的哭的改动先增加到扩展库中(<code>x/exp</code>),成熟后再加到标准库中，得到了很多Gopher的赞同。这是另外一个话题了。</p>
</blockquote>
<p>包<code>constraints</code>定义常用的约束可以很好的帮助我们开发，但是你有没有感觉有点异常？</p>
<h2 id="省略接口">省略接口</h2>
<p>是的，依照Go泛型规范，我们必须定义一个约束，然后才能在泛型类型和泛型方法中使用，和其它语言的泛型定义相比，你有没有觉得这一点有脱裤子放屁多此一举的味道？</p>
<p>你看上面的Slice、Map、Chan的定义，是不是很冗余？为什么我们不能直接在泛型类型和方法的定义中直接使用<code>~[]Elem</code>、<code>~map[Key]Val</code>、<code>~chan Elem</code>呢？</p>
<p>因此fzipp提议，对于一个非接口的类型，默认等价为一个约束<a href="https://github.com/golang/go/issues/48424" target="_blank" rel="external">#48424</a>，下面的公式很好的描述了这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[T nonInterfaceType] ≡ [T <span class="class"><span class="keyword">interface</span></span>{~nonInterfaceType}]</div></pre></td></tr></table></figure>

<p>在泛型的定义中，非接口类型<code>nonInterfaceType</code>等价于约束<code>interface{~nonInterfaceType}</code>, 比如<code>~int</code>等价于<code>interface{~int}</code>。这样我们就可以省略<code>constraints</code>包了。 这个提议北接收了，而且相关功能也加入到了go master分支中。</p>
<p>mattn的Go泛型例子中，将一个整形数组转换成一个chan的<a href="https://github.com/mattn/go-generics-example/blob/main/constraints-chan/main.go" target="_blank" rel="external">例子</a>(我稍微改动成更地道的Go的写法):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"constraints"</span></div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> makeChan[T constraints.Chan[E], E any](ctx context.Context, arr []E) T {</div><div class="line">	ch := <span class="built_in">make</span>(T)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> ch &lt;- v:</div><div class="line">			}</div><div class="line">			</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> makeChan(context.Background(), []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}) {</div><div class="line">		fmt.Println(v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里使用的是<code>constraints.Chan[E]</code>代表一个泛型的channel，现在可以用更简便的方法了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> makeChan[T <span class="keyword">chan</span> E, E any](ctx context.Context, arr []E) T {</div><div class="line">	ch := <span class="built_in">make</span>(T)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> ch &lt;- v:</div><div class="line">			}</div><div class="line">			</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接使用<code>chan E</code>就可以了，方不方便？</p>
<p><code>chan E</code> 隐式地代表<code>interface {chan E}</code>,使用起来更简捷，不需要额外的接口(约束)定义。</p>
<p>虽然Go 1.18的临近，感觉Go泛型的开发工作越来越重，甚至有一些还不明确的地方，祝福一下吧，希望它顺顺利利的推出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Go泛型系列文章。</p>
<p>其它Go泛型文章：</p>
<ul>
<li><a href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/" target="_blank" rel="external">Go泛型是怎么实现的?</a></li>
<li><a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a></li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]更快的时间解析]]></title>
    <link href="https://colobu.com/2021/10/10/faster-time-parsing/"/>
    <id>https://colobu.com/2021/10/10/faster-time-parsing/</id>
    <published>2021-10-10T08:17:51.000Z</published>
    <updated>2021-10-24T09:19:04.610Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://philpearl.github.io/post/perf_time/" target="_blank" rel="external">Faster time parsing</a>， 可以学习一下作者优化程序的方法。</p>
<a id="more"></a>
<p><img src="time.jpg" alt=""></p>
<p>在<a href="https://www.ravelin.com/careers" target="_blank" rel="external">Ravelin</a>，我们大量的数据都携带时间戳(timestamp)。大部分时间戳都以字符串形式存储在BigQuery中，而我们的大多数Go结构都使用Go time.Time类型表示时间。</p>
<p>很遗憾这就是我们的现实情况。我们真的有很多很多数据，所以我们真的有很多很多时间戳。一段时间以来，我总结出一个结论，随着时间的推移，我确信这个结论是正确的：</p>
<blockquote>
<p><strong>Friends don’t let friends represent time in databases as strings.</strong><br><strong>真心是哥们的话就不要在数据库把时间表示成字符串类型</strong></p>
</blockquote>
<p>不管咋地，自己的苦还得自己咽下去，既然我们已经这么设计了，我们还得坚持下去，但这不意味着我们破罐子破摔了，我们可以尽力而为。对于我来说，现在做得最好的方案就是找到一种比<a href="https://pkg.go.dev/time#Parse" target="_blank" rel="external">time.Parse</a>更快的方法解析 <strong>RFC3339</strong> 格式的时间戳。<br> If we write a dedicated parsing routine that just parses RFC3339 it should be faster than that.</p>
<p>事实证明这很容易。<strong>time.Parse</strong>有两个参数：一个描述要解析的数据格式(特殊字符串)，另一个是需要解析的数据字符串。format参数不只是选择合适的格式。format参数描述应如何解析数据。<strong>time.Parse</strong>不仅解析时间，还必须解析、理解和实现一种解析时间的描述。如果我们编写一个只是解析RFC3339的专用解析函数，它应该会比<strong>time.Parse</strong>更快。</p>
<p>但是在动手之前，让我们先写一个快速的基准测试，看看<strong>time.Parse</strong>有多快:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkParseRFC3339(b *testing.B) {</div><div class="line">	now := time.Now().UTC().Format(time.RFC3339Nano)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		<span class="keyword">if</span> _, err := time.Parse(time.RFC3339, now); err != <span class="constant">nil</span> {</div><div class="line">			b.Fatal(err)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面数据是测试的结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="property">name</span>             <span class="property">time</span>/op</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">150</span>ns ± <span class="number">1</span>%</div></pre></td></tr></table></figure>

<p>接下来我们开始写自己专用的 RFC3339 解析函数。它索然无味，而且也不漂亮，但是至少它可以工作。</p>
<p>(它真的很长且不漂亮，所以与其把它包含在这篇文章中，让大家滚动过去，不如这里有一个<a href="https://github.com/philpearl/avro/blob/master/time/parse.go" target="_blank" rel="external">链接</a>，指向最终版本，并应用下面讨论的所有优化。如果你想象一个很长的函数，调用<a href="https://pkg.go.dev/strconv#Atoi" target="_blank" rel="external">strconv.Atoi</a>的次数很多，你就会明白这一点)</p>
<p>我们使用基础测试代码测试新的解析函数，我们得到下面的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>   <span class="number">150</span>ns ± <span class="number">1</span>%    <span class="number">45</span>ns ± <span class="number">4</span>%  -<span class="number">70.15</span>%  (p=<span class="number">0.000</span> n=<span class="number">7</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>相比较而言，新的函数真的很快。完美，结束。</p>
<h2 id="等等，_还未结束">等等， 还未结束</h2>
<p>如果我们采样 <a href="https://hackernoon.com/go-the-complete-guide-to-profiling-your-code-h51r3waz" target="_blank" rel="external">CPU profile</a>,我们观察到很多时间都花费在调用<strong>strconv.Atoi</strong>上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; go test -run ^$ -bench BenchmarkParseRFC3339 -cpuprofile cpu.prof </div><div class="line">&gt; go tool pprof cpu.prof</div><div class="line"><span class="keyword">Type</span>: cpu</div><div class="line"><span class="typename">Time</span>: Oct <span class="number">1</span>, <span class="number">2021</span> at <span class="number">7</span>:<span class="number">19</span>pm (BST)</div><div class="line">Duration: <span class="number">1.22</span>s, Total samples = <span class="number">960</span>ms (<span class="number">78.50</span>%)</div><div class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">950</span>ms, <span class="number">98.96</span>% <span class="keyword">of</span> <span class="number">960</span>ms total</div><div class="line">Showing top <span class="number">10</span> nodes <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">24</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     <span class="number">380</span>ms <span class="number">39.58</span>% <span class="number">39.58</span>%      <span class="number">380</span>ms <span class="number">39.58</span>%  strconv.Atoi</div><div class="line">     <span class="number">370</span>ms <span class="number">38.54</span>% <span class="number">78.12</span>%      <span class="number">920</span>ms <span class="number">95.83</span>%  github.com/philpearl/blog/content/post.parseTime</div><div class="line">      <span class="number">60</span>ms  <span class="number">6.25</span>% <span class="number">84.38</span>%      <span class="number">170</span>ms <span class="number">17.71</span>%  <span class="typename">time</span>.Date</div></pre></td></tr></table></figure>

<p><strong>strconv.Atoi</strong>转换ASCII字符到整数类型。这是Go标准库的基础实现，所以它一定是经过了很好的编码和优化，所以我们不能优化它吗？</p>
<p>未必，我们的大部分数字正好有2个字节长，或者正好有4个字节长。我们可以编写数字解析函数，针对我们的特殊情况做优化，不需要任何令人讨厌的慢循环:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> atoi4(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	a, b, c, d := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[2</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[3</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> || c &lt;<span class="number"> 0</span> || c &gt;<span class="number"> 9</span> || d &lt;<span class="number"> 0</span> || d &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*1000</span> + b<span class="number">*100</span> + c<span class="number">*10</span> + d, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果再运行我们的基准测试，可以看到我们又做了一次更深入的性能提升。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">44.9</span>ns ± <span class="number">4</span>%  <span class="number">39.7</span>ns ± <span class="number">3</span>%  -<span class="number">11.51</span>%  (p=<span class="number">0.000</span> n=<span class="number">8</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>好了，我们现在不仅写了一个定制的时间解析器，而且还实现了定制的数字解析器。非常完美，结束。</p>
<h2 id="等等，_当然还未结束">等等， 当然还未结束</h2>
<p>啊哈，让我们在看一眼现在的CPU profile, 并且看一些汇编代码。在<strong>atoi2</strong>中有两个slice长度检查(下面绿色的汇编代码,调用panicIndex之前)，不是有一个<a href="https://go101.org/article/bounds-check-elimination.html" target="_blank" rel="external">边界检查的技巧</a>吗？</p>
<p><img src="lencheck.png" alt=""></p>
<p>以下是根据此技巧进行修正后的代码。函数开始处的<strong>_ = in[1]</strong>给了编译器充足的提示，这样我们在调用它的时候不用每次都检查是否溢出了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	_ = in<span class="number">[1</span>] <span class="comment">// This helps the compiler reduce the number of times it checks `in` is long enough</span></div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>虽然是一点小小的改变，但也带来明显的改变:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">39.7</span>ns ± <span class="number">3</span>%  <span class="number">38.4</span>ns ± <span class="number">2</span>%  -<span class="number">3.26</span>%  (p=<span class="number">0.001</span> n=<span class="number">8</span>+<span class="number">7</span>)</div></pre></td></tr></table></figure>

<p><strong>atoi2</strong>非常短。为什么它不被内联的？如果我们简化错误处理，是不是有效果？如果我们删除对<strong>fmt.Errorf</strong>的调用，并将其替换为一个简单的错误类型，这将降低<strong>atoi2</strong>函数的复杂性。这可能足以让Go编译器决定不作为单独的代码块而是直接在调用函数中内联这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> errNotNumber = errors.New(<span class="string">"not a valid number"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	_ = in<span class="number">[1</span>]</div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, errNotNumber</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是最终的形态，基准测试结果有了显著的提升。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">38.4</span>ns ± <span class="number">2</span>%  <span class="number">32.9</span>ns ± <span class="number">5</span>%  -<span class="number">14.39</span>%  (p=<span class="number">0.000</span> n=<span class="number">7</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>我们的优化故事真的就此结束了。为了优化120纳秒的时间我们做了大量的工作。必看120纳秒很小，加起来却对程序提升不少，这些优化将Ravelin的一些机器学习特征提取管道组件的运行时间减少了一个小时甚至更多。如我前面所说，我们真的有很多很多的数据和时间戳。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://philpearl.github.io/post/perf_time/" target="_blank" rel="external">Faster time parsing</a>， 可以学习一下作者优化程序的方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
