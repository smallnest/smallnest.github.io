<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2022-07-31T09:41:23.081Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2022 Go生态圈 rpc 框架 Benchmark]]></title>
    <link href="https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/"/>
    <id>https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/</id>
    <published>2022-07-31T07:49:55.000Z</published>
    <updated>2022-07-31T09:40:53.414Z</updated>
    <content type="html"><![CDATA[<p>距离上一次<a href="https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/" target="_blank" rel="external">2021年Go生态圈rpc框架benchmark</a>的测试整整一年了。一年来，各个RPC框架也获得长足的进展，<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>也在众多网友的支持下做了一些有益的优化和精简，所以是时候再做一次国内几个常用框架的性能比较了。</p>
<a id="more"></a>
<p>每次性能结果的发布，必然引来众多的人的注目，也引来更多的争议。这是很正常的。一个benchmark不代表评价一个框架的优劣，一个benchmakr测试也不足以代表测试所有的应用场景。在不同的业务形态下、巨大的连接数差别、消息的格式不同、消息大小的不同、部署环境的不同都可能导致某些场景下某个框架的结果比较好，某个框架的结果比较差。我们奖讨论和焦点放在还有哪些可以性能提升的点上即可。某个框架的优化点或许能够其它框架带来一些优化的提示。</p>
<p>另外，在实际使用微服务框架的时候，大部分的性能瓶颈在于业务代码，而不是框架本身，所以重点优化业务代码也非常的重要。</p>
<p>本次测试针对五种常见的rpc框架进行了测试:</p>
<ul>
<li><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>, 最早的Go生态圈微服务框架之一，被新浪、好未来等公司使用</li>
<li><a href="https://github.com/cloudwego/kitex" target="_blank" rel="external">kitex</a>, 字节跳动出品的微服务框架</li>
<li><a href="https://github.com/lesismal/arpc" target="_blank" rel="external">arpc</a>: 一个性能优异的rpc框架 by lesismal</li>
<li><a href="https://grpc.io/" target="_blank" rel="external">grpc</a>: Google发起的一个开源rpc框架，支持跨语言，使用广泛。该系统基于HTTP/2 协议传输，使用Protocol Buffers 作为接口描述语言。</li>
<li><a href="https://pkg.go.dev/net/rpc" target="_blank" rel="external">标准库的rpc/std_rpc</a>: Go标准库自带的rpc框架，目前处于维护状态</li>
</ul>
<p>测试采用了各框架的最新版本:</p>
<ul>
<li><strong>rpcx</strong>: v1.7.8</li>
<li><strong>kitex</strong>: v0.3.4</li>
<li><strong>arpc</strong>: v1.2.9</li>
<li><strong>grpc</strong>: v1.48.0</li>
<li><strong>std_rpc</strong>: v1.8.4</li>
</ul>
<p>为了尽量保持一致性的测试，所有的测试都是在相同的才是环境下，相同的测试逻辑，相同的测试消息进行的:</p>
<ul>
<li>测试环境(已经服役6年的老机器,两台，一台做server,一台做client)<ul>
<li>CPU型号: Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz / 2颗</li>
<li>物理核: 6个; 逻辑核: 12核</li>
<li>内存: 64G</li>
<li>开启网卡多队列</li>
</ul>
</li>
<li>都采用protobuf作为消息体的编码方式，编码后的消息体大小伟581个字节</li>
<li>在客户端统计，统计吞吐量(throughputs)和延迟(lantency, 包括最大值，平均值，中位数值，和p99.9的值， 最小值都小于1毫秒，所以未统计)<ul>
<li>对于延迟，我们还需要关注它的长尾情况，所以需要关注中位数和p99.9。p99.9指千分之999的请求的延迟都小于某个时间。</li>
</ul>
</li>
</ul>
<p>主要分为三个场景进行测试。</p>
<ul>
<li>TCP连接数为10, 长连接。并发数为100、200、500、1000、2000、5000的情况<br>主要测试高并发的情况下各框架最大的能力，包括吞吐量和延迟。</li>
<li>TCP连接数为10,并发数伟200,长连接。 吞吐量为10万/秒、15万/秒、18万/秒的情况下的延迟<br>主要测在吞吐保持一致的情况下，各个框架的延迟情况和长尾情况。延迟胡哲长尾太大意味着使用这个吞吐率是不合适。</li>
<li>TCP连接数为1000，并发数为1000，长连接。<br>主要测试大连接数比较高的情况下各框架的性能。主要是想针对字节的kitex这种自研的netpull,看看是否更适合这种大量连接数的情况。</li>
</ul>
<p>这里并发数是指客户端启动的goroutine数量，多个goroutine可能共享同一个client(连接)。</p>
<p>所有的各框架的测试代码都放在了<a href="https://github.com/rpcxio/rpcx-benchmark" target="_blank" rel="external">rpcx-benchmark</a>。测试的命令非常简单，如下面的介绍中所示，所以你可以下载下来自己测试验证，也欢迎提供优化补丁，补充更多的rpc框架等等。</p>
<h2 id="场景一：_TCP连接数为10,_长连接。并发数为100、200、500、1000、2000、5000的情况">场景一： TCP连接数为10, 长连接。并发数为100、200、500、1000、2000、5000的情况</h2>
<ul>
<li>服务端启动: <code>./server -s xxx.xxx.xxx.xxx:8972</code> // xxx.xxx.xxx.xxx是服务端监听的IP地址</li>
<li>客户端测试: <code>./client -c 2000 -n 1000000 -s xxx.xxx.xxx.xxx:8972</code> // 这里的并发数是2000, 测试总共发送1百万个请求</li>
</ul>
<p>测试原始数据: </p>
<iframe width="700" height="300" frameborder="0" scrolling="no" src="https://onedrive.live.com/embed?resid=CD09EE1AE0AE8966%211237&authkey=%21ALkUD_tZUvdczJ8&em=2&wdAllowInteractivity=False&wdDownloadButton=True&wdInConfigurator=True&wdInConfigurator=True&edesNext=false&ejss=false"></iframe>


<h3 id="吞吐量">吞吐量</h3>
<p><img src="1.png" alt=""><br>Y轴是吞吐量/秒，越高越好。可以看到arpc框架吞吐非常的好，去年的测试也是arpc表现比较好，其次是rpcx、标准的rpc、kitex、grpc。</p>
<p>可以看到在并发量比较大的情况下，除了grpc， 其它都能达到18万个请求/秒的吞吐量。</p>
<h3 id="平均延迟">平均延迟</h3>
<p><img src="2.png" alt=""><br>Y轴是平均延迟，越低越好，可以看到grpc的延迟较高。延迟正好和上面的吞吐量相反。</p>
<h3 id="P99-9_延迟">P99.9 延迟</h3>
<p>另外一个我们可能比较关注长尾的情况，可以选取中位数或者p99.9观察。 下面是p99.9的情况。<br><img src="3.png" alt=""></p>
<p>当然，并发数为5000的情况下比较是无意义的，因为在并发数为5000的情况下，各框架的吞吐量是不一样的，在吞吐量高的情况下延迟也会大。<br>所以为了在公平的情况下观察长尾情况，我设计了下面的测试。</p>
<h2 id="场景二:_TCP连接数为10,并发数伟200,长连接。_吞吐量为10万/秒、15万/秒、18万/秒的情况下的延迟">场景二: TCP连接数为10,并发数伟200,长连接。 吞吐量为10万/秒、15万/秒、18万/秒的情况下的延迟</h2>
<p>为了观察延迟，我们需要保证吞吐量都尽量一样，在相同的吞吐量情况下观察延迟和长尾情况更科学。</p>
<p>所以场景二就是在并发数为200的情况下，针对吞吐量为10万/秒、15万/秒、18万/秒三个场景，观察框架的延迟和P99.9延迟。</p>
<p>测试原始数据: </p>
<iframe width="700" height="346" frameborder="0" scrolling="no" src="https://onedrive.live.com/embed?resid=CD09EE1AE0AE8966%211240&authkey=%21AH7IxJNptuzNIRI&em=2&wdAllowInteractivity=False&wdDownloadButton=True&wdInConfigurator=True&wdInConfigurator=True&edesNext=false&ejss=false"></iframe>

<h3 id="平均延迟-1">平均延迟</h3>
<p><img src="4.png" alt=""><br>平均延迟看起来grpc比较高，因为它达不到18万/秒的吞吐，所以它的最后一个数值是没有的。kitex相对较高，这个还得具体看是不是kitex有一些具体的调优。 基本上是和吞吐量成负相关的。</p>
<h3 id="P99-9_延迟-1">P99.9 延迟</h3>
<p>长尾的情况，下面是p99.9的情况。<br><img src="5.png" alt=""></p>
<p>arpc、rpcx和标准rpc的P99.9延迟还是比较好的。</p>
<h2 id="场景三:_TCP连接数为1000，并发数为1000，长连接。">场景三: TCP连接数为1000，并发数为1000，长连接。</h2>
<p>观察在大量连接情况下各框架的表现(吞吐率和延迟)。这个场景并没有选择巨量的连接数，而是选择了一个较常见的1000的连接数做测试，连接伟长连接。</p>
<p><img src="6.png" alt=""></p>
<p>arpc在连接数比较多的情况下明显要浩好于其它框架，其次就是rpcx和标准rpc框架。</p>
<p>平均耗时和P99.9耗时也符合这个情况，具体原始数据参考</p>
<iframe width="700" height="346" frameborder="0" scrolling="no" src="https://onedrive.live.com/embed?resid=CD09EE1AE0AE8966%211242&authkey=%21ADlRyez3xISIKx4&em=2&wdAllowInteractivity=False&wdDownloadButton=True&wdInConfigurator=True&wdInConfigurator=True&edesNext=false&ejss=false"></iframe>


<p>总体来看，rpcx的性能还是不错的，希望在以后的日子，参考兄弟rpc框架，做进一步的优化。<br>h欢迎在<a href="https://colobu.com/2022/07/31/2022-rpc-frameworks-benchmarks/" target="_blank" rel="external">本文留言区</a>进行探讨。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>距离上一次<a href="https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/" target="_blank" rel="external">2021年Go生态圈rpc框架benchmark</a>的测试整整一年了。一年来，各个RPC框架也获得长足的进展，<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>也在众多网友的支持下做了一些有益的优化和精简，所以是时候再做一次国内几个常用框架的性能比较了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 垃圾回收器指南]]></title>
    <link href="https://colobu.com/2022/07/16/A-Guide-to-the-Go-Garbage-Collector/"/>
    <id>https://colobu.com/2022/07/16/A-Guide-to-the-Go-Garbage-Collector/</id>
    <published>2022-07-16T06:37:59.000Z</published>
    <updated>2022-07-25T12:19:30.941Z</updated>
    <content type="html"><![CDATA[<p>Go官方原文: <a href="https://tip.golang.org/doc/gc-guide?continueFlag=bf311ba190bf0d160b5d3461e092f0f4" target="_blank" rel="external">A Guide to the Go Garbage Collector</a></p>
<a id="more"></a>
<h2 id="简介">简介</h2>
<p>本指南旨在帮助高级Go语言用户更好地了解Go语言垃圾回收器的使用成本。 它还提供了Go用户如何利用这些知识来提高应用程序的资源利用率的指导。 它并不假设你了解垃圾回收，但假设你熟悉Go语言。</p>
<p>Go语言负责安排Go语言值的存储。在大多数情况下，Go语言开发人员根本不需要关心这些值存储在哪里，或者为什么要存储。 然而，在实践中，这些值通常需要存储在计算机<strong>物理内存</strong>中，而物理内存是有限的资源。 因为内存是有限的，所以必须小心地管理和回收内存，以避免在执行Go语言程序时耗尽内存。 Go语言的工作就是根据需要分配和回收内存。</p>
<p>自动回收内存的另一个说法是<strong>垃圾回收</strong>。 从较高的层次上讲，垃圾回收器（或简称为GC）是一个系统，这个系统通过标识内存的哪些部分不再需要来代表应用程序回收内存。 Go语言的标准工具链提供了一个运行时库，它随每个应用程序一起提供，并且这个运行时库包含了一个垃圾回收器。</p>
<p>请注意，Go语言规范并不能保证本指南所描述的垃圾回收器的存在，只不过Go语言本身负责管理Go语言值的底层存储。 这一省略是有意的，并允许使用完全不同的内存管理技术。</p>
<p>因此，本指南是关于Go语言的一个具体实现的指导，可能不适用于其他实现。 具体来说，本指南适用于标准工具链（gc Go compiler和工具）。 Gccgo和Gollvm都使用非常相似的GC实现，因此许多相同的概念都适用，但细节可能会有所不同。</p>
<p>此外，这是一个一直在修正的文档，随着时间的推移而变化，以最好地反映Go语言的最新版本。 本文档目前描述的是Go语言1.19中的垃圾回收器。</p>
<h3 id="价值所在">价值所在</h3>
<p>在深入研究GC之前，让我们首先讨论一下不需要由GC管理的内存。</p>
<p>例如，存储在局部变量中的非指针Go语言的值可能根本不会被Go语言的GC管理，Go语言会安排内存的分配，并将其绑定到创建它的<a href="https://go.dev/ref/spec#Declarations_and_scope" target="_blank" rel="external">词法作用域</a>中。 一般来说，这比依赖GC更有效率，因为Go语言编译器能够预先确定何时释放内存，并发出清理内存的机器指令。 通常，我们把这种为Go语言的值分配内存的方式称为“<strong>栈分配</strong>”，因为空间存储在goroutine栈中。</p>
<p>如果Go语言的值不能以这种方式分配内存，则Go语言编译器无法确定它的生存期，那么这些值就被称为“<strong>逃逸到堆</strong>”。 “堆”可以被认为是内存分配的一个大杂烩，Go语言的值需要被放置在堆的某个地方。 在堆上分配内存的操作通常称为“动态内存分配”，因为编译器和运行库都很少会对如何使用内存以及何时可以清理内存做出假设。 这就是GC的用武之地：它是一个专门标识和清理动态内存分配的系统。</p>
<p>Go语言的值需要逃逸到堆中的原因有很多。 一个原因可能是其大小是动态确定的。 例如，考虑一个切片的支持数组，它的初始大小由一个变量而不是一个常量确定。 请注意，逃逸到堆也必须是可传递的：如果一个Go值的引用被写入到另一个已经被确定为逃逸的Go值中，那么这个值也必须逃逸。</p>
<p>Go语言的值是否逃逸取决于使用它的上下文和Go语言编译器的逃逸分析算法。 当价值观逃逸时，试图准确地列举它将是脆弱和困难的：算法本身相当复杂，并且在不同的Go语言版本中会有所变化。 有关如何识别哪些值逃逸而哪些值不逃逸的详细信息，请参阅<a href="https://tip.golang.org/doc/gc-guide#Eliminating_heap_allocations" target="_blank" rel="external">消除堆分配</a>一节。</p>
<h3 id="跟踪垃圾回收">跟踪垃圾回收</h3>
<p>垃圾回收可能指自动回收内存的众多实现方法，例如引用计数。 在本文档的上下文中，垃圾回收指的是跟踪垃圾回收，其通过循着指针来标识正在使用的、所谓的活动对象。</p>
<p>让我们更严格地定义这些术语:</p>
<ul>
<li><strong>对象</strong> - 对象是一个动态分配的内存块，包含一个或多个Go值。</li>
<li><strong>指针</strong> - 指向对象内任何值的内存地址。 这自然包括 <code>*T</code> 形式的Go语言值，但也包括部分内置Go语言值。 字符串、切片、通道、map和接口值都包含GC必须跟踪的内存地址。</li>
</ul>
<p>对象和指向其他对象的指针一起形成<strong>对象图</strong>。 为了识别活动内存，GC从程序的<strong>根</strong>开始遍历对象图，程序明确使用的对象的指针。 根的两个例子是局部变量和全局变量。 遍历对象图的过程被称为<strong>扫描</strong>。</p>
<p>此基本算法对所有跟踪GC通用。 跟踪GC的不同之处在于，一旦它们发现内存是活的，它们会做什么。 Go语言的GC使用了<strong>标记(mark)</strong>—<strong>清除(sweep)</strong>技术，这意味着为了跟踪它的过程，GC也会将它遇到的值<strong>标记</strong>为活动的。 跟踪完成后，GC将遍历堆中的所有内存，并使所有未标记的对象的内存设置为可用于分配的内存。 此过程称为<strong>扫描(scanning)</strong>。</p>
<p>您可能熟悉的另一种技术是将对象实际移动到内存的新部分，并留下一个转发指针，以后将使用该指针更新应用程序的所有指针。 我们称以这种方式移动对象的GC为<strong>移动GC</strong>; Go的GC不是这样子的，它是<strong>非移动GC</strong>。</p>
<h2 id="GC循环">GC循环</h2>
<p>由于Go GC是一个标记—清除GC，因此它大致分为两个阶段：<strong>标记阶段</strong>和<strong>清扫阶段</strong>。 虽然这句话似乎是重复的，但它包含了一个重要的见解：在跟踪完所有内存之前，不可能释放内存以供分配，因为可能仍有未扫描的指针使对象保持活动状态。 因此，清扫动作必须与标记动作完全分开。 此外，当没有与GC相关的工作要做时，GC也可能根本不活动。 GC在离开(off)、标记和扫描这三种状态之间不断循环，这就是所谓的GC循环。</p>
<p>接下来的几个章节我们将集中讨论如何直观地了解GC的成本，以帮助用户调整GC参数，从而为自己谋福利。</p>
<h2 id="了解成本">了解成本</h2>
<p>GC本质上是一个构建在更复杂系统上的复杂软件。 当试图理解GC并调整其行为时，很容易陷入细节的泥潭。 本节旨在提供一个框架，用于说明Go GC的开销和调优参数。</p>
<p>开始讨论前，先了解基于四个简单公理的GC成本模型。</p>
<ol>
<li>在GC执行时，应用程序会暂停。</li>
<li>GC只涉及两种资源：CPU时间和物理内存。</li>
<li>GC的内存开销包括活动堆内存、标记阶段之前分配的新堆内存，以及元数据空间（即使与前两个的开销成比例，但相比之下元数据空间开销也很小）。<blockquote>
<p>注意：活动堆内存是由上一个GC周期确定为活动的内存，而新堆内存是在当前周期中分配的任何内存，在结束时可能是活动的，也可能不是活动的。</p>
</blockquote>
</li>
<li>GC的CPU成本被建模为每个周期的固定成本，以及与活动堆的大小成比例的边际成本(marginal cost)。<blockquote>
<p>注意：从渐进的角度来说，清扫的伸缩性比标记和扫描要差，因为它必须执行与整个堆的大小成比例的工作，包括被确定为非活动（即“死”）的内存。 然而，在当前的实现中，清扫操作比标记和扫描快得多，因此在本讨论中可以忽略其相关成本。</p>
</blockquote>
</li>
</ol>
<p>这种模型简单而有效：它准确地对GC的主要成本进行了分类。 然而，这个模型没有说明这些成本的规模，也没有说明它们是如何相互作用的。 为了对此建模，考虑以下情况，我们称这种场景为<strong>稳态</strong>(steady-stat)。</p>
<ul>
<li><p>应用程序分配新内存的速率（以字节/秒为单位）是恒定的。</p>
<blockquote>
<p>注意：重要的是要理解这个分配率与这个新内存是否是活动的完全无关。 没有一个是活的，所有的都是活的，或者一部分是活的都有可能。 (除此之外，一些旧的堆内存也可能死亡，因此，如果该内存是活动的，活动堆大小不一定会增长。）<br>更具体地说，假设有一个web服务为它处理的每个请求分配2 MiB的总堆内存。 在请求过程中，2 MiB中最多有512 KiB在请求进行期间保持活动状态，当服务完成对请求的处理时，所有这些内存都会死亡。 稳定的请求流（比如每秒100个请求）会产生200 MiB/s的分配率和50 MiB的峰值活动堆。</p>
</blockquote>
</li>
<li><p>应用程序的对象图每次看起来都大致相同（对象的大小相似，指针的数量大致恒定，图的最大深度大致恒定）。<br>另一种思考方式是GC的边际成本是恒定的。</p>
</li>
</ul>
<blockquote>
<p>注意：稳态可能看起来是人为的，但它的确代表了应用程序在某个恒定工作负载下的行为。 当然，在应用程序执行时，工作负载也可能发生变化，但通常应用程序行为看起来总体上像是一串稳定状态，中间穿插着一些瞬态行为。</p>
</blockquote>
<blockquote>
<p>注意：稳定状态对活动堆没有任何假设。 它可能会随着每个后续GC周期而增长，可能会缩小，也可能会保持不变。 然而，试图在下面的解释中包含所有这些情况很无聊乏味，而且不是很有说明性，所以本指南将重点放在活动堆保持不变的示例上。 GOGC一节会更详细地探讨了非常量活动堆的场景。</p>
</blockquote>
<p>在活动堆大小不变的稳定状态下，只要GC在经过相同的时间后执行，每个GC周期在成本模型中看起来都是相同的。 这是因为在固定的时间内，如果应用程序的分配速率是固定的，则将分配固定数量的新堆内存。 因此，在活动堆大小和新堆内存保持不变的情况下，内存使用量将始终保持不变。 而且因为活动堆的大小相同，所以边际GC CPU成本也相同，并且固定成本将以某个固定间隔发生。</p>
<p>现在考虑GC如果延迟，发生在稍后时间应该运行的点之后， 因此将分配更多的内存，但每个GC周期仍将导致相同的CPU开销。 但是，在其他固定的时间窗口中，完成的GC周期会更少，从而降低了总体CPU成本。 如果GC决定提前启动，则情况正好相反：将分配较少的内存并且将更频繁地引起CPU成本。</p>
<p>这种情况代表了GC可以在CPU时间和内存之间进行的基本权衡，由GC实际执行的频率来控制。 换句话说，折衷完全由GC的频率定义。</p>
<p>还有一个细节需要定义，那就是GC应该决定何时开始。 注意，这直接设置了任何特定稳态下的GC频率，从而定义了折衷。 在Go语言中，决定GC何时启动是用户可以控制的主要参数。</p>
<h2 id="GOGC">GOGC</h2>
<p>GOGC是Go GC的一个调优参数，它通过控制GC频率直接反映了CPU时间和内存之间的平衡。 更具体地说，GOGC设置GC的目标堆大小，或者在标记阶段完成之前应该分配的新内存量。 GOGC被定义为GC需要完成的工作量的百分比开销。 这项工作目前被定义为活动堆的大小加上GC根的大小（以字节为单位）。</p>
<p>举个例子，假设一个Go语言程序，它有8 MiB的堆，1 MiB的goroutine栈，1 MiB的全局变量指针。 如果GOGC值为100，则在下一次GC运行之前将分配的新内存量将为10 MiB，或10 MiB工作量的100%，总堆占用量为18 MiB。 如果GOGC值为50，则它将为50%，即分配的新内存量为5 MiB。 如果GOGC值为200，则为200%，即分配的新内存量20 MiB。</p>
<blockquote>
<p>注意：GOGC可以更精确地描述为定义在下一个扫描阶段开始之前可以分配的新内存量。 从技术上讲，这个记时对于本指南目前使用的GC模型来说是正确的，但是它也适用于Go语言使用的真实GC实现，在延迟一节中会有更详细的讨论。</p>
</blockquote>
<p>以这种方式定义权衡(trade-off)的好处是，无论GC必须完成的工作量如何（也就是说，无论活动堆和根集的大小如何），GC的成本在稳态下都保持不变，因为频率总是与必须完成的工作量成比例。 换句话说，它代表了CPU成本和内存使用之间权衡的一个固定点。 (需要注意的是，如果稳定状态也发生变化，则此固定点也可能发生偏移，但关键是它不依赖于活动堆的大小。）</p>
<blockquote>
<p>注意：GOGC 自Go 1.18开始包含根集， 以前它只对活动堆进行计数。 通常，goroutine堆栈中的内存量非常小，并且活动堆的大小支配着GC的所有其他工作来源, (所以先前的计算大概也没问题,) 但是当程序有几十万个goroutine时，GC会做出错误的判断。</p>
</blockquote>
<p>GOGC可以通过GOGC环境变量（所有Go语言程序都能识别）或者<code>runtime/debug</code>包中的<code>SetGCPercent</code> API来配置。</p>
<blockquote>
<p>请注意，GOGC也可用于通过设置<code>GOGC=off</code>或调用<code>SetGCPercent(-1)</code>来完全关闭GC（前提是memory limit没有使用）。 从概念上讲，此设置等效于将GOGC设置为无穷大值，因为在触发GC之前新内存的数量是无限的。</p>
</blockquote>
<p>为了更好地理解我们到目前为止讨论的所有内容，请尝试下面的交互式可视化，它是基于前面讨论的GC成本模型构建的。 该可视化描述了某个程序的执行，该程序的非GC工作需要10秒的CPU时间才能完成。 在进入稳定状态之前的第一秒，它执行一些初始化步骤（增长其活动堆）。 应用程序总共分配200 MiB，其中20 MiB一次处于活动状态。 它假设要完成的唯一相关GC工作来自活动堆，并且（不现实地）应用程序不使用额外的内存。</p>
<p>使用滑块调整GOGC的值，以查看应用程序在总持续时间和GC开销方面的响应情况。 每次GC循环都会在新堆降为零时发生。 X轴移动以始终显示程序的完整CPU持续时间。 请注意，GC使用的额外CPU时间会增加总持续时间。</p>
<p><img src="1.png" alt=""></p>
<p>请注意，GC总是会导致一些CPU和峰值内存开销。 随着GOGC的增加，这些CPU开销降低，但峰值内存与活动堆大小成比例增加。 随着GOGC的减小，峰值内存需求也会减少，但会增加额外的CPU开销。</p>
<blockquote>
<p>注意：图形显示的是CPU时间，而不是完成程序所需的挂钟时间(wall-clock time)。 如果程序在1个CPU上运行并充分利用其资源，则它们是等效的。 真实的的程序可能运行在多核系统上，并且不会始终100%地利用CPU。 在这些情况下，GC的挂钟时间影响会比较低。</p>
</blockquote>
<blockquote>
<p>注意：Go GC的最小总堆大小为4 MiB，因此如果GOGC设置的目标值低于该值，则会取整。 这个图形展示反映此细节。</p>
</blockquote>
<p>这里有一个动态的和更有真实感的例子。 同样，在没有GC的情况下，应用程序需要10个CPU秒才能完成，但在中途，稳态分配率急剧增加，并且活动堆大小在第一阶段发生了一些变化。 这个示例演示了当活动堆大小实际上发生变化时，稳定状态可能是什么样子的，以及更高的分配率如何导致更频繁的GC周期。</p>
<p><img src="2.png" alt=""></p>
<h2 id="内存限制_（memory_limit）">内存限制 （memory limit）</h2>
<p>在Go 1.19之前，GOGC是唯一一个可以用来修改GC行为的参数。 虽然它作为一种设置权衡(trade-off)的方式非常有效，但它没有考虑到可用内存是有限的。 考虑当活动堆大小出现短暂峰值时会发生什么情况：因为GC将选择与活动堆大小成比例的总堆大小，所以GOGC必须被配置为峰值活动堆大小相匹配的值，即使在通常情况下，较高的GOGC值会提供了更好的权衡效果。</p>
<p>下面的可视化演示了这种瞬态堆峰值情况。</p>
<p><img src="3.png" alt=""></p>
<p>如果示例工作负载在可用内存略高于60 MiB的容器中运行，则GOGC不能增加到100以上，即使其余GC周期有可用内存来使用该额外内存。 此外，在一些应用中，这些瞬时峰值可能是罕见的并且难以预测，从而导致偶然的、不可避免的并且可能代价高昂的内存不足情况。</p>
<p>这就是为什么在1.19版本中，Go语言增加了对设置运行时内存限制的支持。 内存限制可以通过所有Go语言程序都能识别的<strong>GOMEMLIMIT</strong>环境变量来配置，也可以通过<code>runtime/debug</code>包中的<code>SetMemoryLimit</code>函数来配置。</p>
<p>这个内存限制设置了Go语言运行时可以使用的最大内存总量。 包含的特定内存集是<code>runtime.MemStats</code>的<code>Sys - HeapReleased</code>的值，或者等价于<code>runtime/metrics</code>的公式<code>/memory/classes/total:bytes - /memory/classes/heap/released:bytes</code>。</p>
<p>因为Go GC可以显式控制它使用多少堆内存，所以它会根据这个内存限制和Go运行时使用的其他内存来设置总的堆大小。</p>
<p>下面的可视化描述了来自GOGC部分的相同的单阶段稳态工作负载，但这次Go运行时额外增加了10 MiB的开销，并且内存限制可调。 尝试在GOGC和内存限制之间移动，看看会发生什么。</p>
<p><img src="4.png" alt=""></p>
<p>请注意，当内存限制降低到GOGC确定的峰值内存（GOGC为100时为42 MiB）以下时，GC会更频繁地运行，以将峰值内存保持在限制的内存之下。</p>
<p>回到我们前面的瞬态堆峰值的例子，通过设置内存限制并打开GOGC，我们可以获得两个世界的最佳结果：不违反内存限制，且更好地节约资源。 请尝试以下交互式可视化。</p>
<p><img src="5.png" alt=""></p>
<p>请注意，对于GOGC的某些值和内存限制，峰值内存使用在内存限制为多少时停止，但程序执行的其余部分仍然遵守GOGC设置的总堆大小规则。</p>
<p>这一观察引出了另一个有趣的细节：即使GOGC设置为关闭，内存限制仍然有效! 实际上，这种特定的配置代表了资源经济的最大化，因为它设置了维持某个内存限制所需的最小GC频率。 在这种情况下，所有程序的执行都会使堆大小增加以满足内存限制。</p>
<p>现在，虽然内存限制显然是一个强大的工具，<strong>但使用内存限制并不是没有代价的</strong>，当然也不会使GOGC的实用性失效。</p>
<p>请考虑当活动堆增长到足以使总内存使用量接近内存限制时会发生什么。 在上面的稳定状态可视化中，尝试关闭GOGC，然后慢慢地进一步降低内存限制，看看会发生什么。 请注意，应用程序花费的总时间将开始以无限制的方式增长，因为GC不断地执行以维持不可能的内存限制。</p>
<p>这种情况，即程序由于不断的GC循环而无法取得合理的进展，称为系统颠簸(thrashing)。 这是特别危险的，因为它严重地拖延了程序。 更糟糕的是，它可能会发生在我们试图避免使用GOGC的情况下：一个足够大临时堆尖峰会导致程序无限期地停止! 尝试在瞬态堆峰值可视化中降低内存限制（大约30 MiB或更低），并注意最坏的行为是如何从堆峰值开始的。</p>
<p>在许多情况下，无限期暂停比内存不足情况更糟，因为后者往往会导致更快的失败以便我们发现和处理。</p>
<p>因此，内存限制被定义为软限制。 Go语言运行时并不保证在任何情况下都能保持这个内存限制;它只承诺了一些合理的努力。 内存限制的放宽对于避免系统颠簸行为至关重要，因为它为GC提供了一条出路：让内存使用超过限制以避免在GC中花费太多时间。</p>
<p>这在内部是如何工作的？GC mitigates 设置了一个在某个时间窗口内可以使用的CPU时间量的上限（对于CPU使用中非常短的瞬时峰值，有一些滞后）。 此限制当前设置为大约50%，具有<code>2 * GOMAXPROCS CPU-second</code>窗口。 限制GC CPU时间的结果是GC的工作被延迟，同时Go程序可能会继续分配新的堆内存，甚至超过内存限制。</p>
<p>50% GC CPU限制背后的直觉是基于对具有充足可用内存的程序的最坏情况影响。 在内存限制配置错误的情况下，它被错误地设置得太低，程序最多会慢2倍，因为GC占用的CPU时间不能超过50%。</p>
<p>注意：此页上的可视化不会模拟GC CPU限制。</p>
<h3 id="建议用法">建议用法</h3>
<p>虽然内存限制是一个强大的工具，Go语言运行时也会采取措施来减少误用造成的最坏行为，但谨慎使用它仍然很重要。 下面是一些关于内存限制在哪些地方最有用，以及在哪些地方可能弊大于利的建议。</p>
<ul>
<li><p>当Go语言程序的执行环境完全在你的控制之下，并且Go语言程序是唯一可以访问某些资源的程序时（也就是说，某种内存预留，就像容器内存限制一样），一定要利用内存限制。<br>一个很好的示例是将web服务部署到具有固定可用内存量的容器中。<br><strong>在这种情况下，一个很好的经验法则是，留出额外的5-10%的空间来处理Go语言运行时不知道的内存资源。</strong></p>
</li>
<li><p>请随时调整内存限制，以适应不断变化的条件。<br>一个很好的例子是cgo程序，其中C库暂时需要使用更多的内存。</p>
</li>
<li><p>如果Go语言程序可能会与其他程序共享有限的内存，那么不要将GOGC设置为off，因为这些程序通常与Go语言程序是解耦的。 相反，保留内存限制，因为它可能有助于抑制不需要的瞬态行为，但将GOGC设置为某个较小的、对于一般情况而言合理的值。</p>
</li>
</ul>
<p>虽然尝试为共享程序“保留”内存是很诱人的，但除非程序完全同步（例如，Go程序在被调用程序执行时调用某些子进程和阻塞），否则结果将不太可靠，因为两个程序都不可避免地需要更多内存。 让Go程序在不需要内存的时候使用更少的内存，总体上会产生更可靠的结果。 此建议也适用于过量使用的情况，在这种情况下，在一台计算机上运行的容器的内存限制之和可能会超过该计算机可用的实际物理内存。</p>
<ul>
<li><p>当部署到您无法控制的执行环境时，不要使用内存限制，特别是当程序的内存使用与其输入成比例时。<br>CLI工具或桌面应用程序就是一个很好的例子。 在不清楚可能输入什么类型的输入，或者系统上可能有多少可用内存时，将内存限制写入程序可能会导致混乱的崩溃和性能下降。 此外，高级最终用户可以根据需要设置内存限制。</p>
</li>
<li><p>当程序已经接近其环境的内存限制时，不要设置内存限制以避免内存不足的情况。</p>
</li>
</ul>
<p>这有效地将内存不足的风险替换为严重的应用程序速度减慢的风险，这通常不是一个有利的交易，即使Go语言努力减轻系统颠簸。 在这种情况下，提高环境的内存限制（然后可能设置内存限制）或降低GOGC（这提供了比系统颠簸缓解更干净的权衡）将更加有效。</p>
<h3 id="延迟时间">延迟时间</h3>
<p>到目前为止，本文将应用程序建模在在GC执行时会暂停这一公理上。 确实存在这样的GC实现，它们被称为<strong>stop-the-world</strong> GC。</p>
<p>然而，Go GC并不是完全停止工作，实际上它的大部分工作都是与应用程序同时进行的。 这样做的主要原因是它减少了应用程序延迟。 具体来说，延迟是指单个计算单元（例如，web请求）的端到端持续时间。 到目前为止，本文主要考虑应用程序吞吐量，或这些操作的聚合（例如，每秒处理的web请求）。 请注意，GC周期部分中的每个示例都侧重于执行程序的总CPU持续时间。 然而，这样的持续时间对于例如web服务来说意义要小得多，web服务的持续时间主要捕获可靠性（即uptime）而不是成本。 虽然吞吐量（即每秒的查询数）对于web服务仍然很重要，但通常每个单独请求的延迟甚至更重要，因为它与其他重要指标相关。</p>
<p>就延迟而言，stop-the-world GC可能需要相当长的时间来执行其标记和扫描阶段，在此期间，应用程序以及在web服务的上下文中的任何正在进行的请求都无法取得进一步的进展。 相反，Go GC确保了任何全局应用程序暂停的长度都不会以任何形式与堆的大小成比例，并且在应用程序主动执行的同时执行核心跟踪算法。 这种选择并非没有成本，因为在实践中，它往往会导致吞吐量较低的设计，但需要注意的是，低延迟并不必然意味着低吞吐量，即使在许多情况下，这两者并不一致。</p>
<p>首先，Go GC的并发特性可能看起来与前面介绍的成本模型有很大的不同。 幸运的是，模型背后的直觉仍然适用。</p>
<p>虽然第一条公理不再成立，但它开始并不是那么重要;其余的成本仍然如模型所描述的那样，并且使用相同的稳态概念。 因此，GC频率仍然是GC在CPU时间和内存吞吐量之间进行权衡的主要方式，它还承担了延迟的角色。 关于吞吐量，只要假设并发GC所产生的所有小开销都发生在GC周期的末尾，就很容易回到模型的范围内。 关于延迟，GC增加的延迟中的大部分特别来自标记阶段处于活动状态的时间段。 因此，GC处于标记阶段的频率越高，这些成本就越频繁地发生，因此等待时间也跟随GC频率。</p>
<p>更具体地，调整GC参数以降低GC频率也可以导致延迟改善。 这意味着需要增加GOGC和/或内存限制。</p>
<p>然而，理解延迟通常比理解吞吐量更复杂，因为它是程序即时执行的产物，而不仅仅是成本的聚合之物。 因此，延迟和GC频率之间的联系更加脆弱，可能不那么直接。 下面是一个可能导致延迟的来源列表，供那些倾向于深入研究的人使用。 这些延迟源在执行跟踪中是可见的。</p>
<ul>
<li>当GC在标记和清除阶段之间转换时，</li>
<li>调度延迟是因为GC在标记阶段占用了25%的CPU资源，</li>
<li>用户goroutine贡献出来以便辅助GC处理高内存分配率</li>
<li>当GC处于标记阶段时，指针写入需要额外的处理。</li>
<li>运行中的goroutine必须被暂停，以便扫描它们的根。</li>
</ul>
<h3 id="其他资源">其他资源</h3>
<p>虽然上面提供的信息是准确的，但它缺乏充分理解Go GC设计中的成本和权衡的细节。 有关详细信息，请参阅以下其他资源。</p>
<ul>
<li><a href="https://tip.golang.org/doc/gc-guide#:~:text=following%20additional%20resources.-,The%20GC%20Handbook,-%E2%80%94An%20excellent%20general" target="_blank" rel="external">The GC Handbook</a> — 一个垃圾收集器设计的优秀通用资源和参考资料。</li>
<li><a href="https://google.github.io/tcmalloc/design.html" target="_blank" rel="external">TCMalloc</a> — C/C++内存分配器TCMalloc的设计文档，Go内存分配器就是基于此。</li>
<li><a href="https://go.dev/blog/go15gc" target="_blank" rel="external">Go 1.5 GC announcement</a> — 官方介绍Go 1.5并发GC的博客文章，其中更详细地描述了算法。</li>
<li><a href="https://go.dev/blog/ismmkeynote" target="_blank" rel="external">Getting to Go</a> — 深入介绍Go GC设计到2018年的演变</li>
<li><a href="https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit" target="_blank" rel="external">Go 1.5 concurrent GC pacing</a> — 确定何时开始并发标记阶段的设计文档</li>
<li><a href="https://github.com/golang/go/issues/30333" target="_blank" rel="external">Smarter scavenging</a> — 订正Go运行时向操作系统返回内存的方式的设计文档</li>
<li><a href="https://github.com/golang/go/issues/35112" target="_blank" rel="external">Scalable page allocator</a> — 订正Go运行时管理其从操作系统获得的内存的方式的设计文档</li>
<li><a href="https://github.com/golang/go/issues/44167" target="_blank" rel="external">GC pacer redesign (Go 1.18)</a> — 用于修改算法以确定何时开始并发标记阶段的设计文件</li>
<li><a href="https://github.com/golang/go/issues/48409" target="_blank" rel="external">Soft memory limit (Go 1.19)</a> — 软内存限制的设计文件</li>
</ul>
<h2 id="关于虚拟内存注意事项">关于虚拟内存注意事项</h2>
<p>本指南主要关注GC的物理内存使用，但经常出现的一个问题是你到底想说个啥，以及它与虚拟内存的比较（通常在像top这样的程序中表示为“VSS”）。</p>
<p>物理内存是大多数计算机中实际物理RAM芯片中的内存。 虚拟内存是由操作系统提供的物理内存上的抽象，用于将程序彼此隔离。 程序保留完全不映射到任何物理地址的虚拟地址空间通常也是可以接受的。</p>
<p><strong>由于虚拟内存只是操作系统维护的映射，因此保留不映射到物理内存的大型虚拟内存通常非常便宜。</strong></p>
<p>Go语言运行时通常在以下几个方面依赖于这种虚拟内存开销视图：</p>
<ul>
<li><p>Go语言运行时不会删除它所映射的虚拟内存。 相反，它使用大多数操作系统提供的特殊操作来显式释放与某个虚拟内存范围相关联的任何物理内存资源。<br>该技术被显式地用于管理内存限制，并将Go语言运行时不再需要的内存返回给操作系统。 Go运行时也会在后台连续释放不再需要的内存。 有关详细信息，请参阅其他资源。</p>
</li>
<li><p>在32位平台上，Go运行时会为堆预留128 MiB到512 MiB的地址空间，以限制碎片问题。</p>
</li>
<li><p>Go语言运行时在实现几个内部数据结构时使用了大量的虚拟内存地址空间预留。 在64位平台上，它们通常具有大约700 MiB的最小虚拟内存占用量。 在32位平台上，它们的占用空间可以忽略不计。</p>
</li>
</ul>
<p>因此，虚拟内存指标，比如top中的“VSS”，在理解Go语言程序的内存占用方面通常不是很有用。 相反，应该关注“RSS”和类似的度量，它们更直接地反映了物理内存的使用情况。</p>
<h2 id="优化指南">优化指南</h2>
<h3 id="确定成本">确定成本</h3>
<p>在尝试优化Go语言应用程序与GC的交互方式之前，首先确定GC是一个主要的开销，这一点很重要。</p>
<p>Go生态系统提供了大量的工具来识别成本和优化Go应用程序。 有关这些工具的简要概述，请参阅<a href="https://tip.golang.org/doc/diagnostics" target="_blank" rel="external">诊断指南</a>。 在这里，我们将重点讨论这些工具的一个子集，以及应用它们的合理顺序，以便理解GC的影响和行为。</p>
<p><strong> 1、CPU profile</strong></p>
<p>优化程序的一个很好的起点是<a href="https://pkg.go.dev/runtime/pprof#hdr-Profiling_a_Go_program" target="_blank" rel="external">CPU profiling</a>。 CPU profiling提供了CPU时间花费在何处的概述，尽管对于未经训练的眼睛来说，可能很难确定GC在特定应用程序中所起作用的大小。 幸运的是，理解profile的GC主要归结为了解<code>runtime</code>包中不同函数的含义即可。 以下是这些函数中用于解释CPU profile文件的有用子集。</p>
<blockquote>
<p>注意：下面列出的函数不是叶函数，因此它们可能不会显示在pprof工具为top命令提供的默认值中。 相反，使用<code>top cum</code>命令或直接对这些函数使用<code>list</code>命令，并将注意力集中在累计百分比列上。</p>
</blockquote>
<ul>
<li><strong>runtime.gcBgMarkWorker</strong>: 专用标记工作goroutine的入口点。 这里花费的时间与GC频率以及对象图的复杂性和大小成比例。 它表示应用程序标记和扫描所用时间的基准。</li>
</ul>
<p>注意：在一个大部分时间都处于空闲状态的Go应用程序中，Go GC会消耗额外的（空闲的）CPU资源来更快地完成任务。 结果，该符号可以表示它认为是免费采样部分。 一个常见的原因是，一个应用程序完全在一个goroutine中运行，但是GOMAXPROCS &gt; 1。</p>
<ul>
<li><p><strong>runtime.mallocgc</strong>:堆内存的内存分配器的入口点。 此处花费的大量累积时间（&gt; 15%）通常表示分配了大量内存。</p>
</li>
<li><p><strong>runtime.gcAssistAlloc</strong>: goroutine进入这个函数是为了腾出一些时间来帮助GC进行扫描和标记。 这里花费的大量累积时间（&gt; 5%）表明应用程序在分配速度方面可能超过了GC。 它表示GC的影响程度特别高，并且还表示应用程序在标记和扫描上花费的时间。 请注意，它包含在<code>runtime.mallocgc</code>调用树中，因此它也会使该调用树累计时间增加。</p>
</li>
</ul>
<p><strong>2、执行跟踪</strong></p>
<p>虽然CPU profile文件非常适合用于确定时间在聚合中的花费点，但对于指示更细微、更罕见或与延迟具体相关的性能成本，它们的用处不大。 另一方面，执行跟踪提供了Go语言程序执行的一个短窗口的丰富而深入的视图。 它们包含了与Go GC相关的各种事件，可以直接观察到具体的执行路径，沿着应用程序与Go GC的交互方式。 所有被跟踪的GC事件都在跟踪查看器中被方便地标记为GC事件。</p>
<p>有关如何开始使用执行跟踪的信息，请参阅 <a href="https://pkg.go.dev/runtime/trace" target="_blank" rel="external">runtime/trace</a> 的文档。</p>
<p><strong> 3、GC跟踪</strong></p>
<p>当所有其他方法都失败时，Go GC还提供了一些不同的特定跟踪，这些跟踪提供了对GC行为的更深入的了解。 这些踪迹总是被直接打印到 STDERR 中，每个GC循环一行，并且通过所有Go语言程序都能识别的 GODEBUG 环境变量来配置。 它们主要用于调试Go GC本身，因为它们需要对GC实现的细节有一定的了解，但是偶尔也可以用于更好地理解GC的行为。</p>
<p>通过设置<code>GODEBUG=gctrace=1</code>，可以启用核心GC跟踪。 此跟踪生成的输出记录在<a href="https://pkg.go.dev/runtime#hdr-Environment_Variables" target="_blank" rel="external">runtime</a>包文档的环境变量部分中。</p>
<p>一个称为<code>pacer trace</code>的技术用来补充GC跟踪，提供了更深入的见解，它通过设置<code>GODEBUG=gcpacertrace=1</code>来启用。 解释这个输出需要理解GC的<code>pacer</code>（参见<a href="https://tip.golang.org/doc/gc-guide#Additional_resources" target="_blank" rel="external">其他参考资料</a>），这超出了本指南的范围。</p>
<h3 id="消除堆分配">消除堆分配</h3>
<p>降低GC成本的一种方法是让GC开始管理较少的值。 下面描述的技术可以带来一些最大的性能改进，因为正如GOGC部分所展示的，Go语言程序的分配率是GC频率的一个主要因素，GC频率是本指南使用的关键成本度量。</p>
<h4 id="堆分析">堆分析</h4>
<p>在确定GC是一个巨大开销的来源之后，消除堆分配的下一步是找出它们中的大多数来自哪里。 为此，内存 profile 文件（实际上是堆内存 profile 文件）非常有用。 请查看<a href="https://pkg.go.dev/runtime/pprof#hdr-Profiling_a_Go_program" target="_blank" rel="external">文档</a>以了解如何开始使用它们。</p>
<p>内存 profile 文件描述了程序堆中分配的来源，并通过分配时的堆栈跟踪来标识它们。 每个内存 profile 文件可以按四种方式分析：</p>
<ul>
<li>inuse_objects - 活动对象的数量</li>
<li>inuse_space - 按活动对象使用的内存量（以字节为单位</li>
<li>alloc_objects - 自Go程序开始执行以来已经分配的对象数</li>
<li>alloc_space - 自Go程序开始执行以来所分配的内存总量</li>
</ul>
<p>在这些不同的堆内存视图之间切换可以通过pprof工具的 <code>-sample_index</code>标志来完成，或者在交互式使用该工具时通过<code>sample_index</code>选项来完成。</p>
<blockquote>
<p>注意：默认情况下，内存 profile 文件只对堆对象的子集进行采样，因此它们不会包含有关每个堆分配的信息。 但是，这足以找到热点。 若要更改采样率，请参见<a href="https://pkg.go.dev/runtime#pkg-variables" target="_blank" rel="external">runtime.MemProfileRate</a>。</p>
</blockquote>
<p>为了降低GC成本，alloc_space通常是最有用的视图，因为它直接对应于分配率。 此视图将指示可提供最大益处的分配热点。</p>
<h4 id="逃逸分析">逃逸分析</h4>
<p>一旦在<a href="https://tip.golang.org/doc/Heap_profiling" target="_blank" rel="external">堆 profile 文件</a>的帮助下确定了候选堆分配点，如何消除它们？ 关键是要利用Go语言编译器的逃逸分析，让Go语言编译器为这个内存找到替代的、更有效的存储空间，比如在goroutine栈中。 幸运的是，Go语言编译器能够描述为什么要将Go语言的值逃逸到堆中。 有了这些知识，就变成了重新组织源代码以改变分析结果的问题（这通常是最困难的部分，但超出了本指南的范围）。</p>
<p>至于如何从Go语言编译器的逃逸分析中获取信息，最简单的方法是通过Go语言编译器支持的调试标志，该标志以文本格式描述了对某个包应用或未应用的所有优化。 这包括值是否逃逸。 尝试下面的命令，其中<code>package</code>是Go语言包的路径:<br><code>$go build-gcflags=-m=3 软件包</code></p>
<p>此信息也可以在VS代码中可视化为覆盖图。 此覆盖在VS Code Go插件设置中配置和启用:</p>
<ul>
<li>设置<a href="https://github.com/golang/vscode-go/wiki/settings#uicodelenses" target="_blank" rel="external">ui.codelenses设置以包括gc_details</a></li>
<li>通过<a href="https://github.com/golang/vscode-go/wiki/settings#uidiagnosticannotations" target="_blank" rel="external">将ui.diagnostic.annotations设置为包括逃逸，启用逃逸分析的覆盖</a></li>
</ul>
<p>最后，Go编译器以机器可读（JSON）格式提供了这些信息，可以用来构建其他定制工具。 有关这方面的更多信息，请参见<a href="https://cs.opensource.google/go/go/+/master:src/cmd/compile/internal/logopt/log_opts.go;l=25;drc=351e0f4083779d8ac91c05afebded42a302a6893" target="_blank" rel="external">Go语言源代码中的文档</a>。</p>
<h3 id="基于特定实现的优化">基于特定实现的优化</h3>
<p>Go GC对活动内存的人口统计很敏感，因为对象和指针的复杂图既限制了并行性，又为GC生成了更多的工作。 因此，GC包含了一些针对特定公共结构的优化。 下面列出了对性能优化最直接有用的方法。</p>
<blockquote>
<p>注意：应用下面的优化可能会因为混淆意图而降低代码的可读性，并且可能无法在Go语言的各个版本中保持。 希望只在最重要的地方应用这些优化。 可以使用确定成本一节中列出的工具来确定这些地点。</p>
</blockquote>
<ul>
<li>无指针值与其他值分开。</li>
</ul>
<p>因此，从并不严格需要指针的数据结构中消除指针可能是有利的，因为这减少了GC施加在程序上的缓存压力。 因此，依赖于指针值上的索引的数据结构虽然类型化较差，但可能执行得更好。 只有当对象图很复杂并且GC花费大量时间进行标记和扫描时，才值得这样做。</p>
<ul>
<li>GC将在值中的最后一个指针处停止扫描值。</li>
</ul>
<p>因此，将结构类型值中的指针字段分组在值的开头可能是有利的。 只有当应用程序花费大量时间进行标记和扫描时，才值得这样做。 (理论上，编译器可以自动执行此操作，但尚未实现，并且结构字段的排列方式与源代码中所写的相同。）</p>
<p>此外，GC必须与它所看到的几乎每个指针交互，因此，例如，使用切片中的索引而不是指针，可以帮助降低GC成本。</p>
<blockquote>
<p>译者著， 这篇文章， 和Russ Cox的那三遍关于Go内存的模型一样， 里面有众多的未解释的名词，不是那么容易进行翻译，而Go语言规范和Go内存相对就容易理解和翻译了。我之所以尝试翻译，最重要的原因想深入学习本文介绍的相关知识，疏漏之处，欢迎斧正。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go官方原文: <a href="https://tip.golang.org/doc/gc-guide?continueFlag=bf311ba190bf0d160b5d3461e092f0f4" target="_blank" rel="external">A Guide to the Go Garbage Collector</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式系统设计模式]]></title>
    <link href="https://colobu.com/2022/06/26/distributed-system-design-patterns/"/>
    <id>https://colobu.com/2022/06/26/distributed-system-design-patterns/</id>
    <published>2022-06-26T10:27:32.000Z</published>
    <updated>2022-06-26T11:19:54.168Z</updated>
    <content type="html"><![CDATA[<p>原文:<a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="external">Distributed System Design Patterns</a> </p>
<p>与分布式系统相关的常见问题的关键设计模式。<br><a id="more"></a></p>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p>Bloom 过滤器是一种节省空间的概率数据结构，用于测试元素是否为某集合的成员。它用于我们只需要检查元素是否属于对象的场景。</p>
<p><img src="bloom-filter.png" alt=""></p>
<p>在BigTable（和Cassandra）中，任何读取操作都必须从组成Tablet的SSTable中读取。如果这些 SSTable 不在内存中，则读取操作可能最终会执行许多磁盘访问以便读取所需的SSTable。为了减少磁盘访问次数，BigTable 使用 Bloom 过滤器。</p>
<h2 id="一致性哈希">一致性哈希</h2>
<p>一致的哈希允许您轻松扩展，从而允许以有效的方式复制数据，从而实现更好的可用性和容错能力。</p>
<p>通过对数据项的键进行哈希处理以产生其在环上的位置，然后顺时针遍历环以查找位置大于该项位置的第一个节点，将每个由键标识的数据项分配给节点。与节点关联的节点是数据项的位置。</p>
<p><img src="chash.png" alt=""></p>
<p>一致散列的主要优点是增量稳定性;节点离开或到达集群仅影响其直接邻居，其他节点不受影响。</p>
<h2 id="Quorum">Quorum</h2>
<p>在分布式环境中，quorum是在确认操作成功之前需要成功执行此分布式操作的最小服务器数。</p>
<p><img src="quorum.png" alt=""></p>
<p>Cassandra，为了确保数据一致性，每个写入请求都可以配置为仅当数据已写入至少一个quorum（或大多数）副本节点时才成功。</p>
<p>对于领导者选举，Chubby使用Paxos，它使用quorum来确保强大的一致性。</p>
<p>Dynamo 将写入复制到系统中其他节点的草率quorum，而不是像 Paxos 那样的严格多数quorum。所有读/写操作都在首选项列表中的第一个 NN 正常节点上执行，该节点可能并不总是在遍历一致哈希环时遇到的第一个 NN 节点。</p>
<h2 id="领导者(Leader)和追随者(Follower)">领导者(Leader)和追随者(Follower)</h2>
<p>为了在管理数据的系统中实现容错，需要在多个服务器上复制数据。</p>
<p>在集群中选择一个服务器作为领导者。领导者负责代表整个集群做出决策，并将决策传播到所有其他服务器。</p>
<p>三到五个节点的集群，就像在实现共识的系统中一样，领导者选举可以在数据集群本身内实施，而不依赖于任何外部系统。领导者选举在服务器启动时进行。每个服务器在启动时都会启动领导者选举，并尝试选举领导者。除非选出领导者，否则系统不接受任何客户端请求。</p>
<h2 id="心跳">心跳</h2>
<p>心跳机制用于检测现有领导者是否失败，以便可以启动新的领导者选举。</p>
<h2 id="Fencing">Fencing</h2>
<p>在领导者-追随者模式中，当领导者失败时，不可能确定领导者已停止工作。例如，慢速网络或网络分区可能会触发新的领导者选举，即使前一个领导者仍在运行并认为它仍然是活动的领导者。</p>
<p>屏蔽是指在以前处于活动状态的领导者周围设置围栏，使其无法访问集群资源，从而停止为任何读/写请求提供服务。</p>
<p>使用以下两种技术：</p>
<ul>
<li><strong>资源屏蔽</strong>：系统会阻止以前处于活动状态的领导者访问执行基本任务所需的资源。</li>
<li><strong>节点屏蔽</strong>：系统会阻止以前处于活动状态的领导者访问所有资源。执行此操作的常见方法是关闭节点电源或重置节点。</li>
</ul>
<h2 id="WAL_(预写日志_Write-ahead_Log)">WAL (预写日志 Write-ahead Log)</h2>
<p>预写日志记录是解决操作系统中<a href="https://www.geeksforgeeks.org/file-system-inconsistency/" target="_blank" rel="external">文件系统不一致</a>的问题的高级解决方案。受数据库管理系统的启发，此方法首先将要执行的操作的摘要记入“日志”中，然后再将其实际写入磁盘。在发生崩溃的情况下，操作系统只需检查此日志并从中断的位置继续。</p>
<h2 id="分段日志">分段日志</h2>
<p>将日志拆分为多个较小的文件，而不是单个大文件，以便于操作。</p>
<p>单个日志文件在启动时读取时可能会增长并成为性能瓶颈。较旧的日志会定期清理，并且很难对单个大文件执行清理操作。</p>
<p>单个日志拆分为多个段。日志文件在指定的大小限制后滚动。使用日志分段，需要有一种将逻辑日志偏移量（或日志序列号）映射到日志段文件的简单方法。</p>
<h2 id="高水位线_(High-Water_mark)">高水位线 (High-Water mark)</h2>
<p>跟踪领导者上的最后一个日志条目，该条目已成功复制到追随者的quorum。日志中此条目的索引称为高水位线索引。领导者仅公开到高水位线索引的数据。</p>
<p>Kafka：为了处理非可重复读取并确保数据一致性，Kafka broker会跟踪高水位线，这是特定分区的最大偏移量。使用者只能看到高水位线之前的消息。</p>
<h2 id="租约(Lease)">租约(Lease)</h2>
<p>租约就像一个锁，但即使客户端离开，它也能工作。客户端请求有限期限的租约，之后租约到期。如果客户端想要延长租约，它可以在租约到期之前续订租约。</p>
<p>Chubby 客户端与领导者保持有时限的会话租约。在此时间间隔内，领导者保证不会单方面终止会话。</p>
<h2 id="Gossip_协议">Gossip 协议</h2>
<p>Gossip协议是点对点通信机制，其中节点定期交换有关自己和他们所知道的其他节点的状态信息。</p>
<p>每个节点每秒启动一轮Gossip回合，以与另一个随机节点交换有关自己和其他节点的状态信息。</p>
<p><img src="gossip.png" alt=""></p>
<h2 id="Phi_累计故障检测（Phi_Accrual_Failure_Detection）">Phi 累计故障检测（Phi Accrual Failure Detection）</h2>
<p>此算法使用历史检测信号信息使阈值自适应。通用的应计故障检测器不会判断服务器是否处于活动状态，而是输出有关服务器的可疑级别。</p>
<p>Cassandra 使用 Phi 应计故障检测器算法来确定群集中节点的状态。</p>
<h2 id="脑裂">脑裂</h2>
<p>分布式系统具有两个或多个活动领导者的场景称为脑裂。</p>
<p>通过使用生成时钟(Generation Clock)可以解决脑裂问题，生成时钟只是一个单调递增的数字，用于指示服务器的生成。</p>
<p>每次选出新领导者时，时钟数字(generation number)都会增加。这意味着，如果旧领导者的时钟数为“1”，则新领导人的时钟数将为“2”。此时钟号包含在从领导发送到其他节点的每个请求中。通过这种方式，节点现在可以通过简单地信任具有最高数字的领导者来轻松区分真正的领导者。</p>
<p>Kafka：为了处理脑裂（我们可以有多个active controller broker），Kafka使用“纪元数”（Epoch number），这只是一个单调增加的数字来表示服务器的代次(generation)。</p>
<p>HDFS：ZooKeeper用于确保任何时候只有一个NameNode处于活动状态。epoch 编号作为每个事务 ID 的一部分进行维护，以反映 NameNode 的代次。</p>
<h2 id="校验和_(checksum)">校验和 (checksum)</h2>
<p>在分布式系统中，在组件之间移动数据时，从节点获取的数据可能会损坏。</p>
<p>计算校验和并将其与数据一起存储。</p>
<p>要计算校验和，请使用 MD5、SHA-1、SHA-256 或 SHA-512 等加密哈希函数。哈希函数获取输入数据并生成固定长度的字符串（包含字母和数字）;此字符串称为校验和。</p>
<p>当系统存储某些数据时，它会计算数据的校验和，并将校验和与数据一起存储。当客户端检索数据时，它会验证从服务器接收的数据是否与存储的校验和匹配。如果没有，则客户端可以选择从另一个副本检索该数据。</p>
<p>HDFS和Chubby将每个文件的校验和与数据一起存储。</p>
<h2 id="CAP定理">CAP定理</h2>
<p>CAP定理指出，分布式系统不可能同时提供以下所有三个理想属性：</p>
<p>一致性(C)、可用性(A) 和分区容差(P)。</p>
<p>根据CAP定理，任何分布式系统都需要从三个属性中选择两个。这三个选项是 CA、CP 和 AP。</p>
<p>Dynamo：在CAP定理术语中，Dynamo属于AP系统的类别，旨在牺牲强一致性为代价实现高可用性。</p>
<p>BigTable：就CAP定理而言，BigTable是一个CP系统，即它具有严格一致的读取和写入。</p>
<h2 id="PACELEC_定理">PACELEC 定理</h2>
<p>PACELC定理指出，在复制数据的系统中：</p>
<ul>
<li>如果有一个分区（&#39;P&#39;），分布式系统可以在可用性和一致性（即&#39;A&#39;和&#39;C&#39;）之间进行权衡;</li>
<li>否则（&#39;E&#39;），当系统在没有分区的情况下正常运行时，系统可以在延迟（&#39;L&#39;）和一致性（&#39;C&#39;）之间进行权衡。</li>
</ul>
<p><img src="PACELEC.png" alt=""></p>
<p>定理（PAC）的第一部分与CAP定理相同，ELC是扩展。整个论点假设我们通过复制来保持高可用性。因此，当失败时，CAP定理占上风。但如果没有，我们仍然必须考虑复制系统的一致性和延迟之间的权衡。</p>
<h2 id="提示交接_(Hinted_Handoff)">提示交接 (Hinted Handoff)</h2>
<p>如果节点关闭，系统会保留它们错过的所有请求的提示（或注释）。故障节点恢复后，将根据存储的提示将请求转发给它们。</p>
<p>当节点关闭时，领导者会在本地磁盘上的文本文件中写入提示。此提示包含数据及其所属的节点信息。当领导者意识到它为其保留提示的节点已恢复时，它会将每个提示的写入请求转发到该节点。</p>
<h2 id="读取时修复">读取时修复</h2>
<p>在分布式系统中，数据跨多个节点复制，某些节点最终可能会拥有过时的数据。</p>
<p>在读取操作期间修复过时的数据，因为此时，我们可以从多个节点读取数据以进行比较并找到具有过时数据的节点。此机制称为读取修复。一旦已知具有旧数据的节点，读取修复操作就会将较新版本的数据推送到具有较旧版本的节点。</p>
<p>Cassandra和Dynamo使用“读取修复”将最新版本的数据推送到具有旧版本的节点。</p>
<h2 id="默克尔树_(Merkle_Trees)">默克尔树 (Merkle Trees)</h2>
<p>“读取修复”可在处理读取请求时消除冲突。但是，如果某个副本明显落后于其他副本，则可能需要很长时间才能解决冲突。</p>
<p>副本可以包含大量数据。单纯地拆分整个范围来计算校验和进行比较并不是很可行;有太多的数据需要传输。相反，我们可以使用Merkle树来比较一个范围的副本。</p>
<p>Merkle 树是哈希的二叉树，其中每个内部节点是其两个子节点的哈希，每个叶节点是原始数据一部分的哈希。</p>
<p><img src="merkle-tree.png" alt=""></p>
<p>比较Merkle树在概念上很简单：</p>
<ul>
<li>比较两个树的根哈希。</li>
<li>如果它们相等，请停止。</li>
<li>在左边和右边的孩子上递归检查。</li>
</ul>
<p>为了实现反熵和在后台解决冲突，Dynamo使用Merkle树。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文:<a href="https://medium.com/@nishantparmar/distributed-system-design-patterns-2d20908fecfc" target="_blank" rel="external">Distributed System Design Patterns</a> </p>
<p>与分布式系统相关的常见问题的关键设计模式。<br>]]>
    
    </summary>
    
      <category term="设计模式" scheme="https://colobu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[等等， 怎么使用 SetMemoryLimit?]]></title>
    <link href="https://colobu.com/2022/06/20/how-to-use-SetMemoryLimit/"/>
    <id>https://colobu.com/2022/06/20/how-to-use-SetMemoryLimit/</id>
    <published>2022-06-20T05:43:30.000Z</published>
    <updated>2022-06-20T07:14:58.271Z</updated>
    <content type="html"><![CDATA[<p>Go 1.19中终于实现了<code>SetMemoryLimit</code>的功能。Go的GC并不像Java那样提供了很多的参数可以调整，目前也就有<code>GOGC</code>这么一个参数，所以能增加一个可以调整GC的参数确实让人兴奋。</p>
<a id="more"></a>
<p>一直关注Go性能同学一定知道，最近几年有两个调整Go GC的hack方式:</p>
<ul>
<li><a href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/" target="_blank" rel="external">ballast</a>: 压舱石技术。使用一个&quot;虚假&quot;的内存占用，让Go运行时难以达到触发GC的阈值，来实现减少GC的次数，从而提高性能。如果你的程序的内存占用基本都会在某个阈值之下的话，这个技术非常有效，毕竟，Go很大的一部分性能消耗都是在GC上。这是twitch.tv的工程师提供的一种技术。</li>
<li><a href="https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/" target="_blank" rel="external">GOGC tuner</a>: 通过自动调整GOGC，来动态的调整GC的target,用来在内存足够的时候调整GOGC来减少GC的次数，这也是一个非常有趣有效的技术，在uber公司的实践中行之有效。这是uber工程师提供的一项技术，Uber的工程师并没有把它开源出来，不过曹大根据文章的原理实现了一个<a href="https://github.com/cch123/gogctuner" target="_blank" rel="external">cch123/gogctuner</a>。</li>
</ul>
<p>现在， Go 1.19 提供了<code>SetMemoryLimit</code>的功能，通过这个方法，可以替换<code>ballast</code>的方案，部分替换<code>GOGC Tuner</code>的方案。</p>
<p>谈起这个功能的历史，可以追溯到2017年12月的<a href="https://github.com/golang/go/issues/23044" target="_blank" rel="external">#23044</a>，它提议增加一个方法，可以指定最小的目标堆大小。这个issue大家讨论的热火朝天，结果就是2019年twitch.tv的工程师实现了ballast,从工程的角度验证了GC是可以优化，而且在实践中也有效。</p>
<p>2021年Go team的工程师 Michael Knyszek 发起一个提案<a href="https://github.com/golang/go/issues/44309" target="_blank" rel="external">#44309</a>,包括设计文档<a href="https://github.com/golang/proposal/blob/7f0d01687e030f21e8bdc36dfd9d5aac3a6f4a71/design/44309-user-configurable-memory-target.md" target="_blank" rel="external">user configurable memory target</a>。这个提案的跟踪issue最终归于<a href="https://github.com/golang/go/issues/48409" target="_blank" rel="external">#48409</a>。</p>
<p>本来，这个提案预期在Go 1.18中实现，不过因为提案迟迟没有批准，所以最终会在Go 1.19中实现。</p>
<p>在撰写本文的时候，Go 1.19还在开发之中，不过这个提案的功能已经实现，剩下的是一些文档和bug修复的工作了，所以我们可以使用<a href="https://pkg.go.dev/golang.org/dl/gotip" target="_blank" rel="external">gotip</a>来测试。</p>
<p>这个提案的实现原来就是要实现(替换)ballast的功能，所以一旦Go 1.19发布， ballast的方案就可以废弃了。没想到今年突然Uber的工程师来了一个自动调整GOGC的方案,所以当前方案还不能完全代替GOGC tuner, 毕竟GOGC Tuner可以更灵活的调整GC的target,而<code>SetMemoryLimit</code>在设定的<code>MemoryLimit</code>之下，还是会频繁的进行GC, 如果加上<code>GOGC=off</code>的话，只能等待达到<code>MemoryLimit</code>才能GC,和GOGC Tuner的方式还有有所不同的,所以并不能完全替代GOGC tuner。</p>
<p>详细的 GC调优指导的<a href="https://tip.golang.org/doc/gc-guide" target="_blank" rel="external">官方文档</a>还没有完成，大家也可以关注一下，看看官方的建议。</p>
<blockquote>
<p>This page is currently a work-in-progress and is expected to be complete by the time of the Go 1.19 release. See this <a href="https://tip.golang.org/doc/gc-guide#:~:text=This%20page%20is%20currently%20a%20work%2Din%2Dprogress%20and%20is%20expected%20to%20be%20complete%20by%20the%20time%20of%20the%20Go%201.19%20release.%20See%20this%20tracking%20issue%20for%20more%20details." target="_blank" rel="external">tracking issue</a> for more details.</p>
</blockquote>
<p>即使官方文档还没有完成，依照提案的内容，我们还是可以早点了解这个提案的功能以及带给我们的收益。</p>
<p>下面通过四个场景，观察一下此功能对GC的影响:</p>
<ul>
<li><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>足够大</li>
<li><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>不足够大</li>
<li><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>足够大</li>
<li><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>不足够大</li>
</ul>
<h2 id="基本例子">基本例子</h2>
<p>本文通过Debian的benchmarks game中的<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/binarytrees-go-2.html" target="_blank" rel="external">btree例子</a>演示这四个场景。</p>
<p>因为这个例子会频繁生成生成二叉树，正适合内存分配和回收的场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> {</div><div class="line">	next *next</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> next <span class="keyword">struct</span> {</div><div class="line">	left, right node</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> create(d <span class="typename">int</span>) node {</div><div class="line">	<span class="keyword">if</span> d ==<span class="number"> 1</span> {</div><div class="line">		<span class="keyword">return</span> node{&next{node{}, node{}}}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> node{&next{create(d -<span class="number"> 1</span>), create(d -<span class="number"> 1</span>)}}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p node) check() <span class="typename">int</span> {</div><div class="line">	sum :=<span class="number"> 1</span></div><div class="line">	current := p.next</div><div class="line">	<span class="keyword">for</span> current != <span class="constant">nil</span> {</div><div class="line">		sum += current.right.check() +<span class="number"> 1</span></div><div class="line">		current = current.left.next</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	depth = flag.Int(<span class="string">"depth"</span>,<span class="number"> 10</span>, <span class="string">"depth"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	start := time.Now()</div><div class="line">	<span class="keyword">const</span> MinDepth =<span class="number"> 4</span></div><div class="line">	<span class="keyword">const</span> NoTasks =<span class="number"> 4</span></div><div class="line">	maxDepth := *depth</div><div class="line"></div><div class="line">	longLivedTree := create(maxDepth)</div><div class="line"></div><div class="line">	stretchTreeCheck := <span class="string">""</span></div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">	wg.Add<span class="number">(1</span>)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		stretchDepth := maxDepth +<span class="number"> 1</span></div><div class="line">		stretchTreeCheck = fmt.Sprintf(<span class="string">"stretch tree of depth %d\t check: %d"</span>,</div><div class="line">			stretchDepth, create(stretchDepth).check())</div><div class="line">		wg.Done()</div><div class="line">	}()</div><div class="line"></div><div class="line">	results := <span class="built_in">make</span>([]<span class="typename">string</span>, (maxDepth-MinDepth)<span class="number">/2</span><span class="number">+1</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> results {</div><div class="line">		depth :=<span class="number"> 2</span>*i + MinDepth</div><div class="line"></div><div class="line">		n := <span class="number">(1</span> &lt;&lt; (maxDepth - depth + MinDepth)) / NoTasks</div><div class="line"></div><div class="line">		tasks := <span class="built_in">make</span>([]<span class="typename">int</span>, NoTasks)</div><div class="line">		wg.Add(NoTasks)</div><div class="line">		<span class="comment">// 执行NoTasks个goroutine, 每个goroutine执行n个深度为depth的tree的check</span></div><div class="line">		<span class="comment">// 一共是n*NoTasks个tree,每个tree的深度是depth</span></div><div class="line">		<span class="keyword">for</span> t := <span class="keyword">range</span> tasks {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(t <span class="typename">int</span>) {</div><div class="line">				check :=<span class="number"> 0</span></div><div class="line">				<span class="keyword">for</span> i := n; i &gt;<span class="number"> 0</span>; i-- {</div><div class="line">					check += create(depth).check()</div><div class="line">				}</div><div class="line">				tasks[t] = check</div><div class="line">				wg.Done()</div><div class="line">			}(t)</div><div class="line">		}</div><div class="line"></div><div class="line">		wg.Wait()</div><div class="line">		check :=<span class="number"> 0</span> <span class="comment">// 总检查次数</span></div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> tasks {</div><div class="line">			check += v</div><div class="line">		}</div><div class="line">		results[i] = fmt.Sprintf(<span class="string">"%d\t trees of depth %d\t check: %d"</span>,</div><div class="line">			n*NoTasks, depth, check)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(stretchTreeCheck)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> results {</div><div class="line">		fmt.Println(s)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"long lived tree of depth %d\t check: %d\n"</span>,</div><div class="line">		maxDepth, longLivedTree.check())</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"took %.02f s"</span>, <span class="typename">float64</span>(time.Since(start).Milliseconds())<span class="number">/1000</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以使用<code>gotip build main.go</code>生成Go 1.19编译的二进制文件。</p>
<p>后面的例子中我并没有使用<code>debug.SetMemoryLimit</code>设置<code>MemoryLimit</code>,而是使用环境变量<code>GOMEMLIMIT</code>。</p>
<h2 id="SetMemoryLimit_+_GOGC=off_+_MemoryLimit足够大"><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>足够大</h2>
<p>首先使用<code>gotip build main.go</code>编译出可执行的二进制文件<code>soft_memory_limit</code>。</p>
<p>运行 <code>GOMEMLIMIT=10737418240 GOGC=off GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code>查看效果：<br><img src="case1.png" alt=""></p>
<p>这里我设置的<code>MemoryLimit</code>为10G,整个程序中并没有达到这个内存阈值，所以没有GC发生。</p>
<p>是不是和设置ballast的效果一样。</p>
<h2 id="SetMemoryLimit_+_GOGC=off_+_MemoryLimit不足够大"><code>SetMemoryLimit</code> + <code>GOGC=off</code> + <code>MemoryLimit</code>不足够大</h2>
<p>我们将<code>MemoryLimit</code>设置为1G,看看GC的表现(<code>GOMEMLIMIT=1073741824 GOGC=off GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code>)：<br><img src="case2.png" alt=""></p>
<p>可以看到程序的运行过程内存占用还是能够触达阈值1G的，这会导致几次的垃圾回收，整体运行时间和case1差别不到，原因是GC回收仅仅几次，可以忽略。</p>
<p>如果你把阈值设置更小，比如缩小10倍(<code>GOMEMLIMIT=107374182 GOGC=off GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code>),可以看到更频繁的垃圾回收，程序整体运行时间也显著增加：<br><img src="case2-2.png" alt=""></p>
<h2 id="SetMemoryLimit_+_GOGC=100_+_MemoryLimit足够大"><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>足够大</h2>
<p>为了达到ballast的效果，前面的case都把GOGC设置为了<code>off</code>,如果我们设置为默认值100呢？</p>
<p><code>GOMEMLIMIT=10737418240 GOGC=100 GODEBUG=gctrace=1 ./soft_memory_limit -depth=21</code></p>
<p><img src="case3.png" alt=""></p>
<p>可以看到，会有大量的GC事件，并且很多并没有达到阈值就发生GC了。这也是显而易见的，因为在没有达到<code>MemoryLimit</code>阈值的情况下，还是遵循GOGC的target决定要不要进行垃圾回收。</p>
<p>在这种情况下，可以使用GOGC tuner进行调优，避免这么多次的垃圾回收。</p>
<h2 id="SetMemoryLimit_+_GOGC=100_+_MemoryLimit不足够大"><code>SetMemoryLimit</code> + <code>GOGC=100</code> + <code>MemoryLimit</code>不足够大</h2>
<p>如果设置的<code>MemoryLimit</code>不足够大,在内存触达<code>MemoryLimit</code>的时候也会触发GC,只不过因为没有关闭GOGC,所以GOGC和触达<code>MemoryLimit</code>两种情况下都有可能触发GC,程序整体运行还是比较慢的。</p>
<p><img src="case4.png" alt=""></p>
<p>综上所述,通过<code>SetMemoryLimit</code>设置一个较大的值，再加上 <code>GOGC=off</code>，可以实现ballast的效果。</p>
<p>但是在没有关闭<code>GOGC</code>的情况下，还是有可能会触发很多次的GC,影响性能，这个时候还得GOGC Tuner调优，减少触达<code>MemoryLimit</code>之前的GC次数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.19中终于实现了<code>SetMemoryLimit</code>的功能。Go的GC并不像Java那样提供了很多的参数可以调整，目前也就有<code>GOGC</code>这么一个参数，所以能增加一个可以调整GC的参数确实让人兴奋。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用BPF, 将Go网络程序的吞吐提升8倍]]></title>
    <link href="https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/"/>
    <id>https://colobu.com/2022/06/05/use-bpf-to-make-the-go-network-program-8x-faster/</id>
    <published>2022-06-05T09:05:09.000Z</published>
    <updated>2022-06-05T11:18:34.897Z</updated>
    <content type="html"><![CDATA[<p>经典的bpf(classical Berkeley Packet Filter) 是非常好用的一个技术，在一些特殊的Go底层网络编程的场合，可以很好的提高性能。<br><a id="more"></a></p>
<h2 id="背景">背景</h2>
<p>先前我开发过一个Go UDP应用程序， 客户端和服务端通过UDP程序，通过raw socket进行通讯。程序的目的比较特殊，这里我以一个简单的程序为例介绍。</p>
<p>事实上，我说我使用rawsocket方式并不严谨，我并不是采用下面的方式实现socket并进行通讯的(链路层的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fd, err:= syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW,syscall.ETH_P_ALL)</div><div class="line"><span class="keyword">if</span> (err != <span class="constant">nil</span>) {</div><div class="line">    fmt.Println(<span class="string">"Error: "</span> + err.Error())</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div><div class="line">fmt.Println(<span class="string">"Obtained fd "</span>, fd)</div><div class="line"><span class="keyword">defer</span> syscall.Close(fd)</div></pre></td></tr></table></figure>

<p>也不是采用下面的rawsocket方式(IP层的方式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    fd, e := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_UDP)</div><div class="line">    <span class="keyword">if</span> e != <span class="constant">nil</span> {</div><div class="line">        fmt.Println(<span class="string">"Problem @ location 1"</span>)</div><div class="line">    }</div><div class="line">    addr := syscall.SockaddrInet4{</div><div class="line">        Port:<span class="number"> 27289</span>,</div><div class="line">        Addr: <span class="number">[4</span>]<span class="typename">byte</span><span class="number">{127</span>,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 1</span>},</div><div class="line">    }</div><div class="line">    p := pkt()</div><div class="line">    err = syscall.Sendto(fd, p,<span class="number"> 0</span>, &addr)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(<span class="string">"Sendto:"</span>, err)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>而是直接采用Go标准库中封装好的方法<code>net.ListenPacket(&quot;ip4:udp&quot;, addr)</code>在IP层进行包的发送和接收。</p>
<p>我通过封装自定义的UDP层的数据结构，实现自定义的包的发送和接收，进行网络的监控。</p>
<p>也许有人说使用标准库的UDPConn不就行了。如果是普通的UDP程序，的确没问题，如果对于一些特殊的需求，比如监听1000个UDP端口，有上万个节点定时的发送监控的数据，我们不太可能建立1000*1万个UDPConn,所以这里我采用rawsocket通讯的方式。</p>
<p>RawSocket是是标准Berkeley socket的一部分，我们使用Go的标准库开发网络程序时，大部分场景都是使用封装好的数据报类型(UDPConn)或者流类型(TCPConn),但是如果想做更底层的一些网络编程的话，就需要使用到RawSocket了，比如更底层的TCP、UDP网络控制、ICMP、ARP等协议。不同的操作系统可能实现的RawSocket也不同，这里我们以Linux环境为例。</p>
<p>Linux man手册对RawSocket相关知识做了详细的介绍:<a href="https://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="external">socket(2)</a>、<a href="https://man7.org/linux/man-pages/man7/packet.7.html" target="_blank" rel="external">packet(7) </a>、<a href="https://man7.org/linux/man-pages/man7/raw.7.html" target="_blank" rel="external">raw(7)</a>,本文不再做转述，这也不是本文的重点。</p>
<p>依照Linux文档，Linux 服务器中收到的包既=会传给内核网络模块，也会传给RawSocket。所以你使用RawSocket的时候有时候需要注意，比如你在处理TCP的包时，可能Linux内核的网络程序已经把这个包处理了。</p>
<blockquote>
<p>Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or TCP which have a protocol module in the kernel.  In this case, the packets are passed to both the kernel module and the raw socket(s).  This should not be relied upon in portable programs, many other BSD socket implementation have limitations here.</p>
</blockquote>
<p>如果没有特殊的需求，我们直接就使用<a href="https://pkg.go.dev/net#ListenPacket" target="_blank" rel="external">net.ListenPacket</a>是实现一个RawSocket的程序。这个方法的签名如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ListenPacket(network, address <span class="typename">string</span>) (PacketConn, error)</div></pre></td></tr></table></figure>

<p>其中第一个参数<code>network</code>可以是<code>udp</code>、<code>udp4</code>、<code>udp6</code>、<code>unixgram</code>，也是可以<code>ip</code>、<code>ip4</code>、<code>ip6</code>加冒号再加一个协议号或者协议名，比如<code>ip:1</code>、<code>ip:icmp</code>，就可以你也处理什么协议。</p>
<h2 id="演示程序">演示程序</h2>
<h3 id="服务端程序">服务端程序</h3>
<p>服务端程序我们使用<code>conn, err := net.ListenPacket(&quot;ip4:udp&quot;, *addr)</code>监听本地地址上所有的UDP包，并启动一个goroutine去处理。处理程序中应该还有一个判断，就是检查UDP的端口是不是我们处理的端口，因为这里<code>net.ListenPacket</code>监听的是本地所有的UDP,可能有很多无用的UDP包都传入到用户态的程序中了。</p>
<p>这里我们使用gopacket对各种协议层的包的定义，方便解析(或创建)TCP/IP各层的网络协议。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">	<span class="string">"golang.org/x/net/bpf"</span></div><div class="line">	<span class="string">"golang.org/x/net/ipv4"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"s"</span>, <span class="string">"localhost"</span>, <span class="string">"server address"</span>)</div><div class="line">	port = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	stat         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">	lastStatTime = <span class="typename">int64</span><span class="number">(0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	cc := conn.(*net.IPConn)</div><div class="line">	cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">	cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	handleConn(conn)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.PacketConn) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">		n, remoteaddr, err := conn.ReadFrom(buffer)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		buffer = buffer[:n]</div><div class="line"></div><div class="line">		packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">		<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">		<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line">			udp, _ := udpLayer.(*layers.UDP)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">				data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>), <span class="typename">uint16</span>(udp.DstPort), <span class="typename">uint16</span>(udp.SrcPort), app.Payload())</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteaddr); err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">					conn.Close()</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="客户端程序">客户端程序</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, <span class="string">"127.0.0.1"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>),<span class="number"> 8972</span>,<span class="number"> 0</span>, []<span class="typename">byte</span>(<span class="string">"hello"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	remoteAddr := &net.IPAddr{IP: net.ParseIP(<span class="string">"127.0.0.1"</span>)}</div><div class="line"></div><div class="line">	<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteAddr); err != <span class="constant">nil</span> {</div><div class="line">		log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">		conn.Close()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	n, _, err := conn.ReadFrom(buffer)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	buffer = buffer[:n]</div><div class="line"></div><div class="line">	packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">	<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">	<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">			fmt.Printf(<span class="string">"reply: %s\n"</span>, app.Payload())</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端程序这里做了简化，写入一个<code>hello</code>,并读取服务端的返回。我们在做性能测试的时候，会使用循环不断的写入一个seq号，并检查服务端是否返回这个seq，以便计算丢包性能。并且还使用一个限流器进行限流，测试在一定的RPS情况下的丢包率。</p>
<h3 id="辅助方法">辅助方法</h3>
<p>下面是<code>EncodeUDPPacket</code>方法，用来产生一个UDP的包数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> codec</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> EncodeUDPPacket(localIP, remoteIP net.IP, localPort, remotePort <span class="typename">uint16</span>, payload []<span class="typename">byte</span>) ([]<span class="typename">byte</span>, error) {</div><div class="line">	ip := &layers.IPv4{</div><div class="line">		Version: <span class="number"> 4</span>,</div><div class="line">		TTL:     <span class="number"> 128</span>,</div><div class="line">		SrcIP:    localIP,</div><div class="line">		DstIP:    remoteIP,</div><div class="line">		Protocol: layers.IPProtocolUDP,</div><div class="line">	}</div><div class="line">	udp := &layers.UDP{</div><div class="line">		SrcPort: layers.UDPPort(localPort),</div><div class="line">		DstPort: layers.UDPPort(remotePort),</div><div class="line">	}</div><div class="line">	udp.SetNetworkLayerForChecksum(ip)</div><div class="line"></div><div class="line">	buf := gopacket.NewSerializeBuffer()</div><div class="line">	opts := gopacket.SerializeOptions{</div><div class="line">		ComputeChecksums: <span class="constant">true</span>,</div><div class="line">		FixLengths:       <span class="constant">true</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	err := gopacket.SerializeLayers(buf, opts, udp, gopacket.Payload(payload))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> buf.Bytes(), err</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="性能问题">性能问题</h2>
<p>虽然上面的程序运行的很好，但是在并发量比较大的情况，会有一些问题。</p>
<p>上面我们启动了一个goroutine去读取这个包，这里是一个性能瓶颈，最终服务端只能使用一个核去处理RawSocket的包。</p>
<p>即使创建多个goroutine去读取这个PacketConn,也是没有用的，因为这个PacketConn是唯一的，它是一个瓶颈，多个goroutine有时候还不如一个goroutine去读取更好。</p>
<p>那么能不能调用多次<code>net.ListenPacket(&quot;ip4:udp&quot;, *addr)</code>,生成多个RawSocket并发的去处理呢？</p>
<p>貌似看起来可以，但是实际上，这多个RawSocket都会读取到相同的UDPPacket，而不是负载均衡平摊到多个Socket上。所以多个RawSocket不但没用，反而更加耗费服务器的资源了。</p>
<p>实际测试也就能达到2~3万的吞吐，并发量再高就出现丢包的情况了。</p>
<p>但是没有办法了么？</p>
<p>也不是。这里我们可以看到，主要性能瓶颈是我们上面的程序没有办法做到负载均衡，利用多核的能力并发的去处理。第二个性能瓶颈就是程序监听了本机所有的UDP的packet,交给用户态程序筛选去处理，这里面有很多我们不需要的包。</p>
<p>这两个性能问题我们都可以通过BPF进行处理。</p>
<h2 id="BPF进行包过滤">BPF进行包过滤</h2>
<p>经典的BPF早在1994就出现了，虽然大家现在都在谈论扩展的BPF(eBPF),但是经典的BPF依然可以发挥它的威力。</p>
<p>你可能没有在编程中应用过BPF,但是我相信你在实际工作中一定和它发生过什么。</p>
<p>比如你使用tcpdump在监听网络的传输情况时，经常会加上过滤手段，比如下面的命令是只监听tcp协议的8080端口:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -nn -vvvv -i any <span class="string">"tcp port 8080"</span></div></pre></td></tr></table></figure>

<p>tcpdump其实就是把<code>tcp port 8080</code>生成过滤器，在内核中对包进行过滤，只把过滤后的包打筛选出来。</p>
<p>其实你可以通过下面的命令查看编译的过滤的代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@lab ~]<span class="comment"># tcpdump -d "tcp port 8080"</span></div><div class="line">(<span class="number">000</span>) ldh      [<span class="number">12</span>]</div><div class="line">(<span class="number">001</span>) jeq      <span class="comment">#0x86dd          jt 2	jf 8</span></div><div class="line">(<span class="number">002</span>) ldb      [<span class="number">20</span>]</div><div class="line">(<span class="number">003</span>) jeq      <span class="comment">#0x6             jt 4	jf 19</span></div><div class="line">(<span class="number">004</span>) ldh      [<span class="number">54</span>]</div><div class="line">(<span class="number">005</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 6</span></div><div class="line">(<span class="number">006</span>) ldh      [<span class="number">56</span>]</div><div class="line">(<span class="number">007</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 19</span></div><div class="line">(<span class="number">008</span>) jeq      <span class="comment">#0x800           jt 9	jf 19</span></div><div class="line">(<span class="number">009</span>) ldb      [<span class="number">23</span>]</div><div class="line">(<span class="number">010</span>) jeq      <span class="comment">#0x6             jt 11	jf 19</span></div><div class="line">(<span class="number">011</span>) ldh      [<span class="number">20</span>]</div><div class="line">(<span class="number">012</span>) jset     <span class="comment">#0x1fff          jt 19	jf 13</span></div><div class="line">(<span class="number">013</span>) ldxb     <span class="number">4</span>*([<span class="number">14</span>]&<span class="number">0</span>xf)</div><div class="line">(<span class="number">014</span>) ldh      [x + <span class="number">14</span>]</div><div class="line">(<span class="number">015</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 16</span></div><div class="line">(<span class="number">016</span>) ldh      [x + <span class="number">16</span>]</div><div class="line">(<span class="number">017</span>) jeq      <span class="comment">#0x1f90          jt 18	jf 19</span></div><div class="line">(<span class="number">018</span>) ret      <span class="comment">#262144</span></div><div class="line">(<span class="number">019</span>) ret      <span class="comment">#0</span></div></pre></td></tr></table></figure>

<p>这代表什么意思的？BPF定义了有限一些指令，可以在VM中，对包进行过滤.<br>第一行是加载包的偏移量(offset 12个字节)，第二行是检查是否是IPV6，如果是跳到<code>002</code>,如果不是跳到<code>008</code>。我们关注一下IPV4。<br><code>008</code>那一行是判断是否是ipv4，如果是跳到<code>009</code>。<code>009</code>加载偏移量23处的一个字节，它是ip proto,<code>010</code>行判断ip proto是否是TCP,如果是跳到<code>011</code>。<br>接下来判断flags，以便确定数据的地址。<br><code>014</code>行和<code>016</code>行是读取TCP协议中的源端口和目的端口，如果等于<code>8080</code>(<code>0x1f90</code>),则最大返回包大小262144个字节，否则就丢弃这个包。</p>
<p>当然tcpdump的生成的代码相当的严谨了我我们实际写的时候，如果确定是ipv4的包，包也没什么扩展的话，写出的代码要比这个简单。但是我们实际在应用BPF的时候不妨采用tcpdump生成的代码，不会出错。</p>
<p>使用<code>-dd</code>可以显示成c代码片段，使用<code>-ddd</code>显示为十进制数。我们看一下<code>-dd</code>的效果，因为这个结果我们可以用来转换成Go的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@lab ~]# tcpdump -dd <span class="string">"tcp port 8080"</span></div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000c },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 6</span>,<span class="number"> 0</span>x000086dd },</div><div class="line">{<span class="number"> 0</span>x30,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000014 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 15</span>,<span class="number"> 0</span>x00000006 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000036 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 12</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000038 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 10</span>,<span class="number"> 11</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 10</span>,<span class="number"> 0</span>x00000800 },</div><div class="line">{<span class="number"> 0</span>x30,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000017 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 8</span>,<span class="number"> 0</span>x00000006 },</div><div class="line">{<span class="number"> 0</span>x28,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000014 },</div><div class="line">{<span class="number"> 0</span>x45,<span class="number"> 6</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001fff },</div><div class="line">{<span class="number"> 0</span>xb1,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000e },</div><div class="line">{<span class="number"> 0</span>x48,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x0000000e },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 2</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x48,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000010 },</div><div class="line">{<span class="number"> 0</span>x15,<span class="number"> 0</span>,<span class="number"> 1</span>,<span class="number"> 0</span>x00001f90 },</div><div class="line">{<span class="number"> 0</span>x6,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00040000 },</div><div class="line">{<span class="number"> 0</span>x6,<span class="number"> 0</span>,<span class="number"> 0</span>,<span class="number"> 0</span>x00000000 },</div></pre></td></tr></table></figure>

<p>实际上，<a href="https://pkg.go.dev/golang.org/x/net/bpf" target="_blank" rel="external">x/net/bpf</a>提供了相应的方法，可以更容易的编写BPF程序，序列化和反序列化。比如编写一个过滤出目的端口等于8972的所有的包，我们可以简单写成如下的格式(考虑到简单形式，我们只考虑了IPV4和普通IP包的形式):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">//加载目的端口到寄存器</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val:<span class="number"> 8972</span>, SkipFalse:<span class="number"> 1</span>}, <span class="comment">// 如果值等于8972的话,执行下一行，否则跳过下一行</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},   <span class="comment">// 返回这个包的最多0xffff的字节的数据</span></div><div class="line"></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">// 返回零个字节，也就是忽略这个包</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以写一个程序，把tcpdump生成的代码转换成bpf的RawInstruction指令:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> parse(data <span class="typename">string</span>) (raws []bpf.RawInstruction) {</div><div class="line">	lines := strings.Split(data, <span class="string">"\n"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, line := <span class="keyword">range</span> lines {</div><div class="line">		line = strings.TrimSpace(line)</div><div class="line">		<span class="keyword">if</span> line == <span class="string">""</span> {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line"></div><div class="line">		line = strings.TrimPrefix(line, <span class="string">"{"</span>)</div><div class="line">		line = strings.TrimSuffix(line, <span class="string">" },"</span>)</div><div class="line">		items := strings.Split(line, <span class="string">","</span>)</div><div class="line">		<span class="comment">// assert len(items) == 4</span></div><div class="line"></div><div class="line">		raw := bpf.RawInstruction{</div><div class="line">			Op: <span class="typename">uint16</span>(numToInteger(items<span class="number">[0</span>])),</div><div class="line">			Jt: <span class="typename">uint8</span>(numToInteger(items<span class="number">[1</span>])),</div><div class="line">			Jf: <span class="typename">uint8</span>(numToInteger(items<span class="number">[2</span>])),</div><div class="line">			K:  <span class="typename">uint32</span>(numToInteger(items<span class="number">[3</span>])),</div><div class="line">		}</div><div class="line"></div><div class="line">		raws = <span class="built_in">append</span>(raws, raw)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> raws</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> numToInteger(s <span class="typename">string</span>) <span class="typename">int</span> {</div><div class="line">	s = strings.TrimSpace(s)</div><div class="line">	<span class="keyword">if</span> strings.HasPrefix(s, <span class="string">"0x"</span>) {</div><div class="line">		s := strings.Replace(s, <span class="string">"0x"</span>, <span class="string">""</span>,<span class="number"> -1</span>)</div><div class="line">		result, _ := strconv.ParseInt(s,<span class="number"> 16</span>,<span class="number"> 64</span>)</div><div class="line">		<span class="keyword">return</span> <span class="typename">int</span>(result)</div><div class="line">	}</div><div class="line"></div><div class="line">	result, _ := strconv.ParseInt(s,<span class="number"> 10</span>,<span class="number"> 64</span>)</div><div class="line">	<span class="keyword">return</span> <span class="typename">int</span>(result)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>好了所有这一切都准备好了，背景知识介绍了，当前的RawSocket程序的性能瓶颈也介绍了，那么如果解决性能瓶颈呢。</p>
<p>第一个性能瓶颈我们可以生成多个goroutine，每个goroutine负责过滤一部分的包，这样就实现了负载均衡。比如根据客户端的IP进行过滤，或者服务端监听1000个端口，每个goroutine只负责一部分的端口。而可以根据客户端的源端口进行过滤等等。总是，通过BPF过滤，一个goroutine只负责一部分的packet，实现了多核的处理。</p>
<p>第二个瓶颈随着第一个问题也迎刃而解。因为BPF只过滤我们的特定的端口，其它端口的UDP包不会从内核态复制到用户态，减少了无用包的处理。</p>
<p>要为标准库的PacketConn设置BPF过滤，也有多种办法，比如调用<code>syscall.SetsockoptInt</code>进行设置。但是<a href="https://pkg.go.dev/golang.org/x/net/ipv4#PacketConn.SetBPF" target="_blank" rel="external">golang.org/x/net/ipv4</a>提供了SetBPF方法，我们可以直接将标准库的PacketConn转换成ipv4.PacketConn,再进行设置。</p>
<p>比如上面的server程序，我们可以修改为使用BPF在内核态过滤:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/google/gopacket"</span></div><div class="line">	<span class="string">"github.com/google/gopacket/layers"</span></div><div class="line">	<span class="string">"github.com/smallnest/go-network-programming/codec"</span></div><div class="line">	<span class="string">"golang.org/x/net/bpf"</span></div><div class="line">	<span class="string">"golang.org/x/net/ipv4"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"s"</span>, <span class="string">"localhost"</span>, <span class="string">"server address"</span>)</div><div class="line">	port = flag.Int(<span class="string">"p"</span>,<span class="number"> 8972</span>, <span class="string">"port"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	stat         = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)</div><div class="line">	lastStatTime = <span class="typename">int64</span><span class="number">(0</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	conn, err := net.ListenPacket(<span class="string">"ip4:udp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	cc := conn.(*net.IPConn)</div><div class="line">	cc.SetReadBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line">	cc.SetWriteBuffer<span class="number">(20</span> *<span class="number"> 1024</span> *<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">	pconn := ipv4.NewPacketConn(conn)</div><div class="line">	<span class="keyword">var</span> assembled []bpf.RawInstruction</div><div class="line">	<span class="keyword">if</span> assembled, err = bpf.Assemble(filter); err != <span class="constant">nil</span> {</div><div class="line">		log.Print(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	pconn.SetBPF(assembled)</div><div class="line"></div><div class="line">	handleConn(conn)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> handleConn(conn net.PacketConn) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		buffer := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>)</div><div class="line"></div><div class="line">		n, remoteaddr, err := conn.ReadFrom(buffer)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatal(err)</div><div class="line">		}</div><div class="line"></div><div class="line">		buffer = buffer[:n]</div><div class="line"></div><div class="line">		packet := gopacket.NewPacket(buffer, layers.LayerTypeUDP, gopacket.NoCopy)</div><div class="line"></div><div class="line">		<span class="comment">// Get the UDP layer from this packet</span></div><div class="line">		<span class="keyword">if</span> udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != <span class="constant">nil</span> {</div><div class="line">			udp, _ := udpLayer.(*layers.UDP)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> app := packet.ApplicationLayer(); app != <span class="constant">nil</span> {</div><div class="line"></div><div class="line">				data, err := codec.EncodeUDPPacket(net.ParseIP(<span class="string">"127.0.0.1"</span>), net.ParseIP(<span class="string">"127.0.0.1"</span>), <span class="typename">uint16</span>(udp.DstPort), <span class="typename">uint16</span>(udp.SrcPort), app.Payload())</div><div class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to EncodePacket: %v"</span>, err)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line"></div><div class="line">				<span class="keyword">if</span> _, err := conn.WriteTo(data, remoteaddr); err != <span class="constant">nil</span> {</div><div class="line">					log.Printf(<span class="string">"failed to write packet: %v"</span>, err)</div><div class="line">					conn.Close()</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Filter []bpf.Instruction</div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = Filter{</div><div class="line">	bpf.LoadAbsolute{Off:<span class="number"> 22</span>, Size:<span class="number"> 2</span>},                                <span class="comment">// load the destination port</span></div><div class="line">	bpf.JumpIf{Cond: bpf.JumpEqual, Val: <span class="typename">uint32</span>(*port), SkipFalse:<span class="number"> 1</span>}, <span class="comment">// if Val != 8972 skip next instruction</span></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>xffff},                                      <span class="comment">// return 0xffff bytes (or less) from packet</span></div><div class="line"></div><div class="line">	bpf.RetConstant{Val:<span class="number"> 0</span>x0}, <span class="comment">// return 0 bytes, effectively ignore this packet</span></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>经典的bpf(classical Berkeley Packet Filter) 是非常好用的一个技术，在一些特殊的Go底层网络编程的场合，可以很好的提高性能。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[想学习k8s但没有环境？使用minikube轻松搭建一个]]></title>
    <link href="https://colobu.com/2022/06/02/setup-a-k8s-cluster-with-minikube/"/>
    <id>https://colobu.com/2022/06/02/setup-a-k8s-cluster-with-minikube/</id>
    <published>2022-06-02T07:37:14.000Z</published>
    <updated>2022-06-03T09:35:15.901Z</updated>
    <content type="html"><![CDATA[<p><a href="https://kubernetes.io/" target="_blank" rel="external">Kubernetes</a>（常简称为K8s）是用于自动部署、扩展和管理“容器化（containerized）应用程序”的开源系统。该系统由Google设计并捐赠给Cloud Native Computing Foundation（今属Linux基金会）来使用。</p>
<p>它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。 它支持一系列容器工具，包括Docker等。</p>
<p>Kubernetes（在希腊语意为“舵手”或“驾驶员”）由Joe Beda、Brendan Burns和Craig McLuckie创立，并由其他谷歌工程师，包括Brian Grant和Tim Hockin等进行加盟创作，并由谷歌在2014年首次对外宣布 。 该系统的开发和设计都深受谷歌的Borg系统的影响，其许多顶级贡献者之前也是Borg系统的开发者。在谷歌内部，Kubernetes的原始代号曾经是Seven，即星际迷航中的Borg（博格人）。Kubernetes标识中舵轮有七个轮辐就是对该项目代号的致意。</p>
<p>Kuberbetes一直是IT行业炽手可热的技术，很多同学都想学习它，但是刚想上手遇到了一个麻烦，需要搭建一个k8s的集群。虽然云服务提供商比如阿里云、百度云都提供了k8s集群的服务，但是还需要花一笔钱去购买服务和节点。如何在自己的机器上搭建一个k8s集群学习呢？本文给你介绍一种使用minikube搭建一个k8s测试集群的方法。</p>
<a id="more"></a>
<h2 id="安装">安装</h2>
<p><a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="external">minikube</a> 主要基于运行一个单节点 Kubernetes 集群，以便支持在本地机器上的 VM 内进行开发。它支持虚拟机驱动程序，如 VirtualBox、HyperV、KVM2。由于 Minikube 是 Kubernetes 体系中相对成熟的解决方案，支持的功能列表非常令人印象深刻。这些功能是负载均衡器、多集群、节点端口、持久卷、入口、仪表板或容器运行时。</p>
<p>基于 Minikube 开源工具，使得开发、运维人员及 DevOps 工程师能够快速在本地搭建 Kubernetes 单节点集群环境，毕竟，Minikube 对软硬件资源没有太高的要求，方便技术人员学习与实践，以及进行日常的项目开发。</p>
<p>运行minikube,你至少需要:</p>
<ul>
<li>2 CPU或者更多</li>
<li>2GB 内存</li>
<li>20GB 磁盘空间</li>
<li>互联网</li>
<li>容器或者虚机管理器如: Docker, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware Fusion/Workstation</li>
</ul>
<p>我使用的MacBook Pro M1的苹果本，并且机器上已经安装Docker,所以这些需求都满足。如果你是Linux或者Windows，也可以安装，只不过你需要下载相应的安装程序。<br>本文以我的环境为例进行介绍。</p>
<p>对于MacOS,你可以有两种方式进行安装。<br>一种是手工安装方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64</div><div class="line">sudo <span class="operator"><span class="keyword">install</span> minikube-darwin-amd64 /usr/<span class="keyword">local</span>/<span class="keyword">bin</span>/minikube</span></div></pre></td></tr></table></figure>

<p>如果你因为一些原因没有办法下载这个文件，也可以到github网站上下载<a href="https://github.com/kubernetes/minikube/releases/tag/v1.25.2" target="_blank" rel="external">二进制文件</a>，放到/usr/local/bin/minikube中。</p>
<p>第二种方式就是使用brew命令安装:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">brew <span class="operator"><span class="keyword">install</span> minikube</span></div><div class="line"></div><div class="line">// 查看minikube安装在哪里</div><div class="line">➜  ~ which minikube</div><div class="line">/usr/<span class="keyword">local</span>/<span class="keyword">bin</span>/minikube</div></pre></td></tr></table></figure>

<h2 id="启动">启动</h2>
<p>接下来就是启动minikube。</p>
<p>执行下面的命令就可以启动:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minikube start</div></pre></td></tr></table></figure>

<p>第一次启动需要下载k8s依赖的各种镜像，可能因为墙的原因，一些镜像会拉不下来安装失败。</p>
<p>我采用的方法是从阿里云拉取镜像，再重新打tag到对应的k8s依赖的镜像，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">docker pull <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy</span>:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:<span class="filename">v1.22.3 k8s.gcr.io/kube-proxy</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:<span class="filename">v1.8.4</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:<span class="filename">v1.8.4 k8s.gcr.io/coredns/coredns</span>:<span class="filename">v1.8.4</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:<span class="filename">v1.22.3 k8s.gcr.io/kube-scheduler</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner:v5</div><div class="line">docker tag <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner</span>:v5 <span class="filename">gcr.io/k8s-minikube/storage-provisioner</span>:v5</div><div class="line"></div><div class="line">docker pull <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver</span>:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:<span class="filename">v1.22.3 k8s.gcr.io/kube-apiserver</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:<span class="number">3.5</span><span class="number">.0</span>-<span class="number">0</span></div><div class="line">docker tag <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd</span>:<span class="number">3.5</span><span class="number">.0</span>-<span class="number">0</span>  <span class="filename">k8s.gcr.io/etcd</span>:<span class="number">3.5</span><span class="number">.0</span>-<span class="number">0</span></div><div class="line"></div><div class="line">docker pull <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager</span>:<span class="filename">v1.22.3</span></div><div class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:<span class="filename">v1.22.3 k8s.gcr.io/kube-controller-manager</span>:<span class="filename">v1.22.3</span></div><div class="line"></div><div class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:<span class="number">3.5</span></div><div class="line">docker tag <span class="filename">registry.cn-hangzhou.aliyuncs.com/google_containers/pause</span>:<span class="number">3.5</span>  <span class="filename">k8s.gcr.io/pause</span>:<span class="number">3.5</span></div></pre></td></tr></table></figure>

<p>手工把这些镜像拉到本地后，再执行<code>minikube start</code>就顺利启动成功了。</p>
<p>我还在网上看到另外一种启动方式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minikube <span class="operator"><span class="keyword">start</span> <span class="comment">--image-mirror-country='cn'</span></span></div></pre></td></tr></table></figure>

<p>我觉得这是一种更简捷的方式，不过我已经安装好了，所以这种方式我没有试过，你可以试试。</p>
<p>minikube命令提供了非常多的配置参数，比如：</p>
<p>--driver=<strong><em> 从1.5.0版本开始，Minikube缺省使用系统优选的驱动来创建Kubernetes本地环境，比如您已经安装过Docker环境，minikube 将使用 docker 驱动<br>--cpus=2: 为minikube虚拟机分配CPU核数<br>--memory=4096mb: 为minikube虚拟机分配内存数<br>--registry-mirror=</em></strong> 为 Docker daemon 配置镜像加速，比如<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="external">阿里云镜像服务</a><br>--kubernetes-version=***: minikube 虚拟机将使用的 kubernetes 版本</p>
<p>现在，你就可以打开Kubernetes控制台了: <code>minikube dashboard</code></p>
<p><img src="dashboard.png" alt=""></p>
<p>现在，一个本地测试用的k8s集群就搭建好了。</p>
<p>如果你暂时不用，可以调用<code>minikube stop</code>暂停，等需要的时候再启动。</p>
<h2 id="插件">插件</h2>
<p>你现在可以直接使用<code>kubectl</code>命令快速创建、更新和删除Kubernetes 对象。你可以自由自在的在自己的集群中学习、测试k8s的技术了。</p>
<p>minikube也提供了很多插件,比如istio、ingress、helm-tiller等等。随着你对k8s的掌握程度，可以逐步的安装测试这些扩展的功能。<br>插件列表如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">➜  ~ minikube addons list</div><div class="line"><span class="string">|-----------------------------|----------|--------------|-----------------------|</span></div><div class="line"><span class="string">|         ADDON NAME          | PROFILE  |    STATUS    |      MAINTAINER       |</span></div><div class="line"><span class="string">|-----------------------------|----------|--------------|-----------------------|</span></div><div class="line"><span class="string">| ambassador                  | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| auto-pause                  | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| csi-hostpath-driver         | minikube | disabled     | kubernetes            |</span></div><div class="line"><span class="string">| dashboard                   | minikube | enabled ✅   | kubernetes            |</span></div><div class="line"><span class="string">| default-storageclass        | minikube | enabled ✅   | kubernetes            |</span></div><div class="line"><span class="string">| efk                         | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| freshpod                    | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| gcp-auth                    | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| gvisor                      | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| helm-tiller                 | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| ingress                     | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| ingress-dns                 | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| istio                       | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| istio-provisioner           | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| kubevirt                    | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| logviewer                   | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| metallb                     | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| metrics-server              | minikube | disabled     | kubernetes            |</span></div><div class="line"><span class="string">| nvidia-driver-installer     | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| nvidia-gpu-device-plugin    | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| olm                         | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| pod-security-policy         | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| portainer                   | minikube | disabled     | portainer.io          |</span></div><div class="line"><span class="string">| registry                    | minikube | disabled     | google                |</span></div><div class="line"><span class="string">| registry-aliases            | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| registry-creds              | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| storage-provisioner         | minikube | enabled ✅   | kubernetes            |</span></div><div class="line"><span class="string">| storage-provisioner-gluster | minikube | disabled     | unknown (third-party) |</span></div><div class="line"><span class="string">| volumesnapshots             | minikube | disabled     | kubernetes            |</span></div><div class="line"><span class="string">|-----------------------------|----------|--------------|-----------------------|</span></div></pre></td></tr></table></figure>

<p>启用某个插件可以用下面的命令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ minikube addons enable ingress</div><div class="line">💡  After the addon <span class="keyword">is</span> enabled, please run <span class="string">"minikube tunnel"</span> <span class="keyword">and</span> your ingress resources would be available at <span class="string">"127.0.0.1"</span></div><div class="line">    ▪ <span class="keyword">Using</span> image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1<span class="number">.1</span><span class="number">.1</span></div><div class="line">    ▪ <span class="keyword">Using</span> image k8s.gcr.io/ingress-nginx/controller:v1<span class="number">.0</span><span class="number">.4</span></div><div class="line">    ▪ <span class="keyword">Using</span> image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1<span class="number">.1</span><span class="number">.1</span></div><div class="line">🔎  Verifying ingress addon...</div></pre></td></tr></table></figure>

<h2 id="k8s集群初步">k8s集群初步</h2>
<p>既然我们搭建好了一个k8s集群,我们不妨使用它部署一下应用和服务。</p>
<p>我们以rpcx微服务框架的一个hello world程序为例。</p>
<h3 id="部署一个rpcx服务端的应用">部署一个rpcx服务端的应用</h3>
<p>rpcx服务端的程序很简单:</p>
<figure class="highlight go"><figcaption><span>server.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/server"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">"addr"</span>, <span class="string">":8972"</span>, <span class="string">"server address"</span>)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// the second parameter is not a pointer</span></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(ctx context.Context, args example.Args, reply *example.Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	fmt.Println(<span class="string">"C="</span>, reply.C)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line">	<span class="comment">// s.Register(new(Arith), "")</span></div><div class="line">	s.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith), <span class="string">""</span>)</div><div class="line">	err := s.Serve(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>写一个Docker文件，编译并生成镜像:</p>
<figure class="highlight Dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">FROM golan<span class="variable">g:1</span>.<span class="number">18</span>-alpine <span class="keyword">as</span> builder</div><div class="line">WORKDIR /usr/src/app</div><div class="line">ENV GOPROXY=http<span class="variable">s:</span>//goproxy.<span class="keyword">cn</span></div><div class="line">RUN sed -<span class="keyword">i</span> <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories && \</div><div class="line">  apk <span class="built_in">add</span> --<span class="keyword">no</span>-cache <span class="keyword">ca</span>-certificates tzdata</div><div class="line">COPY ./<span class="keyword">go</span>.<span class="keyword">mod</span> ./</div><div class="line">COPY ./<span class="keyword">go</span>.sum ./</div><div class="line">RUN <span class="keyword">go</span> <span class="keyword">mod</span> download</div><div class="line">COPY . .</div><div class="line">RUN CGO_ENABLED=<span class="number">0</span> <span class="keyword">go</span> build -ldflags <span class="string">"-s -w"</span> -<span class="keyword">o</span> rpcx_server </div><div class="line"></div><div class="line">FROM scratch <span class="keyword">as</span> runner</div><div class="line">COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/<span class="built_in">localtime</span></div><div class="line">COPY --from=builder /etc/ssl/certs/<span class="keyword">ca</span>-certificates.crt /etc/ssl/certs/</div><div class="line">COPY --from=builder /usr/src/app/rpcx_server /<span class="keyword">opt</span>/app/</div><div class="line"></div><div class="line">EXPOSE <span class="number">8972</span></div><div class="line"></div><div class="line">CMD [<span class="string">"/opt/app/rpcx_server"</span>]</div></pre></td></tr></table></figure>

<p>生成镜像（我还把它推到了docker平台）:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker build . -t smallnest/rpcx-server-demo:<span class="number">0.1</span>.<span class="number">0</span></div><div class="line">docker push smallnest/rpcx-server-demo:<span class="number">0.1</span>.<span class="number">0</span></div></pre></td></tr></table></figure>

<p>接下来就是写部署文件了,使用我们的镜像，副本数为3:</p>
<figure class="highlight yaml"><figcaption><span>rpcx-server-demo.yaml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">apiVersion: apps/v1</div><div class="line">kind: <span class="type">Deployment</span></div><div class="line">metadata:</div><div class="line">  name: rpcx-server-demo-deployment</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: rpcx-server-demo</div><div class="line">  replicas: <span class="number">3</span></div><div class="line">  <span class="keyword">template</span>:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: rpcx-server-demo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: rpcx-server-demo</div><div class="line">        image: smallnest/rpcx-server-demo:<span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></div><div class="line">        ports:</div><div class="line">        - containerPort: <span class="number">8972</span></div></pre></td></tr></table></figure>

<p>接下了再定义服务,把我们的这个微服务暴露成k8s的一个服务:</p>
<figure class="highlight yaml"><figcaption><span>rpcx-server-demo-service.yaml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: rpcx-<span class="keyword">server</span>-demo-service	<span class="preprocessor">#Service 的名称</span></div><div class="line">  labels:     	<span class="preprocessor">#Service 自己的标签</span></div><div class="line">    app: rpcx-<span class="keyword">server</span>-demo	<span class="preprocessor">#为该 Service 设置 key 为 app，value 为 rpcx-server-demo 的标签</span></div><div class="line">spec:	    <span class="preprocessor">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span></div><div class="line">  selector:	    <span class="preprocessor">#标签选择器</span></div><div class="line">    app: rpcx-<span class="keyword">server</span>-demo	<span class="preprocessor">#选择包含标签 app:rpcx-server-demo 的 Pod</span></div><div class="line">  ports:</div><div class="line">  - name: rpcx-<span class="keyword">server</span>-demo-port	<span class="preprocessor">#端口的名字</span></div><div class="line">    protocol: TCP	    <span class="preprocessor">#协议类型 TCP/UDP</span></div><div class="line">    port: <span class="number">9981</span>	        <span class="preprocessor">#集群内的其他容器组可通过 9981 端口访问 Service</span></div><div class="line">    targetPort: <span class="number">8972</span>	<span class="preprocessor">#将请求转发到匹配 Pod 的 8972 端口</span></div></pre></td></tr></table></figure>

<p>最后执行下面的命令发布应用和服务:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl apply <span class="operator">-f</span> rpcx-server-demo.yaml</div><div class="line">kubectl apply <span class="operator">-f</span> rpcx-server-demo-service.yaml</div></pre></td></tr></table></figure>

<p>可以查看发布的应用和服务:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl get pods</div><div class="line">NAME                                           READY   STATUS    RESTARTS       AGE</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">42</span>wbm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">499</span>gm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc<span class="operator">-s</span>6gh9   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">25</span>h ago)    <span class="number">103</span>d</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl get svc</div><div class="line">NAME                       TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE</div><div class="line">kubernetes                 ClusterIP   <span class="number">10.96</span>.<span class="number">0.1</span>     &lt;none&gt;        <span class="number">443</span>/TCP    <span class="number">114</span>d</div><div class="line">rpcx-server-demo-service   ClusterIP   <span class="number">10.98</span>.<span class="number">134.3</span>   &lt;none&gt;        <span class="number">9981</span>/TCP   <span class="number">103</span>d</div></pre></td></tr></table></figure>

<h3 id="部署rpcx客户端的应用">部署rpcx客户端的应用</h3>
<p>类似的，我们也部署rpcx客户端的程序，它会调用我们刚才部署rpcx服务。</p>
<figure class="highlight go"><figcaption><span>client.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/protocol"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/client"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	port := os.Getenv(<span class="string">"RPCX_SERVER_DEMO_SERVICE_PORT"</span>)</div><div class="line">	addr := strings.TrimPrefix(port, <span class="string">"tcp://"</span>)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"dial "</span>, addr)</div><div class="line"></div><div class="line">	d, _ := client.NewPeer2PeerDiscovery(<span class="string">"tcp@"</span>+addr, <span class="string">""</span>)</div><div class="line">	opt := client.DefaultOption</div><div class="line">	opt.SerializeType = protocol.JSON</div><div class="line"></div><div class="line">	xclient := client.NewXClient(<span class="string">"Arith"</span>, client.Failtry, client.RandomSelect, d, opt)</div><div class="line">	<span class="keyword">defer</span> xclient.Close()</div><div class="line"></div><div class="line">	args := example.Args{</div><div class="line">		A:<span class="number"> 10</span>,</div><div class="line">		B:<span class="number"> 20</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		reply := &example.Reply{}</div><div class="line">		err := xclient.Call(context.Background(), <span class="string">"Mul"</span>, args, reply)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatalf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">		}</div><div class="line"></div><div class="line">		log.Printf(<span class="string">"%d * %d = %d"</span>, args.A, args.B, reply.C)</div><div class="line"></div><div class="line">		time.Sleep(time.Second)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编写一个Dockerfile文件，以便生成镜像:</p>
<figure class="highlight Dockerfile"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FROM golan<span class="variable">g:1</span>.<span class="number">18</span>-alpine <span class="keyword">as</span> builder</div><div class="line">WORKDIR /usr/src/app</div><div class="line">ENV GOPROXY=http<span class="variable">s:</span>//goproxy.<span class="keyword">cn</span></div><div class="line">RUN sed -<span class="keyword">i</span> <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories && \</div><div class="line">  apk <span class="built_in">add</span> --<span class="keyword">no</span>-cache <span class="keyword">ca</span>-certificates tzdata</div><div class="line">COPY ./<span class="keyword">go</span>.<span class="keyword">mod</span> ./</div><div class="line">COPY ./<span class="keyword">go</span>.sum ./</div><div class="line">RUN <span class="keyword">go</span> <span class="keyword">mod</span> download</div><div class="line">COPY . .</div><div class="line">RUN CGO_ENABLED=<span class="number">0</span> <span class="keyword">go</span> build -ldflags <span class="string">"-s -w"</span> -<span class="keyword">o</span> rpcx_client </div><div class="line"></div><div class="line">FROM busybox <span class="keyword">as</span> runner</div><div class="line">COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/<span class="built_in">localtime</span></div><div class="line">COPY --from=builder /etc/ssl/certs/<span class="keyword">ca</span>-certificates.crt /etc/ssl/certs/</div><div class="line">COPY --from=builder /usr/src/app/rpcx_client /<span class="keyword">opt</span>/app/</div><div class="line"></div><div class="line">CMD [<span class="string">"/opt/app/rpcx_client"</span>]</div></pre></td></tr></table></figure>

<p>编译生成镜像：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker build . -t smallnest/rpcx-<span class="keyword">client</span>-demo:<span class="number">0.1</span><span class="number">.0</span></div><div class="line">docker push smallnest/rpcx-<span class="keyword">client</span>-demo:<span class="number">0.1</span><span class="number">.0</span></div></pre></td></tr></table></figure>

<p>编写yaml文件:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apiVersion: apps/v1</div><div class="line">kind: <span class="type">Deployment</span></div><div class="line">metadata:</div><div class="line">  name: rpcx-client-demo-deployment</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: rpcx-client-demo</div><div class="line">  replicas: <span class="number">1</span></div><div class="line">  <span class="keyword">template</span>:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: rpcx-client-demo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: rpcx-client-demo</div><div class="line">        image: smallnest/rpcx-client-demo:<span class="number">0</span>.<span class="number">1</span>.<span class="number">0</span></div></pre></td></tr></table></figure>

<p>最后发布:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl apply <span class="operator">-f</span> rpcx-client-demo.yaml</div></pre></td></tr></table></figure>

<p>检查client是否发布成功了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl get pods</div><div class="line">NAME                                           READY   STATUS    RESTARTS       AGE</div><div class="line">rpcx-client-demo-deployment-<span class="number">699</span>bfb8799-wdsww   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">25</span>h ago)    <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">42</span>wbm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc-<span class="number">499</span>gm   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">102</span>d ago)   <span class="number">103</span>d</div><div class="line">rpcx-server-demo-deployment-<span class="number">7</span>f9d85c5dc<span class="operator">-s</span>6gh9   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">1</span> (<span class="number">25</span>h ago)    <span class="number">103</span>d</div></pre></td></tr></table></figure>

<p>因为我们的副本数是1,所以这里只有一个节点。</p>
<p>查看客户端的输出，可以看到它调用服务成功了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜  ~ kubectl logs rpcx-client-demo-deployment-<span class="number">699</span>bfb8799-wdsww |more</div><div class="line">dial  <span class="number">10.98</span>.<span class="number">134.3</span>:<span class="number">9981</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">17</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">18</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">19</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">20</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">21</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">22</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">23</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div><div class="line"><span class="number">2022</span><span class="regexp">/06/</span><span class="number">02</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">24</span> <span class="number">10</span> * <span class="number">20</span> = <span class="number">200</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://kubernetes.io/" target="_blank" rel="external">Kubernetes</a>（常简称为K8s）是用于自动部署、扩展和管理“容器化（containerized）应用程序”的开源系统。该系统由Google设计并捐赠给Cloud Native Computing Foundation（今属Linux基金会）来使用。</p>
<p>它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。 它支持一系列容器工具，包括Docker等。</p>
<p>Kubernetes（在希腊语意为“舵手”或“驾驶员”）由Joe Beda、Brendan Burns和Craig McLuckie创立，并由其他谷歌工程师，包括Brian Grant和Tim Hockin等进行加盟创作，并由谷歌在2014年首次对外宣布 。 该系统的开发和设计都深受谷歌的Borg系统的影响，其许多顶级贡献者之前也是Borg系统的开发者。在谷歌内部，Kubernetes的原始代号曾经是Seven，即星际迷航中的Borg（博格人）。Kubernetes标识中舵轮有七个轮辐就是对该项目代号的致意。</p>
<p>Kuberbetes一直是IT行业炽手可热的技术，很多同学都想学习它，但是刚想上手遇到了一个麻烦，需要搭建一个k8s的集群。虽然云服务提供商比如阿里云、百度云都提供了k8s集群的服务，但是还需要花一笔钱去购买服务和节点。如何在自己的机器上搭建一个k8s集群学习呢？本文给你介绍一种使用minikube搭建一个k8s测试集群的方法。</p>
]]>
    
    </summary>
    
      <category term="k8s" scheme="https://colobu.com/categories/k8s/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ebpf跟踪rpcx微服务]]></title>
    <link href="https://colobu.com/2022/05/22/use-ebpf-to-trace-rpcx-microservices/"/>
    <id>https://colobu.com/2022/05/22/use-ebpf-to-trace-rpcx-microservices/</id>
    <published>2022-05-22T08:34:29.000Z</published>
    <updated>2022-05-22T13:17:44.617Z</updated>
    <content type="html"><![CDATA[<p><a href="https://ebpf.io/zh-cn/" target="_blank" rel="external">ebpf</a>是一种创新的革命性技术，它能在内核中运行沙箱程序， 而无需修改内核源码或者加载内核模块。将 Linux 内核变成可编程之后，就能基于现有的（而非增加新的）抽象层来打造更加智能、 功能更加丰富的基础设施软件，而不会增加系统的复杂度，也不会牺牲执行效率和安全性。</p>
<p>BPF的第一个版本在1994年问世。我们在使用tcpdump工具编写规则的时候其实就使用到它了，该工具用于查看或”嗅探”网络数据包。</p>
<a id="more"></a>
<p><img src="ebpf.png" alt=""></p>
<p>使用ebpf技术，你可以从安全、跟踪&amp;性能分析、网络、观测&amp;监控等方向提供新的思路和技术：</p>
<ul>
<li>安全：可以从系统调用级、packet层、socket层进行安全检查，比如开发DDOS防护系统，编写防火墙程序。</li>
<li>网络：可以开发内核层高性能包处理程序，比如Cilium提供内核层的负载均衡，把service mesh往更深层推进，解决sidecar的性能问题。</li>
<li>跟踪&amp;性能分析: Linux提供多种类型的探针点(probe point),比如Kernel probes、perf events、Tracepoints、User-space probes、User statically defined tracepoints、XDP等等，我们可以编写probe程序收集这些探针点的信息，所以我们可以通过这种方式跟踪程序，分析性能。</li>
<li>观测&amp;监控: 对这些探针点的持续观测和监控，我们可以丰富我们的trace程序。关键是，我们不需要更改既有的程序，而是通过ebpf方法从其它程序进行观测。2014年，著名的内核黑客Alexei Starovoitov对BPF的功能进行了扩展。他增加了寄存器的数量和程序允许的大小，增加了JIT编译，并创建了一个用于检查程序是否安全的程序。然而，最令人印象深刻的是，新的BPF程序不仅能够在处理数据包时运行，而且能够响应其他内核事件，并在内核和用户空间之间来回传递信息。Alexei Starovoitov的新版本的BPF被称为eBPF（e代表扩展：extended）。但现在，它已经取代了所有旧版的BPF用法，并且已经变得非常流行，为了简单起见，它仍然被称为BPF。</li>
</ul>
<p><img src="functions.png" alt=""></p>
<p>你可以自己编写bpf程序，进行定制化的逻辑处理和分析，也可以使用大神们写好的工具，利用这些工具对程序进行通用的性能分析和跟踪。本文主要介绍使用一些工具对rpcx微服务程序进行通用的分析，既然是通用的，你可以可以对其它的Go程序进行分析，而且不仅限于Go程序，其它应用程序甚至内核你可以进行分析和跟踪。</p>
<p>自己编写bpf程序我准备再新开一篇文章介绍。</p>
<p>这一次主要介绍<a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc提供的相关工具</a>和<a href="https://github.com/iovisor/bpftrace" target="_blank" rel="external">bpftrace</a>。</p>
<p>bcc是用于创建基于eBPF的高效内核跟踪和操作程序的工具包，其中包括一些有用的命令行工具和示例。 BCC简化了用C进行内核检测的eBPF程序的编写，包括LLVM的包装器以及Python和Lua的前端。它还提供了用于直接集成到应用程序中的高级库。</p>
<p>bpftrace是Linux eBPF的高级跟踪语言。它的语言受awk和C以及DTrace和SystemTap等以前的跟踪程序的启发。 bpftrace使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p>
<h2 id="简单的_rpcx_微服务程序">简单的 rpcx 微服务程序</h2>
<p>既然要使用ebpf分析程序，首先我们要有一个程序。这里我选取了<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>一个最简单的例子，实现一个乘法的最小的微服务。</p>
<p>这个程序的代码可以在<a href="https://github.com/rpcxio/rpcx-examples/tree/master/102basic" target="_blank" rel="external">rpcx-examples-102basic</a>下载到。</p>
<p>服务端的程序如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/server"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"server address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// 使用ebpf跟踪这个服务调用</span></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(ctx context.Context, args example.Args, reply *example.Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	fmt.Println(<span class="string">"C="</span>, reply.C)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line">	s.RegisterName(<span class="string">"Arith"</span>, <span class="built_in">new</span>(Arith), <span class="string">""</span>)</div><div class="line">	err := s.Serve(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用<code>go build server.go</code>编译出<code>server</code>程序并运行(<code>./server</code>)。</p>
<p>客户端程序如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/protocol"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/client"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"server address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	d, _ := client.NewPeer2PeerDiscovery(<span class="string">"tcp@"</span>+*addr, <span class="string">""</span>)</div><div class="line">	opt := client.DefaultOption</div><div class="line">	opt.SerializeType = protocol.JSON</div><div class="line"></div><div class="line">	xclient := client.NewXClient(<span class="string">"Arith"</span>, client.Failtry, client.RandomSelect, d, opt)</div><div class="line">	<span class="keyword">defer</span> xclient.Close()</div><div class="line"></div><div class="line">	args := example.Args{</div><div class="line">		A:<span class="number"> 10</span>,</div><div class="line">		B:<span class="number"> 20</span>,</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		reply := &example.Reply{}</div><div class="line">		err := xclient.Call(context.Background(), <span class="string">"Mul"</span>, args, reply)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			log.Fatalf(<span class="string">"failed to call: %v"</span>, err)</div><div class="line">		}</div><div class="line"></div><div class="line">		log.Printf(<span class="string">"%d * %d = %d"</span>, args.A, args.B, reply.C)</div><div class="line">		time.Sleep(time.Second)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端每一秒会调用<code>Arith.Mul</code>微服务一次，微服务的逻辑也很简单，就是执行乘法，并把结果返回给客户端。</p>
<h2 id="跟踪和分析微服务">跟踪和分析微服务</h2>
<p>作为演示，本文只跟踪服务端<code>Arith.Mul</code>调用情况。</p>
<p>bcc提供了很多的基于bpf的分析程序，如下图(大神Brendan Gregg整理的经典图)</p>
<p><img src="bcc_tracing_tools_early2019.png" alt=""><br><img src="bpftrace_tools_early2019.png" alt=""></p>
<p>这里我们会选取几个相关的工具演示如何使用这些工具分析运行中的程序。 注意是运行中的程序，我们并没有给程序添加额外的一些埋点。</p>
<h3 id="bcc套件">bcc套件</h3>
<p>首先你得安装bcc套件，而且你的Linux内核还要足够新，在一些大厂的机房内，还有一些内核版本的2.6.x服务器，这些老的内核服务器不能支持ebpf或者ebpf的新特性。</p>
<p>我是在我的阿里云的一台虚机上测试的，它的版本是:</p>
<ul>
<li>Linux lab 4.18.0-348.2.1.el8_5.x86_64</li>
<li>CentOS Stream release 8</li>
</ul>
<p>直接<code>yum install bcc-tools</code>就可以安装这些工具。 </p>
<p>如果你是其它的版本的操作系统，你可以参考bcc的安装文档进行安装: <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md" target="_blank" rel="external">bcc/INSTALL</a>。</p>
<p>在使用工具分析之前，你首先要知道你的微服务<code>Arith.Mul</code>在符号表中的名称，你可以使用objdump查询到:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># objdump -t server|grep Mul|grep main</span></div><div class="line"><span class="number">000000000075</span>a5e0 g     F .text	<span class="number">00000000000000</span>d0              main.(*Arith).Mul</div></pre></td></tr></table></figure>

<p>它的名称是<code>main.(*Arith).Mul</code>,下面我们会使用这个名称分析这个微服务。</p>
<p>确保刚才的服务器一直在运行中。</p>
<h4 id="funccount">funccount</h4>
<p>funccount 用来统计一段时间内某个函数的调用次数。</p>
<p>在server所在的目录下执行下面的命令(如果在不同的路径，你需要更改命令参数中程序的路径):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -d 10  './server:main.*.Mul'</span></div><div class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"b'./server:main.*.Mul'"</span><span class="keyword">...</span> Hit Ctrl-C to end.</div><div class="line"></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'main.(*Arith).Mul'</span>                       <span class="number">10</span></div><div class="line">Detaching...</div><div class="line">[root@lab server]<span class="comment">#</span></div></pre></td></tr></table></figure>

<p>这里我们设置观察时间是10秒，可以看到在这10秒内，这个函数被调用了10次。</p>
<p>它包含几个参数，比如你可以持续观察，每5秒输出一次结果:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -Ti 5  './server:main.*.Mul'</span></div><div class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"b'./server:main.*.Mul'"</span>... Hit Ctrl-C to end.</div><div class="line"></div><div class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">29</span></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'main.(*Arith).Mul'</span>                        <span class="number">5</span></div></pre></td></tr></table></figure>

<p>我们甚至可以用它进行Go GC相关函数的跟踪:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -d 10  './server:runtime.*.gc*'</span></div><div class="line">Tracing <span class="number">21</span> functions <span class="keyword">for</span> <span class="string">"b'./server:runtime.*.gc*'"</span>... Hit Ctrl-C to end.</div><div class="line"></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'runtime.(*gcControllerState).update'</span>        <span class="number">2</span></div><div class="line">b<span class="string">'runtime.mallocgc'</span>                       <span class="number">250</span></div></pre></td></tr></table></figure>

<p>抑或是跟踪Go运行时的调度:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funccount -d 10  './server:runtime.schedule'</span></div><div class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"b'./server:runtime.schedule'"</span>... Hit Ctrl-C to end.</div><div class="line"></div><div class="line">FUNC                                    COUNT</div><div class="line">b<span class="string">'runtime.schedule'</span>                        <span class="number">20</span></div><div class="line">Detaching...</div></pre></td></tr></table></figure>

<h4 id="funclatency">funclatency</h4>
<p>funclatency统计函数的执行的耗时情况。<br>如果我们想分析<code>Arith.Mul</code>方法执行的情况，我们可以使用下面的命令，它会用直方图的形式展示这个函数调用的耗时分布:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[root<span class="variable">@lab</span> server]<span class="comment"># funclatency -d 10  './server:main.*.Mul'</span></div><div class="line"><span class="constant">Tracing </span><span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"./server:main.*.Mul"</span>... <span class="constant">Hit Ctrl-C </span>to <span class="keyword">end</span>.</div><div class="line"></div><div class="line"></div><div class="line"><span class="constant">Function </span>= b<span class="string">'main.(*Arith).Mul'</span> [<span class="number">359284</span>]</div><div class="line">     nsecs               <span class="symbol">:</span> count     distribution</div><div class="line">         <span class="number">0</span> -&gt; <span class="number">1</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">2</span> -&gt; <span class="number">3</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">4</span> -&gt; <span class="number">7</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">8</span> -&gt; <span class="number">15</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">16</span> -&gt; <span class="number">31</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">32</span> -&gt; <span class="number">63</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">64</span> -&gt; <span class="number">127</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">128</span> -&gt; <span class="number">255</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">256</span> -&gt; <span class="number">511</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">512</span> -&gt; <span class="number">1023</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">1024</span> -&gt; <span class="number">2047</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">2048</span> -&gt; <span class="number">4095</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">4096</span> -&gt; <span class="number">8191</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">8192</span> -&gt; <span class="number">16383</span>      <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">     <span class="number">16384</span> -&gt; <span class="number">32767</span>      <span class="symbol">:</span> <span class="number">7</span>        |****************************************|</div><div class="line">     <span class="number">32768</span> -&gt; <span class="number">65535</span>      <span class="symbol">:</span> <span class="number">3</span>        |*****************                       |</div><div class="line"></div><div class="line">avg = <span class="number">31978</span> nsecs, <span class="symbol">total:</span> <span class="number">319783</span> nsecs, <span class="symbol">count:</span> <span class="number">10</span></div></pre></td></tr></table></figure>

<p>我们统计了10秒的数据。可以看到期间这个函数被调用了10次。平均耗时31微秒。</p>
<p>如果我们想检查线上的程序有没有长尾的现象，使用这个工具很容易分析统计。</p>
<h4 id="funcslower">funcslower</h4>
<p>funcslower 这个工具可以跟踪内核和程序的执行慢的函数，比如使用下面的命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@lab server]<span class="comment"># funcslower -u 10  './server:main.(*Arith).Mul'</span></div><div class="line">Tracing function calls slower than <span class="number">10</span> us... Ctrl+C to quit.</div><div class="line">COMM           PID    LAT(us)             RVAL FUNC</div><div class="line">server         <span class="number">359284</span>   <span class="number">44.75</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">server         <span class="number">359284</span>   <span class="number">30.97</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">server         <span class="number">359284</span>   <span class="number">33.38</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">server         <span class="number">359284</span>   <span class="number">31.28</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div></pre></td></tr></table></figure>

<p>你甚至可以打印出堆栈信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@lab server]funcslower -UK -u <span class="number">10</span>  <span class="string">'./server:main.(*Arith).Mul'</span></div><div class="line">Tracing function calls slower than <span class="number">10</span> us... Ctrl+C to quit.</div><div class="line">COMM           PID    LAT(us)             RVAL FUNC</div><div class="line">server         <span class="number">359284</span>   <span class="number">31.20</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">    b<span class="string">'runtime.call64.abi0'</span></div><div class="line">    b<span class="string">'runtime.reflectcall'</span></div><div class="line">    b<span class="string">'reflect.Value.call'</span></div><div class="line">    b<span class="string">'reflect.Value.Call'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*service).call'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*Server).handleRequest'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*Server).serveConn.func2'</span></div><div class="line">    b<span class="string">'runtime.goexit.abi0'</span></div><div class="line">server         <span class="number">359284</span>   <span class="number">32.23</span>                <span class="number">0</span> ./server:main.(*Arith).Mul</div><div class="line">    b<span class="string">'runtime.call64.abi0'</span></div><div class="line">    b<span class="string">'runtime.reflectcall'</span></div><div class="line">    b<span class="string">'reflect.Value.call'</span></div><div class="line">    b<span class="string">'reflect.Value.Call'</span></div><div class="line">    b<span class="string">'github.com/smallnest/rpcx/server.(*service).call'</span></div></pre></td></tr></table></figure>

<h4 id="tcp_系列工具">tcp 系列工具</h4>
<p>bcc提供了一堆的对tcp的跟踪情况，我们可以针对不同的场景选择使用相应的工具。</p>
<ul>
<li>tools/tcpaccept: 跟踪TCP被动连接 (accept()). </li>
<li>tools/tcpconnect: 跟踪TCP主动的连接 (connect()).</li>
<li>tools/tcpconnlat: 跟踪TCP主动连接的延迟(connect()). </li>
<li>tools/tcpdrop: 跟踪内核的TCP包的丢包细节.</li>
<li>tools/tcplife: 跟踪TCP session(生命周期指标汇总).</li>
<li>tools/tcpretrans: 跟踪TCP重传.</li>
<li>tools/tcprtt: 跟踪TCP来回的耗时.</li>
<li>tools/tcpstates: 跟踪TCP session状态的改变.</li>
<li>tools/tcpsubnet: 按子网汇总和聚合TCP发送情况.</li>
<li>tools/tcpsynbl: 显示TCP SYN backlog的情况.</li>
<li>tools/tcptop: 按主机汇总TCP send/recv吞吐情况.</li>
<li>tools/tcptracer: 跟踪TCP 建立/关闭连接的情况 (connect(), accept(), close()).</li>
<li>tools/tcpcong: 跟踪TCP套接字拥塞控制状态持续时间.</li>
</ul>
<p>比如我们如果关注连接的建立情况，可以使用<code>tcptracer</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@lab lib]<span class="comment"># tcptracer</span></div><div class="line">Tracing TCP established connections. Ctrl-C to end.</div><div class="line">T  PID    COMM             IP SADDR            DADDR            SPORT  DPORT</div><div class="line">C  <span class="number">360005</span> client           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">43126</span>  <span class="number">8972</span></div><div class="line">X  <span class="number">360005</span> client           <span class="number">6</span>  [::<span class="number">1</span>]            [::<span class="number">1</span>]            <span class="number">43010</span>  <span class="number">8972</span></div><div class="line">A  <span class="number">359284</span> server           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">8972</span>   <span class="number">43126</span></div><div class="line">X  <span class="number">360005</span> client           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">43126</span>  <span class="number">8972</span></div><div class="line">X  <span class="number">359284</span> server           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">8972</span>   <span class="number">43126</span></div><div class="line">C  <span class="number">360009</span> client           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">43130</span>  <span class="number">8972</span></div><div class="line">X  <span class="number">360009</span> client           <span class="number">6</span>  [::<span class="number">1</span>]            [::<span class="number">1</span>]            <span class="number">43014</span>  <span class="number">8972</span></div><div class="line">A  <span class="number">359284</span> server           <span class="number">4</span>  <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="number">8972</span>   <span class="number">43130</span></div></pre></td></tr></table></figure>

<p>另外还有一堆的<code>xxxxsnoop</code>程序，可以对特定的系统调用进行跟踪。</p>
<h3 id="bpftrace">bpftrace</h3>
<p>有时候，我们想使用脚本实现一些定制化的跟踪，比如类似awk这样的工具，可以提供简单的脚本编写。</p>
<p>bpftrace就是这样的工具, 它使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p>
<p>bpftrace参考手册可以在<a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#20-override-override-return-value" target="_blank" rel="external">bpftrace reference_guide</a>找到。</p>
<p>以我们的<code>Arith.Mul</code>为例，我们可以使用下面的命令，在函数调用时加入探针，把输入的参数打印出来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@lab server]# bpftrace -e <span class="string">'uprobe:./server:main.*.Mul {printf("%s - %s: arg1: %d, arg2: %d\n", comm, func, arg0, arg1)}'</span></div><div class="line">Attaching<span class="number"> 1</span> probe...</div><div class="line">server - main.(*Arith).Mul: arg1:<span class="number"> 10</span>, arg2:<span class="number"> 20</span></div><div class="line">server - main.(*Arith).Mul: arg1:<span class="number"> 10</span>, arg2:<span class="number"> 20</span></div><div class="line">server - main.(*Arith).Mul: arg1:<span class="number"> 10</span>, arg2:<span class="number"> 20</span></div></pre></td></tr></table></figure>

<p>为什么arg0,arg1就能把参数打印出来呢？简单说，我们的微服务参数正好是两个int64的整数，正好对应arg0,arg1。</p>
<p>rpcx的服务返回值也是当做参数传入的，函数调用的时候还没有设置，所以你如果打印arg3并不是reply返回值。</p>
<p>这个时候我们需要移动探针，加一个偏移量，加多少的偏移量呢？通过反汇编我们看到加92时返回值已经赋值了，所以使用下面的命令就可以打印返回值了(这个时候第一个参数就被覆盖掉了):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@lab <span class="keyword">server</span>]<span class="preprocessor"># bpftrace -e 'uprobe:./server:main.*.Mul+92 {printf("%s - %s: reply: %d\n", comm, func, arg0)}'</span></div><div class="line">Attaching <span class="number">1</span> probe...</div><div class="line"><span class="keyword">server</span> - main.(*Arith).Mul: reply: <span class="number">200</span></div><div class="line"><span class="keyword">server</span> - main.(*Arith).Mul: reply: <span class="number">200</span></div><div class="line"><span class="keyword">server</span> - main.(*Arith).Mul: reply: <span class="number">200</span></div></pre></td></tr></table></figure>

<blockquote>
<p>Go自1.17开始已经改成了基于寄存器的调用惯例，所以这里使用了内建的arg0、arg1、..., 如果你使用更早的Go版本，这里你可以换成sarg0,sarg1,...试试(stack arguments)。</p>
</blockquote>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html" target="_blank" rel="external">https://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html</a></li>
<li><a href="https://golangexample.com/library-to-work-with-ebpf-programs-from-golang/" target="_blank" rel="external">https://golangexample.com/library-to-work-with-ebpf-programs-from-golang/</a></li>
<li><a href="https://tonybai.com/2020/12/25/bpf-and-go-modern-forms-of-introspection-in-linux/" target="_blank" rel="external">https://tonybai.com/2020/12/25/bpf-and-go-modern-forms-of-introspection-in-linux/</a></li>
<li><a href="https://networkop.co.uk/post/2021-03-ebpf-intro/" target="_blank" rel="external">https://networkop.co.uk/post/2021-03-ebpf-intro/</a></li>
<li><a href="https://medium.com/bumble-tech/bpf-and-go-modern-forms-of-introspection-in-linux-6b9802682223#db17" target="_blank" rel="external">https://medium.com/bumble-tech/bpf-and-go-modern-forms-of-introspection-in-linux-6b9802682223#db17</a></li>
<li><a href="https://blog.px.dev/ebpf-http-tracing/" target="_blank" rel="external">https://blog.px.dev/ebpf-http-tracing/</a></li>
<li><a href="https://www.ebpf.top/post/ebpf_and_go/" target="_blank" rel="external">https://www.ebpf.top/post/ebpf_and_go/</a></li>
<li><a href="https://www.ebpf.top/" target="_blank" rel="external">https://www.ebpf.top/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://ebpf.io/zh-cn/" target="_blank" rel="external">ebpf</a>是一种创新的革命性技术，它能在内核中运行沙箱程序， 而无需修改内核源码或者加载内核模块。将 Linux 内核变成可编程之后，就能基于现有的（而非增加新的）抽象层来打造更加智能、 功能更加丰富的基础设施软件，而不会增加系统的复杂度，也不会牺牲执行效率和安全性。</p>
<p>BPF的第一个版本在1994年问世。我们在使用tcpdump工具编写规则的时候其实就使用到它了，该工具用于查看或”嗅探”网络数据包。</p>
]]>
    
    </summary>
    
      <category term="go" scheme="https://colobu.com/tags/go/"/>
    
      <category term="ebpf" scheme="https://colobu.com/tags/ebpf/"/>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[atomic包的新变化]]></title>
    <link href="https://colobu.com/2022/05/06/changes-in-atomic-package/"/>
    <id>https://colobu.com/2022/05/06/changes-in-atomic-package/</id>
    <published>2022-05-06T00:59:12.000Z</published>
    <updated>2022-05-22T08:37:06.156Z</updated>
    <content type="html"><![CDATA[<p>Russ Cox在去年的系列<a href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/" target="_blank" rel="external">文章</a>中，提到对atomic包的改变，并且开了一个issue供大家<a href="https://github.com/golang/go/discussions/47141" target="_blank" rel="external">讨论</a>,现在他提交的改变已经merge到master分支，Go 1.19就会包含这些改变。</p>
<a id="more"></a>
<p>你也可以使用<a href="https://pkg.go.dev/golang.org/dl/gotip" target="_blank" rel="external">gotip</a>提前了解这些改变。</p>
<p>Russ Cox这次的提交只是对atomic补充了一些新的类型，这些类型是对基本类型(primitive type, 如bool、int32、int64、uint32、uint64、uintptr等)的一个包装，以便提供原子操作。</p>
<p>事实上，uber很早以前就提供类似的功能，也许你很早之前就使用过<a href="https://github.com/uber-go/atomic" target="_blank" rel="external">uber-go/atomic</a>这个库。</p>
<p>Russ Cox实现的方式也类似，毕竟，这个为基本类型实现包装器的套路还是比较固定的，但是实现上略微有些不同。</p>
<ul>
<li>Russ Cox在标准库中的实现<ul>
<li>嵌入<code>_ noCopy</code>,方便go vet等工具做data race检查</li>
<li>代码可以进行inline,提高性能</li>
</ul>
</li>
<li>Uber的实现<ul>
<li>嵌入<code>_ nocmp</code>,避免非原子比较</li>
<li>提供JSON Marshal/UnMarshal的功能，方便序列化</li>
<li>提供更多类型的包装器: <code>Duration</code>、<code>String</code>、<code>Time</code>、<code>Float64</code>、<code>Error</code></li>
</ul>
</li>
</ul>
<p>我们在这篇文章中主要介绍Russ Cox的实现，毕竟这是Go标准库中的改动，我多少要对这些改动有些印象，在我们将来的代码开发，或者看别人的代码时做到心中有数。</p>
<p>这次改动增加了bool、int32、int64、uint32、uint64、uintptr、Value、unsafe.Pointer类型的包装器：<code>Bool</code>、<code>Int32</code>、<code>Int64</code>、<code>Uint32</code>、<code>Uint64</code>、<code>Uintptr</code>、<code>Value</code>、<code>Pointer</code>。</p>
<p>所有这些类型都包含下面四个<strong>方法</strong>:</p>
<ul>
<li>CompareAndSwap(old, new *T) (swapped bool) : 执行CAS操作</li>
<li>Load() *T : 原子load对应的值</li>
<li>Store(val *T) : 将值val原子存储</li>
<li>Swap(new <em>T) (old </em>T)： 原子保存新值，并返回老的值</li>
</ul>
<p>针对不同的类型，可能还会有一些额外的方法，比如:</p>
<ul>
<li>Int32: <code>func (x *Int32) Add(delta int32) (new int32)</code></li>
<li>Int64: <code>func (x *Int64) Add(delta int64) (new int64)</code></li>
<li>Uint32: <code>func (x *Int64) Add(delta int64) (new int64)</code></li>
<li>Uint64: <code>func (x *Uint64) Add(delta uint64) (new uint64)</code></li>
<li>Uintptr: <code>func (x *Uintptr) Add(delta uintptr) (new uintptr)</code></li>
</ul>
<p>同样，针对<code>Uint32</code>、<code>Uint64</code>类型，只有Add方法，如果想减去一个正值c，就得利用Add加上一个负值（-c），可是delta的类型都是uxxx类型，怎么办呢？使用<code>^uint64(c-1)</code>或者<code>^uint32(c-1)</code>。</p>
<p>这些包装器和方法其实对应的是atomic的相应的函数，所以使用起来没什么难度:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i Int64</div><div class="line">i.Add<span class="number">(100</span>)</div><div class="line">i.Load()</div><div class="line">i.Store<span class="number">(200</span>)</div><div class="line">i.Swap<span class="number">(300</span>)</div><div class="line">I.CompareAndSwap<span class="number">(300</span><span class="number">,400</span>)</div></pre></td></tr></table></figure>

<p>你可以查看go doc了解更详细的信息: <a href="https://pkg.go.dev/sync/atomic@master" target="_blank" rel="external">sync/atomic</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Russ Cox在去年的系列<a href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/" target="_blank" rel="external">文章</a>中，提到对atomic包的改变，并且开了一个issue供大家<a href="https://github.com/golang/go/discussions/47141" target="_blank" rel="external">讨论</a>,现在他提交的改变已经merge到master分支，Go 1.19就会包含这些改变。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型的坏例子]]></title>
    <link href="https://colobu.com/2022/04/26/Crimes-with-Go-Generics/"/>
    <id>https://colobu.com/2022/04/26/Crimes-with-Go-Generics/</id>
    <published>2022-04-26T00:09:46.000Z</published>
    <updated>2022-05-22T08:37:06.156Z</updated>
    <content type="html"><![CDATA[<p>Go 1.18发布了第一版的Go泛型之后，大家开始对Go泛型进行了深入的研究，今天翻译的这一篇，是加拿大的Xe Iaso刚出炉的一篇有趣的<a href="https://christine.website/blog/gonads-2022-04-24" target="_blank" rel="external">文章</a>，对Go泛型的应用做了一些探索。</p>
<a id="more"></a>
<p>Go 1.18在语言中添加了泛型特性。允许您把你的类型作为参数，这样你可以创建复合类型（类型之外的类型）。这让你在使用Go的过程中可以有更多的表现力和清晰度。</p>
<p>然而，如果你正在寻找关于如何使用Go泛型的好主意，这篇文章不适合你。这里面满是坏主意。这篇文章全是不应该在生产环境中使用Go泛型的方法。不要将本文中的示例复制到生产中。通过阅读本文，您同意不将本文中的示例复制到生产中。</p>
<p>我已将本文的代码放在<a href="https://tulpa.dev/internal/gonads" target="_blank" rel="external">我的git服务器</a>上。我故意采取以下步骤以便代码难以在生产环境中使用：</p>
<ol>
<li>我在一个名为<code>internal</code>的gitea组织下创建了它。这将使您无法导入包，除非您是从我的gitea服务器上的repo使用它。该gitea服务器上的注册被禁用。有关内部包规则的更多信息，请参见<a href="https://go.dev/doc/go1.4#internalpackages" target="_blank" rel="external">此处</a>。</li>
<li>软件包文档包含一条神奇的注释，它会让staticcheck和其他linter 警告您正在使用的软件包已被弃用。</li>
</ol>
<h2 id="Queue[T]"><code>Queue[T]</code></h2>
<p>首先，让我们展示一下计算机科学中一个难题。让我们创建一个MPMS（multiple producer, multiple subscriber,多生产者、多消费者）队列,这是我们并发编程常见的一种数据结构。</p>
<p>首先，我们需要一个struct来包装一切。它看起来是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Queue[T any] <span class="keyword">struct</span> {</div><div class="line">  data <span class="keyword">chan</span> T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码创建了一个名为<code>Queue</code>的类型，它接受一个类型参数<code>T</code>。这个<code>T</code>可以是任何类型，但唯一要求是这个数据是一个Go类型。</p>
<p>您可以使用以下函数为<code>Queue[T]</code>实例创建一个小小的构造函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NewQueue[T any](size <span class="typename">int</span>) Queue[T] {</div><div class="line">  <span class="keyword">return</span> Queue[T]{</div><div class="line">    data: <span class="built_in">make</span>(<span class="keyword">chan</span> T, size),</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，让我们在<code>Queue</code> struct上创建一些方法，当然也就是压入和弹出操作了。它们可能是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (q Queue[T]) Push(val T) {</div><div class="line">  q.data &lt;- val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (q Queue[T]) Pop() T {</div><div class="line">  <span class="keyword">return</span> &lt;-q.data</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这些方法将允许您将数据放在队列的末尾，然后从头部取出数据。你可以这样使用它们：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">q := NewQueue[<span class="typename">string</span>]<span class="number">(5</span>)</div><div class="line">q.Push(<span class="string">"hi there"</span>)</div><div class="line">str := q.Pop()</div><div class="line"><span class="keyword">if</span> str != <span class="string">"hi there"</span> {</div><div class="line">  <span class="built_in">panic</span>(<span class="string">"string is wrong"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前来说一切都好，但是有个小问题，当队列为空时，调用<code>Pop</code>时调用者会被阻塞在那里，我们可以使用<code>select - default</code>语句来实现非阻塞版本的<code>TrpPop</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> (q Queue[T]) TryPop() (T, <span class="typename">bool</span>) {</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> val := &lt;-q.data:</div><div class="line">    <span class="keyword">return</span> val, <span class="constant">true</span></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，不幸的事情发生了，上面的代码无法编译,出错信息如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cannot use <span class="constant">nil</span> as T value in <span class="keyword">return</span> statement</div></pre></td></tr></table></figure>

<p>在该代码中，<code>T</code>可以是任何值，包括可能不为nil的值。我们可以利用var语句来解决这个问题，它生成一个新变量，并将其初始化为该类型的零值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Zero[T any]() T {</div><div class="line">  <span class="keyword">var</span> zero T</div><div class="line">  <span class="keyword">return</span> zero</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以像下面一样使用这个返回零值的函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">log.Printf(<span class="string">"%q"</span>, Zero[<span class="typename">string</span>]())</div><div class="line">log.Printf(<span class="string">"%v"</span>, Zero[<span class="typename">int</span>]())</div></pre></td></tr></table></figure>

<p>输出的结果可能如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2009</span><span class="regexp">/11/</span><span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> <span class="string">""</span></div><div class="line"><span class="number">2009</span><span class="regexp">/11/</span><span class="number">10</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></div></pre></td></tr></table></figure>

<p>现在我们就可以改造<code>TryPop</code>的<code>default</code>分支了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (q Queue[T]) TryPop() (T, <span class="typename">bool</span>) {</div><div class="line">  <span class="keyword">select</span> {</div><div class="line">  <span class="keyword">case</span> val := &lt;-q.data:</div><div class="line">    <span class="keyword">return</span> val, <span class="constant">true</span></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="keyword">var</span> zero T</div><div class="line">    <span class="keyword">return</span> zero, <span class="constant">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后我们写一个单元测试来测试它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestQueue(t *testing.T) {</div><div class="line">  q := NewQueue[<span class="typename">int</span>]<span class="number">(5</span>)</div><div class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> <span class="built_in">make</span>([]<span class="keyword">struct</span>{},<span class="number"> 5</span>) {</div><div class="line">    q.Push(i)</div><div class="line">  }</div><div class="line">	</div><div class="line">  <span class="keyword">for</span> <span class="keyword">range</span> <span class="built_in">make</span>([]<span class="keyword">struct</span>{},<span class="number"> 5</span>) {</div><div class="line">    t.Log(q.Pop())</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Option[T]"><code>Option[T]</code></h2>
<p>使用Go时，人们会有很多原因使用指针值：</p>
<ul>
<li>指针值可能为零，因此可以表示该值可能不存在。</li>
<li>指针值只在内存中存储偏移量，因此传递该值会导致只复制指针，而不用复制传递的值。</li>
<li>传递给函数的指针值允许您在传递中改变值。否则Go将复制该值，您就可以随心所欲地对其进行更改，但所做的更改不会持续到函数调用之后。你可以认为这是“不可变的”，但它不像在Rust中函数传递那样严格。</li>
</ul>
<p><code>Optiion[T]</code>类型可以帮助我们对第一条约束创建一个容器：一个值可能不存在。我们可以这样定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Option[T any] <span class="keyword">struct</span> {</div><div class="line">  val *T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你需要为这个容器实现一组方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ErrOptionIsNone = errors.New(<span class="string">"gonads: Option[T] has no value"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o Option[T]) Take() (T, error) {</div><div class="line">  <span class="keyword">if</span> o.IsNone() {</div><div class="line">    <span class="keyword">var</span> zero T</div><div class="line">    <span class="keyword">return</span> zero, ErrOptionIsNone</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">return</span> *o.val, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Option[T]) Set(val T) {</div><div class="line">  o.val = &val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o *Option[T]) Clear() {</div><div class="line">  o.val = <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>Some other functions that will be useful will be an IsSome function to tell if the Option contains a value. We can use this to also implement an IsNone function that will let you tell if that Option does not contain a value. They will look like this:</p>
<p>其他一些有用的函数包括<code>IsSome</code>函数，用于判断<code>Option</code>是否包含值。我们还可以为它实现一个<code>IsNone</code>函数，该函数将让您判断该<code>Option</code>是否不包含值。它们看起来是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (o Option[T]) IsSome() <span class="typename">bool</span> {</div><div class="line">  <span class="keyword">return</span> o.val != <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (o Option[T]) IsNone() <span class="typename">bool</span> {</div><div class="line">  <span class="keyword">return</span> !o.IsSome()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当<code>Option</code>没有保存某个值时，我们可以说<code>Option</code>为空，我们可以使用<code>IsSome</code>来实现<code>IsNone</code>。</p>
<p>最后我们把这些都放在<code>Yank</code>函数中，它类似Rust语言中的<code>Option::unwrap()</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (o Option[T]) Yank() T {</div><div class="line">  <span class="keyword">if</span> o.IsNone() {</div><div class="line">    <span class="built_in">panic</span>(<span class="string">"gonads: Yank on None Option"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">return</span> *o.val</div><div class="line">}</div></pre></td></tr></table></figure>

<p>写个Go单元测试校验它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestOption(t *testing.T) {</div><div class="line">  o := NewOption[<span class="typename">string</span>]()</div><div class="line">  val, err := o.Take()</div><div class="line">  <span class="keyword">if</span> err == <span class="constant">nil</span> {</div><div class="line">    t.Fatalf(<span class="string">"[unexpected] wanted no value out of Option[T], got: %v"</span>, val)</div><div class="line">  }</div><div class="line">    </div><div class="line">  o.Set(<span class="string">"hello friendos"</span>)</div><div class="line">  _, err = o.Take()</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    t.Fatalf(<span class="string">"[unexpected] wanted no value out of Option[T], got: %v"</span>, err)</div><div class="line">  }</div><div class="line">    </div><div class="line">  o.Clear()</div><div class="line">  <span class="keyword">if</span> o.IsSome() {</div><div class="line">    t.Fatal(<span class="string">"Option should have none, but has some"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>脱离本篇文章，我认为<code>Option[T]</code>, 但是它需要更进一步的工作和泛化（才能更好的应用在生产环境），这应当是Go核心团队去做的事情，而不是第三方自己去实现。</p>
</blockquote>
<h2 id="Thunk[T]"><code>Thunk[T]</code></h2>
<p>在计算机科学中，我们通常程序分成数值(value)和计算(computation)。通常我们会处理其中一个,或者另一个。但是有时候计算也可以被视为值，但这是非常罕见的。更为罕见的是，将部分完成的计算用作一个值。</p>
<p><code>thunk</code>是一种存储为值的部分计算。为了了解我所说的内容，让我们考虑一下这个JavaScript函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> add = (x, y) =&gt; x + y;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">2</span>)); <span class="comment">// 4</span></div></pre></td></tr></table></figure>

<p>上面的代码实现了一个<code>add</code>函数对象，需要两个参数，返回一个参数。很多场景下都会这么使用。但是如果我们只绑定一个参数，让另一个参数做变量，这会变得很困难。</p>
<p>我们可以这样实现<code>add</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> add = (x) =&gt; (y) =&gt; x + y;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)(<span class="number">2</span>)); <span class="comment">// 4</span></div></pre></td></tr></table></figure>

<p>它需要我们部分的实现<code>add</code>函数，比如<code>addTwo</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addTwo = add(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(addTwo(<span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>

<p>也可以用在不需要参数的函数中，这样实现了延迟计算:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> hypotenuse = (x, y) =&gt; <span class="built_in">Math</span>.sqrt(x * x + y * y);</div><div class="line"><span class="keyword">const</span> thunk = () =&gt; hypot(<span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>

<p>你可以传递<code>trunk</code>对象，而不必立即计算它，只有在需要的时候才去计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dominateWorld(thunk); <span class="comment">// thunk is passed as an unevaluated function</span></div></pre></td></tr></table></figure>

<p>现在我们使用Go来实现这个类型:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Thunk[T any] <span class="keyword">struct</span> {</div><div class="line">  doer <span class="keyword">func</span>() T</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后使用<code>Force</code>函数强制<code>Trunk</code>进行计算:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (t Thunk[T]) Force() T {</div><div class="line">  <span class="keyword">return</span> t.doer()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是可行的，但是我们也可以比JavaScript示例更进一步。我们可以利用<code>Thunk[T]</code>容器来缓存<code>doer</code>函数的结果，这样多次调用它实际上只会返回一次相同的结果。</p>
<blockquote>
<p>请记住，这只适用于纯函数，或不修改外部世界的函数。这也不仅仅是全局变量，而是任何可以在任何地方修改任何状态的函数，包括网络和文件系统IO。(如果你不理解纯函数，可以搜索pure function了解更多)</p>
</blockquote>
<p>所以<code>Trunk[T]</code>可以实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Thunk[T any] <span class="keyword">struct</span> {</div><div class="line">  doer <span class="keyword">func</span>() T <span class="comment">// action being thunked</span></div><div class="line">  o    *Option[T] <span class="comment">// cache for complete thunk data</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Thunk[T]) Force() T {</div><div class="line">  <span class="keyword">if</span> t.o.IsSome() {</div><div class="line">    <span class="keyword">return</span> t.o.Yank()</div><div class="line">  }</div><div class="line">    </div><div class="line">  t.o.Set(t.doer())</div><div class="line">  <span class="keyword">return</span> t.o.Yank()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewThunk[T any](doer <span class="keyword">func</span>() T) *Thunk[T] {</div><div class="line">  <span class="keyword">return</span> &Thunk[T]{</div><div class="line">    doer: doer,</div><div class="line">    o:    NewOption[T](),</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在来一个复杂点的例子，我们用它实现斐波那契函数。斐波那契函数正规的例子如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Fib(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">  <span class="keyword">if</span> n &lt;=<span class="number"> 1</span> {</div><div class="line">    <span class="keyword">return</span> n</div><div class="line">  }</div><div class="line">    </div><div class="line">  <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们写一个单元测试看看它的时间花费:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestRecurFib(t *testing.T) {</div><div class="line">  t.Log(Fib<span class="number">(40</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行go test,结果如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go test -run RecurFib</div><div class="line"><span class="header">=== RUN   TestRecurFib</span></div><div class="line"><span class="code">    thunk_test.go:15: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestRecurFib (0.36s)</div></pre></td></tr></table></figure>

<p>然而，我们可以使用刚才实现的<code>Trunk[T]</code>实现它，不过更复杂了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestThunkFib(t *testing.T) {</div><div class="line">  cache := <span class="built_in">make</span>([]*Thunk[<span class="typename">int</span>],<span class="number"> 41</span>)</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> fib <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span></div><div class="line">  fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">if</span> cache[n].o.IsSome() {</div><div class="line">      <span class="keyword">return</span> *cache[n].o.val</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> cache {</div><div class="line">    i := i</div><div class="line">    cache[i] = NewThunk(<span class="keyword">func</span>() <span class="typename">int</span> { <span class="keyword">return</span> fib(i) })</div><div class="line">  }</div><div class="line">  cache<span class="number">[0</span>].o.Set<span class="number">(0</span>)</div><div class="line">  cache<span class="number">[1</span>].o.Set<span class="number">(1</span>)</div><div class="line">  </div><div class="line">  t.Log(cache<span class="number">[40</span>].Force())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>执行go test,.输出结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="header">=== RUN   TestThunkFib</span></div><div class="line"><span class="code">    thunk_test.go:36: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestThunkFib (0.60s)</div></pre></td></tr></table></figure>

<p>奇怪不？为什么更慢了?我们不是缓存了中间计算的结果了么？下面的代码是我们常见的优化，我们的版本和下面不是一样的么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestMemoizedFib(t *testing.T) {</div><div class="line">  mem := <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>{</div><div class="line">   <span class="number"> 0</span>:<span class="number"> 0</span>,</div><div class="line">   <span class="number"> 1</span>:<span class="number"> 1</span>,</div><div class="line">  }</div><div class="line">    </div><div class="line">  <span class="keyword">var</span> fib <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span></div><div class="line">  fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">if</span> result, ok := mem[n]; ok {</div><div class="line">      <span class="keyword">return</span> result</div><div class="line">    }</div><div class="line">        </div><div class="line">    result := fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">    mem[n] = result</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  }</div><div class="line">    </div><div class="line">  t.Log(fib<span class="number">(40</span>))</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ go test -run Memoized</div><div class="line"><span class="header">=== RUN   TestMemoizedFib</span></div><div class="line"><span class="code">    thunk_test.go:35: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestMemoizedFib (0.00s)</div></pre></td></tr></table></figure>

<p>如果你把我们使用<code>Trunk[T]</code>的斐波那契函数改动如下，也是能快速跑完的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">  <span class="keyword">if</span> cache[n].o.IsSome() {</div><div class="line">    <span class="keyword">return</span> *cache[n].o.val</div><div class="line">  }</div><div class="line">  </div><div class="line">  result := fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">  cache[n].o.Set(result)</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="header">=== RUN   TestThunkFib</span></div><div class="line"><span class="code">    thunk_test.go:59: 102334155</span></div><div class="line"><span class="bullet">--- </span>PASS: TestThunkFib (0.00s)</div></pre></td></tr></table></figure>

<p>要明确的是，这不是Go泛型的错。我几乎可以肯定的是，我糟糕的代码导致了速度大大降低。</p>
<blockquote>
<p>网友指出我的代码事实上是错误的，我的<code>fib</code>实现应该如下:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fib = <span class="keyword">func</span>(n <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">  <span class="keyword">return</span> cache[n<span class="number">-1</span>].Force() + cache[n<span class="number">-2</span>].Force()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我很高兴Go语言添加了泛型。这肯定会让很多事情变得更容易，更富有表现力。我担心在学习Go泛型的过程会给人们带来很多麻烦，。泛型应在特定情况下使用，而不是被滥用。</p>
<p>我希望这是一个关于如何在Go中使用泛型的有趣研究，但请不要在生产中使用这些示例。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.18发布了第一版的Go泛型之后，大家开始对Go泛型进行了深入的研究，今天翻译的这一篇，是加拿大的Xe Iaso刚出炉的一篇有趣的<a href="https://christine.website/blog/gonads-2022-04-24" target="_blank" rel="external">文章</a>，对Go泛型的应用做了一些探索。</p>
]]>
    
    </summary>
    
      <category term="go" scheme="https://colobu.com/categories/go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Uber工程师对真实世界并发问题的研究]]></title>
    <link href="https://colobu.com/2022/04/07/A-Study-of-Real-World-Data-Races-in-Golang/"/>
    <id>https://colobu.com/2022/04/07/A-Study-of-Real-World-Data-Races-in-Golang/</id>
    <published>2022-04-07T00:16:19.000Z</published>
    <updated>2022-05-22T08:37:06.155Z</updated>
    <content type="html"><![CDATA[<p>今天Uber工程师放出一篇论文(<a href="https://arxiv.org/abs/2204.00764" target="_blank" rel="external">A Study of Real-World Data Races in Golang</a>)，作者是Uber的工程师Milind Chabbi和Murali Krishna Ramanathan，他们负责使用Go内建的data race detector在Uber内的落地，经过6个多月的研究分析，他们将data race detector成功落地，并基于对多个项目的分析，得出了一些有趣的结论。</p>
<a id="more"></a>
<p>我们知道，Go是Uber公司的主打编程语言。他们对Uber的2100个不同的微服务，4600万行Go代码的分析，发现了超过2000个的有数据竞争的bug, 修复了其中的1000多个，剩余的正在分析修复中。</p>
<p>谈起真实世界中的Go并发Bug,其实2019年我们华人学者的<a href="https://songlh.github.io/paper/go-study.pdf" target="_blank" rel="external">Understanding Real-World Concurrency Bugs in Go</a>论文可以说是开山之作，首次全面系统地分析了几个流行的大型Go项目的并发bug。今天谈的这一篇呢，是Uber工程师针对Uber的众多的Go代码做的分析。我猜他们可能是类似国内工程效能部的同学，所以这篇论文有一半的篇幅介绍Go data race detector是怎么落地的，这个我们就不详细讲了，这篇论文的另一半是基于对data race的分析，罗列出了常见的出现data race的场景，对我们Gopher同学来说，很有学习的意义，所以我晚上好好拜读了一下这篇论文，做一总结和摘要。</p>
<p>作为一个大厂，肯定不止一种开发语言，作者对Uber线上个编程语言(go、java、nodejs、python)进行分析，可以看到：</p>
<ol>
<li>相比较Java， 在Go语言中会更多的使用并发处理</li>
<li>同一个进程中，nodejs平均会启动16个线程，python会启动16-32个线程，java进程一般启动128-1024个线程，10%的Java程序启动4096个线程，7%的java程序启动8192个线程。Go程序一般启动1024-4096个goroutine,6%的Go程序启动8192个goroutine(原文是8102，我认为是一个笔误)，最大13万个。</li>
</ol>
<p>可以看到Go程序会比其它语言有更多的并发单元，更多的并发单元意味着存在着更多的并发bug。Uber代码库中都有哪些类的并发bug呢？</p>
<p>下面的介绍会很多的使用数据竞争概念(data race)，它是并发编程中常见的概念，有数据竞争，意味着有多个并发单元对同一个数据资源有并发的读写，至少有一个写，有可能会导致并发问题。</p>
<h2 id="透明地引用捕获_(Transparent_Capture-by-Reference)">透明地引用捕获 (Transparent Capture-by-Reference)</h2>
<p>直接翻译过来你可能觉得不知所云。Transparent是指没有显示的声明或者定义，就直接引用某些变量，很容易导致数据竞争。通过例子更容易理解。这是一大类，我们分成小类逐一介绍。</p>
<h3 id="循环变量的捕获">循环变量的捕获</h3>
<p>不得不说，这也是我最常犯的错误。虽然明明知道会有这样的问题，但是在开发的过程中，总是无意的犯这样的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _ , job := <span class="keyword">range</span> jobs {</div><div class="line"> <span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">   ProcessJob ( job )</div><div class="line"> }()</div><div class="line"> } <span class="comment">// end for</span></div></pre></td></tr></table></figure>

<p>比如这个简单的例子,job是索引变量，循环中启动了一个goroutine处理这个job。job变量就透明地被这个goroutine引用。</p>
<p>循环变量是唯一的，意味着启动的这个goroutine,有可能处理的都是同一个job,而并不是期望的没有一个job。</p>
<p>这个例子还很明显，有时候循环体内特别复杂，可能并不像这个例子那么容易发现。</p>
<h3 id="err变量被捕获">err变量被捕获</h3>
<p>下面这个例子，y,z的赋值时，会对同一个err进行写操作，也可能会导致数据竞争，产生并发问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">x , err := Foo ()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line"> <span class="keyword">var</span> y <span class="typename">int</span></div><div class="line"> y , err = Bar ()</div><div class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">  ...</div><div class="line">  }</div><div class="line">}()</div><div class="line"></div><div class="line"><span class="keyword">var</span> z <span class="typename">string</span></div><div class="line">z , err = Baz ()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">...</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="捕获命名的返回值">捕获命名的返回值</h3>
<p>下面这个例子定义了一个命名的返回值<code>result</code>。可以看到 <code>... = result</code>（读操作）和<code>return 20</code> (写操作)有数据竞争的问题，虽然<code>return 20</code>你并没有看到对result的赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> NamedReturnCallee () ( result <span class="typename">int</span>) {</div><div class="line">  result =<span class="number"> 10</span></div><div class="line">  <span class="keyword">if</span> ... {</div><div class="line">    <span class="keyword">return</span> <span class="comment">// this has the effect of " return 10"</span></div><div class="line">  }</div><div class="line">  <span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">   ... = result <span class="comment">// read result</span></div><div class="line">  }()</div><div class="line">  <span class="keyword">return</span><span class="number"> 20</span> <span class="comment">// this is equivalent to result =20</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Caller () {</div><div class="line"> retVal := NamedReturnCallee ()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>defer</code>也会有类似的效果,下面这段代码对err有数据竞争问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">func</span> Redeem ( request Entity ) ( resp Response , err error )</div><div class="line">{</div><div class="line"> <span class="keyword">defer</span> <span class="keyword">func</span> () {</div><div class="line">  resp , err = c . Foo ( request , err )</div><div class="line"> }()</div><div class="line"> err = CheckRequest ( request )</div><div class="line"> ... <span class="comment">// err check but no return</span></div><div class="line"> <span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">  ProcessRequest ( request , err != <span class="constant">nil</span> )</div><div class="line"> }()</div><div class="line"> <span class="keyword">return</span> <span class="comment">// the defer function runs after here</span></div><div class="line"> }</div></pre></td></tr></table></figure>

<h2 id="Slice相关的数据竞争">Slice相关的数据竞争</h2>
<p>下面这个例子，<code>safeAppend</code>使用锁对<code>myResults</code>进行了保护，但是在每次循环调用<code>(uuid, myResults)</code>并没有读保护，也会有竞争问题，而且不容易发现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ProcessAll ( uuids [] <span class="typename">string</span> ) {</div><div class="line"> <span class="keyword">var</span> myResults [] <span class="typename">string</span></div><div class="line"> <span class="keyword">var</span> mutex sync . Mutex</div><div class="line"> safeAppend := <span class="keyword">func</span> ( res <span class="typename">string</span> ) {</div><div class="line"> mutex.Lock ()</div><div class="line">  myResults = <span class="built_in">append</span> ( myResults , res )</div><div class="line"> mutex.Unlock ()</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">for</span> _ , uuid := <span class="keyword">range</span> uuids {</div><div class="line"> <span class="keyword">go</span> <span class="keyword">func</span> ( id <span class="typename">string</span> , results [] <span class="typename">string</span> ) {</div><div class="line"> res := Foo ( id )</div><div class="line"> safeAppend ( res )</div><div class="line">  }( uuid , myResults ) <span class="comment">// slice read without holding lock</span></div><div class="line"> }</div><div class="line"> ...</div><div class="line"> }</div></pre></td></tr></table></figure>

<h2 id="非线程安全的map">非线程安全的map</h2>
<p>这个很常见了，几乎每个Gopher都曾犯过，犯过才意识到Go内建的map对象并不是线程安全的，需要加锁或者使用sync.Map等其它并发原语。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> processOrders ( uuids [] <span class="typename">string</span> ) error {</div><div class="line"><span class="keyword">var</span> errMap = <span class="built_in">make</span> ( <span class="keyword">map</span> [ <span class="typename">string</span> ] error )</div><div class="line"><span class="keyword">for</span> _ , uuid := <span class="keyword">range</span> uuids {</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span> ( uuid <span class="typename">string</span> ) {</div><div class="line">orderHandle , err := GetOrder ( uuid )</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">▶ errMap [ uuid ] = err</div><div class="line"><span class="keyword">return</span></div><div class="line">}</div><div class="line">...</div><div class="line">}( uuid )</div><div class="line"><span class="keyword">return</span> combineErrors ( errMap )</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="传值和传引用的误用">传值和传引用的误用</h2>
<p>Go标准库常见并发原语不允许在使用后Copy, go vet也能检查出来。比如下面的代码，两个goroutine想共享mutex,需要传递<code>&amp;mutex</code>,而不是<code>mutex</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="typename">int</span></div><div class="line"><span class="comment">// CriticalSection receives a copy of mutex .</span></div><div class="line"><span class="keyword">func</span> CriticalSection ( m sync . Mutex ) {</div><div class="line">m.Lock ()</div><div class="line"> a ++</div><div class="line">m.Unlock ()</div><div class="line">}</div><div class="line"><span class="keyword">func</span> main () {</div><div class="line">mutex := sync . Mutex {}</div><div class="line"><span class="comment">// passes a copy of m to A .</span></div><div class="line"><span class="keyword">go</span> CriticalSection ( mutex )</div><div class="line"><span class="keyword">go</span> CriticalSection ( mutex )</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="混用消息传递和共享内存两种并发方式">混用消息传递和共享内存两种并发方式</h2>
<p>消息传递常用channel。下面的例子中，如果context因为超时或者主动cancel被取消的话，Start中的goroutine中的<code>f.ch &lt;- 1</code>可能会被永远阻塞，导致goroutine泄露。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ( f * Future ) Start () {</div><div class="line"><span class="keyword">go</span> <span class="keyword">func</span> () {</div><div class="line">resp , err := f.f () <span class="comment">// invoke a registered function</span></div><div class="line"> f.response = resp</div><div class="line"> f.err = err</div><div class="line"> f.ch &lt;-<span class="number"> 1</span> <span class="comment">// may block forever !</span></div><div class="line">}()</div><div class="line">}</div><div class="line"><span class="keyword">func</span> ( f * Future ) Wait ( ctx context . Context ) error {</div><div class="line"><span class="keyword">select</span> {</div><div class="line"><span class="keyword">case</span> &lt;-f.ch :</div><div class="line"><span class="keyword">return</span> <span class="constant">nil</span></div><div class="line"><span class="keyword">case</span> &lt;- ctx.Done () :</div><div class="line"> f.err = ErrCancelled</div><div class="line"><span class="keyword">return</span> ErrCancelled</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="并发测试">并发测试</h2>
<p>Go的<code>testing.T.Parallel()</code>为单元测试提供了并发能力，或者开发者自己写一些并发的测试程序测试代码逻辑，在这些并发测试中，也是有可能导致数据竞争的。不要以为测试不会有数据竞争问题。</p>
<h2 id="不正确的锁调用">不正确的锁调用</h2>
<h3 id="为写操作申请读锁">为写操作申请读锁</h3>
<p>下面这个例子中，<code>g.ready</code>是写操作，可是这个函数调用的是读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ( g * HealthGate ) updateGate () {</div><div class="line">g.mutex.RLock ()</div><div class="line"><span class="keyword">defer</span> g.mutex.RUnlock ()</div><div class="line"><span class="comment">// ... several read - only operations ...</span></div><div class="line"><span class="keyword">if</span> ... {</div><div class="line"> g.ready = <span class="constant">true</span> <span class="comment">// Concurrent writes .</span></div><div class="line"> g.gate.Accept () <span class="comment">// More than one Accept () .</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="其它锁的问题">其它锁的问题</h3>
<p>你会发现，大家经常犯的一个“弱智”的问题，就是Mutex只有Lock或者只有Unlock,或者两个Lock,这类问题本来你认为绝不会出现的，在现实中却经常能看到。</p>
<p>还有使用<code>atomic</code>进行原子写，但是却没有原子读。</p>
<blockquote>
<p>我认为这里Uber工程师并没有全面详细的介绍使用锁常见的一些陷阱，推荐你学习极客时间中的<a href="https://time.geekbang.org/column/intro/355" target="_blank" rel="external">Go 并发编程实战课</a>课程，此课程详细介绍了每个并发原语的陷阱和死锁情况。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>总结一下，下表列出了基于语言类型统计的数据竞争bug数：</p>
<p><img src="2.png" alt=""></p>
<p>整体来看，锁的误用是最大的数据竞争的原因。并发访问slice和map也是很常见的数据竞争的原因。<br><img src="3.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天Uber工程师放出一篇论文(<a href="https://arxiv.org/abs/2204.00764" target="_blank" rel="external">A Study of Real-World Data Races in Golang</a>)，作者是Uber的工程师Milind Chabbi和Murali Krishna Ramanathan，他们负责使用Go内建的data race detector在Uber内的落地，经过6个多月的研究分析，他们将data race detector成功落地，并基于对多个项目的分析，得出了一些有趣的结论。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最常用的架构模式]]></title>
    <link href="https://colobu.com/2022/03/06/most-useful-software-architecture-patterns/"/>
    <id>https://colobu.com/2022/03/06/most-useful-software-architecture-patterns/</id>
    <published>2022-03-06T08:48:44.000Z</published>
    <updated>2022-03-06T09:46:52.573Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>观其设计知其人</p>
<p>A MAN is KNOWN by the DESIGN he keeps</p>
</blockquote>
<p>原文:<a href="https://shadman-jamil.medium.com/most-useful-software-architecture-patterns-68e171405292" target="_blank" rel="external">Most Useful Software Architecture Patterns</a> by Shadman Jamil</p>
<a id="more"></a>
<p><img src="Software-Architecture.png" alt=""></p>
<h2 id="分层模式_(Layered_Pattern_(n-tier))">分层模式 (Layered Pattern (n-tier))</h2>
<p>分层架构模式是最常见的模式之一。分层模式背后的理念是，具有相同功能的组件将被组织成水平层。因此，每一层在应用程序中都扮演着特定的角色。</p>
<p>在这种模式中，我们对应用程序可以拥有的层数没有限制。在这方面，我们还提倡关注点分离的概念。分层模式风格抽象了整个软件的视图；同时提供足够的细节，以了解各个层的角色和职责以及它们之间的关系。分层模式的典型实现如下：</p>
<ul>
<li>UI展示层(<strong>UI / Presentation Layer</strong>): 渲染并运行用户界面，向服务器应用程序发送请求。</li>
<li>应用层(<strong>Application Layer</strong>): 包含表示层、应用程序层、域对象层和持久化层。</li>
<li>域对象层/业务层(<strong>Domain / Business Layer</strong>): 该层包含所有业务逻辑、实体、事件和其他包含业务逻辑的对象类型。</li>
<li>数据库层(<strong>Database Layer</strong>): 这是数据层，用于持久化数据，应用服务器将使用这些数据。</li>
</ul>
<p><img src="layers.png" alt=""></p>
<p><strong>例子</strong>: 桌面应用程序、电子商务、web应用程序等。</p>
<blockquote>
<p>参考例子： <a href="https://github.com/bxcodec/go-clean-arch" target="_blank" rel="external">go-clean-arch</a></p>
</blockquote>
<h2 id="客户端-服务器模式_(Client-Server_Pattern)">客户端-服务器模式 (Client-Server Pattern)</h2>
<p>这是最简单的架构模式，由一台服务器和多个客户端组成。这种模式是一种分布式架构，在资源/服务的提供者（称为服务器）和服务请求者（称为客户端）之间划分任务/工作负载。</p>
<p>在客户端-服务器模式中，当客户端向服务器发送数据请求时，服务器接受请求的进程，并向客户机发送所需的数据。客户不共享他们的任何资源。</p>
<p><img src="client-server.png" alt=""></p>
<p><strong>例子</strong>: Email、文档共享、银行等</p>
<h2 id="事件总线模式_(Event-Bus_Pattern_(Event-Driven_Architecture))">事件总线模式 (Event-Bus Pattern (Event-Driven Architecture))</h2>
<p>该模式是一种分布式异步体系架构模式，用于创建高度可扩展的响应式应用程序。适用于从小型到复杂的各级应用程序技术栈。此模式的主要思想是异步传递和处理事件。</p>
<p>这个模式包含四个组件:</p>
<ol>
<li>事件源(Event Source)</li>
<li>事件监听器(Event Listener)</li>
<li>通道(Channel)</li>
<li>事件总线(Event Bus)</li>
</ol>
<p>源将消息发布到事件总线上的特定通道。监听器订阅特定的频道，监听器可以获取发布到其订阅的频道的消息。</p>
<p><img src="event-source.png" alt=""></p>
<p><strong>例子</strong>: 电子商务、手机应用程序、通知服务等</p>
<h2 id="代理人模式(Broker_Pattern)">代理人模式(Broker Pattern)</h2>
<p>此模式可用于构造具有通过远程服务调用进行交互的解耦组件的分布式系统。代理组件负责协调组件之间的通信；例如转发请求，以及传输结果和异常。</p>
<p><strong>服务器</strong>将其能力（服务和特性）发布给<strong>代理</strong>(Broker)。<strong>客户端</strong>向<strong>代理</strong>请求服务，然后<strong>代理</strong>将<strong>客户端</strong>的请求重定向到合适的服务。</p>
<p><img src="broker.png" alt=""></p>
<p><strong>例子</strong>: 消息Broker程序，如Apache ActiveMQ、Apache Kafka、RabbitMQ、JBOSS Messaging等</p>
<h2 id="微服务模式_(Microservices_Pattern)">微服务模式 (Microservices Pattern)</h2>
<p>在这种模式中，服务通过使用HTTP/REST等同步协议或AMQP（高级消息队列协议）等异步协议进行通信。服务可以独立开发和部署，每个服务都有自己的数据库。服务之间的数据一致性是通过使用Saga模式（一系列本地事务）来维护的。</p>
<p><img src="microservices.png" alt=""></p>
<p><strong>例子</strong>: 可以在许多用例上实现，尤其是广泛的数据管道处理上</p>
<h2 id="点对点模式_(Peer-to-Peer_Pattern)">点对点模式 (Peer-to-Peer Pattern)</h2>
<p>在通用客户端-服务器体系架构中，多个客户端与中央服务器通信。但P2P模式由分散的对等网络组成。</p>
<p>在这种模式中，节点的行为类似于客户端和服务器。对等点既可以作为客户端向其他对等点请求服务，也可以作为服务器向其他对等点提供服务。</p>
<p>P2P网络在节点之间分配工作负载，所有节点贡献并消耗网络中的资源，而不需要集中的服务器。对等方可能会随着时间动态地改变其角色。</p>
<p><img src="peer-2-peer.png" alt=""></p>
<p><strong>例子</strong>: 文件分享网络、多媒体协议PDTP,P2PTV、比特币、区块链等</p>
<h2 id="黑板模式(Blackboard_Pattern)">黑板模式(Blackboard Pattern)</h2>
<p>这种模式对于不知道确定性解决方案策略的问题很有用。</p>
<p>所有部件都可以接触到黑板。组件可能会产生新的数据对象，这些对象将被添加到黑板上。组件在黑板上寻找特定类型的数据，并通过与现有知识源的模式匹配找到这些数据。</p>
<p>这个模式包含三个组件：</p>
<ul>
<li>黑板(blackboard): 含解决方案空间中的对象的结构化全局内存</li>
<li>知识源(knowledge source:):具有自己表示形式的专用模块</li>
<li>控制组件(control component):选择、配置和执行模块。</li>
</ul>
<p><img src="blackboard.png" alt=""></p>
<p><strong>例子</strong>: 速度识别、蛋白质结构识别、声纳信号解释、机器学习程序等。</p>
<h2 id="组件模式_(Component-based_Pattern)">组件模式 (Component-based Pattern)</h2>
<p>基于组件的软件工程（Component-based software engineering，简称CBSE）或基于组件的开发（Component-Based Development，简称CBD）是针对系统的广泛功能，进行关注点分离的软件工程方式。此方式是以复用为基础的作法，定义、实现许多松耦合的独立组件（Component），再将组件组合成为系统。此作法的目的是希望在软件本身的短期益处以及开发软件组织的长期益处之间获取平衡。</p>
<p>一旦组件进行了划分，可以将组件分布式的开发部署，就会演化成面向服务或者微服务的架构。</p>
<p><img src="component-based.png" alt=""></p>
<p><strong>例子</strong>: 常见大型项目中或者单个服务中。</p>
<h2 id="管道模式_(Pipes_和_filters)">管道模式 (Pipes 和 filters)</h2>
<p>管道(pipeline)由一系列处理元素（进程、线程、协同程序、函数等）组成，每个元素的输出都是下一个元素的输入；这个名字类似于一个物理管道。通常在连续元素之间提供一定量的缓冲。在这些管道中流动的信息通常是记录流、字节流或比特流，管道中的元素可以称为过滤器(filter)；这也称为管道和过滤器设计模式。将元素连接到管道中类似于函数合成。</p>
<p>管道模式可以将数据的处理解耦，并且可以动态的增加或者删除特定的处理流程。每个处理单元可以结合下面插件模式，实现定制化。</p>
<p><img src="pipeline.png" alt=""></p>
<p><strong>例子</strong>: 多任务操作系统、数据处理程序等。</p>
<h2 id="插件模式">插件模式</h2>
<p>在计算技术中，插件（或插件、外接程序、外接程序、外接程序或外接程序）是一种软件组件，用于向现有计算机程序添加特定功能。当程序支持插件时，它会启用自定义功能。</p>
<p>插件模式可以方便对程序进行扩展，以及动态实现功能的开启和禁用等功能，方便进行定制化。</p>
<p><img src="plugin.png" alt=""></p>
<p><strong>例子</strong>: IDE程序如Eclipse，IDEA Intellj、网络应用程序入netty等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>观其设计知其人</p>
<p>A MAN is KNOWN by the DESIGN he keeps</p>
</blockquote>
<p>原文:<a href="https://shadman-jamil.medium.com/most-useful-software-architecture-patterns-68e171405292" target="_blank" rel="external">Most Useful Software Architecture Patterns</a> by Shadman Jamil</p>
]]>
    
    </summary>
    
      <category term="架构" scheme="https://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题: 大型理发店]]></title>
    <link href="https://colobu.com/2022/03/06/hilzers-barbershop-problem/"/>
    <id>https://colobu.com/2022/03/06/hilzers-barbershop-problem/</id>
    <published>2022-03-06T06:04:11.000Z</published>
    <updated>2022-03-06T08:19:05.176Z</updated>
    <content type="html"><![CDATA[<p>二月二理发店太火了，家家都爆满，这次我们来到Hilzer的理发店，这是一家比较大的理发店。</p>
<a id="more"></a>
<p>这家理发店有三位有经验的理发师，每个理发师都有自己独立的理发椅。等待区有一个四座的沙发，等待区还有站一些人等待。还有一个收银台。</p>
<ul>
<li>依照新冠疫情防控的要求，最多允许20个顾客进入。</li>
<li>如果有顾客，理发师优先从沙发上叫起等待最久的顾客开始理发；如果没有顾客，理发师则在自己的理发椅上睡觉</li>
<li>顾客来到后<ul>
<li>如果已经有20个顾客，则此顾客离开去其它理发店</li>
<li>如果理发师在睡觉，则叫起一位理发师开始理发</li>
<li>如果没有空闲的理发师，则选择沙发坐下</li>
<li>如果沙发已经坐满，则在休息去站着等待</li>
</ul>
</li>
<li>理完发后顾客去收银台去缴费，交完费后理发师把发票交给顾客。顾客就离开，而理发师则准备服务下一位顾客</li>
</ul>
<p>这一次理发店的问题比上一个<a href="https://colobu.com/2022/02/27/barbershop-problem/" target="_blank" rel="external">理发店问题</a>要复杂很多:</p>
<ul>
<li>等待区分为了站立区和沙发区</li>
<li>新增加了收银台，理发师和顾客需要付款和发票的相互等待</li>
<li>三位理发师</li>
</ul>
<p>这类问题使用信号量并发原语比较好，因为理发师、沙发等都是一定数量的资源。理发师和顾客之间缴费和发票之间的同步按理说使用channel比较合适，但是收银台只有一位收银员，还需要处理理发师、顾客和收银员之间的并发，所以我们可以把收银、开发票看成计数器是1的资源。</p>
<p>首先我们还是定义信号量和辅助方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Semaphore定义</span></div><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">	time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来我们定义所需的并发原语。</p>
<p>我们使用<code>customerMutex</code>这个排他锁来控制理发店的顾客数量。<br>使用<code>sofaSema</code>控制站立用户坐到沙发上以及理发师叫起等待的顾客。</p>
<p><code>paySema</code>用来让顾客去缴费，而<code>receiptSema</code>让理发师把发票送给顾客，顾客离开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 控制顾客的总数</span></div><div class="line">	customerMutex    sync.Mutex</div><div class="line">	customerMaxCount =<span class="number"> 20</span></div><div class="line">	customerCount    =<span class="number"> 0</span></div><div class="line"></div><div class="line">	<span class="comment">// 沙发的容量</span></div><div class="line">	sofaSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 4</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 三位理发师</span></div><div class="line">	barberSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 3</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 收银台</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 同时只有一对理发师和顾客结账</span></div><div class="line">	paySema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)</div><div class="line">	<span class="comment">// 顾客拿到发票才会离开，控制开票</span></div><div class="line">	receiptSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>接下来我们实现理发师的逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理发师工作</span></div><div class="line"><span class="keyword">func</span> barber(name <span class="typename">string</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(name + <span class="string">"老师尝试请求一个顾客"</span>)</div><div class="line">		sofaSema.Release() <span class="comment">// 等待沙发上等待最久的一位顾客</span></div><div class="line">		log.Println(name + <span class="string">"老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line"></div><div class="line">		log.Println(name + <span class="string">"老师理完发，等待顾客付款"</span>)</div><div class="line">		paySema.Acquire() <span class="comment">// 等待用户缴费</span></div><div class="line">		log.Println(name + <span class="string">"老师给付完款的顾客发票"</span>)</div><div class="line">		receiptSema.Release() <span class="comment">// 通知顾客发票开好</span></div><div class="line">		log.Println(name + <span class="string">"老师服务完一位顾客"</span>)</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来实现顾客的逻辑, 注意<code>customerCount</code>操作需要使用Mutex保护:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(500</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	customerMutex.Lock()</div><div class="line">	<span class="keyword">if</span> customerCount == customerMaxCount {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">		customerMutex.Unlock()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	customerCount++</div><div class="line">	customerMutex.Unlock()</div><div class="line"></div><div class="line">	log.Println(<span class="string">"一位顾客开始等沙发坐下"</span>)</div><div class="line">	sofaSema.Acquire()</div><div class="line">	log.Println(<span class="string">"一位顾客找到空闲沙发坐下,直到被理发师叫起理发"</span>)</div><div class="line"></div><div class="line">	paySema.Release()</div><div class="line">	log.Println(<span class="string">"一位顾客已付完钱"</span>)</div><div class="line">	receiptSema.Acquire()</div><div class="line">	log.Println(<span class="string">"一位顾客拿到发票，离开"</span>)</div><div class="line"></div><div class="line">	customerMutex.Lock()</div><div class="line">	customerCount--</div><div class="line">	customerMutex.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后把所有的逻辑串起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 托尼、凯文、艾伦理发师三巨头</span></div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Tony"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Kevin"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Allen"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> customers()</div><div class="line"></div><div class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">	&lt;-sigs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序观察并发的执行。</p>
<p>通过这个问题，我们可以好好的练习Semaphore的使用，以及两个goroutine之间信号的传递，控制并发程序的协作执行。</p>
<p>下一章你想了解什么样的经典并发问题呢？</p>
<h2 id="历史并发问题">历史并发问题</h2>
<ul>
<li><a href="https://colobu.com/2022/02/13/dining-philosophers-problem/" target="_blank" rel="external">哲学家就餐问题</a></li>
<li><a href="https://colobu.com/2019/07/23/concurrent-problem-h2o-factory/" target="_blank" rel="external">制造一氧化二氢</a></li>
<li><a href="https://colobu.com/2022/02/27/barbershop-problem/" target="_blank" rel="external">理发店的故事</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>二月二理发店太火了，家家都爆满，这次我们来到Hilzer的理发店，这是一家比较大的理发店。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题： 理发店的故事]]></title>
    <link href="https://colobu.com/2022/02/27/barbershop-problem/"/>
    <id>https://colobu.com/2022/02/27/barbershop-problem/</id>
    <published>2022-02-27T08:40:51.000Z</published>
    <updated>2022-02-27T10:12:01.956Z</updated>
    <content type="html"><![CDATA[<p>马上就二月二了，理发店就要忙活起来了，托尼、凯文、艾伦等老师的理发剪磨刀霍霍，把椅子擦亮，准备各位顾客的到来。</p>
<p><a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" target="_blank" rel="external">Sleeping barber problem</a>是一个经典的goroutine交互和并发控制的问题，可以很好的用来演示多写多读的并发问题(multiple writers multiple readers)。</p>
<a id="more"></a>
<p>理发店问题最早是由计算机科学先驱 Edsger Dijkstra 在1965指出的，在 Silberschatz 和 Galvin 的 Operating Systems Concepts一书中有此问题的变种。</p>
<p>这个问题是这样子的。<br>有这么一个理发店，有一位理发师和几个让顾客等待的座位：</p>
<ul>
<li>如果没有顾客，这位理发师就躺在理发椅上睡觉</li>
<li>顾客必须唤醒理发师让他开始理发</li>
<li>如果一位顾客到来，理发师正在理发<ul>
<li>如果还有顾客用来等待的座位，则此顾客坐下</li>
<li>如果座位都满了，则此顾客离开</li>
</ul>
</li>
<li>理发师理完头发后，需要检查是否还有等待的顾客<ul>
<li>如果有，则请一位顾客起来开始理发</li>
<li>如果没有，理发师则去睡觉</li>
</ul>
</li>
</ul>
<p>虽然条件很多，我们可以把它想象成为一个并发的queue。在当前的问题下，有多个并发写(multiple writer, 顾客)，一个并发读(single reader),对吧。</p>
<h2 id="使用sync-Cond实现">使用sync.Cond实现</h2>
<p>一般，先前，我们处理并发队列通过使用<a href="https://pkg.go.dev/sync#Cond" target="_blank" rel="external">sync.Cond</a>这个并发原语(在java语言中，我们一般使用wait/notify)。</p>
<p>就<code>sync.Cond</code>这个并发原语而言，它并不是一个很容易使用的对象。因为它还需要一个一个<code>sync.Locker</code>配合使用，并且相关的方法要么必须使用Locker、要么可以省略Locker，容易让人迷惑，等待的goroutine被唤醒时还需要检查判断条件，所以用起来总是需要小心翼翼地。</p>
<p>首先，我们定义一个Locker和一个Cond,并且定义顾客等待的座位数。<br>来了一位顾客，座位数加一，Tony老师叫起一位等待的顾客开始理发时，座位数减一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	seatsLock sync.Mutex</div><div class="line">	seats     <span class="typename">int</span></div><div class="line">	cond = sync.NewCond(&seatsLock)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>理发师的工作就是不断的检查是否有顾客等待，如果有，就交起一位顾客开始理发，理发耗时是随机的，理完再去叫下一位顾客。如果没有顾客，那么理发师就会被阻塞(开始睡觉)。<br>逐一这里Cond的使用方法，Wait之后需要for循环检查条件是否满足，并且Wait上下会有Locker的使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(<span class="string">"Tony老师尝试请求一个顾客"</span>)</div><div class="line">		seatsLock.Lock()</div><div class="line">		<span class="keyword">for</span> seats ==<span class="number"> 0</span> {</div><div class="line">			cond.Wait()</div><div class="line">		}</div><div class="line">		seats--</div><div class="line">		seatsLock.Unlock()</div><div class="line">		log.Println(<span class="string">"Tony老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>customers</code>模拟陆陆续续的顾客的到来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾客到来之后，先请求seatsLock， 避免多个顾客同时进来的并发竞争。然后他会检查是否有空闲的座位，如果有则坐下并通知理发师。此时理发师如果睡眠则会被唤醒，如果正在理发会忽略。<br>如果没有空闲的座位则离开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	seatsLock.Lock()</div><div class="line">	<span class="keyword">defer</span> seatsLock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> seats ==<span class="number"> 3</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	seats++</div><div class="line">	cond.Broadcast()</div><div class="line"></div><div class="line">	log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里简单的是由整数seats代表空闲的座位，实际处理这样的场景的时候，你可能会使用一个slice作为队列。</p>
<p>本身这个实现还是很简单的，但是Cond+Locker的使用方式还是感觉让人有那么一点不放心，事实上，很多这样的场景，我们可以使用channel来实现。</p>
<h2 id="使用Channel实现Semaphore">使用Channel实现Semaphore</h2>
<p>我们可以使用Channel实现一个Semaphore来解决理发店问题。Semaphore实现如下,和我们水分子生成的问题中的实现是类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) TryAcquire() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> s &lt;- <span class="keyword">struct</span>{}{}: <span class="comment">// 还有空位子</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>: <span class="comment">// 没有空位子了,离开</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了这个并发原语，我们就容易解决理发店问题了。注意这里我们实现了<code>TryAcquire</code>,就是为了顾客到来的是否检查有没有空闲的座位。<br>这里为什么不使用Go官方扩展的<code>semaphore.Weighted</code>并发原语呢，是因为<code>semaphore.Weighted</code>有个问题，在<code>Accquire</code>之前调用<code>Release</code>方法的话会panic，所以我们自己实现了一个。</p>
<p>我们定义了有三个等待座位的信号量。Tony老师先调用<code>Release</code>方法，也就是想从座位上请一位顾客过来理发，以便空出一个等待座位。如果没有顾客，Tony就会无奈的等待和睡觉了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seats = <span class="built_in">make</span>(Semaphore,<span class="number"> 3</span>)</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">    		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(<span class="string">"Tony老师尝试请求一个顾客"</span>)</div><div class="line">		seats.Release()</div><div class="line">		log.Println(<span class="string">"Tony老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾客的检查也更简单:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	<span class="keyword">if</span> ok := seats.TryAcquire(); ok {</div><div class="line">		log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，如果我们使用自定义的Semaphore话，代码会变得更加的简单。</p>
<p>那么这种channel实现的Semaphore有什么缺陷吗？那就是如果队列的长度太大的话，channel的容量就会很大。不过如果类型设置为strcut{}类型的话，就会节省很多的内存，所以一般也不会有什么问题，虽然比官方扩展的计数器方式的<code>semaphore.Weighted</code>多占用一些空间，但是占用的空间还是有限的。</p>
<p>更进一步，尽然我们要实现一个队列，其实可以通过这个channel来实现，把顾客类型替换struct{}类型，这样就没有额外多余的占用了。</p>
<h2 id="多理发师的情况">多理发师的情况</h2>
<p>更进一步，我们考虑多个理发师的情况。</p>
<p>多个理发师的问题其实就演变成了多写(multiple writer)多读(multiple reader)的场景了。</p>
<p>托尼、凯文和艾伦是理发界的三大巨头，我们演示三位理发师并发理发的场景，同时理发店的规模也扩大了，有10个可以等待的座位。</p>
<p>基于channel实现的Semaphore的解决方案，多个理发师的场景和单个理发师的场景是一样的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) TryAcquire() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> s &lt;- <span class="keyword">struct</span>{}{}: <span class="comment">// 还有空位子</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>: <span class="comment">// 没有空位子了,离开</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> seats = <span class="built_in">make</span>(Semaphore,<span class="number"> 10</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 托尼、凯文、艾伦理发师三巨头</span></div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Tony"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Kevin"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Allen"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> customers()</div><div class="line"></div><div class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">	&lt;-sigs</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">	time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber(name <span class="typename">string</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(name + <span class="string">"老师尝试请求一个顾客"</span>)</div><div class="line">		seats.Release()</div><div class="line">		log.Println(name + <span class="string">"老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	<span class="keyword">if</span> ok := seats.TryAcquire(); ok {</div><div class="line">		log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>全部经典并发问题的代码可以参考<a href="https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems" target="_blank" rel="external">smallnest/dive-to-gosync-workshop</a>。下一次我们再分析一个更加复杂的理发店问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>马上就二月二了，理发店就要忙活起来了，托尼、凯文、艾伦等老师的理发剪磨刀霍霍，把椅子擦亮，准备各位顾客的到来。</p>
<p><a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" target="_blank" rel="external">Sleeping barber problem</a>是一个经典的goroutine交互和并发控制的问题，可以很好的用来演示多写多读的并发问题(multiple writers multiple readers)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题: 哲学家就餐问题]]></title>
    <link href="https://colobu.com/2022/02/13/dining-philosophers-problem/"/>
    <id>https://colobu.com/2022/02/13/dining-philosophers-problem/</id>
    <published>2022-02-13T09:25:44.000Z</published>
    <updated>2022-02-24T09:36:34.503Z</updated>
    <content type="html"><![CDATA[<p>哲学家就餐问题是一个非常非常经典的问题，也是一个非常通用的研究并发编程中死锁现象的问题。</p>
<a id="more"></a>
<blockquote>
<p>为什么我们要研究经典的并发问题呢？这些经典问题是对现实中的计算机编程的抽象，代表了非常通用的计算机并发问题，计算机科学家对此进行了深入的研究，也总结出很多行之有效的解决办法。我们通过学习这些经典问题，可以将我们遇到的并发问题做对比，看不看是否是类似的问题，如何是相同的问题，可以使用前人总结的解决方案去解决。同时练习解决这些问题，也可以使我们学习和掌握并发原语和解决问题的技巧，举一反三去解决更多的并发问题。</p>
</blockquote>
<p>在1971年，著名的计算机科学家艾兹格·迪科斯彻(Edsger Dijkstra)提出了一个同步问题，即假设有五台计算机都试图访问五份共享的磁带驱动器。稍后，这个问题被托尼·霍尔(Tony Hoare)重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。</p>
<p>到了中国，哲学家就餐问题可以这样表述，假设因为新冠的原因，五位哲学家被隔离在一个房间里。这五位哲学家分别是孔子、庄子、墨子、孙子和老子，他们围坐在一个圆形的餐桌旁，餐桌上有无尽的可口的饭菜，不幸的是，出于环保的原因，只有五根筷子，每根筷子都位于两位哲学家之间。哲学家吃饭时，必须拿起自己左右两边的两根筷子才能吃饭，吃完饭后才放回筷子，这样其它哲学家可以再拿起筷子。</p>
<p>虽然隔离的日子比较寂寞，但是这些哲学家还是有事情可做，他们不断的冥想或者吃饭。饿了的时候就开始尝试拿起筷子，吃随机时间的饭菜，然后放下筷子开始冥想。冥想一段时间就饿了，又开始吃饭。所以他们总是处于冥想-饿了-吃饭-冥想这样的状态中。</p>
<p><img src="1.png" alt=""></p>
<p>这个哲学家很好的模拟了计算机并发编程中一定数量的资源和一定数量的持有者的并发问题，这类问题很大的一个问题就是死锁问题。</p>
<p>如果五位哲学家同时饿了，同时拿起左手边的那根筷子，你就会发现他们想去拿右边的筷子的时候，都没有办法拿起右边的筷子，因为右边那根筷子都被旁边的哲学家拿走了，所有的哲学家都处于等待状态而没有办法继续下去。对于程序来说，就是程序 hang死了，没有办法继续处理。</p>
<blockquote>
<p>如果这五位哲学家同时发现没有右边的筷子可用，他们同时放下左手的筷子，冥想5分钟再同时就餐，你会发现程序貌似还在进行，但是哲学家依然还是没有办法就餐，这种现象叫做死锁。在分布式一致性算法中在选主的时候也会有类似的现象，有些实现是通过随机休眠一定的时间，避免各个节点同时请求选主来避免。</p>
</blockquote>
<p>如果系统中只有一个线程，当然不会产生死锁。如果每个线程仅需求一种并发资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。如果你搜索Go官方的项目中的issue,可以看到几百个关于死锁的issue,足可以表明死锁是一个常见且并不容易处理的bug。</p>
<p><img src="2.png" alt=""></p>
<p>死锁的四个条件是：</p>
<ul>
<li><p><strong>禁止抢占</strong>（no preemption）：系统资源不能被强制从一个线程中退出。如果哲学家可以抢夺，那么大家都去抢别人的筷子，也会打破死锁的局面，但这是有风险的，因为可能孔子还没吃饭就被老子抢走了。计算机资源如果不是主动释放而是被抢夺有可能出现意想不到的现象。</p>
</li>
<li><p><strong>持有和等待</strong>（hold and wait）：一个线程在等待时持有并发资源。持有并发资源并还等待其它资源，也就是吃着碗里的望着锅里的。</p>
</li>
<li><p><strong>互斥</strong>（mutual exclusion）：资源只能同时分配给一个线程，无法多个线程共享。资源具有排他性，孔子和老子的关系再好，也不允许他们俩一起拿着一根筷同时吃。</p>
</li>
<li><p><strong>循环等待</strong>（circular waiting）：一系列线程互相持有其他进程所需要的资源。必须有一个循环依赖的关系。</p>
</li>
</ul>
<p>死锁只有在四个条件同时满足时发生，预防死锁必须至少破坏其中一项。</p>
<h2 id="模拟哲学家就餐问题">模拟哲学家就餐问题</h2>
<p>首先我们通过程序模拟哲学家就餐问题，看看程序在运行的是不是会产生死锁问题。</p>
<p>首先我们定义筷子对象和哲学家对象。其中筷子是并发资源，具有排他性，所以它包含一个锁，用来实现互斥，并且禁止抢占(其它非持有这根筷子的哲学家不能调用Unlock,只有持有这根筷子的哲学家才能调用Unlock)。</p>
<p>每个哲学家需要左手的筷子和右手的筷子，status代表哲学家的状态(冥想、饿了、就餐中)，他有一种状态就是持有一根筷子并请求另一根筷子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Chopstick 代表筷子.</span></div><div class="line"><span class="keyword">type</span> Chopstick <span class="keyword">struct</span>{ sync.Mutex }</div><div class="line"></div><div class="line"><span class="comment">// Philosopher 代表哲学家.</span></div><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>哲学家在隔离的房间就是不断的冥想、就餐、冥想、就餐...... 永无终日。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 随机暂停一段时</span></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">    time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 显示此哲学家的状态</span></div><div class="line"><span class="keyword">func</span> mark(p *Philosopher, action <span class="typename">string</span>) {</div><div class="line">    fmt.Printf(<span class="string">"%s开始%s\n"</span>, p.name, action)</div><div class="line">    p.status = fmt.Sprintf(<span class="string">"%s开始%s\n"</span>, p.name, action)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的mark用来在控制台输出此哲学家的状态，便于我们观察。</p>
<p>最后一步就是实现main函数，分配5根筷子和五个哲学家，让程序运行起来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">go</span> http.ListenAndServe(<span class="string">"localhost:8972"</span>, <span class="constant">nil</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 哲学家数量</span></div><div class="line">    count :=<span class="number"> 5</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建5根筷子</span></div><div class="line">    chopsticks := <span class="built_in">make</span>([]*Chopstick, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        chopsticks[i] = <span class="built_in">new</span>(Chopstick)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    names := []<span class="typename">string</span>{color.RedString(<span class="string">"孔子"</span>), color.MagentaString(<span class="string">"庄子"</span>), color.CyanString(<span class="string">"墨子"</span>), color.GreenString(<span class="string">"孙子"</span>), color.WhiteString(<span class="string">"老子"</span>)}</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">    &lt;-sigs</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"退出中... 每个哲学家的状态:"</span>)</div><div class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> philosophers {</div><div class="line">        fmt.Print(p.status)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序你会很快就发现这个程序会hang住，每个哲学家都处于拿到左手筷子等待右手筷子的状态。</p>
<p>在我们实际的应用中，死锁问题并不是这么容易的被发现的，很可能在一些非常特定的场景(也被称之为corner case)才会被触发和发现。</p>
<h2 id="解法一：限制就餐人数">解法一：限制就餐人数</h2>
<p>我们知道，解决死锁的问题就是破坏死锁形成的四个条件之一就可以。一般来说，禁止抢占和互斥是我们必须的条件，所以其它两个条件是我们重点突破的点。</p>
<p>针对哲学家就餐问题，如果我们限制最多允许四位哲学家同时就餐，就可以避免循环依赖的条件，因为依照抽屉原理，总是会有一位哲学家可以拿到两根筷子，所以程序可以运行下去。</p>
<p>针对限制特定数量资源的情况，最好用的并发原语就是信号量(Semaphore)。Go官方提供了一个扩展库，提供了一个Semaphore的实现：<a href="https://pkg.go.dev/golang.org/x/sync/semaphore" target="_blank" rel="external">semaphore/Weighted</a>。</p>
<p>我们把这个信号量初始值设置为4，代表最多允许同时4位哲学家就餐。把这个信号量传给哲学家对象，哲学家想就餐时就请求这个信号量，如果能得到一个许可，就可以就餐，吃完把许可释放回给信号量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line">    <span class="comment">// 信号量</span></div><div class="line">    sema *semaphore.Weighted</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.sema.Acquire(context.Background(),<span class="number"> 1</span>) <span class="comment">// 请求一个许可</span></div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">        p.sema.Release<span class="number">(1</span>) <span class="comment">// 释放许可给信号量</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 最多允许四个哲学家就餐</span></div><div class="line">    sema := semaphore.NewWeighted<span class="number">(4</span>)</div><div class="line">    <span class="comment">//</span></div><div class="line">    names := []<span class="typename">string</span>{color.RedString(<span class="string">"孔子"</span>), color.MagentaString(<span class="string">"庄子"</span>), color.CyanString(<span class="string">"墨子"</span>), color.GreenString(<span class="string">"孙子"</span>), color.WhiteString(<span class="string">"老子"</span>)}</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">            sema: sema,</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以运行这个程序，看看是否程序是否还会被hang住。</p>
<h2 id="解法二：奇偶资源">解法二：奇偶资源</h2>
<p>我们给每一位哲学家编号，从1到5, 如果我们规定奇数号的哲学家首先拿左手边的筷子，再拿右手边的筷子，偶数号的哲学家先拿右手边的筷子，再拿左手边的筷子， 释放筷子的时候按照相反的顺序，这样也可以避免出现循环依赖的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        <span class="keyword">if</span> p.ID<span class="number">%2</span> ==<span class="number"> 1</span> { <span class="comment">// 奇数</span></div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">            mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 再尝试放下左手边的筷子</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 先尝试拿起右手边的筷子</span></div><div class="line">            mark(p, <span class="string">"拿起右手筷子"</span>)</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 先尝试放下左手边的筷子</span></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 再尝试放下右手边的筷子</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            ID:   i +<span class="number"> 1</span>,</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序，你同样也会发现程序可以顺利执行下去，并不会出现死锁的现象。</p>
<h2 id="解法三：资源分级">解法三：资源分级</h2>
<p>另一个简单的解法是为资源（这里是筷子）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，筷子按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的筷子，再拿编号较高的。用完筷子后，他总是先放下编号较高的筷子，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的筷子时，只有编号最高的筷子留在桌上，从而第五位哲学家就不能使用任何一只筷子了。而且，只有一位哲学家能使用最高编号的筷子，所以他能使用两只筷子用餐。当他吃完后，他会先放下编号最高的筷子，再放下编号较低的筷子，从而让另一位哲学家拿起后边的这只开始吃东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        <span class="keyword">if</span> p.ID ==<span class="number"> 5</span> { <span class="comment">//</span></div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 先尝试拿起第1只筷子</span></div><div class="line">            mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 再尝试拿起第5只筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 先尝试放下第5只的筷子</span></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 再尝试放下第1只的筷子</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子(第n只)</span></div><div class="line">            mark(p, <span class="string">"拿起右手筷子"</span>)</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子(第n+1只)</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="解法四：引入服务生">解法四：引入服务生</h2>
<p>如果我们引入一个服务生，比如韩非子，由韩非子负责分配筷子，这样我们就可以将拿左手筷子和右手筷子看成一个原子操作，要么拿到筷子，要么等待，就可以破坏死锁的第二个条件(持有和等待)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line"></div><div class="line">    mu *sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.mu.Lock() <span class="comment">// 服务生控制</span></div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line">        p.mu.Unlock() </div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>完整代码可以参考 [dive-to-gosync-workshop(<a href="https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems" target="_blank" rel="external">https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems</a>)</p>
<p>下一篇我们讲解另外一个经典并发问题：一氧化二氢的生成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>哲学家就餐问题是一个非常非常经典的问题，也是一个非常通用的研究并发编程中死锁现象的问题。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyroscope: 一个简单易用的持续剖析平台]]></title>
    <link href="https://colobu.com/2022/01/27/pyroscope-a-continuous-profiling-platform/"/>
    <id>https://colobu.com/2022/01/27/pyroscope-a-continuous-profiling-platform/</id>
    <published>2022-01-27T10:56:27.000Z</published>
    <updated>2022-01-27T11:00:43.197Z</updated>
    <content type="html"><![CDATA[<p>开发人员常常需要跟踪生产环境中的应用程序的性能瓶颈，并试图找出造成瓶颈的根本原因。要做到这一点，他们通常会通过日志来收集这些信息。不幸的是，这种方法可能会很耗时，而且无法提供有关潜在问题的足够详细的信息。</p>
<p>一种现代且更先进的方法是应用和使用profiling技术和工具，突出显示最慢的应用程序代码和消耗大部分资源（如CPU和内存）的方法。持续分析(Continuous profiling)是在生产环境中持续    收集应用程序性能数据，并将这些数据提供给开发人员进行深入分析的过程。</p>
<p>通过，我们通过采集程序的指标，生成一个概要文件(Profile)进行单次的分析。Go语言提供了pprof工具，可以很方便的生成profile文件。你可以通过程序调用<a href="https://pkg.go.dev/runtime/pprof" target="_blank" rel="external">runtime/pprof</a>生成CPU、Heap等概要文件，也可以使用<a href="https://pkg.go.dev/net/http/pprof" target="_blank" rel="external">net/http/pprof</a>集成到web应用程序中，通过go tool pprof工具在命令行或者web页面中进行分析。</p>
<p>有时候，我们不能及时的进行pprof分析，故障可能消失了或者程序已经crash了。另外我们可能需要不同时段的profile进行对比，进行比较才能发现问题，比如内存泄露的问题。这个时候持续分析(continuous profiling)就很重要了。很多云服务厂商都提供持续分析的功能，比如<a href="https://www.datadoghq.com/dg/apm/ts/profiler/go-continuous-profiler-ts/?utm_source=advertisement&amp;utm_medium=search&amp;utm_campaign=dg-google-profiler-emea-goprofiling-tshirt&amp;utm_keyword=%2Bgo %2Bprofiling&amp;utm_matchtype=b&amp;utm_campaignid=15426873343&amp;utm_adgroupid=128217964697&amp;gclid=Cj0KCQiA_8OPBhDtARIsAKQu0gYymyElbglw_I7uZJkZ7ynxfzn1nVojVZJ9rkm_6_hbchG09w4CCmEaAkWfEALw_wcB" target="_blank" rel="external">Go Continuous Profiler | Datadog</a>、<a href="https://cloud.google.com/profiler/docs" target="_blank" rel="external">Cloud Profiler | Google Cloud</a>、<a href="https://aws.amazon.com/cn/codeguru/features/" target="_blank" rel="external">Amazon CodeGuru Profiler</a>等。</p>
<a id="more"></a>
<h2 id="Pyroscope简介">Pyroscope简介</h2>
<p>如果你想在自己的生产系统中使用持续分析，可以考虑<a href="https://pyroscope.io/" target="_blank" rel="external">Pyroscope</a>。</p>
<p>Pyroscope是一个开源的持续分析系统，使用Go语言实现。服务端使用web页面查看，提供丰富的分析的功能，客户端提供Go、Java、Python、Ruby、PHP、.NET等多种语言的支持，并且支持PUSH、PULL两种采集方式。</p>
<p><img src="0.svg" alt="deployment diagram"></p>
<p>首先，你需要部署一个Pyroscope server，它底层采用BadgerDB作为存储引擎，对profile数据进行了优化处理。</p>
<p>Pyroscope server负责接收(或者拉取，下面我们主要演示推的方式)agent上传的profile数据，并提供时间线界面，可以查看一段时间以内的profile数据。比如下图演示了一个<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>微服务程序12个小时的profile数据。</p>
<p><img src="1.png" alt="image-20220127133952215"></p>
<p>它既可以显示这一段时间内的火焰图，也可以显示排序表格展示，或者同时显示。这个火焰图可以看出耗时主要在微服务的方法调用和编解码上(除了Go运行时调度)。</p>
<p>你还可以选取不同的时间段进行比较, 左右的图形的时间只需在时间线上拖拽选取即可。</p>
<p><img src="2.png" alt="image-20220127134555179"></p>
<p>还可以进行diff查看，这个常常用在内存泄露的分析上。</p>
<p><img src="3.png" alt="image-20220127135630155"></p>
<h2 id="Pyroscope_server安装">Pyroscope server安装</h2>
<p>Pyroscope server端可以通过docker安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -p <span class="number">4040</span>:<span class="number">4040</span> pyroscope/pyroscope:latest server</div></pre></td></tr></table></figure>

<p>也可以在各中操作系统中直接安装。</p>
<p>比如Mac:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install pyroscope-io/brew/pyroscope</div><div class="line">brew services start pyroscope-server</div></pre></td></tr></table></figure>

<p>各Liunx发行版也方便安装，比如Cebtos:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://dl.pyroscope.io/release/pyroscope-<span class="number">0.8</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.rpm</div><div class="line"><span class="built_in">sudo</span> yum localinstall pyroscope-<span class="number">0.8</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.rpm</div><div class="line"><span class="built_in">sudo</span> systemctl start pyroscope-server</div><div class="line"><span class="built_in">sudo</span> systemctl enable pyroscope-server</div></pre></td></tr></table></figure>

<p>比如ubuntu:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://dl.pyroscope.io/release/pyroscope_0.<span class="number">8.0</span>_amd64.deb</div><div class="line"><span class="built_in">sudo</span> apt-get install ./pyroscope_0.<span class="number">8.0</span>_amd64.deb</div></pre></td></tr></table></figure>

<p>安装完成后，就可以通过web界面访问了: <a href="http://localhost:4040" target="_blank" rel="external">http://localhost:4040</a>, 你可以通过配置文件更改监听端口以及其它一些配置项。</p>
<h2 id="客户端集成">客户端集成</h2>
<p>上面已经提到，Pyroscope提供了好几种语言的agent sdk, 我们以Go  Push方式为例。在你需要持续分析的应用程序的开始加入agent的配置:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">pyroscope.Start(pyroscope.Config{</div><div class="line">    ApplicationName: <span class="string">"simple.golang.app"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// replace this with the address of pyroscope server</span></div><div class="line">    ServerAddress:   <span class="string">"http://pyroscope-server:4040"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// you can disable logging by setting this to nil</span></div><div class="line">    Logger:          pyroscope.StandardLogger,</div><div class="line"></div><div class="line">    <span class="comment">// by default all profilers are enabled,</span></div><div class="line">    <span class="comment">// but you can select the ones you want to use:</span></div><div class="line">    ProfileTypes: []pyroscope.ProfileType{</div><div class="line">      pyroscope.ProfileCPU,</div><div class="line">      pyroscope.ProfileAllocObjects,</div><div class="line">      pyroscope.ProfileAllocSpace,</div><div class="line">      pyroscope.ProfileInuseObjects,</div><div class="line">      pyroscope.ProfileInuseSpace,</div><div class="line">    },</div><div class="line">  })</div></pre></td></tr></table></figure>

<p>主要配置ApplicationName的名称，这个名称会显示在Pyroscope的服务端下拉框中。profile数据要发送到哪一个Pyroscope服务器上，你可以配置ServerAddress,以及通过ProfileTypes监控要监控的Profile项。</p>
<p>只需加上这几行启动程序后，你就可以在Pyroscope server的web界面上查看持续分析的数据了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开发人员常常需要跟踪生产环境中的应用程序的性能瓶颈，并试图找出造成瓶颈的根本原因。要做到这一点，他们通常会通过日志来收集这些信息。不幸的是，这种方法可能会很耗时，而且无法提供有关潜在问题的足够详细的信息。</p>
<p>一种现代且更先进的方法是应用和使用profiling技术和工具，突出显示最慢的应用程序代码和消耗大部分资源（如CPU和内存）的方法。持续分析(Continuous profiling)是在生产环境中持续    收集应用程序性能数据，并将这些数据提供给开发人员进行深入分析的过程。</p>
<p>通过，我们通过采集程序的指标，生成一个概要文件(Profile)进行单次的分析。Go语言提供了pprof工具，可以很方便的生成profile文件。你可以通过程序调用<a href="https://pkg.go.dev/runtime/pprof" target="_blank" rel="external">runtime/pprof</a>生成CPU、Heap等概要文件，也可以使用<a href="https://pkg.go.dev/net/http/pprof" target="_blank" rel="external">net/http/pprof</a>集成到web应用程序中，通过go tool pprof工具在命令行或者web页面中进行分析。</p>
<p>有时候，我们不能及时的进行pprof分析，故障可能消失了或者程序已经crash了。另外我们可能需要不同时段的profile进行对比，进行比较才能发现问题，比如内存泄露的问题。这个时候持续分析(continuous profiling)就很重要了。很多云服务厂商都提供持续分析的功能，比如<a href="https://www.datadoghq.com/dg/apm/ts/profiler/go-continuous-profiler-ts/?utm_source=advertisement&amp;utm_medium=search&amp;utm_campaign=dg-google-profiler-emea-goprofiling-tshirt&amp;utm_keyword=%2Bgo %2Bprofiling&amp;utm_matchtype=b&amp;utm_campaignid=15426873343&amp;utm_adgroupid=128217964697&amp;gclid=Cj0KCQiA_8OPBhDtARIsAKQu0gYymyElbglw_I7uZJkZ7ynxfzn1nVojVZJ9rkm_6_hbchG09w4CCmEaAkWfEALw_wcB" target="_blank" rel="external">Go Continuous Profiler | Datadog</a>、<a href="https://cloud.google.com/profiler/docs" target="_blank" rel="external">Cloud Profiler | Google Cloud</a>、<a href="https://aws.amazon.com/cn/codeguru/features/" target="_blank" rel="external">Amazon CodeGuru Profiler</a>等。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试官提问三个Go接口的概念， 10年gopher竟无言以对]]></title>
    <link href="https://colobu.com/2022/01/16/three-new-concepts-of-go-interface-since-1-18/"/>
    <id>https://colobu.com/2022/01/16/three-new-concepts-of-go-interface-since-1-18/</id>
    <published>2022-01-16T11:44:58.000Z</published>
    <updated>2022-01-16T14:00:52.957Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.18后， Go的interface的含义有所<a href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/" target="_blank" rel="external">变化</a>, 三个新的和Go接口有关的概念很多人还不知道: <code>type set</code>(类型集合)、<code>specific type</code>(特定类型)和<code>structural type</code>(结构类型)。</p>
<a id="more"></a>
<h2 id="type_set_(类型集合)">type set (类型集合)</h2>
<p>type set称之为类型集合，一些关注Go泛型的朋友其实也对此有些了解，它是Go 1.18新增加的一个概念。</p>
<p>Go 1.18之前，Go的接口代表了一组方法的集合(method set),凡是实现了这些方法集合的类型，都被称之为实现了这个接口。Go不像Java语言，需要显示地定义某个类实现某个接口，Go不需要这样，在Go中，只要一个类型实现了某个接口定义的所有方法，它就实现了这个接口，可以赋值给这个接口类型的变量，或者作为这个接口类型的方法的实参或者返回值，这种设计有时候也被叫做<code>鸭子类型</code>(duck typing)。只要它走起来像鸭子，叫起来像鸭子，那么它就是鸭子，这是一个很经典的对鸭子类型的描述。</p>
<p>在Go 1.18中，接口不再代表方法的集合了，而是代表类型的集合(type set)。只要某种类型在这个接口的类型集合中，那么我们就说这种类型实现了这个接口。如果这个接口被用作类型约束，那么在这个接口定义的类型集合中的任意一个元素，都可以实例化这个类型参数。</p>
<p>所以，实际上，为了支持接口作为类型约束的扩展，Go语言规范不得不重新定义接口的含义了，这也是类型集合出现的原因。</p>
<p>其实，接口的方法集的概念还在 一个接口的方法集是这个接口的类型集合中所有元素的方法集的<strong>交集</strong>。</p>
<p>r本文假定你对Go泛型有了一定的了解。假定你还不了解，那么你必须知道，Go 1.18中接口除了原先的方法元素还，还支持包含类型元素，类型元素可以是某个类型<code>T</code>、或者是近似类型<code>~T</code>,或者是它们的联合<code>int|int8|int16|int32|int64|~string</code>。</p>
<p>如果一个接口<code>I</code>嵌入了另外一个接口<code>E</code>,那么<code>I</code>的类型集是它显示定义的类型集合和嵌入的接口<code>E</code>的类型集合的交集。相当于<code>E</code>把接口<code>I</code>的类型集收窄了。</p>
<p>如何判断一个接口的类型集呢？请遵循下面的原则:</p>
<ul>
<li><p>空接口<code>any</code>、<code>interface{}</code>的类型集是所有类型的集合<br>所以像<code>int</code>、<code>string</code>、<code>strcut{}</code>、<code>MyStruct</code>、<code>func foobar()</code>、<code>chan int</code>、<code>map[int]string</code>、<code>[]int</code>等等都在空接口的类型集合中</p>
</li>
<li><p>非空接口的类型集合是接口元素的类型集合的交集<br>那么什么是接口元素的类型集合呢？参照下面的四条。<br>前面我们已经提到，接口元素包含类型元素和方法元素。</p>
<ul>
<li><p>一个方法的类型集合是定义这个方法的所有类型，也就是只要某个类型的方法集包含这个方法，那么它就属于这个方法的类型集合<br>比如接口中有<code>String() string</code>这样一个方法，那么所有实现这个方法的类型都属于<code>String() string</code>定义的类型集合，比如<code>net.IP</code>。</p>
</li>
<li><p>一个非接口类型的类型集合就是只包含这个类型的类型集合<br>比如<code>int</code>的类型集合只包含<code>int</code>这样一个元素。</p>
</li>
<li><p>近似元素<code>~T</code>的类型集合是所有底层类型为<code>T</code>的所有类型的集合</p>
</li>
</ul>
<p>比如<code>type MyInt int</code>中的<code>MyInt</code>就属于<code>~int</code>的类型集合</p>
<ul>
<li>联合元素<code>t1|t2|…|tn</code>的类型集合是这些联合元素类型集合的<strong>并集</strong></li>
</ul>
</li>
</ul>
<p>下面的例子列举了一些类型的集合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个集合的类型集合只有int这一种类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口代表所有底层为int类型的所有类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口代表底层为int，并且实现了String方法的所有类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">	String() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口的类型集合是空集，因为不可能一个元素既是int又是string类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">	<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Floats代表所有底层是浮点数的类型 (底层为float32或者float64)</span></div><div class="line"><span class="keyword">type</span> Floats <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">float32</span> | ~<span class="typename">float64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="specific_type_(特定类型)_和_specific_type_set">specific type (特定类型) 和 specific type set</h2>
<p>接口另外一个很重要的概念就是<code>specific type</code> (特定类型)。</p>
<p>只有包含类型元素的接口才定义了特定类型(可能是空的类型)。</p>
<p>如果不严格的讲，特定类型是出现在类型元素中定义的那些类型<code>T</code>、<code>~T</code>、<code>t1|t2|...|tn</code>中的<code>t1</code>、<code>t2</code>、<code>...</code>、<code>tn</code>。</p>
<p>更准确地说，对于给定的接口<code>I</code>，特定类型的集合对应于该接口代表的类型集合<strong>𝑅</strong>，这里要求<strong>𝑅</strong>是非空且有限的。否则，如果<strong>𝑅</strong>为空或无限，则接口没有特定类型。</p>
<p>对于一个给定的接口、类型元素或者类型，它代表的类型集合<strong>𝑅</strong>定义如下：</p>
<ul>
<li><p>对于一个没有任何类型元素的接口，它的<strong>𝑅</strong>是所有的元素(无限)。<br>所以它没有特定类型。</p>
</li>
<li><p>如果一个接口有类型元素，它的<strong>𝑅</strong>是它的元素代表的类型的交集<br>至于有没有特定类型要看<strong>𝑅</strong>是否是非空且有限。</p>
</li>
<li><p>对于一个非接口类型<code>T</code>,或者<code>~T</code>, 它的<strong>𝑅</strong>是包含类型<code>T</code>的集合</p>
</li>
<li><p>对于联合元素<code>t1|t2|…|tn</code>, 它的<strong>𝑅</strong>是这些项代表类型的<strong>并集</strong></p>
</li>
</ul>
<p>下面是特定类型的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Celsius <span class="typename">float32</span></div><div class="line"><span class="keyword">type</span> Kelvin  <span class="typename">float32</span></div><div class="line"></div><div class="line"><span class="keyword">interface</span>{}                    <span class="comment">// 无限，所以没有特定类型</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span> }               <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="typename">string</span> }           <span class="comment">// 特定类型是string</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>|~<span class="typename">string</span> }       <span class="comment">// 特定类型是int, string</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|Kelvin }    <span class="comment">// 特定类型是Celsius, Kelvin</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">float64</span>|any }       <span class="comment">// 没有特定类型，因为联合类型的代表类型是无限的</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; m() }          <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="typename">int</span>; m() }         <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; any }          <span class="comment">// 特定类型是int，int和any的交集</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; <span class="typename">string</span> }       <span class="comment">// 没有特定类型</span></div></pre></td></tr></table></figure>

<h2 id="type_set_vs_specific_type_set">type set vs specific type set</h2>
<p>类型集合和特定类型集合还是有区别的，从上面它们的定义可以看出来。</p>
<p><strong>一个接口即使类型为空，它的特定类型集合可能不为空。</strong><br>比如<code>interface{ int; m() }</code>,它的类型集合是空的(int没有实现m方法)，但是它的特定类型是<code>int</code>。</p>
<p><strong>一个接口即使有有限的特定类型，它的类型集合也可能是无限的</strong><br>比如<code>interface{ ~int; m() }</code>,它的特定类型是int，但是它的类型集合确是无限的(任何底层为int并且实现了方法m的类型都属于它的类型集合)</p>
<p>那么定义特定类型有什么用呢？</p>
<h2 id="特定类型的应用">特定类型的应用</h2>
<p>特定类型主要用于判断类型参数是否支持索引, 像<code>a[x]</code>这样的类型。</p>
<p>比如一个表达式<code>a[x]</code>, <code>a</code>这个实例的类型可能是数组、指向数组的指针、slice、字符串、map。</p>
<p>如果<code>a</code>的类型是类型参数<code>P</code>的话，那么我们的代码<code>a[x]</code>在什么条件下才不会编译出错？</p>
<p>要求的条件就和特定类型有关了：</p>
<ul>
<li>P必须有特定类型</li>
<li>对于P的特定类型的值a，支持<code>a[x]</code>这种索引写法</li>
<li>P的所有特定类型必须相同。在这里，string类型的元素类型是byte (<a href="https://github.com/golang/go/issues/49551" target="_blank" rel="external">https://github.com/golang/go/issues/49551</a>)</li>
<li>如果P的特定类型包含map类型的话，那么它的所有特定类型必须是map,而且所有的key的类型是相同的<br>所以有时候你定义了一个包含map、slice、string的联合元素接口的话，这个接口的实例你不能使用<code>a[x]</code>索引类型，元素的类型都是int</li>
<li><code>a[x]</code>是数组、slice、string的索引为x的元素，或者是map类型key为x的元素，a[x]的类型必须相同</li>
<li>如果P的特定类型包含string类型，那么不能给<code>a[x]</code>赋值(字符串是不可变的)</li>
</ul>
<p>特定类型还用作类型转化定义上。<br>对于一个变量<code>x</code>,如果它的类型是<code>V</code>, 要转换成的类型是<code>T</code>, 只要满足下面一条，x就可以转换成<code>T</code>类型:</p>
<ul>
<li><code>V</code>的每一个特定类型的值都可以转换成<code>T</code>的每一个特定类型</li>
<li>只有<code>V</code>是类型参数，<code>T</code>不是，那么<code>V</code>的每一个特定类型的值都可以转换成<code>T</code></li>
<li>只有<code>T</code>是类型参数，<code>x</code>可以转换成T的每一个特定类型</li>
</ul>
<p>一句话，是类型参数就满足每一个特定类型，不是类型参数就满足这个类型。</p>
<p>另外，对于类型参数，要调用内建的函数<code>len</code>、<code>cap</code>，必须要求它们的特定类型允许使用这些内建函数。</p>
<h2 id="structural_type_(结构类型)">structural type (结构类型)</h2>
<p>一个接口<code>T</code>要被成为结构化的(<code>structural</code>),需要满足下面的条件之一:</p>
<ol>
<li>存在一个单一的类型<code>U</code>,它是<code>T</code>的类型集合中的每一个元素相同的底层类型</li>
<li><code>T</code>的类型集合只包含chan类型，并且它们的元素类型都是<code>E</code>, 所有的chan的方向包含相同的方向(不一定要求完全相同)</li>
</ol>
<p>结构化类型包含一个结构类型，根据上面的条件不同，结构类型可能是:</p>
<ol>
<li>类型<code>U</code>, 或者</li>
<li>如果<code>T</code>只包含双向chan的话，结构类型为<code>chan E</code>,否则可能是<code>chan&lt;- E</code>或者<code>&lt;-chan E</code></li>
</ol>
<p>下面是包含结构类型的结构化接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span> }                          <span class="comment">// 结构类型为 int</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|Kelvin }               <span class="comment">// 结构类型为 float32</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="keyword">chan</span> <span class="typename">int</span> }                    <span class="comment">// 结构类型为 chan int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="keyword">chan</span> <span class="typename">int</span>|~<span class="keyword">chan</span>&lt;- <span class="typename">int</span> }        <span class="comment">// 结构类型为 chan&lt;- int</span></div><div class="line"><span class="keyword">interface</span>{ ~[]*data; String() <span class="typename">string</span> }    <span class="comment">// 结构类型为 *data</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的例子不包含结构类型，所以是非结构化接口</span></div><div class="line"><span class="keyword">interface</span>{}                               <span class="comment">// 没有固定单一的底层类型</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|<span class="typename">float64</span> }              <span class="comment">// 底层类型不相同</span></div><div class="line"><span class="keyword">interface</span>{ <span class="keyword">chan</span> <span class="typename">int</span> | <span class="keyword">chan</span>&lt;- <span class="typename">string</span> }     <span class="comment">// channel的元素类型不相同</span></div><div class="line"><span class="keyword">interface</span>{ &lt;-<span class="keyword">chan</span> <span class="typename">int</span> | <span class="keyword">chan</span>&lt;- <span class="typename">int</span> }      <span class="comment">// channel没有相同的方向</span></div></pre></td></tr></table></figure>

<p>在Go语言规范中，并没有对结构化接口有更多的介绍，如何使用，更多是是它内部获取底层的结构类型，以及做类型检查，比如下面的例子就会报<code>no structural type</code>编译错误:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> myByte1 []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | []<span class="typename">int</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j:k] <span class="comment">// 底层类型不一致</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | []<span class="typename">int</span> | <span class="typename">string</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j] </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面这个函数没问题，因为string的底层页被看做[]byte</span></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | myByte2 | <span class="typename">string</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j] </div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的代码也会报<code>M has no structural type</code>编译错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> multiMapOfInt <span class="keyword">interface</span> {</div><div class="line">	<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">float64</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">complex64</span>]<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> arraySummer[M multiMapOfInt](mp M) (sum <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> mp {</div><div class="line">		sum += v</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如下面大家使用Go泛型的时候常会犯的错误,虽然<code>[]byte</code>、<code>map[int]byte</code>、<code>string</code>都能range,而且key(index)、value类型都一样，但是也会报<code>R has no structural type</code>错误:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> rangeType <span class="keyword">interface</span> {</div><div class="line">	[]<span class="typename">byte</span> | <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">byte</span> | <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> rangeIt[R rangeType](r R) {</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> r {</div><div class="line">		fmt.Println(i, v)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	rangeIt(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">byte</span><span class="number">{1</span>:<span class="number"> 1</span>,<span class="number"> 2</span>:<span class="number"> 2</span>,<span class="number"> 3</span>:<span class="number"> 3</span>})</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.18后， Go的interface的含义有所<a href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/" target="_blank" rel="external">变化</a>, 三个新的和Go接口有关的概念很多人还不知道: <code>type set</code>(类型集合)、<code>specific type</code>(特定类型)和<code>structural type</code>(结构类型)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写可维护的Go代码]]></title>
    <link href="https://colobu.com/2022/01/15/Writing-maintainable-Go-code/"/>
    <id>https://colobu.com/2022/01/15/Writing-maintainable-Go-code/</id>
    <published>2022-01-15T04:54:58.000Z</published>
    <updated>2022-02-24T09:36:34.503Z</updated>
    <content type="html"><![CDATA[<p>编写可维护的代码是最基本的要求。清晰度、可读性和简单性都是保持代码可维护性的各个方面。它应该使某人加入您的项目或在有人离开后维护代码的过程变得容易。可维护性的衡量指标是代码更改的容易程度以及与这些更改引起的风险性。为了有效地编写Go程序，了解Go语言的属性和地道写法，并使用与命名、程序构建、格式等相关既定约定是至关重要。</p>
<p>以下是一些有助于编写可维护的Go代码的良好实践。</p>
<p>原文: <a href="https://jogendra.dev/writing-maintainable-go-code" target="_blank" rel="external">Writing maintainable Go code</a> by Jogendra.</p>
<a id="more"></a>
<p>保持小巧的<code>main</code>函数</p>
<p>&quot;<a href="https://go.dev/tour/basics/1" target="_blank" rel="external">Go之旅</a>&quot;中讲到：</p>
<blockquote>
<p>每个 Go 程序都由包组成。程序在包 <code>main</code> 中开会运行。</p>
</blockquote>
<p>包<strong>main</strong>是唯一的，那些导出名称(<code>exported name</code>)既不会导出，编译器也不会将其视为常规包; 相反，它将其编译为可执行程序。在包<strong>main</strong>中，<strong>main</strong>函数必须存在，它是 Go 程序的入口点。对软件包<code>main</code>和函数<code>main</code>的期望是它们尽可能少。</p>
<p><strong>main.main</strong>是单例的，仅被调用一次。你为它内部的代码编写测试也很困难，因此，强烈建议使用<em>main.main</em>仅仅启动程序，但不要在此包中编写业务逻辑。将启动程序和业务逻辑分别写在单独的包中可改进程序的结构和可维护性。</p>
<h2 id="使用有意义的名称">使用有意义的名称</h2>
<p>在 Go 中命名主要强调一致、简短和准确的名称，因为它们往往会提高代码的可读性。</p>
<p>Russ Cox的命名<a href="https://research.swtch.com/names" target="_blank" rel="external">理念</a>：</p>
<blockquote>
<p>一个名称的长度不应超过它的信息内容。对于一个局部变量，名称<code>i</code>和<code>index</code>或者<code>idx</code>携带同样的信息，而且更方便快速阅读。类似地，<code>i</code>和<code>j</code>这一对命名比索引变量<code>i1</code>和<code>i2</code>更好(更差的是<code>index1</code>和<code>index2</code>),在阅读代码的时候它们更容易区分。全局名称必须传达相对更多的信息，因为它们出现在更广泛的上下文中。即便如此，一个简短、准确的名字比冗长的名字更能说明问题：比较<a href="http://www.google.com/codesearch?q=acquire" target="_blank" rel="external"><code>acquire</code></a>和<a href="http://www.google.com/codesearch?q=take_?ownership" target="_blank" rel="external"><code>take_ownership</code></a>。让每个命名都能<a href="http://www.bartleby.com/141/strunk5.html#13" target="_blank" rel="external">区分</a>。</p>
</blockquote>
<p>Ken Thompson，Rob Pike，Robert Griesemer，Russ Cox，Ian Lance Taylor等人多年的编程经验和命名理念很可能激发了Go中的命名约定。<a href="https://talks.golang.org/2014/names.slide" target="_blank" rel="external">这是</a>安德鲁·格兰德（Andrew Gerrand）的一张幻灯片，其更深入地讨论了Go中的命名。</p>
<h2 id="代码分组">代码分组</h2>
<p>在函数（或方法）中，某些语句可能有关联。因此，建议将这些语句保留在单独的代码块中，用换行符分隔。分组使程序构造更好，并通过分隔相关部分来提高可读性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Creating new HTTP request with request body</span></div><div class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"https://api.example.com/endpoint"</span>, body)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// handle err</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Setting headers to HTTP request</span></div><div class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">req.Header.Set(<span class="string">"Authorization"</span>, <span class="string">"Bearer b7d03a6947b217efb6f3ec3bd3504582"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Executing the request</span></div><div class="line">resp, err := http.DefaultClient.Do(req)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// handle err</span></div><div class="line">}</div><div class="line"><span class="keyword">defer</span> resp.Body.Close()</div></pre></td></tr></table></figure>

<h2 id="撰写有意义的注释">撰写有意义的注释</h2>
<p>注释是理解现有代码的绝佳方式，它可以回答这段代码的作用，为什么会存在某些代码段以及为什么它是这样编写的。最好在编写代码时就编写注释，但更重要的是在更新代码时更新注释。代码更新可能会改变特定代码的实现目的，因此更新注释也至关重要的; 否则，它将造成困惑而不是在以后有所帮助。与其编写与代码相矛盾的注释还不如不写代码注释。您可以在 Go 中编写块注释或内联注释，你可以选择任何更适合您的代码的内容。</p>
<p>您使用该工具做检查在 Go 中你是否正确编写注释代码。<a href="https://blog.golang.org/godoc" target="_blank" rel="external">godoc</a>将从您的代码中提取注释，并为您的 Go 程序生成文档。Go 中的注释有几个不错的功能，请参阅<a href="https://blog.jbowen.dev/2019/09/the-magic-of-go-comments/" target="_blank" rel="external">Go代码注释的魔法</a>以详细了解。<code></code></p>
<p>知道不必写注释与知道应该写注释一样重要。最好避免过度注释代码，并将其留给其他程序员来理解Go。您应该避显而易见的注释，如果代码的可读性足够高，则不需要注释。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get country code from customer address.</span></div><div class="line">    countryCode := getCountryCode(address)</div><div class="line"></div><div class="line">    <span class="comment">// If country code is "IN", assign "India" as</span></div><div class="line">    <span class="comment">// country.</span></div><div class="line">    <span class="keyword">if</span> countryCode == <span class="string">"IN"</span> {</div><div class="line">        country = <span class="string">"India"</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里写的注释没啥意义，不会增加任何价值。</p>
<h2 id="不要重复">不要重复</h2>
<p>DRY（不要重复自己）是软件开发的一个原则，旨在减少软件模式的重复，用抽象代替它以避免冗余。</p>
<p>那么，代码重复又有什么问题呢？在有变更之前，没有太多问题。想象一下，在10个地方重复相同的代码，每当有小的变化时都要在所有10个地方做改变。如果代码仅存在于一个位置，则更容易维护代码，从而确保一致性。如果代码重复，您很有可能忘记更新其中一个副本，这意味着您在一个副本中修复的错误仍将存在于另一个副本中。</p>
<p>如果必须再次编写相同的代码，可以其移动到大多数<code>helper</code>函数所在的共享package中。通过删除重复的代码，您将拥有更少的代码，这些代码将更清晰，更易于维护。</p>
<p>缺少泛型（Go 1.17以及先前版本）可能会使 Go 代码在某些地方看起来重复。但是，随着Go 1.18正式支持泛型，将使编写通用代码变得更加简单，冗余更少，并且更易于维护。</p>
<p>但是，有时重复代码比试图强制抽象以免冗余会更简单，更容易理解。因此，更重要的是要知道在哪里应用 DRY，在哪里不应用 DRY，因为代码的可读性和易懂性胜过其他问题。</p>
<h2 id="Linting和样式指南">Linting和样式指南</h2>
<p>遵守编码标准使代码库保持一致，易于代码审查和维护。它使编码风格一致。通常，风格指南是有争议的，为了让人们遵守相同指南的最佳方法是为Go代码创建一个标准的风格指南。拥有风格指南不是最重要的，最重要的是让你的团队真正地使用它。市面上有许多开源的 linting 工具和样式指南，你可以从以此为基础并对其进行修改，使其适合你。</p>
<p>Go有一个在社区中普遍使用和接受的代码格式标准，尽管它不需要特殊的规则。Go 提供了这个<code>fmt</code>工具，鼓励和保护 Go 代码使用既定约定进行格式化。</p>
<p>许多编辑器支持在保存文件时调用文件格式化工具。或者，像 <a href="https://github.com/mvdan/gofumpt" target="_blank" rel="external">gofumpt</a>工具，提供更严格的格式化版本。该工具是 <code>gofmt</code>的修改分支，可用作<code>gofmt</code>原地替换。此外，这些工具还支持自定义源代码转换和添加自定义的规则。</p>
<p>如果您想遵循Go的社区风格指南，可以使用<a href="https://github.com/golang/lint" target="_blank" rel="external">golint</a>。该工具提供了有关代码样式的有用提示，还可以帮助查看Go的公认约定。这将极大地帮助加入项目的每个新开发人员。</p>
<h2 id="避免深度嵌套">避免深度嵌套</h2>
<p>过度的嵌套困扰着每个人。深度嵌套使得代码很难遵循设计逻辑。如果您正在执行代码审查或重新访问旧代码，具有大量嵌套的超大函数（或方法）会造成逻辑的混乱。此外，嵌套代码难以阅读; 嵌套越小，读者的认知负荷就越小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition1 {</div><div class="line">    <span class="keyword">if</span> condition2 {</div><div class="line">        <span class="keyword">if</span> condition3 {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> condition5 {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>开发人员可以通过多种方式避免这种情况。<a href="https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting" target="_blank" rel="external">这里是</a>一个很好的阅读材料。</p>
<h2 id="编写更好的函数">编写更好的函数</h2>
<p>避免编写较长的函数;函数越小越好。较长的函数可能难以读取、测试和维护。较长的函数通常具有较大的职责，因此建议将它们分解为较小的函数。通过分解较长的函数创建的较短的函数，可以服务更多的调用方。因为它们可以提供可管理的独立任务。</p>
<p>Unix管道的发明者、Unix的创始人之一道格·麦克罗伊（Doug McIlroy）说（Unix Philosophy）：</p>
<blockquote>
<p>让每个程序都做好一件事。要完成一项新工作，请重新构建，而不是通过添加新功能使旧程序复杂化。</p>
</blockquote>
<p>因此，分解函数以做好一件事确实与Unix哲学英雄相惜。</p>
<p>如前所述，命名对于可读性至关重要。好的函数名称比注释更好，它们与编写良好的注释或 API 文档一样有助于理解代码。尽量保留较少的功能参数。</p>
<h2 id="避免包(package)级别状态">避免包(package)级别状态</h2>
<p>在 Go 中，对于任何给定的导入路径，包的实例都是唯一一个(单例)。这意味着在包级别上，任何变量只有一个实例。包级别的变量在全局级别共享，这意味着所有访问者将共享同一个实例。函数<code>X</code>可以修改变量，函数<code>Y</code>可以读取修改后的值。</p>
<p>使用包级别的变量可能会产生许多影响：</p>
<ol>
<li>很难跟踪变量的修改位置以及跟踪访问变量的位置以做出任何决定。</li>
<li>包级变量导致紧密耦合; 一个角落的代码修改可能需要修改代码的另一个角落，这使得阅读、修改和单元测试代码变得更加困难。</li>
<li>它可能会导致争用条件等问题。</li>
</ol>
<p>但是，包级别常量的使用非常有用。因此，始终建议尽可能避免使用包级别状态(译者注: 可修改的变量)。若要减少耦合，请将相关变量移到所需的结构体的字段上。在结构体中定义依赖项和配置使其变得容易。接口的使用也非常有帮助。</p>
<h2 id="尽早返回并明智地使用条件">尽早返回并明智地使用条件</h2>
<p>条件语句是我们必须经常写的东西。它在代码是干净还是混乱方面发挥着重要作用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此代码的问题在于<code>else</code>语句在此处没有帮助;相反，它使代码变得混乱且可读性降低。相反，把它写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>译者注， 把它写成下面的方式更简洁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">return</span> n &lt;=<span class="number"> 12</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也经常会看到整个函数体都包在<code>if</code>语句里面,这也是不好的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        sum()</div><div class="line">        subtract()</div><div class="line">        multiply()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以翻转判断条件使代码更简洁可读:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) {</div><div class="line">    <span class="keyword">if</span> n &lt;=<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    sum()</div><div class="line">    subtract()</div><div class="line">    multiply()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="更经常的使用switch">更经常的使用<code>switch</code></h2>
<p><strong>switch</strong>语句是缩短 if-else 语句序列的最佳方式，有益于编写干净的程序。程序经常需要做比较判断，如果我们的程序使用了太多的<code>if-else</code>，会使代码凌乱且可读性较差。所以使用switch有很大帮助。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> transact(bank <span class="typename">string</span>) {</div><div class="line">    <span class="keyword">if</span> bank == <span class="string">"Citi"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #1: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"StandardChartered"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #2: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"HSBC"</span> || bank == <span class="string">"Deutsche"</span> || bank == <span class="string">"JPMorgan"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #3: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"NatWest"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #4: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #E: %s\n"</span>, bank)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这看起来很乱，对吧？现在让我们改用一个switch。以下代码如何以惯用方式重写相同的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> transact(bank <span class="typename">string</span>) {</div><div class="line">    <span class="keyword">switch</span> bank {</div><div class="line">    <span class="keyword">case</span> <span class="string">"Citi"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #1: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"StandardChartered"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #2: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"HSBC"</span>, <span class="string">"Deutsche"</span>, <span class="string">"JPMorgan"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #3: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"NatWest"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #4: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #E: %s\n"</span>, bank)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将来，如果添加新的银行，使用<code>switch-case</code>将更容易，更干净。</p>
<h2 id="持续的代码重构">持续的代码重构</h2>
<p>在大型代码库中，重构代码库结构至关重要。代码重构不时地提高代码的可读性和质量。这不是一次性的过程；团队应持续支付技术债务，以保持代码库正常。我曾学过“尽早重构，经常重构”（<code>refactor early, refactor often</code>），这对于编写可维护的Go代码非常有意义。随着时间的推移，包的代码数量和责任会变得越来越重，因此最好将一些包分解成更小的包，因为它们易于维护。重构包的另一个好理由是改进命名。包只包含与其功能相关的代码也是至关重要的。例如，Go把<code>os.SEEK_SET</code>、<code>os.SEEK_CUR</code>和 <code>os.SEEK_END</code>移动到<code>io.SeekStart</code>、<code>io.SeekCurrent</code>和 <code>io.SeekEnd</code>。包<code>io</code>更适合于组织涉及文件I/O的代码。将包分解成小的包也会使依赖关系变得轻量级。</p>
<h2 id="结论">结论</h2>
<p>随着时间和其他程序员在代码库上工作，我们更好地理解可维护性意味着什么。 编写可维护的代码并不复杂； 它需要每个贡献代码的人的知识、经验和仔细思考。 我们讨论的一组良好实践应该可以帮助您和团队更好地维护您的 Go 代码。</p>
<blockquote>
<p>原文 <a href="https://deepsource.io/learn/software-engineering-guide/writing-maintainable-go-code/" target="_blank" rel="external">Writing maintainable Go code - DeepSource Learn</a> by Jogendra</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写可维护的代码是最基本的要求。清晰度、可读性和简单性都是保持代码可维护性的各个方面。它应该使某人加入您的项目或在有人离开后维护代码的过程变得容易。可维护性的衡量指标是代码更改的容易程度以及与这些更改引起的风险性。为了有效地编写Go程序，了解Go语言的属性和地道写法，并使用与命名、程序构建、格式等相关既定约定是至关重要。</p>
<p>以下是一些有助于编写可维护的Go代码的良好实践。</p>
<p>原文: <a href="https://jogendra.dev/writing-maintainable-go-code" target="_blank" rel="external">Writing maintainable Go code</a> by Jogendra.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型编程: 支持特例化?]]></title>
    <link href="https://colobu.com/2022/01/11/go-generic-supports-specialization-no/"/>
    <id>https://colobu.com/2022/01/11/go-generic-supports-specialization-no/</id>
    <published>2022-01-11T00:14:53.000Z</published>
    <updated>2022-01-16T11:25:05.338Z</updated>
    <content type="html"><![CDATA[<p>一些编程语言如C++、Rust都是支持泛型特例化的，Go泛型支持吗？</p>
<a id="more"></a>
<p>所谓特例化(specialization)对泛型功能代码的扩展。比如对于泛型的函数，它的实现对于满足泛型参数的所有类型(type set)都是一样的，如果我们想对这些类型集(type set)中的一个，它的函数做特殊的实现，一些支持泛型特例化的语言是可以支持的，比如C++ template:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> fun(T a)</div><div class="line">{</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"template fun(): "</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;   <span class="comment">// 对int型特例化</span></div><div class="line"><span class="keyword">void</span> fun(<span class="keyword">int</span> a)</div><div class="line">{</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"specialized template fun for int type: "</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>fun</code>是一个函数模板,但是针对<code>int</code>类型，此函数有特殊的实现。</p>
<p>Rust也有类似的功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#![feature(min_specialization)]</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> Special</div><div class="line">{</div><div class="line">    x : usize,</div><div class="line">    y : usize</div><div class="line">}</div><div class="line"></div><div class="line">trait MyTrait</div><div class="line">{</div><div class="line">    fn myfunc(&self);</div><div class="line">}</div><div class="line"></div><div class="line">impl&lt;T&gt; MyTrait <span class="keyword">for</span> T</div><div class="line">{</div><div class="line">    <span class="keyword">default</span> fn myfunc(&self) { println!(<span class="string">"hi"</span>); }</div><div class="line">}</div><div class="line"></div><div class="line">impl MyTrait <span class="keyword">for</span> Special</div><div class="line">{</div><div class="line">    fn myfunc(&self) { println!(<span class="string">"I'm special"</span>); }</div><div class="line">}</div><div class="line"></div><div class="line">fn main() {</div><div class="line">    let spe = Special{</div><div class="line">        x: <span class="number">1</span>,</div><div class="line">        y: <span class="number">2</span>,</div><div class="line">    };</div><div class="line">    spe.myfunc();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>MyTrait</code>针对通用类型<code>T</code>有一个默认实现，但是针对特定的类型<code>Special</code>,有一个特定的实现。</p>
<p>其它编程语言当前还不支持特例化，但是可以通过方法重载实现类似的功能，如typescript、C#等。<br>另外复杂的特例化还包括部分特例化的特性。</p>
<p>那么问题来了，Go的泛型(类型参数)是否支持特例化呢？我们先写个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> {</div><div class="line">	next  *List[T]</div><div class="line">	value T</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l *List[T]) Len() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l *List[<span class="typename">string</span>]) Length() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们定义了一个泛型类型<code>List[T any]</code>, 包括它的一个泛型方法<code>Len() int</code>，接下来我们尝试定义一个“特例化”的方法<code>Length() int</code>。</p>
<p>编译一下，没问题，程序可以正常编译，难道Go泛型真的支持特例化吗？</p>
<p>我们再增加一个特例化泛型方法试试:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (l *List[<span class="typename">int</span>]) Size() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个时候再编译试试,编译出错:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cannot <span class="operator"><span class="keyword">use</span> <span class="number">0</span> (untyped <span class="built_in">int</span> constant) <span class="keyword">as</span> <span class="built_in">int</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="keyword">return</span> statement</span></div></pre></td></tr></table></figure>

<p>其实这个错误信息已经告诉我们了，这里的<code>int</code>并不是内建的整数类型，而是一个类型参数的名称，等价于我们常用的<code>T</code>、<code>K</code>、<code>V</code>。这里我们使用<code>int</code>作为类型参数的名称很有迷惑性。</p>
<p>所以答案也是很明确的，当前Go 1.18并不支持<strong>泛型特例化</strong>, 小心别掉到坑里了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些编程语言如C++、Rust都是支持泛型特例化的，Go泛型支持吗？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型编程: interface 不再是那个interface]]></title>
    <link href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/"/>
    <id>https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/</id>
    <published>2022-01-08T13:48:20.000Z</published>
    <updated>2022-01-14T11:10:58.895Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.18 支持泛型后， Go interface 的意义已经彻彻底底的改变了，除了先前代表的方法集的意义外，还被用作泛型的类型约束(type constraint)的功能, interface已经不再是以前那个单纯的少年了。</p>
<a id="more"></a>
<p>在Go 1.17.x以及以前的版本中，interface是这样定义的：</p>
<blockquote>
<p>An interface type specifies a <strong>method set</strong> called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
<p>接口类型定义了一个方法集合，称之为接口(interface)。接口类型的变量可以存储任意的实现这个方法集合的类型，这种类型是此interface的超集。这种类型被称为实现了接口。接口类型的变量如果未初始化则它的值为nil。</p>
</blockquote>
<p>在Go 1.18中，interface定义改变了：</p>
<blockquote>
<p>An interface type defines a <strong>type set</strong>. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
<p>接口类型定义了一个类型集合。接口类型的变量可以存储这个接口类型集合的任意一种类型的实例值。这种类型被称之为实现了这个接口。接口类型的变量如果未初始化则它的值为nil。</p>
</blockquote>
<p>所以一句话，先前接口定义了方法集合，现在接口定义了类型集合。接口的用途也进行了扩展。</p>
<p>interface的定义也扩展了。先前，接口定义只能包含方法元素(method element):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> {</div><div class="line">	Read([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</div><div class="line">	Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</div><div class="line">	Close() error</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在接口定义除了方法元素外，还可以包含类型元素:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing all types with underlying type int.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing all types with underlying type int which implement the String method.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">	String() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing an empty type set: there is no type that is both an int and a string.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">	<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>类型元素包含类型(<code>T</code>)或者近似类型(<code>~T</code>)或者联合(union)元素(<code>A|B|C|~D</code>)。</p>
<p>但是，因为接口的定义和含义改变了，所以接口在使用的时候也有一些些不同。本文通过实例一一介绍。</p>
<p>首先记住一点，Go 1.17.x 及以前的版本中接口的使用方法在Go 1.18中照样使用，使用方法不变。变得是接口有类型元素或者做类型约束时的一些限制。</p>
<h3 id="近似元素的类型T必须是底层类型(underlying_type)自己，而且不能是接口类型">近似元素的类型<code>T</code>必须是底层类型(underlying type)自己，而且不能是接口类型</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误的定义!</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> I0 <span class="keyword">interface</span> {</div><div class="line">	~MyInt <span class="comment">// 错误! MyInt不是underlying type, int才是</span></div><div class="line">	~error <span class="comment">// 错误! error是接口</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素不能是类型参数(type_parameter)">联合(union)类型元素不能是类型参数(type parameter)</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误, interface{ K }中K是类型参数</span></div><div class="line"><span class="keyword">func</span> I1[K any, V <span class="keyword">interface</span>{ K }]() {</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误, interface{ nt | K }中K 是类型参数</span></div><div class="line"><span class="keyword">func</span> I2[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | K }]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素的非接口元素必须是两两不相交">联合(union)类型元素的非接口元素必须是两两不相交</h3>
<p>两两不相交意思是两两的交集是空集，比如 <code>int|string</code>的交集是空集，而<code>int|~int</code>的交集是<code>int</code>。</p>
<p>联合类型中的非接口元素必须是两两不相交的。</p>
<p>下面的定义没问题，因为any等价于<code>interface{}</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> I3[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | any }]() {</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误！ int和!int相交</span></div><div class="line"><span class="keyword">func</span> I4[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | ~<span class="typename">int</span> }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面的定义没有问题。因为int和MyInt是两个类型，不相交</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> I5[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | MyInt }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! int和~MyInt相交，交集是int</span></div><div class="line"><span class="keyword">func</span> I6[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | ~MyInt }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! int和MyInt2是相同类型，相交</span></div><div class="line"><span class="keyword">type</span> MyInt2 = <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> I7[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | MyInt2 }]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素如果包含多于一个元素，不能包含包含非空方法的接口类型，也不能是comparable或者嵌入comparable">联合(union)类型元素如果包含多于一个元素，不能包含包含非空方法的接口类型，也不能是comparable或者嵌入comparable</h3>
<p>这条规则定义了接口作为类型元素的一些限制.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译没问题，只包含一个元素</span></div><div class="line"><span class="keyword">func</span> I9[K <span class="keyword">interface</span>{ io.Reader }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误!不能编译。因为包含了两个元素，而且无论是`io.Reader`还是`io.Writer`都包含方法</span></div><div class="line"><span class="keyword">func</span> I10[K <span class="keyword">interface</span>{ io.Reader | io.Writer }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 编译正常，因为这是正常的接口，没有联合元素</span></div><div class="line"><span class="keyword">func</span> I11[K <span class="keyword">interface</span> {</div><div class="line">	io.Reader</div><div class="line">	io.Writer</div><div class="line">}]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 联合类型多于一个元素，并且io.Reader包含方法</span></div><div class="line"><span class="keyword">func</span> I12[K <span class="keyword">interface</span>{ io.Reader | <span class="typename">int</span> }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且不能是comparable</span></div><div class="line"><span class="keyword">func</span> I13[K comparable | <span class="typename">int</span>]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且元素不能嵌入comparable</span></div><div class="line"><span class="keyword">func</span> I14[K <span class="keyword">interface</span>{ comparable } | <span class="typename">int</span>]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="包含非接口类型元素、近似元素和联合类型只能用作类型参数，或者其它用作约束接口的元素">包含非接口类型元素、近似元素和联合类型只能用作类型参数，或者其它用作约束接口的元素</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line"></div><div class="line">    <span class="comment">// 以下编译没问题 </span></div><div class="line">	_ <span class="keyword">interface</span>{}</div><div class="line">	_ <span class="keyword">interface</span>{ m() }</div><div class="line">	_ <span class="keyword">interface</span>{ io.Reader }</div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		io.Reader</div><div class="line">		io.Writer</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 以下不能编译，接口不能用作变量实例类型</span></div><div class="line">	_ <span class="keyword">interface</span>{ <span class="typename">int</span> }</div><div class="line">	_ <span class="keyword">interface</span>{ ~<span class="typename">int</span> }</div><div class="line">	_ <span class="keyword">interface</span>{ MyInt }</div><div class="line">	A <span class="keyword">interface</span> {</div><div class="line">   	  <span class="typename">int</span></div><div class="line">	  m()</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 可以编译</span></div><div class="line">	_ <span class="keyword">struct</span>{ i <span class="typename">int</span> }</div><div class="line">    <span class="comment">// 下面一行不能编译,因为~int不能作为字段的类型</span></div><div class="line">	_ <span class="keyword">struct</span>{ i ~<span class="typename">int</span> }</div><div class="line">    <span class="comment">// 下面一行不能编译，因为constraints.Ordered只能用作类型约束</span></div><div class="line">	_ <span class="keyword">struct</span>{ i constraints.Ordered }</div><div class="line"></div><div class="line">    <span class="comment">// 下面两行能够编译，因为它们是接口类型，并且类型元素也是普通接口</span></div><div class="line">    _ <span class="keyword">interface</span>{ any }</div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		<span class="keyword">interface</span> {</div><div class="line">			any</div><div class="line">			m()</div><div class="line">		}</div><div class="line">	}</div><div class="line">    <span class="comment">// 不能编译，因为接口部署普通接口，而是类型约束</span></div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		<span class="keyword">interface</span> {</div><div class="line">			<span class="typename">int</span>|~<span class="typename">int</span></div><div class="line">			m()</div><div class="line">		}</div><div class="line">	}</div><div class="line">)</div></pre></td></tr></table></figure>

<h3 id="接口类型不定递归嵌入">接口类型不定递归嵌入</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误! 不能自己嵌入自己</span></div><div class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> {</div><div class="line">	Node</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! Tree不能通过TreeNode嵌入自己</span></div><div class="line"><span class="keyword">type</span> Tree <span class="keyword">interface</span> {</div><div class="line">	TreeNode</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> TreeNode <span class="keyword">interface</span> {</div><div class="line">	Tree</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.18 支持泛型后， Go interface 的意义已经彻彻底底的改变了，除了先前代表的方法集的意义外，还被用作泛型的类型约束(type constraint)的功能, interface已经不再是以前那个单纯的少年了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译] go fuzzing]]></title>
    <link href="https://colobu.com/2022/01/03/go-fuzzing/"/>
    <id>https://colobu.com/2022/01/03/go-fuzzing/</id>
    <published>2022-01-03T13:40:09.000Z</published>
    <updated>2022-01-03T14:28:09.864Z</updated>
    <content type="html"><![CDATA[<p>Go fuzzing(模糊测试)是Go 1.18发布的另一个非常重要的特性，因为Go泛型已经把大家的目光都吸引过去了，导致go fuzzing这个特性有些人还不是太了解。Go官方发布了一个文档，介绍了Go Fuzzing技术。<br><a href="https://tip.golang.org/doc/fuzz/" target="_blank" rel="external">Go Fuzzing</a></p>
<a id="more"></a>
<p>Go 自 1.18开始在标准工具链中开始支持模糊测试(fuzzing)。</p>
<h2 id="概览">概览</h2>
<p>Fuzzing 是一种自动化的测试技术， 它不断的创建输入用来测试程序的bug。 Go fuzzing使用覆盖率智能指导遍历被模糊化测试的代码，发现缺陷并报告给用户。由于模糊测试可以达到人类经常忽略的边缘场景，因此它对于发现安全漏洞和缺陷特别有价值。</p>
<p>下面是一个模糊测试的示例，突出标识了它的主要组件。<br><img src="example.png" alt=""></p>
<h2 id="编写并运行模糊测试">编写并运行模糊测试</h2>
<h3 id="必备条件">必备条件</h3>
<p>Below are rules that fuzz tests must follow.</p>
<p>下面是模糊测试必须遵循的规则：</p>
<ul>
<li>模糊测试必须是一个名称类似<code>FuzzXxx</code>的函数，仅仅接收一个<code>*testing.F</code>类型的参数,没有返回值</li>
<li>模糊测试必须在<code>*_test.go</code>文件中才能运行</li>
<li>Fuzz target(模糊目标)必须是对<code>(*testing.F).Fuzz</code>的方法调用，参数是一个函数，并且此函数的第一个参数是<code>*testing.T</code>,然后是模糊参数(<code>fuzzing argument</code>)，没有返回值</li>
<li>一个模糊测试中必须只有一个模糊目标</li>
<li>所有的种子语料库(<code>seed corpus</code>)必须具有与模糊参数相同的类型,顺序相同。对<code>(*testing.F).Add</code>的调用也是如此, 同样也适用模糊测试中的testdata/fuzz中的语料文件</li>
<li>模糊参数只能是下面的类型<ul>
<li>string, []byte</li>
<li>int, int8, int16, int32/rune, int64</li>
<li>uint, uint8/byte, uint16, uint32, uint64</li>
<li>float32, float64</li>
<li>bool</li>
</ul>
</li>
</ul>
<h3 id="建议">建议</h3>
<p>下面的建议可以帮助你应付大部分的模糊测试：</p>
<ul>
<li>Fuzzing应该在支持覆盖率检测的平台上运行（目前是AMD64和ARM64），这样语料库可以在运行时有意义地增长，并且在进行Fuzzing时可以覆盖更多的代码。</li>
<li>模糊目标应该是快速的和确定性的，这样模糊引擎可以有效地工作，并且新的故障和代码覆盖率可以很容易地重现。</li>
<li>由于模糊目标是在多个工作进程之间以不确定的顺序并行调用的，因此模糊目标的状态不应持续到每次调用结束后，并且模糊目标的行为不应依赖于全局状态。</li>
</ul>
<h3 id="定制">定制</h3>
<p>默认的go命令满足大部分模糊化测试场景，所以典型的一个模糊化运行命令应该如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go test -fuzz={FuzzTestName}</div></pre></td></tr></table></figure>

<p>但是go命令提供一些定制化的参数来运行模糊测试，它们在<a href="https://pkg.go.dev/cmd/go" target="_blank" rel="external">cmd/go</a>文档中都有介绍。</p>
<p>这里重点说几个:</p>
<p>-fuzztime:  执行的模糊目标在退出的时候要执行的总时间或者迭代次数，默认是用不结束<br>-fuzzminimizetime: 模糊目标在每次最少尝试时要执行的时间或者迭代次数，默认是60秒。你可以禁用最小化尝试，只需把这个参数设置为0<br>-parallel: 同时执行的模糊化数量，默认是<code>$GOMAXPROCS</code>。当前进行模糊化测试时设置-cpu无效果</p>
<h2 id="其它资源">其它资源</h2>
<ul>
<li><strong>教程</strong><ul>
<li>如果想了解Go模糊化介绍性的文章，请参考<a href="https://go.dev/blog/fuzz-beta" target="_blank" rel="external">the blog post</a></li>
<li>更多教程正在准备中</li>
</ul>
</li>
<li><strong>文档</strong><ul>
<li><code>testing</code> 包描述了模糊测试中用到的<code>testing.F</code>类型</li>
<li><code>cmd/go</code> 描述了和模糊测试相关的参数</li>
</ul>
</li>
<li><strong>技术细节</strong><ul>
<li><a href="https://golang.org/s/draft-fuzzing-design" target="_blank" rel="external">Design draft</a></li>
<li><a href="https://golang.org/issue/44551" target="_blank" rel="external">提案</a></li>
</ul>
</li>
</ul>
<h2 id="术语">术语</h2>
<ul>
<li>corpus entry: 语料库条目，可以在模糊化测试时使用。它可以是一个特殊格式的文件，也可以是<code>(*testing.F).Add</code>方法的调用</li>
<li>coverage guidance: 一种模糊化方法，它使用代码覆盖范围的扩展来确定哪些语料库条目值得保留以备将来使用。</li>
<li>fuzz target: 模糊测试的函数，在模糊化过程中对语料库条目和生成的值执行模糊测试。通过将函数传递给<code>(*testing.F).Fuzz</code>来提供模糊测试</li>
<li>fuzz test: 一个test文件中的函数，格式为<code>FuzzXxx(*testing.F)</code>,用来执行模糊测试</li>
<li>fuzzing: 一种自动测试类型，它不断地修改程序的输入，以发现代码可能易受影响的问题，如bug或漏洞。</li>
<li>fuzzing arguments: 被传递到模糊目标的类型，并且可以被mutator修改变异</li>
<li>fuzzing engine: 一种管理模糊化的工具，包括维护语料库、调用变体、识别新覆盖范围和报告失败。</li>
<li>generated corpus: 语料库在模糊化过程中由模糊引擎随时间进行维护，以跟踪进度。它存储在<code>$GOCACHE/fuzz</code>中。</li>
<li>mutator: 模糊处理时使用的一种工具，它在将语料库条目传递给模糊目标之前对其进行随机操作。</li>
<li>package: 同一个文件夹下源代码的集合，会被编译在一起。Go代码组织的<a href="https://tip.golang.org/ref/spec#Packages" target="_blank" rel="external">方式</a>。ation.</li>
<li>seed corpus: 用户提供的用于模糊测试的语料库，可用于指导模糊引擎。它由模糊测试中的<code>f.Add</code>调用提供的语料库条目和包中<code>testdata/fuzz/{FuzzTestName}</code>目录中的文件组成。</li>
<li>test file: 格式为<code>xxx_test.go</code>类型的文件，包含测试、benchmark和模糊测试代码</li>
<li>vulnerability: 代码中的安全敏感弱点，可被攻击者利用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go fuzzing(模糊测试)是Go 1.18发布的另一个非常重要的特性，因为Go泛型已经把大家的目光都吸引过去了，导致go fuzzing这个特性有些人还不是太了解。Go官方发布了一个文档，介绍了Go Fuzzing技术。<br><a href="https://tip.golang.org/doc/fuzz/" target="_blank" rel="external">Go Fuzzing</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
