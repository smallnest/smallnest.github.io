<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2022-03-06T08:19:33.989Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[经典并发问题: 大型理发店]]></title>
    <link href="https://colobu.com/2022/03/06/hilzers-barbershop-problem/"/>
    <id>https://colobu.com/2022/03/06/hilzers-barbershop-problem/</id>
    <published>2022-03-06T06:04:11.000Z</published>
    <updated>2022-03-06T08:19:05.176Z</updated>
    <content type="html"><![CDATA[<p>二月二理发店太火了，家家都爆满，这次我们来到Hilzer的理发店，这是一家比较大的理发店。</p>
<a id="more"></a>
<p>这家理发店有三位有经验的理发师，每个理发师都有自己独立的理发椅。等待区有一个四座的沙发，等待区还有站一些人等待。还有一个收银台。</p>
<ul>
<li>依照新冠疫情防控的要求，最多允许20个顾客进入。</li>
<li>如果有顾客，理发师优先从沙发上叫起等待最久的顾客开始理发；如果没有顾客，理发师则在自己的理发椅上睡觉</li>
<li>顾客来到后<ul>
<li>如果已经有20个顾客，则此顾客离开去其它理发店</li>
<li>如果理发师在睡觉，则叫起一位理发师开始理发</li>
<li>如果没有空闲的理发师，则选择沙发坐下</li>
<li>如果沙发已经坐满，则在休息去站着等待</li>
</ul>
</li>
<li>理完发后顾客去收银台去缴费，交完费后理发师把发票交给顾客。顾客就离开，而理发师则准备服务下一位顾客</li>
</ul>
<p>这一次理发店的问题比上一个<a href="https://colobu.com/2022/02/27/barbershop-problem/" target="_blank" rel="external">理发店问题</a>要复杂很多:</p>
<ul>
<li>等待区分为了站立区和沙发区</li>
<li>新增加了收银台，理发师和顾客需要付款和发票的相互等待</li>
<li>三位理发师</li>
</ul>
<p>这类问题使用信号量并发原语比较好，因为理发师、沙发等都是一定数量的资源。理发师和顾客之间缴费和发票之间的同步按理说使用channel比较合适，但是收银台只有一位收银员，还需要处理理发师、顾客和收银员之间的并发，所以我们可以把收银、开发票看成计数器是1的资源。</p>
<p>首先我们还是定义信号量和辅助方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Semaphore定义</span></div><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">	time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来我们定义所需的并发原语。</p>
<p>我们使用<code>customerMutex</code>这个排他锁来控制理发店的顾客数量。<br>使用<code>sofaSema</code>控制站立用户坐到沙发上以及理发师叫起等待的顾客。</p>
<p><code>paySema</code>用来让顾客去缴费，而<code>receiptSema</code>让理发师把发票送给顾客，顾客离开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 控制顾客的总数</span></div><div class="line">	customerMutex    sync.Mutex</div><div class="line">	customerMaxCount =<span class="number"> 20</span></div><div class="line">	customerCount    =<span class="number"> 0</span></div><div class="line"></div><div class="line">	<span class="comment">// 沙发的容量</span></div><div class="line">	sofaSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 4</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 三位理发师</span></div><div class="line">	barberSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 3</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 收银台</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// 同时只有一对理发师和顾客结账</span></div><div class="line">	paySema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)</div><div class="line">	<span class="comment">// 顾客拿到发票才会离开，控制开票</span></div><div class="line">	receiptSema Semaphore = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>接下来我们实现理发师的逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理发师工作</span></div><div class="line"><span class="keyword">func</span> barber(name <span class="typename">string</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(name + <span class="string">"老师尝试请求一个顾客"</span>)</div><div class="line">		sofaSema.Release() <span class="comment">// 等待沙发上等待最久的一位顾客</span></div><div class="line">		log.Println(name + <span class="string">"老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line"></div><div class="line">		log.Println(name + <span class="string">"老师理完发，等待顾客付款"</span>)</div><div class="line">		paySema.Acquire() <span class="comment">// 等待用户缴费</span></div><div class="line">		log.Println(name + <span class="string">"老师给付完款的顾客发票"</span>)</div><div class="line">		receiptSema.Release() <span class="comment">// 通知顾客发票开好</span></div><div class="line">		log.Println(name + <span class="string">"老师服务完一位顾客"</span>)</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来实现顾客的逻辑, 注意<code>customerCount</code>操作需要使用Mutex保护:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(500</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	customerMutex.Lock()</div><div class="line">	<span class="keyword">if</span> customerCount == customerMaxCount {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">		customerMutex.Unlock()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	customerCount++</div><div class="line">	customerMutex.Unlock()</div><div class="line"></div><div class="line">	log.Println(<span class="string">"一位顾客开始等沙发坐下"</span>)</div><div class="line">	sofaSema.Acquire()</div><div class="line">	log.Println(<span class="string">"一位顾客找到空闲沙发坐下,直到被理发师叫起理发"</span>)</div><div class="line"></div><div class="line">	paySema.Release()</div><div class="line">	log.Println(<span class="string">"一位顾客已付完钱"</span>)</div><div class="line">	receiptSema.Acquire()</div><div class="line">	log.Println(<span class="string">"一位顾客拿到发票，离开"</span>)</div><div class="line"></div><div class="line">	customerMutex.Lock()</div><div class="line">	customerCount--</div><div class="line">	customerMutex.Unlock()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后把所有的逻辑串起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 托尼、凯文、艾伦理发师三巨头</span></div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Tony"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Kevin"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Allen"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> customers()</div><div class="line"></div><div class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">	&lt;-sigs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序观察并发的执行。</p>
<p>通过这个问题，我们可以好好的练习Semaphore的使用，以及两个goroutine之间信号的传递，控制并发程序的协作执行。</p>
<p>下一章你想了解什么样的经典并发问题呢？</p>
<h2 id="历史并发问题">历史并发问题</h2>
<ul>
<li><a href="https://colobu.com/2022/02/13/dining-philosophers-problem/" target="_blank" rel="external">哲学家就餐问题</a></li>
<li><a href="https://colobu.com/2019/07/23/concurrent-problem-h2o-factory/" target="_blank" rel="external">制造一氧化二氢</a></li>
<li><a href="https://colobu.com/2022/02/27/barbershop-problem/" target="_blank" rel="external">理发店的故事</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>二月二理发店太火了，家家都爆满，这次我们来到Hilzer的理发店，这是一家比较大的理发店。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题： 理发店的故事]]></title>
    <link href="https://colobu.com/2022/02/27/barbershop-problem/"/>
    <id>https://colobu.com/2022/02/27/barbershop-problem/</id>
    <published>2022-02-27T08:40:51.000Z</published>
    <updated>2022-02-27T10:12:01.956Z</updated>
    <content type="html"><![CDATA[<p>马上就二月二了，理发店就要忙活起来了，托尼、凯文、艾伦等老师的理发剪磨刀霍霍，把椅子擦亮，准备各位顾客的到来。</p>
<p><a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" target="_blank" rel="external">Sleeping barber problem</a>是一个经典的goroutine交互和并发控制的问题，可以很好的用来演示多写多读的并发问题(multiple writers multiple readers)。</p>
<a id="more"></a>
<p>理发店问题最早是由计算机科学先驱 Edsger Dijkstra 在1965指出的，在 Silberschatz 和 Galvin 的 Operating Systems Concepts一书中有此问题的变种。</p>
<p>这个问题是这样子的。<br>有这么一个理发店，有一位理发师和几个让顾客等待的座位：</p>
<ul>
<li>如果没有顾客，这位理发师就躺在理发椅上睡觉</li>
<li>顾客必须唤醒理发师让他开始理发</li>
<li>如果一位顾客到来，理发师正在理发<ul>
<li>如果还有顾客用来等待的座位，则此顾客坐下</li>
<li>如果座位都满了，则此顾客离开</li>
</ul>
</li>
<li>理发师理完头发后，需要检查是否还有等待的顾客<ul>
<li>如果有，则请一位顾客起来开始理发</li>
<li>如果没有，理发师则去睡觉</li>
</ul>
</li>
</ul>
<p>虽然条件很多，我们可以把它想象成为一个并发的queue。在当前的问题下，有多个并发写(multiple writer, 顾客)，一个并发读(single reader),对吧。</p>
<h2 id="使用sync-Cond实现">使用sync.Cond实现</h2>
<p>一般，先前，我们处理并发队列通过使用<a href="https://pkg.go.dev/sync#Cond" target="_blank" rel="external">sync.Cond</a>这个并发原语(在java语言中，我们一般使用wait/notify)。</p>
<p>就<code>sync.Cond</code>这个并发原语而言，它并不是一个很容易使用的对象。因为它还需要一个一个<code>sync.Locker</code>配合使用，并且相关的方法要么必须使用Locker、要么可以省略Locker，容易让人迷惑，等待的goroutine被唤醒时还需要检查判断条件，所以用起来总是需要小心翼翼地。</p>
<p>首先，我们定义一个Locker和一个Cond,并且定义顾客等待的座位数。<br>来了一位顾客，座位数加一，Tony老师叫起一位等待的顾客开始理发时，座位数减一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	seatsLock sync.Mutex</div><div class="line">	seats     <span class="typename">int</span></div><div class="line">	cond = sync.NewCond(&seatsLock)</div><div class="line">)</div></pre></td></tr></table></figure>

<p>理发师的工作就是不断的检查是否有顾客等待，如果有，就交起一位顾客开始理发，理发耗时是随机的，理完再去叫下一位顾客。如果没有顾客，那么理发师就会被阻塞(开始睡觉)。<br>逐一这里Cond的使用方法，Wait之后需要for循环检查条件是否满足，并且Wait上下会有Locker的使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(<span class="string">"Tony老师尝试请求一个顾客"</span>)</div><div class="line">		seatsLock.Lock()</div><div class="line">		<span class="keyword">for</span> seats ==<span class="number"> 0</span> {</div><div class="line">			cond.Wait()</div><div class="line">		}</div><div class="line">		seats--</div><div class="line">		seatsLock.Unlock()</div><div class="line">		log.Println(<span class="string">"Tony老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>customers</code>模拟陆陆续续的顾客的到来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾客到来之后，先请求seatsLock， 避免多个顾客同时进来的并发竞争。然后他会检查是否有空闲的座位，如果有则坐下并通知理发师。此时理发师如果睡眠则会被唤醒，如果正在理发会忽略。<br>如果没有空闲的座位则离开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	seatsLock.Lock()</div><div class="line">	<span class="keyword">defer</span> seatsLock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> seats ==<span class="number"> 3</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	seats++</div><div class="line">	cond.Broadcast()</div><div class="line"></div><div class="line">	log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里简单的是由整数seats代表空闲的座位，实际处理这样的场景的时候，你可能会使用一个slice作为队列。</p>
<p>本身这个实现还是很简单的，但是Cond+Locker的使用方式还是感觉让人有那么一点不放心，事实上，很多这样的场景，我们可以使用channel来实现。</p>
<h2 id="使用Channel实现Semaphore">使用Channel实现Semaphore</h2>
<p>我们可以使用Channel实现一个Semaphore来解决理发店问题。Semaphore实现如下,和我们水分子生成的问题中的实现是类似的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) TryAcquire() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> s &lt;- <span class="keyword">struct</span>{}{}: <span class="comment">// 还有空位子</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>: <span class="comment">// 没有空位子了,离开</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了这个并发原语，我们就容易解决理发店问题了。注意这里我们实现了<code>TryAcquire</code>,就是为了顾客到来的是否检查有没有空闲的座位。<br>这里为什么不使用Go官方扩展的<code>semaphore.Weighted</code>并发原语呢，是因为<code>semaphore.Weighted</code>有个问题，在<code>Accquire</code>之前调用<code>Release</code>方法的话会panic，所以我们自己实现了一个。</p>
<p>我们定义了有三个等待座位的信号量。Tony老师先调用<code>Release</code>方法，也就是想从座位上请一位顾客过来理发，以便空出一个等待座位。如果没有顾客，Tony就会无奈的等待和睡觉了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> seats = <span class="built_in">make</span>(Semaphore,<span class="number"> 3</span>)</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">    		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(<span class="string">"Tony老师尝试请求一个顾客"</span>)</div><div class="line">		seats.Release()</div><div class="line">		log.Println(<span class="string">"Tony老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>顾客的检查也更简单:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	<span class="keyword">if</span> ok := seats.TryAcquire(); ok {</div><div class="line">		log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，如果我们使用自定义的Semaphore话，代码会变得更加的简单。</p>
<p>那么这种channel实现的Semaphore有什么缺陷吗？那就是如果队列的长度太大的话，channel的容量就会很大。不过如果类型设置为strcut{}类型的话，就会节省很多的内存，所以一般也不会有什么问题，虽然比官方扩展的计数器方式的<code>semaphore.Weighted</code>多占用一些空间，但是占用的空间还是有限的。</p>
<p>更进一步，尽然我们要实现一个队列，其实可以通过这个channel来实现，把顾客类型替换struct{}类型，这样就没有额外多余的占用了。</p>
<h2 id="多理发师的情况">多理发师的情况</h2>
<p>更进一步，我们考虑多个理发师的情况。</p>
<p>多个理发师的问题其实就演变成了多写(multiple writer)多读(multiple reader)的场景了。</p>
<p>托尼、凯文和艾伦是理发界的三大巨头，我们演示三位理发师并发理发的场景，同时理发店的规模也扩大了，有10个可以等待的座位。</p>
<p>基于channel实现的Semaphore的解决方案，多个理发师的场景和单个理发师的场景是一样的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Acquire() {</div><div class="line">	s &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) TryAcquire() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> s &lt;- <span class="keyword">struct</span>{}{}: <span class="comment">// 还有空位子</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>: <span class="comment">// 没有空位子了,离开</span></div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s Semaphore) Release() {</div><div class="line">	&lt;-s</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> seats = <span class="built_in">make</span>(Semaphore,<span class="number"> 10</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 托尼、凯文、艾伦理发师三巨头</span></div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Tony"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Kevin"</span>)</div><div class="line">	<span class="keyword">go</span> barber(<span class="string">"Allen"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> customers()</div><div class="line"></div><div class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">	&lt;-sigs</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">	time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 理发师</span></div><div class="line"><span class="keyword">func</span> barber(name <span class="typename">string</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		<span class="comment">// 等待一个用户</span></div><div class="line">		log.Println(name + <span class="string">"老师尝试请求一个顾客"</span>)</div><div class="line">		seats.Release()</div><div class="line">		log.Println(name + <span class="string">"老师找到一位顾客，开始理发"</span>)</div><div class="line"></div><div class="line">		randomPause<span class="number">(2000</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 模拟顾客陆陆续续的过来</span></div><div class="line"><span class="keyword">func</span> customers() {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		randomPause<span class="number">(1000</span>)</div><div class="line"></div><div class="line">		<span class="keyword">go</span> customer()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 顾客</span></div><div class="line"><span class="keyword">func</span> customer() {</div><div class="line">	<span class="keyword">if</span> ok := seats.TryAcquire(); ok {</div><div class="line">		log.Println(<span class="string">"一位顾客开始坐下排队理发"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		log.Println(<span class="string">"没有空闲座位了，一位顾客离开了"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>全部经典并发问题的代码可以参考<a href="https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems" target="_blank" rel="external">smallnest/dive-to-gosync-workshop</a>。下一次我们再分析一个更加复杂的理发店问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>马上就二月二了，理发店就要忙活起来了，托尼、凯文、艾伦等老师的理发剪磨刀霍霍，把椅子擦亮，准备各位顾客的到来。</p>
<p><a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem" target="_blank" rel="external">Sleeping barber problem</a>是一个经典的goroutine交互和并发控制的问题，可以很好的用来演示多写多读的并发问题(multiple writers multiple readers)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[经典并发问题: 哲学家就餐问题]]></title>
    <link href="https://colobu.com/2022/02/13/dining-philosophers-problem/"/>
    <id>https://colobu.com/2022/02/13/dining-philosophers-problem/</id>
    <published>2022-02-13T09:25:44.000Z</published>
    <updated>2022-02-24T09:36:34.503Z</updated>
    <content type="html"><![CDATA[<p>哲学家就餐问题是一个非常非常经典的问题，也是一个非常通用的研究并发编程中死锁现象的问题。</p>
<a id="more"></a>
<blockquote>
<p>为什么我们要研究经典的并发问题呢？这些经典问题是对现实中的计算机编程的抽象，代表了非常通用的计算机并发问题，计算机科学家对此进行了深入的研究，也总结出很多行之有效的解决办法。我们通过学习这些经典问题，可以将我们遇到的并发问题做对比，看不看是否是类似的问题，如何是相同的问题，可以使用前人总结的解决方案去解决。同时练习解决这些问题，也可以使我们学习和掌握并发原语和解决问题的技巧，举一反三去解决更多的并发问题。</p>
</blockquote>
<p>在1971年，著名的计算机科学家艾兹格·迪科斯彻(Edsger Dijkstra)提出了一个同步问题，即假设有五台计算机都试图访问五份共享的磁带驱动器。稍后，这个问题被托尼·霍尔(Tony Hoare)重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。</p>
<p>到了中国，哲学家就餐问题可以这样表述，假设因为新冠的原因，五位哲学家被隔离在一个房间里。这五位哲学家分别是孔子、庄子、墨子、孙子和老子，他们围坐在一个圆形的餐桌旁，餐桌上有无尽的可口的饭菜，不幸的是，出于环保的原因，只有五根筷子，每根筷子都位于两位哲学家之间。哲学家吃饭时，必须拿起自己左右两边的两根筷子才能吃饭，吃完饭后才放回筷子，这样其它哲学家可以再拿起筷子。</p>
<p>虽然隔离的日子比较寂寞，但是这些哲学家还是有事情可做，他们不断的冥想或者吃饭。饿了的时候就开始尝试拿起筷子，吃随机时间的饭菜，然后放下筷子开始冥想。冥想一段时间就饿了，又开始吃饭。所以他们总是处于冥想-饿了-吃饭-冥想这样的状态中。</p>
<p><img src="1.png" alt=""></p>
<p>这个哲学家很好的模拟了计算机并发编程中一定数量的资源和一定数量的持有者的并发问题，这类问题很大的一个问题就是死锁问题。</p>
<p>如果五位哲学家同时饿了，同时拿起左手边的那根筷子，你就会发现他们想去拿右边的筷子的时候，都没有办法拿起右边的筷子，因为右边那根筷子都被旁边的哲学家拿走了，所有的哲学家都处于等待状态而没有办法继续下去。对于程序来说，就是程序 hang死了，没有办法继续处理。</p>
<blockquote>
<p>如果这五位哲学家同时发现没有右边的筷子可用，他们同时放下左手的筷子，冥想5分钟再同时就餐，你会发现程序貌似还在进行，但是哲学家依然还是没有办法就餐，这种现象叫做死锁。在分布式一致性算法中在选主的时候也会有类似的现象，有些实现是通过随机休眠一定的时间，避免各个节点同时请求选主来避免。</p>
</blockquote>
<p>如果系统中只有一个线程，当然不会产生死锁。如果每个线程仅需求一种并发资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。如果你搜索Go官方的项目中的issue,可以看到几百个关于死锁的issue,足可以表明死锁是一个常见且并不容易处理的bug。</p>
<p><img src="2.png" alt=""></p>
<p>死锁的四个条件是：</p>
<ul>
<li><p><strong>禁止抢占</strong>（no preemption）：系统资源不能被强制从一个线程中退出。如果哲学家可以抢夺，那么大家都去抢别人的筷子，也会打破死锁的局面，但这是有风险的，因为可能孔子还没吃饭就被老子抢走了。计算机资源如果不是主动释放而是被抢夺有可能出现意想不到的现象。</p>
</li>
<li><p><strong>持有和等待</strong>（hold and wait）：一个线程在等待时持有并发资源。持有并发资源并还等待其它资源，也就是吃着碗里的望着锅里的。</p>
</li>
<li><p><strong>互斥</strong>（mutual exclusion）：资源只能同时分配给一个线程，无法多个线程共享。资源具有排他性，孔子和老子的关系再好，也不允许他们俩一起拿着一根筷同时吃。</p>
</li>
<li><p><strong>循环等待</strong>（circular waiting）：一系列线程互相持有其他进程所需要的资源。必须有一个循环依赖的关系。</p>
</li>
</ul>
<p>死锁只有在四个条件同时满足时发生，预防死锁必须至少破坏其中一项。</p>
<h2 id="模拟哲学家就餐问题">模拟哲学家就餐问题</h2>
<p>首先我们通过程序模拟哲学家就餐问题，看看程序在运行的是不是会产生死锁问题。</p>
<p>首先我们定义筷子对象和哲学家对象。其中筷子是并发资源，具有排他性，所以它包含一个锁，用来实现互斥，并且禁止抢占(其它非持有这根筷子的哲学家不能调用Unlock,只有持有这根筷子的哲学家才能调用Unlock)。</p>
<p>每个哲学家需要左手的筷子和右手的筷子，status代表哲学家的状态(冥想、饿了、就餐中)，他有一种状态就是持有一根筷子并请求另一根筷子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Chopstick 代表筷子.</span></div><div class="line"><span class="keyword">type</span> Chopstick <span class="keyword">struct</span>{ sync.Mutex }</div><div class="line"></div><div class="line"><span class="comment">// Philosopher 代表哲学家.</span></div><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>哲学家在隔离的房间就是不断的冥想、就餐、冥想、就餐...... 永无终日。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 随机暂停一段时</span></div><div class="line"><span class="keyword">func</span> randomPause(max <span class="typename">int</span>) {</div><div class="line">    time.Sleep(time.Millisecond * time.Duration(rand.Intn(max)))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 显示此哲学家的状态</span></div><div class="line"><span class="keyword">func</span> mark(p *Philosopher, action <span class="typename">string</span>) {</div><div class="line">    fmt.Printf(<span class="string">"%s开始%s\n"</span>, p.name, action)</div><div class="line">    p.status = fmt.Sprintf(<span class="string">"%s开始%s\n"</span>, p.name, action)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的mark用来在控制台输出此哲学家的状态，便于我们观察。</p>
<p>最后一步就是实现main函数，分配5根筷子和五个哲学家，让程序运行起来:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="keyword">go</span> http.ListenAndServe(<span class="string">"localhost:8972"</span>, <span class="constant">nil</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 哲学家数量</span></div><div class="line">    count :=<span class="number"> 5</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建5根筷子</span></div><div class="line">    chopsticks := <span class="built_in">make</span>([]*Chopstick, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        chopsticks[i] = <span class="built_in">new</span>(Chopstick)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//</span></div><div class="line">    names := []<span class="typename">string</span>{color.RedString(<span class="string">"孔子"</span>), color.MagentaString(<span class="string">"庄子"</span>), color.CyanString(<span class="string">"墨子"</span>), color.GreenString(<span class="string">"孙子"</span>), color.WhiteString(<span class="string">"老子"</span>)}</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number"> 1</span>)</div><div class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</div><div class="line">    &lt;-sigs</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"退出中... 每个哲学家的状态:"</span>)</div><div class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> philosophers {</div><div class="line">        fmt.Print(p.status)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序你会很快就发现这个程序会hang住，每个哲学家都处于拿到左手筷子等待右手筷子的状态。</p>
<p>在我们实际的应用中，死锁问题并不是这么容易的被发现的，很可能在一些非常特定的场景(也被称之为corner case)才会被触发和发现。</p>
<h2 id="解法一：限制就餐人数">解法一：限制就餐人数</h2>
<p>我们知道，解决死锁的问题就是破坏死锁形成的四个条件之一就可以。一般来说，禁止抢占和互斥是我们必须的条件，所以其它两个条件是我们重点突破的点。</p>
<p>针对哲学家就餐问题，如果我们限制最多允许四位哲学家同时就餐，就可以避免循环依赖的条件，因为依照抽屉原理，总是会有一位哲学家可以拿到两根筷子，所以程序可以运行下去。</p>
<p>针对限制特定数量资源的情况，最好用的并发原语就是信号量(Semaphore)。Go官方提供了一个扩展库，提供了一个Semaphore的实现：<a href="https://pkg.go.dev/golang.org/x/sync/semaphore" target="_blank" rel="external">semaphore/Weighted</a>。</p>
<p>我们把这个信号量初始值设置为4，代表最多允许同时4位哲学家就餐。把这个信号量传给哲学家对象，哲学家想就餐时就请求这个信号量，如果能得到一个许可，就可以就餐，吃完把许可释放回给信号量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line">    <span class="comment">// 信号量</span></div><div class="line">    sema *semaphore.Weighted</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.sema.Acquire(context.Background(),<span class="number"> 1</span>) <span class="comment">// 请求一个许可</span></div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">        p.sema.Release<span class="number">(1</span>) <span class="comment">// 释放许可给信号量</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 最多允许四个哲学家就餐</span></div><div class="line">    sema := semaphore.NewWeighted<span class="number">(4</span>)</div><div class="line">    <span class="comment">//</span></div><div class="line">    names := []<span class="typename">string</span>{color.RedString(<span class="string">"孔子"</span>), color.MagentaString(<span class="string">"庄子"</span>), color.CyanString(<span class="string">"墨子"</span>), color.GreenString(<span class="string">"孙子"</span>), color.WhiteString(<span class="string">"老子"</span>)}</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">            sema: sema,</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以运行这个程序，看看是否程序是否还会被hang住。</p>
<h2 id="解法二：奇偶资源">解法二：奇偶资源</h2>
<p>我们给每一位哲学家编号，从1到5, 如果我们规定奇数号的哲学家首先拿左手边的筷子，再拿右手边的筷子，偶数号的哲学家先拿右手边的筷子，再拿左手边的筷子， 释放筷子的时候按照相反的顺序，这样也可以避免出现循环依赖的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        <span class="keyword">if</span> p.ID<span class="number">%2</span> ==<span class="number"> 1</span> { <span class="comment">// 奇数</span></div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">            mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 再尝试放下左手边的筷子</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 先尝试拿起右手边的筷子</span></div><div class="line">            mark(p, <span class="string">"拿起右手筷子"</span>)</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 先尝试放下左手边的筷子</span></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 再尝试放下右手边的筷子</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">// 创建哲学家, 分配给他们左右手边的叉子，领他们做到圆餐桌上.</span></div><div class="line">    philosophers := <span class="built_in">make</span>([]*Philosopher, count)</div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; count; i++ {</div><div class="line">        philosophers[i] = &Philosopher{</div><div class="line">            ID:   i +<span class="number"> 1</span>,</div><div class="line">            name: names[i], leftChopstick: chopsticks[i], rightChopstick: chopsticks[(i<span class="number">+1</span>)%count],</div><div class="line">        }</div><div class="line">        <span class="keyword">go</span> philosophers[i].dine()</div><div class="line">    }</div><div class="line"></div><div class="line">    ......</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序，你同样也会发现程序可以顺利执行下去，并不会出现死锁的现象。</p>
<h2 id="解法三：资源分级">解法三：资源分级</h2>
<p>另一个简单的解法是为资源（这里是筷子）分配一个偏序或者分级的关系，并约定所有资源都按照这种顺序获取，按相反顺序释放，而且保证不会有两个无关资源同时被同一项工作所需要。在哲学家就餐问题中，筷子按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的筷子，再拿编号较高的。用完筷子后，他总是先放下编号较高的筷子，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的筷子时，只有编号最高的筷子留在桌上，从而第五位哲学家就不能使用任何一只筷子了。而且，只有一位哲学家能使用最高编号的筷子，所以他能使用两只筷子用餐。当他吃完后，他会先放下编号最高的筷子，再放下编号较低的筷子，从而让另一位哲学家拿起后边的这只开始吃东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        <span class="keyword">if</span> p.ID ==<span class="number"> 5</span> { <span class="comment">//</span></div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 先尝试拿起第1只筷子</span></div><div class="line">            mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 再尝试拿起第5只筷子</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 先尝试放下第5只的筷子</span></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 再尝试放下第1只的筷子</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子(第n只)</span></div><div class="line">            mark(p, <span class="string">"拿起右手筷子"</span>)</div><div class="line">            p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子(第n+1只)</span></div><div class="line"></div><div class="line">            mark(p, <span class="string">"用膳"</span>)</div><div class="line">            randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">            p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">            p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="解法四：引入服务生">解法四：引入服务生</h2>
<p>如果我们引入一个服务生，比如韩非子，由韩非子负责分配筷子，这样我们就可以将拿左手筷子和右手筷子看成一个原子操作，要么拿到筷子，要么等待，就可以破坏死锁的第二个条件(持有和等待)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Philosopher <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// 哲学家的名字</span></div><div class="line">    name <span class="typename">string</span></div><div class="line">    <span class="comment">// 左手一只和右手一只筷子</span></div><div class="line">    leftChopstick, rightChopstick *Chopstick</div><div class="line">    status                        <span class="typename">string</span></div><div class="line"></div><div class="line">    mu *sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 无休止的进餐和冥想.</span></div><div class="line"><span class="comment">// 吃完睡(冥想、打坐), 睡完吃.</span></div><div class="line"><span class="comment">// 可以调整吃睡的时间来增加或者减少抢夺叉子的机会.</span></div><div class="line"><span class="keyword">func</span> (p *Philosopher) dine() {</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        mark(p, <span class="string">"冥想"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        mark(p, <span class="string">"饿了"</span>)</div><div class="line">        p.mu.Lock() <span class="comment">// 服务生控制</span></div><div class="line">        p.leftChopstick.Lock() <span class="comment">// 先尝试拿起左手边的筷子</span></div><div class="line">        mark(p, <span class="string">"拿起左手筷子"</span>)</div><div class="line">        p.rightChopstick.Lock() <span class="comment">// 再尝试拿起右手边的筷子</span></div><div class="line">        p.mu.Unlock() </div><div class="line"></div><div class="line">        mark(p, <span class="string">"用膳"</span>)</div><div class="line">        randomPause<span class="number">(10</span>)</div><div class="line"></div><div class="line">        p.rightChopstick.Unlock() <span class="comment">// 先尝试放下右手边的筷子</span></div><div class="line">        p.leftChopstick.Unlock()  <span class="comment">// 再尝试拿起左手边的筷子</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>完整代码可以参考 [dive-to-gosync-workshop(<a href="https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems" target="_blank" rel="external">https://github.com/smallnest/dive-to-gosync-workshop/tree/master/11.classical_problems</a>)</p>
<p>下一篇我们讲解另外一个经典并发问题：一氧化二氢的生成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>哲学家就餐问题是一个非常非常经典的问题，也是一个非常通用的研究并发编程中死锁现象的问题。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyroscope: 一个简单易用的持续剖析平台]]></title>
    <link href="https://colobu.com/2022/01/27/pyroscope-a-continuous-profiling-platform/"/>
    <id>https://colobu.com/2022/01/27/pyroscope-a-continuous-profiling-platform/</id>
    <published>2022-01-27T10:56:27.000Z</published>
    <updated>2022-01-27T11:00:43.197Z</updated>
    <content type="html"><![CDATA[<p>开发人员常常需要跟踪生产环境中的应用程序的性能瓶颈，并试图找出造成瓶颈的根本原因。要做到这一点，他们通常会通过日志来收集这些信息。不幸的是，这种方法可能会很耗时，而且无法提供有关潜在问题的足够详细的信息。</p>
<p>一种现代且更先进的方法是应用和使用profiling技术和工具，突出显示最慢的应用程序代码和消耗大部分资源（如CPU和内存）的方法。持续分析(Continuous profiling)是在生产环境中持续    收集应用程序性能数据，并将这些数据提供给开发人员进行深入分析的过程。</p>
<p>通过，我们通过采集程序的指标，生成一个概要文件(Profile)进行单次的分析。Go语言提供了pprof工具，可以很方便的生成profile文件。你可以通过程序调用<a href="https://pkg.go.dev/runtime/pprof" target="_blank" rel="external">runtime/pprof</a>生成CPU、Heap等概要文件，也可以使用<a href="https://pkg.go.dev/net/http/pprof" target="_blank" rel="external">net/http/pprof</a>集成到web应用程序中，通过go tool pprof工具在命令行或者web页面中进行分析。</p>
<p>有时候，我们不能及时的进行pprof分析，故障可能消失了或者程序已经crash了。另外我们可能需要不同时段的profile进行对比，进行比较才能发现问题，比如内存泄露的问题。这个时候持续分析(continuous profiling)就很重要了。很多云服务厂商都提供持续分析的功能，比如<a href="https://www.datadoghq.com/dg/apm/ts/profiler/go-continuous-profiler-ts/?utm_source=advertisement&amp;utm_medium=search&amp;utm_campaign=dg-google-profiler-emea-goprofiling-tshirt&amp;utm_keyword=%2Bgo %2Bprofiling&amp;utm_matchtype=b&amp;utm_campaignid=15426873343&amp;utm_adgroupid=128217964697&amp;gclid=Cj0KCQiA_8OPBhDtARIsAKQu0gYymyElbglw_I7uZJkZ7ynxfzn1nVojVZJ9rkm_6_hbchG09w4CCmEaAkWfEALw_wcB" target="_blank" rel="external">Go Continuous Profiler | Datadog</a>、<a href="https://cloud.google.com/profiler/docs" target="_blank" rel="external">Cloud Profiler | Google Cloud</a>、<a href="https://aws.amazon.com/cn/codeguru/features/" target="_blank" rel="external">Amazon CodeGuru Profiler</a>等。</p>
<a id="more"></a>
<h2 id="Pyroscope简介">Pyroscope简介</h2>
<p>如果你想在自己的生产系统中使用持续分析，可以考虑<a href="https://pyroscope.io/" target="_blank" rel="external">Pyroscope</a>。</p>
<p>Pyroscope是一个开源的持续分析系统，使用Go语言实现。服务端使用web页面查看，提供丰富的分析的功能，客户端提供Go、Java、Python、Ruby、PHP、.NET等多种语言的支持，并且支持PUSH、PULL两种采集方式。</p>
<p><img src="0.svg" alt="deployment diagram"></p>
<p>首先，你需要部署一个Pyroscope server，它底层采用BadgerDB作为存储引擎，对profile数据进行了优化处理。</p>
<p>Pyroscope server负责接收(或者拉取，下面我们主要演示推的方式)agent上传的profile数据，并提供时间线界面，可以查看一段时间以内的profile数据。比如下图演示了一个<a href="https://rpcx.io" target="_blank" rel="external">rpcx</a>微服务程序12个小时的profile数据。</p>
<p><img src="1.png" alt="image-20220127133952215"></p>
<p>它既可以显示这一段时间内的火焰图，也可以显示排序表格展示，或者同时显示。这个火焰图可以看出耗时主要在微服务的方法调用和编解码上(除了Go运行时调度)。</p>
<p>你还可以选取不同的时间段进行比较, 左右的图形的时间只需在时间线上拖拽选取即可。</p>
<p><img src="2.png" alt="image-20220127134555179"></p>
<p>还可以进行diff查看，这个常常用在内存泄露的分析上。</p>
<p><img src="3.png" alt="image-20220127135630155"></p>
<h2 id="Pyroscope_server安装">Pyroscope server安装</h2>
<p>Pyroscope server端可以通过docker安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it -p <span class="number">4040</span>:<span class="number">4040</span> pyroscope/pyroscope:latest server</div></pre></td></tr></table></figure>

<p>也可以在各中操作系统中直接安装。</p>
<p>比如Mac:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install pyroscope-io/brew/pyroscope</div><div class="line">brew services start pyroscope-server</div></pre></td></tr></table></figure>

<p>各Liunx发行版也方便安装，比如Cebtos:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://dl.pyroscope.io/release/pyroscope-<span class="number">0.8</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.rpm</div><div class="line"><span class="built_in">sudo</span> yum localinstall pyroscope-<span class="number">0.8</span>.<span class="number">0</span>-<span class="number">1</span>-x86_64.rpm</div><div class="line"><span class="built_in">sudo</span> systemctl start pyroscope-server</div><div class="line"><span class="built_in">sudo</span> systemctl enable pyroscope-server</div></pre></td></tr></table></figure>

<p>比如ubuntu:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://dl.pyroscope.io/release/pyroscope_0.<span class="number">8.0</span>_amd64.deb</div><div class="line"><span class="built_in">sudo</span> apt-get install ./pyroscope_0.<span class="number">8.0</span>_amd64.deb</div></pre></td></tr></table></figure>

<p>安装完成后，就可以通过web界面访问了: <a href="http://localhost:4040" target="_blank" rel="external">http://localhost:4040</a>, 你可以通过配置文件更改监听端口以及其它一些配置项。</p>
<h2 id="客户端集成">客户端集成</h2>
<p>上面已经提到，Pyroscope提供了好几种语言的agent sdk, 我们以Go  Push方式为例。在你需要持续分析的应用程序的开始加入agent的配置:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">pyroscope.Start(pyroscope.Config{</div><div class="line">    ApplicationName: <span class="string">"simple.golang.app"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// replace this with the address of pyroscope server</span></div><div class="line">    ServerAddress:   <span class="string">"http://pyroscope-server:4040"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// you can disable logging by setting this to nil</span></div><div class="line">    Logger:          pyroscope.StandardLogger,</div><div class="line"></div><div class="line">    <span class="comment">// by default all profilers are enabled,</span></div><div class="line">    <span class="comment">// but you can select the ones you want to use:</span></div><div class="line">    ProfileTypes: []pyroscope.ProfileType{</div><div class="line">      pyroscope.ProfileCPU,</div><div class="line">      pyroscope.ProfileAllocObjects,</div><div class="line">      pyroscope.ProfileAllocSpace,</div><div class="line">      pyroscope.ProfileInuseObjects,</div><div class="line">      pyroscope.ProfileInuseSpace,</div><div class="line">    },</div><div class="line">  })</div></pre></td></tr></table></figure>

<p>主要配置ApplicationName的名称，这个名称会显示在Pyroscope的服务端下拉框中。profile数据要发送到哪一个Pyroscope服务器上，你可以配置ServerAddress,以及通过ProfileTypes监控要监控的Profile项。</p>
<p>只需加上这几行启动程序后，你就可以在Pyroscope server的web界面上查看持续分析的数据了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开发人员常常需要跟踪生产环境中的应用程序的性能瓶颈，并试图找出造成瓶颈的根本原因。要做到这一点，他们通常会通过日志来收集这些信息。不幸的是，这种方法可能会很耗时，而且无法提供有关潜在问题的足够详细的信息。</p>
<p>一种现代且更先进的方法是应用和使用profiling技术和工具，突出显示最慢的应用程序代码和消耗大部分资源（如CPU和内存）的方法。持续分析(Continuous profiling)是在生产环境中持续    收集应用程序性能数据，并将这些数据提供给开发人员进行深入分析的过程。</p>
<p>通过，我们通过采集程序的指标，生成一个概要文件(Profile)进行单次的分析。Go语言提供了pprof工具，可以很方便的生成profile文件。你可以通过程序调用<a href="https://pkg.go.dev/runtime/pprof" target="_blank" rel="external">runtime/pprof</a>生成CPU、Heap等概要文件，也可以使用<a href="https://pkg.go.dev/net/http/pprof" target="_blank" rel="external">net/http/pprof</a>集成到web应用程序中，通过go tool pprof工具在命令行或者web页面中进行分析。</p>
<p>有时候，我们不能及时的进行pprof分析，故障可能消失了或者程序已经crash了。另外我们可能需要不同时段的profile进行对比，进行比较才能发现问题，比如内存泄露的问题。这个时候持续分析(continuous profiling)就很重要了。很多云服务厂商都提供持续分析的功能，比如<a href="https://www.datadoghq.com/dg/apm/ts/profiler/go-continuous-profiler-ts/?utm_source=advertisement&amp;utm_medium=search&amp;utm_campaign=dg-google-profiler-emea-goprofiling-tshirt&amp;utm_keyword=%2Bgo %2Bprofiling&amp;utm_matchtype=b&amp;utm_campaignid=15426873343&amp;utm_adgroupid=128217964697&amp;gclid=Cj0KCQiA_8OPBhDtARIsAKQu0gYymyElbglw_I7uZJkZ7ynxfzn1nVojVZJ9rkm_6_hbchG09w4CCmEaAkWfEALw_wcB" target="_blank" rel="external">Go Continuous Profiler | Datadog</a>、<a href="https://cloud.google.com/profiler/docs" target="_blank" rel="external">Cloud Profiler | Google Cloud</a>、<a href="https://aws.amazon.com/cn/codeguru/features/" target="_blank" rel="external">Amazon CodeGuru Profiler</a>等。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试官提问三个Go接口的概念， 10年gopher竟无言以对]]></title>
    <link href="https://colobu.com/2022/01/16/three-new-concepts-of-go-interface-since-1-18/"/>
    <id>https://colobu.com/2022/01/16/three-new-concepts-of-go-interface-since-1-18/</id>
    <published>2022-01-16T11:44:58.000Z</published>
    <updated>2022-01-16T14:00:52.957Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.18后， Go的interface的含义有所<a href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/" target="_blank" rel="external">变化</a>, 三个新的和Go接口有关的概念很多人还不知道: <code>type set</code>(类型集合)、<code>specific type</code>(特定类型)和<code>structural type</code>(结构类型)。</p>
<a id="more"></a>
<h2 id="type_set_(类型集合)">type set (类型集合)</h2>
<p>type set称之为类型集合，一些关注Go泛型的朋友其实也对此有些了解，它是Go 1.18新增加的一个概念。</p>
<p>Go 1.18之前，Go的接口代表了一组方法的集合(method set),凡是实现了这些方法集合的类型，都被称之为实现了这个接口。Go不像Java语言，需要显示地定义某个类实现某个接口，Go不需要这样，在Go中，只要一个类型实现了某个接口定义的所有方法，它就实现了这个接口，可以赋值给这个接口类型的变量，或者作为这个接口类型的方法的实参或者返回值，这种设计有时候也被叫做<code>鸭子类型</code>(duck typing)。只要它走起来像鸭子，叫起来像鸭子，那么它就是鸭子，这是一个很经典的对鸭子类型的描述。</p>
<p>在Go 1.18中，接口不再代表方法的集合了，而是代表类型的集合(type set)。只要某种类型在这个接口的类型集合中，那么我们就说这种类型实现了这个接口。如果这个接口被用作类型约束，那么在这个接口定义的类型集合中的任意一个元素，都可以实例化这个类型参数。</p>
<p>所以，实际上，为了支持接口作为类型约束的扩展，Go语言规范不得不重新定义接口的含义了，这也是类型集合出现的原因。</p>
<p>其实，接口的方法集的概念还在 一个接口的方法集是这个接口的类型集合中所有元素的方法集的<strong>交集</strong>。</p>
<p>r本文假定你对Go泛型有了一定的了解。假定你还不了解，那么你必须知道，Go 1.18中接口除了原先的方法元素还，还支持包含类型元素，类型元素可以是某个类型<code>T</code>、或者是近似类型<code>~T</code>,或者是它们的联合<code>int|int8|int16|int32|int64|~string</code>。</p>
<p>如果一个接口<code>I</code>嵌入了另外一个接口<code>E</code>,那么<code>I</code>的类型集是它显示定义的类型集合和嵌入的接口<code>E</code>的类型集合的交集。相当于<code>E</code>把接口<code>I</code>的类型集收窄了。</p>
<p>如何判断一个接口的类型集呢？请遵循下面的原则:</p>
<ul>
<li><p>空接口<code>any</code>、<code>interface{}</code>的类型集是所有类型的集合<br>所以像<code>int</code>、<code>string</code>、<code>strcut{}</code>、<code>MyStruct</code>、<code>func foobar()</code>、<code>chan int</code>、<code>map[int]string</code>、<code>[]int</code>等等都在空接口的类型集合中</p>
</li>
<li><p>非空接口的类型集合是接口元素的类型集合的交集<br>那么什么是接口元素的类型集合呢？参照下面的四条。<br>前面我们已经提到，接口元素包含类型元素和方法元素。</p>
<ul>
<li><p>一个方法的类型集合是定义这个方法的所有类型，也就是只要某个类型的方法集包含这个方法，那么它就属于这个方法的类型集合<br>比如接口中有<code>String() string</code>这样一个方法，那么所有实现这个方法的类型都属于<code>String() string</code>定义的类型集合，比如<code>net.IP</code>。</p>
</li>
<li><p>一个非接口类型的类型集合就是只包含这个类型的类型集合<br>比如<code>int</code>的类型集合只包含<code>int</code>这样一个元素。</p>
</li>
<li><p>近似元素<code>~T</code>的类型集合是所有底层类型为<code>T</code>的所有类型的集合</p>
</li>
</ul>
<p>比如<code>type MyInt int</code>中的<code>MyInt</code>就属于<code>~int</code>的类型集合</p>
<ul>
<li>联合元素<code>t1|t2|…|tn</code>的类型集合是这些联合元素类型集合的<strong>并集</strong></li>
</ul>
</li>
</ul>
<p>下面的例子列举了一些类型的集合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个集合的类型集合只有int这一种类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口代表所有底层为int类型的所有类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口代表底层为int，并且实现了String方法的所有类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">	String() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这个接口的类型集合是空集，因为不可能一个元素既是int又是string类型</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">	<span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Floats代表所有底层是浮点数的类型 (底层为float32或者float64)</span></div><div class="line"><span class="keyword">type</span> Floats <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">float32</span> | ~<span class="typename">float64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="specific_type_(特定类型)_和_specific_type_set">specific type (特定类型) 和 specific type set</h2>
<p>接口另外一个很重要的概念就是<code>specific type</code> (特定类型)。</p>
<p>只有包含类型元素的接口才定义了特定类型(可能是空的类型)。</p>
<p>如果不严格的讲，特定类型是出现在类型元素中定义的那些类型<code>T</code>、<code>~T</code>、<code>t1|t2|...|tn</code>中的<code>t1</code>、<code>t2</code>、<code>...</code>、<code>tn</code>。</p>
<p>更准确地说，对于给定的接口<code>I</code>，特定类型的集合对应于该接口代表的类型集合<strong>𝑅</strong>，这里要求<strong>𝑅</strong>是非空且有限的。否则，如果<strong>𝑅</strong>为空或无限，则接口没有特定类型。</p>
<p>对于一个给定的接口、类型元素或者类型，它代表的类型集合<strong>𝑅</strong>定义如下：</p>
<ul>
<li><p>对于一个没有任何类型元素的接口，它的<strong>𝑅</strong>是所有的元素(无限)。<br>所以它没有特定类型。</p>
</li>
<li><p>如果一个接口有类型元素，它的<strong>𝑅</strong>是它的元素代表的类型的交集<br>至于有没有特定类型要看<strong>𝑅</strong>是否是非空且有限。</p>
</li>
<li><p>对于一个非接口类型<code>T</code>,或者<code>~T</code>, 它的<strong>𝑅</strong>是包含类型<code>T</code>的集合</p>
</li>
<li><p>对于联合元素<code>t1|t2|…|tn</code>, 它的<strong>𝑅</strong>是这些项代表类型的<strong>并集</strong></p>
</li>
</ul>
<p>下面是特定类型的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Celsius <span class="typename">float32</span></div><div class="line"><span class="keyword">type</span> Kelvin  <span class="typename">float32</span></div><div class="line"></div><div class="line"><span class="keyword">interface</span>{}                    <span class="comment">// 无限，所以没有特定类型</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span> }               <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="typename">string</span> }           <span class="comment">// 特定类型是string</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>|~<span class="typename">string</span> }       <span class="comment">// 特定类型是int, string</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|Kelvin }    <span class="comment">// 特定类型是Celsius, Kelvin</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">float64</span>|any }       <span class="comment">// 没有特定类型，因为联合类型的代表类型是无限的</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; m() }          <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="typename">int</span>; m() }         <span class="comment">// 特定类型是int</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; any }          <span class="comment">// 特定类型是int，int和any的交集</span></div><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span>; <span class="typename">string</span> }       <span class="comment">// 没有特定类型</span></div></pre></td></tr></table></figure>

<h2 id="type_set_vs_specific_type_set">type set vs specific type set</h2>
<p>类型集合和特定类型集合还是有区别的，从上面它们的定义可以看出来。</p>
<p><strong>一个接口即使类型为空，它的特定类型集合可能不为空。</strong><br>比如<code>interface{ int; m() }</code>,它的类型集合是空的(int没有实现m方法)，但是它的特定类型是<code>int</code>。</p>
<p><strong>一个接口即使有有限的特定类型，它的类型集合也可能是无限的</strong><br>比如<code>interface{ ~int; m() }</code>,它的特定类型是int，但是它的类型集合确是无限的(任何底层为int并且实现了方法m的类型都属于它的类型集合)</p>
<p>那么定义特定类型有什么用呢？</p>
<h2 id="特定类型的应用">特定类型的应用</h2>
<p>特定类型主要用于判断类型参数是否支持索引, 像<code>a[x]</code>这样的类型。</p>
<p>比如一个表达式<code>a[x]</code>, <code>a</code>这个实例的类型可能是数组、指向数组的指针、slice、字符串、map。</p>
<p>如果<code>a</code>的类型是类型参数<code>P</code>的话，那么我们的代码<code>a[x]</code>在什么条件下才不会编译出错？</p>
<p>要求的条件就和特定类型有关了：</p>
<ul>
<li>P必须有特定类型</li>
<li>对于P的特定类型的值a，支持<code>a[x]</code>这种索引写法</li>
<li>P的所有特定类型必须相同。在这里，string类型的元素类型是byte (<a href="https://github.com/golang/go/issues/49551" target="_blank" rel="external">https://github.com/golang/go/issues/49551</a>)</li>
<li>如果P的特定类型包含map类型的话，那么它的所有特定类型必须是map,而且所有的key的类型是相同的<br>所以有时候你定义了一个包含map、slice、string的联合元素接口的话，这个接口的实例你不能使用<code>a[x]</code>索引类型，元素的类型都是int</li>
<li><code>a[x]</code>是数组、slice、string的索引为x的元素，或者是map类型key为x的元素，a[x]的类型必须相同</li>
<li>如果P的特定类型包含string类型，那么不能给<code>a[x]</code>赋值(字符串是不可变的)</li>
</ul>
<p>特定类型还用作类型转化定义上。<br>对于一个变量<code>x</code>,如果它的类型是<code>V</code>, 要转换成的类型是<code>T</code>, 只要满足下面一条，x就可以转换成<code>T</code>类型:</p>
<ul>
<li><code>V</code>的每一个特定类型的值都可以转换成<code>T</code>的每一个特定类型</li>
<li>只有<code>V</code>是类型参数，<code>T</code>不是，那么<code>V</code>的每一个特定类型的值都可以转换成<code>T</code></li>
<li>只有<code>T</code>是类型参数，<code>x</code>可以转换成T的每一个特定类型</li>
</ul>
<p>一句话，是类型参数就满足每一个特定类型，不是类型参数就满足这个类型。</p>
<p>另外，对于类型参数，要调用内建的函数<code>len</code>、<code>cap</code>，必须要求它们的特定类型允许使用这些内建函数。</p>
<h2 id="structural_type_(结构类型)">structural type (结构类型)</h2>
<p>一个接口<code>T</code>要被成为结构化的(<code>structural</code>),需要满足下面的条件之一:</p>
<ol>
<li>存在一个单一的类型<code>U</code>,它是<code>T</code>的类型集合中的每一个元素相同的底层类型</li>
<li><code>T</code>的类型集合只包含chan类型，并且它们的元素类型都是<code>E</code>, 所有的chan的方向包含相同的方向(不一定要求完全相同)</li>
</ol>
<p>结构化类型包含一个结构类型，根据上面的条件不同，结构类型可能是:</p>
<ol>
<li>类型<code>U</code>, 或者</li>
<li>如果<code>T</code>只包含双向chan的话，结构类型为<code>chan E</code>,否则可能是<code>chan&lt;- E</code>或者<code>&lt;-chan E</code></li>
</ol>
<p>下面是包含结构类型的结构化接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span>{ <span class="typename">int</span> }                          <span class="comment">// 结构类型为 int</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|Kelvin }               <span class="comment">// 结构类型为 float32</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="keyword">chan</span> <span class="typename">int</span> }                    <span class="comment">// 结构类型为 chan int</span></div><div class="line"><span class="keyword">interface</span>{ ~<span class="keyword">chan</span> <span class="typename">int</span>|~<span class="keyword">chan</span>&lt;- <span class="typename">int</span> }        <span class="comment">// 结构类型为 chan&lt;- int</span></div><div class="line"><span class="keyword">interface</span>{ ~[]*data; String() <span class="typename">string</span> }    <span class="comment">// 结构类型为 *data</span></div><div class="line"></div><div class="line"><span class="comment">// 下面的例子不包含结构类型，所以是非结构化接口</span></div><div class="line"><span class="keyword">interface</span>{}                               <span class="comment">// 没有固定单一的底层类型</span></div><div class="line"><span class="keyword">interface</span>{ Celsius|<span class="typename">float64</span> }              <span class="comment">// 底层类型不相同</span></div><div class="line"><span class="keyword">interface</span>{ <span class="keyword">chan</span> <span class="typename">int</span> | <span class="keyword">chan</span>&lt;- <span class="typename">string</span> }     <span class="comment">// channel的元素类型不相同</span></div><div class="line"><span class="keyword">interface</span>{ &lt;-<span class="keyword">chan</span> <span class="typename">int</span> | <span class="keyword">chan</span>&lt;- <span class="typename">int</span> }      <span class="comment">// channel没有相同的方向</span></div></pre></td></tr></table></figure>

<p>在Go语言规范中，并没有对结构化接口有更多的介绍，如何使用，更多是是它内部获取底层的结构类型，以及做类型检查，比如下面的例子就会报<code>no structural type</code>编译错误:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> myByte1 []<span class="typename">byte</span></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | []<span class="typename">int</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j:k] <span class="comment">// 底层类型不一致</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | []<span class="typename">int</span> | <span class="typename">string</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j] </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面这个函数没问题，因为string的底层页被看做[]byte</span></div><div class="line"><span class="keyword">func</span> _[T <span class="keyword">interface</span>{ []<span class="typename">byte</span> | myByte1 | myByte2 | <span class="typename">string</span> }] (x T, i, j, k <span class="typename">int</span>) { </div><div class="line">    <span class="keyword">var</span> _ T = x[i:j] </div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面的代码也会报<code>M has no structural type</code>编译错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> multiMapOfInt <span class="keyword">interface</span> {</div><div class="line">	<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">float64</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span> | <span class="keyword">map</span>[<span class="typename">complex64</span>]<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> arraySummer[M multiMapOfInt](mp M) (sum <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> mp {</div><div class="line">		sum += v</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如下面大家使用Go泛型的时候常会犯的错误,虽然<code>[]byte</code>、<code>map[int]byte</code>、<code>string</code>都能range,而且key(index)、value类型都一样，但是也会报<code>R has no structural type</code>错误:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> rangeType <span class="keyword">interface</span> {</div><div class="line">	[]<span class="typename">byte</span> | <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">byte</span> | <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> rangeIt[R rangeType](r R) {</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> r {</div><div class="line">		fmt.Println(i, v)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	rangeIt(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">byte</span><span class="number">{1</span>:<span class="number"> 1</span>,<span class="number"> 2</span>:<span class="number"> 2</span>,<span class="number"> 3</span>:<span class="number"> 3</span>})</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.18后， Go的interface的含义有所<a href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/" target="_blank" rel="external">变化</a>, 三个新的和Go接口有关的概念很多人还不知道: <code>type set</code>(类型集合)、<code>specific type</code>(特定类型)和<code>structural type</code>(结构类型)。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写可维护的Go代码]]></title>
    <link href="https://colobu.com/2022/01/15/Writing-maintainable-Go-code/"/>
    <id>https://colobu.com/2022/01/15/Writing-maintainable-Go-code/</id>
    <published>2022-01-15T04:54:58.000Z</published>
    <updated>2022-02-24T09:36:34.503Z</updated>
    <content type="html"><![CDATA[<p>编写可维护的代码是最基本的要求。清晰度、可读性和简单性都是保持代码可维护性的各个方面。它应该使某人加入您的项目或在有人离开后维护代码的过程变得容易。可维护性的衡量指标是代码更改的容易程度以及与这些更改引起的风险性。为了有效地编写Go程序，了解Go语言的属性和地道写法，并使用与命名、程序构建、格式等相关既定约定是至关重要。</p>
<p>以下是一些有助于编写可维护的Go代码的良好实践。</p>
<p>原文: <a href="https://jogendra.dev/writing-maintainable-go-code" target="_blank" rel="external">Writing maintainable Go code</a> by Jogendra.</p>
<a id="more"></a>
<p>保持小巧的<code>main</code>函数</p>
<p>&quot;<a href="https://go.dev/tour/basics/1" target="_blank" rel="external">Go之旅</a>&quot;中讲到：</p>
<blockquote>
<p>每个 Go 程序都由包组成。程序在包 <code>main</code> 中开会运行。</p>
</blockquote>
<p>包<strong>main</strong>是唯一的，那些导出名称(<code>exported name</code>)既不会导出，编译器也不会将其视为常规包; 相反，它将其编译为可执行程序。在包<strong>main</strong>中，<strong>main</strong>函数必须存在，它是 Go 程序的入口点。对软件包<code>main</code>和函数<code>main</code>的期望是它们尽可能少。</p>
<p><strong>main.main</strong>是单例的，仅被调用一次。你为它内部的代码编写测试也很困难，因此，强烈建议使用<em>main.main</em>仅仅启动程序，但不要在此包中编写业务逻辑。将启动程序和业务逻辑分别写在单独的包中可改进程序的结构和可维护性。</p>
<h2 id="使用有意义的名称">使用有意义的名称</h2>
<p>在 Go 中命名主要强调一致、简短和准确的名称，因为它们往往会提高代码的可读性。</p>
<p>Russ Cox的命名<a href="https://research.swtch.com/names" target="_blank" rel="external">理念</a>：</p>
<blockquote>
<p>一个名称的长度不应超过它的信息内容。对于一个局部变量，名称<code>i</code>和<code>index</code>或者<code>idx</code>携带同样的信息，而且更方便快速阅读。类似地，<code>i</code>和<code>j</code>这一对命名比索引变量<code>i1</code>和<code>i2</code>更好(更差的是<code>index1</code>和<code>index2</code>),在阅读代码的时候它们更容易区分。全局名称必须传达相对更多的信息，因为它们出现在更广泛的上下文中。即便如此，一个简短、准确的名字比冗长的名字更能说明问题：比较<a href="http://www.google.com/codesearch?q=acquire" target="_blank" rel="external"><code>acquire</code></a>和<a href="http://www.google.com/codesearch?q=take_?ownership" target="_blank" rel="external"><code>take_ownership</code></a>。让每个命名都能<a href="http://www.bartleby.com/141/strunk5.html#13" target="_blank" rel="external">区分</a>。</p>
</blockquote>
<p>Ken Thompson，Rob Pike，Robert Griesemer，Russ Cox，Ian Lance Taylor等人多年的编程经验和命名理念很可能激发了Go中的命名约定。<a href="https://talks.golang.org/2014/names.slide" target="_blank" rel="external">这是</a>安德鲁·格兰德（Andrew Gerrand）的一张幻灯片，其更深入地讨论了Go中的命名。</p>
<h2 id="代码分组">代码分组</h2>
<p>在函数（或方法）中，某些语句可能有关联。因此，建议将这些语句保留在单独的代码块中，用换行符分隔。分组使程序构造更好，并通过分隔相关部分来提高可读性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Creating new HTTP request with request body</span></div><div class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"https://api.example.com/endpoint"</span>, body)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// handle err</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Setting headers to HTTP request</span></div><div class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">req.Header.Set(<span class="string">"Authorization"</span>, <span class="string">"Bearer b7d03a6947b217efb6f3ec3bd3504582"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Executing the request</span></div><div class="line">resp, err := http.DefaultClient.Do(req)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// handle err</span></div><div class="line">}</div><div class="line"><span class="keyword">defer</span> resp.Body.Close()</div></pre></td></tr></table></figure>

<h2 id="撰写有意义的注释">撰写有意义的注释</h2>
<p>注释是理解现有代码的绝佳方式，它可以回答这段代码的作用，为什么会存在某些代码段以及为什么它是这样编写的。最好在编写代码时就编写注释，但更重要的是在更新代码时更新注释。代码更新可能会改变特定代码的实现目的，因此更新注释也至关重要的; 否则，它将造成困惑而不是在以后有所帮助。与其编写与代码相矛盾的注释还不如不写代码注释。您可以在 Go 中编写块注释或内联注释，你可以选择任何更适合您的代码的内容。</p>
<p>您使用该工具做检查在 Go 中你是否正确编写注释代码。<a href="https://blog.golang.org/godoc" target="_blank" rel="external">godoc</a>将从您的代码中提取注释，并为您的 Go 程序生成文档。Go 中的注释有几个不错的功能，请参阅<a href="https://blog.jbowen.dev/2019/09/the-magic-of-go-comments/" target="_blank" rel="external">Go代码注释的魔法</a>以详细了解。<code></code></p>
<p>知道不必写注释与知道应该写注释一样重要。最好避免过度注释代码，并将其留给其他程序员来理解Go。您应该避显而易见的注释，如果代码的可读性足够高，则不需要注释。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get country code from customer address.</span></div><div class="line">    countryCode := getCountryCode(address)</div><div class="line"></div><div class="line">    <span class="comment">// If country code is "IN", assign "India" as</span></div><div class="line">    <span class="comment">// country.</span></div><div class="line">    <span class="keyword">if</span> countryCode == <span class="string">"IN"</span> {</div><div class="line">        country = <span class="string">"India"</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里写的注释没啥意义，不会增加任何价值。</p>
<h2 id="不要重复">不要重复</h2>
<p>DRY（不要重复自己）是软件开发的一个原则，旨在减少软件模式的重复，用抽象代替它以避免冗余。</p>
<p>那么，代码重复又有什么问题呢？在有变更之前，没有太多问题。想象一下，在10个地方重复相同的代码，每当有小的变化时都要在所有10个地方做改变。如果代码仅存在于一个位置，则更容易维护代码，从而确保一致性。如果代码重复，您很有可能忘记更新其中一个副本，这意味着您在一个副本中修复的错误仍将存在于另一个副本中。</p>
<p>如果必须再次编写相同的代码，可以其移动到大多数<code>helper</code>函数所在的共享package中。通过删除重复的代码，您将拥有更少的代码，这些代码将更清晰，更易于维护。</p>
<p>缺少泛型（Go 1.17以及先前版本）可能会使 Go 代码在某些地方看起来重复。但是，随着Go 1.18正式支持泛型，将使编写通用代码变得更加简单，冗余更少，并且更易于维护。</p>
<p>但是，有时重复代码比试图强制抽象以免冗余会更简单，更容易理解。因此，更重要的是要知道在哪里应用 DRY，在哪里不应用 DRY，因为代码的可读性和易懂性胜过其他问题。</p>
<h2 id="Linting和样式指南">Linting和样式指南</h2>
<p>遵守编码标准使代码库保持一致，易于代码审查和维护。它使编码风格一致。通常，风格指南是有争议的，为了让人们遵守相同指南的最佳方法是为Go代码创建一个标准的风格指南。拥有风格指南不是最重要的，最重要的是让你的团队真正地使用它。市面上有许多开源的 linting 工具和样式指南，你可以从以此为基础并对其进行修改，使其适合你。</p>
<p>Go有一个在社区中普遍使用和接受的代码格式标准，尽管它不需要特殊的规则。Go 提供了这个<code>fmt</code>工具，鼓励和保护 Go 代码使用既定约定进行格式化。</p>
<p>许多编辑器支持在保存文件时调用文件格式化工具。或者，像 <a href="https://github.com/mvdan/gofumpt" target="_blank" rel="external">gofumpt</a>工具，提供更严格的格式化版本。该工具是 <code>gofmt</code>的修改分支，可用作<code>gofmt</code>原地替换。此外，这些工具还支持自定义源代码转换和添加自定义的规则。</p>
<p>如果您想遵循Go的社区风格指南，可以使用<a href="https://github.com/golang/lint" target="_blank" rel="external">golint</a>。该工具提供了有关代码样式的有用提示，还可以帮助查看Go的公认约定。这将极大地帮助加入项目的每个新开发人员。</p>
<h2 id="避免深度嵌套">避免深度嵌套</h2>
<p>过度的嵌套困扰着每个人。深度嵌套使得代码很难遵循设计逻辑。如果您正在执行代码审查或重新访问旧代码，具有大量嵌套的超大函数（或方法）会造成逻辑的混乱。此外，嵌套代码难以阅读; 嵌套越小，读者的认知负荷就越小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition1 {</div><div class="line">    <span class="keyword">if</span> condition2 {</div><div class="line">        <span class="keyword">if</span> condition3 {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> condition5 {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>开发人员可以通过多种方式避免这种情况。<a href="https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting" target="_blank" rel="external">这里是</a>一个很好的阅读材料。</p>
<h2 id="编写更好的函数">编写更好的函数</h2>
<p>避免编写较长的函数;函数越小越好。较长的函数可能难以读取、测试和维护。较长的函数通常具有较大的职责，因此建议将它们分解为较小的函数。通过分解较长的函数创建的较短的函数，可以服务更多的调用方。因为它们可以提供可管理的独立任务。</p>
<p>Unix管道的发明者、Unix的创始人之一道格·麦克罗伊（Doug McIlroy）说（Unix Philosophy）：</p>
<blockquote>
<p>让每个程序都做好一件事。要完成一项新工作，请重新构建，而不是通过添加新功能使旧程序复杂化。</p>
</blockquote>
<p>因此，分解函数以做好一件事确实与Unix哲学英雄相惜。</p>
<p>如前所述，命名对于可读性至关重要。好的函数名称比注释更好，它们与编写良好的注释或 API 文档一样有助于理解代码。尽量保留较少的功能参数。</p>
<h2 id="避免包(package)级别状态">避免包(package)级别状态</h2>
<p>在 Go 中，对于任何给定的导入路径，包的实例都是唯一一个(单例)。这意味着在包级别上，任何变量只有一个实例。包级别的变量在全局级别共享，这意味着所有访问者将共享同一个实例。函数<code>X</code>可以修改变量，函数<code>Y</code>可以读取修改后的值。</p>
<p>使用包级别的变量可能会产生许多影响：</p>
<ol>
<li>很难跟踪变量的修改位置以及跟踪访问变量的位置以做出任何决定。</li>
<li>包级变量导致紧密耦合; 一个角落的代码修改可能需要修改代码的另一个角落，这使得阅读、修改和单元测试代码变得更加困难。</li>
<li>它可能会导致争用条件等问题。</li>
</ol>
<p>但是，包级别常量的使用非常有用。因此，始终建议尽可能避免使用包级别状态(译者注: 可修改的变量)。若要减少耦合，请将相关变量移到所需的结构体的字段上。在结构体中定义依赖项和配置使其变得容易。接口的使用也非常有帮助。</p>
<h2 id="尽早返回并明智地使用条件">尽早返回并明智地使用条件</h2>
<p>条件语句是我们必须经常写的东西。它在代码是干净还是混乱方面发挥着重要作用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此代码的问题在于<code>else</code>语句在此处没有帮助;相反，它使代码变得混乱且可读性降低。相反，把它写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>译者注， 把它写成下面的方式更简洁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">return</span> n &lt;=<span class="number"> 12</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也经常会看到整个函数体都包在<code>if</code>语句里面,这也是不好的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) {</div><div class="line">    <span class="keyword">if</span> n &gt;<span class="number"> 12</span> {</div><div class="line">        sum()</div><div class="line">        subtract()</div><div class="line">        multiply()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以翻转判断条件使代码更简洁可读:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> do(n <span class="typename">int</span>) {</div><div class="line">    <span class="keyword">if</span> n &lt;=<span class="number"> 12</span> {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    sum()</div><div class="line">    subtract()</div><div class="line">    multiply()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="更经常的使用switch">更经常的使用<code>switch</code></h2>
<p><strong>switch</strong>语句是缩短 if-else 语句序列的最佳方式，有益于编写干净的程序。程序经常需要做比较判断，如果我们的程序使用了太多的<code>if-else</code>，会使代码凌乱且可读性较差。所以使用switch有很大帮助。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> transact(bank <span class="typename">string</span>) {</div><div class="line">    <span class="keyword">if</span> bank == <span class="string">"Citi"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #1: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"StandardChartered"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #2: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"HSBC"</span> || bank == <span class="string">"Deutsche"</span> || bank == <span class="string">"JPMorgan"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #3: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> bank == <span class="string">"NatWest"</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #4: %s\n"</span>, bank)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        fmt.Printf(<span class="string">"Tx #E: %s\n"</span>, bank)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这看起来很乱，对吧？现在让我们改用一个switch。以下代码如何以惯用方式重写相同的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> transact(bank <span class="typename">string</span>) {</div><div class="line">    <span class="keyword">switch</span> bank {</div><div class="line">    <span class="keyword">case</span> <span class="string">"Citi"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #1: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"StandardChartered"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #2: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"HSBC"</span>, <span class="string">"Deutsche"</span>, <span class="string">"JPMorgan"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #3: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">case</span> <span class="string">"NatWest"</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #4: %s\n"</span>, bank)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Printf(<span class="string">"Tx #E: %s\n"</span>, bank)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将来，如果添加新的银行，使用<code>switch-case</code>将更容易，更干净。</p>
<h2 id="持续的代码重构">持续的代码重构</h2>
<p>在大型代码库中，重构代码库结构至关重要。代码重构不时地提高代码的可读性和质量。这不是一次性的过程；团队应持续支付技术债务，以保持代码库正常。我曾学过“尽早重构，经常重构”（<code>refactor early, refactor often</code>），这对于编写可维护的Go代码非常有意义。随着时间的推移，包的代码数量和责任会变得越来越重，因此最好将一些包分解成更小的包，因为它们易于维护。重构包的另一个好理由是改进命名。包只包含与其功能相关的代码也是至关重要的。例如，Go把<code>os.SEEK_SET</code>、<code>os.SEEK_CUR</code>和 <code>os.SEEK_END</code>移动到<code>io.SeekStart</code>、<code>io.SeekCurrent</code>和 <code>io.SeekEnd</code>。包<code>io</code>更适合于组织涉及文件I/O的代码。将包分解成小的包也会使依赖关系变得轻量级。</p>
<h2 id="结论">结论</h2>
<p>随着时间和其他程序员在代码库上工作，我们更好地理解可维护性意味着什么。 编写可维护的代码并不复杂； 它需要每个贡献代码的人的知识、经验和仔细思考。 我们讨论的一组良好实践应该可以帮助您和团队更好地维护您的 Go 代码。</p>
<blockquote>
<p>原文 <a href="https://deepsource.io/learn/software-engineering-guide/writing-maintainable-go-code/" target="_blank" rel="external">Writing maintainable Go code - DeepSource Learn</a> by Jogendra</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写可维护的代码是最基本的要求。清晰度、可读性和简单性都是保持代码可维护性的各个方面。它应该使某人加入您的项目或在有人离开后维护代码的过程变得容易。可维护性的衡量指标是代码更改的容易程度以及与这些更改引起的风险性。为了有效地编写Go程序，了解Go语言的属性和地道写法，并使用与命名、程序构建、格式等相关既定约定是至关重要。</p>
<p>以下是一些有助于编写可维护的Go代码的良好实践。</p>
<p>原文: <a href="https://jogendra.dev/writing-maintainable-go-code" target="_blank" rel="external">Writing maintainable Go code</a> by Jogendra.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型编程: 支持特例化?]]></title>
    <link href="https://colobu.com/2022/01/11/go-generic-supports-specialization-no/"/>
    <id>https://colobu.com/2022/01/11/go-generic-supports-specialization-no/</id>
    <published>2022-01-11T00:14:53.000Z</published>
    <updated>2022-01-16T11:25:05.338Z</updated>
    <content type="html"><![CDATA[<p>一些编程语言如C++、Rust都是支持泛型特例化的，Go泛型支持吗？</p>
<a id="more"></a>
<p>所谓特例化(specialization)对泛型功能代码的扩展。比如对于泛型的函数，它的实现对于满足泛型参数的所有类型(type set)都是一样的，如果我们想对这些类型集(type set)中的一个，它的函数做特殊的实现，一些支持泛型特例化的语言是可以支持的，比如C++ template:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> fun(T a)</div><div class="line">{</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"template fun(): "</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;   <span class="comment">// 对int型特例化</span></div><div class="line"><span class="keyword">void</span> fun(<span class="keyword">int</span> a)</div><div class="line">{</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"specialized template fun for int type: "</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>fun</code>是一个函数模板,但是针对<code>int</code>类型，此函数有特殊的实现。</p>
<p>Rust也有类似的功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#![feature(min_specialization)]</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> Special</div><div class="line">{</div><div class="line">    x : usize,</div><div class="line">    y : usize</div><div class="line">}</div><div class="line"></div><div class="line">trait MyTrait</div><div class="line">{</div><div class="line">    fn myfunc(&self);</div><div class="line">}</div><div class="line"></div><div class="line">impl&lt;T&gt; MyTrait <span class="keyword">for</span> T</div><div class="line">{</div><div class="line">    <span class="keyword">default</span> fn myfunc(&self) { println!(<span class="string">"hi"</span>); }</div><div class="line">}</div><div class="line"></div><div class="line">impl MyTrait <span class="keyword">for</span> Special</div><div class="line">{</div><div class="line">    fn myfunc(&self) { println!(<span class="string">"I'm special"</span>); }</div><div class="line">}</div><div class="line"></div><div class="line">fn main() {</div><div class="line">    let spe = Special{</div><div class="line">        x: <span class="number">1</span>,</div><div class="line">        y: <span class="number">2</span>,</div><div class="line">    };</div><div class="line">    spe.myfunc();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里<code>MyTrait</code>针对通用类型<code>T</code>有一个默认实现，但是针对特定的类型<code>Special</code>,有一个特定的实现。</p>
<p>其它编程语言当前还不支持特例化，但是可以通过方法重载实现类似的功能，如typescript、C#等。<br>另外复杂的特例化还包括部分特例化的特性。</p>
<p>那么问题来了，Go的泛型(类型参数)是否支持特例化呢？我们先写个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> {</div><div class="line">	next  *List[T]</div><div class="line">	value T</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l *List[T]) Len() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (l *List[<span class="typename">string</span>]) Length() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们定义了一个泛型类型<code>List[T any]</code>, 包括它的一个泛型方法<code>Len() int</code>，接下来我们尝试定义一个“特例化”的方法<code>Length() int</code>。</p>
<p>编译一下，没问题，程序可以正常编译，难道Go泛型真的支持特例化吗？</p>
<p>我们再增加一个特例化泛型方法试试:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (l *List[<span class="typename">int</span>]) Size() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个时候再编译试试,编译出错:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cannot <span class="operator"><span class="keyword">use</span> <span class="number">0</span> (untyped <span class="built_in">int</span> constant) <span class="keyword">as</span> <span class="built_in">int</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="keyword">return</span> statement</span></div></pre></td></tr></table></figure>

<p>其实这个错误信息已经告诉我们了，这里的<code>int</code>并不是内建的整数类型，而是一个类型参数的名称，等价于我们常用的<code>T</code>、<code>K</code>、<code>V</code>。这里我们使用<code>int</code>作为类型参数的名称很有迷惑性。</p>
<p>所以答案也是很明确的，当前Go 1.18并不支持<strong>泛型特例化</strong>, 小心别掉到坑里了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些编程语言如C++、Rust都是支持泛型特例化的，Go泛型支持吗？</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型编程: interface 不再是那个interface]]></title>
    <link href="https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/"/>
    <id>https://colobu.com/2022/01/08/the-interface-is-not-that-interface-in-go-1-18/</id>
    <published>2022-01-08T13:48:20.000Z</published>
    <updated>2022-01-14T11:10:58.895Z</updated>
    <content type="html"><![CDATA[<p>自 Go 1.18 支持泛型后， Go interface 的意义已经彻彻底底的改变了，除了先前代表的方法集的意义外，还被用作泛型的类型约束(type constraint)的功能, interface已经不再是以前那个单纯的少年了。</p>
<a id="more"></a>
<p>在Go 1.17.x以及以前的版本中，interface是这样定义的：</p>
<blockquote>
<p>An interface type specifies a <strong>method set</strong> called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
<p>接口类型定义了一个方法集合，称之为接口(interface)。接口类型的变量可以存储任意的实现这个方法集合的类型，这种类型是此interface的超集。这种类型被称为实现了接口。接口类型的变量如果未初始化则它的值为nil。</p>
</blockquote>
<p>在Go 1.18中，interface定义改变了：</p>
<blockquote>
<p>An interface type defines a <strong>type set</strong>. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
<p>接口类型定义了一个类型集合。接口类型的变量可以存储这个接口类型集合的任意一种类型的实例值。这种类型被称之为实现了这个接口。接口类型的变量如果未初始化则它的值为nil。</p>
</blockquote>
<p>所以一句话，先前接口定义了方法集合，现在接口定义了类型集合。接口的用途也进行了扩展。</p>
<p>interface的定义也扩展了。先前，接口定义只能包含方法元素(method element):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> {</div><div class="line">	Read([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</div><div class="line">	Write([]<span class="typename">byte</span>) (<span class="typename">int</span>, error)</div><div class="line">	Close() error</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在接口定义除了方法元素外，还可以包含类型元素:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing all types with underlying type int.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing all types with underlying type int which implement the String method.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span></div><div class="line">	String() <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// An interface representing an empty type set: there is no type that is both an int and a string.</span></div><div class="line"><span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">	<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>类型元素包含类型(<code>T</code>)或者近似类型(<code>~T</code>)或者联合(union)元素(<code>A|B|C|~D</code>)。</p>
<p>但是，因为接口的定义和含义改变了，所以接口在使用的时候也有一些些不同。本文通过实例一一介绍。</p>
<p>首先记住一点，Go 1.17.x 及以前的版本中接口的使用方法在Go 1.18中照样使用，使用方法不变。变得是接口有类型元素或者做类型约束时的一些限制。</p>
<h3 id="近似元素的类型T必须是底层类型(underlying_type)自己，而且不能是接口类型">近似元素的类型<code>T</code>必须是底层类型(underlying type)自己，而且不能是接口类型</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误的定义!</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> I0 <span class="keyword">interface</span> {</div><div class="line">	~MyInt <span class="comment">// 错误! MyInt不是underlying type, int才是</span></div><div class="line">	~error <span class="comment">// 错误! error是接口</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素不能是类型参数(type_parameter)">联合(union)类型元素不能是类型参数(type parameter)</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误, interface{ K }中K是类型参数</span></div><div class="line"><span class="keyword">func</span> I1[K any, V <span class="keyword">interface</span>{ K }]() {</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误, interface{ nt | K }中K 是类型参数</span></div><div class="line"><span class="keyword">func</span> I2[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | K }]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素的非接口元素必须是两两不相交">联合(union)类型元素的非接口元素必须是两两不相交</h3>
<p>两两不相交意思是两两的交集是空集，比如 <code>int|string</code>的交集是空集，而<code>int|~int</code>的交集是<code>int</code>。</p>
<p>联合类型中的非接口元素必须是两两不相交的。</p>
<p>下面的定义没问题，因为any等价于<code>interface{}</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> I3[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | any }]() {</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误！ int和!int相交</span></div><div class="line"><span class="keyword">func</span> I4[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | ~<span class="typename">int</span> }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 下面的定义没有问题。因为int和MyInt是两个类型，不相交</span></div><div class="line"><span class="keyword">type</span> MyInt <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> I5[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | MyInt }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! int和~MyInt相交，交集是int</span></div><div class="line"><span class="keyword">func</span> I6[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | ~MyInt }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! int和MyInt2是相同类型，相交</span></div><div class="line"><span class="keyword">type</span> MyInt2 = <span class="typename">int</span></div><div class="line"><span class="keyword">func</span> I7[K any, V <span class="keyword">interface</span>{ <span class="typename">int</span> | MyInt2 }]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="联合(union)类型元素如果包含多于一个元素，不能包含包含非空方法的接口类型，也不能是comparable或者嵌入comparable">联合(union)类型元素如果包含多于一个元素，不能包含包含非空方法的接口类型，也不能是comparable或者嵌入comparable</h3>
<p>这条规则定义了接口作为类型元素的一些限制.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 编译没问题，只包含一个元素</span></div><div class="line"><span class="keyword">func</span> I9[K <span class="keyword">interface</span>{ io.Reader }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误!不能编译。因为包含了两个元素，而且无论是`io.Reader`还是`io.Writer`都包含方法</span></div><div class="line"><span class="keyword">func</span> I10[K <span class="keyword">interface</span>{ io.Reader | io.Writer }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 编译正常，因为这是正常的接口，没有联合元素</span></div><div class="line"><span class="keyword">func</span> I11[K <span class="keyword">interface</span> {</div><div class="line">	io.Reader</div><div class="line">	io.Writer</div><div class="line">}]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 联合类型多于一个元素，并且io.Reader包含方法</span></div><div class="line"><span class="keyword">func</span> I12[K <span class="keyword">interface</span>{ io.Reader | <span class="typename">int</span> }]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且不能是comparable</span></div><div class="line"><span class="keyword">func</span> I13[K comparable | <span class="typename">int</span>]() {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! 不能编译.因为联合元素大于一个，并且元素不能嵌入comparable</span></div><div class="line"><span class="keyword">func</span> I14[K <span class="keyword">interface</span>{ comparable } | <span class="typename">int</span>]() {</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="包含非接口类型元素、近似元素和联合类型只能用作类型参数，或者其它用作约束接口的元素">包含非接口类型元素、近似元素和联合类型只能用作类型参数，或者其它用作约束接口的元素</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line"></div><div class="line">    <span class="comment">// 以下编译没问题 </span></div><div class="line">	_ <span class="keyword">interface</span>{}</div><div class="line">	_ <span class="keyword">interface</span>{ m() }</div><div class="line">	_ <span class="keyword">interface</span>{ io.Reader }</div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		io.Reader</div><div class="line">		io.Writer</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 以下不能编译，接口不能用作变量实例类型</span></div><div class="line">	_ <span class="keyword">interface</span>{ <span class="typename">int</span> }</div><div class="line">	_ <span class="keyword">interface</span>{ ~<span class="typename">int</span> }</div><div class="line">	_ <span class="keyword">interface</span>{ MyInt }</div><div class="line">	A <span class="keyword">interface</span> {</div><div class="line">   	  <span class="typename">int</span></div><div class="line">	  m()</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 可以编译</span></div><div class="line">	_ <span class="keyword">struct</span>{ i <span class="typename">int</span> }</div><div class="line">    <span class="comment">// 下面一行不能编译,因为~int不能作为字段的类型</span></div><div class="line">	_ <span class="keyword">struct</span>{ i ~<span class="typename">int</span> }</div><div class="line">    <span class="comment">// 下面一行不能编译，因为constraints.Ordered只能用作类型约束</span></div><div class="line">	_ <span class="keyword">struct</span>{ i constraints.Ordered }</div><div class="line"></div><div class="line">    <span class="comment">// 下面两行能够编译，因为它们是接口类型，并且类型元素也是普通接口</span></div><div class="line">    _ <span class="keyword">interface</span>{ any }</div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		<span class="keyword">interface</span> {</div><div class="line">			any</div><div class="line">			m()</div><div class="line">		}</div><div class="line">	}</div><div class="line">    <span class="comment">// 不能编译，因为接口部署普通接口，而是类型约束</span></div><div class="line">	_ <span class="keyword">interface</span> {</div><div class="line">		<span class="keyword">interface</span> {</div><div class="line">			<span class="typename">int</span>|~<span class="typename">int</span></div><div class="line">			m()</div><div class="line">		}</div><div class="line">	}</div><div class="line">)</div></pre></td></tr></table></figure>

<h3 id="接口类型不定递归嵌入">接口类型不定递归嵌入</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误! 不能自己嵌入自己</span></div><div class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span> {</div><div class="line">	Node</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 错误! Tree不能通过TreeNode嵌入自己</span></div><div class="line"><span class="keyword">type</span> Tree <span class="keyword">interface</span> {</div><div class="line">	TreeNode</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> TreeNode <span class="keyword">interface</span> {</div><div class="line">	Tree</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>自 Go 1.18 支持泛型后， Go interface 的意义已经彻彻底底的改变了，除了先前代表的方法集的意义外，还被用作泛型的类型约束(type constraint)的功能, interface已经不再是以前那个单纯的少年了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译] go fuzzing]]></title>
    <link href="https://colobu.com/2022/01/03/go-fuzzing/"/>
    <id>https://colobu.com/2022/01/03/go-fuzzing/</id>
    <published>2022-01-03T13:40:09.000Z</published>
    <updated>2022-01-03T14:28:09.864Z</updated>
    <content type="html"><![CDATA[<p>Go fuzzing(模糊测试)是Go 1.18发布的另一个非常重要的特性，因为Go泛型已经把大家的目光都吸引过去了，导致go fuzzing这个特性有些人还不是太了解。Go官方发布了一个文档，介绍了Go Fuzzing技术。<br><a href="https://tip.golang.org/doc/fuzz/" target="_blank" rel="external">Go Fuzzing</a></p>
<a id="more"></a>
<p>Go 自 1.18开始在标准工具链中开始支持模糊测试(fuzzing)。</p>
<h2 id="概览">概览</h2>
<p>Fuzzing 是一种自动化的测试技术， 它不断的创建输入用来测试程序的bug。 Go fuzzing使用覆盖率智能指导遍历被模糊化测试的代码，发现缺陷并报告给用户。由于模糊测试可以达到人类经常忽略的边缘场景，因此它对于发现安全漏洞和缺陷特别有价值。</p>
<p>下面是一个模糊测试的示例，突出标识了它的主要组件。<br><img src="example.png" alt=""></p>
<h2 id="编写并运行模糊测试">编写并运行模糊测试</h2>
<h3 id="必备条件">必备条件</h3>
<p>Below are rules that fuzz tests must follow.</p>
<p>下面是模糊测试必须遵循的规则：</p>
<ul>
<li>模糊测试必须是一个名称类似<code>FuzzXxx</code>的函数，仅仅接收一个<code>*testing.F</code>类型的参数,没有返回值</li>
<li>模糊测试必须在<code>*_test.go</code>文件中才能运行</li>
<li>Fuzz target(模糊目标)必须是对<code>(*testing.F).Fuzz</code>的方法调用，参数是一个函数，并且此函数的第一个参数是<code>*testing.T</code>,然后是模糊参数(<code>fuzzing argument</code>)，没有返回值</li>
<li>一个模糊测试中必须只有一个模糊目标</li>
<li>所有的种子语料库(<code>seed corpus</code>)必须具有与模糊参数相同的类型,顺序相同。对<code>(*testing.F).Add</code>的调用也是如此, 同样也适用模糊测试中的testdata/fuzz中的语料文件</li>
<li>模糊参数只能是下面的类型<ul>
<li>string, []byte</li>
<li>int, int8, int16, int32/rune, int64</li>
<li>uint, uint8/byte, uint16, uint32, uint64</li>
<li>float32, float64</li>
<li>bool</li>
</ul>
</li>
</ul>
<h3 id="建议">建议</h3>
<p>下面的建议可以帮助你应付大部分的模糊测试：</p>
<ul>
<li>Fuzzing应该在支持覆盖率检测的平台上运行（目前是AMD64和ARM64），这样语料库可以在运行时有意义地增长，并且在进行Fuzzing时可以覆盖更多的代码。</li>
<li>模糊目标应该是快速的和确定性的，这样模糊引擎可以有效地工作，并且新的故障和代码覆盖率可以很容易地重现。</li>
<li>由于模糊目标是在多个工作进程之间以不确定的顺序并行调用的，因此模糊目标的状态不应持续到每次调用结束后，并且模糊目标的行为不应依赖于全局状态。</li>
</ul>
<h3 id="定制">定制</h3>
<p>默认的go命令满足大部分模糊化测试场景，所以典型的一个模糊化运行命令应该如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go test -fuzz={FuzzTestName}</div></pre></td></tr></table></figure>

<p>但是go命令提供一些定制化的参数来运行模糊测试，它们在<a href="https://pkg.go.dev/cmd/go" target="_blank" rel="external">cmd/go</a>文档中都有介绍。</p>
<p>这里重点说几个:</p>
<p>-fuzztime:  执行的模糊目标在退出的时候要执行的总时间或者迭代次数，默认是用不结束<br>-fuzzminimizetime: 模糊目标在每次最少尝试时要执行的时间或者迭代次数，默认是60秒。你可以禁用最小化尝试，只需把这个参数设置为0<br>-parallel: 同时执行的模糊化数量，默认是<code>$GOMAXPROCS</code>。当前进行模糊化测试时设置-cpu无效果</p>
<h2 id="其它资源">其它资源</h2>
<ul>
<li><strong>教程</strong><ul>
<li>如果想了解Go模糊化介绍性的文章，请参考<a href="https://go.dev/blog/fuzz-beta" target="_blank" rel="external">the blog post</a></li>
<li>更多教程正在准备中</li>
</ul>
</li>
<li><strong>文档</strong><ul>
<li><code>testing</code> 包描述了模糊测试中用到的<code>testing.F</code>类型</li>
<li><code>cmd/go</code> 描述了和模糊测试相关的参数</li>
</ul>
</li>
<li><strong>技术细节</strong><ul>
<li><a href="https://golang.org/s/draft-fuzzing-design" target="_blank" rel="external">Design draft</a></li>
<li><a href="https://golang.org/issue/44551" target="_blank" rel="external">提案</a></li>
</ul>
</li>
</ul>
<h2 id="术语">术语</h2>
<ul>
<li>corpus entry: 语料库条目，可以在模糊化测试时使用。它可以是一个特殊格式的文件，也可以是<code>(*testing.F).Add</code>方法的调用</li>
<li>coverage guidance: 一种模糊化方法，它使用代码覆盖范围的扩展来确定哪些语料库条目值得保留以备将来使用。</li>
<li>fuzz target: 模糊测试的函数，在模糊化过程中对语料库条目和生成的值执行模糊测试。通过将函数传递给<code>(*testing.F).Fuzz</code>来提供模糊测试</li>
<li>fuzz test: 一个test文件中的函数，格式为<code>FuzzXxx(*testing.F)</code>,用来执行模糊测试</li>
<li>fuzzing: 一种自动测试类型，它不断地修改程序的输入，以发现代码可能易受影响的问题，如bug或漏洞。</li>
<li>fuzzing arguments: 被传递到模糊目标的类型，并且可以被mutator修改变异</li>
<li>fuzzing engine: 一种管理模糊化的工具，包括维护语料库、调用变体、识别新覆盖范围和报告失败。</li>
<li>generated corpus: 语料库在模糊化过程中由模糊引擎随时间进行维护，以跟踪进度。它存储在<code>$GOCACHE/fuzz</code>中。</li>
<li>mutator: 模糊处理时使用的一种工具，它在将语料库条目传递给模糊目标之前对其进行随机操作。</li>
<li>package: 同一个文件夹下源代码的集合，会被编译在一起。Go代码组织的<a href="https://tip.golang.org/ref/spec#Packages" target="_blank" rel="external">方式</a>。ation.</li>
<li>seed corpus: 用户提供的用于模糊测试的语料库，可用于指导模糊引擎。它由模糊测试中的<code>f.Add</code>调用提供的语料库条目和包中<code>testdata/fuzz/{FuzzTestName}</code>目录中的文件组成。</li>
<li>test file: 格式为<code>xxx_test.go</code>类型的文件，包含测试、benchmark和模糊测试代码</li>
<li>vulnerability: 代码中的安全敏感弱点，可被攻击者利用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go fuzzing(模糊测试)是Go 1.18发布的另一个非常重要的特性，因为Go泛型已经把大家的目光都吸引过去了，导致go fuzzing这个特性有些人还不是太了解。Go官方发布了一个文档，介绍了Go Fuzzing技术。<br><a href="https://tip.golang.org/doc/fuzz/" target="_blank" rel="external">Go Fuzzing</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型不支持泛型方法，这是一个悲伤的故事]]></title>
    <link href="https://colobu.com/2021/12/22/no-parameterized-methods/"/>
    <id>https://colobu.com/2021/12/22/no-parameterized-methods/</id>
    <published>2021-12-22T00:25:06.000Z</published>
    <updated>2021-12-22T06:37:46.594Z</updated>
    <content type="html"><![CDATA[<p>根据Go 泛型提案的描述，Go不支持泛型方法:<a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md#no-parameterized-methods" target="_blank" rel="external">No parameterized methods</a>。主要原因Go泛型的处理是在编译的时候实现的，泛型方法在编译的时候，如果没有上下文的分析推断，很难判断泛型方案该如何实例化，甚至判断不了，导致目前(Go 1.18)Go实现中不支持泛型方案。</p>
<p>不过，泛型方法的缺失，多多少少给程序员带来一丝丝的忧伤的情绪，在一些场景之下，使用起来特别不方便。我最近看到了几个因为缺乏泛型方法导致的问题，在本文中总结一下，和大家探讨。</p>
<p>有一点点让人欣慰的是，Ian Lance Taylor和Ian Lance Taylor并没有把话说绝，说不定在某个版本中，泛型方法又支持了:</p>
<blockquote>
<p>So while parameterized methods seem clearly useful at first glance, we would have to decide what they mean and how to implement that.</p>
</blockquote>
<a id="more"></a>
<h2 id="为啥当前Go泛型不好实现泛型方法?">为啥当前Go泛型不好实现泛型方法?</h2>
<p>考虑下面一个例子，一共有四个package:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p1</div><div class="line"></div><div class="line"><span class="comment">// S 是一个普通的struct,但是包含一个泛型方法Identity.</span></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="comment">// Identity 一个泛型方法，支持任意类型.</span></div><div class="line"><span class="keyword">func</span> (S) Identity[T any](v T) T { <span class="keyword">return</span> v }</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p2</div><div class="line"></div><div class="line"><span class="comment">// HasIdentity 定义了一个接口，支持任意实现了泛型方法Identity的类型.</span></div><div class="line"><span class="keyword">type</span> HasIdentity <span class="keyword">interface</span> {</div><div class="line">	Identity[T any](T) T</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p3</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"p2"</span></div><div class="line"></div><div class="line"><span class="comment">// CheckIdentity 是一个普通函数，检查实参是不是实现了HasIdentity接口，如果是，则调用这个接口的泛型方法Identity.</span></div><div class="line"><span class="keyword">func</span> CheckIdentity(v <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">if</span> vi, ok := v.(p2.HasIdentity); ok {</div><div class="line">		<span class="keyword">if</span> got := vi.Identity[<span class="typename">int</span>]<span class="number">(0</span>); got !=<span class="number"> 0</span> {</div><div class="line">			<span class="built_in">panic</span>(got)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p4</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"p1"</span></div><div class="line">	<span class="string">"p3"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// CheckSIdentity 传参S给CheckIdentity.</span></div><div class="line"><span class="keyword">func</span> CheckSIdentity() {</div><div class="line">	p3.CheckIdentity(p1.S{})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一切看起来都没有问题，但是问题是<code>package p3</code>不知道<code>p1.S</code>类型，整个程序中如果也没有其它地方调用<code>p1.S.Identity</code>,依照现在的Go编译器的实现，是没有办法为<code>p1.S.Identity[int]</code>生成对应的代码的。</p>
<p>是的，如果go编译器做的比较复杂，在编译的时候这个场景是可以识别出来的，但是它需要遍历整体的程序调用链以便生成全部可能的泛型方法，对编译时间和编译器复杂性带来很大的调整。另外一点，如果代码中通过反射调用的话，编译器可能会遗漏一些泛型方法的实现，这就很要命了。</p>
<p>如果在运行时实现呢？就需要JIT或者反射等技术，这会造成运行时性能的下降。</p>
<p>很难实现啊？如果规定泛型方法不能实现接口呢？那么这类的泛型方法的存在的意义是什么呢？</p>
<p>所以目前没有太好的手段去实现泛型方法，暂时搁置了。</p>
<p>如果真的有必要，你可以通过实现泛型函数来实现泛型方法，把方法的receiver当成第一个参数传递过去。</p>
<p>这可以解决一部分问题，但是在使用的过程中多多少少有些麻烦。</p>
<p>因为泛型方法的缺乏，大家在开始使用泛型的时候就遇到了麻烦，最近连续看到多篇关于这方面的问题，比如下面几个。</p>
<h2 id="Facilitator模式_by_rakyll">Facilitator模式 by rakyll</h2>
<p>昨天rakyll写了一篇文章<a href="https://rakyll.org/generics-facilititators/" target="_blank" rel="external">https://rakyll.org/generics-facilititators/</a>,介绍她遇到的困难以及解决方式。这也是促进我把这几天看到的case总结的原因。</p>
<p>如果你熟悉其它编程语言，在使用orm框架的时候，可能见过下面类似的代码，实现泛型方法进行某种对象的查询:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db, err := database.Connect(<span class="string">"...."</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatal(err)</div><div class="line">}</div><div class="line"></div><div class="line">all, err := db.All[Person](ctx) <span class="comment">// Reads all person entities</span></div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatal(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为Go缺乏泛型方法的实现，你不能实现泛型<code>All</code>方法，那么怎么实现呢？一种方式是实现<code>All</code>函数，另一种实现是实现rakyll称之为的<code>Facilitator模式</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> database</div><div class="line"></div><div class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span>{ ... }</div><div class="line"></div><div class="line"><span class="keyword">type</span> Querier[T any] <span class="keyword">struct</span> {</div><div class="line">	client *Client</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewQuerier[T any](c *Client) *Querier[T] {</div><div class="line">	<span class="keyword">return</span> &Querier[T]{</div><div class="line">		client: c,</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (q *Querier[T]) All(ctx context.Context) ([]T, error) {</div><div class="line">	<span class="comment">// implementation</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (q *Querier[T]) Filter(ctx context.Context, filter ...Filter) ([]T, error) {</div><div class="line">	<span class="comment">// implementation</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数实现让人感觉到一种无力感，一种缺乏归宿感，一种没有对象的感觉，而这种实现呢，生成了特定类型的Querier[T],<code>All</code>方法就有泛型的感觉了(虽然实际是Receiver泛型)</p>
<h2 id="泛型signleflight">泛型signleflight</h2>
<p>有些同学熟悉Go官方扩展库<a href="golang.org/x/sync/singleflight">x/sync/singleflight</a>，这个库很好的解决大并发的时候并发访问的问题，常常用在cache访问和微服务访问的处理之中。</p>
<p>为了支持任意类型，它内部的实现是使用<code>interface{}</code>(<code>any</code>)类型来表示和处理的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g Group</div><div class="line">v, _, _ := g.Do(<span class="string">"key"</span>, <span class="keyword">func</span>() (<span class="keyword">interface</span>{}, error) {</div><div class="line">    <span class="keyword">return</span> <span class="string">"bar"</span>, <span class="constant">nil</span></div><div class="line">})</div><div class="line">useString(v.(<span class="typename">string</span>))</div></pre></td></tr></table></figure>

<p>五天前，有人把它改造成泛型的方式:<a href="https://github.com/marwan-at-work/singleflight" target="_blank" rel="external">marwan-at-work/singleflight</a>，上面的代码使用起来改变成如下方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g Group[<span class="typename">string</span>]</div><div class="line">v, _, _ := g.Do(<span class="string">"key"</span>, <span class="keyword">func</span>() (<span class="typename">string</span>, error) {</div><div class="line">    <span class="keyword">return</span> <span class="string">"bar"</span>, <span class="constant">nil</span></div><div class="line">})</div><div class="line">useString(v)</div></pre></td></tr></table></figure>

<p>相当于把Group改造成泛型类型，而不是实现泛型方法<code>Do</code>(当然目前Go泛型也实现不了)。</p>
<p>这个处理和上面rakyll处理方式类型，都是生成泛型类型，通过Receiver实现泛型的方法的处理。</p>
<p>不过对于这种方式，有一点不好的地方就是每种类型你都得生成一个特别的对象，略显麻烦。</p>
<h2 id="map_reduce">map reduce</h2>
<p>更早时候关于泛型的讨论，有人提出泛型方法的缺乏导致Go实现map reduce类似的库的困难，具体在哪里提到的我已经忘记了。</p>
<p>比如下面的实现一个iter的map reduce:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (i *iter[T any]) <span class="keyword">map</span>[K ~<span class="typename">string</span>](mapFn <span class="keyword">func</span>(t T) K) *iter[K]</div></pre></td></tr></table></figure>

<p>这种情况下用户想传入任意的<code>K</code>,把原先<code>T</code>类型的iter转换成<code>K</code>类型的iter,这种就不想其它支持泛型语言那么好实现了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据Go 泛型提案的描述，Go不支持泛型方法:<a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md#no-parameterized-methods" target="_blank" rel="external">No parameterized methods</a>。主要原因Go泛型的处理是在编译的时候实现的，泛型方法在编译的时候，如果没有上下文的分析推断，很难判断泛型方案该如何实例化，甚至判断不了，导致目前(Go 1.18)Go实现中不支持泛型方案。</p>
<p>不过，泛型方法的缺失，多多少少给程序员带来一丝丝的忧伤的情绪，在一些场景之下，使用起来特别不方便。我最近看到了几个因为缺乏泛型方法导致的问题，在本文中总结一下，和大家探讨。</p>
<p>有一点点让人欣慰的是，Ian Lance Taylor和Ian Lance Taylor并没有把话说绝，说不定在某个版本中，泛型方法又支持了:</p>
<blockquote>
<p>So while parameterized methods seem clearly useful at first glance, we would have to decide what they mean and how to implement that.</p>
</blockquote>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go并发编程一年回顾(2021)]]></title>
    <link href="https://colobu.com/2021/11/09/the-state-of-go-sync-2021/"/>
    <id>https://colobu.com/2021/11/09/the-state-of-go-sync-2021/</id>
    <published>2021-11-09T06:37:32.000Z</published>
    <updated>2021-11-10T00:35:33.185Z</updated>
    <content type="html"><![CDATA[<p>去年的时候我写了一篇<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/" target="_blank" rel="external">Go并发编程一年回顾</a>,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。</p>
<a id="more"></a>
<h2 id="TryLock终于要发布">TryLock终于要发布</h2>
<p>很久以来(可以追溯到2013年<a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">#6123</a>),就有人提议给Mutex增加TryLock的方法，被大佬们无情的拒绝了，断断续续，断断续续的一直有人提议需要这个方法，如今到了2021年，Go team大佬们终于松口了，增加了相应的方法(<a href="https://github.com/golang/go/issues/45435" target="_blank" rel="external">#45435</a>)。</p>
<p>一句话来说，Mutex增加了TryLock， 尝试获取锁, RWMutex 增加了 TryLock和TryRLock方法，尝试获取写锁和读锁。它们都返回bool类型。如果返回true,代表已经获取到了相应的锁，如果返回false,则表示没有获取到相应的锁。</p>
<p>本质上，要实现这些方法并不麻烦，接下来我们看看相应的实现(去除了race代码)。</p>
<p>首先是Mutex.TryLock:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&m.state,<span class="number"> 0</span>, mutexLocked) {</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是利用aromic.CAS操作state字段，如果当前没有被锁或者没有等待锁的情况，就可以成功获取到锁。不会尝试spin和与等待者竞争。</p>
<p>不要吐槽上面的代码风格，可能你觉得不应该写成下面的方式吗？原因在于我删除了race代码，那些代码块中包含race代码，所以不能像下面一样简写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32(&m.state,<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>读写锁有些麻烦，因为它有读锁和写锁两种情况。</p>
<p>首先看RWMutex.TryLock(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (rw *RWMutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> !rw.w.TryLock() {</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !atomic.CompareAndSwapInt32(&rw.readerCount,<span class="number"> 0</span>, -rwmutexMaxReaders) {</div><div class="line">        rw.w.Unlock()</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先底层的Mutex.TryLock,尝试获取w字段的锁,如果成功，需要检查当前的Reader, 如果没有reader,则成功, 如果此时不幸还有reader没有释放读锁，那么尝试Lock也是不成功的,返回false。注意返回之前一定要把rw.w的锁释放掉。</p>
<p>接下来看RWMutex.TryRLock(去除了race代码):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (rw *RWMutex) TryRLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		c := atomic.LoadInt32(&rw.readerCount)</div><div class="line">		<span class="keyword">if</span> c &lt;<span class="number"> 0</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&rw.readerCount, c, c<span class="number">+1</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码首先检查readerCount,如果为负值，说明有writer，此时直接返回false。</p>
<p>如果没有writer, 则使用atomic.CAS把reader加1, 如果成功，返回。如果不成功，那么此时可能有其它reader加入，或者也可能有writer加入，因为不能判断是reader还是writer加入，那么就用一个for循环再重试。</p>
<p>如果是writer加入，那么下一次循环c可能就是负数，直接返回false,如果刚才是有reader加入，那么它再尝试加1就好了。</p>
<p>以上就是新增的代码，不是特别复杂。Go team不情愿的把这几个方法加上了, 同时有很贴心的提示(恐吓):</p>
<blockquote>
<p>Note that while correct uses of TryLock do exist, they are rare,<br>and use of TryLock is often a sign of a deeper problem<br> in a particular use of mutexes. </p>
</blockquote>
<h2 id="WaitGroup的字段变化">WaitGroup的字段变化</h2>
<p>先前，WaitGroup类型使用<code>[3]uint32</code>作为<code>state1</code>字段的类型，在64位和32位编译器情况下，这个字段的byte的意义是不同的，主要是为了对齐。虽然使用一个字段很&quot;睿智&quot;,但是阅读起来却很费劲，现在，Go team把它改成了两个字段，根据对齐规则，64位编译器会对齐相应字段，讲真的，我们不差那4个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</div><div class="line">	noCopy noCopy</div><div class="line"></div><div class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></div><div class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></div><div class="line">	<span class="comment">// compilers only guarantee that 64-bit fields are 32-bit aligned.</span></div><div class="line">	<span class="comment">// For this reason on 32 bit architectures we need to check in state()</span></div><div class="line">	<span class="comment">// if state1 is aligned or not, and dynamically "swap" the field order if</span></div><div class="line">	<span class="comment">// needed.</span></div><div class="line">	state1 <span class="typename">uint64</span></div><div class="line">	state2 <span class="typename">uint32</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// state returns pointers to the state and sema fields stored within wg.state*.</span></div><div class="line"><span class="keyword">func</span> (wg *WaitGroup) state() (statep *<span class="typename">uint64</span>, semap *<span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">if</span> unsafe.Alignof(wg.state1) ==<span class="number"> 8</span> || <span class="typename">uintptr</span>(unsafe.Pointer(&wg.state1))<span class="number">%8</span> ==<span class="number"> 0</span> {</div><div class="line">		<span class="comment">// state1 is 64-bit aligned: nothing to do.</span></div><div class="line">		<span class="keyword">return</span> &wg.state1, &wg.state2</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="comment">// state1 is 32-bit aligned but not 64-bit aligned: this means that</span></div><div class="line">		<span class="comment">// (&state1)+4 is 64-bit aligned.</span></div><div class="line">		state := (*<span class="number">[3</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&wg.state1))</div><div class="line">		<span class="keyword">return</span> (*<span class="typename">uint64</span>)(unsafe.Pointer(&state<span class="number">[1</span>])), &state<span class="number">[0</span>]</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>64位对齐情况下state1和state2意义很明确，如果不是64位对齐，还得巧妙的转换一下。</p>
<h2 id="Pool中使用fastrandn替换fastrand">Pool中使用fastrandn替换fastrand</h2>
<p>Go运行时中提供了<code>fastrandn</code>方法，要比<code>fastrand() % n</code>快很多，相关的文章可以看下面中的注释中的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> fastrand() <span class="typename">uint32</span> {</div><div class="line">	mp := getg().m</div><div class="line">	<span class="comment">// Implement wyrand: https://github.com/wangyi-fudan/wyhash</span></div><div class="line">	<span class="keyword">if</span> goarch.IsAmd64|goarch.IsArm64|goarch.IsPpc64|</div><div class="line">		goarch.IsPpc64le|goarch.IsMips64|goarch.IsMips64le|</div><div class="line">		goarch.IsS390x|goarch.IsRiscv64 ==<span class="number"> 1</span> {</div><div class="line">		mp.fastrand +=<span class="number"> 0</span>xa0761d6478bd642f</div><div class="line">		hi, lo := math.Mul64(mp.fastrand, mp.fastrand<span class="number">^0</span>xe7037ed1a0b428db)</div><div class="line">		<span class="keyword">return</span> <span class="typename">uint32</span>(hi ^ lo)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Implement xorshift64+</span></div><div class="line">	t := (*<span class="number">[2</span>]<span class="typename">uint32</span>)(unsafe.Pointer(&mp.fastrand))</div><div class="line">	s1, s0 := t<span class="number">[0</span>], t<span class="number">[1</span>]</div><div class="line">	s1 ^= s1 &lt;&lt;<span class="number"> 17</span></div><div class="line">	s1 = s1 ^ s0 ^ s1&gt;<span class="number">&gt;7</span> ^ s0&gt;<span class="number">&gt;16</span></div><div class="line">	t<span class="number">[0</span>], t<span class="number">[1</span>] = s0, s1</div><div class="line">	<span class="keyword">return</span> s0 + s1</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> fastrandn(n <span class="typename">uint32</span>) <span class="typename">uint32</span> {</div><div class="line">	<span class="comment">// This is similar to fastrand() % n, but faster.</span></div><div class="line">	<span class="comment">// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/</span></div><div class="line">	<span class="keyword">return</span> <span class="typename">uint32</span>(<span class="typename">uint64</span>(fastrand()) * <span class="typename">uint64</span>(n) &gt;&gt;<span class="number"> 32</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>所以sync.Pool中使用<code>fastrandn</code>做了一点点修改，用来提高性能。好卷啊，这一点点性能都来压榨,关键，这还是开启race才会执行的代码。</p>
<h2 id="sync-Value增加了Swap和CompareAndSwap两个便利方法">sync.Value增加了Swap和CompareAndSwap两个便利方法</h2>
<p>如果使用sync.Value,这两个方法的逻辑经常会用到，现在这两个方法已经添加到标准库中了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (v *Value) Swap(<span class="built_in">new</span> <span class="keyword">interface</span>{}) (old <span class="keyword">interface</span>{}) </div><div class="line"><span class="keyword">func</span> (v *Value) CompareAndSwap(old, <span class="built_in">new</span> <span class="keyword">interface</span>{}) (swapped <span class="typename">bool</span>)</div></pre></td></tr></table></figure>

<p>Go 1.18中虽然实现了泛型，但是一些库的修改有可能在将来的版本中实现了。在泛型推出来之后，atomic对类型的支持会有大大的加强，所以将来Value这个类型有可能退出历史舞台，很少被使用了。(参考Russ Cox的文章<a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>)</p>
<p>整体来说，Go的并发相关的库比较稳定，并没有大的变化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去年的时候我写了一篇<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/" target="_blank" rel="external">Go并发编程一年回顾</a>,如今2021年也快结束了，Go 1.18的特性已经冻结，美国页很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型系列：再简化，省略接口]]></title>
    <link href="https://colobu.com/2021/10/24/go-generic-eliding-interface/"/>
    <id>https://colobu.com/2021/10/24/go-generic-eliding-interface/</id>
    <published>2021-10-24T09:27:08.000Z</published>
    <updated>2021-10-28T04:19:25.403Z</updated>
    <content type="html"><![CDATA[<p>这是Go泛型系列文章。</p>
<p>其它Go泛型文章：</p>
<ul>
<li><a href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/" target="_blank" rel="external">Go泛型是怎么实现的?</a></li>
<li><a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a></li>
</ul>
<a id="more"></a>
<p>如果你一直关注Go泛型的设计和实现，一定知道Go泛型代码实现是通过类型参数(type parameter)实现的，当运行泛型代码时，类型参数(type parameter)由类型参数（type argument）替代。(很遗憾parameter和argument都被翻译成了中文参数)</p>
<p>类型参数(type parameter)也有类型，也就是描述这个参数类型行为的元数据，被成为约束(constraint)。最通用的约束就是内建的<code>any</code>类型，它代表任意的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Print[T any](s []T) {</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s {</div><div class="line">		fmt.Println(v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Go泛型设计中， 约束是通过接口类型来实现的(<code>interface</code>)。因为接口类型和约束的功能黑类似，就是限定type argument必须实现type parameter的约束(方法集)。当然，为了实现泛型的功能，除了方法集之外，Go还对用来当做约束的接口做了扩展，定义了类型集(<code>type set</code>)的概念,比如下面是约束代表一个type argument可以是int、int8、int16、int32或int64的类型，是并(<code>union</code>)的关系，所以使用<code>|</code>符号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span> | <span class="typename">int8</span> | <span class="typename">int16</span> | <span class="typename">int32</span> | <span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>更进一步，Go还定义了<code>~</code>的符号，代表只要底层类型都是某个特定类型就可以，所以上面的例子可以写的更通用一些:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span> | ~<span class="typename">int8</span> | ~<span class="typename">int16</span> | ~<span class="typename">int32</span> | ~<span class="typename">int64</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样<code>type MyInt int</code>定义的<code>MyInt</code>类型的实例也满足这个约束。</p>
<h2 id="constraints_包">constraints 包</h2>
<p>Go目前的实现新增加一个package,叫做<code>constraints</code>,用来定义内建的约束,比如常见的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">int</span> | ~<span class="typename">int8</span> | ~<span class="typename">int16</span> | ~<span class="typename">int32</span> | ~<span class="typename">int64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">uint</span> | ~<span class="typename">uint8</span> | ~<span class="typename">uint16</span> | ~<span class="typename">uint32</span> | ~<span class="typename">uint64</span> | ~<span class="typename">uintptr</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</div><div class="line">	Signed | Unsigned</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">float32</span> | ~<span class="typename">float64</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Complex <span class="keyword">interface</span> {</div><div class="line">	~<span class="typename">complex64</span> | ~<span class="typename">complex128</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> {</div><div class="line">	Integer | Float | ~<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>甚至 Russ Cox、Ian Lance Taylor他们 提议和讨论为 slice、map、chan增加必要的约束，因为它们太常用了，标准库中都可以用到。(<a href="https://github.com/golang/go/discussions/47203" target="_blank" rel="external">#47203</a>、<a href="https://github.com/golang/go/discussions/47319" target="_blank" rel="external">#47319</a>、<a href="https://github.com/golang/go/discussions/47330" target="_blank" rel="external">47330#</a>)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Slice[Elem any] <span class="keyword">interface</span> {</div><div class="line">	~[]Elem</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Map[Key comparable, Val any] <span class="keyword">interface</span> {</div><div class="line">	~<span class="keyword">map</span>[Key]Val</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Chan[Elem any] <span class="keyword">interface</span> {</div><div class="line">	~<span class="keyword">chan</span> Elem</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>Rob Pike 最近新提交了一个issue,建议在Go 1.18中不要对标准库增加泛型的支持<a href="https://github.com/golang/go/issues/48918" target="_blank" rel="external">#48918</a>。离Go 1.18发布就四个月了，很多实现还在摸索之中，这是大师给出的一个很中肯的建议，建议相关的哭的改动先增加到扩展库中(<code>x/exp</code>),成熟后再加到标准库中，得到了很多Gopher的赞同。这是另外一个话题了。</p>
</blockquote>
<p>包<code>constraints</code>定义常用的约束可以很好的帮助我们开发，但是你有没有感觉有点异常？</p>
<h2 id="省略接口">省略接口</h2>
<p>是的，依照Go泛型规范，我们必须定义一个约束，然后才能在泛型类型和泛型方法中使用，和其它语言的泛型定义相比，你有没有觉得这一点有脱裤子放屁多此一举的味道？</p>
<p>你看上面的Slice、Map、Chan的定义，是不是很冗余？为什么我们不能直接在泛型类型和方法的定义中直接使用<code>~[]Elem</code>、<code>~map[Key]Val</code>、<code>~chan Elem</code>呢？</p>
<p>因此fzipp提议，对于一个非接口的类型，默认等价为一个约束<a href="https://github.com/golang/go/issues/48424" target="_blank" rel="external">#48424</a>，下面的公式很好的描述了这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[T nonInterfaceType] ≡ [T <span class="class"><span class="keyword">interface</span></span>{~nonInterfaceType}]</div></pre></td></tr></table></figure>

<p>在泛型的定义中，非接口类型<code>nonInterfaceType</code>等价于约束<code>interface{~nonInterfaceType}</code>, 比如<code>~int</code>等价于<code>interface{~int}</code>。这样我们就可以省略<code>constraints</code>包了。 这个提议北接收了，而且相关功能也加入到了go master分支中。</p>
<p>mattn的Go泛型例子中，将一个整形数组转换成一个chan的<a href="https://github.com/mattn/go-generics-example/blob/main/constraints-chan/main.go" target="_blank" rel="external">例子</a>(我稍微改动成更地道的Go的写法):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"constraints"</span></div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> makeChan[T constraints.Chan[E], E any](ctx context.Context, arr []E) T {</div><div class="line">	ch := <span class="built_in">make</span>(T)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> ch &lt;- v:</div><div class="line">			}</div><div class="line">			</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> makeChan(context.Background(), []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}) {</div><div class="line">		fmt.Println(v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里使用的是<code>constraints.Chan[E]</code>代表一个泛型的channel，现在可以用更简便的方法了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> makeChan[T <span class="keyword">chan</span> E, E any](ctx context.Context, arr []E) T {</div><div class="line">	ch := <span class="built_in">make</span>(T)</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> ch &lt;- v:</div><div class="line">			}</div><div class="line">			</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> ch</div><div class="line">}</div></pre></td></tr></table></figure>

<p>直接使用<code>chan E</code>就可以了，方不方便？</p>
<p><code>chan E</code> 隐式地代表<code>interface {chan E}</code>,使用起来更简捷，不需要额外的接口(约束)定义。</p>
<p>虽然Go 1.18的临近，感觉Go泛型的开发工作越来越重，甚至有一些还不明确的地方，祝福一下吧，希望它顺顺利利的推出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Go泛型系列文章。</p>
<p>其它Go泛型文章：</p>
<ul>
<li><a href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/" target="_blank" rel="external">Go泛型是怎么实现的?</a></li>
<li><a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a></li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]更快的时间解析]]></title>
    <link href="https://colobu.com/2021/10/10/faster-time-parsing/"/>
    <id>https://colobu.com/2021/10/10/faster-time-parsing/</id>
    <published>2021-10-10T08:17:51.000Z</published>
    <updated>2021-10-24T09:19:04.610Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://philpearl.github.io/post/perf_time/" target="_blank" rel="external">Faster time parsing</a>， 可以学习一下作者优化程序的方法。</p>
<a id="more"></a>
<p><img src="time.jpg" alt=""></p>
<p>在<a href="https://www.ravelin.com/careers" target="_blank" rel="external">Ravelin</a>，我们大量的数据都携带时间戳(timestamp)。大部分时间戳都以字符串形式存储在BigQuery中，而我们的大多数Go结构都使用Go time.Time类型表示时间。</p>
<p>很遗憾这就是我们的现实情况。我们真的有很多很多数据，所以我们真的有很多很多时间戳。一段时间以来，我总结出一个结论，随着时间的推移，我确信这个结论是正确的：</p>
<blockquote>
<p><strong>Friends don’t let friends represent time in databases as strings.</strong><br><strong>真心是哥们的话就不要在数据库把时间表示成字符串类型</strong></p>
</blockquote>
<p>不管咋地，自己的苦还得自己咽下去，既然我们已经这么设计了，我们还得坚持下去，但这不意味着我们破罐子破摔了，我们可以尽力而为。对于我来说，现在做得最好的方案就是找到一种比<a href="https://pkg.go.dev/time#Parse" target="_blank" rel="external">time.Parse</a>更快的方法解析 <strong>RFC3339</strong> 格式的时间戳。<br> If we write a dedicated parsing routine that just parses RFC3339 it should be faster than that.</p>
<p>事实证明这很容易。<strong>time.Parse</strong>有两个参数：一个描述要解析的数据格式(特殊字符串)，另一个是需要解析的数据字符串。format参数不只是选择合适的格式。format参数描述应如何解析数据。<strong>time.Parse</strong>不仅解析时间，还必须解析、理解和实现一种解析时间的描述。如果我们编写一个只是解析RFC3339的专用解析函数，它应该会比<strong>time.Parse</strong>更快。</p>
<p>但是在动手之前，让我们先写一个快速的基准测试，看看<strong>time.Parse</strong>有多快:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkParseRFC3339(b *testing.B) {</div><div class="line">	now := time.Now().UTC().Format(time.RFC3339Nano)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		<span class="keyword">if</span> _, err := time.Parse(time.RFC3339, now); err != <span class="constant">nil</span> {</div><div class="line">			b.Fatal(err)</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面数据是测试的结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="property">name</span>             <span class="property">time</span>/op</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">150</span>ns ± <span class="number">1</span>%</div></pre></td></tr></table></figure>

<p>接下来我们开始写自己专用的 RFC3339 解析函数。它索然无味，而且也不漂亮，但是至少它可以工作。</p>
<p>(它真的很长且不漂亮，所以与其把它包含在这篇文章中，让大家滚动过去，不如这里有一个<a href="https://github.com/philpearl/avro/blob/master/time/parse.go" target="_blank" rel="external">链接</a>，指向最终版本，并应用下面讨论的所有优化。如果你想象一个很长的函数，调用<a href="https://pkg.go.dev/strconv#Atoi" target="_blank" rel="external">strconv.Atoi</a>的次数很多，你就会明白这一点)</p>
<p>我们使用基础测试代码测试新的解析函数，我们得到下面的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>   <span class="number">150</span>ns ± <span class="number">1</span>%    <span class="number">45</span>ns ± <span class="number">4</span>%  -<span class="number">70.15</span>%  (p=<span class="number">0.000</span> n=<span class="number">7</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>相比较而言，新的函数真的很快。完美，结束。</p>
<h2 id="等等，_还未结束">等等， 还未结束</h2>
<p>如果我们采样 <a href="https://hackernoon.com/go-the-complete-guide-to-profiling-your-code-h51r3waz" target="_blank" rel="external">CPU profile</a>,我们观察到很多时间都花费在调用<strong>strconv.Atoi</strong>上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; go test -run ^$ -bench BenchmarkParseRFC3339 -cpuprofile cpu.prof </div><div class="line">&gt; go tool pprof cpu.prof</div><div class="line"><span class="keyword">Type</span>: cpu</div><div class="line"><span class="typename">Time</span>: Oct <span class="number">1</span>, <span class="number">2021</span> at <span class="number">7</span>:<span class="number">19</span>pm (BST)</div><div class="line">Duration: <span class="number">1.22</span>s, Total samples = <span class="number">960</span>ms (<span class="number">78.50</span>%)</div><div class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</div><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">950</span>ms, <span class="number">98.96</span>% <span class="keyword">of</span> <span class="number">960</span>ms total</div><div class="line">Showing top <span class="number">10</span> nodes <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">24</span></div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     <span class="number">380</span>ms <span class="number">39.58</span>% <span class="number">39.58</span>%      <span class="number">380</span>ms <span class="number">39.58</span>%  strconv.Atoi</div><div class="line">     <span class="number">370</span>ms <span class="number">38.54</span>% <span class="number">78.12</span>%      <span class="number">920</span>ms <span class="number">95.83</span>%  github.com/philpearl/blog/content/post.parseTime</div><div class="line">      <span class="number">60</span>ms  <span class="number">6.25</span>% <span class="number">84.38</span>%      <span class="number">170</span>ms <span class="number">17.71</span>%  <span class="typename">time</span>.Date</div></pre></td></tr></table></figure>

<p><strong>strconv.Atoi</strong>转换ASCII字符到整数类型。这是Go标准库的基础实现，所以它一定是经过了很好的编码和优化，所以我们不能优化它吗？</p>
<p>未必，我们的大部分数字正好有2个字节长，或者正好有4个字节长。我们可以编写数字解析函数，针对我们的特殊情况做优化，不需要任何令人讨厌的慢循环:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> atoi4(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	a, b, c, d := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[2</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[3</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> || c &lt;<span class="number"> 0</span> || c &gt;<span class="number"> 9</span> || d &lt;<span class="number"> 0</span> || d &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*1000</span> + b<span class="number">*100</span> + c<span class="number">*10</span> + d, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果再运行我们的基准测试，可以看到我们又做了一次更深入的性能提升。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">44.9</span>ns ± <span class="number">4</span>%  <span class="number">39.7</span>ns ± <span class="number">3</span>%  -<span class="number">11.51</span>%  (p=<span class="number">0.000</span> n=<span class="number">8</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>好了，我们现在不仅写了一个定制的时间解析器，而且还实现了定制的数字解析器。非常完美，结束。</p>
<h2 id="等等，_当然还未结束">等等， 当然还未结束</h2>
<p>啊哈，让我们在看一眼现在的CPU profile, 并且看一些汇编代码。在<strong>atoi2</strong>中有两个slice长度检查(下面绿色的汇编代码,调用panicIndex之前)，不是有一个<a href="https://go101.org/article/bounds-check-elimination.html" target="_blank" rel="external">边界检查的技巧</a>吗？</p>
<p><img src="lencheck.png" alt=""></p>
<p>以下是根据此技巧进行修正后的代码。函数开始处的<strong>_ = in[1]</strong>给了编译器充足的提示，这样我们在调用它的时候不用每次都检查是否溢出了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	_ = in<span class="number">[1</span>] <span class="comment">// This helps the compiler reduce the number of times it checks `in` is long enough</span></div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, fmt.Errorf(<span class="string">"can't parse number %q"</span>, in)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>虽然是一点小小的改变，但也带来明显的改变:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">39.7</span>ns ± <span class="number">3</span>%  <span class="number">38.4</span>ns ± <span class="number">2</span>%  -<span class="number">3.26</span>%  (p=<span class="number">0.001</span> n=<span class="number">8</span>+<span class="number">7</span>)</div></pre></td></tr></table></figure>

<p><strong>atoi2</strong>非常短。为什么它不被内联的？如果我们简化错误处理，是不是有效果？如果我们删除对<strong>fmt.Errorf</strong>的调用，并将其替换为一个简单的错误类型，这将降低<strong>atoi2</strong>函数的复杂性。这可能足以让Go编译器决定不作为单独的代码块而是直接在调用函数中内联这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> errNotNumber = errors.New(<span class="string">"not a valid number"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> atoi2(in <span class="typename">string</span>) (<span class="typename">int</span>, error) {</div><div class="line">	_ = in<span class="number">[1</span>]</div><div class="line">	a, b := <span class="typename">int</span>(in<span class="number">[0</span>]-<span class="string">'0'</span>), <span class="typename">int</span>(in<span class="number">[1</span>]-<span class="string">'0'</span>)</div><div class="line">	<span class="keyword">if</span> a &lt;<span class="number"> 0</span> || a &gt;<span class="number"> 9</span> || b &lt;<span class="number"> 0</span> || b &gt;<span class="number"> 9</span> {</div><div class="line">		<span class="keyword">return</span><span class="number"> 0</span>, errNotNumber</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> a<span class="number">*10</span> + b, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是最终的形态，基准测试结果有了显著的提升。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name             old <span class="built_in">time</span>/op  <span class="built_in">new</span> <span class="built_in">time</span>/op  delta</div><div class="line">ParseRFC3339-<span class="number">16</span>  <span class="number">38.4</span>ns ± <span class="number">2</span>%  <span class="number">32.9</span>ns ± <span class="number">5</span>%  -<span class="number">14.39</span>%  (p=<span class="number">0.000</span> n=<span class="number">7</span>+<span class="number">8</span>)</div></pre></td></tr></table></figure>

<p>我们的优化故事真的就此结束了。为了优化120纳秒的时间我们做了大量的工作。必看120纳秒很小，加起来却对程序提升不少，这些优化将Ravelin的一些机器学习特征提取管道组件的运行时间减少了一个小时甚至更多。如我前面所说，我们真的有很多很多的数据和时间戳。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://philpearl.github.io/post/perf_time/" target="_blank" rel="external">Faster time parsing</a>， 可以学习一下作者优化程序的方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[强制更改Go标准库的实现]]></title>
    <link href="https://colobu.com/2021/10/06/replace-implementations-in-go-std-libs-at-runtime/"/>
    <id>https://colobu.com/2021/10/06/replace-implementations-in-go-std-libs-at-runtime/</id>
    <published>2021-10-06T03:51:16.000Z</published>
    <updated>2021-10-06T05:16:58.923Z</updated>
    <content type="html"><![CDATA[<p>Go标准库中有一些单例的实现，比如<code>log</code>包中默认的<code>Logger</code>、<code>net.DefaultResolver</code>, 这些对象提供了便利的方法，但是有的时候，我们需要做一些定制话的功能，需要更改这些对象，<br>甚至有的时候，我们需要更改标准库的特定方法，常规手段是不起作用的, 必须使用一些&quot;骇客&quot;的方式。</p>
<p>国庆北京连绵秋雨，整好我窝在家里，实现了一个原本想12月份实现的产品，在开发项目的过程中，也遇到了一些需要更改标准库默认行为的需求，所以在这方面做了一些探索，整理出这篇文章，以飨读者。<br><a id="more"></a></p>
<p>如果你想实现自己的一个日志库(事实上Go生态圈已经有很多很多的日志库了)，你可能想&quot;拦截&quot;标准库的默认的Log,这样你的代码，或者第三方代码中通过标准库<code>log</code>输出的日志都能通过你自己的日志库输入出来。</p>
<p>其实标准库<code>log</code>默认的Logger是这样定义的: <code>var std = New(os.Stderr, &quot;&quot;, LstdFlags)</code>, std实现了一个输出到<code>os.Stderr</code>的<code>Logger</code>。Go标准库中的Logger不是一个接口，所以本身你可能还不能做太多的定制化的改造，但是至少，你可以改变日志输出的目的地，比如从标准err输出改到日志文件中。这里<code>std</code>是未输出的变量，但是标准库提供了<code>func SetOutput(w io.Writer)</code>方法，用来更改输出目的地。</p>
<p>这样看来，日志库还好，至少还暴露了一个更改定制化的方法，但是有很多情况下，标准库并没有提供定制的方法，或者说不方便定制的方法。</p>
<p>这几天我在实现项目的时候，遇到了一台机器有多个IP的情况。</p>
<p>一台机器配置了多个IP并不罕见，当你在这台机器连接其它的TCP服务器时， 本地到底使用的是哪一个IP地址呢？如<a href="https://serverfault.com/questions/12285/when-ip-aliasing-how-does-the-os-determine-which-ip-address-will-be-used-as-sour" target="_blank" rel="external">serverfault</a>有人提出的问题，在默认的情况下，Linux会依照子网的分类，选择和服务器在相同的子网的本地地址，但是如果同一个子网中配置了多个IP地址，那么Linux会选择此子网的&quot;主&quot;IP地址作为本地Ip地址连接服务器。</p>
<p>在我这个项目中，会有很多的网络连接，比如连接mysql，连接clickhouse,连接第三方的HTTP API服务，连接Kafka、连接 Redis等。不幸的事，当使用第三方库比如go-sql-driver/mysql、go-redis时，Linux所选择的本地IP地址并不是我期望的本地IP地址，导致权限验证失败无法连接。</p>
<p>本质上，无论是<code>go-sql-driver/mysql</code>或者<code>go-redis</code>,都是基于<code>net.Dial</code>或者<code>net.DialContext</code>建立的TCP连接。<code>go-sql-driver/mysql</code> 提供了 <code>RegisterDialContext</code>用于定制化<code>Dial</code>,<code>go-redis</code>提供了<code>Dialer</code>字段用来定制，你如果想指定本地的IP地址，可以通过定制的<code>net.Dialer</code>来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   localAddrDialier := &net.Dialer{</div><div class="line">	LocalAddr: localAddr,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是一个不错的、传统的方法，唯一不爽的是，每种类型我都需要进行地址，访问mysql、访问redis、访问kafka、访问第三方库、访问服务器......, 有没有一劳永逸的方法呢？</p>
<p>有!</p>
<p><a href="https://github.com/bouk/monkey" target="_blank" rel="external">bouk/monkey</a>是一个相当相当&quot;骇客&quot;的技术，当过运行时动态将方法的实现替换成<code>JMP 新的函数</code>, 来实现在运行时替换方法。经常我们会在单元测试的时候用来&quot;Mock&quot;一些方法，非常的有效，这一次，我要尝试使用它替换所有的<code>net.Dialer.Dial</code>或者<code>net.Dialer.DialContext</code>方法，来实现强制指定本地地址。</p>
<p>当然，agiledragon基于它的原理实现了<a href="https://github.com/agiledragon/gomonkey" target="_blank" rel="external">agiledragon/gomonkey</a>以方便调用，不过目前不支持临时恢复原函数。曹春晖基于它实现了<a href="https://github.com/cch123/supermonkey" target="_blank" rel="external">cch123/supermonkey</a>,通过解析符号表得到函数指针，可以替换未输出的函数，可以说功能更强大了。本文中还是使用原始的bouk/monkey,因为对于我来说，功能足够了。</p>
<blockquote>
<p>不要使用<a href="https://github.com/bouk/monkey" target="_blank" rel="external">bouk/monkey</a>做恶。</p>
</blockquote>
<p>可以使用<a href="https://github.com/bouk/monkey" target="_blank" rel="external">bouk/monkey</a>替换标准库的<code>net.Dialer.Dial</code>或者<code>net.Dialer.DialContext</code>函数，在建立TCP连接的时候，使用本地IP地址。这样，无论是mysql的库、还是redis的库，或者其它的第三方库，只要基于<code>net.Dialer.Dial</code>或者<code>net.Dialer.DialContext</code>函数，就会使用我们替换的方法。</p>
<p>相关代码也非常简单，如下所示，注释已经加到代码中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 指定要使用的本地地址. // by https://colobu.com</span></div><div class="line">   localAddr := &net.TCPAddr{</div><div class="line">	IP:   net.ParseIP(localIP),</div><div class="line">	Port:<span class="number"> 0</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> d *net.Dialer</div><div class="line"></div><div class="line">   <span class="comment">// 替换Dialer.DialContext方法</span></div><div class="line">dialContextGuard = monkey.PatchInstanceMethod(reflect.TypeOf(d), <span class="string">"DialContext"</span>, <span class="keyword">func</span>(d *net.Dialer, ctx context.Context, network, address <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">       <span class="comment">// 临时恢复</span></div><div class="line">	dialContextGuard.Unpatch()</div><div class="line">	<span class="keyword">defer</span> dialContextGuard.Restore()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"tcp"</span> || network == <span class="string">"tcp4"</span> || network == <span class="string">"tcp6"</span> {</div><div class="line">		localAddrDialier := &net.Dialer{</div><div class="line">			LocalAddr: localAddr,</div><div class="line">		}</div><div class="line"></div><div class="line">           <span class="comment">// 使用指定本地地址的dialer</span></div><div class="line">		<span class="keyword">return</span> localAddrDialier.DialContext(ctx, network, address)</div><div class="line">	}</div><div class="line"></div><div class="line">       <span class="comment">// 其它情况，比如UDP、UnixDomain等，使用标准库的方法</span></div><div class="line">	<span class="keyword">return</span> d.DialContext(ctx, network, address)</div><div class="line">})</div><div class="line"></div><div class="line">   <span class="comment">// 替换Dail方法</span></div><div class="line">dialGuard = monkey.PatchInstanceMethod(reflect.TypeOf(d), <span class="string">"Dial"</span>, <span class="keyword">func</span>(d *net.Dialer, network, address <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">       <span class="comment">// 临时恢复</span></div><div class="line">	dialGuard.Unpatch()</div><div class="line">	<span class="keyword">defer</span> dialGuard.Restore()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> network == <span class="string">"tcp"</span> || network == <span class="string">"tcp4"</span> || network == <span class="string">"tcp6"</span> {</div><div class="line">		localAddrDialier := &net.Dialer{</div><div class="line">			LocalAddr: localAddr,</div><div class="line">		}</div><div class="line"></div><div class="line">           <span class="comment">// 使用指定本地地址的dialer</span></div><div class="line">		<span class="keyword">return</span> localAddrDialier.Dial(network, address)</div><div class="line">	}</div><div class="line"></div><div class="line">       <span class="comment">// 其它情况，比如UDP、UnixDomain等，使用标准库的方法</span></div><div class="line">	<span class="keyword">return</span> d.Dial(network, address)</div><div class="line">})</div></pre></td></tr></table></figure>

<p>替换了这两个方法后，之后即使新建立<code>net.Dailer</code>对象，也是使用替换后的方法执行。</p>
<blockquote>
<p>这里并没有考虑并发定位情况，如果你的程序有并发的调用Dial或者DialContext,你需要加锁。</p>
</blockquote>
<p>这样，我们就一劳永逸的解决了指定本地IP地址创建TCP连接的问题，无需改动标准库的代码，无需逐个定制Dial方法。</p>
<p>同样的，你可以更改标准库的<code>net.DefaultResolver</code>, 这是标准库用来进行域名解析的实现，支持Go自己的解析实现和CGO方式查询。本身它是一个struct,而不是一个接口，所以虽然它是一个单例的对象，但是通常情况下你也没有多少定制化的可能。比如在调用<code>LookupIP</code>方法时,你想使用自己的一个协议返回IP列表，而不是查询本地文件或者DNS服务器，你基本是没有办法的。但是通过bouk/monkey，你可以更改<code>LookupIP</code>方法，这样你就可以定制了。</p>
<p>所以，bouk/monkey不仅仅可以用来在单元测试中mock对象和方法，还可以在应用运行中替换一些常规没有办法更改的函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go标准库中有一些单例的实现，比如<code>log</code>包中默认的<code>Logger</code>、<code>net.DefaultResolver</code>, 这些对象提供了便利的方法，但是有的时候，我们需要做一些定制话的功能，需要更改这些对象，<br>甚至有的时候，我们需要更改标准库的特定方法，常规手段是不起作用的, 必须使用一些&quot;骇客&quot;的方式。</p>
<p>国庆北京连绵秋雨，整好我窝在家里，实现了一个原本想12月份实现的产品，在开发项目的过程中，也遇到了一些需要更改标准库默认行为的需求，所以在这方面做了一些探索，整理出这篇文章，以飨读者。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/tags/Go/"/>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go泛型是怎么实现的?]]></title>
    <link href="https://colobu.com/2021/08/30/how-is-go-generic-implemented/"/>
    <id>https://colobu.com/2021/08/30/how-is-go-generic-implemented/</id>
    <published>2021-08-30T09:21:18.000Z</published>
    <updated>2021-10-06T03:29:34.356Z</updated>
    <content type="html"><![CDATA[<p>Go 1.17中你就可以使用泛型了，可以参考我3月份的文章:<a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a>, 编译的时候需要加<code>-gcflags=-G=3</code>参数，而当前master分支，默认已经支持泛型，不需要加<code>-G=3</code>参数了。</p>
<p>你可以通过下面的步骤尝试go最新分支:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get golang.org/dl/gotip</div><div class="line">gotip download</div></pre></td></tr></table></figure>

<p>编译代码的时候使用<code>gotip</code>替换<code>go</code>命令即可。</p>
<p>随着Go 1.17的发布，最近也涌现了很多的介绍Go泛型的文章，基本上都是简单介绍的文章。</p>
<p>最近Go泛型的变化是增加了两个操作符: <code>~</code>和<code>|</code>：</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<p>这些不是我想介绍的内容，今天我肝一篇介绍Go泛型实现原理的文章，介绍Go泛型实现的方案。</p>
<p>对于一个函数<code>func Echo[T any](t T){}</code>，Go编译器到底编译成了什么代码？</p>
<p>简单的说，当前Go泛型实现的方案和下图中的方案一样：</p>
<a id="more"></a>
<p><img src="stenciling.jpeg" alt=""></p>
<p>在国内的老破小小区的楼道中常见的一种高科技印刷技术，通过一个镂花模板，为每一种类型生成特化的类型，这个术语叫做<code>stenciling</code>。</p>
<p>但是如果再说多一点，那么就应该从 Taylor和Griesemer说起。</p>
<h2 id="Go泛型提案中关于泛型实现的介绍">Go泛型提案中关于泛型实现的介绍</h2>
<p>Go的泛型有别于其它语言的方案，在Go语言中泛型叫做<code>Type Parameter</code>(类型参数).</p>
<p>Taylor和Griesemer的提案<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md" target="_blank" rel="external">Type Parameters Proposal</a>更多的是泛型呈现形式和影响的思考,对具体的实现涉及甚少。</p>
<p>无论什么编程语言，<a href="https://research.swtch.com/generic" target="_blank" rel="external">根据Russ Cox的观察</a>，实现泛型至少要面对下面三条困境之一,那还是在2009年：</p>
<ul>
<li>拖累程序员:比如C语言，增加了程序员的负担，需要曲折的实现，但是不对增加语言的复杂性</li>
<li>拖累编译器: 比如C++编程语言，增加了编译器的负担，可能会产生很多冗余的代码，重复的代码还需要编译器斟酌删除，编译的文件可能非常大。Rust的泛型也属于这一类。</li>
<li>拖累执行时间:比如Java，将一些装箱成Object,进行类型擦除。虽然代码没啥冗余了，空间节省了，但是需要装箱拆箱操作，代码效率低。</li>
</ul>
<p>很显然, Go语言至简的设计哲学让它的泛型实现不会选择增加程序员的负担的道路，所以它会在第二和第三种方案中做选择。虽然提案中没有最终说明它选择了哪种方案，但是从实际编译的代码可以看出，它选择的是第二种方案。</p>
<h2 id="三个方案">三个方案</h2>
<p>Keith H. Randall, MIT的博士，现在在Google/Go team做泛型方面的开发，提出了Go泛型实现的三个方案：</p>
<h3 id="字典">字典</h3>
<p>在编译时生成一组实例化的字典，在实例话一个泛型函数的时候会使用字典进行蜡印(stencile)。</p>
<p>当为泛型函数生成代码的时候，会生成唯一的一块代码，并且会在参数列表中增加一个字典做参数，就像方法会把receiver当成一个参数传入。字典包含为类型参数实例化的类型信息。</p>
<p>字典在编译时生成，存放在只读的data section中。</p>
<p>当然字段可以当成第一个参数，或者最后一个参数，或者放入一个独占的寄存器。</p>
<p>当然这种方案还有依赖问题，比如字典递归的问题，更重要的是，它对性能可能有比较大的影响，比如一个实例化类型<code>int</code>, <code>x=y</code>可能通过寄存器复制就可以了，但是泛型必须通过<code>memmove</code>。</p>
<h3 id="蜡印(Stenciling)">蜡印(Stenciling)</h3>
<p>或者翻译成<code>用模板印</code>等。</p>
<p>就像下面的动图一样，同一个泛型函数，为每一个实例化的类型参数生成一套独立的代码，感觉和rust的泛型特化一样。<br><img src="stencile.gif" alt=""></p>
<p>这种方案和上面的字典方案正好相反。</p>
<p>比如下面一个泛型方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f[T1, T2 any](x <span class="typename">int</span>, y T1) T2 {</div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果有两个不同的类型实例化的调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="typename">float64</span> = f[<span class="typename">int</span>, <span class="typename">float64</span>]<span class="number">(7</span>,<span class="number"> 8.0</span>)</div><div class="line"><span class="keyword">var</span> b <span class="keyword">struct</span>{f <span class="typename">int</span>} = f[<span class="typename">complex128</span>, <span class="keyword">struct</span>{f <span class="typename">int</span>}]<span class="number">(3</span>,<span class="number"> 1</span><span class="number">+1</span>i)</div></pre></td></tr></table></figure>

<p>那么这个方案会生成两套代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> f1(x <span class="typename">int</span>, y <span class="typename">int</span>) <span class="typename">float64</span> {</div><div class="line">    ... identical bodies ...</div><div class="line">}</div><div class="line"><span class="keyword">func</span> f2(x <span class="typename">int</span>, y <span class="typename">complex128</span>) <span class="keyword">struct</span>{f <span class="typename">int</span>} {</div><div class="line">    ... identical bodies ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为编译f时是不知道它的实例化类型的，只有在调用它时才知道它的实例化的类型，所以需要在调用时编译f。对于相同实例化类型的多个调用，同一个package下编译器可以识别出来是一样的，只生成一个代码就可以了，但是不同的package就不简单了，这些函数表标记为<code>DUPOK</code>,所以链接器会丢掉重复的函数实现。</p>
<p>这种策略需要更多的编译时间，因为需要编译泛型函数多次。因为对于同一个泛型函数，每种类型需要单独的一份编译的代码，如果类型非常多，编译的文件可能非常大，而且性能也比较差。</p>
<h3 id="混合方案（GC_Shape_Stenciling）">混合方案（GC Shape Stenciling）</h3>
<p>混合前面的两种方案。</p>
<p>对于实例类型的shape相同的情况，只生成一份代码，对于shape类型相同的类型，使用字典区分类型的不同行为。</p>
<p>这种方案介于前两者之间。</p>
<p>啥叫<code>shape</code>?</p>
<p>类型的shape是它对内存分配器/垃圾回收器呈现的方式，包括它的大小、所需的对齐方式、以及类型哪些部分包含指针。</p>
<p>每一个唯一的shape会产生一份代码，每份代码携带一个字典，包含了实例化类型的信息。</p>
<p>这种方案的问题是到底能带来多大的收益，它会变得有多慢，以及其它的一些问题。</p>
<p>从当前的反编译的代码看，当前Go采用的是第二种方案，尽管名称中已经带了<code>shape</code>、<code>dict</code>的标志，或许，Go的泛型方案还在进化之中，进化到第三种方案或者其它方案也不是没有可能。</p>
<p>接下来我们看一个例子，看看Go泛型的方案是怎么实现的。</p>
<h2 id="例子">例子</h2>
<p>下面是一个简单的例子，有一个泛型函数<code>func echo[T any](t T) string {return fmt.Sprintf(&quot;%v&quot;, t)}</code>,使用不同的几种实例化类型去调用它，并且使用shape一样的<code>int32</code>和<code>uint32</code>做为实例化类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> generic</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> echo[T any](t T) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v"</span>, t)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Test() {</div><div class="line">	echo<span class="number">(0</span>)</div><div class="line">	echo(<span class="typename">int32</span><span class="number">(0</span>))</div><div class="line">	echo(<span class="typename">uint32</span><span class="number">(0</span>))</div><div class="line">	echo(<span class="typename">uint64</span><span class="number">(0</span>))</div><div class="line">	echo(<span class="string">"hello"</span>)</div><div class="line">	echo(<span class="keyword">struct</span>{}{})</div><div class="line">	echo(time.Now())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>反编译后代码非常长，精简如下。编译的时候禁止优化和内联，否则实例化的代码内联后看不到效果了。</p>
<p>可以看到函数<code>echo</code>编译成了不同的函数：<code>&quot;&quot;.echo[.shape.int]</code>、<code>&quot;&quot;.echo[.shape.int32]</code>、<code>&quot;&quot;.echo[.shape.uint32]</code>、<code>&quot;&quot;.echo[.shape.uint64]</code>、<code>&quot;&quot;.echo[.shape.string]</code>、<code>&quot;&quot;.echo[.shape.struct{}]</code>、<code>&quot;&quot;.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }]</code>不同的函数，即使shape一样的类型(<code>int32</code>、<code>uint32</code>)。 调用这些函数时，是通过<code>&quot;&quot;..dict.echo[uint64]</code>这种方式调用的。</p>
<p>所以我谨慎怀疑，Go的泛型方式在逐步的向第三种方案进化。</p>
<figure class="highlight assemble"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"># command-line-arguments</div><div class="line"><span class="string">""</span>.Test STEXT <span class="keyword">size</span>=<span class="number">185</span> args=<span class="number">0</span>x0 locals=<span class="number">0</span>x48 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	TEXT	<span class="string">""</span>.Test(SB), ABIInternal, $<span class="number">72</span>-<span class="number">0</span></div><div class="line">	<span class="string">""</span>.Test STEXT <span class="keyword">size</span>=<span class="number">185</span> args=<span class="number">0</span>x0 locals=<span class="number">0</span>x48 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	TEXT	<span class="string">""</span>.Test(SB), ABIInternal, $<span class="number">72</span>-<span class="number">0</span></div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	CMPQ	SP, <span class="number">16</span>(R14)</div><div class="line">	<span class="number">0</span>x0004 <span class="number">00004</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">2</span></div><div class="line">	<span class="number">0</span>x0004 <span class="number">00004</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	JLS	<span class="number">175</span></div><div class="line">	<span class="number">0</span>x000a <span class="number">00010</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">1</span></div><div class="line">	<span class="number">0</span>x000a <span class="number">00010</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	SUBQ	$<span class="number">72</span>, SP</div><div class="line">	<span class="number">0</span>x000e <span class="number">00014</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	MOVQ	BP, <span class="number">64</span>(SP)</div><div class="line">	<span class="number">0</span>x0013 <span class="number">00019</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	LEAQ	<span class="number">64</span>(SP), BP</div><div class="line">	<span class="number">0</span>x0018 <span class="number">00024</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</div><div class="line">	<span class="number">0</span>x0018 <span class="number">00024</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	FUNCDATA	$<span class="number">1</span>, gclocals·<span class="number">54241</span>e171da8af6ae173d69da0236748(SB)</div><div class="line">	<span class="number">0</span>x0018 <span class="number">00024</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	LEAQ	<span class="string">""</span>..dict.echo[<span class="keyword">int</span>](SB), AX</div><div class="line">	<span class="number">0</span>x001f <span class="number">00031</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x0021 <span class="number">00033</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x0021 <span class="number">00033</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">13</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.<span class="keyword">int</span>](SB)</div><div class="line">	<span class="number">0</span>x0026 <span class="number">00038</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">14</span>)	LEAQ	<span class="string">""</span>..dict.echo[int32](SB), AX</div><div class="line">	<span class="number">0</span>x002d <span class="number">00045</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">14</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x002f <span class="number">00047</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">14</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.int32](SB)</div><div class="line">	<span class="number">0</span>x0034 <span class="number">00052</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	LEAQ	<span class="string">""</span>..dict.echo[uint32](SB), AX</div><div class="line">	<span class="number">0</span>x003b <span class="number">00059</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x003d <span class="number">00061</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	NOP</div><div class="line">	<span class="number">0</span>x0040 <span class="number">00064</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">15</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.uint32](SB)</div><div class="line">	<span class="number">0</span>x0045 <span class="number">00069</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">16</span>)	LEAQ	<span class="string">""</span>..dict.echo[uint64](SB), AX</div><div class="line">	<span class="number">0</span>x004c <span class="number">00076</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">16</span>)	XORL	BX, BX</div><div class="line">	<span class="number">0</span>x004e <span class="number">00078</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">16</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.uint64](SB)</div><div class="line">	<span class="number">0</span>x0053 <span class="number">00083</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	LEAQ	<span class="string">""</span>..dict.echo[string](SB), AX</div><div class="line">	<span class="number">0</span>x005a <span class="number">00090</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	LEAQ	go.string.<span class="string">"hello"</span>(SB), BX</div><div class="line">	<span class="number">0</span>x0061 <span class="number">00097</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	MOVL	$<span class="number">5</span>, CX</div><div class="line">	<span class="number">0</span>x0066 <span class="number">00102</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">17</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.string](SB)</div><div class="line">	<span class="number">0</span>x006b <span class="number">00107</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">18</span>)	LEAQ	<span class="string">""</span>..dict.echo[struct{}](SB), AX</div><div class="line">	<span class="number">0</span>x0072 <span class="number">00114</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">18</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.struct{}](SB)</div><div class="line">	<span class="number">0</span>x0077 <span class="number">00119</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	<span class="keyword">CALL</span>	time.Now(SB)</div><div class="line">	<span class="number">0</span>x007c <span class="number">00124</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	AX, <span class="string">""</span>..autotmp_0+<span class="number">40</span>(SP)</div><div class="line">	<span class="number">0</span>x0081 <span class="number">00129</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	BX, <span class="string">""</span>..autotmp_0+<span class="number">48</span>(SP)</div><div class="line">	<span class="number">0</span>x0086 <span class="number">00134</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	CX, <span class="string">""</span>..autotmp_0+<span class="number">56</span>(SP)</div><div class="line">	<span class="number">0</span>x008b <span class="number">00139</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	CX, DI</div><div class="line">	<span class="number">0</span>x008e <span class="number">00142</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	BX, CX</div><div class="line">	<span class="number">0</span>x0091 <span class="number">00145</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	MOVQ	AX, BX</div><div class="line">	<span class="number">0</span>x0094 <span class="number">00148</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	LEAQ	<span class="string">""</span>..dict.echo[time.Time](SB), AX</div><div class="line">	<span class="number">0</span>x009b <span class="number">00155</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	NOP</div><div class="line">	<span class="number">0</span>x00a0 <span class="number">00160</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">19</span>)	<span class="keyword">CALL</span>	<span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }](SB)</div><div class="line">	<span class="number">0</span>x00a5 <span class="number">00165</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	MOVQ	<span class="number">64</span>(SP), BP</div><div class="line">	<span class="number">0</span>x00aa <span class="number">00170</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	ADDQ	$<span class="number">72</span>, SP</div><div class="line">	<span class="number">0</span>x00ae <span class="number">00174</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	RET</div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">20</span>)	NOP</div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">1</span>, $-<span class="number">1</span></div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">2</span></div><div class="line">	<span class="number">0</span>x00af <span class="number">00175</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	<span class="keyword">CALL</span>	<span class="keyword">runtime</span>.morestack_noctxt(SB)</div><div class="line">	<span class="number">0</span>x00b4 <span class="number">00180</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	PCDATA	$<span class="number">0</span>, $-<span class="number">1</span></div><div class="line">	<span class="number">0</span>x00b4 <span class="number">00180</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">12</span>)	JMP	<span class="number">0</span></div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.<span class="keyword">int</span>] STEXT dupok <span class="keyword">size</span>=<span class="number">268</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.<span class="keyword">int</span>](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c2 <span class="number">00194</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	DI, SI</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.int32] STEXT dupok <span class="keyword">size</span>=<span class="number">266</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.int32](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00bd <span class="number">00189</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVL	$<span class="number">1</span>, DI</div><div class="line">	<span class="number">0</span>x00c2 <span class="number">00194</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	DI, SI</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.uint32] STEXT dupok <span class="keyword">size</span>=<span class="number">266</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.uint32](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.uint64] STEXT dupok <span class="keyword">size</span>=<span class="number">268</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.uint64](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">16</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c2 <span class="number">00194</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	DI, SI</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.string] STEXT dupok <span class="keyword">size</span>=<span class="number">295</span> args=<span class="number">0</span>x18 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.string](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">24</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00d6 <span class="number">00214</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">2</span></div><div class="line">	<span class="number">0</span>x00d6 <span class="number">00214</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line"><span class="string">""</span>.echo[.shape.struct{}] STEXT dupok <span class="keyword">size</span>=<span class="number">208</span> args=<span class="number">0</span>x8 locals=<span class="number">0</span>x88 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.struct{}](SB), DUPOK|ABIInternal, $<span class="number">136</span>-<span class="number">8</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x0093 <span class="number">00147</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	PCDATA	$<span class="number">1</span>, $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x0093 <span class="number">00147</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	fmt.Sprintf(SB)</div><div class="line">    .................</div><div class="line">	<span class="number">0</span>x00cb <span class="number">00203</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	JMP	<span class="number">0</span></div><div class="line">	.................</div><div class="line"><span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }] STEXT dupok <span class="keyword">size</span>=<span class="number">364</span> args=<span class="number">0</span>x20 locals=<span class="number">0</span>xa0 funcid=<span class="number">0</span>x0</div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	TEXT	<span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }](SB), DUPOK|ABIInternal, $<span class="number">160</span>-<span class="number">32</span></div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x00c5 <span class="number">00197</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	CMPL	<span class="keyword">runtime</span>.writeBarrier(SB), $<span class="number">0</span></div><div class="line">	<span class="number">0</span>x00cc <span class="number">00204</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	JEQ	<span class="number">208</span></div><div class="line">	<span class="number">0</span>x00ce <span class="number">00206</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	JMP	<span class="number">214</span></div><div class="line">	<span class="number">0</span>x00d0 <span class="number">00208</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	MOVQ	AX, <span class="number">8</span>(CX)</div><div class="line">	<span class="number">0</span>x00d4 <span class="number">00212</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	JMP	<span class="number">221</span></div><div class="line">	<span class="number">0</span>x00d6 <span class="number">00214</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">9</span>)	<span class="keyword">CALL</span>	<span class="keyword">runtime</span>.gcWriteBarrier(SB)</div><div class="line">	.................</div><div class="line">	<span class="number">0</span>x0167 <span class="number">00359</span> (<span class="regexp">/Users/</span>chaoyuepan<span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>smallnest<span class="regexp">/study/</span>type_parameter<span class="regexp">/generic/g</span>eneric.go:<span class="number">8</span>)	JMP	<span class="number">0</span></div><div class="line">	</div><div class="line">...............</div><div class="line"><span class="string">""</span>.echo[.shape.string].stkobj SRODATA <span class="keyword">static</span> <span class="keyword">size</span>=<span class="number">32</span></div><div class="line">	.......</div><div class="line"><span class="string">""</span>.echo[.shape.string].arginfo1 SRODATA <span class="keyword">static</span> dupok <span class="keyword">size</span>=<span class="number">9</span></div><div class="line">	.......           ..........</div><div class="line"><span class="string">""</span>.echo[.shape.struct{}].stkobj SRODATA <span class="keyword">static</span> <span class="keyword">size</span>=<span class="number">32</span></div><div class="line">	.......</div><div class="line"><span class="string">""</span>.echo[.shape.struct{}].arginfo1 SRODATA <span class="keyword">static</span> dupok <span class="keyword">size</span>=<span class="number">5</span></div><div class="line">	.......</div><div class="line"><span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }].stkobj SRODATA <span class="keyword">static</span> <span class="keyword">size</span>=<span class="number">56</span></div><div class="line">	......</div><div class="line"><span class="string">""</span>.echo[.shape.struct{ time.wall uint64; time.ext int64; time.loc *time.Location }].arginfo1 SRODATA <span class="keyword">static</span> dupok <span class="keyword">size</span>=<span class="number">11</span></div><div class="line">	<span class="number">0</span>x0000 <span class="number">00</span> <span class="number">08</span> fe <span class="number">08</span> <span class="number">08</span> <span class="number">10</span> <span class="number">08</span> <span class="number">18</span> <span class="number">08</span> fd ff                 ...........</div></pre></td></tr></table></figure>

<h2 id="泛型的性能">泛型的性能</h2>
<p>写一个简单的benchmark程序，没看到明显的性能变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> bench_test</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">    <span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkAdd_Generic(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		add(i, i)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkAdd_NonGeneric(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		addInt(i, i)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span> {</div><div class="line">	<span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> add[T Addable](a, b T) T {</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> addInt(a, b <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	fmt.Println(add<span class="number">(1</span>,<span class="number"> 2</span>))</div><div class="line">	fmt.Println(addInt<span class="number">(1</span>,<span class="number"> 2</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md</a></li>
<li><a href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#" target="_blank" rel="external">https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.17中你就可以使用泛型了，可以参考我3月份的文章:<a href="https://colobu.com/2021/03/22/try-go-generic/" target="_blank" rel="external">Go 泛型尝鲜</a>, 编译的时候需要加<code>-gcflags=-G=3</code>参数，而当前master分支，默认已经支持泛型，不需要加<code>-G=3</code>参数了。</p>
<p>你可以通过下面的步骤尝试go最新分支:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> get golang.org/dl/gotip</div><div class="line">gotip download</div></pre></td></tr></table></figure>

<p>编译代码的时候使用<code>gotip</code>替换<code>go</code>命令即可。</p>
<p>随着Go 1.17的发布，最近也涌现了很多的介绍Go泛型的文章，基本上都是简单介绍的文章。</p>
<p>最近Go泛型的变化是增加了两个操作符: <code>~</code>和<code>|</code>：</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<p>这些不是我想介绍的内容，今天我肝一篇介绍Go泛型实现原理的文章，介绍Go泛型实现的方案。</p>
<p>对于一个函数<code>func Echo[T any](t T){}</code>，Go编译器到底编译成了什么代码？</p>
<p>简单的说，当前Go泛型实现的方案和下图中的方案一样：</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2021年Go生态圈rpc框架benchmark]]></title>
    <link href="https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/"/>
    <id>https://colobu.com/2021/08/01/benchmark-of-rpc-frameworks/</id>
    <published>2021-08-01T11:08:17.000Z</published>
    <updated>2021-10-06T03:29:34.208Z</updated>
    <content type="html"><![CDATA[<p>有朋友问，每年年初的时候我会发布一个rpc的框架的大比拼，今年为啥没有了？<br><a id="more"></a></p>
<p>有几个原因，一是我去年下半年换了一份工作，熟悉新的业务耗费了很大精力，导致博客文章相对少了，开源的贡献也少了，二是rpcx我自己觉得性能已经很不错了没有想着进一步的优化，所以也没有做相应的benchmark比较。</p>
<p>前几个星期头条的同学推出他们的rpcx框架<a href="https://github.com/cloudwego/kitex" target="_blank" rel="external">kitex</a>,据说性能要比rpcx和grpc好很多，加上今年GopherChina2021大会上他们也分享了他们的netpoll的优化。</p>
<p>本来，我对自定义epoll一类的框架如evio、gnet是不感冒的，因为go本身的net库也是基于epoll实现的，只不过这类框架在处理epoll事件之后的处理和标准库是不一样的。在GopherChina大会上我也和小伙伴说，我担心的这类框架的&quot;长尾效应&quot;,也就是从客户端视角看，大大并发的情况下latency的长尾效应可能是一个很大的痛点。这个话题我一直想专门写一篇文章探讨一下，希望这个秋季能出一篇深度分析标准库和自定义epoll的文章。</p>
<p>当然，既然头条的同学测试kitex性能不错，那么我也就把kitex加入到我的<a href="https://github.com/rpcxio/rpcx-benchmark" target="_blank" rel="external">rpc benchmark项目</a>中了,并且在这个周末也对几种Go rpc框架做了benchmark对比,我想自己测试看看这些框架的性能表现。</p>
<p>当然，每次发表benchmark文章，我都会先声明，没有一个benchmark可以全面的反应这些框架的完整的性能的，更不用说完整的特性了。每个人在使用rpc框架时，面对的场景可能都不同，有些是CPU敏感的服务、有的是IO敏感的服务、有的是内存敏感的服务、有的是读数据库的服务、有的是提供缓存的服务、有些是写文件的服务，消息的长度有大有小、消息的编码格式也不尽相同，有的是同步调用，有的是异步调用，有些是同机房的调用，有些是跨机房的调用，有些用tcp，有些用udp,......,各种各样五花八门，所以没有一种benchmark可以涵盖所有的场景。这次我做的benchmark，也只是覆盖了其中的一种场景。但是幸运的是，这个项目提供了一个框架，可以根据你的场景自己定制，如果你感兴趣，你可以在这个项目的基础上做一些修改，以便和你的使用场景做匹配。</p>
<p>另外，性能只是比较rpc框架的一个方面，千万不要因为测试结果A框架比B框架好就拿去吹嘘，那是幼稚的表现。另外也不可能Go生态圈只有一个框架存在，目前Go生态圈至少有十几个框架存在，各有特色。我个人对于Go生态圈的微服务框架持开放态度，而且也会了解和学习其它框架的优点，让rpcx框架变得更好，我相信·其他开发者也是这么想的。</p>
<p>想比以前的测试，我把Dubbo、Motan、Tarsgo等rpc框架去掉了。我个人不认为这些框架真的适合Go生态群的开发。Go的设计哲学就是简单，这几种框架都需要复杂的配置。当然我知道这些框架原先是Java、C++语言的，只不过为了跨语言才port到Go生态圈，导致这些框架的使用非常的复杂，因为为了保持和主语言的框架的兼容。如果单纯的Go生态圈的使用的话，我还是建议挑选简单可依赖的纯Go生态圈的框架。</p>
<p>为了尽量保持一致的测试环境，所有的框架统一遵循下面的约定：</p>
<ul>
<li>分别测试并发数为100、200、500、1000、2000、5000的场景，测试单个服务在面对不同并发量的情况下的性能。</li>
<li>从客户端统计吞吐率和延迟(latency)</li>
<li>采用共享的client。创建一定数量的client作为client池。</li>
<li>所有的框架都是在“公平”的情况下测试。测试数据都是一致的，采用protobuf进行测试。虽然有比Protobuf性能更好的序列化框架，但是因为不具有通用性所以不考虑。</li>
<li>测试会进行预热。</li>
<li>避免<a href="http://highscalability.com/blog/2015/10/5/your-load-generator-is-probably-lying-to-you-take-the-red-pi.html" target="_blank" rel="external">coordinated omission</a>:测试统计的是等待时间+服务时间,而不是服务端服务时间</li>
<li>统计既包含平均值，也包含P99.9值。</li>
</ul>
<h2 id="测试环境">测试环境</h2>
<ul>
<li>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz,2颗</li>
<li>总物理核 8个， 开超线程逻辑核数为 32个</li>
<li>内存 128G</li>
<li>Go 1.16.6</li>
<li>各框架版本<ul>
<li>arpc: 1.1.5</li>
<li>go std rpc: 1.16.6</li>
<li>grpc: 1.39.0</li>
<li>kitex: 0.0.3</li>
<li>rpcx: 1.6.5</li>
</ul>
</li>
</ul>
<p>测试是在单机上进行的。 坏处就是测试是没有像实际情况一样经过实际网络，而是本机网络支持处理，好处就是我们可以刨去长距离或者不好的网络的影响，只关注于rpc框架的处理。</p>
<h2 id="测试步骤">测试步骤</h2>
<p>生成每个框架的服务端和客户端:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span>  <span class="number">9756450</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">50</span> arpc_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">12800584</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">51</span> gostd_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">12520016</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">52</span> grpc_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11240760</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">53</span> kitex_server</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11810350</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">54</span> rpcx_server</span></div><div class="line"></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span>  <span class="number">5021980</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">56</span> arpc_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11109233</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">57</span> gostd_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">12581237</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">58</span> grpc_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">11559544</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">17</span><span class="symbol">:</span><span class="number">59</span> kitex_client</span></div><div class="line">-<span class="ruby">rwxr-xr-x <span class="number">1</span> smallnest <span class="constant">USER</span> <span class="number">16065065</span> <span class="constant">Aug</span>  <span class="number">1</span> <span class="number">18</span><span class="symbol">:</span><span class="number">00</span> rpcx_client</span></div></pre></td></tr></table></figure>

<p>启动服务端:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./xxx_server <span class="operator">-d</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8972</span></div></pre></td></tr></table></figure>

<p>客户端测试(并发数100)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./xxx_client -c <span class="number">1000</span> -n <span class="number">10000000</span> <span class="operator">-s</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8973</span></div></pre></td></tr></table></figure>

<p>每个场景会发送一千万个请求，内容一个不大不小的protobuf编码的数据，服务端收到后会设置某个字段为<code>OK</code>,并返回。没有复杂的计算。</p>
<p>相对于简单的echo 字符串的服务，消息体适中，编码格式通用，业务处理简单，耗时很短吞吐率有保障。</p>
<h2 id="测试结果">测试结果</h2>
<p>当前对5种rpc框架做了测试，有些是普通的rpc服务，比如arpc、Go标准库中的rpc、有些是支持微服务治理的框架如kitex、rpcx，有些是有一些微服务治理的功能如grpc。测试的时候，并没有测试他们的微服务治理的功能，而是只是测试了他们简单的rpc调用。</p>
<p>实际测试是，发现kitex在并发数为2000的时候，客户端调用会有少量出错，并发数为5000时，会有10+%的调用出错。</p>
<h3 id="吞吐率_(越高越好)">吞吐率 (越高越好)</h3>
<p>也就是每秒完成的调用数。</p>
<p><img src="throughputs.png" alt=""></p>
<h3 id="延迟(平均耗时，越小越好)">延迟(平均耗时，越小越好)</h3>
<p>单位毫秒。</p>
<p><img src="latency.png" alt=""></p>
<h3 id="延迟(P99-9耗时，越小越好)">延迟(P99.9耗时，越小越好)</h3>
<p>单位毫秒。</p>
<p><img src="p99.png" alt=""></p>
<h3 id="原始测试数据">原始测试数据</h3>
<p><img src="data.png" alt=""></p>
<h2 id="简单总结">简单总结</h2>
<p>arpc表现亮眼，吞吐率和耗时表现都不错。它是一个类似go web编程风格的rpc框架，采用router和handler的方式实现服务，值的学习。</p>
<p>kitex在并发量小的时候吞吐率要比rpcx要好，随着并发量增多，吞吐率基本差不多，吞吐率在大一些，它的长尾效应很明显P99.9延迟很高，这符合我对自定义epoll框架的推测。如果有小伙伴有不同的想法，欢迎发送评论。</p>
<p>Go标准库rpc框架中规中矩。</p>
<p>rpcx框架表现优异，在各种并发量的情况下都领先，并且没有明显的长尾效应。</p>
<p>grpc本来也是很不错的框架，但是性能和这几位比起来，还稍差一些。</p>
<p>通过这次测试，我对rpcx当前的性能有了一个大致的了解，并且通过对其它rpc框架测试，又进一步优化了rpcx的性能。</p>
<blockquote>
<p>可能这个测试对于基于netpoll的kitex不&quot;公平&quot;，我的理解是自定义netpoll适合那种有巨量socket连接，并发量适中的场景。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>有朋友问，每年年初的时候我会发布一个rpc的框架的大比拼，今年为啥没有了？<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]更新Go内存模型]]></title>
    <link href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/"/>
    <id>https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/</id>
    <published>2021-07-13T09:53:00.000Z</published>
    <updated>2021-10-06T03:29:34.174Z</updated>
    <content type="html"><![CDATA[<p>这是Russ Cox的系列论文的第三篇，也是最后一篇: <a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>。</p>
<p>文章对 官方的Go内存模型做了一些补充和思考。</p>
<a id="more"></a>
<p><img src="gophers-racing.jpeg" alt=""></p>
<p>当前的Go语言内存模型是在2009年编写的，从那以后略有更新。很明显，至少有一些细节我们应该添加到当前的内存这个内存模型中，其中包括对竞态检测器的明确认可，以及关于sync/atomic中的API是如何同步程序的清晰声明。</p>
<p>这篇文章重申了Go的总体哲学和当前的内存模型，然后概述了我认为我们应该对Go内存模型进行的相对较小的调整。假定你已经了解了前两篇文章<a href="https://colobu.com/2021/06/30/hwmm/" target="_blank" rel="external">“硬件内存模型”</a>和<a href="https://colobu.com/2021/07/11/Programming-Language-Memory-Models/" target="_blank" rel="external">“编程语言内存模型”</a>中的背景知识。</p>
<p>我已经开启了一个<a href="https://golang.org/s/mm-discuss" target="_blank" rel="external">GitHub讨论项目</a>来收集对反馈。根据这些反馈，我打算在本月晚些时候准备一份正式的Go提案。使用GitHub讨论本身就是一个实验，我还会继续尝试<a href="https://research.swtch.com/proposals-discuss" target="_blank" rel="external">找到一个合理的方法来扩大这些重要变化的讨论</a>。</p>
<h2 id="Go_设计哲学">Go 设计哲学</h2>
<p>Go旨在成为构建实用、高效系统的编程环境。它的目标是为小型项目的轻量级开发语言，但也可以优雅地扩展到大型项目和大型工程团队。</p>
<p>Go鼓励在高层次上处理并发，特别是通过通信。第一句Go箴言(<a href="https://go-proverbs.github.io/" target="_blank" rel="external">Go proverb</a>)就是“不要通过共享内存来通信，而是通过通信共享内存。”另一个流行的谚语是“清晰胜于聪明。”换句话说，Go鼓励通过避免使用巧妙的代码来避免狡猾的bug。</p>
<p>Go的目标不仅仅是可以理解的程序，还包括可以理解的语言和可以理解的package API。复杂或巧妙的语言特征或API与这一目标相矛盾。正如Tony Hoare在1980年<a href="https://www.cs.fsu.edu/~engelen/courses/COP4610/hoare.pdf" target="_blank" rel="external">图灵奖演讲</a>中所说:</p>
<blockquote>
<p>I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.</p>
<p>我的结论是，构建软件设计有两种方法:一种方法是简单实现，以至于明显没有缺陷；另一种方法是异常复杂，以至于没有明显缺陷。</p>
</blockquote>
<p>第一种方法要困难得多。它需要同样的技巧、奉献、洞察力，甚至是灵感，就像发现构成复杂自然现象基础的简单物理定律一样。它还要求愿意接受受物理、逻辑和技术限制的目标，并在冲突的目标无法实现时接受妥协。</p>
<p>这与Go的设计API的理念非常吻合。我们通常在设计过程中花很长时间来确保一个应用编程接口是正确的，并努力将其简化为最基本、最有用的精华。</p>
<p>Go作为一个有用的编程环境的另一方面是为最常见编程错误有定义明确的语义，这有助于理解和调试。这个想法并不新鲜。再次引用Tony Hoare的话，这是来自他1972年的“软件质量”检查单:</p>
<blockquote>
<p>As well as being very simple to use, a software program must be very difficult to misuse; it must be kind to programming errors, giving clear indication of their occurrence, and never becoming unpredictable in its effects.</p>
<p>一个软件程序不仅使用起来非常简单，而且很难被误用；它必须友好对待编程错误，给出它们发生的明确指示，并且其影响永远不会变得不可预测。</p>
</blockquote>
<p>为有问题的程序定义良好的语义，这种常识并不像人们预期的那样普遍。在C/C++中，未定义的行为已经演变成一种编译器作者的全权委托，以越来越有趣的方式将有轻微问题的程序转换成有大问题的程序。Go不采用这种方法:不存在“未定义的行为”。特别是，像空指针取消引用、整数溢出和无意的无限循环这样的错误都在Go中定义了语义。</p>
<h2 id="当前的_Go内存模型">当前的 Go内存模型</h2>
<p>Go的内存模型始于以下建议，符合Go的总体哲学:</p>
<ul>
<li>修改由多个goroutines同时访问的数据的程序必须串行化这些访问。</li>
<li>为了实现串行访问, 需要使用channel操作或其他同步原语(如sync和sync/atomic包中的原语)来保护数据。</li>
<li>如果你必须阅读本文的其余部分才能理解你的程序的行为，那你太聪明了。</li>
<li>别自作聪明。</li>
</ul>
<p>这仍然是个好建议。该建议也与其他语言对DRF-SC的鼓励使用一致:同步以消除数据竞争，然后程序将表现得好像顺序一致，不需要理解内存模型的其余部分。</p>
<p>根据这个建议，Go内存模型定义了一个传统的基于happens-before对读写竞争的定义。像在Java和JavaScript中一样，在Go中的读操作可以观察到任何更早但尚未被覆盖的写操作，或者任何竞争的写操作；仅安排一个这样的写入会强制产生指定的结果。</p>
<p>然后，内存模型继续定义同步操作，这些操作建立交替执行的goroutine的happen-before关系。操作尽管稀松平常，但是还是带有一些Go特有的风格:</p>
<ul>
<li>如果package <strong>p</strong>引入了package <strong>q</strong>,那么<strong>q</strong>的init函数的执行完成一定happen-before <strong>p</strong>的所有init函数(之前)</li>
<li><strong>main.main</strong> 函数一定 happen after 所有的init函数完成(之后)</li>
<li>go语句创建一个goroutine一定happen before goroutine执行(之前)</li>
<li>往一个channel中send happen before 从这个channel receive这个数据完成(之前)</li>
<li>一个channel的close一定happen before 从这个channel receive到零值数据(这里指因为close而返回的零值数据)</li>
<li>从一个unbuffered channel的receive一定happen before 往这个channel send完成(之前)</li>
<li>从容量为C的channel receive第k个数据一定happen before第k+C次send完成(之前)</li>
<li>对于任意的<strong>sync.Mutex</strong>或者<strong>sync.RWMutex</strong>类型的变量l以及n &lt; m, 调用第n次l.UnLock()一定happen before 第m次的l.Lock()返回(之前)</li>
<li>once.Do(f)中的对f的单次调用一定happen before 任意次的对once.Do(f)调用返回(之前)</li>
</ul>
<p>值得注意的是，这个列表忽略了package sync中新加的API以及sync/atomic的API。</p>
<p>Go内存模型规范以一些不正确同步的例子结束。它没有包含错误编译的例子。</p>
<h2 id="对Go内存模型做的改变">对Go内存模型做的改变</h2>
<p>2009年，当我们着手编写Go的内存模型时，Java内存模型进行了新的修订，C/C++11内存模型正在定稿。一些人强烈鼓励我们采用C/C++11模型，并充分利用了其已经完成的所有工作。对我们来说这似乎很冒险。相反，我们决定采用一种更保守的方法来保证我们要做的，这一决定得到了随后十年详细描述Java/C/C++内存模型中非常狡猾问题的论文的证实。是的，定义足够充分的内存模型来指导程序员和编译器作者是很重要的，但是完全正式地定义一个正确的内存模型似乎仍然超出了最有才华的研究人员的能力范围。Go定义一个最小的需求就足够了。</p>
<p>下面这一部分列出了我认为我们应该做的调整。如前所述，我已经开启了一个<a href="https://golang.org/s/mm-discuss" target="_blank" rel="external">GitHub讨论项</a>来收集反馈。根据这些反馈，我计划在本月晚些时候准备一份正式的Go提案。</p>
<h3 id="文档化Go的整体方法">文档化Go的整体方法</h3>
<p>“不要聪明”的建议很重要，应该坚持下去，但我们也需要在深入研究happen before细节之前，对Go的整体方法更多的谈一谈。我看到过很多关于Go方法的不正确总结，比如宣称Go的模型是C/C++的“DRF-SC或Catch Fire”。 这种误会是可以理解的: Go内存模型规范没有说它的方法是什么，而且它是如此之短(材料又如此微妙)，以至于人们看到了他们期望看到的东西，而不是那里有什么或没有什么。</p>
<p>拟在Go内存模型规范中增加的文档大致如下:</p>
<blockquote>
<h2 id="概观">概观</h2>
<p>Go以与本语言其余部分几乎相同的方式处理其内存模型，旨在保持语义简单、可理解和有用。</p>
<p>数据竞争被定义为对存储器位置的写入与对同一位置的另一次读取或写入同时发生，除非所有访问都是由sync/atomic package提供的原子数据访问提供。如前所述，强烈建议程序员使用适当的同步来避免数据竞争。在没有数据竞争的情况下，Go程序表现得好像所有的gorouitine都被多路复用到一个处理器上。这个属性有时被称为DRF-SC:无数据竞争的程序以顺序一致的方式执行。</p>
<p>其他编程语言通常采用两种方法之一来处理包含数据竞争的程序。第一，以C和C++为例，带有数据竞争的程序是无效的:编译器可能会以任意令人惊讶的方式中断它们。第二，以Java和JavaScript为例，具有数据竞争的程序定义了语义，通过限制竞争的可能影响，使程序更加可靠和易于调试。Go的方法介于这两者之间。具有数据竞争的程序是无效的，因为语言实现可能会报告竞争并终止程序。但另一方面，具有数据竞争的程序定义了具有有限数量结果的语义，使得错误的程序更可靠，更容易调试。</p>
</blockquote>
<p>这些文字应该阐明Go和其他语言有什么不同，纠正读者先前的任何期望。</p>
<p>在“happen before”一节的最后，我们还应该澄清某些竞争仍然会导致内存损坏。当前它以下面的句子结束：</p>
<blockquote>
<p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p>
</blockquote>
<p>我们应该加上一点:</p>
<blockquote>
<p>请注意，这意味着多word数据结构上的竞争可能导致单次写入产生不一致值。当值依赖于内部(指针、长度)或(指针、类型)pair的一致性时，就像大多数Go实现中的接口、map、切片和字符串的情况一样，这种竞争又会导致内存损坏。</p>
</blockquote>
<p>这将更清楚地说明保证对具有数据竞争的程序的限制。</p>
<h3 id="文档化_sync库的happen_before">文档化 sync库的happen before</h3>
<p>自从Go内存模型发布以来，一些新的API已经被添加到sync包中。我们需要将它们添加到内存模型中(<a href="https://golang.org/issue/7948" target="_blank" rel="external">issue#7948</a>)。谢天谢地谢广坤，增加的内容看起来很简单。我相信它们应该如下：</p>
<ul>
<li>对于sync.Cond, <strong>Broadcast</strong> 和 <strong>Signal</strong> 一定happen before 它解锁的Wait方法调用完成(之前)</li>
<li>对于sync.Map, Load, LoadAndDelete 和 LoadOrStore 都是读操作， Delete、LoadAndDelete和 Store都是写操作。LoadOrStore当它的loaded返回false时是写操作。一个写操作happen before 能观察到这个写操作的读操作(之前)</li>
<li>对于sync.Pool,对Put(x)的调用一定happen before Get方法返回这个x(之前)。同样的，返回x的New方法一定happen before Get方法返回这个x(之前)</li>
<li>对于sync.EWaitGroup, Done方法的调用一定happen before 它解锁的Wait方法调用返回(之前)</li>
</ul>
<p>这些API的用户需要知道保证，以便有效地使用它们。因此，虽然我们应该将这些文字保留在内存模型中以供介绍，但我们也应该将其包含在package sync的文档注释中。这也将有助于为第三方同步原语树立一个榜样，说明记录由API建立的顺序保证的重要性。</p>
<h3 id="文档话_sync/atomic的happen_before">文档话 sync/atomic的happen before</h3>
<p>Atomic operations are missing from the memory model. We need to add them (issue #5045). I believe we should say:</p>
<p>内存模型中缺少原子操作的保证。我们需要添加它们(<a href="https://golang.org/issue/5045" target="_blank" rel="external">issue #5045</a>)。我认为我们应该说:</p>
<blockquote>
<p>sync/atomic package中的API统称为“原子操作”，可用于同步各种goroutine执行。如果原子操作A的效果被原子操作B观察到，那么A发生在B之前(happen before)。在一个程序中执行的所有原子操作表现得好像是以某种顺序一致的顺序执行的。</p>
</blockquote>
<p>这是Dmitri Vyukov在2013年提出的建议，也是我在2016年非正式承诺的。它还与Java的volatiles和C++的默认原子具有相同的语义。</p>
<p>就C/C++而言，同步原子只有两种选择:顺序一致或acquire/release(Relaxed原子不会创建happen before，因此没有同步效果). 对这两者的决策归结为，第一，能够推理出多个位置上原子操作的相对顺序有多重要，第二，顺序一致的原子与acquire/release原子相比要多昂贵(慢)。</p>
<p>首先要考虑的是，关于多个位置上原子操作的相对顺序的推理非常重要。在之前的一篇文章中，我举了一个使用两个原子变量实现的无锁快速路径的条件变量的<a href="https://research.swtch.com/plmm#cond" target="_blank" rel="external">例子</a>，这两个原子变量被使用acuqire/release原子打破了。这种模式反复出现。例如，sync.WaitGroup曾经的实现使用了一对<a href="https://go.googlesource.com/go/+/ee6e1a3ff77a41eff5a606a5aa8c46bf8b571a13/src/pkg/sync/waitgroup.go#54" target="_blank" rel="external">原子uint32值</a>：wg.counter和wg.waiters。<a href="https://go.googlesource.com/go/+/cf148f3d468f4d0648e7fc6d2858d2afdc37f70d/src/runtime/sema.go#134" target="_blank" rel="external">Go运行时中的信号量的实现</a>也依赖于两个独立的原子word，即信号量值*addr和相应的waiter count root.nwait。还有更多。在缺乏顺序一致的语义的情况下(也就是说，如果我们改为采用acquire/release语义)，人们仍然会像这样错误地编写代码；它会神秘地失败，而且只在特定的情况下。</p>
<p>根本的问题是，使用acuqire/release原子使无数据竞争的程序不会导致程序以顺序一致的方式运行，因为原子本身不会提供保证。也就是说，这样的程序不提供DRF-SC。这使得这种程序很难推理，因此很难正确编写。</p>
<p>关于第二个考虑，正如在之前的文章中提到的，硬件设计人员开始为顺序一致的原子提供直接支持。例如，ARMv8添加了ldar和stlr指令来实现顺序一致的原子，它们也是acquire/release原子的推荐实现。如果我们为sync/atomic采用acquire/release语义，那么写在ARMv8上的程序无论如何都会获得顺序一致性。这无疑会导致依赖更强顺序的程序意外地在更弱的平台上崩溃。，如果由于竞争窗口很小, acquire/release和结果一致的原子之间的差异在实践中很难观察到，这甚至可能发生在单个架构上。</p>
<p>这两种考虑都强烈建议我们应该采用顺序一致的原子而不是acquire/release原子:顺序一致的原子更有用，一些芯片已经完全缩小了这两个级别之间的差距。如果差距很大，想必其他人也会这么做。</p>
<p>同样的考虑，以及Go拥有小型、易于理解的API的总体哲学，所有这一切都反对将acuqire/release作为一套额外的并行API来提供。似乎最好只提供最容易理解的，最有用的，很难被误用的原子操作。</p>
<p>另一种可能性是提供原始屏障，而不是原子操作(当然，C++两者都提供)。屏障的缺点是使期望变得不那么清晰，并且在某种程度上更加局限于特定的体系结构。Hans Boehm文章<a href="http://www.hboehm.info/c++mm/ordering_integrated.html" target="_blank" rel="external">“Why atomics have integrated ordering constraints”</a>给出了提供原子而不是屏障的论点(他使用术语栅栏fence)。一般来说，原子比栅栏更容易理解，而且由于我们现在已经提供了原子操作，所以我们不能轻易移除它们。一个机制要比提供两个好。</p>
<h3 id="可能的改变：_为sync/atomic提供类型化的API">可能的改变： 为sync/atomic提供类型化的API</h3>
<p>上面的定义说，当一个特定的内存块必须由多个线程同时访问而没有其他同步时，消除争用的唯一方法是让所有的访问都使用原子。仅仅让一些访问使用原子是不够的。例如，与原子读或写并发的非原子写仍然是s数据竞争，与非原子读或写并发的原子写也是数据竞争。</p>
<p>因此，一个特定的值是否应该用atomic访问是该值的属性，而不是特定的访问。正因为如此，大多数语言将这些信息放在类型系统中，比如Java的volatile int和C++的atomic<int>。Go当前的API没有，这意味着正确的使用需要仔细标注结构或全局变量的哪些字段预计只能使用原子API来访问。</int></p>
<blockquote>
<p>译者按: uber提供了类似的库<a href="https://github.com/uber-go/atomic" target="_blank" rel="external">uber-go/atomic</a>。</p>
</blockquote>
<p>为了提高程序的正确性，我开始认为Go应该定义一组类型化的原子值，类似于当前的原子值。值:Bool、Int、Uint、Int32、Uint32、Int64、Uint64和Uintptr。像Value一样，它们也有CompareAndSwap、Load、Store和Swap方法。例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Int32 <span class="keyword">struct</span> { v <span class="typename">int32</span> }</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Add(delta <span class="typename">int32</span>) <span class="typename">int32</span> {</div><div class="line">	<span class="keyword">return</span> AddInt32(&i.v, delta)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) CompareAndSwap(old, <span class="built_in">new</span> <span class="typename">int32</span>) (swapped <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">return</span> CompareAndSwapInt32(&i.v, old, <span class="built_in">new</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Load() <span class="typename">int32</span> {</div><div class="line">	<span class="keyword">return</span> LoadInt32(&i.v)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Store(v <span class="typename">int32</span>) {</div><div class="line">	<span class="keyword">return</span> StoreInt32(&i.v, v)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (i *Int32) Swap(<span class="built_in">new</span> <span class="typename">int32</span>) (old <span class="typename">int32</span>) {</div><div class="line">	<span class="keyword">return</span> SwapInt32(&i.v, <span class="built_in">new</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我将Bool包括在列表中，因为我们在Go标准库中多次用原子整数构造了原子Bool(在未暴露的API中)。显然是有需要的。</p>
<p>我们还可以利用即将到来的泛型支持，并为原子指针定义一个API，该API是类型化的，并且在其API中没有包不安全:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Pointer[T any] <span class="keyword">struct</span> { v *T }</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pointer[T]) CompareAndSwap(old, <span class="built_in">new</span> *T) (swapped <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">return</span> CompareAndSwapPointer(... lots of unsafe ...)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>(以此类推),你可能会想到不能使用泛型定义一个类型吗？我没有看到一个干净的方法使用泛型来实现atomic.Atomic[T]，避免我们引入Bool、Int等作为单独的类型。走走看吧。</p>
<h3 id="可能的改变:_增加非同步的atomic">可能的改变: 增加非同步的atomic</h3>
<p>所有其他现代编程语言都提供了一种方法来进行并发内存读写，这种方法不会使程序同步，但也不会使程序无效(不会算作数据竞争)。C、C++、Rust和Swift都有relaxed原子。Java有VarHandle的“普通”模式。JavaScript对共享内存缓冲区(唯一的共享内存)有非原子的访问权限。Go没有办法做到这一点。或许应该有，我不知道。</p>
<p>如果我们想添加非同步的原子读写，我们可以向类型化的原子添加UnsyncAdd、UnsyncCompareAndSwap、UnsyncLoad、UnsyncStore和 UnsyncSwap方法。将它们命名为“unsync”避免了一些“relaxed”名称的问题。首先，有些人用relaxed作为相对的比较，如“acquire/release是比顺序一致性更宽松的内存顺序。”你可以说这不是这个术语的恰当用法，但它确实发生了。其次，也是更重要的，这些操作的关键细节不是操作本身的内存排序，而是它们对程序其余部分的同步没有影响。对于不是内存模型专家的人来说，看到UnsyncLoad应该清楚没有同步，而RelaxedLoad可能不会。在人群中喵一眼Unsync也知道它是不安全的。</p>
<p>有了API，真正的问题是到底要不要添加这些。对提供非同步原子的争论是，它确实对某些数据结构中快速路径的性能有影响。我的总体印象是，它在非x86架构上最重要，尽管我没有数据来支持这一点。不提供不同步的原子可以被认为是对那些架构的惩罚。</p>
<p>反对提供非同步原子的一个可能的争论是，在x86上，忽略了潜在的编译器重组的影响，非同步原子与acquire/release原子是无法区分的。因此，他们可能会被滥用来编写只适用于x86的代码。反驳的理由是，这样的花招不会通过race检测器，它实现的是实际的内存模型，而不是x86内存模型。</p>
<p>由于缺乏证据，我们没有理由添加这个API。如果有人强烈认为我们应该添加它，那么证明这一点的方法是收集两方面的证据:(1)程序员需要编写的代码的普遍适用性，以及(2)使用非同步原子对广泛使用的系统产生的显著性能改进。(使用Go以外的语言的程序来显示这一点是很好的。)</p>
<h3 id="文档化对编译器优化的禁止项">文档化对编译器优化的禁止项</h3>
<p>当前的内存模型最后给出了无效程序的例子。由于内存模型是程序员和编译器作者之间的契约，我们应该添加无效编译器优化的例子。例如，我们可以添加:</p>
<h4 id="不正确的编译">不正确的编译</h4>
<p>Go内存模型和Go程序一样限制编译器优化。一些在单线程程序中有效的编译器优化在Go程序中是无效。特别是，编译器不能在无竞争程序中引入数据竞争。它不能允许单次读取观察到多个值。并且它不能允许一个写操作写入多个值。</p>
<p>Not introducing data races into race-free programs means not moving reads or writes out of conditional statements in which they appear. For example, a compiler must not invert the conditional in this program:</p>
<p>不在无竞争程序中引入数据竞争意味着不移动出现条件语句的读或写。例如，编译器不得反转该程序中的条件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i :=<span class="number"> 0</span></div><div class="line"><span class="keyword">if</span> cond {</div><div class="line">	i = *p</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也就是说，编译器不能将程序重写为这个:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i := *p</div><div class="line"><span class="keyword">if</span> !cond {</div><div class="line">	i =<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果cond为false，另一个goroutine正在写*p，那么原始程序是无竞争的，但是重写的程序包含竞争。</p>
<p>不引入数据竞争也意味着不假设循环终止。例如，在这个程序中，编译器不能将对<em>p或</em>q访问移动到循环前面:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">n :=<span class="number"> 0</span></div><div class="line"><span class="keyword">for</span> e := list; e != <span class="constant">nil</span>; e = e.next {</div><div class="line">	n++</div><div class="line">}</div><div class="line">i := *p</div><div class="line">*q =<span class="number"> 1</span></div></pre></td></tr></table></figure>

<p>如果列表指向循环列表，那么原始程序永远不会访问<em>p或</em>q，但是重写的程序会。</p>
<p>不引入数据竞争也意味着不假设被调用的函数总是返回或者没有同步操作。例如，在这个程序中，编译器不能移动对<em>p或</em>q访问到函数调用之前:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f()</div><div class="line">i := *p</div><div class="line">*q =<span class="number"> 1</span></div></pre></td></tr></table></figure>

<p>如果调用从未返回，那么原始程序将不会再访问<em>p或</em>q，但是重写的程序会。如果调用包含同步操作，那么原始程序可以建立f和<em>p/</em>q的happen before关系，但是重写的程序就破坏了这个关系。</p>
<p>不允许单次读取观察多个值,意味着不从共享内存中重新加载局部变量。例如，在这个程序中，编译器不能扔掉(spill)i,并重新加载它:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i := *p</div><div class="line"><span class="keyword">if</span> i &lt;<span class="number"> 0</span> || i &gt;= <span class="built_in">len</span>(funcs) {</div><div class="line">	<span class="built_in">panic</span>(<span class="string">"invalid function index"</span>)</div><div class="line">}</div><div class="line">... <span class="built_in">complex</span> code ...</div><div class="line"><span class="comment">// compiler must NOT reload i = *p here</span></div><div class="line">funcs[i]()</div></pre></td></tr></table></figure>

<p>如果复杂的代码需要许多寄存器，单线程程序的编译器可以在不保存副本的情况下丢弃i，然后在funcs<a href="">i</a>之前重新加载i = <em>p。Go编译器不能，因为</em>p的值可能已经更改。(相反，编译器可能会将i移动到栈上)。</p>
<p>不允许一次写操作写入多个值也意味着不使用在写入之前将本地变量作为临时存储写入的内存。例如，编译器不得在此程序中使用*p作为临时存储:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*p = i + *p<span class="number">/2</span></div></pre></td></tr></table></figure>

<p>也就是说，它绝不能把程序改写成这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p /=<span class="number"> 2</span></div><div class="line">*p += i</div></pre></td></tr></table></figure>

<p>如果i和<em>p开始等于2，则原始代码最终</em>p = 3，但是一个竞争线程只能从<em>p读取2或3。重写后的代码最终</em>p = 1，然后*p = 3，这也允许竞争线程读取1。</p>
<p>请注意，所有这些优化在C/C++编译器中都是允许的:与C/C++编译器共享后端的Go编译器必须注意禁用对Go无效的优化。</p>
<p>这些分类和示例涵盖了最常见的C/C++编译器优化，这些优化与为竞争数据访问定义的语义不兼容。他们明确规定Go和C/C++有不同的要求。</p>
<h2 id="结论">结论</h2>
<p>Go在其内存模型中保守的方法很好地服务了我们，应该继续下去。然而，有一些早该做的更改，包括定义sync和sync/package package中新API的同步行为。特别是atomic的内存模型应该被文档化，其以提供顺序一致的行为，这种行为创建了与它们左右的非原子代码同步的happen before关系。这与所有其他现代系统语言提供的默认原子相匹配。</p>
<p>也许更新中最独特的部分是清楚地声明具有数据竞争的程序可能会被停止以报告竞争，但是在其他方面具有明确定义的语义。这约束了程序员和编译器，它优先考虑并发程序的可调试性和正确性，而不是编译器编写者的便利性。</p>
<h2 id="感谢">感谢</h2>
<p>这一系列的帖子从我有幸在谷歌工作的一长串工程师的讨论和反馈中受益匪浅。我感谢他们。我对任何错误或不受欢迎的意见负全部责任。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Russ Cox的系列论文的第三篇，也是最后一篇: <a href="https://research.swtch.com/gomm" target="_blank" rel="external">Updating the Go Memory Model</a>。</p>
<p>文章对 官方的Go内存模型做了一些补充和思考。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]编程语言内存模型]]></title>
    <link href="https://colobu.com/2021/07/11/Programming-Language-Memory-Models/"/>
    <id>https://colobu.com/2021/07/11/Programming-Language-Memory-Models/</id>
    <published>2021-07-11T12:53:32.000Z</published>
    <updated>2021-10-06T03:29:34.129Z</updated>
    <content type="html"><![CDATA[<p>这是Russ Cox的第二篇<a href="https://research.swtch.com/plmm" target="_blank" rel="external">Programming Language Memory Models</a>。</p>
<p>如果你已经阅读了前一篇<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">硬件内存模型</a>,以及如果有Java内存模型或者C++内存模型的经验，本文还好理解，如果你没有相关经验，可能阅读起来比较费劲，建议先阅读一下相关的材料。论文有些词句比较难以理解，本人才学疏浅，有翻译不当之处欢迎批评指正。</p>
<a id="more"></a>
<p>编程语言内存模型回答了并行程序可以依靠什么行为以便它们的线程之间可以共享内存的问题。例如，考虑下面这个类似C语言的程序，其中x和done都从零开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>程序试图通过变量x从线程1向线程2发送一条消息(x)，使用done作为信号，通知线程2消息已经准备好被接收。如果线程1和线程2都运行在自己的专用处理器上，并且都运行完成，那么这个程序是否保证能够按照预期完成并打印1？编程语言内存模型回答了这个问题，以及其它类似问题。</p>
<p>Although each programming language differs in the details, a few general answers are true of essentially all modern multithreaded languages, including C, C++, Go, Java, JavaScript, Rust, and Swift:</p>
<p>尽管每种编程语言在细节上有所不同，但是一些通用答案基本上适用于所有现代多线程语言，包括C、C++、Go、Java、JavaScript、Rust和Swift:</p>
<ul>
<li>首先，如果x和done是普通变量，那么线程2的循环可能永远不会停止。一种常见的编译器优化是在变量首次使用时将其加载到寄存器中，然后尽可能长时间地重用该寄存器，以便将来访问该变量。如果线程2在线程1执行之前将done复制到一个寄存器中，它可能会在整个循环中一直使用该寄存器，永远不会注意到线程1后来修改了done。</li>
<li>其次，即使线程2的循环会停止，也就是观察到done == 1，它仍然可能打印x的值为0。编译器通常会根据优化试探法甚至是生成代码时使用哈希表或其他中间数据结构的方式，对程序读写进行重新排序。线程1的编译代码可能在done赋值之后而不是之前写入x，或者线程2的编译代码也可能在循环前读取x。</li>
</ul>
<p>既然这个程序有并发问题，那么问题是如何修复它。</p>
<p>现代语言以原子变量(atomic variable)或原子操作(atomic operation)的形式提供特殊能力，允许程序同步其线程。如果我们使用一个原子变量实现done(或者用原子操作来操作它)，那么我们的程序保证会执行完成并打印1。使用原子变量或者原子操作会产生很多效果：</p>
<ul>
<li>线程1的编译代码必须确保对x的写入完成，并且在对done的写入可见之前对x的写入对其他线程可见。</li>
<li>线程2的编译代码必须在循环的每次迭代中(重新)读取done。</li>
<li>线程2的编译代码必须在读取done之后才读取x。</li>
<li>编译后的代码必须做任何必要的事情来禁用可能会重新引入这些问题的硬件优化</li>
<li></li>
</ul>
<p>使done原子化的最终结果是程序按照我们想要的方式运行，成功地将x的值从线程1传递到线程2。</p>
<p>在最初始的程序中，在编译器的代码重新排序之后，线程1可能会在线程2读取x的同时写x。这是data race问题。在修改后的程序中，原子变量done用于同步对x的访问:线程1现在不可能在线程2读取x的同时写入x。这个程序没有数据竞争。一般来说，现代语言保证了无数据竞争的程序总是以顺序一致（sequentially consistent）的方式执行，就好像来自不同线程的操作被随意地但没有重新排序地转移到单个处理器上一样。这是硬件内存模型的<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">DRF-SC属性</a>，在编程语言环境中采用。</p>
<p>另外，这些原子变量或原子操作更恰当应该称之为“同步原子”(synchronizing atomic)，在数据库的意义上，操作是原子的，允许同时进行读和写，就像以某种顺序按顺序运行一样:当使用原子时，普通变量上的竞争不是竞争。但更重要的是，atomic同步了程序的其余部分，提供了一种消除非原子数据竞争的方法。标准术语就是“atomic”，也就是这篇文章使用的属于。除非另有说明，请记住将“原子”理解为“同步原子”。</p>
<p>编程语言内存模型规定了程序员和编译器所需的额外细节，作为他们之间的约定。上面谈到的通用特征基本上适用于所有现代语言，但直到最近，事情才收敛到一点:在21世纪初，有明显更多的变种。即使在今天，各种语言在更多的排序问题上也有显著的差异，包括:</p>
<ul>
<li>原子变量们本身的排序保证是什么？</li>
<li>变量是否既可以原子访问，有可以非原子访问？</li>
<li>除了原子之外是否还有其它同步机制？</li>
<li>是否存在不同步的原子操作？</li>
<li>有数据竞争的程序有什么保证？</li>
</ul>
<p>在做了一些准备之后，这篇文章的剩余部分将探讨不同的语言如何回答这些相关的问题，以及它们解决这些问题之道。这篇文章介绍探索路上的许多错误初始设计，强调我们仍然在学习啥是有效的方案，啥是无效的方案</p>
<h2 id="硬件、Litmus_Tests、Happens_Before_和_DRF-SC">硬件、Litmus Tests、Happens Before 和 DRF-SC</h2>
<p>在我们了解任何特定语言的细节之前，我们需要记住<a href="https://colobu.com/2021/06/30/hwmm/" target="_blank" rel="external">硬件内存模型</a>的简要经验总结。</p>
<blockquote>
<p>不同的CPU体系架构允许不同数量的指令重新排序，因此在多个处理器上并行运行的代码可以根据体系架构的不同有不同的结果。黄金标准是<a href="https://colobu.com/2021/06/30/hwmm/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">顺序一致性</a>，即任何执行都必须表现得好像在不同处理器上执行的程序只是以某种顺序交替在单个处理器上执行。对于开发人员来说，这种模型更容易推理，但是今天没有重要的架构能够提供这种模型，因为提供较弱的并发保证能够足够的性能。</p>
</blockquote>
<p>很难对不同的内存模型做出完全通用的比较。反过来我们可以关注特定的测试用例，称为Litmus Test。如果两个内存模型通过Litmus Test有不同的行为，那么可以证明它们是不同的，并且通常可以帮助我们判断，至少对于那个测试用例，一个模型比另一个模型是弱还是强。例如，这是我们之前检查的程序的Litmus Test:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: <span class="keyword">Message</span> Passing</div><div class="line">Can this <span class="keyword">program</span> see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div><div class="line"><span class="keyword">On</span> sequentially consistent hardware: no.</div><div class="line"><span class="keyword">On</span> x86 (<span class="keyword">or</span> other TSO): no.</div><div class="line"><span class="keyword">On</span> ARM/POWER: yes!</div><div class="line"><span class="keyword">In</span> any modern compiled language using ordinary variables: yes!</div></pre></td></tr></table></figure>

<p>和前一篇文章一样，我们假设每个例子一开始所有共享变量都为零。rN这个名字表示私有存储，如寄存器或函数变量；像x和y这样的名称是共享(全局)变量。我们问在执行结束时，寄存器的特定设置是否存在可能。在回答硬件的litmus test时，我们假设没有编译器对线程中发生的事情进行重新排序:清单中的指令被直接翻译成汇编指令，交给处理器执行。</p>
<p>结果r1 = 1，r2 = 0代表原始程序的线程2完成了循环(这里简化了循环，而是简单的使用y进行赋值)，但随后打印0。这个结果在程序操作的任何顺序一致的交替执行中是不可能的。对于汇编语言版本，在x86上打印0是不可能的，尽管由于处理器本身的重新排序优化，在ARM和POWER等更宽松的架构上打印0是可能的。在现代语言中，编译期间可能发生的重新排序使得这种结果成为可能，不管底层硬件是什么。</p>
<p>正如我们前面提到的，今天的处理器不保证顺序一致性，而是保证一种称为<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">“无数据竞争的顺序一致性”或DRF-DRF(有时也写成SC-DRF)</a>的属性。一个保证DRF-SC的系统必须提供被称为同步指令的特定指令，它提供了一种协调不同处理器(相当于线程)的方法。程序使用这些指令在一个处理器上运行的代码和另一个处理器上运行的代码之间创建一种“happens before”的关系。</p>
<p>例如，这里描述了一个程序在两个线程上的短暂执行；像以前一样，假设每个处理器都有自己的专用处理器:</p>
<p><img src="mem-adve-4.png" alt=""></p>
<p>我们在之前的帖子里也看到了这个程序。线程1和线程2执行同步指令。在这个特定执行中，两条S(a)指令建立了从线程1到线程2的happens-before关系，因此线程1中的W(x)发生在线程2中的R(x)之前。</p>
<p>不同处理器上的两个事件，如果不是按照happens-before的顺序排序，可能会同时发生:确切的顺序搞不清楚。我们说它们同时执行。数据竞争（data race）是指对一个变量的写操作与对同一变量的读操作或写操作同时执行。提供DRF-SC的处理器保证没有数据竞争的程序行为就像它们在一个顺序一致的架构上运行一样。这是在现代处理器上编写正确的多线程汇编程序的基本保证。</p>
<p>正如我们前面所看到的，DRF-SC也是现代语言所采用的基本保证，使得用更高级别语言编写正确的多线程程序成为可能。</p>
<h2 id="编译器和优化">编译器和优化</h2>
<p>我们已经提到过几次，编译器可能会在生成最终可执行代码的过程中对输入程序中的操作重新排序。让我们仔细看看这个声明和其他可能导致问题的优化。</p>
<p>人们普遍认为，编译器几乎可以任意地对普通的内存读写进行重新排序，前提是重新排序不能改变观察到的单线程代码执行的效果。例如，考虑这个程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">w =</span> <span class="number">1</span></div><div class="line"><span class="variable">x =</span> <span class="number">2</span></div><div class="line"><span class="variable">r1 =</span> y</div><div class="line"><span class="variable">r2 =</span> z</div></pre></td></tr></table></figure>

<p>由于w、x、y和z都是不同的变量，这四个语句可以以编译器认为最好的任何顺序执行。</p>
<p>如上所述，如此自由地重新排序读写的能力使得普通编译程序的保证至少和ARM/POWER宽松内存模型一样弱，因为编译程序无法通过消息传递的litmus test。事实上，编译程序的保证更弱。</p>
<p>在上一篇硬件内存模型的文章中，我们将一致性（coherence）看作是ARM/POWER架构所能保证的一个例子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Coherence</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">2</span>, <span class="variable">r3 =</span> <span class="number">2</span>, <span class="variable">r4 =</span> <span class="number">1</span>?</div><div class="line">(Can Thread <span class="number">3</span> see <span class="variable">x =</span> <span class="number">1</span> before <span class="variable">x =</span> <span class="number">2</span> while Thread <span class="number">4</span> sees the reverse?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">x =</span> <span class="number">2</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> x</div><div class="line">                              <span class="variable">r2 =</span> x         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div><div class="line">On ARM/POWER: no.</div><div class="line">In any modern compiled language using ordinary variables: yes!</div></pre></td></tr></table></figure>

<p>所有现代硬件都保证一致性，这也可以看作是对单个存储单元的操作的顺序一致性。在这个程序中，一个写操作必须覆盖另一个，并且整个系统必须就哪个是哪个达成一致。事实证明，由于编译过程中程序的重新排序，现代语言甚至不能提供一致性。</p>
<p>假设编译器对线程4中的两次读取进行了重新排序，然后指令按照以下顺序交替运行:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line">                                             // (reordered)</div><div class="line">(<span class="number">1</span>) <span class="variable">x =</span> <span class="number">1</span>                     (<span class="number">2</span>) <span class="variable">r1 =</span> x     (<span class="number">3</span>) <span class="variable">r4 =</span> x</div><div class="line">               (<span class="number">4</span>) <span class="variable">x =</span> <span class="number">2</span>      (<span class="number">5</span>) <span class="variable">r2 =</span> x     (<span class="number">6</span>) <span class="variable">r3 =</span> x</div></pre></td></tr></table></figure>

<p>结果r1 = 1，r2 = 2，r3 = 2，r4 = 1 在汇编程序中是不可能的，但在高级语言中是可能的。从这个意义上说，编程语言内存模型都比最宽松的硬件内存模型都弱。</p>
<p>但是有一些保证。每个人都同意需要提供DRF-SC，它不允许引入新的读或写的优化，即使这些优化在单线程代码中是有效的。</p>
<p>例如，考虑下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(c) {</div><div class="line">	x++;</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	... lots of code ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有一个if语句，在else中有很多代码，在if主体中只有一个x++。拥有更少的分支并彻底消除if体可能更快。如果我们编写代码有问题，我们可以在if之前运行了x++,然后在else中用x--进行调整。也就是说，编译器可能会考虑将该代码重写为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x++;</div><div class="line"><span class="keyword">if</span>(!c) {</div><div class="line">	x--;</div><div class="line">	... lots of code ...</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是安全的编译器优化吗？在单线程程序中，是的。在一个多线程程序中，当c为false时，x与另一个线程共享，答案是否: 优化会在x上引入一个原始程序中没有的数据</p>
<p>这个例子来源于Hans Boehm 2004年的论文<a href="https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf" target="_blank" rel="external">Threads Cannot Be Implemented As a Library</a>中的一个例子，它说明了语言不能对多线程执行的语义保持沉默。</p>
<p>编程语言内存模型试图精确回答这些问题，即哪些优化是允许的，哪些是不允许的。通过研究过去几十年来尝试编写这些模型的历史，我们可以了解哪些可行，哪些不可行，并了解事情的发展方向。</p>
<h2 id="原始的Java内存模型_(1996)">原始的Java内存模型 (1996)</h2>
<p>Java是第一个试图写下多线程程序保证的主流语言。它包括互斥体(mutex)，并定义了它们隐含的内存排序要求。它还包括“volatile”原子变量: volatile变量的所有读和写都需要直接在主内存中按程序顺序执行，使得对volatile变量的操作以顺序一致的方式进行。最后，Java制定了(或者至少试图制定)具有数据竞争的程序的行为。其中的一部分是为普通变量规定一种一致性的形式，我们将在下面详细讨论。不幸的是，在Java语言规范(1996)的第一版中，这种尝试至少有两个严重的缺陷。凭借后见之明和我们已经做好的准备，它们很容易解释。当时，它们远没有那么明显被发现。</p>
<h3 id="Atomic_需要同步">Atomic 需要同步</h3>
<p>第一个缺陷是volatile原子变量是不同步的，所以它们无助于消除程序其余部分的竞争。我们在上面看到的消息传递程序的Java版本是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> done;</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>因为done被声明为volatile，所以循环肯定会结束: 编译器不能将它缓存在寄存器中并导致无限循环。但是，程序不能保证打印1。编译器没有被禁止重新排序对x和done的访问，也没有被要求禁止硬件做同样的事情。</p>
<p>因为Java volatile是非同步原子，所以您不能使用它们来构建新的同步原语。从这个意义上说，最初的Java内存模型太弱了。</p>
<h3 id="一致性与编译器优化不兼容">一致性与编译器优化不兼容</h3>
<p>初的Java内存模型也太强了: 强制一致性 —— 一旦线程读取了内存位置的新值，它就不能再读取旧值——不允许基本的编译器优化。前面我们讨论了重新排序读操作会如何破坏一致性，但是你可能会想，好吧，不要重新排序读操作。这里有一个更微妙的方法，可以通过另一个优化来打破一致性:公共子表达式消除。考虑一下这个Java程序:</p>
<p>考虑一下这个Java程序:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// p and q may or may not point at the same object.</span></div><div class="line"><span class="keyword">int</span> i = p.x;</div><div class="line"><span class="comment">// ... maybe another thread writes p.x at this point ...</span></div><div class="line"><span class="keyword">int</span> j = q.x;</div><div class="line"><span class="keyword">int</span> k = p.x;</div></pre></td></tr></table></figure>

<p>在这个程序中，公共子表达式消除(common subexpression elimination)会注意到p.x被计算了两次，并将最后一行优化为k = i。但是，如果p和q指向同一个对象，并且另一个线程在读入I和j之间向p.x写入，那么为k重用旧值i违反了一致性:读入i看到了旧值，读入j看到了新值，但是读入k重用i会再次看到旧值。不能优化掉冗余读取会阻碍大多数编译器，使生成的代码变慢。</p>
<p>硬件比编译器更容易提供一致性，因为硬件可以应用动态优化:它可以根据给定内存读写序列中涉及的确切地址来调整优化路径。相比之下，编译器只能应用静态优化:无论涉及什么地址和值，它们都必须提前写出正确的指令序列。在这个例子中，编译器不能根据p和q是否碰巧指向同一个对象来轻易改变发生的事情，至少在没有为这两种可能性写出代码的情况下不能，这导致了大量的时间和空间开销。编译器对内存位置之间可能存在的别名不完全了解意味着：实际上要实现一致性就需要放弃基本的优化。</p>
<p>Bill Pugh在他1999年的论文<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.17.7914&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">修复Java内存模型</a>中指出了这个问题和其他问题.</p>
<h2 id="新的Java内存模型_(2004)">新的Java内存模型 (2004)</h2>
<p>由于这些问题，并且因为最初的Java内存模型甚至对于专家来说都很难理解，Pugh和其他人开始努力为Java提供一个新的内存模型。该模型后来成为JSR-133，并在2004年发布的Java 5.0中被采用。规范参考是Jeremy Manson, Bill Pugh和Sarita Adve的<a href="http://rsim.cs.uiuc.edu/Pubs/popl05.pdf" target="_blank" rel="external">Java内存模型(2005)</a>，Jeremy Manson的博士论文中有更多细节。新模型遵循DRF-SC方法:保证无数据竞争的Java程序以顺序一致的方式执行。</p>
<h3 id="同步原子和其它操作">同步原子和其它操作</h3>
<p>正如我们前面看到的，要编写一个无数据竞争的程序，程序员需要同步操作，这些同步操作可以建立happens-before关系，以确保一个线程不会在另一个线程读取或写入非原子变量的同时写入该变量。在Java中，主要的同步操作有:</p>
<ul>
<li>线程的创建发生在(happen before)它的第一个动作之前</li>
<li>mutex m的unlock发生在m的后续lock之前</li>
<li>写volatile变量v发生在后续读取v之前</li>
<li></li>
</ul>
<p>“subsequent”(“后续”)`是什么意思？Java定义了所有锁、解锁和volatile变量访问的行为，就好像它们发生在一些顺序一致的中断中，给出了整个程序中所有这些操作的总顺序。“后续”是指总顺序中的较晚执行。也就是说:锁、解锁和volatile变量访问的总顺序定义了后续的含义，然后后续定义了特定执行创建了happen before关系，然后happend before关系定义了该特定执行是否有数据竞争。如果没有数据竞争，那么执行就会以顺序一致的方式进行。</p>
<p>事实上， volatile访问必须表现得好像在某种总排序中一样，这意味着在<a href="https://research.swtch.com/hwmm#x86" target="_blank" rel="external">存储缓冲区litmus test</a>中，不能出现r1 = 0和r2 = 0的结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Store Buffering</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">0</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): yes!</div><div class="line">On ARM/POWER: yes!</div><div class="line">On Java using volatiles: no.</div></pre></td></tr></table></figure>

<p>在Java中，对于volatile变量x和y，读取和写入不能被重新排序:一个写入必须排在第二位，第二个写入之后的读取必须看到第一个写入。如果我们没有顺序一致的要求——比如说，如果只要求volatile是一致的——两次读取可能会错过写入。</p>
<p>这里有一个重要但微妙的点:所有同步操作的总顺序与happen-before关系是分开的。在程序中的每个锁、解锁或volatile变量访问之间，在一个方向或另一个方向上不存在happen-before关系:从写入到观察写入的读取，您只获得了happen-before的关系。例如，不同互斥体的锁定和解锁之间没有happen-before关系。</p>
<h3 id="有数据竞争的程序的语义">有数据竞争的程序的语义</h3>
<p>DRF-SC只保证没有数据竞争的程序的顺序一致行为。新的Java内存模型和最初的一样，定义了有数据竞争的程序的行为，原因有很多:</p>
<ul>
<li>支持Java的一般安全（security）和安全保障（safety guarantee）。</li>
<li>让程序员更容易发现错误。</li>
<li>使攻击者更难利用问题，因为由于数据竞争的原因可能造成的损失更有限。</li>
<li>让程序员更清楚他们的程序是做什么的。</li>
</ul>
<p>新模型不再依赖于一致性，而是重新使用了happens-before关系(已经用来决定程序是否有竞争)来决定竞争读写的结果。</p>
<p>Java的具体规则是，对于word大小或更小的变量，对变量(或字段)x的读取必须看到对x的某一次写入所存储的值。如果读取r观察到对x的写入w，那么r不发生在w之前。这意味着r可以观察发生在r之前的所有写入，并且它可以观察与r竞争的写入。</p>
<p>使用happens-before，结合同步原子(volatile)就可以建立新的happen before关系，是对原始Java内存模型的重大改进。它为程序员提供了更多有用的保证，并使大量重要的编译器优化得到了明确的允许。这个模型至今仍然是Java的内存模型。也就是说，这仍然是不完全正确的:在试图定义竞争程序的语义时，使用before-before是有问题的。</p>
<h3 id="happen-before不排除语无伦次(incoherence)">happen-before不排除语无伦次(incoherence)</h3>
<p>定义程序语义的“happen-before”关系的第一个问题与一致性有关(有一次!).(以下例子摘自Jaroslav Ševčík 和 David Aspinall的论文<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.112.1790&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">《论Java内存模型中程序转换的有效性》(2007年)</a>)。)</p>
<p>这里有一个三线程的程序。让我们假设线程1和线程2已知在线程3开始之前完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2           // Thread 3</span></div><div class="line">lock(m1)              lock(m2)</div><div class="line">x = <span class="number">1</span>                 x = <span class="number">2</span></div><div class="line">unlock(m1)            unlock(m2)</div><div class="line">                                            lock(m1)</div><div class="line">                                            lock(m2)</div><div class="line">                                            r1 = x</div><div class="line">                                            r2 = x</div><div class="line">                                            unlock(m2)</div><div class="line">                                            unlock(m1)</div></pre></td></tr></table></figure>

<p>线程1在持有mutex m1时写入x = 1。线程2在持有 mutex m2时写入x = 2。这些是不同的mutex，所以两个写操作是竞争的。然而，只有线程3读取x，并且它是在获取两个mutex后读取的。对r1的读取可以是读也可以是写:两者都发生在它之前，并且都不会完全覆盖另一个。通过相同的参数，读入r2可以读或写。但是严格来说，Java内存模型中没有任何东西说两次读取必须一致：从技术上讲，r1和r2可以读取不同的x值。也就是说，这个程序可以以r1和r2持有不同的值结束。当然，没有真正的实现会产生不同的r1和r2。互斥意味着这两次读取之间没有写操作发生。他们必须得到相同的值。但是内存模型允许不同读取值的事实表明，从某种技术角度来说，它并没有精确地描述真实的Java实现。</p>
<p>情况变得更糟。如果我们在两个读数之间再加一个指令，x = r1，会怎么样:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Thread 1           // Thread 2           // Thread 3</div><div class="line"><span class="operator"><span class="keyword">lock</span>(m1)              <span class="keyword">lock</span>(m2)</span></div><div class="line">x = <span class="number">1</span>                 x = <span class="number">2</span></div><div class="line"><span class="keyword">unlock</span>(m1)            <span class="keyword">unlock</span>(m2)</div><div class="line">                                            <span class="keyword">lock</span>(m1)</div><div class="line">                                            <span class="keyword">lock</span>(m2)</div><div class="line">                                            r1 = x</div><div class="line">                                            x = r1   // !?</div><div class="line">                                            r2 = x</div><div class="line">                                            <span class="keyword">unlock</span>(m2)</div><div class="line">                                            <span class="keyword">unlock</span>(m1)</div></pre></td></tr></table></figure>

<p>很明显，r2 = x读数必须使用x = r1写的值，因此程序必须在r1和r2中获得相同的值。两个值r1和r2现在保证相等。</p>
<p>这两个程序之间的差异意味着我们在编译器方面有问题。看到r1 = x后跟着x = r1时编译器很可能想要删除第二个赋值，这“显然”是多余的。但这种“优化”将第二个程序(r1和r2的值必须相同)变成了第一个程序(从技术上讲，r1可能不同于r2)。因此，根据Java内存模型，这种优化在技术上是无效的:它改变了程序的含义。明确地说，这种优化不会改变在任何你能想象的真实JVM上执行的Java程序的意义。但不知何故，Java内存模型不允许这样做，这表明还有更多需要说的。</p>
<p>有关这个例子和其他例子的更多信息，请参见evík和Aspinall的论文。</p>
<h2 id="以前发生的事不排除无用性（acausality）">以前发生的事不排除无用性（acausality）</h2>
<p>最后一个例子证明是个简单的问题。这里有一个更难的问题。考虑这个litmus test，使用普通的(非volatile)Java变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Racy Out Of Thin Air Values</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">42</span>, r2 = <span class="number">42</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">r1 = x                r2 = y</div><div class="line">y = r1                x = r2</div><div class="line">(Obviously not!)</div></pre></td></tr></table></figure>

<p>这个程序中的所有变量都像往常一样从零开始，然后这个程序在一个线程中有效地运行y = x，在另一个线程中运行x = y。x和y最终能变成42吗？在现实生活中，显然不能。但为什么不呢？内存模型并没有否定这个结果。</p>
<p>假设“r1 = x”的读数是42。那么“y = r1”会将42写入y，然后竞争“r2 = y”会读取42，导致“x = r2”写入42到x，且write与原始“r1 = x”竞争(因此可被原始“r1 = x”观察到)，看起来证明原始假设是正确的。在这个例子中，42被称为无中生有的值，因为它看起来没有任何理由，但随后用循环逻辑证明了自己。如果内存在当前的0之前曾经持有42，而硬件错误地推测它仍然是42，会怎么样？这种猜测可能会成为一个自我实现的预言。(在Spectre和相关攻击显示出硬件是如何不断进步的之前，这个论点似乎更加牵强。即便如此，没有一种硬件是这样凭空创造值的。)</p>
<p>很明显，这个程序不能以r1和r2设置为42结束，但是happens-before本身并不能解释为什么不能这样做。这再次表明存在某种不完整性。新的Java内存模型花费了大量时间来解决这种不完整性，稍后将对此进行更详细的描述。</p>
<p>这个程序有一个竞争——x和y的读取与其他线程中的写入竞争——所以我们可能会继续认为它是一个不正确的程序。但是这里有一个没有数据竞争的版本:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Litmus <span class="keyword">Test</span>: Non-Racy <span class="keyword">Out</span> Of Thin Air Values</div><div class="line">Can this program see <span class="literal">r1</span> = <span class="number">42</span>, <span class="literal">r2</span> = <span class="number">42</span>?</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>           // Thread <span class="number">2</span></div><div class="line"><span class="literal">r1</span> = x                <span class="literal">r2</span> = y</div><div class="line">if (<span class="literal">r1</span> == <span class="number">42</span>)         if (<span class="literal">r2</span> == <span class="number">42</span>)</div><div class="line">    y = <span class="literal">r1</span>                x = <span class="literal">r2</span></div><div class="line">(Obviously <span class="keyword">not</span>!)</div></pre></td></tr></table></figure>

<p>由于x和y从零开始，任何顺序一致的执行都不执行写操作，所以这个程序没有写操作，所以没有竞争。不过，同样，仅happen-before并不排除这样的可能性，假设r1 = x看到竞争不是write，然后根据这个假设，两个条件最终都为真，x和y最终都是42。这是另一种无中生有的价值，但这一次是在没有竞争的程序中。任何保证DRF-SC的模型都必须保证这个程序只在末尾看到全零，然而happens-before并没有解释为什么。</p>
<p>Java内存模型花了很多我不想赘述的话来试图排除这些类型的假设。不幸的是，五年后，Sarita Adve and Hans Boehm对这个内存模型有这样的评价:</p>
<blockquote>
<p>Prohibiting such causality violations in a way that does not also prohibit other desired optimizations turned out to be surprisingly difficult. … After many proposals and five years of spirited debate, the current model was approved as the best compromise. … Unfortunately, this model is very complex, was known to have some surprising behaviors, and has recently been shown to have a bug.</p>
<p>以一种不妨碍其他期望的优化的方式来禁止这种因果关系冲突，结果令人惊讶地难以实现。……经过许多提议和五年的激烈辩论，目前的模式被认为是最好的折衷方案。……不幸的是，这个模型非常复杂，已知有一些令人惊讶的缺点，最近被证明有一个错误。</p>
</blockquote>
<p>(Adve 和 Boehm, <a href="https://cacm.acm.org/magazines/2010/8/96610-memory-models-a-case-for-rethinking-parallel-languages-and-hardware/fulltext" target="_blank" rel="external">“Memory Models: A Case For Rethinking Parallel Languages and Hardware,”</a> August 2010)</p>
<h2 id="C++11_内存模型_(2011)">C++11 内存模型 (2011)</h2>
<p>让我们把Java放在一边，研究C++。受Java新内存模型明显成功的启发，许多同样的人开始为C++定义一个类似的内存模型，最终在C++11中采用。与Java相比，C++在两个重要方面有所不同。首先，C++对具有数据竞争的程序不做任何保证，这似乎消除了对Java模型复杂性的需求。其次，C++提供了三种原子性:强同步(“顺序一致”)、弱同步(“acquire/release”,、coherence-only)和无同步(“relaxed”，用于隐藏竞争)。“relaxed”的原子性重新引入了Java关于定义什么是竞争程序的所有复杂性。结果是C++模型比Java更复杂，但对程序员的帮助更小。</p>
<p>C++11还定义了原子栅栏作为原子变量的替代，但是它们并不常用，我不打算讨论它们。</p>
<h3 id="DRF-SC_还是_着火(Catch_Fire）">DRF-SC 还是 着火(Catch Fire）</h3>
<p>与Java不同，C++没有给有竞争的程序任何保证。任何有竞争的程序都属于<a href="https://blog.regehr.org/archives/213" target="_blank" rel="external">“未定义的行为”</a>。允许在程序执行的最初几微秒内进行竞争访问，从而在几小时或几天后导致任意的错误行为。这通常被称为“DRF-SC或着火”:如果程序没有数据竞争，它以顺序一致的方式运行，如果有数据竞争，它可以做任何事情，包括着火。</p>
<p>关于DRF-SC或Catch Fire的论点的更详细的介绍，参见Boehm，<a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2176.html#undefined" target="_blank" rel="external">“内存模型原理”(2007)</a> 和Boehm和Adve，<a href="https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf" target="_blank" rel="external">“C++并发内存模型的基础”(2008)</a>。</p>
<p>简而言之，这中情况有四个正当理由:</p>
<p>Briefly, there are four common justifications for this position:</p>
<ul>
<li>C和C++已经充斥着未定义的行为，这是编译器优化横行的语言小角落，用户最好不要迟疑。多一个未定义行为又有多大的坏处？</li>
<li>现有的编译器和库编写时没有考虑线程，以任意方式破坏了有竞争的程序。找到并修复所有的问题太难了，或者这个争论没有了，尽管还不清楚那些不固定的编译器和库是如何应对宽松的原子的。</li>
<li>真正知道自己在做什么并希望避免未定义行为的程序员可以使用relaxed的原子。</li>
<li>不定义竞争语义允许实现检测和诊断竞争并停止执行。</li>
</ul>
<p>就我个人而言，最后一个理由是我认为唯一有说服力的，尽管我认为这个意思是说“允许使用竞争检测器”，而不是说“一个整数的竞争会使整个程序无效。”</p>
<p>这里有一个来自“内存模型原理”的例子，我认为它抓住了C++方法的本质以及它的问题。考虑这个程序，它引用了一个全局变量x。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> i = x;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (i &lt; <span class="number">2</span>) {</div><div class="line">	foo: ...</div><div class="line">	<span class="keyword">switch</span> (i) {</div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">		...;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">		...;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>据称，C++编译器可能会将i保存在寄存器中，但如果标签foo处的代码很复杂，则需要重用这些寄存器。而不是转移i当前的值到栈上， 编译器可能会决定在到达switch语句时，再次从全局x加载i。结果是，在if体中，i &lt; 2可能不再为真。如果编译器使用由i索引的表将开关编译成计算跳转，那么代码将从表的末尾索引并跳转到一个意外的地址，这可能非常糟糕。</p>
<p>从这个例子和其他类似的例子中，C++内存模型的作者得出结论，任何有竞争的访问都必须被允许对程序的未来执行造成无限的损害。我个人的结论是，在多线程程序中，编译器不应该认为它们可以通过重新执行初始化局部变量的内存读取来重新加载像i这样的局部变量。指望为单线程世界编写的现有C++编译器找到并修复像这样的代码生成问题可能是不切实际的，但是在新的语言中，我认为我们应该有更高的目标。</p>
<h3 id="题外话,_C/C++的未定义行为">题外话, C/C++的未定义行为</h3>
<p>另外，C和C++坚持编译器对程序中的错误行为进行任意的行为的能力导致了真正荒谬的结果。例如，考虑这个程序，这是2017在推特上讨论的话题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (*Function)();</div><div class="line"></div><div class="line"><span class="keyword">static</span> Function Do;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> EraseAll() {</div><div class="line">	<span class="keyword">return</span> system(<span class="string">"rm -rf slash"</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> NeverCalled() {</div><div class="line">	Do = EraseAll;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main() {</div><div class="line">	<span class="keyword">return</span> Do();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你是一个像Clang这样的现代C++编译器，你可能会想到这个程序如下：</p>
<ul>
<li>很明显，main函数中，Do要么为空，要么为EraseAll。</li>
<li>如果Do是Erasell，那么Do()与Erasell()相同。</li>
<li>如果Do 是null, 那么Do()是未定义行为。我可以随意实现，包括作为EraseAll()无条件实现。</li>
<li>因此，我可以将间接调用Do()优化为直接调用EraseAll()。</li>
<li>当我处理这里的时候，我可能直接内联EraseAll。</li>
</ul>
<p>最终结果是，Clang将程序优化为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main() {</div><div class="line">	<span class="keyword">return</span> system(<span class="string">"rm -rf slash"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你必须承认:前一个例子，局部变量i可能在if (i &lt; 2)体的中途突然停止小于2的可能性似乎并不合适。</p>
<p>本质上，现代C和C++编译器假设没有程序员敢尝试未定义的行为。一个程序员写一个有bug的程序？不可思议！</p>
<p>就像我说的，在新的语言中，我认为我们应该有更高的目标。</p>
<h3 id="Acquire/release_atomic">Acquire/release atomic</h3>
<p>C++采用了顺序一致的原子变量，很像(新的)Java的volatile变量(与C++ volatile没有关系)。在我们的消息传递示例中，我们可以将done声明为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atomic&lt;<span class="keyword">int</span>&gt; done;</div></pre></td></tr></table></figure>

<p>然后像使用普通变量一样使用done，就像在Java中一样。或者我们可以把一个普通的整型变量去掉。然后使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atomic_store(&done, <span class="number">1</span>);</div></pre></td></tr></table></figure>

<p>和：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(atomic_load(&<span class="keyword">done</span>) == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div></pre></td></tr></table></figure>

<p>去访问它。</p>
<p>无论哪种方式，完成的操作都参与原子操作的顺序一致的总顺序，并同步程序的其余部分。</p>
<p>C++还添加了较弱的原子，可以使用atomic_store_explicit和atomic_load_explicit以及附加的memory排序参数来访问这些原子。使用memory_order_seq_cst使显式调用等效于上面较短的调用。</p>
<p>较弱的原子称为acquire/release原子，一个release如果被后来的acquire观察到，那么就创建了一个happen-before的关系(从release到acquire)。这个术语意在唤起mutex:release就像unlock mutex，acquire就像lock同一个mutex。release之前执行的写入必须对后续acquire之后执行的读取可见，就像unlock mutex之前执行的写入必须对后来unlock mutex之后执行的读取可见一样。</p>
<p> The terminology is meant to evoke mutexes: release is like unlocking a mutex, and acquire is like locking that same mutex. The writes executed before the release must be visible to reads executed after the subsequent acquire, just as writes executed before unlocking a mutex must be visible to reads executed after later locking that same mutex.</p>
<p>为了使用较弱的原子，我们可以将消息传递示例改为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atomic_store(&done, <span class="number">1</span>, memory_order_release);</div></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(atomic_load(&done, memory_order_acquire) == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div></pre></td></tr></table></figure>

<p>它仍然是正确的。但不是所有的程序都会这样</p>
<p>回想一下，顺序一致的原子要求程序中所有原子的行为与执行的一些全局交替执行(全局顺序)一致。acquire/release原子不会。它们只需要对单个内存位置的操作进行顺序一致的交替执行。也就是说，它们只需要一致性。结果是，一个使用具有多个存储位置的acquire/release原子的程序可能会观察到无法用程序中所有acquire/release原子的顺序一致的交替来解释的执行，这可以说是违反了DRF-SC！</p>
<p>为了说明不同之处，这里再举一个存储缓冲区的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Store Buffering</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">0</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): yes!</div><div class="line">On ARM/POWER: yes!</div><div class="line">On Java (<span class="keyword">using</span> volatiles): no.</div><div class="line">On C++<span class="number">11</span> (sequentially consistent atomics): no.</div><div class="line">On C++<span class="number">11</span> (acquire/release atomics): yes!</div></pre></td></tr></table></figure>

<p>C++顺序一致的原子与Java的volatile相匹配。但是acquire-release原子在x的顺序和y的顺序之间没有强加任何关系。特别地，允许程序表现得好像r1 = y发生在y = 1之前，而同时r2 = x发生在x = 1之前，使得r1 = 0，r2 = 0与整个程序的顺序一致性相矛盾。为什么要引入这些较弱的获取/发布原子？可能是因为它们是x86上的普通内存操作。</p>
<p>请注意，对于观察特定写入的一组给定的特定读取，C++顺序一致原子和C++ acquire/release原子创建相同的happen-before关系。它们之间的区别在于，顺序一致的原子不允许观察特定写入的某些特定读取集，但acuqire/release原子允许这些特定读取集。一个这样的例子是导致存储缓冲测试出现r1 = 0，r2 = 0的结果。</p>
<p>acquire/release原子在实践中不如提供顺序一致性的原子有用。这里有一个例子。假设我们有一个新的同步原语，一个具有通知和等待两种方法的一次性条件变量。为了简单起见，只有一个线程会调用Notify，只有一个线程会调用Wait。我们想安排Notify在另一个线程还没有等待的时候是无锁的。我们可以用一对原子整数来实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Cond {</div><div class="line">	atomic&lt;<span class="keyword">int</span>&gt; done;</div><div class="line">	atomic&lt;<span class="keyword">int</span>&gt; waiting;</div><div class="line">	...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> Cond::notify() {</div><div class="line">	done = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (!waiting)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="comment">// ... wake up waiter ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Cond::wait() {</div><div class="line">	waiting = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(done)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="comment">// ... sleep ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码的重要部分是在检查waiting之前notify设置done为1, 为wait在检查done之前设置waiting为1,因此并发调用notify和wait不会导致notify立即返回并等待休眠。但是使用C++ acquire/release原子，它们可以。而且它们可能只需要很少的几率发生，使得这种错误很难重现和诊断。(更糟糕的是，在像64位ARM这样的一些架构上，实现acquire/release原子的最佳方式是顺序一致的原子，因此您可能会编写在64位ARM上运行良好的代码，但在移植到其他系统时才发现它是不正确的。)</p>
<p>基于这种理解，“acquire/release”对于这些原子来说是一个不幸的名字，因为顺序一致的原子做同样的acquire和release。不同之处在于顺序一致性的丧失。称这些为“一致性”原子可能更好。太迟了。</p>
<h3 id="Relaxed_atomic">Relaxed atomic</h3>
<p>C++并没有仅仅停留在连贯的获取/发布原子上。它还引入了非同步原子，称为relaxed原子。这些原子根本没有同步效果——它们没有创建先发生的边——并且它们根本没有排序保证。事实上，宽松原子读/写和普通读/写没有区别，除了宽松原子上的竞争不被认为是竞争，不能着火。</p>
<p>C++没有停止与仅仅提供一致性的acquire/release原子。它还引入了非同步原子，称为relaxed原子(memory_order_relaxed)。这些原子根本没有同步效果——它们没有创建happens-before关系——并且它们根本没有排序保证。事实上，relaxed原子读/写和普通读/写没有区别，除了relaxed原子上的竞争不被认为是竞争，不能着火。</p>
<p>修改后的Java内存模型的大部分复杂性来自于定义具有数据竞争的程序的行为。如果C++采用DRF-SC或Catch Fire——实际上不允许有数据竞争的程序——意味着我们可以扔掉前面看到的所有奇怪的例子，那么C++语言规范将比Java语言规范更简单，那就太好了。不幸运的是，包括releaxed的原子最终保留了所有这些关注，这意味着C++11规范最终并不比Java简单。</p>
<p>像Java的内存模型一样，C++11的内存模型最终也是不正确的。考虑之前的无数据竞争计划:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Non-Racy Out Of Thin Air Values</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">42</span>, r2 = <span class="number">42</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">r1 = x                r2 = y</div><div class="line"><span class="keyword">if</span> (r1 == <span class="number">42</span>)         <span class="keyword">if</span> (r2 == <span class="number">42</span>)</div><div class="line">    y = r1                x = r2</div><div class="line">(Obviously not!)</div><div class="line"></div><div class="line">C++<span class="number">11</span> (ordinary variables): no.</div><div class="line">C++<span class="number">11</span> (relaxed atomics): yes!</div></pre></td></tr></table></figure>

<p>Viktor Vafeiadis和其他人在他们的论文<a href="https://fzn.fr/readings/c11comp.pdf" target="_blank" rel="external">“Common Compiler Optimisations are Invalid in the C11 Memory Model and what we can do about it” (2015)</a>中表明，C++11规范保证当x和y是普通变量时，该程序必须以x和y设置为零结束。但是如果x和y是relaxed的原子，那么，严格来说，C++11规范不排除r1和r2最终都可能达到42。(惊喜！)</p>
<p>详情见论文，但在较高的层次上，C++11规范有一些正式规则，试图禁止无中生有的值，并结合了一些模糊的词语来阻止其他类型的有问题的值。这些正式的规则就是问题所在，因此C++14放弃了它们，只留下了模糊的词语。引用删除它们的基本原理，C++11公式证明是“既不充分的，因为它使人们基本上无法对内存顺序放松的程序进行推理，也严重有害，因为它可以说不允许在ARM和POWER等体系结构上对memory_order_relaxed的所有合理实现。”</p>
<p>综上所述，Java试图正式排除所有不合法的执行，但失败了。然后，借助Java的后知后觉，C++11试图正式地只排除一些不合法的执行，也失败了。C++14然后说什么都不正式。这不是正确的方向。</p>
<p>事实上，Mark Batty和其他人在2015年发表的一篇题为<a href="https://www.cl.cam.ac.uk/~jp622/the_problem_of_programming_language_concurrency_semantics.pdf" target="_blank" rel="external">“编程语言并发语义的问题”</a>的论文给出了这一发人深省的评估:</p>
<blockquote>
<p>Disturbingly, 40+ years after the first relaxed-memory hardware was introduced (the IBM 370/158MP), the field still does not have a credible proposal for the concurrency semantics of any general-purpose high-level language that includes high-performance shared-memory concurrency primitives.</p>
<p>令人不安的是，在引入第一个relaxed内存硬件(IBM 370/158MP)40多年后，该领域仍然没有一个可信的提案来描述任何包含高性能共享内存并发原语的通用高级语言的并发语义。</p>
</blockquote>
<p>甚至定义弱有序硬件的语义(忽略软件和编译器优化的复杂性)也不太顺利。张思卓等人在2018年发表的一篇名为<a href="https://arxiv.org/abs/1805.07886" target="_blank" rel="external">《构建弱记忆模型》</a>的论文讲述了最近发生的一些事情:</p>
<blockquote>
<p>Sarkar et al. published an operational model for POWER in 2011, and Mador-Haim et al. published an axiomatic model that was proven to match the operational model in 2012. However, in 2014, Alglave et al. showed that the original operational model, as well as the corresponding axiomatic model, ruled out a newly observed behavior on POWER machines. For another instance, in 2016, Flur et al. gave an operational model for ARM, with no corresponding axiomatic model. One year later, ARM released a revision in their ISA manual explicitly forbidding behaviors allowed by Flur&#39;s model, and this resulted in another proposed ARM memory model. Clearly, formalizing weak memory models empirically is error-prone and challenging.</p>
<p>Sarkar等人在2011年公布了POWER的运行模型，Mador-Haim等人在2012年公布了一个公理化模型，该模型被证明与运行模型相匹配。然而，在2014年，Alglave等人表明，最初的操作模型以及相应的公理模型排除了在POWER机器上新观察到的行为。再比如，2016年，Flur等人给出了一个ARM的操作模型，没有对应的公理模型。一年后，ARM在他们的ISA手册中发布了一个修订版，明确规定了Flur模型允许的行为，这导致了另一个提出的ARM内存模型。显然，根据经验形式化弱记忆模型是容易出错且具有挑战性的。</p>
</blockquote>
<p>在过去的十年里，致力于定义和形式化所有这些的研究人员非常聪明、有才华和坚持不懈，我并不想通过指出结果中的不足来贬低他们的努力和成就。我从这些简单的结论中得出结论，这个指定线程程序的确切行为的问题，即使没有竞争，也是难以置信的微妙和困难。如今，即使是最优秀、最聪明的研究人员似乎也无法理解这一点。即使不是，编程语言定义在日常开发人员可以理解的情况下效果最好，而不需要花费十年时间研究并发程序的语义。</p>
<h2 id="C,_Rust_和_Swift_的内存模型">C, Rust 和 Swift 的内存模型</h2>
<p>C11也采用了C++11内存模型，使其成为C/C++11内存模型。</p>
<p>2015年的<a href="https://doc.rust-lang.org/std/sync/atomic/" target="_blank" rel="external">Rust 1.0.0</a>和2020年的<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0282-atomics.md" target="_blank" rel="external">Swift 5.3</a>都整体采用了C/C++内存模型，拥有DRF-SC或Catch Fire以及所有的原子类型和原子栅栏。</p>
<p>毫不奇怪，这两种语言都采用了C/C++ 模型，因为它们建立在C/C++编译器工具链(LLVM)上，并强调与C/C++代码的紧密集成。</p>
<h3 id="硬件题外话：_有效的顺序一致性atomic">硬件题外话： 有效的顺序一致性atomic</h3>
<p>早期的多处理器体系结构有多种同步机制和内存模型，具有不同程度的可用性。在这种多样性中，不同同步抽象的效率取决于它们如何映射到架构所提供的内容。为了构造顺序一致的原子变量的抽象，有时唯一的选择是使用比严格必要的要多得多、贵得多的内存栅栏barriers，特别是在ARM和POWER上。</p>
<p>随着C、C++和Java都提供了这种顺序一致性同步原子的抽象，硬件设计者就应该让这种抽象变得高效。ARMv8架构(32位和64位)引入了ldar和stlr load和store指令，提供了直接的实现。在2017年的一次谈话中，赫伯·萨特声称，IBM已经批准了他的说法，他们希望未来的POWER实现对顺序一致的原子也有某种更有效的支持，这让程序员“更没有理由使用relaxed的原子。”我不知道是否发生了这种情况，尽管在2021年，POWER的相关性远不如ARMv8。</p>
<p>这种融合的效果是顺序一致的原子现在被很好地理解，并且可以在所有主要的硬件平台上有效地实现，这使得它们成为编程语言内存模型的一个很好的目标。</p>
<h2 id="JavaScript_内存模型_(2017)">JavaScript 内存模型 (2017)</h2>
<p>你可能会认为JavaScript，一种众所周知的单线程语言，不需要担心内存模型，当代码在多个处理器上并行运行时会发生什么。我当然有。但是你和我都错了。</p>
<p>JavaScript有web workers，它允许在另一个线程中运行代码。按照最初的设想，工作人员只通过显式的消息复制与主JavaScript线程进行通信。没有共享的可写内存，就没有必要考虑像数据竞争这样的问题。然而，ECMAScript 2017 (ES2017)增加了SharedArrayBuffer对象，它让主线程和工作线程共享一块可写内存。为什么要这样做？在提案的<a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf" target="_blank" rel="external">早期草稿</a>中，列出的第一个原因是将多线程C++代码编译成JavaScript。</p>
<p>当然，共享可写内存还需要定义同步的原子操作和内存模型。JavaScript在三个重要方面偏离了C++:</p>
<ul>
<li>首先，它将原子操作限制在顺序一致的原子上。其他原子可以被编译成顺序一致的原子，可能会损失效率，但不会损失正确性，只有一种原子可以简化系统的其余部分。</li>
<li>第二，JavaScript不采用“DRF-SC或着火。”相反，像Java一样，它仔细定义了竞争访问的可能结果。其原理与Java非常相似，尤其是安全性。允许竞争read返回任何值允许(可以说是鼓励)实现返回不相关的数据，这可能会导致运行时<a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/DISCUSSION.md#races-leaking-private-data-at-run-time" target="_blank" rel="external">私有数据的泄漏</a>。</li>
<li>第三，部分是因为JavaScript为竞争程序提供了语义，它定义了当原子和非原子操作在同一个内存位置使用时，以及当使用不同大小的访问访问同一个内存位置时会发生什么。</li>
</ul>
<p>精确定义racy程序的行为会导致relaxed内存语义的复杂性，以及如何禁止无中生有的读取和类似情况。除了这些与其他地方基本相同的挑战之外，ES2017定义还有两个有趣的错误，它们是由于与新的ARMv8原子指令的语义不匹配而引起的。这些例子改编自康拉德·瓦特等人2020年的论文<a href="https://www.cl.cam.ac.uk/~jp622/repairing_javascript.pdf" target="_blank" rel="external">“Repairing and Mechanising the JavaScript Relaxed Memory Model.”</a></p>
<p>正如我们在上一节中提到的，ARMv8增加了ldar和stlr指令，提供顺序一致的原子加载和存储。这些是针对C++的，它没有定义任何具有数据竞争的程序的行为。因此，毫不奇怪，这些指令在竞争程序中的行为与ES2017作者的期望不符，尤其是它不符合ES2017对竞争程序行为的要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: ES2017 racy reads on ARMv8</div><div class="line">Can <span class="keyword">this</span> program (using atomics) see r1 = <span class="number">0</span>, r2 = <span class="number">1</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                x = <span class="number">2</span> (non-atomic)</div><div class="line">                      r2 = x</div><div class="line">C++: yes (data race, can <span class="keyword">do</span> anything at all).</div><div class="line">Java: the program cannot be written.</div><div class="line">ARMv8 using ldar/stlr: yes.</div><div class="line">ES2017: no! (contradicting ARMv8)</div></pre></td></tr></table></figure>

<p>在这个程序中，所有的读和写都是顺序一致的原子，除了x = 2:线程1使用原子存储写x = 1，但是线程2使用非原子存储写x = 2。在C++中，这是一场数据竞争，所以所有的赌注都取消了。在Java中，这个程序是不能写的:x必须要么声明为volatile，要么不声明；它有时不能被原子访问。在ES2017中，内存模型不允许r1 = 0，r2 = 1。如果r1 = y读取0，线程1必须在线程2开始之前完成，在这种情况下，非原子x = 2似乎发生在x = 1之后并覆盖x = 1，导致原子r2 = x读取2。这个解释似乎完全合理，但这不是ARMv8处理器的工作方式。</p>
<p>事实证明，对于ARMv8指令的等效序列，对x的非原子写可以在对y的原子写之前重新排序，因此该程序实际上产生r1 = 0，r2 = 1。这在C++中不是问题，因为竞争意味着程序可以做任何事情，但对于ES2017来说，这是一个问题，它将竞争行为限制在一组不包括r1 = 0、r2 = 1的结果上</p>
<p>由于ES2017的明确目标是使用ARMv8指令来实现顺序一致的原子操作，Watt等人报告说，他们建议的修复(计划包含在标准的下一个修订版中)将削弱竞争行为约束，足以允许这种结果。(当时我不清楚“下一次修订”是指ES2020还是ES2021。)</p>
<p>Watt等人提出的修改还包括对第二个bug的修复，第一个bug是由Watt、Andreas Rossberg和Jean Pichon-pharabad提出的，其中一个无数据竞争的程序没有按照ES2017规范给出顺序一致的语义。该程序由下式给出:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Litmus Test: ES2017 data-race-free program</div><div class="line">Can this program (using atomics) see r1 = 1, r2 = 2?</div><div class="line"></div><div class="line">// Thread 1           // Thread 2</div><div class="line">x = 1                 x = 2</div><div class="line">                      r1 = x</div><div class="line">                      if (r1 == 1) {</div><div class="line">                          r2 = x // non-atomic</div><div class="line">                      }</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">C++: I'm not enough of a C++ expert to say for sure.</div><div class="line">Java: the program cannot be written.</div><div class="line">ES2017: yes! (violating DRF-SC).</div></pre></td></tr></table></figure>

<p>在这个程序中，所有的读和写都是顺序一致的原子，除了r2 = x，标记为。这个程序是无数据竞争的:非原子读取必须参与任何数据竞争，只有当r1 = 1时才执行，这证明线程1的x = 1发生在r1 = x之前，因此也发生在r2 = x之前。DRF-SC意味着程序必须以顺序一致的方式执行，因此r1 = 1，r2 = 2是不可能的，但ES2017规范允许这样做。</p>
<p>因此，ES2017程序行为规范同时太强(它不允许racy程序的真实ARMv8行为)和太弱(它允许无竞争程序的非顺序一致行为)。如前所述，这些错误已经改正。即便如此，这也再次提醒我们，精确地使用以前发生的事情来指定无数据竞争程序和活泼程序的语义是多么微妙，以及将语言内存模型与底层硬件内存模型相匹配是多么微妙。</p>
<p>令人鼓舞的是，至少到目前为止，除了顺序一致的原子之外，JavaScript避免了添加任何其他原子，并抵制了“DRF-SC或着火”结果是内存模型作为C/C++编译目标是有效的，但更接近于Java。</p>
<h2 id="结论">结论</h2>
<p>看看C、C++、Java、JavaScript、Rust和Swift，我们可以得出以下结论:</p>
<ul>
<li>它们都提供顺序一致的同步原子，用于协调并行程序的非原子部分。</li>
<li>它们的目的都是确保程序使用适当的同步来避免数据竞争，就像以顺序一致的方式执行一样。</li>
<li>Java和JavaScript避免了引入弱(acquire/release)同步原子，这似乎是为x86量身定制的。</li>
<li>它们都为程序提供了一种方式来执行“有意的”数据竞争，而不会使程序的其余部分无效。在C、C++、Rust和Swift中，这种机制是relaxed，非同步原子，一种特殊的内存访问形式。在Java和JavaScript中，这种机制就是普通的内存访问。</li>
<li>没有一种语言找到了正式禁止悖论的方法，比如无中生有的值，但是所有语言都非正式地禁止它们。</li>
</ul>
<p>与此同时，处理器制造商似乎已经接受了顺序一致同步原子的抽象对于高效实现非常重要，并开始这样做：ARMv8和RISC-V都提供了直接支持。</p>
<p>最后，真正大量的验证和形式分析工作已经进入了理解这些系统和精确陈述它们的行为。特别令人鼓舞的是，瓦特等人在2020年能够给出一个JavaScript重要子集的正式模型，并使用定理证明器来证明编译对ARM、POWER、RISC-V和x86-TSO的正确性。</p>
<p>在第一个Java内存模型问世25年后，经过许多人世纪的研究努力，我们可能开始能够形式化整个内存模型。也许，有一天，我们也会完全理解他们。</p>
<p>【本系列的下一篇文章，关于Go内存模型，计划在7月12日那一周发布。】</p>
<h2 id="感谢">感谢</h2>
<p>这一系列的帖子从我有幸在谷歌工作的一长串工程师的讨论和反馈中受益匪浅。我感谢他们。我对任何错误或不受欢迎的意见负全部责任。    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Russ Cox的第二篇<a href="https://research.swtch.com/plmm" target="_blank" rel="external">Programming Language Memory Models</a>。</p>
<p>如果你已经阅读了前一篇<a href="https://colobu.com/2021/06/30/hwmm/#%E5%BC%B1%E6%8E%92%E5%BA%8F%E5%92%8C%E6%97%A0%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7" target="_blank" rel="external">硬件内存模型</a>,以及如果有Java内存模型或者C++内存模型的经验，本文还好理解，如果你没有相关经验，可能阅读起来比较费劲，建议先阅读一下相关的材料。论文有些词句比较难以理解，本人才学疏浅，有翻译不当之处欢迎批评指正。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Go Module之未说的秘密]]></title>
    <link href="https://colobu.com/2021/07/04/dive-into-go-module-3/"/>
    <id>https://colobu.com/2021/07/04/dive-into-go-module-3/</id>
    <published>2021-07-04T07:22:37.000Z</published>
    <updated>2021-10-06T03:29:34.277Z</updated>
    <content type="html"><![CDATA[<p>正常情况下，我们的go.mod依赖库的版本都是符合<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0.0</a>的版本格式，或者<a href="https://golang.org/ref/mod#non-module-compat#glos-pseudo-version" target="_blank" rel="external">伪版本格式</a>。在前面的文章我没有特别提到一点的事，Go使用服务端提交的日期和commit id生成的伪版本号是符合语义化版本号2.0.0的，因为语义化版本号中规定pre-release以连接号<strong>-</strong>加一连串以逗号分隔的标识符组成，标识符以字母数字和连接号组成，所以你看到<code>-yyyyMMddhhmmss-comitid</code>包含两个连接号，这是正常的。</p>
<p>go要求依赖库要么不包含go.mod,要么依赖库中的go.mod定义的依赖库版本必须以语义化版本 2.0.0格式(或伪版本号)标志(其实更严格，除了<code>+incompatible</code>不能加meta字段)，因为这样我们你能够明确标识某个依赖库确切的版本，这样的版本号被称之为<a href="https://golang.org/ref/mod#glos-canonical-version" target="_blank" rel="external">canonical version</a>。</p>
<p>其实main module还可以定义non-canonical version，通过go get或者go mod tidy更新go.mod的时候，命令会尝试更新go.mod,尝试把non-canonical version转变为canonical version版本。</p>
<p>但是，到底有哪些non-canonical version呢？我还没看到官方文章介绍，本文尝试整理这些non-canonical version。</p>
<a id="more"></a>
<h3 id="只定义major或者major-minor">只定义major或者major.minor</h3>
<p>你可以不指定minor.patch或者patch,而是让go命令尝试去寻找最大的minor和patch,所以你可以在go.mod只定义vmajor或者vmajor.minor:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/B v1.<span class="number">2</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/C v1</div><div class="line">github.<span class="keyword">com</span>/panicthis/G/v2 v2</div></pre></td></tr></table></figure>

<p>运行<code>go mod tidy</code>它们会被转换成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/B v1.<span class="number">2.1</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/C v1.<span class="number">4.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/G/v2 v2.<span class="number">0.0</span></div></pre></td></tr></table></figure>

<p><code>go get</code>命令也一样，你也可以直接指定major，忽略minor和patch, 比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go get github.com/panicthis/B@v1.<span class="number">2</span></div><div class="line">go get github.com/panicthis/C@v1</div><div class="line">go get github.com/panicthis/G/v2@v2</div></pre></td></tr></table></figure>

<h3 id="latest,_upgrade_和_patch">latest, upgrade 和 patch</h3>
<p>有三个单词有特别的语义</p>
<ul>
<li>latest: 选择最高的release版本，如果没有release版本，则选择最高的pre-release版本，如果根本就没有打过tag,则选择最高的伪版本号的版本(默认分支的最后的提交版本)</li>
<li>upgrade: 类似latest,但是如果有比release更高的版本(比如pre-release),会选择更高的版本</li>
<li>patch: major和minor和当前的版本相同，只把patch升级到最高。当然如果没有当前的版本，则无从比较，则patch退化成latest语义</li>
</ul>
<p>比如下面的格式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/D latest</div><div class="line">github.<span class="keyword">com</span>/panicthis/E upgrade</div><div class="line">github.<span class="keyword">com</span>/panicthis/F patch</div></pre></td></tr></table></figure>

<p>使用go get命令也一样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/D@latest</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/E@upgrade</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/F@patch //因为没有本地版本，所以此命令在<span class="keyword">go</span> <span class="number">1.16</span>下可能出错</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@v1.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<h3 id="指定特定的commit_id">指定特定的commit id</h3>
<p>因为有时候proxy有缓存时间或者更新周期，如果你提交了一个新的commit,或者新打了一个tag,通过 <code>latest</code>不一定能拉取到最新的提交，这个时候你可以通过指定commit id的方式拉取。或者你就想测试某个特定的版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/H <span class="number">4</span>f7657a</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/H@<span class="number">4</span>f7657a</div></pre></td></tr></table></figure>

<p>甚至，你可以使用<code>HEAD</code>，作为你最新的commit id:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/H HEAD</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/H@HEAD</div></pre></td></tr></table></figure>

<h3 id="特定的分支">特定的分支</h3>
<p>你还可以拉取特定的分支</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/panicthis/J master</div><div class="line">github.<span class="keyword">com</span>/panicthis/K feat-<span class="number">123</span></div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/J@master</div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/panicthis/K@feat-<span class="number">123</span></div></pre></td></tr></table></figure>

<p>≈</p>
<p>更有甚者，你可以使用<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>比较符，选取某个符合条件的最大的版本。</p>
<p>比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">github.<span class="keyword">com</span>/stretchr/testify &gt;v1.<span class="number">7.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/F &gt;=v1.<span class="number">1.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/F &lt;v1.<span class="number">1.0</span></div><div class="line">github.<span class="keyword">com</span>/panicthis/F &lt;=v1.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<p>运行go mod tidy它会转换成canonical version。</p>
<p>或者(注意命令行中需要使用转义符)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/stretchr/testify@\&gt;v1.<span class="number">7.0</span></div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@\&gt;=v1.<span class="number">1.0</span></div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@\&lt;v1.<span class="number">1.0</span></div><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span>=patch github.<span class="keyword">com</span>/panicthis/F@\&lt;=v1.<span class="number">1.0</span></div></pre></td></tr></table></figure>

<p>虽然我们可以在go.mod中使用non-canonical version，但是在提交和发布的时候，我们需要使用go mod tidy把它们转换成canonical version,让依赖库的版本对应一个确定的版本，否则<code>master</code>、<code>HEAD</code>在不同的人使用的时候可能会对应不同的版本。</p>
<h3 id="none">none</h3>
<p>还有一个特殊的字符可以作为non-canonical version,比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/stretchr/testify@none</div></pre></td></tr></table></figure>

<p>它会从go module中移出这个依赖。</p>
<h3 id="tip">tip</h3>
<p>有人提议支持go从开发分支上拉取最新的版本。 有几个单次可以候选，但是感觉从 hg/mercurial中借鉴来的<code>tip</code>很合适。go最新的开发版本也叫做<code>tip</code>。</p>
<p>这只是一个提议，未必最终支持。 <a href="https://github.com/golang/go/issues/42545" target="_blank" rel="external">#42545</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>正常情况下，我们的go.mod依赖库的版本都是符合<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0.0</a>的版本格式，或者<a href="https://golang.org/ref/mod#non-module-compat#glos-pseudo-version" target="_blank" rel="external">伪版本格式</a>。在前面的文章我没有特别提到一点的事，Go使用服务端提交的日期和commit id生成的伪版本号是符合语义化版本号2.0.0的，因为语义化版本号中规定pre-release以连接号<strong>-</strong>加一连串以逗号分隔的标识符组成，标识符以字母数字和连接号组成，所以你看到<code>-yyyyMMddhhmmss-comitid</code>包含两个连接号，这是正常的。</p>
<p>go要求依赖库要么不包含go.mod,要么依赖库中的go.mod定义的依赖库版本必须以语义化版本 2.0.0格式(或伪版本号)标志(其实更严格，除了<code>+incompatible</code>不能加meta字段)，因为这样我们你能够明确标识某个依赖库确切的版本，这样的版本号被称之为<a href="https://golang.org/ref/mod#glos-canonical-version" target="_blank" rel="external">canonical version</a>。</p>
<p>其实main module还可以定义non-canonical version，通过go get或者go mod tidy更新go.mod的时候，命令会尝试更新go.mod,尝试把non-canonical version转变为canonical version版本。</p>
<p>但是，到底有哪些non-canonical version呢？我还没看到官方文章介绍，本文尝试整理这些non-canonical version。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]硬件内存模型]]></title>
    <link href="https://colobu.com/2021/06/30/hwmm/"/>
    <id>https://colobu.com/2021/06/30/hwmm/</id>
    <published>2021-06-30T12:54:43.000Z</published>
    <updated>2021-10-06T03:29:34.375Z</updated>
    <content type="html"><![CDATA[<p>Russ Cox关于内存模型的系列文章之一。这是第一篇 <a href="https://research.swtch.com/hwmm" target="_blank" rel="external">Hardware Memory Models</a></p>
<a id="more"></a>
<h2 id="简介:_童话之终局">简介: 童话之终局</h2>
<p>很久以前，当每个人都写单线程程序的时候，让程序运行得更快最有效的方法之一是坐下来袖手旁观。下一代硬件和编译器的优化结果可以让程序像以前一样运行，只是速度会更快。在这个童话般的年代，有一个判断优化是否有效的简单测试方法:如果程序员不能区分合法程序的未优化执行结果和优化执行的结果之间的区别(除了速度的区别)，那么这个优化就是有效的。也就是说，有效的优化不会改变有效程序的行为。</p>
<p>几年前， 某个悲伤的日子，硬件工程师发现让单个处理器越来越快的魔法失效了。不过，他们发现了一个新的魔法，可以让他们创造出拥有越来越多处理器的计算机，操作系统使用线程抽象模型向程序员展示了这种硬件并行能力。这种新的魔法——多处理器以操作系统线程的形式提供并行能力——对硬件工程师来说效果更好，但它给编程语言设计者、编译器作者和程序员带来了严重的问题。</p>
<p>许多在单线程程序中不可见(因此有效)的硬件和编译器优化会在多线程程序中产生明显的结果变化。如果有效的优化没有改变有效程序的行为，那么这些优化应该被认为是无效的。或者现有程序必须被声明为无效的。到底是哪一个，怎么判断？</p>
<p>这里有一个类似C语言的简单示例程序。在这个程序和我们将要考虑的所有程序中，所有变量最初都设置为零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>如果线程1和线程2都运行在自己专用处理器上，都运行到完成，这个程序能打印 0 吗？</p>
<p>看情况(<code>It depends</code>)。这取决于硬件，也取决于编译器。在x86多处理器上, 如果逐行翻译成汇编的程序执行的话总是会打印1。但是在ARM或POWER多处理器上，如果逐行翻译成汇编的程序可以打印0。此外，无论底层硬件是什么，标准编译器优化都可能使该程序打印0或进入无限循环。</p>
<p>“看情况”(<code>It depends</code>)并不是一个圆满的结局。程序员需要一个明确的答案来判断一个程序是否在新的硬件和新的编译器上能够正确运行。硬件设计人员和编译器开发人员也需要一个明确的答案，说明在执行给定的程序时，硬件和编译后的代码可以有多精确。因为这里的主要问题是对存储在内存中数据更改的可见性和一致性，所以这个契约被称为内存一致性模型（<code>memory consistency model</code>）或仅仅是内存模型(<code>memory model</code>)。</p>
<p>最初，内存模型的目标是定义程序员编写汇编代码时硬件提供的保证。在该定义下，是不包含编译器的内容的。25年前，人们开始尝试写内存模型 ，用来定义高级编程语言(如Java或C++)对用该语言编写代码的程序员提供的保证。在模型中包含编译器会使得定义一个合理模型的工作更加复杂。</p>
<p>这是关于硬件内存模型和编程语言内存模型的两篇文章中的第一篇。我写这些文章的目的是先介绍一下背景，以便讨论我们可能想要对Go的内存模型进行的改变。但是，要了解Go当前状况，我们可能想去哪里，首先我们必须了解其他硬件内存模型和语言内存模型的现状，以及他们采取的道路。</p>
<p>还是那句话，这篇文章讲的是硬件。假设我们正在为多处理器计算机编写汇编语言。程序员为了写出正确的程序，需要从计算机硬件上得到什么保证？四十多年来，计算机科学家一直在寻找这个问题的好答案。</p>
<h2 id="顺序一致性">顺序一致性</h2>
<p>Leslie Lamport 1979年的论文<a href="https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/" target="_blank" rel="external">《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》</a>引入了顺序一致性的概念:</p>
<blockquote>
<p>The customary approach to designing and proving the correctness of multiprocess algorithms for such a computer assumes that the following condition is satisfied: the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program. A multiprocessor satisfying this condition will be called sequentially consistent.</p>
</blockquote>
<blockquote>
<p>为这种计算机设计和证明多处理算法正确性的通常方法假定满足下列条件:任何执行的结果都是相同的，就好像所有处理器的操作都是按某种顺序执行的，每个处理器的操作都是按程序指定的顺序出现的。满足这一条件的多处理器系统将被称为顺序一致的。</p>
</blockquote>
<p>今天，我们不仅讨论计算机硬件，还讨论保证顺序一致性的编程语言，当程序的唯一可能执行对应于某种线程操作交替成顺序执行时。顺序一致性通常被认为是理想的模型，是程序员最自然的工作模式。它允许您假设程序按照它们在页面上出现的顺序执行，并且单个线程的执行只是以某种顺序交替(<code>interleaving</code>)，而不是以其他方式排列。</p>
<p>人们可能会有理由质疑顺序一致性是否应该是理想的模型，但这超出了本文的范围。我只注意到，考虑到所有可能的线程交替(<code>interleaving</code>)依然存在，就像在1979年一样，即使过了四十几年，Leslie Lamport的“设计和证明多处理算法正确性的惯用方法”，依然没有什么能取代它。</p>
<p>之前我问这个程序能不能打印0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>;                <span class="keyword">while</span>(done == <span class="number">0</span>) { <span class="comment">/* loop */</span> }</div><div class="line">done = <span class="number">1</span>;             print(x);</div></pre></td></tr></table></figure>

<p>为了让程序更容易分析，让我们去掉循环和打印，并询问读取共享变量的可能结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Message Passing</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div></pre></td></tr></table></figure>

<p>我们假设每个例子都是所有共享变量最初都被设置为零。因为我们试图确定硬件允许做什么，我们假设每个线程都在自己的专用处理器上执行，并且没有编译器来对线程中发生的事情进行重新排序:列表中的指令就是处理器执行的指令。rN这个名字表示一个线程本地寄存器，而不是一个共享变量，我们会问一个线程本地寄存器的值在执行结束时是否存在某种可能。</p>
<p>这种关于样本程序执行结果的问题被称为<code>litmus test</code>。因为它只有两个答案——这个结果可能还是不可能？——<code>litmus test</code>为我们提供了一种区分内存模型的清晰方法:如果一个模型支持特定的执行，而另一个不支持，那么这两个模型显然是不同的。不幸的是，正如我们将在后面看到的，一个特定的模型对一个特定的<code>litmus test</code>给出的答案往往令人惊讶。</p>
<p>If the execution of this litmus test is sequentially consistent, there are only six possible interleavings:</p>
<p>如果该<code>litmus test</code>的执行顺序一致，则只有六种可能的交替:</p>
<p><img src="mem-litmus.png" alt=""></p>
<p>因为没有交替执行的结果会产生<code>r1 = 1, r2 = 0</code>,所以这个结果是不允许的。也就是说，在顺序执行的硬件上，litmus test执行结果出现<code>r1 = 1, r2 = 0</code>是不可能的。</p>
<p>顺序一致性的一个很好的思维模型是想象所有处理器直接连接到同一个共享内存，它可以一次处理一个线程的读或写请求。 不涉及缓存，因此每次处理器需要读取或写入内存时，该请求都会转到共享内存。 一次使用一次的共享内存对所有内存访问的执行施加了顺序顺序：顺序一致性。 </p>
<p><img src="mem-sc.png" alt=""></p>
<p>(本文中三个内存模型图摘自 Maranget et al. <a href="A Tutorial Introduction to the ARM and POWER Relaxed Memory Models">“A Tutorial Introduction to the ARM and POWER Relaxed Memory Models.”</a>)</p>
<p>上图是顺序一致机器的模型，而不是构建机器的唯一方法。 实际上，可以使用多个共享内存模块和缓存来构建顺序一致的机器来帮助预测内存获取的结果，但顺序一致意味着机器的行为必须与该模型并无二致。 如果我们只是想了解顺序一致执行意味着什么，我们可以忽略所有这些可能的实现复杂性并只考虑这个模型。 </p>
<p>不幸的是，对于我们程序员，放弃严格的顺序一致性可以让硬件更快地执行程序，所以所有现代硬件在各方面都会偏离了顺序一致性。准确定义具体的硬件偏离是相当困难的。本文以当今广泛使用的硬件中的两种内存模型为例:<strong>x86</strong>、<strong>ARM和POWER处理器系列</strong>。</p>
<h2 id="x86_Total_Store_Order_(x86-TSO)">x86 Total Store Order (x86-TSO)</h2>
<p>现代x86系统的内存模型对应于以下硬件图:<br><img src="mem-tso.png" alt=""></p>
<p>所有处理器仍然连接到一个共享内存，但是每个处理器都将对该内存的写入(<code>write</code>)放入到本地写入队列中。处理器继续执行新指令，同时写操作(<code>write</code>)会更新到这个共享内存。一个处理器上的内存读取在查询主内存之前会查询本地写队列，但它看不到其他处理器上的写队列。其效果就是当前处理器比其他处理器会先看到自己的写操作。但是——这一点非常重要——所有处理器都保证写入(存储<code>store</code>)到共享内存的(总)顺序，所以给这个模型起了个名字:总存储有序，或<code>TSO</code>。当一个写操作到达共享内存时，任何处理器上的任何未来读操作都将看到它并使用该值(直到它被以后的写操作覆盖，或者可能被另一个处理器的缓冲写操作覆盖)。</p>
<p>写队列是一个标准的先进先出队列:内存写操作以与处理器执行相同的顺序应用于共享内存。因为写入顺序由写入队列保留，并且由于其他处理器会立即看到对共享内存的写入，所以我们之前考虑的通过<code>litmus test</code>的消息与之前具有相同的结果:<code>r1 = 1，r2 = 0</code>仍然是不可能的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Message Passing</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div><div class="line">On sequentially consistent hardware: no. </div><div class="line">On x86 (or other TSO): no.</div></pre></td></tr></table></figure>

<p>写队列保证线程1在y之前将x写入内存，关于内存写入顺序(总存储有序)的系统级协议保证线程2在读y的新值之前读x的新值。因此，<code>r1 = y</code>在<code>r2 = x</code>看不到新的x之前不可能看到新的y。存储顺序至关重要:线程1在写入y之前先写入x，因此线程2在看到x的写入之前不可能看到y的写入。</p>
<p>在这种情况下，顺序一致性和TSO模型是一致的，但是他们在其他litmus test的结果上并不一致。例如，这是区分两种型号的常用示例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Write Queue (also called Store Buffer)</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">0</span>, <span class="variable">r2 =</span> <span class="number">0</span>?</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>           // Thread <span class="number">2</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>                 <span class="variable">y =</span> <span class="number">1</span></div><div class="line"><span class="variable">r1 =</span> y                <span class="variable">r2 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): yes!</div></pre></td></tr></table></figure>

<p>在任何顺序一致的执行中，<code>x = 1</code>或<code>y = 1</code>必须首先发生，然后另一个线程中的读取必须能够观察到它(此赋值事件)，因此<code>r1 = 0，r2 = 0</code>是不可能的。但是在一个TSO系统中，线程1和线程2可能会将它们的写操作排队，然后在任何一个写操作进入内存之前从内存中读取，这样两个读操作都会看到零。</p>
<p>这个例子看起来可能是人为制造的，但是使用两个同步变量确实发生在众所周知的同步算法中，例如<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm" target="_blank" rel="external">德克尔算法</a>或<a href="https://en.wikipedia.org/wiki/Dekker%27s_algorithm" target="_blank" rel="external">彼得森算法</a>，以及特定的方案。如果一个线程没有看到另一个线程的所有写操作，线程就可能会中断。</p>
<p>为了修复同步算法，我们需要依赖于更强的内存排序，非顺序一致的硬件提供了称为内存屏障(或栅栏)的显式指令，可用于控制排序。我们可以添加一个内存屏障，以确保每个线程在开始读取之前都会刷新其先前对内存的写入:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x =<span class="number"> 1</span>                 y =<span class="number"> 1</span></div><div class="line">barrier               barrier</div><div class="line">r1 = y                r2 = x</div></pre></td></tr></table></figure>

<p>加上正确的障碍，<code>r1 = 0，r2 = 0</code>也是不可能的，德克尔或彼得森的算法就可以正常工作了。内存屏障有很多种；具体细节因系统而异，不在本文讨论范围之内。关键是内存屏障的存在给了程序员或语言实现者一种在程序的关键时刻强制顺序一致行为的方法。</p>
<p>最后一个例子，说明为什么这种模式被称为总存储有序。在该模型中，读路径上有本地写队列，但没有缓存。一旦一个写操作到达主存储器，所有处理器不仅都认同该值存在，而且还认同它相对于来自其他处理器的写操作的先后顺序。考虑一下这个litmus test:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Independent Reads of Independent Writes (IRIW)</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">0</span>, <span class="variable">r3 =</span> <span class="number">1</span>, <span class="variable">r4 =</span> <span class="number">0</span>?</div><div class="line">(Can Threads <span class="number">3</span> <span class="constant">and</span> <span class="number">4</span> see x <span class="constant">and</span> y change <span class="keyword">in</span> different orders?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">y =</span> <span class="number">1</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> y</div><div class="line">                              <span class="variable">r2 =</span> y         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div></pre></td></tr></table></figure>

<p>如果线程3看到x先于y变化，那么线程4能看到y先于x变化吗？对于x86和其他TSO机器，答案是否定的:对主内存的所有存储(写入)都有一个总顺序，所有处理器都认同这个顺序，只是每个处理器在到达主内存之前都先知道自己的写入而已。</p>
<h2 id="x86-TSO_之路">x86-TSO 之路</h2>
<p>x86-TSO模型看起来相当整洁，但是这条道路充满了路障和错误的弯道。在20世纪90年代，第一批x86多处理器可用的手册几乎没有提到硬件提供的内存模型。</p>
<p>作为问题困扰的一个例子，Plan 9 是第一个在x86上运行的真正多处理器操作系统(没有全局内核锁)。1997年，在移植到多处理器 奔腾Pro的过程中，开发人员被写队列litmus test的不期望的行为所困扰。一小段同步代码假设<code>r1 = 0，r2 = 0</code>是不可能的，但它确实发生了。更糟糕的是，英特尔手册对内存模型的细节模糊不清。</p>
<p>针对邮件列表中提出的“使用锁最好保守一点，不要相信硬件设计师会做我们期望的事情”的建议，Plan 9的一名开发人员很好地<a href="https://web.archive.org/web/20091124045026/http://9fans.net/archive/1997/04/76" target="_blank" rel="external">解释了这个问题</a>:</p>
<blockquote>
<p>我当然同意。我们会在多处理器中遇到更宽松的顺序(relaxed ordering )。问题是，硬件设计者认为什么是保守的？在临界区的开头和结尾强制互锁对我来说似乎相当保守，但我显然不够富有想象力。奔腾Pro的手册在描述缓存和怎么使它们保持一致时非常详细，但似乎不在乎说任何关于执行或read顺序的细节。事实是，我们无法知道自己是否足够保守。</p>
</blockquote>
<p>在讨论过程中，英特尔的一名架构师对内存模型做了非正式的解释，指出理论上，即使是多处理器486和奔腾系统也可能产生<code>r1 = 0，r2 = 0</code>的结果，并且奔腾Pro只是具有更大的流水线和写队列，所以会更频繁地暴露了这种行为。</p>
<p>这位英特尔架构师还写道:</p>
<blockquote>
<p>Loosely speaking, this means the ordering of events originating from any one processor in the system, as observed by other processors, is always the same. However, different observers are allowed to disagree on the interleaving of events from two or more processors.<br>Future Intel processors will implement the same memory ordering model.</p>
<p>粗略地说，这意味着从系统中任何一个处理器产生的事件的顺序，正如其他处理器所观察到的，总是相同的。然而，允许不同的观察者对来自两个或更多处理器的事件的交替有不同的观察结果。<br>未来的英特尔处理器将采用相同的内存顺序模式。</p>
</blockquote>
<p>声称“允许不同的观察者对来自两个或更多处理器的事件的交替有不同的观察结果”是在说，IRIW litmus test的答案在x86上可以回答“是”，尽管在前面的部分我们看到x86回答“否”。这怎么可能呢？</p>
<p>答案似乎是，英特尔处理器实际上从未对这一litmus test做出“是”的回答，但当时英特尔架构人员不愿意为未来的处理器做出任何保证。体系结构手册中存在的少量文本几乎没有任何保证，使得很难针对它们进行编程。</p>
<p>Plan 9的讨论不是一个孤立的事件。从11月下旬开始，Linux内核开发人员在他们的邮件列表上<a href="https://lkml.org/lkml/1999/11/20/76" target="_blank" rel="external">讨论了100多条消息</a>。</p>
<p>在接下来的十年里，越来越多的人遇到了这些困难，为此，英特尔的一组架构师承担了为当前和未来的处理器写下有用的处理器行为保证的任务。第一个结果是2007年8月出版的<a href="http://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf" target="_blank" rel="external">Intel 64 Architecture Memory Ordering White Paper</a>，旨在为“软件作者提供对不同顺序的内存访问指令可能产生的结果的清晰理解”。同年晚些时候，AMD在<a href="https://courses.cs.washington.edu/courses/cse351/12wi/supp-docs/AMD%20Vol%201.pdf" target="_blank" rel="external">AMD64 Architecture Programmer&#39;s Manual revision 3.14</a>中发布了类似的描述。这些描述基于一个被称为“总锁序+因果一致性”(TLO+CC)的模型，故意弱于TSO。在公开访谈中，英特尔架构师表示，TLO+CC<a href="http://web.archive.org/web/20080512021617/http://blogs.sun.com/dave/entry/java_memory_model_concerns_on" target="_blank" rel="external">“像要求的那样强大，但并不足够强大。”</a>特别是，该模型保留了x86处理器在IRIW litmus test中回答“是”的权利。不幸的是，内存屏障的定义不够强大，不足以重建顺序一致的内存语义，即使每个指令之后都有一个屏障。更糟糕的是，研究人员观察到实际的英特尔x86硬件违反了TLO+CC模型。例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Litmus Test: n6 (Paul Loewenstein)</div><div class="line">Can this program <span class="operator"><span class="keyword">end</span> <span class="keyword">with</span> r1 = <span class="number">1</span>, r2 = <span class="number">0</span>, x = <span class="number">1</span>?</span></div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span></div><div class="line">x = <span class="number">1</span>          y = <span class="number">1</span></div><div class="line">r1 = x         x = <span class="number">2</span></div><div class="line">r2 = y</div><div class="line"><span class="keyword">On</span> sequentially <span class="keyword">consistent</span> hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 TLO+CC model (<span class="number">2007</span>): <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> actual x86 hardware: yes!</div><div class="line"><span class="keyword">On</span> x86 TSO model: yes! (Example <span class="keyword">from</span> x86-TSO paper.)</div></pre></td></tr></table></figure>

<p>2008年晚些时候对英特尔和AMD规范的修订保证了IRIW case的“不”，并加强了内存屏障，但仍允许不可预期的行为，这些行为似乎不会出现在任何合理的硬件上。例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: n5</div><div class="line">Can this program <span class="operator"><span class="keyword">end</span> <span class="keyword">with</span> r1 = <span class="number">2</span>, r2 = <span class="number">1</span>?</span></div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span></div><div class="line">x = <span class="number">1</span>          x = <span class="number">2</span></div><div class="line">r1 = x         r2 = x</div><div class="line"><span class="keyword">On</span> sequentially <span class="keyword">consistent</span> hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 specification (<span class="number">2008</span>): yes!</div><div class="line"><span class="keyword">On</span> actual x86 hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 TSO model: <span class="keyword">no</span>. (Example <span class="keyword">from</span> x86-TSO paper.)</div></pre></td></tr></table></figure>

<p>为了解决这些问题，欧文斯等人在<a href="https://research.swtch.com/sparcv8.pdf" target="_blank" rel="external">早期SPARCv8 TSO模型</a>的基础上提出了<a href="https://www.cl.cam.ac.uk/~pes20/weakmemory/x86tso-paper.tphols.pdf" target="_blank" rel="external">x86-TSO模型提案</a>。当时，他们声称“据我们所知，x86-TSO是可靠的，足够强大，可以在上面编程，并且大致符合供应商的意图。“几个月后，英特尔和AMD发布了广泛采用这一模式的的新手册。</p>
<p>似乎所有英特尔处理器从一开始就实现了x86-TSO，尽管英特尔花了十年时间才决定致力于此。回想起来，很明显，英特尔和AMD的设计师们正在努力解决如何编写一个能够为未来处理器优化留出空间的内存模型，同时仍然为编译器作者和汇编语言程序设计者提供有用的保证。“有多强就有多强，但没有多强”是一个艰难的平衡动作。</p>
<h2 id="ARM/POWER_Relaxed_Memory_Model">ARM/POWER Relaxed Memory Model</h2>
<p>现在让我们来看看一个更宽松的内存模型，在ARM和POWER处理器上找到的那个。在实现层面上，这两个系统在许多方面有所不同，但保证内存一致性的模型大致相似，比x86-TSO甚至x86-TLO+CC稍弱。</p>
<p>ARM和POWER系统的概念模型是，每个处理器从其自己的完整内存副本中读取和向其写入，每个写入独立地传播到其他处理器，随着写入的传播，允许重新排序。<br><img src="mem-weak.png" alt=""></p>
<p>这里没有总存储顺序。虽然没有描述，但是每个处理器都被允许推迟读取(<code>read</code>)，直到它等到它需要结果:读取(<code>read</code>)可以被延迟到稍后的写入(<code>write</code>)之后。在这个宽松的(<code>relaxed</code>)模型中，我们迄今为止所看到的每一个litmus test的答案都是“yes，这真的可能发生。”</p>
<p>对于通过litmus test的原始消息，单个处理器对写入的重新排序意味着线程1的写入可能不会被其他线程以相同的顺序观察到:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Message Passing</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">1</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 r1 = y</div><div class="line">y = <span class="number">1</span>                 r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): no.</div><div class="line">On ARM/POWER: yes!</div></pre></td></tr></table></figure>

<p>在ARM/POWER模型中，我们可以想象线程1和线程2都有各自独立的内存副本，写操作以任何顺序在内存之间传播。如果线程1的内存在发送x的更新(<code>update</code>)之前向线程2发送y的更新，并且如果线程2在这两次更新之间执行，它将确实看到结果<code>r1 = 1，r2 = 0</code>。</p>
<p>该结果表明，ARM/POWER内存模型比TSO更弱:对硬件的要求更低。ARM/POWER模型仍然承认TSO所做的各种重组:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Store Buffering</div><div class="line">Can <span class="keyword">this</span> program see r1 = <span class="number">0</span>, r2 = <span class="number">0</span>?</div><div class="line"></div><div class="line"><span class="comment">// Thread 1           // Thread 2</span></div><div class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></div><div class="line">r1 = y                r2 = x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (or other TSO): yes!</div><div class="line">On ARM/POWER: yes!</div></pre></td></tr></table></figure>

<p>在ARM/POWER上，对x和y的写入(<code>write</code>)可能会写入本地存储器，但当读取发生在相反的线程上时，写入可能尚未传播开来。</p>
<p>下面是一个litmus test，它展示了x86拥有总存储顺序意味着什么:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Independent Reads of Independent Writes (IRIW)</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">0</span>, <span class="variable">r3 =</span> <span class="number">1</span>, <span class="variable">r4 =</span> <span class="number">0</span>?</div><div class="line">(Can Threads <span class="number">3</span> <span class="constant">and</span> <span class="number">4</span> see x <span class="constant">and</span> y change <span class="keyword">in</span> different orders?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">y =</span> <span class="number">1</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> y</div><div class="line">                              <span class="variable">r2 =</span> y         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div><div class="line">On ARM/POWER: yes!</div></pre></td></tr></table></figure>

<p>在ARM/POWER上，不同的线程可能以不同的顺序观察到不同的写操作。它们不能保证对到达主内存的总写入顺序达成一致的观察效果，因此线程3可以在y变化之前之前看到x的变化，而线程4可以在x变化之前看到y的变化。</p>
<p>作为另一个例子，ARM/POWER系统具有内存读取(负载 load)的可见缓冲或重新排序，如下面litmus test所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: <span class="operator"><span class="keyword">Load</span> Buffering</span></div><div class="line">Can this program see r1 = <span class="number">1</span>, r2 = <span class="number">1</span>?</div><div class="line">(Can <span class="keyword">each</span> thread<span class="string">'s read happen after the other thread'</span>s <span class="keyword">write</span>?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span></div><div class="line">r1 = x         r2 = y</div><div class="line">y = <span class="number">1</span>          x = <span class="number">1</span></div><div class="line"><span class="keyword">On</span> sequentially <span class="keyword">consistent</span> hardware: <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> x86 (<span class="keyword">or</span> other TSO): <span class="keyword">no</span>.</div><div class="line"><span class="keyword">On</span> ARM/<span class="keyword">POWER</span>: yes!</div></pre></td></tr></table></figure>

<p>任何顺序一致的交替必须从线程1的<code>r1 = x</code>或线程2的<code>r2 = y</code>开始，该读取必须看到一个0，使得结果r1 = 1，r2 = 1不可能。然而，在ARM/POWER存储器模型中，处理器被允许延迟读取，直到指令流中稍后的写入之后，因此y = 1和x = 1在两次读取之前执行。</p>
<p>尽管ARM和POWER内存模型都允许这一结果，但Maranget等人(2012年)<a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf" target="_blank" rel="external">报告说</a>，只能在ARM系统上凭经验重现，而不能在POWER上复制。在这里，模型和真实度之间的差异开始发挥作用，就像我们在检查英特尔x86时一样:硬件实现比技术保证更强大的模型会鼓励对更强的行为的依赖，这意味着未来更弱的硬件将破坏程序，无论是否有效。</p>
<p>像TSO系统上一样，ARM和POWER也有内存屏障，我们可以在上面的例子中插入这些内存屏障，以强制顺序一致的行为。但显而易见的问题是，没有内存屏障的ARM/POWER是否完全排除了任何行为。任何litmus test的答案是否都是“no，那不可能发生？” 当我们专注于一个单一的内存位置时，它可以。</p>
<p>这里有一个litmus test，它可以测试即使在ARM和POWER上也不会发生的事情:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Litmus Test: Coherence</div><div class="line">Can this program see <span class="variable">r1 =</span> <span class="number">1</span>, <span class="variable">r2 =</span> <span class="number">2</span>, <span class="variable">r3 =</span> <span class="number">2</span>, <span class="variable">r4 =</span> <span class="number">1</span>?</div><div class="line">(Can Thread <span class="number">3</span> see <span class="variable">x =</span> <span class="number">1</span> before <span class="variable">x =</span> <span class="number">2</span> while Thread <span class="number">4</span> sees the reverse?)</div><div class="line"></div><div class="line">// Thread <span class="number">1</span>    // Thread <span class="number">2</span>    // Thread <span class="number">3</span>    // Thread <span class="number">4</span></div><div class="line"><span class="variable">x =</span> <span class="number">1</span>          <span class="variable">x =</span> <span class="number">2</span>          <span class="variable">r1 =</span> x         <span class="variable">r3 =</span> x</div><div class="line">                              <span class="variable">r2 =</span> x         <span class="variable">r4 =</span> x</div><div class="line">On sequentially consistent hardware: no.</div><div class="line">On x86 (<span class="constant">or</span> other TSO): no.</div><div class="line">On ARM/POWER: no.</div></pre></td></tr></table></figure>

<p>这个litmus test与前一个测试类似，但是现在两个线程都在写入单个变量x，而不是两个不同的变量x和y。线程1和2将冲突的值1和2都写入x，而线程3和线程4都读取x两次。如果线程3看到x = 1被x = 2覆盖，那么线程4能看到相反的情况吗？</p>
<p>答案是<strong>no</strong>的，即使在ARM/POWER上也是如此:系统中的线程必须就写入单个内存位置的总顺序达成一致。也就是说，线程必须同意哪些写入会覆盖其他写入。这个性质叫做相干性。如果没有一致性属性，处理器要么不同意内存的最终结果，要么报告内存位置从一个值翻转到另一个值，然后又回到第一个值。编写这样一个系统是非常困难的。</p>
<p>我故意忽略了ARM和POWER弱内存模型中的许多微妙之处。更多详细信息，请参阅彼得·苏厄尔关于<a href="https://www.cl.cam.ac.uk/~pes20/papers/topics.html#Power_and_ARM" target="_blank" rel="external">该主题</a>的论文。有两个要点要记住。首先，这里有令人难以置信的微妙之处，这是由有非常持久力、非常聪明的人进行了十多年学术研究的主题。我自己并不声称完全理解。这不是我们应该希望向普通程序设计人员解释的事情，也不是我们在调试普通程序时希望能够坚持的事情。第二，允许和观察到的结果之间的差距造成了不幸的未来惊喜。如果当前的硬件没有展现出所有允许的行为——尤其是当首先很难推理出什么是允许的时候！—那么不可避免地会编写一些程序，这些程序会偶然地依赖于实际硬件的更受限制的行为。如果一个新的芯片在行为上受到的限制更少，那么硬件内存模型在技术上允许破坏程序的新行为——也就是说，这个错误在技术上是你的错——这一事实并不能给你带来什么安慰。这不是写程序的方法。</p>
<h2 id="弱排序和无数据竞争的顺序一致性">弱排序和无数据竞争的顺序一致性</h2>
<p>到目前为止，我希望您确信硬件细节是复杂而微妙的，而不是您每次编写程序时都想解决的问题。 相反，它有助于识别“如果你遵循这些简单的规则，你的程序只会产生结果，就像通过一些顺序一致的执行的那样。” （我们仍在谈论硬件，所以我们仍在谈论交替独立的汇编指令。） </p>
<p>Sarita Adve and Mark Hill proposed exactly this approach in their 1990 paper “Weak Ordering – A New Definition”. They defined “weakly ordered” as follows.</p>
<p>Sarita Adve和Mark Hill在他们1990年的论文<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5567" target="_blank" rel="external">“Weak Ordering – A New Definition”</a>中正是提出了这种方法。他们把“弱有序”定义为如下。</p>
<blockquote>
<p>Let a synchronization model be a set of constraints on memory accesses that specify how and when synchronization needs to be done.</p>
<p>同步模型是对内存访问的一组约束，这些约束指定了何时以及如何进行同步。</p>
</blockquote>
<p>硬件相对于同步模型是弱有序的，当且仅当它在顺序上与遵守同步模型的所有软件一致时。</p>
<p>虽然他们的论文是关于捕捉当时的硬件设计(不是x86、ARM和POWER)，但将讨论提升到特定设计之上的想法使论文与今天的讨论依然相关。</p>
<p>我之前说过“有效的优化不会改变有效程序的行为。”这些规则定义了什么是有效的手段，然后任何硬件优化都必须让这些程序像在顺序一致的机器上一样工作。当然，有趣的细节是规则本身，定义程序有效的约束。</p>
<p>Adve和Hill提出了一种同步模型，他们称之为无数据竞争(data-race-free，DRF)。该模型假设硬件具有独立于普通内存读写的内存同步操作。普通的内存读写可以在同步操作之间重新排序，但不能在跨它们移动。(也就是说，同步操作也可用来做重新排序的内存屏障。)如果对于所有理想化的顺序一致的执行，从不同线程对同一位置的任何两个普通存储器访问要么都是读取，要么通过同步操作强制一个在另一个之前发生而分开执行，则程序被称为无数据竞争的。<br>我们来看一些例子，摘自Adve和Hill的论文(为了演示而重新绘制)。这里有一个线程执行变量x的写操作，然后读取同一个变量。<br><img src="mem-adve-1.png" alt=""><br>垂直箭头标记了单个线程内的执行顺序:先写后读。这个程序没有竞争，因为一切都在一个线程中。</p>
<p>相比之下，在这个双线程程序中有一个竞争:<br><img src="mem-adve-2.png" alt=""></p>
<p>这里线程2在不与线程1协调的情况下写入x。线程2的写入与线程1的写入和读取竞争。如果线程2读x而不是写x，程序在线程1写和线程2读之间只有一个竞争。每个竞争至少涉及一次写入:两次不协调的读取不会相互竞争。</p>
<p>为了避免竞争，我们必须添加同步操作，这将在共享一个同步变量的不同线程上的操作之间强制一个特定的顺序。如果同步S(a)(在变量a上同步，用虚线箭头标记)迫使线程2的写操作在线程1完成后发生，则竞争被消除-<br><img src="mem-adve-3.png" alt=""></p>
<p>现在线程2的写操作不能与线程1的操作同时发生。</p>
<p>如果线程2只是读取，我们只需要与线程1的写入同步。两次读取仍然可以同时进行:</p>
<p><img src="mem-adve-4.png" alt=""></p>
<p>线程可以按同步顺序排序，甚至可以使用中间线程。这个程序没有竞争:</p>
<p><img src="mem-adve-5.png" alt=""></p>
<p>另一方面，同步变量的使用本身并不能消除竞争:错误地使用它们是可能的。下面这个程序有一个竞争:<br><img src="mem-adve-6.png" alt=""></p>
<p>线程2的读取与其他线程中的写入完全同步——这肯定发生在两者之后——但是这两个写入本身并不同步。这个程序并不是data-race-free。</p>
<p>Adve和Hill将弱排序描述为“软件和硬件之间的契约”，具体来说，如果软件避免了数据竞争，那么硬件就好像是顺序一致的，这比我们在前面部分研究的模型更容易推理。但是硬件如何满足它的契约呢？</p>
<p>Adve和Hill给出了硬件“遵循DRF弱排序”的证明，这意味着它执行无数据竞争的程序，就好像是按照顺序一致的顺序一样，只要它满足一组特定的最低要求。我不打算详谈细节，但重点是在Adve和Hill的论文发表后，硬件设计师们有了一份由理论支持的手册:做这些事情，你就可以断言你的硬件将与data-race-free程序顺序一致。事实上，假设同步操作的适当实现，大多数宽松的硬件确实是这样做的，并且一直在继续这样做。Adve和Hill最初关注的是VAX，但x86、ARM和POWER肯定也能满足这些限制。这种系统保证无数据竞争程序的顺序一致性的观点通常被缩写为DRF-SC。</p>
<p>DRF-SC标志着硬件内存模型的一个转折点，为硬件设计者和软件作者提供了一个清晰的策略，至少是那些用汇编语言编写软件的人。正如我们将在下一篇文章中看到的，高级编程语言的内存模型问题没有一个整洁的答案。</p>
<blockquote>
<p>下一篇，关于编程语言内存模型，计划在7月5日那一周。然后专门计划在7月12日的那一周发布一篇关于Go内存模型的文章。</p>
</blockquote>
<h2 id="致谢">致谢</h2>
<p>这一系列的帖子从我有幸在谷歌共事的一长串工程师的讨论和反馈中受益匪浅。我感谢他们。我对任何错误或不受欢迎的意见承担全部责任。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Russ Cox关于内存模型的系列文章之一。这是第一篇 <a href="https://research.swtch.com/hwmm" target="_blank" rel="external">Hardware Memory Models</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
