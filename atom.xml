<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2024-08-14T06:11:52.789Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[四种字符串和bytes互相转换方式的性能比较]]></title>
    <link href="https://colobu.com/2024/08/13/string-bytes-benchmark/"/>
    <id>https://colobu.com/2024/08/13/string-bytes-benchmark/</id>
    <published>2024-08-13T14:16:34.000Z</published>
    <updated>2024-08-14T05:10:38.219Z</updated>
    <content type="html"><![CDATA[<p>昨天公司群中同事提到 Go 1.22 中 string 和 bytes 的互转不需要再用 unsafe 那个包了，直接转就可以。我翻看了 Go 1.22 的 release notes 没找到相应的介绍，但是大家提到了 kubernetes 的 <a href="https://github.com/kubernetes/kubernetes/issues/124656" target="_blank" rel="external">issue</a> 中有这个说法：</p>
<blockquote>
<p>As of go 1.22, for string to bytes conversion, we can replace the usage of <code>unsafe.Slice(unsafe.StringData(s), len(s))</code> with type casting <code>[]bytes(str)</code>, without the worry of losing performance.</p>
<p>As of go 1.22, string to bytes conversion <code>[]bytes(str)</code> is faster than using the <code>unsafe</code> package. Both methods have 0 memory allocation now.</p>
</blockquote>
<blockquote>
<p>自 Go 1.22 起，对于 string 到 bytes 的转换，我们可以用类型转换 <code>[]bytes(str)</code> 来替换 <code>unsafe.Slice(unsafe.StringData(s), len(s))</code> 的用法，而不用担心性能损失。<br>自 Go 1.22 起，string 到 bytes 的转换 <code>[]bytes(str)</code> 比使用 unsafe 包更快。现在两种方法都不会有内存分配。</p>
</blockquote>
<p>这个说法让我很好奇，但是我还是想验证一下这个说法。</p>
<p>注意，这个说法只谈到了 string 到 bytes 的转换，并没有提到 bytes 到 string 的转换，这篇文章也会关注这两者的互转。</p>
<p>首先，让我们看看几种 string 和 bytes 的转换方式，然后我们再写 benchmark 比较它们之间的性能。<br><a id="more"></a></p>
<h2 id="一、强转">一、强转</h2>
<p>字符串和 bytes 之间可以强制转换，编译器会内部处理。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> toRawBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> []<span class="typename">byte</span>(s)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> toRawString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="typename">string</span>(b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们做了一点点优化，处理空 string或者 bytes 的情况。</p>
<h2 id="二、传统_unsafe_方式">二、传统 unsafe 方式</h2>
<p>reflect 包中定义了 <code>SliceHeader</code> 和 <code>StringHeader</code>, 分别对应 slice 和 string 的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> {</div><div class="line">	Data <span class="typename">uintptr</span></div><div class="line">	Len  <span class="typename">int</span></div><div class="line">	Cap  <span class="typename">int</span></div><div class="line">}</div><div class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> {</div><div class="line">	Data <span class="typename">uintptr</span></div><div class="line">	Len  <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们按照这种数据结构，可以实现 string 和 bytes 的互转。我们暂且把它叫做 <code>reflect</code> 方式吧，虽然下面的代码没有用到 <code>reflect</code> 包，但是实际我们是按照 <code>reflect</code> 包中的这两个数据结构进行转换的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> toReflectBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	x := (*<span class="number">[2</span>]<span class="typename">uintptr</span>)(unsafe.Pointer(&s))</div><div class="line">	h := <span class="number">[3</span>]<span class="typename">uintptr</span>{x<span class="number">[0</span>], x<span class="number">[1</span>], x<span class="number">[1</span>]}</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&h))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> toReflectString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&b))</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="三、新型_unsafe_方式">三、新型 unsafe 方式</h2>
<p>我在两年前的文章<a href="https://colobu.com/2022/09/06/string-byte-convertion/" target="_blank" rel="external">与日俱进，在 Go 1.20 中这种高效转换的方式又变了</a>介绍了新的 unsafe 方式，reflect 包中的 <code>SliceHeader</code> 和 <code>StringHeader</code> 准备废弃了。让我们看看这种新的转换方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> toBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> unsafe.Slice(unsafe.StringData(s), <span class="built_in">len</span>(s))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> toString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(b) ==<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> unsafe.String(unsafe.SliceData(b), <span class="built_in">len</span>(b))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>利用 <code>unsafe.Slice</code> 、<code>unsafe.String</code>、<code>unsafe.StringData</code> 和 <code>unsafe.SliceData</code> 完成 Slice 和 String 的转换以及底层数据的指针的获取。</p>
<h2 id="四、kubernetes_的实现">四、kubernetes 的实现</h2>
<p>在 k8s 中，使用的是下面方式的优化的转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> toK8sBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&s))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> toK8sString(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> *(*<span class="typename">string</span>)(unsafe.Pointer(&b))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，相对于传统 unsafe 方式，k8s 的实现更简洁，并没有为<code>toBytes</code>临时构造3元素的数组，而是直接将 string 和 bytes 的指针进行转换。</p>
<p>string不是只包含两个字段么？slice不是包含三个字段么？<code>toK8sBytes</code>返回的[]byte的cap是怎么确定的呢？ 最后我们再分析这个问题，现在先把这几个实现的性能搞清楚。 </p>
<h2 id="性能比较">性能比较</h2>
<p>我们分别对这几种实现进行 benchmark，看看它们之间的性能差异。<br>使用一个简单的字符串和它对应的bytes, 分别进行 string 到 bytes 、 bytes 到 string 的转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"hello, world"</span></div><div class="line"><span class="keyword">var</span> bts = []<span class="typename">byte</span>(<span class="string">"hello, world"</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkStringToBytes(b *testing.B) {</div><div class="line">	<span class="keyword">var</span> fns = <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">func</span>(<span class="typename">string</span>) []<span class="typename">byte</span>{</div><div class="line">		<span class="string">"强制转换"</span>:  toRawBytes,</div><div class="line">		<span class="string">"传统转换"</span>:  toReflectBytes,</div><div class="line">		<span class="string">"新型转换"</span>:  toBytes,</div><div class="line">		<span class="string">"k8s转换"</span>: toK8sBytes,</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> name, fn := <span class="keyword">range</span> fns {</div><div class="line">		b.Run(name, <span class="keyword">func</span>(b *testing.B) {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">				bts = fn(s)</div><div class="line">			}</div><div class="line">		})</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytesToString(b *testing.B) {</div><div class="line">	<span class="keyword">var</span> fns = <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">func</span>([]<span class="typename">byte</span>) <span class="typename">string</span>{</div><div class="line">		<span class="string">"强制转换"</span>:  toRawString,</div><div class="line">		<span class="string">"传统转换"</span>:  toReflectString,</div><div class="line">		<span class="string">"新型转换"</span>:  toString,</div><div class="line">		<span class="string">"k8s转换"</span>: toK8sString,</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">for</span> name, fn := <span class="keyword">range</span> fns {</div><div class="line">		b.Run(name, <span class="keyword">func</span>(b *testing.B) {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">				s = fn(bts)</div><div class="line">			}</div><div class="line">		})</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在Mac mini M2上运行，go1.22.6 darwin/arm64，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">goos</span>: <span class="string">darwin</span></div><div class="line"><span class="attribute">goarch</span>: <span class="string">arm64</span></div><div class="line"><span class="attribute">pkg</span>: <span class="string">github.com/smallnest/study/str2bytes</span></div><div class="line"></div><div class="line"><span class="gradle">BenchmarkStringToBytes<span class="regexp">/强制转换-8              	78813638	        14.73 ns/</span>op	      <span class="number">16</span> B<span class="regexp">/op	       1 allocs/</span>op</span></div><div class="line">BenchmarkStringToBytes<span class="regexp">/传统转换-8              	599346962	         2.010 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkStringToBytes<span class="regexp">/新型转换-8              	624976126	         1.929 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkStringToBytes<span class="regexp">/k8s转换-8             	887370499	         1.211 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div></pre></td></tr></table></figure>

<p>string 转 bytes性能最好的是k8s方案， 新型转换和传统转换性能差不多，新型方案略好，强制转换性能最差。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BenchmarkBytesToString<span class="regexp">/强制转换-8              	92011309	        12.68 ns/</span>op	      <span class="number">16</span> B<span class="regexp">/op	       1 allocs/</span>op</div><div class="line">BenchmarkBytesToString<span class="regexp">/传统转换-8              	815922964	         1.471 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkBytesToString<span class="regexp">/新型转换-8              	624965414	         1.922 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkBytesToString<span class="regexp">/k8s转换-8             	1000000000	         1.194 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div></pre></td></tr></table></figure>

<p>而对于 bytes 转 string，k8s方案性能最好，传统转换次之，新型转换性能再次之，强制转换性能非常不好。</p>
<p>在Linux amd64上运行，go1.22.0 linux/amd64，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">goos: linux</div><div class="line">goarch: amd64</div><div class="line">pkg: test</div><div class="line">cpu: Intel(R) Xeon(R) Platinum</div><div class="line">BenchmarkStringToBytes<span class="regexp">/强制转换-2                 	30606319	        42.02 ns/</span>op	      <span class="number">16</span> B<span class="regexp">/op	       1 allocs/</span>op</div><div class="line">BenchmarkStringToBytes<span class="regexp">/传统转换-2                 	315913948	         3.779 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkStringToBytes<span class="regexp">/新型转换-2                 	411972518	         2.753 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkStringToBytes<span class="regexp">/k8s转换-2                	449640819	         2.770 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line"></div><div class="line"></div><div class="line">BenchmarkBytesToString<span class="regexp">/强制转换-2                 	38716465	        29.18 ns/</span>op	      <span class="number">16</span> B<span class="regexp">/op	       1 allocs/</span>op</div><div class="line">BenchmarkBytesToString<span class="regexp">/传统转换-2                 	458832459	         2.593 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkBytesToString<span class="regexp">/新型转换-2                 	439537762	         2.762 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div><div class="line">BenchmarkBytesToString<span class="regexp">/k8s转换-2                	478885546	         2.375 ns/</span>op	       <span class="number">0</span> B<span class="regexp">/op	       0 allocs/</span>op</div></pre></td></tr></table></figure>

<p>整体上看，k8s方案、传统转换、新型转换性能都挺好，强制转换性能最差。k8s在bytes转string上性能最好。</p>
<h2 id="性能分析">性能分析</h2>
<p>等等，kubernates的讨论中，不是说Go1.22中string到bytes的转换可以直接用<code>[]byte(str)</code>了么？为什么这里的性能测试中，强制转换为什么性能那么差呢？</p>
<p>同时你也可以看到，强制转换每个op都会有一次内存分配:<code>1 allocs/op</code>,这严重影响了它的性能。</p>
<p>如果我们编写两个benchmark测试函数, 如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> BenchmarkStringToBytesRaw(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		_ = toRawBytes(s)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkBytesToStringRaw(b *testing.B) {</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		_ = toRawString(bts)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="label">goos:</span> darwin</div><div class="line"><span class="label">goarch:</span> arm64</div><div class="line"><span class="label">pkg:</span> github.com/smallnest/study/str2bytes</div><div class="line">BenchmarkStringToBytesRaw-<span class="number">8</span>   	<span class="number">1000000000</span>	         <span class="number">0.2921</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div><div class="line">BenchmarkBytesToStringRaw-<span class="number">8</span>   	<span class="number">506502222</span>	         <span class="number">2.363</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</div></pre></td></tr></table></figure>

<p>你会发现一个令人诧异的事情，强制转换的性能非常好，没有额外的内存分配(零拷贝)，设置字符串转换为bytes好太多。</p>
<p>这是咋回事呢？</p>
<p>当然聪明的你就会想到这个肯定是编译器做了优化，通过内联，把toRawBytes的函数调用展开了，这个好处是发现s</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># go test -gcflags="-m=2" -bench Raw -benchmem</span></div><div class="line"><span class="keyword">...</span></div><div class="line">./convert_test.go:<span class="number">48</span>:<span class="number">6</span>: can inline toRawBytes with cost <span class="number">10</span> as: func(string) []byte { <span class="keyword">if</span> len(s) == <span class="number">0</span> { <span class="keyword">return</span> nil }; <span class="keyword">return</span> ([]byte)(s) }</div><div class="line">./convert_test.go:<span class="number">55</span>:<span class="number">6</span>: can inline toRawString with cost <span class="number">10</span> as: func([]byte) string { <span class="keyword">if</span> len(b) == <span class="number">0</span> { <span class="keyword">return</span> <span class="string">""</span> }; <span class="keyword">return</span> string(b) }</div><div class="line"><span class="keyword">...</span></div><div class="line">./convert_test.go:<span class="number">101</span>:<span class="number">17</span>: ([]byte)(s) does not escape</div><div class="line">./convert_test.go:<span class="number">101</span>:<span class="number">17</span>: zero-copy string-&gt;[]byte conversion</div><div class="line"><span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>通过<code>-gcflags=&quot;-m=2&quot;</code>, 我们可以观察内联和逃逸分析的结果，可以看到编译器优化了强制转换的函数，将string转换为bytes的操作优化为零拷贝。</p>
<p>而上一节我们的benchmark中，<code>bts = toRawBytes(s)</code>这个操作，会导致<code>([]byte)(s)</code>逃逸到堆上，这样就会有一次内存分配，并且性能底下。</p>
<p>所以你现在情况了，Go1.22确实对强制转换做了优化，但是这个优化是通过编译器的内联和逃逸分析来实现的，并不是所有的场景都能够优化到零拷贝。</p>
<p>谁能在编写代码的时候注意到这个优化呢，甚至准确的判断能否避免逃逸？所以可能在现阶段，我们还是会通过其他三种方式进行优化。</p>
<p>貌似Go 1.23会进一步优化，参考这个CL: <a href="https://github.com/golang/go/commit/925d2fb36c8e4c9c0e6e240a1621db36c34e5d31" target="_blank" rel="external">cmd/compile: restore zero-copy string-&gt;[]byte optimization</a></p>
<h2 id="k8s实现的问题">k8s实现的问题</h2>
<p>一开始，我们留了一个问题：<code>toK8sBytes</code>返回的[]byte的cap是多少？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> toK8sBytes(s <span class="typename">string</span>) []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&s))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>len</code>是明确的，字段对应字符串的len字段，但是<code>cap</code>是多少呢？字符串可是没有<code>cap</code>字段的。</p>
<p>我们可以通过下面的代码来验证:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Test_toK8sBytes(t *testing.T) {</div><div class="line">	a := *(*<span class="number">[3</span>]<span class="typename">int64</span>)(unsafe.Pointer(&s))</div><div class="line">	fmt.Printf(<span class="string">"%d, %d, %d\n"</span>, a<span class="number">[0</span>], a<span class="number">[1</span>], a<span class="number">[2</span>])</div><div class="line"></div><div class="line">	b := *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&s))</div><div class="line">	fmt.Printf(<span class="string">"%d, %d, %d\n"</span>, unsafe.SliceData(b), <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先我们强制获取三个字段，第一个字段应该是字符串底层数据的指针。第二个字段是字符串的长度，第三个字段是什么呢？<br>同样我进行强制转换成slice of byte, 然后打印slice的底层数据指针，长度和容量。</p>
<p>输出结果如下(每次运行可能会得到不同的结果):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4375580047, 12, 4375914624</div><div class="line">4375580047, 12, 4375914624</div></pre></td></tr></table></figure>

<p>可以看到两者的结果是一致的，第一个值就是底层数据指针，第二个值是长度12，第三个啥也不是，就取得的内存中的值，随机的，并不是容量12。</p>
<p>所以通过这种方式转换的slice，其容量是不确定的，这个是一个问题，可能会导致一些问题，比如slice的append操作。</p>
<p>1、如果得到的slice的容量那么大，我们是不是尽情的append数据呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">b := *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&s))</div><div class="line">fmt.Printf(<span class="string">"%d, %d, %d\n"</span>, unsafe.SliceData(b), <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</div><div class="line"></div><div class="line">b = <span class="built_in">append</span>(b, <span class="string">'!'</span>)</div></pre></td></tr></table></figure>

<p>运行上面的测试会导致panic:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">unexpected fault address <span class="number">0x105020dfb</span></div><div class="line">fatal error: fault</div><div class="line">[signal SIGBUS: bus error code=<span class="number">0x1</span> addr=<span class="number">0x105020dfb</span> pc=<span class="number">0x10501ee98</span>]</div></pre></td></tr></table></figure>

<p>2、如果修改返回的bytes, 共享底层数据的原始string是不是也会发生变化？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">b := *(*[]<span class="typename">byte</span>)(unsafe.Pointer(&s))</div><div class="line">fmt.Printf(<span class="string">"%d, %d, %d\n"</span>, unsafe.SliceData(b), <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</div><div class="line">b<span class="number">[0</span>] = <span class="string">'H'</span></div></pre></td></tr></table></figure>

<p>运行上面的测试，会导致string的值<code>s</code>发生变化吗? 答案是不会，运行这段代码依然会导致panic&quot;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">unexpected fault address <span class="number">0x104f1cdcf</span></div><div class="line">fatal error: fault</div><div class="line">[signal SIGBUS: bus error code=<span class="number">0x1</span> addr=<span class="number">0x104f1cdcf</span> pc=<span class="number">0x104f1ae74</span>]</div></pre></td></tr></table></figure>

<p>3、如果修改原始的bytes, 返回的string是不是也会发生变化？<br>我们知道，字符串是不可变的，所以这个问题的答案是？<br>测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c := *(*<span class="typename">string</span>)(unsafe.Pointer(&bts))</div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, c)</div><div class="line">bts<span class="number">[0</span>] = <span class="string">'H'</span></div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, c)</div></pre></td></tr></table></figure>

<p>原始的bytes bts发生变化，返回的string c会发生变化吗？上面的代码打印出修改前后同一个字符串的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello, world</div><div class="line">Hello, world</div></pre></td></tr></table></figure>

<p>哈，字符串也变成了&quot;可变&quot;的了。</p>
<h2 id="总结">总结</h2>
<p>Go 1.22中，string和bytes的互转在部分场景(未逃逸的情况)下做了优化，实现了零拷贝，性能优秀，但是并不是所有的场景都能优化到零拷贝，所以我们、可以再等等，再等几个版本优化完全后再替换传统的互转方式。</p>
<p>在字符串和bytes互转的情况下，我们要确定bytes是不是可变的，这样会避免意外的情况发生，否则不妨采用强制转换的方式，安全第一。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天公司群中同事提到 Go 1.22 中 string 和 bytes 的互转不需要再用 unsafe 那个包了，直接转就可以。我翻看了 Go 1.22 的 release notes 没找到相应的介绍，但是大家提到了 kubernetes 的 <a href="https://github.com/kubernetes/kubernetes/issues/124656" target="_blank" rel="external">issue</a> 中有这个说法：</p>
<blockquote>
<p>As of go 1.22, for string to bytes conversion, we can replace the usage of <code>unsafe.Slice(unsafe.StringData(s), len(s))</code> with type casting <code>[]bytes(str)</code>, without the worry of losing performance.</p>
<p>As of go 1.22, string to bytes conversion <code>[]bytes(str)</code> is faster than using the <code>unsafe</code> package. Both methods have 0 memory allocation now.</p>
</blockquote>
<blockquote>
<p>自 Go 1.22 起，对于 string 到 bytes 的转换，我们可以用类型转换 <code>[]bytes(str)</code> 来替换 <code>unsafe.Slice(unsafe.StringData(s), len(s))</code> 的用法，而不用担心性能损失。<br>自 Go 1.22 起，string 到 bytes 的转换 <code>[]bytes(str)</code> 比使用 unsafe 包更快。现在两种方法都不会有内存分配。</p>
</blockquote>
<p>这个说法让我很好奇，但是我还是想验证一下这个说法。</p>
<p>注意，这个说法只谈到了 string 到 bytes 的转换，并没有提到 bytes 到 string 的转换，这篇文章也会关注这两者的互转。</p>
<p>首先，让我们看看几种 string 和 bytes 的转换方式，然后我们再写 benchmark 比较它们之间的性能。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[没有什么不可能：修改 Go 结构体的私有字段]]></title>
    <link href="https://colobu.com/2024/08/08/access-the-unexported-fields/"/>
    <id>https://colobu.com/2024/08/08/access-the-unexported-fields/</id>
    <published>2024-08-08T15:12:59.000Z</published>
    <updated>2024-08-14T05:10:38.219Z</updated>
    <content type="html"><![CDATA[<p>在Go语言中,结构体(struct)中的字段如果是私有的,只能在定义该结构体的同一个包内访问。这是为了实现数据的封装和信息隐藏,提高代码的健壮性和安全性。</p>
<p>但是在某些情况下,我们可能需要在外部包中访问或修改结构体的私有字段。这时,我们可以使用 Go 语言提供的反射(reflect)机制来实现这一功能。</p>
<p>即使我们能够实现访问，这些字段你没有办法修改，如果尝试通过反射设置这些私有字段的值，会 panic。</p>
<p>甚至有时，我们通过反射设置一些变量或者字段的值的时候，会 panic, 报错 <code>panic: reflect: reflect.Value.Set using unaddressable value</code>。</p>
<p>在本文中，你将了解到：</p>
<ol>
<li>如何通过 hack 的方式访问外部结构体的私有字段</li>
<li>如何通过 hack 的方式设置外部结构体的私有字段</li>
<li>如何通过 hack 的方式设置 unaddressable 的值</li>
</ol>
<a id="more"></a>
<p>首先我先介绍通过反射设置值遇到的 unaddressable 的困境。</p>
<h2 id="通过反射设置一个变量的值">通过反射设置一个变量的值</h2>
<p>如果你使用过反射设置值的变量，你可能熟悉下面的代码，而且这个代码工作正常：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x =<span class="number"> 47</span></div><div class="line"></div><div class="line">v := reflect.ValueOf(&x).Elem()</div><div class="line">fmt.Printf(<span class="string">"原始值: %d, CanSet: %v\n"</span>, v.Int(), v.CanSet()) <span class="comment">// 47, false</span></div><div class="line">v.Set(reflect.ValueOf<span class="number">(50</span>))</div></pre></td></tr></table></figure>

<p>注意这里传入给 <code>reflect.ValueOf</code> 的是 x 的指针 <code>&amp;x</code>, 所以这个 Value 值是 <code>addresable</code> 的，我们可以进行赋值。</p>
<p>如果把 <code>&amp;x</code> 替换成 <code>x</code>, 我们再尝试运行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x =<span class="number"> 47</span></div><div class="line"></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">fmt.Printf(<span class="string">"Original value: %d, CanSet: %v\n"</span>, v.Int(), v.CanSet()) <span class="comment">// 47, false</span></div><div class="line">v.Set(reflect.ValueOf<span class="number">(50</span>))</div></pre></td></tr></table></figure>

<p>可以看到panic:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Original value: <span class="number">47</span>, CanSet: <span class="keyword">false</span></div><div class="line">panic: reflect: reflect.Value.Set using unaddressable value</div><div class="line"></div><div class="line">goroutine <span class="number">1</span> [running]:</div><div class="line">reflect.flag.mustBeAssignableSlow(<span class="number">0</span>x1400012c410?)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">272</span> +<span class="number">0</span>x74</div><div class="line">reflect.flag.mustBeAssignable(...)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">259</span></div><div class="line">reflect.Value.Set({<span class="number">0</span>x104e13e40?, <span class="number">0</span>x104e965b8?, <span class="number">0</span>x104dec7e6?}, {<span class="number">0</span>x104e13e40?, <span class="number">0</span>x104e0ada0?, <span class="number">0</span>x2?})</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">2319</span> +<span class="number">0</span>x58</div><div class="line">main.setUnaddressableValue()</div><div class="line">	<span class="regexp">/Users/</span>smallnest<span class="regexp">/workspace/</span>study<span class="regexp">/private/m</span>ain.go:<span class="number">27</span> +<span class="number">0</span>x1c0</div><div class="line">main.main()</div><div class="line">	<span class="regexp">/Users/</span>smallnest<span class="regexp">/workspace/</span>study<span class="regexp">/private/m</span>ain.go:<span class="number">18</span> +<span class="number">0</span>x1c</div><div class="line">exit status <span class="number">2</span></div></pre></td></tr></table></figure>

<p>文章最后我会介绍如何通过 hack 的方式解决这个问题。</p>
<p>接下来我再介绍访问私有字段的问题。</p>
<h2 id="访问外部包的结构体的私有字段">访问外部包的结构体的私有字段</h2>
<p>我们先准备一个 <code>model</code> 包，在它之下定义了两个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> model</div><div class="line"></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">	age  <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewPerson(name <span class="typename">string</span>, age <span class="typename">int</span>) Person {</div><div class="line">	<span class="keyword">return</span> Person{</div><div class="line">		Name: name,</div><div class="line">		age:  age, <span class="comment">// unexported field</span></div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> {</div><div class="line">	Name <span class="typename">string</span></div><div class="line">	Age  <span class="typename">int</span> <span class="comment">// exported field</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewTeacher(name <span class="typename">string</span>, age <span class="typename">int</span>) Teacher {</div><div class="line">	<span class="keyword">return</span> Teacher{</div><div class="line">		Name: name,</div><div class="line">		Age:  age,</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>Person</code>的<code>age</code>字段是私有的，<code>Teacher</code>的<code>Age</code>字段是公开的。</p>
<p>在我们的<code>main</code>函数中，你不能访问<code>Person</code>的<code>age</code>字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main;</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">    <span class="string">"unsafe"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/smallnest/private/model"</span></div><div class="line">)   </div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    p := model.NewPerson(<span class="string">"Alice"</span>,<span class="number"> 30</span>)</div><div class="line">    fmt.Printf(<span class="string">"Person: %+v\n"</span>, p)</div><div class="line"></div><div class="line">    <span class="comment">// fmt.Println(p.age) // error: p.age undefined (cannot refer to unexported field or method age)</span></div><div class="line"></div><div class="line">    t := model.NewTeacher(<span class="string">"smallnest"</span>,<span class="number"> 18</span>)</div><div class="line">    fmt.Printf(<span class="string">"Teacher: %+v\n"</span>, t) <span class="comment">// Teacher: {Name:Alice Age:30}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>那么真的就无法访问了吗？也不一定，我们可以通过反射的方式访问私有字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p := model.NewPerson(<span class="string">"Alice"</span>,<span class="number"> 30</span>)</div><div class="line"></div><div class="line">age := reflect.ValueOf(p).FieldByName(<span class="string">"age"</span>)</div><div class="line">fmt.Printf(<span class="string">"原始值: %d, CanSet: %v\n"</span>, age.Int(), age.CanSet()) <span class="comment">// 30, false</span></div></pre></td></tr></table></figure>

<p>运行这个程序，可以看到我们获得了这个私有字段<code>age</code>的值:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">原始值: <span class="number">30</span>, CanSet: <span class="literal">false</span></div></pre></td></tr></table></figure>

<p>这样我们就绕过了Go语言的访问限制，访问了私有字段。</p>
<h2 id="设置结构体的私有字段">设置结构体的私有字段</h2>
<p>但是如果我们尝试修改这个私有字段的值，会 panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">age.SetInt<span class="number">(50</span>)</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">age.Set(reflect.ValueOf<span class="number">(50</span>))</div></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">原始值: <span class="number">30</span>, CanSet: <span class="keyword">false</span></div><div class="line">panic: reflect: reflect.Value.SetInt using value obtained using unexported field</div><div class="line"></div><div class="line">goroutine <span class="number">1</span> [running]:</div><div class="line">reflect.flag.mustBeAssignableSlow(<span class="number">0</span>x2?)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">269</span> +<span class="number">0</span>xb4</div><div class="line">reflect.flag.mustBeAssignable(...)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">259</span></div><div class="line">reflect.Value.SetInt({<span class="number">0</span>x1050ac0c0?, <span class="number">0</span>x14000118f20?, <span class="number">0</span>x1050830a8?}, <span class="number">0</span>x32)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">2398</span> +<span class="number">0</span>x44</div><div class="line">main.setUnexportedField()</div><div class="line">	<span class="regexp">/Users/</span>smallnest<span class="regexp">/workspace/</span>study<span class="regexp">/private/m</span>ain.go:<span class="number">37</span> +<span class="number">0</span>x1a0</div><div class="line">main.main()</div><div class="line">	<span class="regexp">/Users/</span>smallnest<span class="regexp">/workspace/</span>study<span class="regexp">/private/m</span>ain.go:<span class="number">18</span> +<span class="number">0</span>x1c</div><div class="line">exit status <span class="number">2</span></div></pre></td></tr></table></figure>

<p>实际上，<code>reflect.Value</code>的<code>Set</code>方法会做一系列的检查，包括检查是否是<code>addressable</code>的，以及是否是exported的字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (v Value) Set(x Value) {</div><div class="line">	v.mustBeAssignable()</div><div class="line">	x.mustBeExported() <span class="comment">// do not let unexported x leak</span></div><div class="line">	...</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>v.mustBeAssignable()</code>检查是否是<code>addressable</code>的，而且是exported的字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (f flag) mustBeAssignable() {</div><div class="line">	<span class="keyword">if</span> f&flagRO !=<span class="number"> 0</span> || f&flagAddr ==<span class="number"> 0</span> {</div><div class="line">		f.mustBeAssignableSlow()</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (f flag) mustBeAssignableSlow() {</div><div class="line">	<span class="keyword">if</span> f ==<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(&ValueError{valueMethodName(), Invalid})</div><div class="line">	}</div><div class="line">	<span class="comment">// Assignable if addressable and not read-only.</span></div><div class="line">	<span class="keyword">if</span> f&flagRO !=<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"reflect: "</span> + valueMethodName() + <span class="string">" using value obtained using unexported field"</span>)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> f&flagAddr ==<span class="number"> 0</span> {</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"reflect: "</span> + valueMethodName() + <span class="string">" using unaddressable value"</span>)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>f&amp;flagRO == 0</code> 代表是可写的（<code>exported</code>），<code>f&amp;flagAddr != 0</code> 代表是<code>addressable</code>的,当这两个条件任意一个不满足时，就会报错。</p>
<p>既然我们明白了它检查的原理，我们就可以通过 hack 的方式绕过这个检查，设置私有字段的值。我们还是要使用<code>unsafe</code>代码。</p>
<p>这里我们以标准库的<code>sync.Mutex</code>结构体为例， <code>sync.Mutex</code>包含两个字段，这两个字段都是私有的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">    state <span class="typename">int32</span></div><div class="line">    sema  <span class="typename">uint32</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>正常情况下你只能通过<code>Mutex.Lock</code>和<code>Mutex.Unlock</code>来间接的修改这两个字段。</p>
<p>现在我们演示通过 hack 的方式修改<code>Mutex</code>的<code>state</code>字段的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> setPrivateField() {</div><div class="line">	<span class="keyword">var</span> mu sync.Mutex</div><div class="line">	mu.Lock()</div><div class="line"></div><div class="line">	field := reflect.ValueOf(&mu).Elem().FieldByName(<span class="string">"state"</span>)</div><div class="line">	state := field.Interface().(*<span class="typename">int32</span>)</div><div class="line">	fmt.Println(*state) <span class="comment">// ❶ </span></div><div class="line"></div><div class="line">	flagField := reflect.ValueOf(&field).Elem().FieldByName(<span class="string">"flag"</span>)</div><div class="line">	flagPtr := (*<span class="typename">uintptr</span>)(unsafe.Pointer(flagField.UnsafeAddr()))</div><div class="line"></div><div class="line">	<span class="comment">// 修改flag字段的值</span></div><div class="line">	*flagPtr &= ^<span class="typename">uintptr</span>(flagRO) <span class="comment">// ❷</span></div><div class="line">	field.Set(reflect.ValueOf(<span class="typename">int32</span><span class="number">(0</span>)))</div><div class="line"></div><div class="line">	mu.Lock() <span class="comment">// ❸</span></div><div class="line">	fmt.Println(*state)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> flag <span class="typename">uintptr</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	flagKindWidth        =<span class="number"> 5</span> <span class="comment">// there are 27 kinds</span></div><div class="line">	flagKindMask    flag =<span class="number"> 1</span>&lt;&lt;flagKindWidth -<span class="number"> 1</span></div><div class="line">	flagStickyRO    flag =<span class="number"> 1</span> &lt;&lt;<span class="number"> 5</span></div><div class="line">	flagEmbedRO     flag =<span class="number"> 1</span> &lt;&lt;<span class="number"> 6</span></div><div class="line">	flagIndir       flag =<span class="number"> 1</span> &lt;&lt;<span class="number"> 7</span></div><div class="line">	flagAddr        flag =<span class="number"> 1</span> &lt;&lt;<span class="number"> 8</span></div><div class="line">	flagMethod      flag =<span class="number"> 1</span> &lt;&lt;<span class="number"> 9</span></div><div class="line">	flagMethodShift      =<span class="number"> 10</span></div><div class="line">	flagRO          flag = flagStickyRO | flagEmbedRO</div><div class="line">)</div></pre></td></tr></table></figure>

<p>❶ 处我们已经介绍过了，访问私有字段的值，这里会打印出1<br>❶ 处我们清除了<code>flag</code>字段的<code>flagRO</code>标志位，这样就不会报<code>reflect: reflect.Value.SetInt using value obtained using unexported field</code>错误了<br>❸ 处不会导致二次加锁带来的死锁，因为<code>state</code>字段的值已经被修改为0了，所以不会阻塞。最后打印结果还是1</p>
<p>这样我们就可以实现了修改私有字段的值了。</p>
<h2 id="使用unexported字段的Value设置公开字段">使用unexported字段的Value设置公开字段</h2>
<p>看<code>reflect.Value.Set</code>的源码，我们可以看到它会检查参数的值是否<code>unexported</code>，如果是，就会报错,下面就是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> setUnexportedField2() {</div><div class="line">	alice := model.NewPerson(<span class="string">"Alice"</span>,<span class="number"> 30</span>)</div><div class="line">	bob := model.NewTeacher(<span class="string">"Bob"</span>,<span class="number"> 40</span>)</div><div class="line"></div><div class="line">	bobAgent := reflect.ValueOf(&bob).Elem().FieldByName(<span class="string">"Age"</span>)</div><div class="line"></div><div class="line">	aliceAge := reflect.ValueOf(&alice).Elem().FieldByName(<span class="string">"age"</span>)</div><div class="line"></div><div class="line">	bobAgent.Set(aliceAge) <span class="comment">// ❹</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意❹处，我们尝试把<code>alice</code>的私有字段<code>age</code>的值赋值给<code>bob</code>的公开字段<code>Age</code>，这里会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">panic</span>: <span class="string">reflect: reflect.Value.Set using value obtained using unexported field</span></div><div class="line"></div><div class="line"><span class="gradle">goroutine <span class="number">1</span> [running]:</span></div><div class="line">reflect.flag.mustBeExportedSlow(<span class="number">0</span>x1400012a000?)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">250</span> +<span class="number">0</span>x70</div><div class="line">reflect.flag.mustBeExported(...)</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">241</span></div><div class="line">reflect.Value.Set({<span class="number">0</span>x102773a60?, <span class="number">0</span>x1400012a028?, <span class="number">0</span>x60?}, {<span class="number">0</span>x102773a60?, <span class="number">0</span>x1400012a010?, <span class="number">0</span>x1027002b8?})</div><div class="line">	<span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/reflect/</span>value.go:<span class="number">2320</span> +<span class="number">0</span>x88</div><div class="line">main.setUnexportedField2()</div><div class="line">	<span class="regexp">/Users/</span>smallnest<span class="regexp">/workspace/</span>study<span class="regexp">/private/m</span>ain.go:<span class="number">50</span> +<span class="number">0</span>x168</div><div class="line">main.main()</div><div class="line">	<span class="regexp">/Users/</span>smallnest<span class="regexp">/workspace/</span>study<span class="regexp">/private/m</span>ain.go:<span class="number">18</span> +<span class="number">0</span>x1c</div><div class="line">exit status <span class="number">2</span></div></pre></td></tr></table></figure>

<p>原因<code>alice</code>的<code>age</code>值被识别为私有字段，它是不能用来赋值给公开字段的。</p>
<p>有了上一节的经验，我们同样可以绕过这个检查，实现这个赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> setUnexportedField2() {</div><div class="line">	alice := model.NewPerson(<span class="string">"Alice"</span>,<span class="number"> 30</span>)</div><div class="line">	bob := model.NewTeacher(<span class="string">"Bob"</span>,<span class="number"> 40</span>)</div><div class="line"></div><div class="line">	bobAgent := reflect.ValueOf(&bob).Elem().FieldByName(<span class="string">"Age"</span>)</div><div class="line"></div><div class="line">	aliceAge := reflect.ValueOf(&alice).Elem().FieldByName(<span class="string">"age"</span>)</div><div class="line">	<span class="comment">// 修改flag字段的值</span></div><div class="line">	flagField := reflect.ValueOf(&aliceAge).Elem().FieldByName(<span class="string">"flag"</span>)</div><div class="line">	flagPtr := (*<span class="typename">uintptr</span>)(unsafe.Pointer(flagField.UnsafeAddr()))</div><div class="line">	*flagPtr &= ^<span class="typename">uintptr</span>(flagRO) <span class="comment">// ❺</span></div><div class="line"></div><div class="line">	bobAgent.Set(reflect.ValueOf<span class="number">(50</span>))</div><div class="line">	bobAgent.Set(aliceAge) <span class="comment">// ❻</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>❺ 处我们修改了<code>aliceAge</code>的<code>flag</code>字段，去掉了<code>flagRO</code>标志位，这样就不会报错了,❻处我们成功的把<code>alice</code>的私有字段<code>age</code>的值赋值给<code>bob</code>的公开字段<code>Age</code>。</p>
<p>这样我们就可以实现了使用私有字段的值给其他Value值进行赋值了。</p>
<h2 id="给unaddressable的值设置值">给unaddressable的值设置值</h2>
<p>回到最初的问题，我们尝试给一个unaddressable的值设置值，会报错。</p>
<p>结合上面的hack手段，我们也可以绕过限制，给unaddressable的值设置值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> setUnaddressableValue() {</div><div class="line">	<span class="keyword">var</span> x =<span class="number"> 47</span></div><div class="line"></div><div class="line">	v := reflect.ValueOf(x)</div><div class="line">	fmt.Printf(<span class="string">"原始值: %d, CanSet: %v\n"</span>, v.Int(), v.CanSet()) <span class="comment">// 47, false</span></div><div class="line">	<span class="comment">// v.Set(reflect.ValueOf(50))</span></div><div class="line"></div><div class="line">	flagField := reflect.ValueOf(&v).Elem().FieldByName(<span class="string">"flag"</span>)</div><div class="line">	flagPtr := (*<span class="typename">uintptr</span>)(unsafe.Pointer(flagField.UnsafeAddr()))</div><div class="line"></div><div class="line">	<span class="comment">// 修改flag字段的值</span></div><div class="line">	*flagPtr |= <span class="typename">uintptr</span>(flagAddr)          <span class="comment">// 设置可寻址标志位</span></div><div class="line">	fmt.Printf(<span class="string">"CanSet: %v\n"</span>, v.CanSet()) <span class="comment">// true</span></div><div class="line">	v.SetInt<span class="number">(50</span>)</div><div class="line">	fmt.Printf(<span class="string">"修改后的值: %d\n"</span>, v.Int()) <span class="comment">// 50</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行这个程序，不会报错，可以看到我们成功的给unaddressable的值设置了新的值。</p>
<h2 id="回顾">回顾</h2>
<p>我们通过修改<code>Value</code>值的flag标志位，可以绕过<code>reflect</code>的检查，实现了访问私有字段、设置私有字段的值、用私有字段设置值，以及给unaddressable的值设置值。</p>
<p>这些都是<code>unsafe</code>的方式，一般情况下不鼓励进行这样的hack操作，但是这种技术也不是完全没有用户，如果你正在写一个debugger，用户在断点出可能想修改某些值，或者你在写深拷贝的库，或者编写某种ORM库，或者你就像突破限制，访问第三方不愿意公开的字段，你有可能会采用这种非常规的技术。</p>
<p>我是鸟窝，一位老程序员，在百度写代码。如果你感觉这篇文章给你带来了帮助，请点击下方点赞按钮或者评论区进行评论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Go语言中,结构体(struct)中的字段如果是私有的,只能在定义该结构体的同一个包内访问。这是为了实现数据的封装和信息隐藏,提高代码的健壮性和安全性。</p>
<p>但是在某些情况下,我们可能需要在外部包中访问或修改结构体的私有字段。这时,我们可以使用 Go 语言提供的反射(reflect)机制来实现这一功能。</p>
<p>即使我们能够实现访问，这些字段你没有办法修改，如果尝试通过反射设置这些私有字段的值，会 panic。</p>
<p>甚至有时，我们通过反射设置一些变量或者字段的值的时候，会 panic, 报错 <code>panic: reflect: reflect.Value.Set using unaddressable value</code>。</p>
<p>在本文中，你将了解到：</p>
<ol>
<li>如何通过 hack 的方式访问外部结构体的私有字段</li>
<li>如何通过 hack 的方式设置外部结构体的私有字段</li>
<li>如何通过 hack 的方式设置 unaddressable 的值</li>
</ol>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用eBPF编写系统调用跟踪器]]></title>
    <link href="https://colobu.com/2024/08/04/beetracer/"/>
    <id>https://colobu.com/2024/08/04/beetracer/</id>
    <published>2024-08-04T09:27:25.000Z</published>
    <updated>2024-08-09T06:26:33.133Z</updated>
    <content type="html"><![CDATA[<h2 id="先决条件">先决条件</h2>
<p>系统调用、eBPF、C语言、底层编程基础。</p>
<h2 id="简介">简介</h2>
<p>eBPF(扩展的伯克利数据包过滤器)是一项允许用户在内核中运行自定义程序的技术。BPF或cBPF(经典BPF)是eBPF的前身,它提供了一种简单高效的方法来基于预定义规则过滤数据包。与内核模块相比,eBPF程序提供了更高的安全性、可移植性和可维护性。现有多种高级方法可用于处理eBPF程序,如Cilium的Go语言库、bpftrace、libbpf等。</p>
<ul>
<li><code>注意</code>: 本文要求读者对<code>eBPF</code>有基本了解。如果你不熟悉它,<code>ebpf.io</code>上的这篇文章是很好的参考资料。</li>
</ul>
<a id="more"></a>
<h2 id="目标">目标</h2>
<p>你应该已经熟悉著名的工具 <code>strace</code>。我们将使用eBPF开发类似的工具。例如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./beetrace /bin/ls</div></pre></td></tr></table></figure>

<p>以下是该文本的地道中文翻译：</p>
<h2 id="概念">概念</h2>
<p>在开始编写我们的工具之前，我们需要熟悉一些关键概念。</p>
<ol>
<li><code>跟踪点（Tracepoints）</code>：这些是放置在 Linux 内核代码各个部分的检测点。它们提供了一种方法，可以在不修改内核源代码的情况下，钩入内核中的特定事件或代码路径。可用于跟踪的事件可以在 <code>/sys/kernel/debug/tracing/events</code> 中找到。</li>
<li><code>SEC</code> 宏：它在目标 ELF 文件中创建一个新的段，段名与跟踪点的名称相同。例如，<code>SEC(tracepoint/raw_syscalls/sys_enter)</code> 创建了一个具有这个名称的新段。可以使用 readelf 命令查看这些段。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readelf <span class="operator">-s</span> --wide somefile.o</div></pre></td></tr></table></figure>

<ol start="3">
<li><code>映射（Maps）</code>：这些是可以从 eBPF 程序和用户空间运行的应用程序中访问的共享数据结构。</li>
</ol>
<h2 id="编写_eBPF_程序">编写 eBPF 程序</h2>
<p>由于 Linux 内核中存在大量的系统调用，我们不会编写一个全面的工具来跟踪所有系统调用。相反，我们将专注于跟踪几个常见的系统调用。为了实现这一目标，我们将编写两类程序：eBPF 程序和加载器（用于将 BPF 对象加载到内核并将其附加进来）。</p>
<p>让我们首先创建一些数据结构来进行初始设置:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// controller.h</span></div><div class="line"></div><div class="line"><span class="comment">// SYS_ENTER : for retrieving system call arguments</span></div><div class="line"><span class="comment">// SYS_EXIT : for retrieving the return values of syscalls</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">{</div><div class="line">    SYS_ENTER,</div><div class="line">    SYS_EXIT</div><div class="line">} event_mode;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> inner_syscall_info</div><div class="line">{</div><div class="line">    <span class="keyword">union</span></div><div class="line">    {</div><div class="line">        <span class="keyword">struct</span></div><div class="line">        {</div><div class="line">            <span class="comment">// For SYS_ENTER mode</span></div><div class="line">            <span class="keyword">char</span> name[<span class="number">32</span>];</div><div class="line">            <span class="keyword">int</span> num_args;</div><div class="line">            <span class="keyword">long</span> syscall_nr;</div><div class="line">            <span class="keyword">void</span> *args[MAX_ARGS];</div><div class="line">        };</div><div class="line">        <span class="keyword">long</span> retval; <span class="comment">// For SYS_EXIT mode</span></div><div class="line">    };</div><div class="line">    event_mode mode;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> default_syscall_info{</div><div class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</div><div class="line">    <span class="keyword">int</span> num_args;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Array for storing the name and argument count of system calls</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> default_syscall_info syscalls[MAX_SYSCALL_NR] = {</div><div class="line">    [SYS_fork] = {<span class="string">"fork"</span>, <span class="number">0</span>},</div><div class="line">    [SYS_alarm] = {<span class="string">"alarm"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_brk] = {<span class="string">"brk"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_close] = {<span class="string">"close"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_exit] = {<span class="string">"exit"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_exit_group] = {<span class="string">"exit_group"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_set_tid_address] = {<span class="string">"set_tid_address"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_set_robust_list] = {<span class="string">"set_robust_list"</span>, <span class="number">1</span>},</div><div class="line">    [SYS_access] = {<span class="string">"access"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_arch_prctl] = {<span class="string">"arch_prctl"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_kill] = {<span class="string">"kill"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_listen] = {<span class="string">"listen"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_munmap] = {<span class="string">"sys_munmap"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_open] = {<span class="string">"open"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_stat] = {<span class="string">"stat"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_fstat] = {<span class="string">"fstat"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_lstat] = {<span class="string">"lstat"</span>, <span class="number">2</span>},</div><div class="line">    [SYS_accept] = {<span class="string">"accept"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_connect] = {<span class="string">"connect"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_execve] = {<span class="string">"execve"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_ioctl] = {<span class="string">"ioctl"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_getrandom] = {<span class="string">"getrandom"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_lseek] = {<span class="string">"lseek"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_poll] = {<span class="string">"poll"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_read] = {<span class="string">"read"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_write] = {<span class="string">"write"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_mprotect] = {<span class="string">"mprotect"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_openat] = {<span class="string">"openat"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_socket] = {<span class="string">"socket"</span>, <span class="number">3</span>},</div><div class="line">    [SYS_newfstatat] = {<span class="string">"newfstatat"</span>, <span class="number">4</span>},</div><div class="line">    [SYS_pread64] = {<span class="string">"pread64"</span>, <span class="number">4</span>},</div><div class="line">    [SYS_prlimit64] = {<span class="string">"prlimit64"</span>, <span class="number">4</span>},</div><div class="line">    [SYS_rseq] = {<span class="string">"rseq"</span>, <span class="number">4</span>},</div><div class="line">    [SYS_sendfile] = {<span class="string">"sendfile"</span>, <span class="number">4</span>},</div><div class="line">    [SYS_socketpair] = {<span class="string">"socketpair"</span>, <span class="number">4</span>},</div><div class="line">    [SYS_mmap] = {<span class="string">"mmap"</span>, <span class="number">6</span>},</div><div class="line">    [SYS_recvfrom] = {<span class="string">"recvfrom"</span>, <span class="number">6</span>},</div><div class="line">    [SYS_sendto] = {<span class="string">"sendto"</span>, <span class="number">6</span>},</div><div class="line">};</div></pre></td></tr></table></figure>

<p>加载器将读取用户通过命令行参数提供的待追踪 ELF 文件的路径。然后，加载器会创建一个子进程，并使用 <code>execve</code> 来运行命令行参数中指定的程序。</p>
<p>父进程将处理加载和附加 eBPF 程序所需的所有设置。它还执行一项关键任务：通过 BPF 哈希映射将子进程的 ID 发送给 eBPF 程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// loader.c</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</div><div class="line">  {</div><div class="line">    fatal_error(<span class="string">"Usage: ./beetrace &lt;path_to_program&gt;"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *file_path = argv[<span class="number">1</span>];</div><div class="line"></div><div class="line">  pid_t pid = fork();</div><div class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">  {</div><div class="line">    <span class="comment">// Child process</span></div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/null"</span>, O_WRONLY);</div><div class="line">    <span class="keyword">if</span>(fd==-<span class="number">1</span>){</div><div class="line">        <span class="comment">// error</span></div><div class="line">    }</div><div class="line">    dup2(fd, <span class="number">1</span>); <span class="comment">// disable stdout for the child process</span></div><div class="line">    sleep(<span class="number">2</span>); <span class="comment">// wait for the parent process to do the required setup for tracing</span></div><div class="line">    execve(file_path, NULL, NULL);</div><div class="line">  }</div><div class="line">  <span class="keyword">else</span>{</div><div class="line">    <span class="comment">// Parent process</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>要追踪系统调用，我们需要编写由 <code>tracepoint/raw_syscalls/sys_enter</code> 和 <code>tracepoint/raw_syscalls/sys_exit</code> 跟踪点触发的 eBPF 程序。这些跟踪点提供了对系统调用号和参数的访问。对于给定的系统调用，<code>tracepoint/raw_syscalls/sys_enter</code> 跟踪点总是在 <code>tracepoint/raw_syscalls/sys_exit</code> 跟踪点之前触发。我们可以使用前者获取系统调用参数，使用后者获取返回值。</p>
<p>此外，我们将使用 eBPF 映射在用户空间程序和我们的 eBPF 程序之间共享信息。具体来说，我们将使用两种类型的 eBPF 映射：哈希映射和环形缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// controller.c</span></div><div class="line"></div><div class="line"><span class="comment">// Hashmap</span></div><div class="line"><span class="keyword">struct</span></div><div class="line">{</div><div class="line">  __uint(type, BPF_MAP_TYPE_HASH);</div><div class="line">  __uint(key_size, <span class="number">10</span>);</div><div class="line">  __uint(value_size, <span class="number">4</span>);</div><div class="line">  __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</div><div class="line">} pid_hashmap SEC(<span class="string">".maps"</span>);</div><div class="line"></div><div class="line"><span class="comment">// Ring buffer</span></div><div class="line"><span class="keyword">struct</span></div><div class="line">{</div><div class="line">  __uint(type, BPF_MAP_TYPE_RINGBUF);</div><div class="line">  __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</div><div class="line">} syscall_info_buffer SEC(<span class="string">".maps"</span>);</div></pre></td></tr></table></figure>

<p>确定了映射关系之后，我们就可以动手写代码了。首先，让我们来编写针对追踪点 tracepoint/raw_syscalls/sys_enter 的程序代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// loader.c</span></div><div class="line"></div><div class="line">SEC(<span class="string">"tracepoint/raw_syscalls/sys_enter"</span>)</div><div class="line"><span class="keyword">int</span> detect_syscall_enter(<span class="keyword">struct</span> trace_event_raw_sys_enter *ctx)</div><div class="line">{</div><div class="line">  <span class="comment">// Retrieve the system call number</span></div><div class="line">  <span class="keyword">long</span> syscall_nr = ctx-&gt;id;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"child_pid"</span>;</div><div class="line">  <span class="keyword">int</span> target_pid;</div><div class="line"></div><div class="line">  <span class="comment">// Reading the process id of the child process in userland</span></div><div class="line">  <span class="keyword">void</span> *value = bpf_map_lookup_elem(&pid_hashmap, key);</div><div class="line">  <span class="keyword">void</span> *args[MAX_ARGS];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (value)</div><div class="line">  {</div><div class="line">    target_pid = *(<span class="keyword">int</span> *)value;</div><div class="line"></div><div class="line">    <span class="comment">// PID of the process that executed the current system call</span></div><div class="line">    pid_t pid = bpf_get_current_pid_tgid() & <span class="number">0xffffffff</span>;</div><div class="line">    <span class="keyword">if</span> (pid == target_pid && syscall_nr &gt;= <span class="number">0</span> && syscall_nr &lt; MAX_SYSCALL_NR)</div><div class="line">    {</div><div class="line"></div><div class="line">      <span class="keyword">int</span> idx = syscall_nr;</div><div class="line">      <span class="comment">// Reserve space in the ring buffer</span></div><div class="line">      <span class="keyword">struct</span> inner_syscall_info *info = bpf_ringbuf_reserve(&syscall_info_buffer, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inner_syscall_info), <span class="number">0</span>);</div><div class="line">      <span class="keyword">if</span> (!info)</div><div class="line">      {</div><div class="line">        bpf_printk(<span class="string">"bpf_ringbuf_reserve failed"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Copy the syscall name into info-&gt;name</span></div><div class="line">      bpf_probe_read_kernel_str(info-&gt;name, <span class="keyword">sizeof</span>(syscalls[syscall_nr].name), syscalls[syscall_nr].name);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ARGS; i++)</div><div class="line">      {</div><div class="line">        info-&gt;args[i] = (<span class="keyword">void</span> *)BPF_CORE_READ(ctx, args[i]);</div><div class="line">      }</div><div class="line">      info-&gt;num_args = syscalls[syscall_nr].num_args;</div><div class="line">      info-&gt;syscall_nr = syscall_nr;</div><div class="line">      info-&gt;mode = SYS_ENTER;</div><div class="line">      <span class="comment">// Insert into ring buffer</span></div><div class="line">      bpf_ringbuf_submit(info, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同理，我们也能编写用于读取返回值并将其传递给用户态空间的程序代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// controller.c</span></div><div class="line"></div><div class="line">SEC(<span class="string">"tracepoint/raw_syscalls/sys_exit"</span>)</div><div class="line"><span class="keyword">int</span> detect_syscall_exit(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"child_pid"</span>;</div><div class="line">  <span class="keyword">void</span> *value = bpf_map_lookup_elem(&pid_hashmap, key);</div><div class="line">  pid_t pid, target_pid;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (value)</div><div class="line">  {</div><div class="line">    pid = bpf_get_current_pid_tgid() & <span class="number">0xffffffff</span>;</div><div class="line">    target_pid = *(pid_t *)value;</div><div class="line">    <span class="keyword">if</span> (pid == target_pid)</div><div class="line">    {</div><div class="line">      <span class="keyword">struct</span> inner_syscall_info *info = bpf_ringbuf_reserve(&syscall_info_buffer, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inner_syscall_info), <span class="number">0</span>);</div><div class="line">      <span class="keyword">if</span> (!info)</div><div class="line">      {</div><div class="line">        bpf_printk(<span class="string">"bpf_ringbuf_reserve failed"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      }</div><div class="line">      info-&gt;mode = SYS_EXIT;</div><div class="line">      info-&gt;retval = ctx-&gt;ret;</div><div class="line">      bpf_ringbuf_submit(info, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，让我们来完善加载器程序中父进程的功能部分。但在进行之前，我们需要理解几个关键函数的工作原理。<br>1、<code>bpf_object__open</code>: 通过打开由传递路径指向的 BPF ELF 对象文件并在内存中加载它，创建一个 <code>bpf_object</code> 结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">struct</span> bpf_object *bpf_object__open(<span class="keyword">const</span> <span class="keyword">char</span> *path);</div></pre></td></tr></table></figure>

<p>2、<code>bpf_object__load</code>: 将 BPF 对象加载到内核中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">int</span> bpf_object__load(<span class="keyword">struct</span> bpf_object *obj);</div></pre></td></tr></table></figure>

<p>3、<code>bpf_object__find_program_by_name</code>: 返回指向有效 BPF 程序的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">struct</span> bpf_program *bpf_object__find_program_by_name(<span class="keyword">const</span> <span class="keyword">struct</span> bpf_object *obj, <span class="keyword">const</span> <span class="keyword">char</span> *name);</div></pre></td></tr></table></figure>

<p>4、<code>bpf_program__attach</code>: 根据自动检测的程序类型、附加类型和适用的额外参数，将 BPF 程序附加到内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">struct</span> bpf_link *bpf_program__attach(<span class="keyword">const</span> <span class="keyword">struct</span> bpf_program *prog);</div></pre></td></tr></table></figure>

<p>5、<code>bpf_map__update_elem</code>: 允许在与提供的键对应的 BPF 映射中插入或更新值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">int</span> bpf_map__update_elem(<span class="keyword">const</span> <span class="keyword">struct</span> bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, size_t key_sz, <span class="keyword">const</span> <span class="keyword">void</span> *value, size_t value_sz, __u64 flags);</div></pre></td></tr></table></figure>

<p>6、<code>bpf_object__find_map_fd_by_name</code>: 给定一个 BPF 映射名称，返回该映射的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">int</span> bpf_object__find_map_fd_by_name(<span class="keyword">const</span> <span class="keyword">struct</span> bpf_object *obj, <span class="keyword">const</span> <span class="keyword">char</span> *name);</div></pre></td></tr></table></figure>

<p>7、<code>ring_buffer__new</code>: 返回指向环形缓冲区的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">struct</span> ring_buffer *ring_buffer__new(<span class="keyword">int</span> map_fd, ring_buffer_sample_fn sample_cb, <span class="keyword">void</span> *ctx, <span class="keyword">const</span> <span class="keyword">struct</span> ring_buffer_opts *opts);</div></pre></td></tr></table></figure>

<p>第二个参数必须是一个可用于处理从环形缓冲区接收的数据的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> syscall_logger(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *data, size_t len)</div><div class="line">{</div><div class="line">  <span class="keyword">struct</span> inner_syscall_info *info = (<span class="keyword">struct</span> inner_syscall_info *)data;</div><div class="line">  <span class="keyword">if</span> (!info)</div><div class="line">  {</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (info-&gt;mode == SYS_ENTER)</div><div class="line">  {</div><div class="line">    initialized = <span class="keyword">true</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s("</span>, info-&gt;name);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info-&gt;num_args; i++)</div><div class="line">    {</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%p,"</span>, info-&gt;args[i]);</div><div class="line">    }</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\b) = "</span>);</div><div class="line">  }</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mode == SYS_EXIT)</div><div class="line">  {</div><div class="line">    <span class="keyword">if</span> (initialized)</div><div class="line">    {</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"0x%lx\n"</span>, info-&gt;retval);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它会打印系统调用的名称和参数。</p>
<p>8、<code>ring_buffer__consume</code>: 此函数处理环形缓冲区中可用的事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIBBPF_API <span class="keyword">int</span> ring_buffer__consume(<span class="keyword">struct</span> ring_buffer *rb);</div></pre></td></tr></table></figure>

<p>现在我们有了编写加载器所需的一切要素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// loader.c</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bpf/libbpf.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "controller.h"</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fcntl.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/wait.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> fatal_error(<span class="keyword">const</span> <span class="keyword">char</span> *message)</div><div class="line">{</div><div class="line">  <span class="built_in">puts</span>(message);</div><div class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> syscall_logger(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *data, size_t len)</div><div class="line">{</div><div class="line">  <span class="keyword">struct</span> inner_syscall_info *info = (<span class="keyword">struct</span> inner_syscall_info *)data;</div><div class="line">  <span class="keyword">if</span> (!info)</div><div class="line">  {</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (info-&gt;mode == SYS_ENTER)</div><div class="line">  {</div><div class="line">    initialized = <span class="keyword">true</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s("</span>, info-&gt;name);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info-&gt;num_args; i++)</div><div class="line">    {</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%p,"</span>, info-&gt;args[i]);</div><div class="line">    }</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\b) = "</span>);</div><div class="line">  }</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mode == SYS_EXIT)</div><div class="line">  {</div><div class="line">    <span class="keyword">if</span> (initialized)</div><div class="line">    {</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"0x%lx\n"</span>, info-&gt;retval);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keyword">int</span> status;</div><div class="line">  <span class="keyword">struct</span> bpf_object *obj;</div><div class="line">  <span class="keyword">struct</span> bpf_program *enter_prog, *exit_prog;</div><div class="line">  <span class="keyword">struct</span> bpf_map *syscall_map;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *obj_name = <span class="string">"controller.o"</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *map_name = <span class="string">"pid_hashmap"</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *enter_prog_name = <span class="string">"detect_syscall_enter"</span>; </div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *exit_prog_name = <span class="string">"detect_syscall_exit"</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *syscall_info_bufname = <span class="string">"syscall_info_buffer"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</div><div class="line">  {</div><div class="line">    fatal_error(<span class="string">"Usage: ./beetrace &lt;path_to_program&gt;"</span>);</div><div class="line">  }</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *file_path = argv[<span class="number">1</span>];</div><div class="line"></div><div class="line">  pid_t pid = fork();</div><div class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/null"</span>, O_WRONLY);</div><div class="line">    <span class="keyword">if</span>(fd==-<span class="number">1</span>){</div><div class="line">      fatal_error(<span class="string">"failed to open /dev/null"</span>);</div><div class="line">    }</div><div class="line">    dup2(fd, <span class="number">1</span>);</div><div class="line">    sleep(<span class="number">2</span>);</div><div class="line">    execve(file_path, NULL, NULL);</div><div class="line">  }</div><div class="line">  <span class="keyword">else</span></div><div class="line">  {</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Spawned child process with a PID of %d\n"</span>, pid);</div><div class="line">    obj = bpf_object__open(obj_name);</div><div class="line">    <span class="keyword">if</span> (!obj)</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to open the BPF object"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (bpf_object__load(obj))</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to load the BPF object into kernel"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    enter_prog = bpf_object__find_program_by_name(obj, enter_prog_name);</div><div class="line">    exit_prog = bpf_object__find_program_by_name(obj, exit_prog_name);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!enter_prog || !exit_prog)</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to find the BPF program"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (!bpf_program__attach(enter_prog) || !bpf_program__attach(exit_prog))</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to attach the BPF program"</span>);</div><div class="line">    }</div><div class="line">    syscall_map = bpf_object__find_map_by_name(obj, map_name);</div><div class="line">    <span class="keyword">if</span> (!syscall_map)</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to find the BPF map"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"child_pid"</span>;</div><div class="line">    <span class="keyword">int</span> err = bpf_map__update_elem(syscall_map, key, <span class="number">10</span>, (<span class="keyword">void</span> *)&pid, <span class="keyword">sizeof</span>(pid_t), <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (err)</div><div class="line">    {</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%d"</span>, err);</div><div class="line">      fatal_error(<span class="string">"failed to insert child pid into the ring buffer"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">int</span> rbFd = bpf_object__find_map_fd_by_name(obj, syscall_info_bufname);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> ring_buffer *rbuffer = ring_buffer__new(rbFd, syscall_logger, NULL, NULL);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!rbuffer)</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to allocate ring buffer"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (wait(&status) == -<span class="number">1</span>)</div><div class="line">    {</div><div class="line">      fatal_error(<span class="string">"failed to wait for the child process"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">int</span> e = ring_buffer__consume(rbuffer);</div><div class="line">      <span class="keyword">if</span> (!e)</div><div class="line">      {</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      }</div><div class="line">      sleep(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以下便是 eBPF 程序的部分。所有的 C 语言源码最终会被编译整合成单一的对象文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// controller.c</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "vmlinux.h"</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bpf/bpf_helpers.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;bpf/bpf_core_read.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/syscall.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "controller.h"</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span></div><div class="line">{</div><div class="line">  __uint(type, BPF_MAP_TYPE_HASH);</div><div class="line">  __uint(key_size, <span class="number">10</span>);</div><div class="line">  __uint(value_size, <span class="number">4</span>);</div><div class="line">  __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</div><div class="line">} pid_hashmap SEC(<span class="string">".maps"</span>);</div><div class="line"></div><div class="line"><span class="keyword">struct</span></div><div class="line">{</div><div class="line">  __uint(type, BPF_MAP_TYPE_RINGBUF);</div><div class="line">  __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</div><div class="line">} syscall_info_buffer SEC(<span class="string">".maps"</span>);</div><div class="line"></div><div class="line"></div><div class="line">SEC(<span class="string">"tracepoint/raw_syscalls/sys_enter"</span>)</div><div class="line"><span class="keyword">int</span> detect_syscall_enter(<span class="keyword">struct</span> trace_event_raw_sys_enter *ctx)</div><div class="line">{</div><div class="line">  <span class="comment">// Retrieve the system call number</span></div><div class="line">  <span class="keyword">long</span> syscall_nr = ctx-&gt;id;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"child_pid"</span>;</div><div class="line">  <span class="keyword">int</span> target_pid;</div><div class="line"></div><div class="line">  <span class="comment">// Reading the process id of the child process in userland</span></div><div class="line">  <span class="keyword">void</span> *value = bpf_map_lookup_elem(&pid_hashmap, key);</div><div class="line">  <span class="keyword">void</span> *args[MAX_ARGS];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (value)</div><div class="line">  {</div><div class="line">    target_pid = *(<span class="keyword">int</span> *)value;</div><div class="line"></div><div class="line">    <span class="comment">// PID of the process that executed the current system call</span></div><div class="line">    pid_t pid = bpf_get_current_pid_tgid() & <span class="number">0xffffffff</span>;</div><div class="line">    <span class="keyword">if</span> (pid == target_pid && syscall_nr &gt;= <span class="number">0</span> && syscall_nr &lt; MAX_SYSCALL_NR)</div><div class="line">    {</div><div class="line"></div><div class="line">      <span class="keyword">int</span> idx = syscall_nr;</div><div class="line">      <span class="comment">// Reserve space in the ring buffer</span></div><div class="line">      <span class="keyword">struct</span> inner_syscall_info *info = bpf_ringbuf_reserve(&syscall_info_buffer, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inner_syscall_info), <span class="number">0</span>);</div><div class="line">      <span class="keyword">if</span> (!info)</div><div class="line">      {</div><div class="line">        bpf_printk(<span class="string">"bpf_ringbuf_reserve failed"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// Copy the syscall name into info-&gt;name</span></div><div class="line">      bpf_probe_read_kernel_str(info-&gt;name, <span class="keyword">sizeof</span>(syscalls[syscall_nr].name), syscalls[syscall_nr].name);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ARGS; i++)</div><div class="line">      {</div><div class="line">        info-&gt;args[i] = (<span class="keyword">void</span> *)BPF_CORE_READ(ctx, args[i]);</div><div class="line">      }</div><div class="line">      info-&gt;num_args = syscalls[syscall_nr].num_args;</div><div class="line">      info-&gt;syscall_nr = syscall_nr;</div><div class="line">      info-&gt;mode = SYS_ENTER;</div><div class="line">      <span class="comment">// Insert into ring buffer</span></div><div class="line">      bpf_ringbuf_submit(info, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line">SEC(<span class="string">"tracepoint/raw_syscalls/sys_exit"</span>)</div><div class="line"><span class="keyword">int</span> detect_syscall_exit(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"child_pid"</span>;</div><div class="line">  <span class="keyword">void</span> *value = bpf_map_lookup_elem(&pid_hashmap, key);</div><div class="line">  pid_t pid, target_pid;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (value)</div><div class="line">  {</div><div class="line">    pid = bpf_get_current_pid_tgid() & <span class="number">0xffffffff</span>;</div><div class="line">    target_pid = *(pid_t *)value;</div><div class="line">    <span class="keyword">if</span> (pid == target_pid)</div><div class="line">    {</div><div class="line">      <span class="keyword">struct</span> inner_syscall_info *info = bpf_ringbuf_reserve(&syscall_info_buffer, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inner_syscall_info), <span class="number">0</span>);</div><div class="line">      <span class="keyword">if</span> (!info)</div><div class="line">      {</div><div class="line">        bpf_printk(<span class="string">"bpf_ringbuf_reserve failed"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">      }</div><div class="line">      info-&gt;mode = SYS_EXIT;</div><div class="line">      info-&gt;retval = ctx-&gt;ret;</div><div class="line">      bpf_ringbuf_submit(info, <span class="number">0</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">char</span> LICENSE[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</div></pre></td></tr></table></figure>

<p>编译之前，我们不妨先构建一个测试程序，以便后续使用我们的工具对其进行追踪分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;stdio.h&gt;</span></div><div class="line"><span class="keyword">int</span> main(){</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"tracer in action"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以利用下面提供的 Makefile 来完成所有相关组件的编译工作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile:</div><div class="line">	clang -O2 -g -Wall -I/usr/include -I/usr/include/bpf -o beetrace loader.c -lbpf</div><div class="line">	clang -O2 -g -target bpf -c controller.c -o controller.o</div></pre></td></tr></table></figure>

<p><img src="beetracer.png" alt=""></p>
<p>整个代码可以在以下的GitHub仓库中找到：<br><a href="https://github.com/0xSh4dy/bee_tracer" target="_blank" rel="external">https://github.com/0xSh4dy/bee_tracer</a></p>
<p>参考链接：</p>
<ul>
<li><a href="https://ebpf.io/" target="_blank" rel="external">https://ebpf.io/</a></li>
<li><a href="https://github.com/libbpf/libbpf" target="_blank" rel="external">https://github.com/libbpf/libbpf</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="先决条件">先决条件</h2>
<p>系统调用、eBPF、C语言、底层编程基础。</p>
<h2 id="简介">简介</h2>
<p>eBPF(扩展的伯克利数据包过滤器)是一项允许用户在内核中运行自定义程序的技术。BPF或cBPF(经典BPF)是eBPF的前身,它提供了一种简单高效的方法来基于预定义规则过滤数据包。与内核模块相比,eBPF程序提供了更高的安全性、可移植性和可维护性。现有多种高级方法可用于处理eBPF程序,如Cilium的Go语言库、bpftrace、libbpf等。</p>
<ul>
<li><code>注意</code>: 本文要求读者对<code>eBPF</code>有基本了解。如果你不熟悉它,<code>ebpf.io</code>上的这篇文章是很好的参考资料。</li>
</ul>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Russ Cox 引退以及他的新项目 Oscar]]></title>
    <link href="https://colobu.com/2024/08/02/Russ-Cox-and-his-Oscar/"/>
    <id>https://colobu.com/2024/08/02/Russ-Cox-and-his-Oscar/</id>
    <published>2024-08-02T06:51:25.000Z</published>
    <updated>2024-08-09T06:26:33.026Z</updated>
    <content type="html"><![CDATA[<p>Go 第一代技术领导人 Rob Pike, 近两年已经隐居澳大利亚。<br>Go 第二代技术领导人 Russ Cox 2024 年 8 月 2 日宣布卸任，转战 AI 项目，聚焦 Oscar 项目。<br>Go 第三代技术领导人 Austin Clements, 同样和 Russ Cox 一样毕业于美国的一个计算机技术比较出名的一个学院，算是 Russ Cox 的师弟，Austin是Go语言运行时系统和垃圾收集器的主要贡献者之一，在运行时和内存管理等底层系统方面有深入的专长。</p>
<a id="more"></a>
<p>Go 第一代技术领导人 Rob Pike, 近两年已经隐居澳大利亚。<br>Go 第二代技术领导人 Russ Cox 2024 年 8 月 2 日宣布卸任，转战 AI 项目，聚焦 Oscar 项目。<br>Go 第三代技术领导人 Austin Clements, 同样和 Russ Cox 一样毕业于美国的一个计算机技术比较出名的一个学院，算是 Russ Cox 的师弟，Austin是Go语言运行时系统和垃圾收集器的主要贡献者之一，在运行时和内存管理等底层系统方面有深入的专长。</p>
<p>Russ Cox 他在网上的 ID 是 rsc，他是麻省理工学院 MIT 2008 届的博士毕业生，他本科和研究生都是在哈佛大学就读的，Go team 里的又一个学神。他所在的项目组是隶属于 MIT 计算机科学与人工智能实验室的并行与分布式操作系统组，据网上的资料 Austin Clements 也是在这个实验室这个组。</p>
<p>Russ 在哈佛大学就读期间就在 <a href="https://en.wikipedia.org/wiki/Bell_Labs" target="_blank" rel="external">Bell Labs</a> 贝尔实验室里实习（Russ 出生成长的家就在贝尔实验室附近，所以他从高中时期就一直在贝尔实验室的计算机科学部门泡着，所以大佬们是不是关注一下学区房，自己做不到也要为下一代考虑下 ：）），那时候他和 Rob Pike 一起开发贝尔实验室的分布式操作系统 <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs" target="_blank" rel="external">Plan 9</a> (上世纪 80 年代末由贝尔实验室的 Ken Thompson 和 Rob Pike 等人发起并领导的项目)，后来他去 MIT 攻读博士学位期间顺便去了 Google 实习，就在他博士快毕业的时候，Rob Pike 和 Ken Thompson 一起和他介绍了他们正在设计的一门新语言 Go，并大概是这么对他说的：“嘿，我们正试图把我们以前在 Plan 9 开发软件时非常喜欢的所有东西用在那些我们想在 Google 里写的软件里，你想过来帮忙一起搞吗？”，然后 Russ 就这样被这两位传奇程序员拉拢进来，事实上 Russ 一直都认为他能在博士毕业以后直接加入 Go 团队是发生在他人生中最幸运的事之一，他说仿佛自己过去十年所学的一切东西就是为了这一刻而准备的。</p>
<p>他加入团队之后就接手了编译器和 Runtime 这两大核心模块，并协助一起开发了标准库，之后依靠这些先前的经验，他和其他人一起完成了标准库后续的所有重构和优化，这就是为什么当你去看 Go 语言的源码的时候会发现 Russ 的名字几乎无处不在，到处都是他的 commits。</p>
<p>在整个 Go 代码仓库中，Russ Cox 提交的代码量是最多的。（请注意，下图中的人物都是大佬，三代领导人都在里面，包括两巨头和 Ian）</p>
<p><img src="contributors.png" alt=""></p>
<p>考虑到Russ Cox在Go项目中的资历和地位以及大学的经历,他可能在某些方面扮演了Austin Clements的导师角色,但这只是推测。我同样推测 Russ Cox 和 Rob Pike 之间也有类似的师承关系。只不过国外可能没有咱们中国这种拜师的礼仪，没有磕头敬过酒。</p>
<p>从 Russ Cox 的信中，可以看到实际他领导 Go 项目已经 12 年，从曾经充满理想、热情澎湃的有志青年，已经进入到经历沧桑的中年，他也在思考自己的职业规划。</p>
<p>尤其最近几位知名 Gopher 大佬对他的批评，不知道是否导致他引退的导火索呢？或许大佬内心受伤了，心灰意冷了。</p>
<p>作为一个绝顶聪明，学历和资历都是金字塔的技术大牛，正处于正当打的年纪，你猜 Ross Cox 下一步会做些什么？</p>
<p>当然是结合当前炙热的 AI 技术，再结合 Go 的经验，做一点有意义的事情，说不定又会发展为一个明星的项目。</p>
<p>这个项目叫 Oscar （奥斯卡），一个开源的贡献者 Agent架构。事实上前几天 Russ Cox 已经透露了它的第一个原型：<a href="https://github.com/gabyhelp" target="_blank" rel="external">gabyhelp</a></p>
<p>Oscar 旨在通过创建用于开源维护的 <code>自动化帮助</code> 或 <code>Agent</code> 来改进开源软件开发。我们相信有很多机会可以减少维护大型和小型开源项目所涉及的辛苦。</p>
<p>这句话已经完全说明这个项目的远景了。</p>
<p>大型语言模型(LLMs)能够对自然语言(如问题报告或维护者指令)进行语义分析,并在自然语言指令和程序代码之间进行转换,这为代理与人更顺畅地交互创造了新的机会。LLMs可能最终只是整个图景中小小的(但关键的!)一部分; Agent的大部分行为将是执行标准的、确定性的代码。</p>
<p>Oscar与许多以开发为中心的LLMs使用方式不同,它完全不试图增强或取代编码过程。毕竟,编写代码是开发软件中最有趣的部分。相反,这个想法是专注于那些不那么有趣的部分,比如处理新提交的问题、将问题与现有文档匹配等。</p>
<p>奥斯卡在很大程度上是一个实验。其实 Russ Cox 目前也还不知道它最终会去哪里。即便如此，他们的第一个原型，<a href="https://github.com/gabyhelp" target="_blank" rel="external">即 @gabyhelp</a> 机器人，已经在 <a href="https://github.com/golang/go/issues?q=label%3Agabywins" target="_blank" rel="external">Go 问题跟踪器中进行了许多成功的交互</a>。这也许是让 Russ Cox 兴奋准备大干一场的动力吧。</p>
<p>目前，Oscar 是在 Go 项目的主持下开发的。在未来的某个时候，它可能会（也可能不会）被分拆成一个单独的项目。</p>
<p>Oscar项目的具体目标是：</p>
<ul>
<li>减少维护人员解决问题的工作量 [请注意，解决并不总是意味着修复]</li>
<li>减少维护人员解决更改列表 （CL） 或拉取请求 （PR） 的工作量 [请注意，解决并不总是意味着提交/合并]</li>
<li>减少维护者解决论坛问题的工作量</li>
<li>让更多人成为高效的维护者</li>
</ul>
<p>和 Copilot 等工具不同，自动化编码不是 Oscar目标。相反，我们专注于<strong>自动化维护人员的工作</strong>。</p>
<p>维护者的辛苦并不是 Go 项目所独有的，因此 Oscar的目标是构建一个任何软件项目都可以重用和扩展的架构，构建他们自己的 Agent，根据项目的需求进行定制。因此 Oscar 是：<em>开源贡献者代理架构</em>。等他们完成额差不多，国内的头部互联网也就会推出类似的产品了。</p>
<p>到目前为止， Russ Cox 已经确定了三项能力，它们将成为奥斯卡的重要组成部分：</p>
<ol>
<li>在贡献者交互期间<strong>索引和显示相关的项目上下文</strong>。</li>
<li>使用<strong>自然语言来控制确定性工具</strong>。</li>
<li><strong>分析问题报告和 CL/PR</strong>，以帮助在提交期间或提交后不久实时改进它们，并适当地标记和路由它们</li>
</ol>
<p>具体的方法 Russ Cox 也在下面这篇文档中描述清楚了，大家可以进一步的了解。<br><a href="https://go.googlesource.com/oscar/+/refs/heads/master/README.md" target="_blank" rel="external">Oscar，一个开源的贡献者代理架构 </a></p>
<p>参考资料：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/YF6WGHpY3LYOamG6KmasFg" target="_blank" rel="external">https://mp.weixin.qq.com/s/YF6WGHpY3LYOamG6KmasFg</a></li>
<li><a href="https://golang.design/history/cn.html" target="_blank" rel="external">https://golang.design/history/cn.html</a></li>
<li><a href="https://strikefreedom.top/archives/my-trip-to-san-diego-for-go-contributor-summit-2023" target="_blank" rel="external">https://strikefreedom.top/archives/my-trip-to-san-diego-for-go-contributor-summit-2023</a></li>
<li><a href="https://groups.google.com/g/golang-dev/c/0OqBkS2RzWw" target="_blank" rel="external">https://groups.google.com/g/golang-dev/c/0OqBkS2RzWw</a></li>
<li><a href="https://go.googlesource.com/oscar/+/refs/heads/master/README.md" target="_blank" rel="external">https://go.googlesource.com/oscar/+/refs/heads/master/README.md</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go 第一代技术领导人 Rob Pike, 近两年已经隐居澳大利亚。<br>Go 第二代技术领导人 Russ Cox 2024 年 8 月 2 日宣布卸任，转战 AI 项目，聚焦 Oscar 项目。<br>Go 第三代技术领导人 Austin Clements, 同样和 Russ Cox 一样毕业于美国的一个计算机技术比较出名的一个学院，算是 Russ Cox 的师弟，Austin是Go语言运行时系统和垃圾收集器的主要贡献者之一，在运行时和内存管理等底层系统方面有深入的专长。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[128位整数的原子操作]]></title>
    <link href="https://colobu.com/2024/06/16/atomic128/"/>
    <id>https://colobu.com/2024/06/16/atomic128/</id>
    <published>2024-06-16T03:42:29.000Z</published>
    <updated>2024-08-09T06:26:33.110Z</updated>
    <content type="html"><![CDATA[<p>我们已经知道，标准库中的 atomic 针对 int32/uint32、int64/uint64 提供了原子操作的方法和函数，但是如果针对 128 bit 的整数呢？<br><a id="more"></a></p>
<p>当然使用128 bit 整数的原子操作的场景可能比较少，也不会有太多人有这个需求，但是如果我们需要对几个 32 bit、64 bit 变量进行原子操作吗， atomic128 可能就很有用。</p>
<p><a href="https://github.com/tmthrgd/atomic128" target="_blank" rel="external">tmthrgd/atomic128</a> 在几年前提供了 atomic 128 的实验性功能，最后放弃了，但是他提供了一个思路，可以使用 <a href="http://www.felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html" target="_blank" rel="external">CMPXCHG16B</a> 指令为 AMD 64 架构的CPU 提供 atomic 128 功能。</p>
<p><a href="https://github.com/CAFxX/atomic128" target="_blank" rel="external">CAFxX/atomic128</a> fork 了上面的项目，继续维护，还是使用 <code>CMPXCHG16B</code> 指令，只为 AMD 64 架构提供原子操作。</p>
<p>首先我们看看它的功能然后再看一看它的实现，最后我们思路发散一下，看看使用 AVX 为 128 bit 甚至更多 bit 的整数提供原子操作是否可行。</p>
<h2 id="atomic128_的方法">atomic128 的方法</h2>
<p><code>Package atomic128</code> 实现了对 128 bit值的原子操作。在可能的情况下（例如，在支持 <code>CMPXCHG16B</code> 的 amd64 处理器上），它会自动使用 CPU 的原生特性来实现这些操作；否则，它会回退到基于互斥锁（mutexes）的方法。</p>
<p>Go 的基本整数中不包含 int128/uint128，所以这个库先定义了一个 Int128 的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Uint128 <span class="keyword">struct</span> {</div><div class="line">	d <span class="number">[3</span>]<span class="typename">uint64</span></div><div class="line">	m sync.Mutex</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后类似标准库 atomic 中对各种整数的操作，它也提供了类似的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> AddUint128(ptr *Uint128, incr <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="number">[2</span>]<span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> CompareAndSwapUint128(ptr *Uint128, old, <span class="built_in">new</span> <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="typename">bool</span></div><div class="line"><span class="keyword">func</span> LoadUint128(ptr *Uint128) <span class="number">[2</span>]<span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> StoreUint128(ptr *Uint128, <span class="built_in">new</span> <span class="number">[2</span>]<span class="typename">uint64</span>)</div><div class="line"><span class="keyword">func</span> SwapUint128(ptr *Uint128, <span class="built_in">new</span> <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="number">[2</span>]<span class="typename">uint64</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> OrUint128(ptr *Uint128, op <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="number">[2</span>]<span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> AndUint128(ptr *Uint128, op <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="number">[2</span>]<span class="typename">uint64</span></div><div class="line"><span class="keyword">func</span> XorUint128(ptr *Uint128, op <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="number">[2</span>]<span class="typename">uint64</span></div></pre></td></tr></table></figure>

<p>可以看到，除了正常的 Add、CAS、Load、Store、Swap 函数，还贴心的提供了 <code>Or</code>、<code>And</code>、<code>Xor</code> 三个位操作的函数。</p>
<p>下面是一个简单的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">n := &atomic128.Uint128{}</div><div class="line">v := atomic128.LoadUint128(n) <span class="comment">// [2]uint64{0, 0}</span></div><div class="line">		</div><div class="line"></div><div class="line">atomic128.StoreUint128(n, <span class="number">[2</span>]<span class="typename">uint64</span><span class="number">{1</span>, ^<span class="typename">uint64</span><span class="number">(0</span>)})</div><div class="line">v = atomic128.LoadUint128(n) <span class="comment">// [2]uint64{1, ^uint64(0)}</span></div><div class="line"></div><div class="line">v = AddUint128(n, <span class="number">[2</span>]<span class="typename">uint64</span><span class="number">{2</span>,<span class="number"> 40</span>})</div><div class="line">v = atomic128.LoadUint128(n) <span class="comment">// [2]uint64{3, 40}</span></div><div class="line"></div><div class="line">v = atomic128.SwapUint128(n, <span class="number">[2</span>]<span class="typename">uint64</span><span class="number">{4</span>,<span class="number"> 50</span>})</div><div class="line">v = atomic128.LoadUint128(n) <span class="comment">// [2]uint64{4, 50}</span></div><div class="line"></div><div class="line">v = atomic128.CompareAndSwapUint128(n, <span class="number">[2</span>]<span class="typename">uint64</span><span class="number">{4</span>,<span class="number"> 50</span>}, <span class="number">[2</span>]<span class="typename">uint64</span><span class="number">{5</span>,<span class="number"> 60</span>})</div><div class="line">v = atomic128.LoadUint128(n) <span class="comment">// [2]uint64{5, 60}</span></div><div class="line"></div><div class="line">v = atomic128.OrUint128(n, <span class="number">[2</span>]<span class="typename">uint64</span><span class="number">{0</span>,<span class="number"> 0</span>})</div><div class="line">v = atomic128.LoadUint128(n) <span class="comment">// [2]uint64{5, 60}</span></div></pre></td></tr></table></figure>

<h2 id="atomic128_的实现">atomic128 的实现</h2>
<p>聪明的你也许看到<code>Uint128</code>的定义的时候就会感觉有一点不对劲，为啥128bit的整数要用3个64bit的整数来表示呢？ 2个Uint64不就够了吗？</p>
<p>这是为了保证128位对齐，类似的技术在Go 1.20之前的WaitGroup中也有使用。进一步了解可以查看：</p>
<ul>
<li><a href="https://go101.org/article/memory-layout.html" target="_blank" rel="external">https://go101.org/article/memory-layout.html</a></li>
<li><a href="https://pkg.go.dev/sync/atomic#pkg-note-BUG" target="_blank" rel="external">https://pkg.go.dev/sync/atomic#pkg-note-BUG</a></li>
</ul>
<p>通过包含三个Uint64元素的数组，我们总能通过下面的方法得到128位对齐的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> addr(ptr *Uint128) *<span class="number">[2</span>]<span class="typename">uint64</span> {</div><div class="line">	<span class="keyword">if</span> (<span class="typename">uintptr</span>)((unsafe.Pointer)(&ptr.d<span class="number">[0</span>]))<span class="number">%16</span> ==<span class="number"> 0</span> { <span class="comment">// 指针已经128位对齐</span></div><div class="line">		<span class="keyword">return</span> (*<span class="number">[2</span>]<span class="typename">uint64</span>)((unsafe.Pointer)(&ptr.d<span class="number">[0</span>]))</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> (*<span class="number">[2</span>]<span class="typename">uint64</span>)((unsafe.Pointer)(&ptr.d<span class="number">[1</span>])) <span class="comment">// 必然ptr.d[1]是128位对齐的 (AMD64架构)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过变量<code>useNativeAmd64</code>判断CPU是否支持<code>CMPXCHG16B</code>指令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	useNativeAmd64 = cpuid.CPU.Supports(cpuid.CX16)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果不支持，回退到使用Mutex实现一个低效的atomic 128bit原子操作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> CompareAndSwapUint128(ptr *Uint128, old, <span class="built_in">new</span> <span class="number">[2</span>]<span class="typename">uint64</span>) <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">if</span> runtime.GOARCH == <span class="string">"amd64"</span> && useNativeAmd64 {</div><div class="line">		<span class="keyword">return</span> compareAndSwapUint128amd64(addr(ptr), old, <span class="built_in">new</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 不支持CMPXCHG16B指令，使用Mutex</span></div><div class="line">	ptr.m.Lock()</div><div class="line">	v := load(ptr)</div><div class="line">	<span class="keyword">if</span> v != old {</div><div class="line">		ptr.m.Unlock()</div><div class="line">		<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">	}</div><div class="line">	store(ptr, <span class="built_in">new</span>)</div><div class="line">	ptr.m.Unlock()</div><div class="line">	<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果支持<code>CMPXCHG16B</code>指令，直接调用<code>compareAndSwapUint128amd64</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">TEXT ·compareAndSwapUint128amd64(SB),NOSPLIT,<span class="number">$0</span></div><div class="line">	MOVQ addr<span class="number">+0</span>(FP), BP</div><div class="line">	MOVQ old<span class="number">+8</span>(FP), AX</div><div class="line">	MOVQ old<span class="number">+16</span>(FP), DX</div><div class="line">	MOVQ <span class="built_in">new</span><span class="number">+24</span>(FP), BX</div><div class="line">	MOVQ <span class="built_in">new</span><span class="number">+32</span>(FP), CX</div><div class="line">	LOCK</div><div class="line">	CMPXCHG16B (BP)</div><div class="line">	SETEQ swapped<span class="number">+40</span>(FP)</div><div class="line">	RET</div></pre></td></tr></table></figure>

<p>主要依赖<code>CMPXCHG16B</code>实现。</p>
<p><code>CMPXCHG16B</code>是一条X86体系结构中的指令,全称为&quot;Compare and Exchange 16 Bytes&quot;。它用于原子地比较和交换16个字节(128位)的内存区域。<br>这条指令的作用是:</p>
<ul>
<li>将要比较的16个字节的内存值加载到一个寄存器中。</li>
<li>将要写入的16个字节的值加载到另一个寄存器中。</li>
<li>比较内存中的值和第一个寄存器中的值是否相等。</li>
<li>如果相等,则用第二个寄存器中的值覆盖内存中的值。</li>
<li>根据比较结果,设置相应的标志位。</li>
</ul>
<h2 id="思路发散">思路发散</h2>
<p>当前很多号称性能优化的库，可能会使用SIMD指令集来提高性能，比如AVX、SSE等。那么，我们是否可以使用AVX指令集来实现对128位整数甚至256、512位整数的原子操作呢？</p>
<p>有一篇很好的文章介绍了这方面的探索:<a href="https://rigtorp.se/isatomic/" target="_blank" rel="external">Aligned AVX loads and stores are atomic</a>。</p>
<p>各家处理器手册中并没有为AVX指令集提供原子性的担保。<a href="https://www.amd.com/system/files/TechDocs/40332.pdf" target="_blank" rel="external">The AMD64 Architecture Programmer’s Manual</a>只是保证了内存操作最大8个字节，<code>CMPXCHG16B</code>是原子的。<a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html" target="_blank" rel="external">The Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>也做了类似的保证。此外，Intel手册明确指出AVX指令没有任何原子性保证。</p>
<p>这篇文章的作者做了实验，得出下面的结论:<br><img src="avx.png" alt=""></p>
<p>尽管看起来对齐的 128 位操作室原子的，但是 CPU 提供商没有提供担保，我们还是使用 <code>CMPXCHG16B</code> 指令保险。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们已经知道，标准库中的 atomic 针对 int32/uint32、int64/uint64 提供了原子操作的方法和函数，但是如果针对 128 bit 的整数呢？<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 朝着错误的方向发展]]></title>
    <link href="https://colobu.com/2024/06/11/go-evolves-in-the-wrong-direction/"/>
    <id>https://colobu.com/2024/06/11/go-evolves-in-the-wrong-direction/</id>
    <published>2024-06-11T14:02:06.000Z</published>
    <updated>2024-08-09T06:26:33.362Z</updated>
    <content type="html"><![CDATA[<p>这是 Aliaksandr Valialkin 昨天刚写的一篇文章, 心有戚戚焉，所以特意翻译成中文，个人感觉，自从Rob Pike退休后，Go在大方向迷失了，正如老貘(Go101)所说，目前Go的开发就像完成KPI一样，也许, 大师不会再回来了。</p>
<p>Aliaksandr Valialkin是fasthttp的作者，也是VictoriaMetrics开发者，一位资深的Go程序员。</p>
<p>以下是译文。<br><a id="more"></a></p>
<p>以下是对原文的地道中文翻译:</p>
<p>Go编程语言以易于使用而闻名。得益于经过深思熟虑的语法、特性和工具,Go允许编写任意复杂度的易读易维护的程序(参见GitHub上的这个<a href="https://github.com/search?q=language%3Ago+stars%3A%3E%3D10000&amp;type=repositories" target="_blank" rel="external">列表</a>)。</p>
<p>有些软件工程师称Go为&quot;无聊&quot;和&quot;过时&quot;,因为它缺乏其他编程语言的高级特性,如单子、Option类型、LINQ、借用检查器、零开销抽象、面向方面编程、继承、函数和运算符重载等。虽然这些特性在特定领域可能可以简化编码,但它们除了好处之外还有非零的成本。这些特性通常对锻炼大脑有好处。但是在处理生产代码时,我们不需要额外的精神负担,因为我们已经很忙于解决业务任务了。所有这些特性的主要成本是<strong>增加了结果代码的复杂性</strong>:</p>
<ul>
<li>仅仅通过阅读代码就变得更难理解正在发生的事情;</li>
<li>调试此类代码变得更加困难,因为您需要跳过数十个非平凡的抽象才能到达业务逻辑;</li>
<li>由于这些特性施加的限制,为此类代码添加新功能变得更加困难。</li>
</ul>
<p>这可能会显著减慢甚至阻碍代码开发的进度。这就是Go一开始就没有这些特性的主要原因。</p>
<p>不幸的是,一些这样的特性开始出现在最新的Go版本中:</p>
<ul>
<li>泛型已在Go1.18中添加。许多软件工程师希望Go有泛型,因为他们认为这将大大提高Go的生产力。Go1.18发布已经两年了,但没有迹象表明生产力有所提高。Go中泛型的整体采用率仍然很低。为什么?因为<strong>大多数实际的Go代码根本不需要泛型</strong>。另一方面,泛型显著增加了Go语言本身的复杂性。例如,尝试理解泛型添加后Go类型推断的所有细节。它的复杂性看起来已经非常接近于C++的类型推断了:)另一个问题是Go中的泛型缺乏C++模板中存在的基本特性。例如,Go泛型不支持泛型类型的泛型方法。它们也不支持模板特化和模板模板参数,以及许多其他需要充分利用泛型编程的特性。让我们将这些缺失的特性添加到Go中吧!等等,那我们就得到另一个过于复杂的C++克隆了。那么,为什么要一开始就将半生不熟的泛型添加到Go中呢?🤦</li>
<li>根据这个提交,Range over functions 又名迭代器、生成器或协程将在 Go 1.23 中添加。让我们仔细看看这个&quot;特性&quot;。</li>
</ul>
<h2 id="Go1-23_中的迭代器">Go1.23 中的迭代器</h2>
<p>如果你不太熟悉Go中的迭代器,请阅读这篇出色的介绍文章。本质上,这是一种语法糖,允许在具有特殊签名的函数上使用<code>for...range</code>循环。这使得可以编写遍历自定义集合和类型的自定义迭代器。听起来像是一个很棒的功能,不是吗?让我们试着弄清楚这一功能解决了哪些实际问题。这在<a href="https://github.com/golang/go/discussions/56413" target="_blank" rel="external">这里</a>有概述:</p>
<blockquote>
<p>Go语言没有标准的方式来遍历一系列值。由于缺乏约定,我们最终使用了各种各样的方法。每种实现都是根据当时的上下文做出最合理的决定,但是孤立地做出的决策导致了用户的困惑。</p>
<p>仅在标准库中,我们就有archive/tar.Reader.Next、bufio.Reader.ReadByte、bufio.Scanner.Scan、container/ring.Ring.Do、database/sql.Rows、expvar.Do、flag.Visit、go/token.FileSet.Iterate、path/filepath.Walk、go/token.FileSet.Iterate、runtime.Frames.Next和sync.Map.Range,几乎没有任何一个在迭代的确切细节上达成一致。即使函数签名相同,语义也不总是一致。例如,大多数返回(T, bool)的迭代函数都遵循Go的惯例,即bool表示T是否有效。相反,runtime.Frames.Next返回的bool则表示下一次调用是否会返回有效的内容。</p>
<p>当你想要遍历某些内容时,你首先必须了解你调用的特定代码是如何处理迭代的。这种不统一阻碍了Go追求的在大型代码库中方便移动的目标。人们常常将Go代码看起来都大致相同作为一个优势,但对于包含自定义迭代的代码而言,这显然是不真实的。</p>
</blockquote>
<p>再说一次,拥有在Go中遍历各种类型的统一方式听起来是合理的。但是对于作为Go主要优势之一的向后兼容性又如何呢?根据Go的兼容性规则,上面提到的标准库中所有现有的自定义迭代器<strong>将永远保留在标准库中</strong>。因此,<strong>所有新的Go版本在标准库中都将至少提供两种不同的方式来遍历各种类型 —— 旧的方式和新的方式</strong>。这增加了Go编程的复杂性,因为:</p>
<ul>
<li>您需要了解遍历各种类型的两种方式,而不是单一方式。</li>
<li>您需要能够阅读和维护使用旧迭代器的旧代码,以及可能使用旧迭代器、新迭代器或同时使用两种迭代器类型的新代码。</li>
<li>在编写新代码时,您需要选择适当的迭代器类型。</li>
</ul>
<h2 id="Go1-23_中迭代器的其他问题">Go1.23 中迭代器的其他问题</h2>
<p>以下是对原文的地道中文翻译:</p>
<p>在Go 1.23之前,<code>for...range</code>循环只能应用于内置类型:整数(从Go1.22开始)、字符串、切片、映射和通道。这些循环的语义很清晰,易于理解(遍历通道的循环语义更加复杂,但如果你处理并发编程,那你应该很容易理解)。</p>
<p>从Go 1.23开始,<code>for...range</code>循环可以应用于具有特殊签名的函数(又称拉取和推送函数)。这使得单凭阅读代码就无法理解给定的看似无辜的<code>for...range</code>循环到底会在底层做什么。它可以做任何事情,就像任何函数调用一样。不同之处在于,Go中的函数调用一直都是<strong>显式的</strong>,比如<code>f(args)</code>，而<code>for...range</code>循环<strong>隐藏了实际的函数调用</strong>。另外,它还对循环体<strong>应用了一些不太明显的转换</strong>:</p>
<ul>
<li>它<strong>隐式地</strong>将循环体包裹在一个匿名函数中,并<strong>隐式地</strong>将这个函数传递给<strong>推送</strong>迭代器函数。</li>
<li>它<strong>隐式地</strong>调用匿名的<strong>拉取</strong>函数,并将返回的结果传递给循环体。</li>
<li>它<strong>隐式地</strong>将<strong>return</strong>、<strong>continue</strong>、<strong>break</strong>、<strong>goto</strong>和<strong>defer</strong>语句转换为另一个不太明显的语句,存在于传递给<strong>推送</strong>迭代器函数的匿名函数中。</li>
</ul>
<p>另外,<strong>在一般情况下,在循环迭代之后使用迭代器函数返回的参数是不安全的</strong>,因为迭代器函数可能会在下一次循环迭代时重用它们。</p>
<p>Go 曾因易于阅读和理解的<strong>显式代码执行路径</strong>而闻名。这一特性在 Go1.23 中<strong>不可逆转地</strong>被破坏了:(我们用什么来交换?<strong>另一种</strong>遍历类型的方式,它具有一些<strong>隐式</strong>的语义,而且在某些情况下行为与广告描述的不同。当遍历可能在迭代过程中返回错误的类型时(例如database/sql.Rows、path/filepath.Walk 或任何其他在迭代过程中进行 IO 操作的类型),这种新方式就无法按预期工作,因为你需要<strong>手动检查迭代错误</strong>,无论是在循环内部还是在循环之后,这与使用旧方法的做法是一样的。</p>
<p>即使你使用不会返回错误的迭代器,生成的 <code>for ... range</code> 循环也看起来比使用显式回调的旧方法更加不清晰。哪种代码更容易理解和调试?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tree.walk(<span class="keyword">func</span>(k, v <span class="typename">string</span>) {</div><div class="line">  <span class="built_in">println</span>(k, v)</div><div class="line">})</div></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> tree.walk {</div><div class="line">  <span class="built_in">println</span>(k, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>请记住,后一个循环会被隐式地转换为前一个带有显式回调调用的代码。现在让我们从循环中返回一些东西:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> tree.walk {</div><div class="line">  <span class="keyword">if</span> k == <span class="string">"foo"</span> {</div><div class="line">    <span class="keyword">return</span> v</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它被隐式转换为难以跟踪的代码，类似于以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vOuter <span class="typename">string</span></div><div class="line">needOuterReturn := <span class="constant">false</span></div><div class="line">tree.walk(<span class="keyword">func</span>(k, v <span class="typename">string</span>) <span class="typename">bool</span> {</div><div class="line">  <span class="keyword">if</span> k == <span class="string">"foo"</span> {</div><div class="line">    needOuterReturn = <span class="constant">true</span></div><div class="line">    vOuter = v</div><div class="line">    <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">  }</div><div class="line">})</div><div class="line"><span class="keyword">if</span> needOuterReturn {</div><div class="line">  <span class="keyword">return</span> vOuter</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看起来很容易调试:)</p>
<p>如果<code>tree.walk</code>通过从字节切片进行不安全转换将<code>v</code>传递给回调函数,那么这段代码可能会崩溃,因为<code>v</code>的内容在下一次循环迭代时可能会发生变化。因此,<strong>隐式</strong>生成的防弹代码必须使用<code>strings.Clone()</code>函数,这可能导致不必要的内存分配和复制:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vOuter <span class="typename">string</span></div><div class="line">needOuterReturn := <span class="constant">false</span></div><div class="line">tree.walk(<span class="keyword">func</span>(k, v <span class="typename">string</span>) <span class="typename">bool</span> {</div><div class="line">  <span class="keyword">if</span> k == <span class="string">"foo"</span> {</div><div class="line">    needOuterReturn = <span class="constant">true</span></div><div class="line">    vOuter = strings.Clone(v)</div><div class="line">    <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">  }</div><div class="line">})</div><div class="line"><span class="keyword">if</span> needOuterReturn {</div><div class="line">  <span class="keyword">return</span> vOuter</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>range over func</code>这一特性对函数签名施加了限制。这些限制不适用于所有需要遍历集合元素的场景。这迫使软件工程师在使用<code>for...range</code>循环时进行丑陋的hack,以及编写理想情况下适合给定任务的显式代码之间做出艰难选择。</p>
<h2 id="结论">结论</h2>
<p>令人遗憾的是,Go开始朝着增加复杂性和隐式代码执行的方向发展。也许我们需要停止添加增加Go复杂性的新功能,而是专注于Go的核心特性 - 简单性、高效性和性能。例如,最近Rust开始在对性能要求苛刻的领域取代Go的份额。我相信如果Go核心团队专注于优化热循环,比如循环展开和SIMD使用,这种趋势是可以扭转的。这不应该太过影响编译和链接速度,因为只有少量编译后的Go代码需要优化。没有必要试图优化所有简单代码的变体 - 这些代码即使优化了热循环也仍然会很慢。只需针对那些由注重代码性能的软件工程师故意编写的特定模式进行优化就足够了。<br>Go比Rust容易使用得多。为什么要在性能竞赛中输给Rust呢?<br>Go可以获得的另一个有用特性的例子是,在不增加语言本身和使用这些特性的Go代码复杂性的情况下,进行类似于小的改善代码质量的改进。</p>
<h2 id="我是谁?">我是谁?</h2>
<p>我是一名专门编写简单、面向性能的Go代码的软件工程师,如VictoriaMetrics、quicktemplate、fastjson、fasthttp、fastcache、easyproto等。多亏了Go,我一直试图遵循KISS(Keep It Simple,Stupid)设计原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是 Aliaksandr Valialkin 昨天刚写的一篇文章, 心有戚戚焉，所以特意翻译成中文，个人感觉，自从Rob Pike退休后，Go在大方向迷失了，正如老貘(Go101)所说，目前Go的开发就像完成KPI一样，也许, 大师不会再回来了。</p>
<p>Aliaksandr Valialkin是fasthttp的作者，也是VictoriaMetrics开发者，一位资深的Go程序员。</p>
<p>以下是译文。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rob Pike 语录]]></title>
    <link href="https://colobu.com/2024/06/10/The-Analects-of-Rob-Pike/"/>
    <id>https://colobu.com/2024/06/10/The-Analects-of-Rob-Pike/</id>
    <published>2024-06-10T04:39:59.000Z</published>
    <updated>2024-08-09T06:26:33.039Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_计算机领域里，没有什么问题是加一层间接寻址解决不了的。">1. 计算机领域里，没有什么问题是加一层间接寻址解决不了的。</h2>
<blockquote>
<p>There&#39;s nothing in computing that can&#39;t be broken by another level of indirection.</p>
</blockquote>
<p>这是 Rob Pike 的修改版。</p>
<p>经常 <code>level of insriection</code> 误引用为 <code>abstraction layer</code>。</p>
<blockquote>
<p>原始版本出自 <strong>Butler Lampson</strong><br>All problems in computer science can be solved by another level of indirection</p>
<p>但是 <strong>David Wheeler</strong> 完成了下半句：<br>All problems in computer science can be solved by another level of indirection, except for the problem of too many layers of indirection.</p>
<p>还有 Kevlin Henney 的下半句：<br>ll problems in computer science can be solved by another level of indirection, except for the problem of too many layers of indirection.&quot;</p>
<p>From <a href="https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html" target="_blank" rel="external">Beautiful Code: Another Level of Indirection </a></p>
</blockquote>
<p>这句话幽默地指出，在计算机编程中，通过引入额外的抽象层或中间层，几乎可以解决任何复杂的问题。这种思路在软件设计和架构中很常见。</p>
<a id="more"></a>
<h2 id="2-_数据为王。如果你选择了正确的数据结构，并且组织得当，算法几乎总是不言自明的。编程的核心在于数据结构，而不是算法。">2. 数据为王。如果你选择了正确的数据结构，并且组织得当，算法几乎总是不言自明的。编程的核心在于数据结构，而不是算法。</h2>
<blockquote>
<p>Data dominates. If you&#39;ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</p>
</blockquote>
<p>&quot;数据为王&quot;意味着在软件开发中，数据的组织和表示方式比实现算法的具体细节更加重要。<br>这个观点强调了良好的数据结构设计对于编程效率和代码质量的重要性。它鼓励程序员把更多精力放在思考如何组织和表示数据上，而不是过分关注算法的技巧性。</p>
<h2 id="3-_面向对象设计就是计算机界的罗马数字。">3. 面向对象设计就是计算机界的罗马数字。</h2>
<blockquote>
<p>Object-oriented design is the roman numerals of computing.</p>
</blockquote>
<p>这是一句颇具争议性和挑衅性的话。罗马数字在数学史上曾经很重要，但现代计算中已被阿拉伯数字体系取代，因为后者更简单、更高效。这句话暗示面向对象设计（OOD）也是如此。</p>
<p>Pike认为，就像罗马数字对现代数学来说过于繁琐和低效一样，面向对象编程（OOP）的某些方面（如过度的类层次结构和封装）可能导致代码复杂、难以理解和维护。</p>
<p>这个比喻引发了编程圈内的热议。支持者认为它点出了OOP的一些问题，如过度设计和不必要的复杂性。反对者则认为OOP仍然是一个强大和有用的范式。</p>
<p>值得注意的是，Pike是Go语言的创始人之一，Go语言采用了一种不同于传统OOP的设计哲学，更注重简单性和数据结构。</p>
<h2 id="4-_最后，我意识到光想是没什么出路的，该动手实践了。">4. 最后，我意识到光想是没什么出路的，该动手实践了。</h2>
<blockquote>
<p>Eventually, I decided that thinking was not getting me very far and it was time to try building.</p>
</blockquote>
<p>这句话体现了一种在技术和创新领域常见的实用主义态度。</p>
<p>&quot;光想没出路&quot;是一种常见的中文表达，意思是仅靠思考而不付诸行动是难以取得进展的。</p>
<p>&quot;动手实践&quot;强调了在实践中学习和创新的重要性。在编程、创业等领域，这种&quot;边做边学&quot;的方法被广泛推崇。</p>
<p>但这并不是完全否定思考的价值。恰当的思考和规划仍然重要，只是强调不要陷入&quot;分析瘫痪&quot;（analysis paralysis），即过度分析导致迟迟不能行动的状态。</p>
<h2 id="5-_见识短浅，想象力就会受限。">5. 见识短浅，想象力就会受限。</h2>
<blockquote>
<p>Narrowness of experience leads to narrowness of imagination.</p>
</blockquote>
<p>更为甚者， 见识短浅， 反而将大师的作品视为平庸。一个讽刺性的文章： <a href="https://github.com/SuperPaintman/the-evolution-of-a-go-programmer" target="_blank" rel="external">The Evolution of a Go Programmer</a></p>
<h2 id="6-_这就是现代计算：简单的东西变得过于复杂，因为随意捣鼓太容易；复杂的东西依旧复杂，因为修复太难。">6. 这就是现代计算：简单的东西变得过于复杂，因为随意捣鼓太容易；复杂的东西依旧复杂，因为修复太难。</h2>
<blockquote>
<p>Such is modern computing: everything simple is made too complicated because it&#39;s easy to fiddle with; everything complicated stays complicated because it&#39;s hard to fix.</p>
</blockquote>
<p>Rob Pike 作为一位推崇简洁设计的大师，他对当前计算机行业的复杂性提出了犀利的批评。</p>
<p>第一部分讽刺了一些程序员或设计师的倾向：明明有简单的解决方案，却偏爱使用复杂的技术，导致本来简单的问题变得难以理解和维护。</p>
<p>第二部分点出了一个现实问题：一旦系统变得复杂，就很难简化。原因可能包括兼容性问题、团队惯性、或者是简单地因为理解和重构复杂系统需要大量时间和资源。</p>
<p>它呼应了UNIX哲学中的一个核心原则：做好一件事。也就是说，程序应该简单、模块化，只专注于完成一个任务。</p>
<h2 id="7-_过程名应该反映它做什么；函数名应该反映它返回什么。">7. 过程名应该反映它做什么；函数名应该反映它返回什么。</h2>
<blockquote>
<p>Procedure names should reflect what they do; function names should reflect what they return</p>
</blockquote>
<p>这是编程领域的一条重要命名规范，有助于提高代码的可读性和可维护性。</p>
<p>在中文编程圈，&quot;过程&quot;（procedure）和&quot;函数&quot;（function）的区别经常被讨论。简单来说：</p>
<ul>
<li>&quot;过程&quot;执行一系列操作，通常不返回值，重点在于&quot;做&quot;。</li>
<li>&quot;函数&quot;计算并返回一个值，重点在于&quot;得到&quot;什么。</li>
</ul>
<h2 id="8-_花哨的算法在_N_小的时候很慢，而_N_通常都很小。">8. 花哨的算法在 N 小的时候很慢，而 N 通常都很小。</h2>
<blockquote>
<p>Fancy algorithms are slow when N is small, and N is usually small.</p>
</blockquote>
<p>&quot;N&quot; 在算法分析中代表输入规模，如要排序的元素个数、要搜索的数据量等。&quot;大 O 表示法&quot;（如 O(n)、O(n²)）就是用 N 来描述算法在最坏情况下的时间复杂度。</p>
<p>这句话的启示：</p>
<ul>
<li>不要过早优化。在数据量小的情况下，简单直白的算法可能更快、更易理解。</li>
<li>理解实际问题的规模。过度设计（用复杂算法解决小问题）可能适得其反。<br>= 在选择算法时，要考虑具体场景，不能只看理论复杂度。</li>
</ul>
<p>俗语&quot;大炮打蚊子&quot;，就是类似的道理。有时候，简单的方法反而更有效。</p>
<h2 id="9-_UNIX不仅已经死了，臭的都快熏死人了。">9. UNIX不仅已经死了，臭的都快熏死人了。</h2>
<blockquote>
<p>Not only is UNIX dead, it&#39;s starting to smell really bad.</p>
</blockquote>
<p>在1990年代，微软的Windows和IBM的OS/2等图形用户界面（GUI）操作系统开始流行，而基于命令行的UNIX看起来过时了。一些人认为，用户友好的GUI是未来，UNIX这样的系统已经落伍，注定会消亡。<br>讽刺的是，这个预言并没有完全实现：</p>
<ul>
<li>Linux（一个UNIX类操作系统）在服务器领域占据主导地位。</li>
<li>macOS基于BSD（另一个UNIX变种）。</li>
<li>甚至Windows 10也加入了Linux子系统。</li>
</ul>
<p>这句话现在常被用来嘲笑那些过早宣布某项技术&quot;死亡&quot;的人。</p>
<h2 id="10-_想要杜绝傻瓜行为的编程语言，往往自己也变得傻不拉几。">10. 想要杜绝傻瓜行为的编程语言，往往自己也变得傻不拉几。</h2>
<blockquote>
<p>Languages that try to disallow idiocy become themselves idiotic.</p>
</blockquote>
<p>过度限制程序员可能弊大于利：</p>
<ul>
<li>好的程序员应该被信任和赋能，而不是被当成&quot;傻瓜&quot;对待。</li>
<li>有时，所谓的&quot;傻瓜行为&quot;其实是创新和效率的源泉。</li>
<li>语言应该提供工具和指导，而不是强制规定唯一的&quot;正确&quot;方式。</li>
</ul>
<p>这句话也反映了一个更广的设计哲学：过度设计来防止错误，可能带来更多问题。无论是编程语言、产品设计还是管理，给予用户或团队合理的自由和信任，往往比试图规避一切风险更有效。</p>
<h2 id="11、缓存不是架构，只是个优化手段而已。">11、缓存不是架构，只是个优化手段而已。</h2>
<blockquote>
<p>Caches aren&#39;t architecture, they&#39;re just optimization.</p>
</blockquote>
<p>Pike的观点是：</p>
<ul>
<li>不要因为缓存效果好，就把它当成架构的一部分。</li>
<li>如果没有缓存系统就崩溃，那可能是架构有问题。</li>
<li>缓存应该是&quot;锦上添花&quot;，而不是&quot;救命稻草&quot;。</li>
</ul>
<p>但这并不意味着缓存不重要。实际上：</p>
<ul>
<li>合理使用缓存可以极大提升性能。</li>
<li>在某些场景（如高并发网站），缓存几乎是必需的。</li>
</ul>
<p>关键是平衡：</p>
<ul>
<li>先有好的架构和算法。</li>
<li>在合适的地方加缓存，但不要让系统对缓存产生依赖。</li>
<li>缓存失效或穿透时，系统应该能够&quot;优雅降级&quot;。</li>
</ul>
<p>用中文的一句话概括就是：&quot;先治本，再治标&quot;。缓存是&quot;标&quot;（优化性能），好的架构才是&quot;本&quot;。</p>
<h2 id="12、没有类型层次，就不用费劲去管理类型层次了。">12、没有类型层次，就不用费劲去管理类型层次了。</h2>
<blockquote>
<p>When there is no type hierarchy you don&#39;t have to manage the type hierarchy.</p>
</blockquote>
<p>它直指面向对象编程（OOP）中一个常见的复杂性来源。&quot;类型层次&quot;主要指面向对象语言中的类继承结构：</p>
<p>&quot;没有类型层次&quot;并非完全否定OOP，而是指一种不同的设计风格：</p>
<ul>
<li>组合优于继承：用组合（has-a）而不是继承（is-a）来复用代码。</li>
<li>接口而非基类：定义行为协议，而不是强制继承关系。</li>
<li>简单类型：类的职责单一，减少复杂的层次结构。</li>
</ul>
<p>这种思想在Go语言中很明显：</p>
<ul>
<li>Go没有类和继承，但有结构体和接口。</li>
<li>结构体可以嵌入其他结构体来复用字段和方法，但不是继承。</li>
<li>接口是隐式的：只要一个类型实现了接口的所有方法，它就&quot;是&quot;那个接口。</li>
</ul>
<h2 id="13、按工程管理的规则，生产力最重要；可在工程师眼里，乐趣才是第一位。生产力源于乐趣。">13、按工程管理的规则，生产力最重要；可在工程师眼里，乐趣才是第一位。生产力源于乐趣。</h2>
<blockquote>
<p>Productivity is most important by engineering management rules, but enjoyment is most important for engineers. One stems from the other.</p>
</blockquote>
<ul>
<li>这里的&quot;乐趣&quot;不只是表面的快乐，更指：<ul>
<li>解决有趣问题的满足感。</li>
<li>创造优雅代码的成就感。</li>
<li>与团队协作的归属感。</li>
<li>学习新技术的好奇心。</li>
</ul>
</li>
<li>优秀的工程师往往被这些内在动机驱动，而不仅仅是外部压力。</li>
</ul>
<p>Pike指出，高生产力实际上源于工程师的乐趣。<br>当工程师享受工作时，他们会：</p>
<ul>
<li>自发加班，因为问题太有趣了。</li>
<li>主动优化代码，因为看到丑陋的代码会不舒服。</li>
<li>积极学习，因为新技术太酷了。<br>这些行为自然而然地提高了生产力。</li>
</ul>
<p>这一观点在软件行业有广泛共识：</p>
<ul>
<li>Google的20%时间：员工可以花20%工作时间做自己感兴趣的项目。许多重要产品（如Gmail）就是这样诞生的。虽然说现在Google已经去掉了20%工作时间的政策。</li>
<li>开源社区：大多数贡献者是因为热情而不是报酬。这种模式创造了Linux、Python等。</li>
<li>创业文化：舒适的办公环境、弹性工作制，都是为了让员工更快乐，从而更有创造力。</li>
</ul>
<p>对管理者的启示：</p>
<ul>
<li>不要只盯着KPI。创造让工程师愉悦的环境，生产力自然会提高。</li>
<li>理解并尊重工程师的动机。有时，让他们&quot;玩&quot;反而能得到更好的结果。</li>
</ul>
<p>对工程师的启示：</p>
<ul>
<li>追求技术乐趣并不自私。它能让你更高效，也让产品更优秀。</li>
<li>但也要有度。纯粹追求个人兴趣而忽视团队目标，同样问题。</li>
</ul>
<h2 id="14、第一法则：你猜不准程序会在哪里耗时。性能瓶颈总在意想不到的地方冒出来，所以别想当然去优化，除非你证实了那里就是瓶颈所在。">14、第一法则：你猜不准程序会在哪里耗时。性能瓶颈总在意想不到的地方冒出来，所以别想当然去优化，除非你证实了那里就是瓶颈所在。</h2>
<blockquote>
<p>Rule 1. You can&#39;t tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don&#39;t try to second guess and put in a speed hack until you&#39;ve proven that&#39;s where the bottleneck is</p>
</blockquote>
<ul>
<li><p>&quot;猜不准程序会在哪里耗时&quot;：</p>
<ul>
<li>程序性能不是直观的。即使是经验丰富的程序员，也常常错误预测哪部分代码最慢。</li>
<li>现代系统复杂（多线程、缓存、编译器优化等），让性能特征更难预测。</li>
</ul>
</li>
<li><p>&quot;性能瓶颈总在意想不到的地方冒出来&quot;：</p>
<ul>
<li>&quot;性能瓶颈&quot;是限制整体性能的最慢部分。就像木桶，最短的那块板决定了水位。</li>
<li>&quot;意想不到&quot;暗示即使是看似简单的代码，也可能因为被频繁调用或数据量大而成为瓶颈。</li>
</ul>
</li>
<li><p>&quot;别想当然去优化&quot;：</p>
</li>
<li>&quot;想当然&quot;在中文里就是不经证实就认定。这在性能优化中很危险。</li>
<li><p>过早优化（premature optimization）是编程界臭名昭著的反模式。它可能导致：</p>
<ul>
<li>代码复杂化，难以理解和维护。</li>
<li>浪费时间在实际上不慢的部分。</li>
<li>引入新的bug或性能问题。</li>
</ul>
</li>
<li><p>&quot;除非你证实了那里就是瓶颈所在&quot;：</p>
<ul>
<li>&quot;证实&quot;是关键。不是猜测，而是通过性能分析工具（profiler）确定。</li>
<li>现代profiler可以精确定位耗时函数、内存分配等，让优化有的放矢。</li>
</ul>
</li>
</ul>
<p>这一法则的实践：</p>
<ul>
<li>先让它跑起来（Make it work）</li>
<li>然后让它对（Make it right）</li>
<li>最后才是让它快（Make it fast）</li>
<li>每一步都用数据（profile）来指导，不猜测。</li>
</ul>
<h2 id="14、扩展">14、扩展</h2>
<p>第14条事实上来源自Robe Pike的编程五原则, 包括上面的多条名言:</p>
<ul>
<li>第一法则： 你猜不准程序会在哪儿磨蹭。性能瓶颈总冒出在意想不到的地方，所以别瞎猜着去优化，除非你摸清楚了瓶颈的准确位置。</li>
<li>第二法则： 先量化。没测量之前别瞎调速度，就算测出来了，也得是哪块代码严重拖后腿了才优化。</li>
<li>第三法则： 花里胡哨的算法在数据小时龟速，而且数据往往就不大。花哨算法有大常数。除非你明摆着要处理大数据，别整那些花活。（就算真遇到大数据，也先用第二法则。）</li>
<li>第四法则： 花哨的算法比简单的更容易藏bug，而且实现起来费劲得很。算法要简单，数据结构也要简单。</li>
<li>第五法则： 数据为王。如果你选对了数据结构，组织得当，算法几乎都是呼之即来。编程的核心是数据结构，不是算法。</li>
</ul>
<ol>
<li>Pike的第一、二法则重申了Tony Hoare的名言：&quot;过早优化是万恶之源&quot;。 在中文里，&quot;万恶之源&quot;是个很重的词，用在这儿既有警示，也带点调侃。</li>
<li>Ken Thompson把Pike 的第三、四法则总结为：&quot;疑难杂症，暴力破解&quot;。 &quot;暴力破解&quot;在中文程序员圈很常见，指不优雅但直接有效的解法。</li>
<li>第三、四法则体现了KISS（Keep It Simple, Stupid）设计哲学。中文常说&quot;简单就是美&quot;，或者IT圈的&quot;能用短裤的地方，别穿西装&quot;。</li>
<li>第五法则早先出现在Fred Brooks的《人月神话》中。程序员们常把它简化为&quot;写傻瓜代码，用聪明对象&quot;。 这句话在中文圈也很流行，强调代码逻辑要直白，复杂性应该封装在良好设计的数据结构里。</li>
</ol>
<h2 id="15、如果POSIX线程算好东西，我都不敢想它比什么还好。">15、如果POSIX线程算好东西，我都不敢想它比什么还好。</h2>
<blockquote>
<p>If POSIX threads are a good thing, perhaps I don&#39;t want to know what they&#39;re better than. </p>
</blockquote>
<p>这是一句典型的程序员式嘲讽，直指他认为设计糟糕的一个技术标准。相当于说&quot;它已经够糟了，居然还有比它更糟的？&quot;</p>
<p>Pike为什么这么说？</p>
<ul>
<li>复杂性：pthreads API被认为过于复杂和底层，容易出错。</li>
<li>死锁风险：错误使用pthreads很容易导致死锁、竞态条件等并发问题。</li>
<li>可移植性问题：尽管POSIX旨在提高可移植性，但不同系统的pthreads实现仍有差异。</li>
</ul>
<h2 id="16、缓存的bug，哪个不是妖魔鬼怪。">16、缓存的bug，哪个不是妖魔鬼怪。</h2>
<blockquote>
<p>There&#39;s no such thing as a simple cache bug.</p>
</blockquote>
<p>&quot;缓存&quot;在计算机中无处不在：CPU缓存（L1, L2, L3）、内存缓存（如Redis）、浏览器缓存、数据库查询缓存、CDN（内容分发网络）、DNS缓存等等。</p>
<p>Pike之所以这么说，是因为缓存bug的特点：</p>
<ul>
<li>诡异性：缓存问题常常表现得不一致、间歇性，像&quot;鬼打墙&quot;。</li>
<li>隐蔽性：问题可能潜伏很久才暴露，像&quot;潜伏的妖怪&quot;。</li>
<li>牵连性：一个小小的缓存问题可能导致系统范围的故障，像&quot;妖风四起&quot;。</li>
<li>难调试：因为缓存常常是分布式的，跟踪问题如同&quot;捉鬼&quot;。</li>
<li>死灰复燃：以为修好了，问题却在高负载时死灰复燃，像&quot;怪物再生&quot;。</li>
</ul>
<h2 id="17、用_Unix_就跟只听大卫·卡西迪的歌似的，纯属乐坛井底之蛙。">17、用 Unix 就跟只听大卫·卡西迪的歌似的，纯属乐坛井底之蛙。</h2>
<blockquote>
<p>Using Unix is the computing equivalent of listening only to music by David Cassidy.</p>
</blockquote>
<p>Rob Pike在一次采访中说了这句话<a href="https://interviews.slashdot.org/story/04/10/18/1153211/rob-pike-responds" target="_blank" rel="external">rob pike responds</a>。</p>
<p>Rob Pike可是Unix的大佬级人物，和Ken Thompson、Dennis Ritchie一起在贝尔实验室创造了Unix。他怎么可能真的觉得Unix就像肤浅的流行乐？</p>
<p>现在的macOS（Mach内核）、Linux，甚至Windows（WSL）都有Unix的影子。<br>Pike仿佛预言般地讽刺：&quot;看看，大家最后都来听&#39;大卫·卡西迪&#39;了。&quot;</p>
<p>Rob Pike这句话是典型的技术人的自嘲式炫耀。表面上自贬，实际上是在用幽默的方式表达：&quot;对，我们就是主流，因为我们简单好用。学院派笑话我们Low，但最后还不是得用我们的东西？&quot;这种自黑中带着骄傲的调调。</p>
<h2 id="18、&quot;智能&quot;终端可不是&quot;自作聪明&quot;的终端，而是你能调教的好帮手。">18、&quot;智能&quot;终端可不是&quot;自作聪明&quot;的终端，而是你能调教的好帮手。</h2>
<blockquote>
<p>A smart terminal is not a smartass terminal, but rather a terminal you can educate.</p>
</blockquote>
<p>Rob Pike这句话用带点烟火气的方式，点出了技术设计的一个关键：真正的&quot;智能&quot;不是自作聪明，而是在交互中学习和成长。就像中国老话说的，&quot;学而不舍，才能化茧成蝶&quot;。无论是终端还是人，都是这个道理。</p>
<h2 id="19、Socket_是_IO_接口的_X_Window。">19、Socket 是 IO 接口的 X Window。</h2>
<blockquote>
<p>Sockets are the X windows of IO interfaces.</p>
</blockquote>
<p>表面上是在夸 Socket，就像当年吹捧 X Window 一样，实际上是 Pike 式的反话，意思是：&quot;Socket 复杂、难用，就跟 X Window 一样令人头疼。&quot;</p>
<p>为什么 Pike 这么黑 Socket？</p>
<ul>
<li>复杂性：Socket API 有很多参数、选项和状态，容易用错。</li>
<li>底层性：直接操作网络协议，程序员要处理字节流、缓冲区等底层细节。</li>
<li>错误处理难：网络环境复杂，Socket 编程中的错误情况多，很难全面处理。</li>
<li>跨平台坑多：不同操作系统的 Socket 实现有微妙差异，写出跨平台代码很烦。</li>
</ul>
<h2 id="20、搞个理论上不那么刺激的编程语言干嘛？因为好用啊，能用才是王道。">20、搞个理论上不那么刺激的编程语言干嘛？因为好用啊，能用才是王道。</h2>
<blockquote>
<p>Why would you have a language that is not theoretically exciting? Because it&#39;s very useful.</p>
</blockquote>
<p>这话当然还是出自Rob Pike。作为Unix和Go语言之父，他一贯秉持&quot;实用主义者&quot;的态度。</p>
<p>学院派追求&quot;道&quot;（理论和原则）。Pike强调&quot;术&quot;（实用技巧和方法）。</p>
<h2 id="21、并发不是并行">21、并发不是并行</h2>
<blockquote>
<p>Concurrency is not parallelism</p>
</blockquote>
<h2 id="22、_Go语言_箴言">22、 Go语言 箴言</h2>
<blockquote>
<p>Go Proverbs</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_计算机领域里，没有什么问题是加一层间接寻址解决不了的。">1. 计算机领域里，没有什么问题是加一层间接寻址解决不了的。</h2>
<blockquote>
<p>There&#39;s nothing in computing that can&#39;t be broken by another level of indirection.</p>
</blockquote>
<p>这是 Rob Pike 的修改版。</p>
<p>经常 <code>level of insriection</code> 误引用为 <code>abstraction layer</code>。</p>
<blockquote>
<p>原始版本出自 <strong>Butler Lampson</strong><br>All problems in computer science can be solved by another level of indirection</p>
<p>但是 <strong>David Wheeler</strong> 完成了下半句：<br>All problems in computer science can be solved by another level of indirection, except for the problem of too many layers of indirection.</p>
<p>还有 Kevlin Henney 的下半句：<br>ll problems in computer science can be solved by another level of indirection, except for the problem of too many layers of indirection.&quot;</p>
<p>From <a href="https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html" target="_blank" rel="external">Beautiful Code: Another Level of Indirection </a></p>
</blockquote>
<p>这句话幽默地指出，在计算机编程中，通过引入额外的抽象层或中间层，几乎可以解决任何复杂的问题。这种思路在软件设计和架构中很常见。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust tips #81 ~ #90]]></title>
    <link href="https://colobu.com/2024/06/09/rust-tips-81-90/"/>
    <id>https://colobu.com/2024/06/09/rust-tips-81-90/</id>
    <published>2024-06-09T03:36:28.000Z</published>
    <updated>2024-08-09T06:26:33.786Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
]]>
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust tips #61 ~ #80]]></title>
    <link href="https://colobu.com/2024/06/09/rust-tips-61-80/"/>
    <id>https://colobu.com/2024/06/09/rust-tips-61-80/</id>
    <published>2024-06-09T03:36:19.000Z</published>
    <updated>2024-08-09T06:26:33.780Z</updated>
    <content type="html"><![CDATA[<h2 id="Tip_#61">Tip #61</h2>
<p>前几天有人问我关于智能指针的事。这里简单介绍一下 <code>Rc&lt;T&gt;</code> 智能指针的基础知识：</p>
<a id="more"></a>
<p><img src="1.png" alt=""></p>
<h2 id="Tip_#62">Tip #62</h2>
<p>这是一篇关于 Rust 中的错误处理以及如何应用 <code>anyhow</code> 库的精彩文章：</p>
<p><a href="https://antoinerr.github.io/blog-website/2023/01/28/rust-anyhow.html" target="_blank" rel="external">https://antoinerr.github.io/blog-website/2023/01/28/rust-anyhow.html</a></p>
<h2 id="Tip_#63">Tip #63</h2>
<p>刚开始学习 Rust 编程时，我惊讶地发现示例中从未见过任何原始指针。常见的都是 <code>Box&lt;&gt;()</code>, <code>Arc&lt;&gt;()</code> 等智能指针。事实上，原始指针确实存在，但在惯用的 Rust 代码中很少使用。深入了解后，这里提供一个 C 语言与 Rust 原始指针的并排对比：<br><img src="2.png" alt=""></p>
<h2 id="Tip_#64">Tip #64</h2>
<p>今天我学到了关于 <code>NonZero</code> 数值类型的知识，你可以确保在编译时数值不会为零。它也是一个真正的零成本抽象，因为如果你定义了例如 <code>Option&lt;NonZeroU8&gt;</code>，那么 &quot;0&quot; 值就会映射到 &quot;None&quot;。非常巧妙！这里有个例子：<br><img src="3.png" alt=""></p>
<h2 id="Tip_#65">Tip #65</h2>
<p>这里有一篇由 @ThePrimeagen 撰写的有益论述，列举了 Rust 中枚举（Enums）的优势：<br><a href="https://www.youtube.com/watch?v=Epwlk4B90vk" target="_blank" rel="external">RUST Enums ARE Better (youtube.com)</a></p>
<h2 id="Tip_#66">Tip #66</h2>
<p><code>std::time::Instant</code> 可以作为一种简便方式用于测量代码块的执行时间：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::time::Instant;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> start = Instant::now();</div><div class="line"></div><div class="line">    <span class="comment">// Your code here</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> duration = start.elapsed();</div><div class="line">    println!(<span class="string">"Time elapsed: {:?}"</span>, duration);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#67">Tip #67</h2>
<p>单元结构体（Unit Struct）和元组结构体（Tuple Struct）是 Rust 类型系统中实用但不太为人知的构造体。</p>
<ul>
<li>单元结构体：可以在类型层面表示一个概念，同时也是在无需数据的情况下实现trait的好帮手。</li>
<li>元组结构体：类似于元组，但能实现方法。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Unit;</div><div class="line"><span class="keyword">struct</span> Point(<span class="keyword">i32</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = Point(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">println!(<span class="string">"Point Value: ({}, {}, {})"</span>, a.<span class="number">0</span>, a.<span class="number">1</span>, a.<span class="number">2</span>);</div></pre></td></tr></table></figure>

<h2 id="Tip_#68">Tip #68</h2>
<p>今天我发现可以在Trait中定义 #常量，而且在trait的具体实现（impl）中也可以重定义这些值。我还在权衡这样做的利弊。你会如何利用这个特性呢？分享你的想法吧！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">trait</span> <span class="title">MathConstants</span> {</div><div class="line">    <span class="keyword">const</span> PI: <span class="keyword">f64</span>;</div><div class="line">    <span class="keyword">const</span> E: <span class="keyword">f64</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyMath;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> MathConstants <span class="keyword">for</span> MyMath {</div><div class="line">    <span class="keyword">const</span> PI: <span class="keyword">f64</span> = <span class="number">3.141592653589</span>;</div><div class="line">    <span class="keyword">const</span> E: <span class="keyword">f64</span> = <span class="number">2.718281828459</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#69">Tip #69</h2>
<p>如果你遇到嵌套的 <code>Option</code> 情况，比如 <code>Option&lt;Option&lt;T&gt;&gt;</code>，你可以使用 <code>.flatten()</code> 方法去除一层嵌套:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> x: Option&lt;Option&lt;<span class="keyword">i32</span>&gt;&gt; = Some(Some(<span class="number">42</span>));</div><div class="line">    <span class="keyword">let</span> y: Option&lt;<span class="keyword">i32</span>&gt; = x.flatten();</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, y); <span class="comment">// 输出: Some(42)</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#70">Tip #70</h2>
<p>这条在 <code>match</code> 语句中使用的神秘语法特性是由一位关注者向我推荐的：</p>
<p><code>var_name @ match_value =&gt; ...</code> 允许你在匹配块中捕获 <code>match_value</code>的值来使用。下面的代码示例应该能清晰地说明这是如何运作的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> number: <span class="keyword">i32</span> = <span class="number">42</span>;</div><div class="line"><span class="keyword">match</span> number {</div><div class="line">    <span class="number">1</span>..=<span class="number">10</span> =&gt; {</div><div class="line">        println!(<span class="string">"Number is between 1 and 10 (inclusive)"</span>);</div><div class="line">    }</div><div class="line">    n: <span class="keyword">i32</span> @ <span class="number">42</span> =&gt; {</div><div class="line">        println!(<span class="string">"Number is {}"</span>, n);</div><div class="line">    }</div><div class="line">    n: <span class="keyword">i32</span> @ <span class="number">43</span>..=<span class="number">100</span> =&gt; {</div><div class="line">        println!(<span class="string">"Number is between 43 and 100 (inclusive): {}"</span>, n);</div><div class="line">    }</div><div class="line">    <span class="number">_</span> =&gt; {</div><div class="line">        println!(<span class="string">"Number is not in any specified range"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#71">Tip #71</h2>
<p>Rust 支持与 C 兼容的联合（union）类型。由于联合的成员共享相同的内存，它们本质上是不安全的。我能想到的最佳应用场景是与 C++ 交互，以及可能的二进制数据协议，比如将字节数组与其他类型联合在一起使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Repr C makes the memory layout conform to C's schema.</span></div><div class="line"><span class="preprocessor">#[repr(C)]</span></div><div class="line">union MyUnion {</div><div class="line">    f1: <span class="keyword">u32</span>,</div><div class="line">    f2: <span class="keyword">f32</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> u = MyUnion { f1: <span class="number">1</span> };</div><div class="line">    <span class="keyword">unsafe</span> {</div><div class="line">        <span class="comment">// Accessing a union's field is unsafe because Rust cannot guarantee</span></div><div class="line">        <span class="comment">// the type of data currently being stored in the union.</span></div><div class="line">        u.f1 = <span class="number">123</span>;</div><div class="line">        println!(<span class="string">"f1: {}"</span>, u.f1);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#72">Tip #72</h2>
<p>Rust 的数值类型真棒！你可以直接使用点符号表示法在数值上调用常见的数学函数。例如，只需通过调用 <code>32.0.sin()</code> 就能计算<code>32.0</code>的正弦值。这一特性增强了代码的可读性，减少了对冗长函数调用的需求。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> x = <span class="number">32.0</span>;</div><div class="line">    println!(<span class="string">"Sin of {} is: {}"</span>, x, x.sin());</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#73">Tip #73</h2>
<p><code>include_str!()</code> 和 <code>include_bytes!()</code> 宏能够在编译时将文件作为字符串或字节数组包含进来。这样就避免了使用冗长且杂乱的多行字符串字面量。编译器甚至会检查文件是否存在，如果文件缺失，还会报错提示。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Both of these files are read at compile time.</span></div><div class="line"><span class="keyword">const</span> FILE_STR: &<span class="keyword">str</span> = include_str!(<span class="string">"./path/to/the/file.txt"</span>);</div><div class="line"><span class="keyword">const</span> FILE_BYTES: &[<span class="keyword">u8</span>] = include_bytes!(<span class="string">"./path/to/image.png"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// Outputs file content as string.</span></div><div class="line">    println!(<span class="string">"{}"</span>, FILE_STR);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#74">Tip #74</h2>
<p>Rust 中迭代器的 <code>.zip()</code> 函数能够让两个 Vec 转换成单一的元组 Vec。然而，其语法不如 Python 版本那样方便。但这个问题可以通过优雅地使用泛型来解决：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">zip</span></span>&lt;T, U&gt;(vec1: Vec&lt;T&gt;, vec2: Vec&lt;U&gt;) -&gt; Vec&lt;(T, U)&gt; {</div><div class="line">    vec1.into_iter().zip(vec2.into_iter()).collect()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> vec1: Vec&lt;<span class="keyword">i32</span>&gt; = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    <span class="keyword">let</span> vec2: Vec&lt;<span class="keyword">char</span>&gt; = vec![<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"></div><div class="line">    <span class="keyword">let</span> zipped: Vec&lt;(<span class="keyword">i32</span>, <span class="keyword">char</span>)&gt; = zip(vec1, vec2);</div><div class="line">    <span class="keyword">for</span> pair: (<span class="keyword">i32</span>, <span class="keyword">char</span>) <span class="keyword">in</span> zipped {</div><div class="line">        println!(<span class="string">"{:?}"</span>, pair);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_插播一条">Tip 插播一条</h2>
<p>标签通常与嵌套循环关联在一起使用。<br>在下面的例子中，我使用了 <code>break &#39;outer</code> 从内部循环跳出到外层循环之外。</p>
<p>但实际上，它们的功能远不止于此：你可以在 任何 Rust 代码块上标注一个标签！<br>这开启了一个不错的编程模式，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_something</span></span>() {</div><div class="line">    'outer: <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] {</div><div class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] {</div><div class="line">            <span class="comment">// This breaks from the inner loop.</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="comment">// This breaks from the outer loop!</span></div><div class="line">            <span class="keyword">break</span> 'outer;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">'block: {</div><div class="line">    <span class="keyword">let</span> Some(b) = a <span class="keyword">else</span> { <span class="keyword">break</span> 'block };</div><div class="line">    <span class="keyword">let</span> Some(c) = b.c <span class="keyword">else</span> { <span class="keyword">break</span> 'block };</div><div class="line">    <span class="keyword">let</span> Some(d) = c.d <span class="keyword">else</span> { <span class="keyword">break</span> 'block };</div><div class="line">    <span class="keyword">let</span> Some(e) = d.e <span class="keyword">else</span> { <span class="keyword">break</span> 'block };</div><div class="line">    <span class="keyword">return</span> e.compute();</div><div class="line">}</div><div class="line">otherwise();</div></pre></td></tr></table></figure>

<h2 id="Tip_#75">Tip #75</h2>
<p>标有 Send 标记 trait的类型表示它们在多个线程之间移动是安全的。Rust 利用这一点来确保在编译时的线程安全性。</p>
<p>虽然编译器会自动为许多标准类型实现 Send，但对于自定义类型，我们依靠开发者——Send 是通过不安全代码块添加的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> MyType;</div><div class="line"></div><div class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Send <span class="keyword">for</span> MyType {}</div></pre></td></tr></table></figure>

<h2 id="Tip_#76">Tip #76</h2>
<p>快速入门：如何在你的 Rust 代码上运行调试器：</p>
<p>➡️ 使用调试符号构建：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">cargo</span> build</div></pre></td></tr></table></figure>

<p>➡️ 使用 lldb（或更美观输出的 rust-lldb）启动你的程序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lldb target/<span class="keyword">debug</span>/your_app_name</div></pre></td></tr></table></figure>

<p>➡️ 在特定行设置断点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">breakpoint <span class="keyword">set</span> --<span class="keyword">file</span> src/main.rs --<span class="built_in">line</span> <span class="number">10</span></div></pre></td></tr></table></figure>

<p>➡️ 通过名称设置函数断点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">breakpoint</span> <span class="built_in">set</span> <span class="comment">--name your_function_name</span></div></pre></td></tr></table></figure>

<p>➡️ 运行你的程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="command">run</span></div></pre></td></tr></table></figure>

<p>➡️ 运行时的调试命令</p>
<ul>
<li><code>frame variable</code> 会显示当前作用域内的所有变量</li>
<li><code>n</code> 执行当前行然后暂停</li>
<li><code>s</code> 进入当前行（调用最内层函数并停止）</li>
<li><code>c</code> 继续执行直到下一个断点</li>
</ul>
<h2 id="Tip_#77">Tip #77</h2>
<ul>
<li><code>Threads</code>: working together. for CPU bound tasks.</li>
<li><code>Async</code>: waiting together. for I/O bound tasks.</li>
</ul>
<h2 id="Tip_#78">Tip #78</h2>
<p>这里有一个很好的介绍文章，介绍如何从你的 Rust 代码中调用外部进程，并处理输出。</p>
<p><a href="https://rust-lang-nursery.github.io/rust-cookbook/os/external.html" target="_blank" rel="external">https://rust-lang-nursery.github.io/rust-cookbook/os/external.html</a></p>
<h2 id="Tip_#79">Tip #79</h2>
<p>作为函数输入参数使用 <code>&amp;Option&lt;T&gt;</code> 还是 <code>Option&lt;&amp;T&gt;</code>？</p>
<p>通常，<code>Option&lt;&amp;T&gt;</code> 是首选的方式，因为它提供了更多的灵活性转换，并利用了空指针优化（pointer niche optimization）。这意味着它可以自然地接受 <code>None</code>（空值）或 <code>&amp;T</code>（对某个值的引用），并且在内部实现上更为高效，特别是当与 Rust 的零值优化特性结合时。</p>
<table>
<thead>
<tr>
<th>argument</th>
<th>arg type : Option&lt;&amp;T&gt;</th>
<th>&amp;Option<t></t></th>
</tr>
</thead>
<tbody>
<tr>
<td>foo: Option<t></t></td>
<td>foo.as_ref()</td>
<td>&amp;foo</td>
</tr>
<tr>
<td>foo: Option&lt;&amp;T&gt;</td>
<td>foo</td>
<td>can&#39;t be done</td>
</tr>
<tr>
<td>foo: T</td>
<td>Some(&amp;foo)</td>
<td>&amp;Some(foo)†</td>
</tr>
<tr>
<td>foo: &amp;T</td>
<td>Some(foo)</td>
<td>can&#39;t be done</td>
</tr>
</tbody>
</table>
<p>一个专门掰扯这个话题的帖视频：<a href="https://www.youtube.com/watch?v=6c7pZYP_iIE" target="_blank" rel="external">https://www.youtube.com/watch?v=6c7pZYP_iIE</a></p>
<h2 id="Tip_#80">Tip #80</h2>
<p>我需要编写一个函数，能够灵活地在编译时定义输出数组的大小。事实证明，const 泛型对此非常有帮助。</p>
<p>&quot;Const 泛型&quot;使我们能够通过常量对类型进行参数化，因此得名。</p>
<p>这种特性允许你在定义泛型时使用编译时常量来指定类型的一部分，比如数组长度或结构体中的字段大小，从而在编译时就能确定这些值，而非运行时。这样可以提高代码效率，同时也增加了类型的灵活性和代码的重用性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">n_neighborhood</span></span>&lt;<span class="keyword">const</span> N: usize&gt;(tree: &Octree,</div><div class="line">                                 coord: [<span class="keyword">f64</span>; <span class="number">3</span>],</div><div class="line">                                 radius: <span class="keyword">f64</span>) -&gt; [<span class="keyword">f32</span>; N] {</div><div class="line">    <span class="keyword">let</span> res = [<span class="keyword">f32</span>; N];</div><div class="line">    </div><div class="line">    <span class="comment">// TODO: Find N neighbors in Octree.</span></div><div class="line"></div><div class="line">    res</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">const</span> SRCH_N: usize = <span class="number">4</span>;</div><div class="line">    <span class="comment">// Result is of type [f32; 4]</span></div><div class="line">    <span class="keyword">let</span> result = n_neighborhood::&lt;SRCH_N&gt;(&tree, coord);</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Tip_#61">Tip #61</h2>
<p>前几天有人问我关于智能指针的事。这里简单介绍一下 <code>Rc&lt;T&gt;</code> 智能指针的基础知识：</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust tips #41 ~ #60]]></title>
    <link href="https://colobu.com/2024/06/09/rust-tips-41-60/"/>
    <id>https://colobu.com/2024/06/09/rust-tips-41-60/</id>
    <published>2024-06-09T03:36:11.000Z</published>
    <updated>2024-08-09T06:26:33.771Z</updated>
    <content type="html"><![CDATA[<h2 id="Tip_#41">Tip #41</h2>
<p>类似于 Go 语言中的通道（Go 的 <code>channel</code>），Rust 中的 <code>std::sync::mpsc</code> 提供了一种线程间安全地读写数据的机制:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::mpsc;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</div><div class="line"></div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="keyword">let</span> val = String::from(<span class="string">"hi"</span>);</div><div class="line">        tx.send(val).unwrap();</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</div><div class="line">    println!(<span class="string">"Got: {}"</span>, received);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个通道，然后在一个线程中发送了一个字符串。在主线程中，我们等待接收这个字符串并打印它。</p>
<a id="more"></a>
<h2 id="Tip_#42">Tip #42</h2>
<p>希望在编码过程中，让编译器和代码检查工具实时地指出并协助解决出现的问题吗？</p>
<p>不妨试试<a href="https://crates.io/crates/bacon" target="_blank" rel="external">Bacon</a><br><img src="1.png" alt=""></p>
<h2 id="Tip_#43">Tip #43</h2>
<p>除了标准库中的 <code>std::HashMap</code>，Rust 还为特定场景提供了其他哈希表变体：</p>
<ul>
<li><code>IndexMap</code>（<code>indexmap</code> 库）：保持键的插入顺序。</li>
<li><code>BTreeMap</code>（位于 <code>std::collections</code>）：按照键的排序顺序维护元素。</li>
<li><code>DashMap</code>（<code>dashmap</code> 库）：无锁并发散列映射，适用于并发或多线程代码。</li>
</ul>
<h2 id="Tip_#44">Tip #44</h2>
<p>使用 actix_web 的 Rust 网页服务器，具备静态文件服务功能，并默认将请求路由到 <code>index.html</code>。几乎和 JavaScript 一样简单,对吗？<br><img src="2.png" alt=""></p>
<h2 id="Tip_#45">Tip #45</h2>
<p>对于想要极度优化代码的你们，这里有一个有趣的小知识：</p>
<p><code>std::hint</code> 允许你告诉编译器某个布尔表达式很可能是真的，从而启用优化的分支预测：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::hint::likely;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> x = <span class="number">42</span>;</div><div class="line">    <span class="keyword">if</span> likely(x &gt; <span class="number">0</span>) {</div><div class="line">        println!(<span class="string">"x is positive"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        println!(<span class="string">"x is not positive"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#46">Tip #46</h2>
<p>你是否曾被 PartialEq 和 Eq 这两个 #trait搞晕过？这里有一个快速概览：</p>
<ul>
<li><code>PartialEq</code>：通过 <code>eq</code> 方法实现（不要与 <code>Eq</code> 混淆！），它启用了相等性（<code>==</code>）检查。如果项目不可比较，则 <code>eq</code> 返回 <code>false</code>。</li>
<li><code>Eq</code>：一个没有自己方法的“标记Trait”。它告诉编译器所有元素都可以进行等价比较，并确保等价关系是自反的、对称的和传递的。</li>
</ul>
<h2 id="Tip_#47">Tip #47</h2>
<p>一些避免使用可怕的<code>clone()</code>方法的策略包括：</p>
<ul>
<li>向只读函数传递借用（<code>&amp;</code>）时使用引用</li>
<li>利用 <code>Rc&lt;T&gt;</code> 或 <code>Arc&lt;T&gt;</code> 来共享所有权</li>
<li>实现 <code>Copy</code> 特性（类似 C 语言中的 memcpy）</li>
<li>使用 <code>Cow&lt;T&gt;</code>（写时复制）来半自动管理复制过程</li>
</ul>
<h2 id="Tip_#48">Tip #48</h2>
<p>Rust 在处理线程和读取它们的返回值方面真正大放异彩的一个例子是，这看起来比许多其他语言做起来要简单得多。下面是一个处理两个线程结果的简单示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> handle1 = thread::spawn(|| <span class="number">1</span>);</div><div class="line">    <span class="keyword">let</span> handle2 = thread::spawn(|| <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> result1 = handle1.join().unwrap();</div><div class="line">    <span class="keyword">let</span> result2 = handle2.join().unwrap();</div><div class="line"></div><div class="line">    println!(<span class="string">"Result: {}"</span>, result1 + result2);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#49">Tip #49</h2>
<p>使用 <code>Rayon</code> 库对 for 循环进行简单并行化，只需添加导入并使用 <code>Rayon</code> 提供的 <code>.par_iter()</code> 并行迭代器。</p>
<p>该代码用于统计大于0的元素。预期的加速效果大约为 X 倍，其中 X 代表你拥有的 CPU 核心数量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> rayon::prelude::*;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> numbers = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</div><div class="line">    <span class="keyword">let</span> count = numbers.par_iter().filter(|&x| x &gt; <span class="number">0</span>).count();</div><div class="line">    println!(<span class="string">"Count: {}"</span>, count);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#50">Tip #50</h2>
<p>如果你正在调试你的迭代器，并且只想测试数据的一个子集，你可以使用 <code>myvec.iter().take(N)</code> 来仅对前 N 个元素进行操作。</p>
<p>或者，你也可以对输入进行切片：<code>&amp;myvec[0..N].iter()</code></p>
<h2 id="Tip_#51">Tip #51</h2>
<p>在迭代器中对一列可选值（<code>Option</code>）使用 <code>map()</code> 感到棘手？</p>
<p><code>filter_map()</code> 巧妙地处理了这个问题，它会忽略 <code>None</code> 值，只处理 <code>Some()</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> numbers = vec![Some(<span class="number">1</span>), None, Some(<span class="number">3</span>), None, Some(<span class="number">5</span>)];</div><div class="line">    <span class="keyword">let</span> sum: <span class="keyword">i32</span> = numbers.iter().filter_map(|&x| x).sum();</div><div class="line">    println!(<span class="string">"Sum: {}"</span>, sum);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#52">Tip #52</h2>
<p><code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code> 分别是什么？这些是用于将闭包作为函数参数传递的特殊trait。</p>
<ul>
<li><code>Fn</code>：不修改环境的闭包</li>
<li><code>FnMut</code>：可以修改环境<br><code>FnOnce</code>：运行一次并消耗环境</li>
</ul>
<p>这里有一个展示 <code>FnMut</code> trait实际运用的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> add = |y| x += y;</div><div class="line">    add(<span class="number">5</span>);</div><div class="line">    println!(<span class="string">"x: {}"</span>, x); <span class="comment">// 输出: x: 10</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#53">Tip #53</h2>
<p>继续探讨“核心”或“系统” trait的主题，<code>Drop</code> trait非常有趣：任何超出作用域的数据类型都会自动调用<code>Drop()</code>。因此，如果你实现了<code>Drop()</code>，就可以在需要时执行自定义的清理操作。</p>
<h2 id="Tip_#54">Tip #54</h2>
<p>在使用异步 Rust 开发时，如果需要执行两个（不相关）任务，你可以使用来自 <code>futures</code> #库的 <code>join!</code> 宏并行地调度它们。相比于依次调用 <code>.await</code>，这样做可以更高效：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> futures::join;</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">task1</span></span>() -&gt; <span class="keyword">u32</span> {</div><div class="line">    <span class="number">42</span></div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">task2</span></span>() -&gt; <span class="keyword">u32</span> {</div><div class="line">    <span class="number">24</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> (result1, result2) = join!(task1(), task2());</div><div class="line">    println!(<span class="string">"Result: {}"</span>, result1 + result2);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#55">Tip #55</h2>
<p>我深入探索了 Rust 中声明式宏的世界。第一步是要理解基本语法……这确实很难用文字描述，所以我制作了一张（希望是有教育意义的）图片，涵盖了基础知识：<br><img src="3.png" alt=""></p>
<h2 id="Tip_#56">Tip #56</h2>
<p>在上一条的宏话题基础上，今天我探讨了10个匹配器加上上次帖子中遗漏的 &quot;ident&quot; 匹配器。来看看这张展示了每个匹配器的示例的网格图吧：<br><img src="4.png" alt=""></p>
<h2 id="Tip_#57">Tip #57</h2>
<p>在 Rust 中，你可以实现在三个主要位置编写测试：</p>
<ul>
<li>作为文档的一部分（doctest）</li>
<li>代码下方的嵌入式测试（#[cfg(test)]属性包裹）</li>
<li>外部的测试文件夹中</li>
</ul>
<p>👉 通过执行 &quot;cargo test&quot; 来运行测试</p>
<h2 id="Tip_#58">Tip #58</h2>
<p>Rust 的类型系统允许我们定义“标记类型”，这些可以仅仅是带有名字的结构体，用来为特定类型编码元数据。以下是一个使用标记结构体示例，表示一个文档结构体可以处于 &quot;草稿&quot; 或 &quot;已发布&quot; 状态：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Marker structs representing states</span></div><div class="line"><span class="keyword">struct</span> Draft;</div><div class="line"><span class="keyword">struct</span> Published;</div><div class="line"></div><div class="line"><span class="comment">// The Document struct, parameterized by its state</span></div><div class="line"><span class="keyword">struct</span> Document&lt;State&gt; {</div><div class="line">    content: String,</div><div class="line">    <span class="number">_</span>state: std::marker::PhantomData&lt;State&gt;,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Document&lt;Draft&gt; {</div><div class="line">    <span class="comment">// Constructor for a new draft document</span></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(content: String) -&gt; Document&lt;Draft&gt; {</div><div class="line">        Document {</div><div class="line">            content,</div><div class="line">            <span class="number">_</span>state: std::marker::PhantomData,</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Review the document</span></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">review</span></span>(<span class="keyword">self</span>) -&gt; Document&lt;Published&gt; {</div><div class="line">        Document {</div><div class="line">            content: <span class="keyword">self</span>.content,</div><div class="line">            <span class="number">_</span>state: std::marker::PhantomData,</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Document&lt;Published&gt; {</div><div class="line">    <span class="comment">// Publish the document</span></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">publish</span></span>(<span class="keyword">self</span>) {</div><div class="line">        println!(<span class="string">"Publishing document: {}"</span>, <span class="keyword">self</span>.content);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#59">Tip #59</h2>
<p>我遇到了几次尝试实现一个扩展trait但编译器不允许的情况。事实证明，有两个规则需要注意：</p>
<ol>
<li>如果trait是在你的crate中定义的，你可以为任何类型实现扩展，即使是其他crate中的类型。</li>
<li>如果trait是在另一个crate中定义的，你只能为你crate中定义的类型实现它。</li>
</ol>
<p>扩展trait基本上允许基于trait定义，向一个类型添加新的功能。</p>
<h2 id="Tip_#60">Tip #60</h2>
<p>当你在结构体上 #派生 <code>Debug</code> trait时，你会得到两种用于 <code>println!</code> 的格式化方式：</p>
<ul>
<li><code>{:?}</code> 默认的调试格式化器</li>
<li><code>{:#?}</code> “美化打印”的调试格式化器</li>
</ul>
<p>这两种输出的视觉差异是什么？让我们来看一下：<br><img src="5.png" alt=""><img src="6.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Tip_#41">Tip #41</h2>
<p>类似于 Go 语言中的通道（Go 的 <code>channel</code>），Rust 中的 <code>std::sync::mpsc</code> 提供了一种线程间安全地读写数据的机制:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::mpsc;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</div><div class="line"></div><div class="line">    thread::spawn(move || {</div><div class="line">        <span class="keyword">let</span> val = String::from(<span class="string">"hi"</span>);</div><div class="line">        tx.send(val).unwrap();</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</div><div class="line">    println!(<span class="string">"Got: {}"</span>, received);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个通道，然后在一个线程中发送了一个字符串。在主线程中，我们等待接收这个字符串并打印它。</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust tips #21 ~ #40]]></title>
    <link href="https://colobu.com/2024/06/08/rust-tips-21-40/"/>
    <id>https://colobu.com/2024/06/08/rust-tips-21-40/</id>
    <published>2024-06-08T10:51:42.000Z</published>
    <updated>2024-08-09T06:26:33.771Z</updated>
    <content type="html"><![CDATA[<h2 id="Tip_#21">Tip #21</h2>
<p>在 Rust 中，我们经常使用 <code>Clone()</code> 或 <code>Copy()</code>。这两者之间的区别是什么？</p>
<ul>
<li><p><code>Copy</code>：支持 <code>Copy</code> 的类型可以安全地通过字节复制的方式进行复制，可以类比 C 语言中的 <code>memcpy</code> 函数。</p>
</li>
<li><p><code>Clone</code>：支持 <code>Clone</code> 的类型也可以被复制，但它通常需要执行一些逻辑操作来完成深拷贝。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="Tip_#22">Tip #22</h2>
<p>我之前忽略的一点是，Rust 中有 <code>static</code> 变量，可以用来追踪某些状态。当然， 可变的静态变量 （mutable static）是不支持的，但对于原始类型，可以考虑使用<strong>std::sync::atomic</strong>。这些可以被实例化为静态的，并且在后续可以被修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> COUNTER: AtomicUsize = AtomicUsize::new(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// Functions to get and increment *static* counter.</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">increment_counter</span></span>() {</div><div class="line">    COUNTER.fetch_add(<span class="number">1</span>, order: Ordering::Relaxed);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_counter</span></span>() -&gt; usize {</div><div class="line">    COUNTER.load(order: Ordering::Relaxed)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#23">Tip #23</h2>
<p>对于大多数使用核心数据类型的结构体，你可以通过派生 <code>Default</code>  trait自动生成一个基本的<strong>Default()</strong>实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[derive(Default)] </div><div class="line"><span class="keyword">struct</span> MyStruct { ... }</div></pre></td></tr></table></figure>

<h2 id="Tip_#24">Tip #24</h2>
<p>探索智能指针：</p>
<ul>
<li><code>Box&lt;T&gt;</code> 用于独占所有权，一旦它所在的作用域 <code>{}</code> 结束，它就会被释放。</li>
<li><code>Rc&lt;T&gt;</code> 是一种引用计数的智能指针。只有当它的所有引用都不存在时，它才会被释放。</li>
<li><code>Arc&lt;T&gt;</code> 是 <code>Rc&lt;T&gt;</code> 的线程安全版本。</li>
</ul>
<h2 id="Tip_#25">Tip #25</h2>
<p>在Rust中，trait的工作方式类似于其他语言中的<strong>接口</strong>定义。实现某个trait的结构体或枚举，在契约上必须提供trait中指定签名的函数 :</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Define a trait `Describable`</span></div><div class="line"><span class="keyword">trait</span> <span class="title">Describable</span> {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">describe</span></span>(&<span class="keyword">self</span>) -&gt; String;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Person {</div><div class="line">    name: String,</div><div class="line">    age: <span class="keyword">u32</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Implement the `Describable` trait for `Person`</span></div><div class="line"><span class="keyword">impl</span> Describable <span class="keyword">for</span> Person {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">describe</span></span>(&<span class="keyword">self</span>) -&gt; String {</div><div class="line">        format!(<span class="string">"{} is {} years old."</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#26">Tip #26</h2>
<p>你知道Rust支持对大多数常见数据类型进行<strong>解构</strong>吗？这里有一个关于结构体的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Rocket {</div><div class="line">    name: String,</div><div class="line">    num_engines: <span class="keyword">u32</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">let</span> falcon9: Rocket = Rocket{name: <span class="string">"Falcon 9"</span>.to_string(), num_engines: <span class="number">9</span>};</div><div class="line"></div><div class="line"><span class="comment">// Destructure name and engines</span></div><div class="line"><span class="keyword">let</span> Rocket {name: the_name: String, num_engines: the_engines: <span class="keyword">u32</span>} = falcon9;</div><div class="line"></div><div class="line">println!(<span class="string">"Rocket name {}, num engines {}"</span>, the_name, the_engines);</div></pre></td></tr></table></figure>

<p>这种解构方式允许你在一行中从结构体中提取多个字段，并给它们起新的名字或指定类型，这在处理复杂数据时非常有用。</p>
<h2 id="Tip_#27">Tip #27</h2>
<p>Rust #区间表达式：</p>
<ul>
<li>包含区间（包含a到b，b也包括在内）：<code>a..=b</code></li>
<li>半开区间（包含a到b-1）：<code>a..b</code></li>
<li>从a开始：<code>a..</code></li>
<li>到b-1为止：<code>..b</code></li>
<li>到b为止（包括b）：<code>..=b</code></li>
<li>完整区间：<code>..</code></li>
</ul>
<h2 id="Tip_#28">Tip #28</h2>
<p>区间表达式(继续)：<br>区间表达式可以应用于for循环，或用于创建迭代器。别忘了调用<strong>collect()</strong>来实际执行迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> squares_a: Vec&lt;<span class="keyword">u32</span>&gt; = vec![];</div><div class="line"></div><div class="line"><span class="keyword">for</span> i: <span class="keyword">u32</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">100</span> {</div><div class="line">    squares_a.push(i * i);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Map creates an iterator, but does not perform the computation.</span></div><div class="line"><span class="keyword">let</span> squares_b_it: <span class="keyword">impl</span> Iterator&lt;Item = <span class="keyword">u32</span>&gt; = (<span class="number">1</span>..=<span class="number">100</span>).map(|x: <span class="keyword">u32</span>| x * x);</div><div class="line"></div><div class="line"><span class="comment">// Apply collect to "run" the iterator.</span></div><div class="line"><span class="keyword">let</span> squares_b: Vec&lt;<span class="keyword">u32</span>&gt; = (<span class="number">1</span>..=<span class="number">100</span>).map(|x: <span class="keyword">u32</span>| x * x).collect();</div></pre></td></tr></table></figure>

<h2 id="Tip_#29">Tip #29</h2>
<p>迭代器可以通过 <code>chain()</code> 方法进行连续拼接。Rust 在处理可能含有或不含值的 <code>Option</code> 类型的连续操作时表现得尤为优雅。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> maybe_rocket = Some(<span class="string">"Starship"</span>);</div><div class="line"><span class="keyword">let</span> rockets = vec![<span class="string">"falcon1"</span>, <span class="string">"falcon2"</span>];</div><div class="line"></div><div class="line"><span class="comment">// Chain the two iterators together.</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rockets.iter().chain(maybe_rocket) {</div><div class="line">    println!(<span class="string">"🚀 {}"</span>, i);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#30">Tip #30</h2>
<p>如果需要以非可变方式将向量（<code>vector</code>）传递给函数，你可以使用 <code>&amp;[T]</code>（等同于 <code>&amp;Vec&lt;T&gt;</code>）类型的参数，这也就是所谓的 <code>切片</code>（<code>slice</code>）。</p>
<p>切片的优势包括：它们避免了所有权的转移，并且对于 #并发或 #并行操作是安全的。</p>
<h2 id="Tip_#31">Tip #31</h2>
<p>动态调度（<code>dynamic dispatch</code>）简单来说，是在程序运行时动态地处理不同类型的特性，通过一个公共的特质（trait）来实现，从而使得（具有 Rust 特色的）多态成为可能。</p>
<p>在 Rust 中，<code>Box&lt;dyn Trait&gt;</code> 通常表明使用了动态调度。</p>
<h2 id="Tip_#32">Tip #32</h2>
<p>迭代器提供了一些非常方便的实用功能。其中之一是 <code>all()</code> 方法，它会检查迭代器中所有元素是否都满足给定的条件。</p>
<p>这使我们能够以优雅且符合习惯用法的方式重写难看的基于for循环的代码:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 难看的代码</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_user_infos</span></span>(user_infos: Vec&lt;UserInfo&gt;) -&gt; <span class="keyword">bool</span> {</div><div class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> user_infos.iter() {</div><div class="line">        <span class="keyword">if</span> !unique_tags.contains(&u.user_name.as_str()) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">true</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 优雅的代码</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_user_infos</span></span>(user_infos: Vec&lt;UserInfo&gt;) -&gt; <span class="keyword">bool</span> {</div><div class="line">    user_infos.iter().all(|u| unique_tags.contains(&u.user_name.as_str()))</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#33">Tip #33</h2>
<p><code>let a: Arc&lt;Mutex&lt;Vec&lt;f32&gt;&gt;&gt;</code> 这样的声明在视觉上是否让你觉得困扰？这时可以使用 <code>type</code>关键字来定义类型 <strong>别名</strong>（alias）:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="title">SharedSafeVec</span>&lt;T&gt; = Arc&lt;Mutex&lt;Vec&lt;T&gt;&gt;&gt;</div></pre></td></tr></table></figure>

<p>这样，你就可以使用 <code>SharedSafeVec&lt;f32&gt;</code> 来代替 <code>Arc&lt;Mutex&lt;Vec&lt;f32&gt;&gt;&gt;</code>。</p>
<h2 id="Tip_#34">Tip #34</h2>
<p><code>Option&lt;T&gt;.map()</code> 是一种将<strong>选项</strong>（<code>Option</code>）从一种类型转换为另一种类型的极佳方式。它能透明地处理 <code>None</code> 值的情况。</p>
<p>请看以下示例，我们将 <code>Option&lt;u32&gt;</code> 转换为 <code>Option&lt;String&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> number_option: Option&lt;<span class="keyword">u32</span>&gt; = Some(<span class="number">42</span>);</div><div class="line">    <span class="keyword">let</span> string_option: Option&lt;String&gt; = number_option.map(|num| num.to_string());</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, string_option); <span class="comment">// 输出: Some("42")</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> none_option: Option&lt;<span class="keyword">u32</span>&gt; = None;</div><div class="line">    <span class="keyword">let</span> empty_string_option: Option&lt;String&gt; = none_option.map(|num| num.to_string());</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, empty_string_option); <span class="comment">// 输出: None</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#35">Tip #35</h2>
<p>什么是 <code>trait bound</code>? 当我们向带有泛型参数的函数中传递额外的trait名称，以便限制该泛型类型时，就是在谈论<code>trait bound</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T: TraitA + TraitB&gt;(param: T) { ... }</div></pre></td></tr></table></figure>

<p>你可以使用 &quot;+&quot; 运算符来组合多个特质。这样一来，类型 T 就需要同时满足 <code>TraitA</code> 和 <code>TraitB</code> 这两个特质的要求。</p>
<h2 id="Tip_#36">Tip #36</h2>
<p>如需从应用程序获取更详细的日志输出，尝试导出环境变量 <code>RUST_LOG={error, warn, info, debug, trace}</code>。</p>
<p>以下是一个使用 <code>actix-web</code> 运行的服务在 <code>trace</code> 模式下的示例，它会提供超级详尽的日志输出：<br>![[Pasted image 20240608183308.png]]</p>
<h2 id="Tip_#37">Tip #37</h2>
<p>元组结构体对于封装值并附加可通过 Rust 的类型系统验证的元数据非常有用。</p>
<p>元组结构体的一个妙用是模拟计量单位——这样就不会再混淆英尺和米了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Feet(<span class="keyword">i32</span>); <span class="comment">// 定义一个元组结构体，表示英尺</span></div><div class="line"><span class="keyword">struct</span> Meters(<span class="keyword">i32</span>); <span class="comment">// 定义另一个元组结构体，表示米</span></div><div class="line"></div><div class="line"><span class="keyword">impl</span> From&lt;Feet&gt; <span class="keyword">for</span> Meter {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(feet: Feet) -&gt; Self {</div><div class="line">        Meter(feet.<span class="number">0</span> * <span class="number">0.3048</span>) <span class="comment">// 将英尺转换为米</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span> From&lt;Meters&gt; <span class="keyword">for</span> Feet {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(meters: Meters) -&gt; Self {</div><div class="line">        Feet(meters.<span class="number">0</span> / <span class="number">0.3048</span>) <span class="comment">// 将米转换为英尺</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">is_longer_enough</span></span>(meters: Meters) -&gt; <span class="keyword">bool</span> {</div><div class="line">    meters.<span class="number">0</span> &gt; <span class="number">1</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_longer_enough</span></span>(feet: Feet) -&gt; <span class="keyword">bool</span> {</div><div class="line">    feet.<span class="number">0</span> &gt; <span class="number">3</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#38">Tip #38</h2>
<p>正在编写一个函数但还没准备好最终完成？可以使用 <code>todo!()</code> 或 <code>unimplemented!()</code> 宏来让代码保持可编译状态。但要记住，如果你的程序运行时遇到这些点，它将会<code>panic</code>！这对于开发阶段非常理想。🚧</p>
<blockquote>
<p>和第四条重复了</p>
</blockquote>
<h2 id="Tip_#39">Tip #39</h2>
<p>30秒速成指南：构建 Rust #模块</p>
<p>创建你的模块结构：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my_module/</div><div class="line">│   ├── <span class="keyword">mod</span>.rs</div><div class="line">│   ├── component_1.rs</div><div class="line">│   └── component_2.rs</div></pre></td></tr></table></figure>

<p>在 mod.rs 中添加：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mod</span> component_1;</div><div class="line"><span class="keyword">mod</span> component_2;</div></pre></td></tr></table></figure>

<p>或者新的方式：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my_module/ </div><div class="line">├── component_1.rs </div><div class="line">└── component_2.rs</div><div class="line">my_module.rs</div></pre></td></tr></table></figure>

<p>🌟 小贴士：使用<code>pub</code> 关键字来定义公有访问权限。</p>
<h2 id="Tip_#40">Tip #40</h2>
<p>实际上，Rust 中有两种类型的<strong>宏</strong>。<code>声明式宏</code>（declarative）和更高级的 <code>过程式宏</code>（procedural）。下面是一个使用 <code>macro_rules!</code> 宏来生成 <code>println</code> 功能的声明式宏示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">macro_rules! my_println {</div><div class="line">    ($($arg:tt)*) =&gt; {</div><div class="line">        println!($($arg)*);</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    my_println!(<span class="string">"Hello, Rust!"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这段代码定义了一个名为 <code>my_println!</code> 的宏，它接收任意数量的参数并简单地将它们传递给标准库的 <code>println!</code> 宏，从而达到打印输出的目的。这是声明式宏的一个基本应用，它们基于规则匹配并在编译时展开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Tip_#21">Tip #21</h2>
<p>在 Rust 中，我们经常使用 <code>Clone()</code> 或 <code>Copy()</code>。这两者之间的区别是什么？</p>
<ul>
<li><p><code>Copy</code>：支持 <code>Copy</code> 的类型可以安全地通过字节复制的方式进行复制，可以类比 C 语言中的 <code>memcpy</code> 函数。</p>
</li>
<li><p><code>Clone</code>：支持 <code>Clone</code> 的类型也可以被复制，但它通常需要执行一些逻辑操作来完成深拷贝。</p>
</li>
</ul>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何将图片编码成base64?]]></title>
    <link href="https://colobu.com/2024/06/06/image-to-base64/"/>
    <id>https://colobu.com/2024/06/06/image-to-base64/</id>
    <published>2024-06-06T15:19:17.000Z</published>
    <updated>2024-08-09T06:26:33.526Z</updated>
    <content type="html"><![CDATA[<p>图片的 base64 编码在多种上下文中都很有用。当需要通过旨在处理文本数据的媒体存储或传输图片时，它通常会被使用，比如嵌入到网页或者通过 API 上传图片。这篇文章将介绍如何使用 Go 标准库得到任何图片的 base64 编码的值。</p>
<a id="more"></a>
<p>在 Go 中将图片转换为其 base64 表示很容易。所有你需要做的是将文件读取为字节 slice并使用包 <code>encoding/base64</code> 对其进行编码。</p>
<h2 id="处理本地图片">处理本地图片</h2>
<p>首先，让我们处理本地文件系统中的图片文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/base64"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> toBase64(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> base64.StdEncoding.EncodeToString(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 读取文件到 byte slice</span></div><div class="line">	bytes, err := ioutil.ReadFile(<span class="string">"./flower.jpg"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> base64Encoding <span class="typename">string</span></div><div class="line"></div><div class="line">	<span class="comment">// 得到当前文件的格式</span></div><div class="line">	mimeType := http.DetectContentType(bytes)</div><div class="line"></div><div class="line">    <span class="comment">// 根据MIME 类型添加适当的 URI 方案头</span></div><div class="line">	<span class="keyword">switch</span> mimeType {</div><div class="line">	<span class="keyword">case</span> <span class="string">"image/jpeg"</span>:</div><div class="line">		base64Encoding += <span class="string">"data:image/jpeg;base64,"</span></div><div class="line">	<span class="keyword">case</span> <span class="string">"image/png"</span>:</div><div class="line">		base64Encoding += <span class="string">"data:image/png;base64,"</span></div><div class="line">	}</div><div class="line"></div><div class="line">    <span class="comment">// 添加 base64 编码的输出</span></div><div class="line">	base64Encoding += toBase64(bytes)</div><div class="line"></div><div class="line">    <span class="comment">// 打印图片的完整 base64 表示</span></div><div class="line">	fmt.Println(base64Encoding)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第一步是通过 <code>ioutil.ReadFile()</code> 将图片文件读取为字节切片。接下来，用于获取 <code>http.DetectContentType()</code> 的 MIME 类型文件，以便将相应的数据 URI 方案标头附加到 base64 编码的输出。之后，调用该函数 <code>toBase64()</code> 它使用 <code>base64.StdEncoding.EncodeToString()</code> 方法检索 图片的 base64 编码。此函数调用的结果将追加到 URI 方案标头。</p>
<p>运行此代码后，它会将图片的 base64 编码打印到提供的标准输出。</p>
<p><img src="1.png" alt=""></p>
<p>您可以复制 base64 字符串并将其直接粘贴到浏览器的地址栏中。它应该显示整个图片，如下所示。<br><img src="2.png" alt=""></p>
<h2 id="处理远程图片">处理远程图片</h2>
<p>将通过URL提供的图片转换为其 base64 编码， 与我们上面已经看到的没有太大区别。您需要做的就是 对图片进行 GET 请求，然后将响应正文读取成字节切片。之后，该过程的其余部分与使用本地图片相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/base64"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> toBase64(b []<span class="typename">byte</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> base64.StdEncoding.EncodeToString(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	resp, err := http.Get(<span class="string">"https://freshman.tech/images/dp-illustration.png"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> resp.Body.Close()</div><div class="line"></div><div class="line">	bytes, err := ioutil.ReadAll(resp.Body)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> base64Encoding <span class="typename">string</span></div><div class="line">	mimeType := http.DetectContentType(bytes)</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> mimeType {</div><div class="line">	<span class="keyword">case</span> <span class="string">"image/jpeg"</span>:</div><div class="line">		base64Encoding += <span class="string">"data:image/jpeg;base64,"</span></div><div class="line">	<span class="keyword">case</span> <span class="string">"image/png"</span>:</div><div class="line">		base64Encoding += <span class="string">"data:image/png;base64,"</span></div><div class="line">	}</div><div class="line"></div><div class="line">	base64Encoding += toBase64(bytes)</div><div class="line">	fmt.Println(base64Encoding)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="3.png" alt=""></p>
<p>本文技术点是通过<code>http.DetectContentType</code>获取图片类型，以及如何编码图片的base4形式。</p>
<p>祝你阅读愉快。</p>
<p>翻译自 <a href="https://freshman.tech/snippets/go/image-to-base64/" target="_blank" rel="external">How to retrieve the base64 encoding for any image in Go</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>图片的 base64 编码在多种上下文中都很有用。当需要通过旨在处理文本数据的媒体存储或传输图片时，它通常会被使用，比如嵌入到网页或者通过 API 上传图片。这篇文章将介绍如何使用 Go 标准库得到任何图片的 base64 编码的值。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust tips #1 ~ #20]]></title>
    <link href="https://colobu.com/2024/06/06/rust-tips-1-20/"/>
    <id>https://colobu.com/2024/06/06/rust-tips-1-20/</id>
    <published>2024-06-06T01:26:42.000Z</published>
    <updated>2024-08-09T06:26:33.770Z</updated>
    <content type="html"><![CDATA[<h2 id="Tip_#001">Tip #001</h2>
<p>Rust 不支持静态 vec(<code>static vec</code>),但是最接近的是静态数组。例如,如果你想存储三个字符串的数组,可以尝试这样: <code>static STRINGS : [&amp;str;3] = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p>
<a id="more"></a>
<h2 id="Tip_#002">Tip #002</h2>
<p>什么是可选值(<code>optional</code>)和 <code>unwrap()</code>? 可以将可选值想象成一个信封,它可以包含一个值(<code>Some(item)</code>)或者什么都没有(<code>None</code>)。对可选值调用 <code>unwrap()</code> 要么返回包含的值,要么如果可选值是 <code>None</code> 的话就会使程序panic。</p>
<h2 id="Tip_#003">Tip #003</h2>
<p>关于可选值( <code>optional</code>)的安全解包方式:</p>
<ul>
<li>使用 <code>match</code> 语句明确处理不同情况</li>
<li><code>unwrap_or_default</code>: 要么解包得到值,要么返回默认值</li>
<li><code>unwrap_or_else</code>: 允许你指定一个函数来处理 <code>None/Error</code> 解包结果</li>
</ul>
<h2 id="Tip_#004">Tip #004</h2>
<p>如果你没有时间完成特定的一段代码,但仍然希望程序可以编译,可以考虑使用 <code>todo!()</code> 或 <code>unimplemented!()</code> 宏。你的代码会继续编译通过,但如果程序运行到包含这些宏的代码块中,它将会panic。</p>
<blockquote>
<p><code>todo!</code> 更适合临时标记,而 <code>unimplemented!</code> 则更适合长期未实现的情况。</p>
</blockquote>
<h2 id="Tip_#005">Tip #005</h2>
<p>如果你想测试一个枚举类型的实例是否符合枚举的特定变体,你可以使用 <code>matches!</code> 宏,例如:<br><code>let match_res = matches!(my_variable, enum_type);</code></p>
<p>你也可以匹配其他模式,如范围,例如: <code>matches!(foo, &#39;A&#39;..=&#39;Z&#39;)</code></p>
<h2 id="Tip_#006">Tip #006</h2>
<p>你知道吗, <code>{}</code> 块可以像函数一样返回结果?这使得基于条件的赋值变得非常容易。例如:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> car_ready = {</div><div class="line">      start_engine();</div><div class="line">      <span class="keyword">match</span> engine_state {</div><div class="line">       Engine::running =&gt; <span class="keyword">true</span>,</div><div class="line">       Engine::error =&gt; <span class="keyword">false</span></div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tip_#007">Tip #007</h2>
<p>const和static之间有什么区别?</p>
<ul>
<li>const值在编译期间会被替换(&quot;内联&quot;)到你的代码中。这对于在代码的各个地方使用的常量值来说是理想的。</li>
<li>static值在运行时有一个内存地址,并且会在整个应用程序的生命周期中存在。它们可以是可变的。如果你需要一个固定的位置来存放共享资源,例如硬件驱动程序或数据库接口,那么静态变量就很有用。</li>
</ul>
<h2 id="Tip_#008">Tip #008</h2>
<p>如果你想将几个相同或不同类型的值一起存储,元组类型就很有用。下面是一个将元组类型声明为结构体元组的示例,访问元组类型字段,以及从函数返回&quot;匿名&quot;元组类型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> MyTuple(String, <span class="keyword">i32</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">flip</span></span>(a: (<span class="keyword">i32</span>, String)) -&gt; MyTuple {</div><div class="line">    <span class="keyword">let</span> my_tuple = MyTuple(String::from(<span class="string">"the answer"</span>), <span class="number">42</span>);</div><div class="line">    (a.<span class="number">1</span>, a.<span class="number">0</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#009">Tips #009</h2>
<p>让我们来谈谈 <code>string</code></p>
<p>在 Rust 中有两种基本的字符串类型: <code>String</code> 和 <code>str</code>。</p>
<p><code>String</code>: (也称为 <code>Owned String</code>),在堆上分配内存并且可变。<code>String</code> 在运行时使用,当你想要创建和修改字符串时。你可以将 <code>String</code> 作为 <code>&amp;str</code> 引用传递给只读函数。</p>
<p><code>str</code>: (也称为 <code>String Slice</code>) 是对一序列 <code>UTF8</code> 数据的引用。你可以在编译时以常量、静态字面量的形式创建 <code>str</code>,或者在运行时从 <code>String</code> 对象获取它们。<code>str</code> 总是不可变的。</p>
<h2 id="Tips_#010">Tips #010</h2>
<p>拼接 <code>string</code> 有两种方式可以将两个字符串连接,分别使用:</p>
<ul>
<li>push_str</li>
<li>format! 宏</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 push_str</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> first = String::from(<span class="string">"Hello, "</span>);</div><div class="line">first.push_str(<span class="string">"world!"</span>);</div><div class="line">assert_eq!(first, <span class="string">"Hello, world!"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 使用 format! 宏</span></div><div class="line"><span class="keyword">let</span> second = String::from(<span class="string">"Hello, "</span>);</div><div class="line"><span class="keyword">let</span> combined = format!(<span class="string">"{}{}"</span>, second, <span class="string">"world!"</span>);</div><div class="line">assert_eq!(combined, <span class="string">"Hello, world!"</span>);</div></pre></td></tr></table></figure>

<h2 id="Tips_#011">Tips #011</h2>
<p>格式化打印宏</p>
<ul>
<li><code>print!</code>、<code>println!</code>: 在控制台打印文本。<br>您可以使用格式字符串打印变量的内容,例如, <code>let a: i32 = 1234; println!(&quot;The value of a is: {}&quot;, a);</code> 将打印出 <code>&quot;The value of a is 1234&quot;</code></li>
<li><code>eprintln!</code>: 打印到标准错误流(<code>stderr</code>)</li>
<li><code>dbg!</code>: 打印变量的值和行号,对于轻量级调试很有用。</li>
</ul>
<h2 id="Tips_#012">Tips #012</h2>
<p>可选值解包使用 <code>if let()</code> 类似于 <code>Swift</code> , Rust 允许我们使用 <code>if let</code> 来测试一个可选值是否有值,这种方式便于保持程序流程的简洁:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> optional_value: Option&lt;<span class="keyword">i32</span>&gt; = Some(<span class="number">9</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 传统方式</span></div><div class="line">    <span class="keyword">match</span> optional_value {</div><div class="line">        Some(value) =&gt; println!(<span class="string">"The value is: {}"</span>, value),</div><div class="line">        None =&gt; println!(<span class="string">"There is no value"</span>),</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 使用 if let</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Some(value) = optional_value {</div><div class="line">        println!(<span class="string">"The value is: {}"</span>, value);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        println!(<span class="string">"There is no value"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#013">Tips #013</h2>
<p>使用 <code>if let</code> 解包多个可选值。继上一条 tip,如果你需要同时检查多个可选值是否都有值,你可以使用 <code>if let</code> 来测试和解包可选值的元组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> optional_tuple: (Option&lt;<span class="keyword">i32</span>&gt;, Option&lt;<span class="keyword">bool</span>&gt;) = (Some(<span class="number">5</span>), Some(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 传统方式</span></div><div class="line">    <span class="keyword">match</span> optional_tuple {</div><div class="line">        (Some(int_value), Some(bool_value)) =&gt; {</div><div class="line">            println!(<span class="string">"Received int: {} and bool: {}"</span>, int_value, bool_value);</div><div class="line">        }</div><div class="line">        <span class="number">_</span> =&gt; println!(<span class="string">"One or more options were None"</span>),</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 使用 if let</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (Some(int_value), Some(bool_value)) = optional_tuple {</div><div class="line">        println!(<span class="string">"Received int: {} and bool: {}"</span>, int_value, bool_value);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        println!(<span class="string">"One or more options were None"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#014">Tips #014</h2>
<p>实例化 <code>vector</code>。<br>Vec是一种动态数组类型,非常适合存储相同数据类型的序列。下面是一些使用标准库调用和vec!宏实例化Vec的方式。注意类型是如何处理的:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type automatically inferred by the next push.</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a: Vec&lt;<span class="keyword">i64</span>&gt; = Vec::new();</div><div class="line">a.push(<span class="number">1_i64</span>);</div><div class="line"></div><div class="line"><span class="comment">// Type set during instantiation.</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> b: Vec&lt;<span class="keyword">i64</span>&gt; = Vec::&lt;<span class="keyword">i64</span>&gt;::new();</div><div class="line"></div><div class="line"><span class="comment">// Type defined explicitly, initialized using vec!</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> c: Vec&lt;<span class="keyword">i64</span>&gt; = vec![];</div><div class="line"></div><div class="line"><span class="comment">// Type automatically inferred, prefilled with vec!</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> d: Vec&lt;<span class="keyword">i64</span>&gt; = vec![<span class="number">1_i64</span>, <span class="number">2_i64</span>, <span class="number">3_i64</span>];</div></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 空Vec</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vec1: Vec&lt;<span class="keyword">i32</span>&gt; = Vec::new();</div><div class="line"></div><div class="line"><span class="comment">// 用值初始化</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vec2 = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">// 用指定数量的元素和默认值初始化</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vec3 = vec![<span class="number">0</span>; <span class="number">5</span>]; <span class="comment">// vec3 = [0, 0, 0, 0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// 从迭代器获取元素</span></div><div class="line"><span class="keyword">let</span> vec4 = (<span class="number">0</span>..<span class="number">5</span>).collect();</div><div class="line"><span class="keyword">let</span> vec5: Vec&lt;<span class="number">_</span>&gt; = [<span class="string">"foo"</span>, <span class="string">"bar"</span>].into_iter().collect();</div><div class="line"></div><div class="line"><span class="comment">// 用给定的初始容量初始化</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vec6 = Vec::with_capacity(<span class="number">10</span>);</div></pre></td></tr></table></figure>

<h2 id="Tip_#015">Tip #015</h2>
<p>Vector迭代。</p>
<p>你可以使用 <code>vec.iter()</code> 来对 Vector进行迭代，使用 <code>map()</code> 或 <code>for_each()</code> 函数，这与例如 JavaScript 中的方式类似。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers: Vec&lt;<span class="keyword">i32</span>&gt; = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="comment">// Using for_each to print each element</span></div><div class="line">numbers.iter().for_each(|&x: <span class="keyword">i32</span>| {</div><div class="line">    println!(<span class="string">"{}"</span>, x);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Use map to transform a vector.</span></div><div class="line"><span class="keyword">let</span> squared: Vec&lt;<span class="keyword">i32</span>&gt; = numbers.iter().map(|&x: <span class="keyword">i32</span>| x * x).collect();</div><div class="line"></div><div class="line">println!(<span class="string">"{:?}"</span>, squared);</div></pre></td></tr></table></figure>

<h2 id="Tips_#016">Tips #016</h2>
<p>嘿,你有一些不错的<code>HashMap</code>,怎么初始化它们?除了创建一个新的<code>HashMap</code>并插入键值对之外,一种值得注意的方式是使用一个元组数组和一个#迭代器:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::collections::HashMap;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 从一个元组数组创建HashMap</span></div><div class="line">    <span class="keyword">let</span> codes: HashMap&lt;<span class="number">_</span>, <span class="number">_</span>&gt; = [</div><div class="line">        (<span class="number">101</span>, <span class="string">"abc"</span>),</div><div class="line">        (<span class="number">102</span>, <span class="string">"def"</span>),</div><div class="line">        (<span class="number">103</span>, <span class="string">"ghi"</span>),</div><div class="line">    ].iter().cloned().collect();</div><div class="line"></div><div class="line">    println!(<span class="string">"codes = {:?}"</span>, codes);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#017">Tips #017</h2>
<p>更好的方式来<code>unwrap()</code><br>如果内容是<code>None</code>的话,<code>unwrap()</code>一个可选值会导致panic。以下是在<code>unwrap</code>时处理None的一些方法:</p>
<ul>
<li>unwrap_or_default(): 如果可选值是None,返回默认值。</li>
<li>unwrap_or(): 提供一个替代值。<br>-unwrap_or_else(): 执行一个函数,如果可选值是None的话该函数返回某个值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> x: Option&lt;<span class="keyword">i32</span>&gt; = None;</div><div class="line"></div><div class="line">    <span class="comment">// 返回默认值0</span></div><div class="line">    println!(<span class="string">"{}"</span>, x.unwrap_or_default()); </div><div class="line"></div><div class="line">    <span class="comment">// 返回提供的替代值99</span></div><div class="line">    println!(<span class="string">"{}"</span>, x.unwrap_or(<span class="number">99</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 返回函数提供的值</span></div><div class="line">    println!(<span class="string">"{}"</span>, x.unwrap_or_else(|| <span class="string">"No value"</span>.to_string()));</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#018">Tips #018</h2>
<p>Rust 允许我们轻松定义匿名函数(也称为<code>lambda</code> 或 <code>closure</code> 或闭包)。闭包通常与 <code>iterator</code> 一起使用,或者用于定义回调函数。以下是语法示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> multiply = |a, b| a * b;</div><div class="line">    <span class="keyword">let</span> product = multiply(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line">    println!(<span class="string">"Product: {}"</span>, product); <span class="comment">// 输出: Product: 12</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> add_two = |x| x + <span class="number">2</span>;</div><div class="line">    <span class="keyword">let</span> values = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">    <span class="keyword">let</span> new_values: Vec&lt;<span class="number">_</span>&gt; = values.iter().map(add_two).collect();</div><div class="line">    println!(<span class="string">"New values: {:?}"</span>, new_values); <span class="comment">// 输出: New values: [3, 4, 5, 6, 7]</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#019">Tips #019</h2>
<p>在<strong>闭包</strong>中使用 <code>move</code> 可以从周围作用域捕获变量。这意味着闭包将获取这些变量的<strong>所有权</strong>,而无需传递任何参数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> num = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> closure = || {</div><div class="line">        println!(<span class="string">"Num: {}"</span>, num); <span class="comment">// 错误: `num` 不可借用</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> closure_move = move || {</div><div class="line">        println!(<span class="string">"Num: {}"</span>, num); <span class="comment">// 正确: `num` 被移动到闭包中</span></div><div class="line">    };</div><div class="line"></div><div class="line">    closure(); <span class="comment">// 调用没有捕获变量的闭包</span></div><div class="line">    closure_move(); <span class="comment">// 调用捕获了 `num` 的闭包</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tips_#020">Tips #020</h2>
<p>实现 <code>From()</code> trait 提供了一种在复杂类型之间进行转换的机制。Rust 还会自动为对应的类型提供一个 <code>Into()</code> 实现。在下面的示例中,我们为 <code>ColorFloat</code> 实现了 <code>From</code>,但是可以使用 <code>Color8Bit</code> 的 <code>Into()</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Color8Bit {</div><div class="line">    r: <span class="keyword">u8</span>,</div><div class="line">    g: <span class="keyword">u8</span>, </div><div class="line">    b: <span class="keyword">u8</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ColorFloat {</div><div class="line">    r: <span class="keyword">f32</span>,</div><div class="line">    g: <span class="keyword">f32</span>,</div><div class="line">    b: <span class="keyword">f32</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span> From&lt;Color8Bit&gt; <span class="keyword">for</span> ColorFloat {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(color: Color8Bit) -&gt; Self {</div><div class="line">        ColorFloat {</div><div class="line">            r: (color.r <span class="keyword">as</span> <span class="keyword">f32</span>) / <span class="number">255.0</span>,</div><div class="line">            g: (color.g <span class="keyword">as</span> <span class="keyword">f32</span>) / <span class="number">255.0</span>,</div><div class="line">            b: (color.b <span class="keyword">as</span> <span class="keyword">f32</span>) / <span class="number">255.0</span>,</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> color8 = Color8Bit { r: <span class="number">230</span>, g: <span class="number">100</span>, b: <span class="number">50</span> };</div><div class="line">    </div><div class="line">    <span class="comment">// 使用 Into 特性将 Color8Bit 转换为 ColorFloat</span></div><div class="line">    <span class="keyword">let</span> color_float: ColorFloat = color8.into();</div><div class="line">    </div><div class="line">    println!(<span class="string">"Color Float: {}, {}, {}"</span>, color_float.r, color_float.g, color_float.b);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整理自 Daily Rust @rustoftheday</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Tip_#001">Tip #001</h2>
<p>Rust 不支持静态 vec(<code>static vec</code>),但是最接近的是静态数组。例如,如果你想存储三个字符串的数组,可以尝试这样: <code>static STRINGS : [&amp;str;3] = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redka - 父亲是Redis，母亲是SQLite]]></title>
    <link href="https://colobu.com/2024/06/04/redka-redis-with-sqlite/"/>
    <id>https://colobu.com/2024/06/04/redka-redis-with-sqlite/</id>
    <published>2024-06-03T23:28:39.000Z</published>
    <updated>2024-08-09T06:26:33.743Z</updated>
    <content type="html"><![CDATA[<p>Redka旨在使用SQLite重新实现Redis的优秀部分,同时保持与Redis API的兼容性。</p>
<p>有意思的特性:</p>
<ul>
<li>数据不必完全装载在内存中。</li>
<li>支持ACID事务。</li>
<li>使用SQL视图以便于内省和报告。</li>
<li>同时提供进程内(Go API)和独立(RESP)服务器。</li>
<li>兼容Redis的命令和线路协议。</li>
</ul>
<p>Redia 并不期望完全达到 Redis 那么高的性能，但是性能上也并不会落后很多。它的主要功能还是 SQL + Redis 的功能，集成了两种优秀产品 SQLite 和 Redis 的盛世美颜。</p>
<a id="more"></a>
<h2 id="支持的_Redis_命令">支持的 Redis 命令</h2>
<h3 id="字符串">字符串</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Command      Go API                 Description</div><div class="line"><span class="comment">-------      ------                 -----------</span></div><div class="line">DECR         DB.Str().Incr          Decrements <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="constant">one</span>.</div><div class="line">DECRBY       DB.Str().Incr          Decrements <span class="operator">a</span> <span class="built_in">number</span> <span class="built_in">from</span> <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">GET          DB.Str().Get           Returns <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">GETSET       DB.Str().SetWith       Sets <span class="operator">the</span> key <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">new</span> <span class="built_in">value</span> <span class="operator">and</span> returns <span class="operator">the</span> prev <span class="built_in">value</span>.</div><div class="line">INCR         DB.Str().Incr          Increments <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="constant">one</span>.</div><div class="line">INCRBY       DB.Str().Incr          Increments <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="operator">a</span> <span class="built_in">number</span>.</div><div class="line">INCRBYFLOAT  DB.Str().IncrFloat     Increments <span class="operator">the</span> float <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="operator">a</span> <span class="built_in">number</span>.</div><div class="line">MGET         DB.Str().GetMany       Returns <span class="operator">the</span> values <span class="operator">of</span> <span class="constant">one</span> <span class="operator">or</span> more <span class="built_in">keys</span>.</div><div class="line">MSET         DB.Str().SetMany       Sets <span class="operator">the</span> values <span class="operator">of</span> <span class="constant">one</span> <span class="operator">or</span> more <span class="built_in">keys</span>.</div><div class="line">PSETEX       DB.Str().SetExpires    Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">and</span> expiration <span class="built_in">time</span> (<span class="operator">in</span> ms) <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">SET          DB.Str().Set           Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">SETEX        DB.Str().SetExpires    Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">and</span> expiration (<span class="operator">in</span> <span class="built_in">sec</span>) <span class="built_in">time</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">SETNX        DB.Str().SetWith       Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key when <span class="operator">the</span> key doesn<span class="string">'t exist.</span></div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">APPEND</span>  GETDEL  GETEX  GETRANGE  LCS  MSETNX  SETRANGE  STRLEN  SUBSTR</div></pre></td></tr></table></figure>

<h3 id="列表">列表</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Command      Go API                      Description</div><div class="line"><span class="comment">-------      ------                      -----------</span></div><div class="line">LINDEX       DB.List().Get               Returns <span class="operator">an</span> <span class="keyword">element</span> <span class="keyword">by</span> its index.</div><div class="line">LINSERT      DB.List().Insert*           Inserts <span class="operator">an</span> <span class="keyword">element</span> <span class="keyword">before</span> <span class="operator">or</span> <span class="keyword">after</span> another <span class="keyword">element</span>.</div><div class="line">LLEN         DB.List().Len               Returns <span class="operator">the</span> <span class="built_in">length</span> <span class="operator">of</span> <span class="operator">a</span> list.</div><div class="line">LPOP         DB.List().PopFront          Returns <span class="operator">the</span> <span class="keyword">first</span> <span class="keyword">element</span> <span class="keyword">after</span> removing <span class="keyword">it</span>.</div><div class="line">LPUSH        DB.List().PushFront         Prepends <span class="operator">an</span> <span class="keyword">element</span> <span class="built_in">to</span> <span class="operator">a</span> list.</div><div class="line">LRANGE       DB.List().Range             Returns <span class="operator">a</span> range <span class="operator">of</span> elements.</div><div class="line">LREM         DB.List().Delete*           Removes elements <span class="built_in">from</span> <span class="operator">a</span> list.</div><div class="line">LSET         DB.List().Set               Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">an</span> <span class="keyword">element</span> <span class="keyword">by</span> its index.</div><div class="line">LTRIM        DB.List().Trim              Removes elements <span class="built_in">from</span> both <span class="operator">ends</span> <span class="operator">a</span> list.</div><div class="line">RPOP         DB.List().PopBack           Returns <span class="operator">the</span> <span class="keyword">last</span> <span class="keyword">element</span> <span class="keyword">after</span> removing <span class="keyword">it</span>.</div><div class="line">RPOPLPUSH    DB.List().PopBackPushFront  Removes <span class="operator">the</span> <span class="keyword">last</span> <span class="keyword">element</span> <span class="operator">and</span> pushes <span class="keyword">it</span> <span class="built_in">to</span> another list.</div><div class="line">RPUSH        DB.List().PushBack          Appends <span class="operator">an</span> <span class="keyword">element</span> <span class="built_in">to</span> <span class="operator">a</span> list.</div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">BLMOVE</span>  BLMPOP  BLPOP  BRPOP  BRPOPLPUSH  LMOVE  LMPOP</div><div class="line">LPOS  LPUSHX  RPUSHX</div></pre></td></tr></table></figure>

<h3 id="Set">Set</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Command      Go API                 Description</div><div class="line"><span class="comment">-------      ------                 -----------</span></div><div class="line">SADD         DB.Set().Add           Adds one or more members to a <span class="operator"><span class="keyword">set</span>.</span></div><div class="line">SCARD        DB.<span class="keyword">Set</span>().<span class="keyword">Len</span>           <span class="keyword">Returns</span> the <span class="built_in">number</span> <span class="keyword">of</span> members <span class="keyword">in</span> a <span class="keyword">set</span>.</div><div class="line">SDIFF        DB.<span class="keyword">Set</span>().Diff          <span class="keyword">Returns</span> the <span class="keyword">difference</span> <span class="keyword">of</span> multiple sets.</div><div class="line">SDIFFSTORE   DB.<span class="keyword">Set</span>().DiffStore     Stores the <span class="keyword">difference</span> <span class="keyword">of</span> multiple sets.</div><div class="line">SINTER       DB.<span class="keyword">Set</span>().Inter         <span class="keyword">Returns</span> the intersection <span class="keyword">of</span> multiple sets.</div><div class="line">SINTERSTORE  DB.<span class="keyword">Set</span>().InterStore    Stores the intersection <span class="keyword">of</span> multiple sets.</div><div class="line">SISMEMBER    DB.<span class="keyword">Set</span>().<span class="keyword">Exists</span>        Determines whether a member belongs <span class="keyword">to</span> a <span class="keyword">set</span>.</div><div class="line">SMEMBERS     DB.<span class="keyword">Set</span>().Items         <span class="keyword">Returns</span> <span class="keyword">all</span> members <span class="keyword">of</span> a <span class="keyword">set</span>.</div><div class="line">SMOVE        DB.<span class="keyword">Set</span>().Move          Moves a member <span class="keyword">from</span> one <span class="keyword">set</span> <span class="keyword">to</span> another.</div><div class="line">SPOP         DB.<span class="keyword">Set</span>().Pop           <span class="keyword">Returns</span> a random member <span class="keyword">after</span> removing it.</div><div class="line">SRANDMEMBER  DB.<span class="keyword">Set</span>().Random        <span class="keyword">Returns</span> a random member <span class="keyword">from</span> a <span class="keyword">set</span>.</div><div class="line">SREM         DB.<span class="keyword">Set</span>().<span class="keyword">Delete</span>        Removes one <span class="keyword">or</span> more members <span class="keyword">from</span> a <span class="keyword">set</span>.</div><div class="line">SSCAN        DB.<span class="keyword">Set</span>().Scanner       Iterates over members <span class="keyword">of</span> a <span class="keyword">set</span>.</div><div class="line">SUNION       DB.<span class="keyword">Set</span>().<span class="keyword">Union</span>         <span class="keyword">Returns</span> the <span class="keyword">union</span> <span class="keyword">of</span> multiple sets.</div><div class="line">SUNIONSTORE  DB.<span class="keyword">Set</span>().UnionStore    Stores the <span class="keyword">union</span> <span class="keyword">of</span> multiple sets.</div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">SINTERCARD</span>  SMISMEMBER</div></pre></td></tr></table></figure>

<h3 id="Hash">Hash</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="variable">Command</span>       <span class="variable">Go</span> <span class="variable">API</span>                  <span class="variable">Description</span></div><div class="line"><span class="pp">-------       ------------------      -----------</span></div><div class="line">HDEL          DB.<span class="variable">Hash</span>().<span class="variable">Delete</span>        <span class="variable">Deletes</span> one or more fields <span class="keyword">and</span> their values.</div><div class="line"><span class="variable">HEXISTS</span>       <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Exists</span>        <span class="variable">Determines</span> whether a field exists.</div><div class="line"><span class="variable">HGET</span>          <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Get</span>           <span class="variable">Returns</span> the value <span class="keyword">of</span> a field.</div><div class="line"><span class="variable">HGETALL</span>       <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Items</span>         <span class="variable">Returns</span> all fields <span class="keyword">and</span> values.</div><div class="line"><span class="variable">HINCRBY</span>       <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Incr</span>          <span class="variable">Increments</span> the integer value <span class="keyword">of</span> a field.</div><div class="line"><span class="variable">HINCRBYFLOAT</span>  <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">IncrFloat</span>     <span class="variable">Increments</span> the float value <span class="keyword">of</span> a field.</div><div class="line"><span class="variable">HKEYS</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Keys</span>          <span class="variable">Returns</span> all fields.</div><div class="line"><span class="variable">HLEN</span>          <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Len</span>           <span class="variable">Returns</span> the number <span class="keyword">of</span> fields.</div><div class="line"><span class="variable">HMGET</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">GetMany</span>       <span class="variable">Returns</span> the values <span class="keyword">of</span> multiple fields.</div><div class="line"><span class="variable">HMSET</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">SetMany</span>       <span class="variable">Sets</span> the values <span class="keyword">of</span> multiple fields.</div><div class="line"><span class="variable">HSCAN</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Scanner</span>       <span class="variable">Iterates</span> over fields <span class="keyword">and</span> values.</div><div class="line"><span class="variable">HSET</span>          <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">SetMany</span>       <span class="variable">Sets</span> the values <span class="keyword">of</span> one or more fields.</div><div class="line"><span class="variable">HSETNX</span>        <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">SetNotExists</span>  <span class="variable">Sets</span> the value <span class="keyword">of</span> a field <span class="keyword">when</span> it doesn't exist.</div><div class="line"><span class="variable">HVALS</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Exists</span>        <span class="variable">Returns</span> all values.</div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">HRANDFIELD</span>  HSTRLEN</div></pre></td></tr></table></figure>

<h3 id="Sorted_Set">Sorted Set</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Command           Go API                  Description</div><div class="line"><span class="comment">-------           ------                  -----------</span></div><div class="line">ZADD              DB.ZSet().AddMany       Adds <span class="operator">or</span> updates <span class="constant">one</span> <span class="operator">or</span> more members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZCARD             DB.ZSet().Len           Returns <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> members <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZCOUNT            DB.ZSet().Count         Returns <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores.</div><div class="line">ZINCRBY           DB.ZSet().Incr          Increments <span class="operator">the</span> score <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZINTER            DB.ZSet().InterWith     Returns <span class="operator">the</span> intersection <span class="operator">of</span> multiple sets.</div><div class="line">ZINTERSTORE       DB.ZSet().InterWith     Stores <span class="operator">the</span> intersection <span class="operator">of</span> multiple sets <span class="operator">in</span> <span class="operator">a</span> key.</div><div class="line">ZRANGE            DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> indexes.</div><div class="line">ZRANGEBYSCORE     DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores.</div><div class="line">ZRANK             DB.ZSet().GetRank       Returns <span class="operator">the</span> index <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span> ordered <span class="keyword">by</span> <span class="keyword">ascending</span> scores.</div><div class="line">ZREM              DB.ZSet().Delete        Removes <span class="constant">one</span> <span class="operator">or</span> more members <span class="built_in">from</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZREMRANGEBYRANK   DB.ZSet().DeleteWith    Removes members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> indexes.</div><div class="line">ZREMRANGEBYSCORE  DB.ZSet().DeleteWith    Removes members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores.</div><div class="line">ZREVRANGE         DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> indexes <span class="operator">in</span> reverse order.</div><div class="line">ZREVRANGEBYSCORE  DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores <span class="operator">in</span> reverse order.</div><div class="line">ZREVRANK          DB.ZSet().GetRankRev    Returns <span class="operator">the</span> index <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span> ordered <span class="keyword">by</span> <span class="keyword">descending</span> scores.</div><div class="line">ZSCAN             DB.ZSet().Scan          Iterates over members <span class="operator">and</span> scores <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZSCORE            DB.ZSet().GetScore      Returns <span class="operator">the</span> score <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZUNION            DB.ZSet().UnionWith     Returns <span class="operator">the</span> <span class="built_in">union</span> <span class="operator">of</span> multiple sets.</div><div class="line">ZUNIONSTORE       DB.ZSet().UnionWith     Stores <span class="operator">the</span> <span class="built_in">union</span> <span class="operator">of</span> multiple sets <span class="operator">in</span> <span class="operator">a</span> key.</div></pre></td></tr></table></figure>

<p>不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">BZMPOP</span>  BZPOPMAX  BZPOPMIN  ZDIFF  ZDIFFSTORE  ZINTERCARD</div><div class="line">ZLEXCOUNT  ZMPOP  ZMSCORE  ZPOPMAX  ZPOPMIN  ZRANDMEMBER</div><div class="line">ZRANGEBYLEX  ZRANGESTORE  ZREMRANGEBYLEX  ZREVRANGEBYLEX</div></pre></td></tr></table></figure>

<h3 id="Key">Key</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Command    Go API                    Description</div><div class="line">-------    ------                    -----------</div><div class="line">DBSIZE     DB.<span class="keyword">Key</span>().Len              Returns the total number <span class="keyword">of</span> keys.</div><div class="line">DEL        DB.<span class="keyword">Key</span>().Delete           Deletes one <span class="keyword">or</span> more keys.</div><div class="line">EXISTS     DB.<span class="keyword">Key</span>().Count            Determines whether one <span class="keyword">or</span> more keys exist.</div><div class="line">EXPIRE     DB.<span class="keyword">Key</span>().Expire           Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> (<span class="keyword">in</span> seconds).</div><div class="line">EXPIREAT   DB.<span class="keyword">Key</span>().ExpireAt         Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> <span class="keyword">to</span> a Unix timestamp.</div><div class="line">FLUSHDB    DB.<span class="keyword">Key</span>().DeleteAll        Deletes all keys <span class="keyword">from</span> the database.</div><div class="line">KEYS       DB.<span class="keyword">Key</span>().Keys             Returns all <span class="keyword">key</span> names that match a pattern.</div><div class="line">PERSIST    DB.<span class="keyword">Key</span>().Persist          Removes the expiration time <span class="keyword">of</span> a <span class="keyword">key</span>.</div><div class="line">PEXPIRE    DB.<span class="keyword">Key</span>().Expire           Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> <span class="keyword">in</span> ms.</div><div class="line">PEXPIREAT  DB.<span class="keyword">Key</span>().ExpireAt         Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> <span class="keyword">to</span> a Unix ms timestamp.</div><div class="line">RANDOMKEY  DB.<span class="keyword">Key</span>().Random           Returns a random <span class="keyword">key</span> name <span class="keyword">from</span> the database.</div><div class="line">RENAME     DB.<span class="keyword">Key</span>().Rename           Renames a <span class="keyword">key</span> <span class="keyword">and</span> overwrites the destination.</div><div class="line">RENAMENX   DB.<span class="keyword">Key</span>().RenameNotExists  Renames a <span class="keyword">key</span> only <span class="keyword">when</span> the target <span class="keyword">key</span> name doesn<span class="comment">'t exist.</span></div><div class="line">SCAN       DB.<span class="keyword">Key</span>().Scanner          Iterates over the <span class="keyword">key</span> names <span class="keyword">in</span> the database.</div><div class="line">TTL        DB.<span class="keyword">Key</span>().<span class="keyword">Get</span>              Returns the expiration time <span class="keyword">in</span> seconds <span class="keyword">of</span> a <span class="keyword">key</span>.</div><div class="line">TYPE       DB.<span class="keyword">Key</span>().<span class="keyword">Get</span>              Returns the type <span class="keyword">of</span> value stored at a <span class="keyword">key</span>.</div></pre></td></tr></table></figure>

<p>不支持的命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span>  <span class="keyword">DUMP</span>  EXPIRETIME  MIGRATE  MOVE  OBJECT  PEXPIRETIME</div><div class="line">PTTL  RESTORE  <span class="keyword">SORT</span>  SORT_RO  TOUCH  TTL  TYPE  UNLINK</div><div class="line">WAIT  WAITAOF</div></pre></td></tr></table></figure>

<h3 id="事务">事务</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Command    Go API                 Description</div><div class="line">-------    ------                 -----------</div><div class="line">DISCARD    <span class="pseudo">DB</span>.View / <span class="pseudo">DB</span>.Update    Discards a transaction.</div><div class="line">EXEC       <span class="pseudo">DB</span>.View / <span class="pseudo">DB</span>.Update    Executes all commands <span class="keyword">in</span> a transaction.</div><div class="line">MULTI      <span class="pseudo">DB</span>.View / <span class="pseudo">DB</span>.Update    Starts a transaction.</div></pre></td></tr></table></figure>

<p>与 Redis 不同，Redka 的事务完全符合 ACID 属性，在发生故障时会自动回滚。</p>
<p>不支持的命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">UNWATCH</span>  WATCH</div></pre></td></tr></table></figure>

<h3 id="连接管理">连接管理</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Command    Go API                Description</div><div class="line"><span class="comment">-------    ------                -----------</span></div><div class="line">ECHO       -                     Returns <span class="operator">the</span> given <span class="keyword">string</span>.</div><div class="line">PING       -                     Returns <span class="operator">the</span> server<span class="string">'s liveliness response.</span></div></pre></td></tr></table></figure>

<h2 id="安装">安装</h2>
<p>你可以以独立的服务的形式安装。官方文档提供了方便的 Linux、macOS 的安装脚本，你也可以使用 docker 进行部署。</p>
<p>也可以在你的 Go 程序中当成一个库引用: <code>go get github.com/nalgeon/redka</code>，当然了你也必须引入 sqlite 的库，比如 <code>github.com/mattn/go-sqlite3</code> 或者 <code>modernc.org/sqlite</code>。</p>
<h2 id="运行">运行</h2>
<p>你可以使用 <code>redka [-h host] [-p port] [db-path]</code> 启动一个 redka 服务，比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./redka</div><div class="line">./redka data.db</div><div class="line">./redka -h <span class="number">0.0</span>.<span class="number">0.0</span> -p <span class="number">6379</span> data.db</div></pre></td></tr></table></figure>

<p>如果没有指定数据库文件，那么它就完全使用内存的方式。</p>
<p>如果当成一个库引入使用，你可以像这样在进程内使用:\</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"log"</span></div><div class="line"></div><div class="line">    _ <span class="string">"github.com/mattn/go-sqlite3"</span></div><div class="line">    <span class="string">"github.com/nalgeon/redka"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// Open or create the data.db file.</span></div><div class="line">    db, err := redka.Open(<span class="string">"data.db"</span>, <span class="constant">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line">    <span class="comment">// Always close the database when you are finished.</span></div><div class="line">    <span class="keyword">defer</span> db.Close()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果是使用内存的方式，可以指定 sqlite 使用内存的方式打开:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// All data is lost when the database is closed.</div><div class="line">redka.Open(<span class="string">"file:redka?mode=memory&cache=shared"</span>)</div></pre></td></tr></table></figure>

<p>然后代码中就可以直接调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">db.Str().Set(<span class="string">"name"</span>, <span class="string">"alice"</span>)</div><div class="line">db.Str().Set(<span class="string">"age"</span>,<span class="number"> 25</span>)</div><div class="line"></div><div class="line">count, err := db.Key().Count(<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"city"</span>)</div><div class="line">slog.Info(<span class="string">"count"</span>, <span class="string">"count"</span>, count, <span class="string">"err"</span>, err)</div><div class="line"></div><div class="line">name, err := db.Str().Get(<span class="string">"name"</span>)</div><div class="line">slog.Info(<span class="string">"get"</span>, <span class="string">"name"</span>, name, <span class="string">"err"</span>, err)</div></pre></td></tr></table></figure>

<p>下面的代码是使用事务的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">updCount :=<span class="number"> 0</span></div><div class="line">err := db.Update(<span class="keyword">func</span>(tx *redka.Tx) error {</div><div class="line">    err := tx.Str().Set(<span class="string">"name"</span>, <span class="string">"bob"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line">    updCount++</div><div class="line"></div><div class="line">    err = tx.Str().Set(<span class="string">"age"</span>,<span class="number"> 50</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line">    updCount++</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">})</div><div class="line">slog.Info(<span class="string">"updated"</span>, <span class="string">"count"</span>, updCount, <span class="string">"err"</span>, err)</div></pre></td></tr></table></figure>

<h2 id="性能">性能</h2>
<p>作者在 Apple M1 8-core CPU, 16GB RAM 的苹果机器和 Redis 进行了性能比较。<br>使用下面的场景进行比较(<code>redis-benchmark -p 6379 -q -c 10 -n 1000000 -r 10000 -t get,set</code>)：</p>
<ul>
<li>10 parallel connections</li>
<li>1000000 requests</li>
<li>10000 randomized keys</li>
<li>GET/SET commands</li>
</ul>
<p>比 Redis 慢 2~5 倍，这也合理，毕竟底层采用一个关系数据库进行存储。</p>
<h2 id="给我们的启发">给我们的启发</h2>
<p>Redka 使用 redcon 进行 Redis 命令的解析，然后针对每种大类的 Redis 命令，会有一个单独的表进行存储。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">rkey</div><div class="line"><span class="comment">---</span></div><div class="line">id       <span class="keyword">integer</span> primary key</div><div class="line">key      <span class="keyword">text</span> <span class="operator">not</span> <span class="constant">null</span></div><div class="line">type     <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- 1 string, 2 list, 3 set, 4 hash, 5 sorted set</span></div><div class="line"><span class="built_in">version</span>  <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- incremented when the key value is updated</span></div><div class="line">etime    <span class="keyword">integer</span>             <span class="comment">-- expiration timestamp in unix milliseconds</span></div><div class="line">mtime    <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- modification timestamp in unix milliseconds</span></div><div class="line"><span class="built_in">len</span>      <span class="keyword">integer</span>             <span class="comment">-- number of child elements</span></div><div class="line"></div><div class="line">rstring</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line"><span class="built_in">value</span>    blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rlist</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">pos      real <span class="operator">not</span> <span class="constant">null</span>       <span class="comment">-- is used for ordering, but is not an index</span></div><div class="line">elem     blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rset</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">elem     blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rhash</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">field    <span class="keyword">text</span> <span class="operator">not</span> <span class="constant">null</span></div><div class="line"><span class="built_in">value</span>    blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rzset</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">elem     blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line">score    real <span class="operator">not</span> <span class="constant">null</span></div></pre></td></tr></table></figure>

<p>既然它支持 sqlite, 我们可以把它 port 到其它的数据库上，比如 clickhouse，这样我们就可以支持巨量的数据了。</p>
<p>当然更深一步，我们还可以接入其他的 NoSQL 数据库，比如 RocksDB 等，类似的项目都有很多了。</p>
<p>这是一个很有意思的项目。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redka旨在使用SQLite重新实现Redis的优秀部分,同时保持与Redis API的兼容性。</p>
<p>有意思的特性:</p>
<ul>
<li>数据不必完全装载在内存中。</li>
<li>支持ACID事务。</li>
<li>使用SQL视图以便于内省和报告。</li>
<li>同时提供进程内(Go API)和独立(RESP)服务器。</li>
<li>兼容Redis的命令和线路协议。</li>
</ul>
<p>Redia 并不期望完全达到 Redis 那么高的性能，但是性能上也并不会落后很多。它的主要功能还是 SQL + Redis 的功能，集成了两种优秀产品 SQLite 和 Redis 的盛世美颜。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[命令分发模式]]></title>
    <link href="https://colobu.com/2024/06/03/command-dispacher-pattern/"/>
    <id>https://colobu.com/2024/06/03/command-dispacher-pattern/</id>
    <published>2024-06-02T23:53:37.000Z</published>
    <updated>2024-08-09T06:26:33.187Z</updated>
    <content type="html"><![CDATA[<p>命令分发模式 (command dispatcher pattern)不属于23种经典的设计模式。它是一种不太为人所知的设计模式,它主要用于构建可扩展、可插拔的系统架构,将请求与执行请求的操作对象解耦。它类似于命令模式(Command Pattern),但更加灵活和动态。</p>
<p>虽然Command Dispatch Pattern不属于那23种经典模式,但它确实是一种很有价值的模式,可以应用于需要在运行时动态添加、修改或删除操作的系统中,使系统更加灵活和可扩展。</p>
<p>这种模式通过允许方便的添加、替换或移除任何命令处理器, 非常的灵活，将命令调用和命令处理解耦。而且每个命令可以由单独的命令处理器处理，代码组织和维护也很方便。</p>
<p>实际上，对于 Gopher 来讲，必然已经接触到这个模式了，只不过少有人指出或者梳理这种模式，但是在标准库和一些知名的项目中，其实已经自然的应用了，而且看起来整个架构也非常的清爽。</p>
<a id="more"></a>
<p>让我们看一个标准库实现 web 服务的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义 HTTP 处理程序函数</span></div><div class="line"><span class="keyword">func</span> homeHandler(w http.ResponseWriter, r *http.Request) {</div><div class="line">	fmt.Fprint(w, <span class="string">"Welcome to the home page!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> aboutHandler(w http.ResponseWriter, r *http.Request) {</div><div class="line">	fmt.Fprint(w, <span class="string">"This is the about page."</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 创建一个新的 ServeMux 实例</span></div><div class="line">	mux := http.NewServeMux()</div><div class="line"></div><div class="line">	<span class="comment">// 注册处理程序函数</span></div><div class="line">	mux.HandleFunc(<span class="string">"/"</span>, homeHandler)</div><div class="line">	mux.HandleFunc(<span class="string">"/about"</span>, aboutHandler)</div><div class="line"></div><div class="line">	<span class="comment">// 启动 HTTP 服务器</span></div><div class="line">	fmt.Println(<span class="string">"Starting server at :8080"</span>)</div><div class="line">	http.ListenAndServe(<span class="string">":8080"</span>, mux)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们可以把 <code>http.ServeMux</code> 看作是 <strong>Command Dispatcher</strong>,而 HTTP 请求就是一个命令。</p>
<p>通过 <code>mux.HandleFunc</code> ，将命令 (path，请求路径) 与命令处理程序  (handler, 处理程序函数) 进行绑定的过程。</p>
<p>新增一个命令，就注册一个新的处理程序。<br>移除一条命令，就删除那一条绑定语句。<br>修改一条命令，就替换对应的处理程序。</p>
<p>Http server 收到 HTTP 请求后，解析出路径信息，然后从注册的信息中找到这个路径对应的处理程序，然后调用这个处理程序。</p>
<p>这是一个经典的命令分发模式的应用。对于贝尔实验室出来的 Rob Pike、Russ Cox 来说，它们和 GoF 设计模式的这一派属于两个门派，所以在 Go 语言中 Rob Pike、Russ Cox 很少会讲到面向对象的设计模式，但是这种 HTTP 的这种实现方法我们可以把它归类为命令分发模式，而且是一个标准的模式实现。</p>
<p>接下来，我再给你介绍几种知名项目中使用这种模式的例子。毕竟，这种设计模式应用的场景之一就是微服务：</p>
<ul>
<li><strong>分布式系统</strong>：在分布式系统中，命令分发模式可以用于将命令分配到不同的服务或节点进行处理。</li>
<li><strong>微服务架构</strong>：在微服务架构中，命令分发模式可以用于协调不同微服务之间的命令处理。</li>
<li><strong>复杂应用</strong>：在复杂应用中，命令分发模式可以用于解耦命令的发出者和处理者，提高系统的灵活性和可维护性。</li>
</ul>
<h2 id="Rpc_中处理">Rpc 中处理</h2>
<p>Go 生态圈中知名的微服务框架之一 <a href="https://rpcx.io" target="_blank" rel="external">rpcx</a> 实现了两种命令分发方式：</p>
<ul>
<li>类似 Go 标准库的 rpc, 通过发射的方式找到对应的微服务方法，然后调用</li>
<li>第二种是类似 Go 标准库这种路由绑定的方法，通过绑定 handler 方式</li>
</ul>
<p>这两种方式都属于命令分发的设计模式，但是第二种更直观。比如下面一个微服务的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/server"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"server address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> mul(ctx *server.Context) error {</div><div class="line">	<span class="keyword">var</span> args example.Args</div><div class="line">	err := ctx.Bind(&args)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> reply example.Reply</div><div class="line">	reply.C = args.A * args.B</div><div class="line"></div><div class="line">	ctx.Write(reply)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line"></div><div class="line">	s.AddHandler(<span class="string">"Arith"</span>, <span class="string">"Mul"</span>, mul)</div><div class="line"></div><div class="line">	err := s.Serve(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里例子以一个 <code>乘法</code> 的微服务做例子。函数 <code>mul</code> 是命令(微服务)处理函数。<code>s.AddHandler</code> 将微服务和命令处理函数进行绑定。这和 HTTP 的例子非常的类似。</p>
<p><code>server</code> 就是一个分发器，它收到客户端的微服务请求，解析出微服务的名称 (名字和方法名)，找到注册的 handler, 把参数传给 handler 去处理。</p>
<p>lesismal 实现的一个高性能的 Go 微服务框架 <a href="https://github.com/lesismal/arpc" target="_blank" rel="external">arpc</a> 也是采用的这种方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/lesismal/arpc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	svr := arpc.NewServer()</div><div class="line"></div><div class="line">	<span class="comment">// register router</span></div><div class="line">	svr.Handler.Handle(<span class="string">"/echo/sync"</span>, <span class="keyword">func</span>(ctx *arpc.Context) {</div><div class="line">		str := <span class="string">""</span></div><div class="line">		err := ctx.Bind(&str)</div><div class="line">		ctx.Write(str)</div><div class="line">		log.Printf(<span class="string">"/echo/sync: \"%v\", error: %v"</span>, str, err)</div><div class="line">	})</div><div class="line"></div><div class="line">	<span class="comment">// register router</span></div><div class="line">	svr.Handler.Handle(<span class="string">"/echo/async"</span>, <span class="keyword">func</span>(ctx *arpc.Context) {</div><div class="line">		str := <span class="string">""</span></div><div class="line">		err := ctx.Bind(&str)</div><div class="line">		<span class="keyword">go</span> ctx.Write(str)</div><div class="line">		log.Printf(<span class="string">"/echo/async: \"%v\", error: %v"</span>, str, err)</div><div class="line">	})</div><div class="line"></div><div class="line">	svr.Run(<span class="string">"localhost:8888"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理微服务、web 路由等这些场景。在基础架构的软件开发中，这种模式对于实现命令式的基础服务组件，也非常的合适，接下来我给你介绍实现自研 memcached 和 redis 服务的基于命令分发模式实现的架构。</p>
<h2 id="在自研基础架构产品中的应用">在自研基础架构产品中的应用</h2>
<h3 id="自研类_memcached_的缓存系统">自研类 memcached 的缓存系统</h3>
<p>Memcached是一种分布式内存对象缓存系统,用于加速动态Web应用程序的响应速度。它基于一种高效的基于内存的键值对存储,设计用于缓存小的数据块。</p>
<p>Memcached的主要优势包括:</p>
<ul>
<li><strong>高性能</strong>:基于内存操作,能够提供非常高的读写性能。</li>
<li><strong>减少服务器负载</strong>:通过缓存数据减轻了数据库的访问压力。</li>
<li><strong>可扩展性</strong>:支持分布式集群部署,能够线性扩展。</li>
</ul>
<p>Memcached的作者是Brad Fitzpatrick。也曾是 Go 开发团队成员之一，维护 Go HTTP 库等。也是 Go memcached client 库 <a href="https://github.com/bradfitz/gomemcache" target="_blank" rel="external">bradfitz/gomemcache:</a> 的作者。</p>
<p>这里我们介绍的是 Go memcached 服务端的库，在你实现类似 Memcached 服务的时候很有用。</p>
<p>Memcached 有文本和二进制两种协议，这里我们介绍的是文本协议，它比较简单，而且也方便使用 telenet 等命令测试。下面是一些常用的Memcached命令:</p>
<ol>
<li><strong>存储命令</strong>:<ul>
<li><code>set key flags exptime bytes [noreply]</code>: 存储一个键值对,并设置可选的标志、过期时间、数据长度和noreply。</li>
<li><code>add key flags exptime bytes [noreply]</code>: 仅当键不存在时添加一个新的键值对。</li>
<li><code>replace key flags exptime bytes [noreply]</code>: 仅当键已存在时替换键的值。</li>
</ul>
</li>
<li><strong>检索命令</strong>:<ul>
<li><code>get key [key ...]</code>: 获取一个或多个键的值。</li>
<li><code>gets key</code>: 获取带有CAS令牌的键值对,用于检查并设置操作。</li>
</ul>
</li>
<li><strong>操作命令</strong>:<ul>
<li><code>incr key value [noreply]</code>: 将键的数值增加给定的值。</li>
<li><code>decr key value [noreply]</code>: 将键的数值减少给定的值。</li>
<li><code>append key flags exptime bytes [noreply]</code>: 将数据追加到一个已存在的键的值中。</li>
<li><code>prepend key flags exptime bytes [noreply]</code>: 将数据添加到一个现有键的值的开始部分。</li>
<li><code>cas keyflags exptime bytes unique-cas-token [noreply]</code>: 使用CAS令牌实现检查并设置操作。</li>
</ul>
</li>
<li><strong>删除命令</strong>:<ul>
<li><code>delete key [noreply]</code>: 删除一个键值对。</li>
</ul>
</li>
<li><strong>统计命令</strong>:<ul>
<li><code>stats</code>: 获取Memcached服务器统计信息。</li>
<li><code>stats reset</code>: 重置Memcached服务器统计信息。</li>
</ul>
</li>
<li><strong>其他命令</strong>:<ul>
<li><code>flush_all [delay] [noreply]</code>: 清空整个Memcached服务器中的所有键值对数据。</li>
<li><code>version</code>: 获取Memcached服务器版本信息。</li>
<li><code>quit</code>: 关闭Memcached连接。</li>
</ul>
</li>
</ol>
<p>这些命令通过TCP连接以文本形式发送给Memcached服务器,服务器也以文本形式返回响应结果。例如,成功的响应以&quot;OK&quot;开头,错误响应以&quot;ERROR&quot;或&quot;SERVER_ERROR&quot;开头。</p>
<p><a href="https://github.com/smallnest/gomemcached" target="_blank" rel="external">smallnest/gomemcached</a> 是实现 memcache server 端的一个库，我们来看它的一个简单例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mockServer = NewServer(addr)</div><div class="line">mockServer.RegisterFunc(<span class="string">"get"</span>, DefaultGet)</div><div class="line">mockServer.RegisterFunc(<span class="string">"gets"</span>, DefaultGet)</div><div class="line">mockServer.RegisterFunc(<span class="string">"set"</span>, DefaultSet)</div><div class="line">mockServer.RegisterFunc(<span class="string">"delete"</span>, DefaultDelete)</div><div class="line">mockServer.RegisterFunc(<span class="string">"incr"</span>, DefaultIncr)</div><div class="line">mockServer.RegisterFunc(<span class="string">"flush_all"</span>, DefaultFlushAll)</div><div class="line">mockServer.RegisterFunc(<span class="string">"version"</span>, DefaultVersion)</div><div class="line">mockServer.Start()</div></pre></td></tr></table></figure>

<p>Server 是一个命令分发器，你可以注册你实现的命令处理函数。<br>你甚至扩展，为你的缓存产品增加 memcached 不支持的命令，比如 <code>auth</code> 等等。</p>
<h3 id="自研类_Redis_的系统">自研类 Redis 的系统</h3>
<p>如果你要开发类似 Redis 的服务，也有一个非常知名的库，甚至可以说是 Go 生态圈的首选，就是 <a href="https://github.com/tidwall/redcon" target="_blank" rel="external">tidwall/redcon</a></p>
<p>它基于命令分发模式，提供了一个通用的 Redis 服务端框架，下面是一个它的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/tidwall/redcon"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> addr = <span class="string">":6380"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> mu sync.RWMutex</div><div class="line">	<span class="keyword">var</span> items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>][]<span class="typename">byte</span>)</div><div class="line">	<span class="keyword">var</span> ps redcon.PubSub</div><div class="line">	<span class="keyword">go</span> log.Printf(<span class="string">"started server at %s"</span>, addr)</div><div class="line">	err := redcon.ListenAndServe(addr,</div><div class="line">		<span class="keyword">func</span>(conn redcon.Conn, cmd redcon.Command) {</div><div class="line">			<span class="keyword">switch</span> strings.ToLower(<span class="typename">string</span>(cmd.Args<span class="number">[0</span>])) {</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				conn.WriteError(<span class="string">"ERR unknown command '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"'"</span>)</div><div class="line">			<span class="keyword">case</span> <span class="string">"ping"</span>:</div><div class="line">				conn.WriteString(<span class="string">"PONG"</span>)</div><div class="line">			<span class="keyword">case</span> <span class="string">"quit"</span>:</div><div class="line">				conn.WriteString(<span class="string">"OK"</span>)</div><div class="line">				conn.Close()</div><div class="line">			<span class="keyword">case</span> <span class="string">"set"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 3</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				mu.Lock()</div><div class="line">				items[<span class="typename">string</span>(cmd.Args<span class="number">[1</span>])] = cmd.Args<span class="number">[2</span>]</div><div class="line">				mu.Unlock()</div><div class="line">				conn.WriteString(<span class="string">"OK"</span>)</div><div class="line">			<span class="keyword">case</span> <span class="string">"get"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 2</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				mu.RLock()</div><div class="line">				val, ok := items[<span class="typename">string</span>(cmd.Args<span class="number">[1</span>])]</div><div class="line">				mu.RUnlock()</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					conn.WriteNull()</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					conn.WriteBulk(val)</div><div class="line">				}</div><div class="line">			<span class="keyword">case</span> <span class="string">"del"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 2</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				mu.Lock()</div><div class="line">				_, ok := items[<span class="typename">string</span>(cmd.Args<span class="number">[1</span>])]</div><div class="line">				<span class="built_in">delete</span>(items, <span class="typename">string</span>(cmd.Args<span class="number">[1</span>]))</div><div class="line">				mu.Unlock()</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					conn.WriteInt<span class="number">(0</span>)</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					conn.WriteInt<span class="number">(1</span>)</div><div class="line">				}</div><div class="line">			<span class="keyword">case</span> <span class="string">"publish"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 3</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				conn.WriteInt(ps.Publish(<span class="typename">string</span>(cmd.Args<span class="number">[1</span>]), <span class="typename">string</span>(cmd.Args<span class="number">[2</span>])))</div><div class="line">			<span class="keyword">case</span> <span class="string">"subscribe"</span>, <span class="string">"psubscribe"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) &lt;<span class="number"> 2</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				command := strings.ToLower(<span class="typename">string</span>(cmd.Args<span class="number">[0</span>]))</div><div class="line">				<span class="keyword">for</span> i :=<span class="number"> 1</span>; i &lt; <span class="built_in">len</span>(cmd.Args); i++ {</div><div class="line">					<span class="keyword">if</span> command == <span class="string">"psubscribe"</span> {</div><div class="line">						ps.Psubscribe(conn, <span class="typename">string</span>(cmd.Args[i]))</div><div class="line">					} <span class="keyword">else</span> {</div><div class="line">						ps.Subscribe(conn, <span class="typename">string</span>(cmd.Args[i]))</div><div class="line">					}</div><div class="line">				}</div><div class="line">			}</div><div class="line">		},</div><div class="line">		<span class="keyword">func</span>(conn redcon.Conn) <span class="typename">bool</span> {</div><div class="line">			<span class="comment">// Use this function to accept or deny the connection.</span></div><div class="line">			<span class="comment">// log.Printf("accept: %s", conn.RemoteAddr())</span></div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		},</div><div class="line">		<span class="keyword">func</span>(conn redcon.Conn, err error) {</div><div class="line">			<span class="comment">// This is called when the connection has been closed</span></div><div class="line">			<span class="comment">// log.Printf("closed: %s, err: %v", conn.RemoteAddr(), err)</span></div><div class="line">		},</div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>redcon.ListenAndServe 是一个命令分发器，你可以注册你实现的命令处理函数。<br>在上面的例子中，每一个<code>switch case</code>是一种命令的处理，这里的例子很简单，就没有把每种命令的处理逻辑写成一个个独立的handler,而是直接在case中直接处理。如果我们要实现一个类Redis系统，最好的方式是把每种命令的处理逻辑写成一个个独立的handler，这样代码更清晰，更易维护。<br>这些handler最好按照redis命令的分类，分成几个文件，分别处理string、set等类型。</p>
<p>这样的设计，不仅符合命令分发模式，而且符合单一职责原则，代码更易维护。</p>
<p>从上面的几个例子来看，命令分发模式在实现类似 Memcached、Redis 这种基础架构产品中非常适用，它可以帮助我们实现一个灵活、可扩展的系统架构。本周的另外一篇文章，介绍一个基于SQLite的类Redisa的实现，也是采用了命令分发模式,请关注“鸟窝聊技术”公众号，及时获取最新的文章。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>命令分发模式 (command dispatcher pattern)不属于23种经典的设计模式。它是一种不太为人所知的设计模式,它主要用于构建可扩展、可插拔的系统架构,将请求与执行请求的操作对象解耦。它类似于命令模式(Command Pattern),但更加灵活和动态。</p>
<p>虽然Command Dispatch Pattern不属于那23种经典模式,但它确实是一种很有价值的模式,可以应用于需要在运行时动态添加、修改或删除操作的系统中,使系统更加灵活和可扩展。</p>
<p>这种模式通过允许方便的添加、替换或移除任何命令处理器, 非常的灵活，将命令调用和命令处理解耦。而且每个命令可以由单独的命令处理器处理，代码组织和维护也很方便。</p>
<p>实际上，对于 Gopher 来讲，必然已经接触到这个模式了，只不过少有人指出或者梳理这种模式，但是在标准库和一些知名的项目中，其实已经自然的应用了，而且看起来整个架构也非常的清爽。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Rust捕获和解析网络包]]></title>
    <link href="https://colobu.com/2024/05/22/parse-tcp-timestamp-in-Rust/"/>
    <id>https://colobu.com/2024/05/22/parse-tcp-timestamp-in-Rust/</id>
    <published>2024-05-22T14:14:30.000Z</published>
    <updated>2024-08-09T06:26:33.704Z</updated>
    <content type="html"><![CDATA[<p>前两篇文章介绍了C++和Go中利用TCP Option中的时间戳实现计算网络时延。基于“用Rust重写一切”的哲学，今天我们来看看Rust中如何做这个事情。夜深人静，再肝一篇关于网络编程的文章。<br><a id="more"></a></p>
<p>Rust中还没有和 gopacket一样功能强大的包，它的<a href="https://crates.io/crates/pcap" target="_blank" rel="external">pcap</a>用来捕获网络包没有问题，但是缺乏解析的能力，所以我们使用另外一个包<a href="https://docs.rs/pdu/latest/pdu/" target="_blank" rel="external">pdu</a>来实现网络包的解析。</p>
<blockquote>
<p>当然rust生态圈中还有其他的包捕获库如<a href="https://github.com/libpnet/libpnet" target="_blank" rel="external">pnet</a>、包解析库如<a href="https://crates.io/crates/etherparse" target="_blank" rel="external">etherparse</a>等，但是我选择了pcap和pdu，因为针对这篇文章的场景，它们用起来很顺手。</p>
</blockquote>
<p>为了简单起见，我们不像前两篇文章那样的程序那么复杂，还要解析参数，针对参数做不同的处理，这次Rust实现的程序中，我们主要实现其最核心的功能：</p>
<ul>
<li>捕获 TCP 包</li>
<li>解析TCP选项中的时间戳</li>
<li>计算时延</li>
</ul>
<p>我是在Mac mini的进行开发和运行的，理论在Linux上也是可以运行的。</p>
<p>你可能需要安装<code>libpcap</code>库。</p>
<p>Mac上可能你需要临时设置权限，才有可能正常运行程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> chmod <span class="number">666</span> /dev/bpf*</div></pre></td></tr></table></figure>

<p>首先看看程序运行的效果：<br><img src="pping.png" alt=""></p>
<p>那么程序一开始，我们开始要使用pcap捕获包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::net::{Ipv4Addr,Ipv6Addr};</div><div class="line"><span class="keyword">use</span> std::ops::Sub;</div><div class="line"><span class="keyword">use</span> std::time::{Duration, UNIX_EPOCH};</div><div class="line"><span class="keyword">use</span> chrono::{DateTime, Local};</div><div class="line"></div><div class="line"><span class="keyword">use</span> macaddr::MacAddr;</div><div class="line"><span class="keyword">use</span> pcap;</div><div class="line"><span class="keyword">use</span> pdu::*;</div><div class="line"><span class="keyword">use</span> libc;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 这个用来记录flow已经它被捕获的时间</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = std::collections::HashMap::new();</div><div class="line"></div><div class="line">    <span class="comment">// 在Mac上，使用en1网卡</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cap = pcap::Capture::from_device(<span class="string">"en1"</span>)</div><div class="line">        .unwrap()</div><div class="line">        .immediate_mode(<span class="keyword">true</span>)</div><div class="line">        .open()</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 你可以设置filter，这里我们简化不进行设置了</span></div><div class="line">    <span class="comment">// cap.filter("host 127.0.0.1", true).unwrap();</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">let</span> Ok(packet) = cap.next_packet() {</div><div class="line">        <span class="comment">// 得到捕获的包信息</span></div><div class="line"></div><div class="line">        ......</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前我们只能得到捕获的包信息，包括pcap增加的头信息(捕获时间、包长度等)和包的数据。</p>
<p>我们需要解析包的数据，得到TCP包，然后解析TCP选项中的时间戳。目前pcap不能帮助我们了。</p>
<p>我们在那个while循环中一步一步补充省略的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ethernet = EthernetPdu::new(&packet.data).unwrap();</div><div class="line"></div><div class="line"><span class="comment">// 实现代码，输出源和目的MAC地址,转换成MacAddr类型</span></div><div class="line"><span class="keyword">let</span> <span class="number">_</span>src_mac = MacAddr::from(ethernet.source_address());</div><div class="line"><span class="keyword">let</span> <span class="number">_</span>dst_mac = MacAddr::from(ethernet.destination_address());</div><div class="line"></div><div class="line"><span class="comment">// println!("ethernet: src_mac={}, dst_mac={}", src_mac, dst_mac);</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> ei = ethernet.inner();</div><div class="line"><span class="keyword">let</span> (src_ip,dst_ip, tcp) = <span class="keyword">match</span> ei {</div><div class="line">    Ok(Ethernet::Ipv4(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv4Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv4Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv4::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line">        </div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    Ok(Ethernet::Ipv6(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv6Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv6Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv6::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line"></div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    <span class="number">_</span> =&gt; (String::new(),String::new(),None)</div><div class="line">    </div><div class="line">};</div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure>

<p>首先解析出<code>ethernet</code>层,和gopacket调用方法不同，但是一样很简洁。</p>
<p><code>ethernet</code>中包含源目的Mac地址，如果你需要，你可以调用相应的方法获取它们。本程序不需要这两个信息，忽略即可。</p>
<p>接下来解析<code>IP</code>层,这会涉及到ipv4和ipv6两种情况，我们分别处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ei = ethernet.inner();</div><div class="line"><span class="keyword">let</span> (src_ip,dst_ip, tcp) = <span class="keyword">match</span> ei {</div><div class="line">    Ok(Ethernet::Ipv4(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv4Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv4Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv4::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line">        </div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    Ok(Ethernet::Ipv6(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv6Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv6Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv6::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line"></div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    <span class="number">_</span> =&gt; (String::new(),String::new(),None)</div><div class="line">    </div><div class="line">};</div><div class="line">    </div><div class="line"><span class="keyword">if</span> tcp.is_none() {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"><span class="keyword">let</span> tcp = tcp.unwrap();</div></pre></td></tr></table></figure>

<p>调用<code>inner</code>方法就可以得到<code>IP</code>层的信息，我们处理ipv4和ipv6两种情况，分别获取源目的IP地址和TCP层这三个数据。</p>
<p>因为一开始我们没有设置filter,所以这里捕获的包很多，比如UDP的包、ARP的包，我们在这里检查包是否是TCP包，如果不是，我们忽略这个包。当然最好是一开始就设置filter，性能会更好。</p>
<p>接下来我们解析TCP选项中的时间戳：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ts = tcp.options().find_map(|option| {</div><div class="line">    <span class="keyword">match</span> option {</div><div class="line">        TcpOption::Timestamp{val,ecr} =&gt; {</div><div class="line">            Some((val, ecr))</div><div class="line">        }</div><div class="line">        <span class="number">_</span> =&gt; None</div><div class="line">    }</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">if</span> ts.is_none() {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> ts.unwrap().<span class="number">1</span> == <span class="number">0</span> && !tcp.syn(){</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>pdu</code>库的好处是方便解析TCP以及它的选项。TCP的选项可能有好几个，我们只match时间戳的那个，得到时间戳的值和echo reply的值。</p>
<p>接下来我们处理数据。首先根据五元组和<code>tval</code>为key,将这个flow的信息存储到map中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> key = format!(<span class="string">"{}:{}-&gt;{}:{}-{}"</span>,  src_ip, tcp.source_port(),dst_ip,tcp.destination_port(),ts.unwrap().<span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> !map.contains_key(key.as_str()) {</div><div class="line">    map.insert(key, packet.header.ts);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后我们找反向的key,如果存在，就说明有去向，当前处理的是回向，我们计算两个捕获的值的差，就是时延：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> reverse_key = format!(<span class="string">"{}:{}-&gt;{}:{}-{}"</span>, dst_ip, tcp.destination_port(),src_ip,tcp.source_port(),ts.unwrap().<span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> map.contains_key(reverse_key.as_str()) {</div><div class="line">    map.get(reverse_key.as_str()).map(|ts| {</div><div class="line">        <span class="keyword">let</span> rtt = timeval_diff_str(ts,&packet.header.ts);</div><div class="line">        println!(<span class="string">"{} {} {}:{}-&gt;{}:{}"</span>, timeval_to_current_time_str(&packet.header.ts), rtt,dst_ip, tcp.destination_port(),src_ip,tcp.source_port());</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然为了避免<code>map</code>中的数据越积越多，我们可以定期清理一下，这里我们根据map中的元素的数量决定要不要清理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> map.len() &gt; <span class="number">10_000</span> {</div><div class="line">    map.retain(|<span class="number">_</span>,v| {</div><div class="line">        <span class="keyword">let</span> now = std::time::SystemTime::now();</div><div class="line">        <span class="keyword">let</span> duration = now.duration_since(UNIX_EPOCH).unwrap();</div><div class="line">        <span class="keyword">let</span> ts = Duration::new(v.tv_sec <span class="keyword">as</span> <span class="keyword">u64</span>, v.tv_usec <span class="keyword">as</span> <span class="keyword">u32</span> * <span class="number">1000</span>);</div><div class="line">        duration.sub(ts).as_secs() &lt; <span class="number">60</span></div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后补充两个计算时间的辅助程序，这就是这个程序的全部代码了:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">timeval_to_current_time_str</span></span>(tv: &libc::timeval) -&gt; String {</div><div class="line">    <span class="keyword">let</span> secs = tv.tv_sec <span class="keyword">as</span> <span class="keyword">u64</span>;</div><div class="line">    <span class="keyword">let</span> nsecs = (tv.tv_usec <span class="keyword">as</span> <span class="keyword">u32</span> * <span class="number">1000</span>) <span class="keyword">as</span> <span class="keyword">u64</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> duration = UNIX_EPOCH + std::time::Duration::new(secs, nsecs <span class="keyword">as</span> <span class="keyword">u32</span>);</div><div class="line">    <span class="keyword">let</span> datetime = DateTime::&lt;Local&gt;::from(duration);</div><div class="line"></div><div class="line">    datetime.format(<span class="string">"%H:%M:%S"</span>).to_string()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">timeval_diff_str</span></span>(start: &libc::timeval, end: &libc::timeval) -&gt; String {</div><div class="line">    <span class="keyword">let</span> secs = end.tv_sec <span class="keyword">as</span> <span class="keyword">i64</span> - start.tv_sec <span class="keyword">as</span> <span class="keyword">i64</span>;</div><div class="line">    <span class="keyword">let</span> usecs = end.tv_usec <span class="keyword">as</span> <span class="keyword">i64</span> - start.tv_usec <span class="keyword">as</span> <span class="keyword">i64</span>;</div><div class="line">    <span class="keyword">let</span> (secs, usecs) = <span class="keyword">if</span> usecs &lt; <span class="number">0</span> {</div><div class="line">        (secs - <span class="number">1</span>, usecs + <span class="number">1_000_000</span>)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        (secs, usecs)</div><div class="line">    };</div><div class="line"></div><div class="line">    format_duration(secs, usecs <span class="keyword">as</span> <span class="keyword">u32</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">format_duration</span></span>(secs: <span class="keyword">i64</span>, usecs: <span class="keyword">u32</span>) -&gt; String {</div><div class="line">    <span class="keyword">let</span> duration = secs * <span class="number">1_000_000</span> + usecs <span class="keyword">as</span> <span class="keyword">i64</span>;</div><div class="line">    <span class="keyword">match</span> duration {</div><div class="line">        <span class="number">0</span>..=<span class="number">999_999</span> =&gt; format!(<span class="string">"{:.3}ms"</span>, duration <span class="keyword">as</span> <span class="keyword">f64</span> / <span class="number">1_000.0</span>),</div><div class="line">        <span class="number">_</span> =&gt; format!(<span class="string">"{:.6}s"</span>, duration <span class="keyword">as</span> <span class="keyword">f64</span> / <span class="number">1_000_000.0</span>),</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你对Rust实现的 pping 有什么看法，欢迎在评论区留下你宝贵的意见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前两篇文章介绍了C++和Go中利用TCP Option中的时间戳实现计算网络时延。基于“用Rust重写一切”的哲学，今天我们来看看Rust中如何做这个事情。夜深人静，再肝一篇关于网络编程的文章。<br>]]>
    
    </summary>
    
      <category term="Rust" scheme="https://colobu.com/categories/Rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go语言实现 pping]]></title>
    <link href="https://colobu.com/2024/05/20/implemenmt-pping-in-go/"/>
    <id>https://colobu.com/2024/05/20/implemenmt-pping-in-go/</id>
    <published>2024-05-20T15:15:55.000Z</published>
    <updated>2024-08-09T06:26:33.593Z</updated>
    <content type="html"><![CDATA[<p>大家好，我是鸟窝。</p>
<p>在前一篇“pping：被动式ping,计算网络时延”一篇中，我给大家介绍了 pping 这个工具的原理和使用方法。这篇文章中，我将使用 Go 语言实现 pping 工具。<br><a id="more"></a><br>通过这篇文章，你将了解到：</p>
<ul>
<li>如何使用gopacket来捕获和解析网络数据包</li>
<li>如何设置捕获时长和过滤捕获的数据包</li>
<li>如何在CGO下静态编译库，如libpcap</li>
<li>了解TCP/IP协议栈的基本知识，如TCP Option</li>
<li>如何进行数据的统计和定时输出和清理</li>
<li>如何使用 pflag 来解析命令行参数</li>
<li><img src="pping.png" alt=""></li>
</ul>
<p>代码在: <a href="https://github.com/smallnest/pping-go" target="_blank" rel="external">github.com/smallnest/pping-go</a></p>
<h2 id="使用libpcap捕获数据包，并进行包过滤">使用libpcap捕获数据包，并进行包过滤</h2>
<p>我们并不直接使用libpcap，而是使用封装好的<a href="https://github.com/google/gopacket" target="_blank" rel="external">gopacket</a>。</p>
<p><code>gopacket</code>是一个用于处理数据包的库，它提供了一个高级的API，可以用来处理数据包的解析、分析和生成。它支持多种数据包格式，包括Ethernet、IPv4、IPv6、TCP、UDP、ICMP等。</p>
<p>我们可以使用<code>gopacket</code>来捕获数据包，然后使用<code>gopacket/layers</code>包来解析数据包的各个部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建一个新的非活动 pcap 句柄, *liveInp是网卡的名称</span></div><div class="line">inactive, _ := pcap.NewInactiveHandle(*liveInp)</div><div class="line"><span class="comment">// 使用 defer 关键字确保在函数结束时清理非活动句柄</span></div><div class="line"><span class="keyword">defer</span> inactive.CleanUp()</div><div class="line"></div><div class="line"><span class="comment">// 设置捕获的数据包的最大长度</span></div><div class="line">inactive.SetSnapLen(snapLen)</div><div class="line"></div><div class="line"><span class="comment">// 激活非活动句柄，返回一个活动句柄和可能的错误</span></div><div class="line">snif, err = inactive.Activate()</div><div class="line"><span class="comment">// 如果在激活句柄时出现错误，我们打印错误并退出程序</span></div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	fmt.Printf(<span class="string">"couldn't open %s: %v\n"</span>, *fname, err)</div><div class="line">	os.Exit<span class="number">(1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然你也可以从一个tcpdump这样的工具捕获的pcap文件中解析包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 pcap.OpenOffline 函数打开一个离线 pcap 文件，返回一个 pcap 句柄和可能的错误</span></div><div class="line">		snif, err = pcap.OpenOffline(*fname)</div><div class="line">		<span class="comment">// 如果在打开文件时出现错误，我们打印错误并退出程序</span></div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Printf(<span class="string">"couldn't open %s: %v\n"</span>, *fname, err)</div><div class="line">			os.Exit<span class="number">(1</span>)</div><div class="line">		}</div></pre></td></tr></table></figure>

<p>之后设置filter进行包过滤, filter的格式和tcpdump使用的过滤格式一样，默认它会加上<code>TCP</code>,只处理TCP的包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 使用 SetBPFFilter 方法设置 BPF 过滤器，过滤器的规则由变量 filter 定义</span></div><div class="line">snif.SetBPFFilter(filter)</div></pre></td></tr></table></figure>

<p>之后处理这个包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">src := gopacket.NewPacketSource(snif, layers.LayerTypeEthernet)</div><div class="line"><span class="comment">// 使用 src.Packets() 获取一个数据包通道，我们可以从这个通道中读取数据包</span></div><div class="line">packets := src.Packets()</div><div class="line"><span class="keyword">for</span> packet := <span class="keyword">range</span> packets {</div><div class="line">	processPacket(packet)</div><div class="line"></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="comment">// 如果结束或者需要定期打印统计信息，可以使用下面的代码</span></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="comment">// 如果需要清理过期的数据</span></div><div class="line">   ......</div></pre></td></tr></table></figure>

<h2 id="解析包">解析包</h2>
<p>从TCP Option中解析时间戳的函数是<code>getTSFromTCPOpts</code>，它的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getTSFromTCPOpts 用于从 TCP 选项中获取时间戳信息</span></div><div class="line"><span class="keyword">func</span> getTSFromTCPOpts(tcp *layers.TCP) (<span class="typename">uint32</span>, <span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">var</span> tsval, tsecr <span class="typename">uint32</span></div><div class="line">	opts := tcp.Options</div><div class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts {</div><div class="line">		<span class="keyword">if</span> opt.OptionType == layers.TCPOptionKindTimestamps && opt.OptionLength ==<span class="number"> 10</span> { <span class="comment">// Timestamp 选项长度为 10 字节</span></div><div class="line">			tsval = binary.BigEndian.Uint32(opt.OptionData<span class="number">[0</span><span class="number">:4</span>])</div><div class="line">			tsecr = binary.BigEndian.Uint32(opt.OptionData<span class="number">[4</span><span class="number">:8</span>])</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> tsval, tsecr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>解析IP和TCP包，并从TCP包的Option解析出时间戳：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// processPacket 用于处理捕获到的数据包</span></div><div class="line"><span class="keyword">func</span> processPacket(pkt gopacket.Packet) {</div><div class="line">	<span class="comment">// 从数据包中获取 TCP 层</span></div><div class="line">	tcpLayer := pkt.Layer(layers.LayerTypeTCP)</div><div class="line">	<span class="keyword">if</span> tcpLayer == <span class="constant">nil</span> {</div><div class="line">		not_tcp++</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	tcp, _ := tcpLayer.(*layers.TCP)</div><div class="line"></div><div class="line">	<span class="comment">// 从 TCP 选项中获取时间戳信息</span></div><div class="line">	<span class="comment">// 如果 TSval 为 0 或者 TSecr 为 0 并且不是 SYN 包，则不处理该数据包</span></div><div class="line">	tsval, tsecr := getTSFromTCPOpts(tcp)</div><div class="line">	<span class="keyword">if</span> tsval ==<span class="number"> 0</span> || (tsecr ==<span class="number"> 0</span> && !tcp.SYN) {</div><div class="line">		no_TS++</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 从数据包中获取网络层</span></div><div class="line">	<span class="comment">// 如果网络层不是 IPv4 或 IPv6，则不处理该数据包</span></div><div class="line">	netLayer := pkt.Layer(layers.LayerTypeIPv4)</div><div class="line">	<span class="keyword">if</span> netLayer == <span class="constant">nil</span> {</div><div class="line">		netLayer = pkt.Layer(layers.LayerTypeIPv6)</div><div class="line">		<span class="keyword">if</span> netLayer == <span class="constant">nil</span> {</div><div class="line">			not_v4or6++</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>目前为止我们从包中解析除了IP包和TCP包，接下里我们得到源目IP和源目端口，以及捕获时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从网络层中获取源 IP 和目的 IP</span></div><div class="line"><span class="comment">// 从 TCP 层中获取源端口和目的端口</span></div><div class="line"><span class="comment">// 用于构建流的源和目的</span></div><div class="line"><span class="keyword">var</span> ipsStr, ipdStr <span class="typename">string</span></div><div class="line"><span class="keyword">if</span> ip, ok := netLayer.(*layers.IPv4); ok {</div><div class="line">	ipsStr = ip.SrcIP.String()</div><div class="line">	ipdStr = ip.DstIP.String()</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	ip := netLayer.(*layers.IPv6)</div><div class="line">	ipsStr = ip.SrcIP.String()</div><div class="line">	ipdStr = ip.DstIP.String()</div><div class="line">}</div><div class="line">srcStr := ipsStr + <span class="string">":"</span> + strconv.Itoa(<span class="typename">int</span>(tcp.SrcPort))</div><div class="line">dstStr := ipdStr + <span class="string">":"</span> + strconv.Itoa(<span class="typename">int</span>(tcp.DstPort))</div><div class="line"></div><div class="line"><span class="comment">// 从数据包中获取捕获时间</span></div><div class="line">captureTime := pkt.Metadata().CaptureInfo.Timestamp</div><div class="line"></div><div class="line"><span class="comment">// 如果 offTm 小于 0，则将捕获时间设置为 offTm</span></div><div class="line"><span class="keyword">if</span> offTm &lt;<span class="number"> 0</span> {</div><div class="line">	offTm = captureTime.Unix()</div><div class="line">	startm = <span class="typename">float64</span>(captureTime.Nanosecond()) *<span class="number"> 1e-9</span></div><div class="line">	<span class="comment">// 如果 sumInt 大于 0，则打印第一个数据包的时间</span></div><div class="line">	capTm = startm</div><div class="line">	<span class="keyword">if</span> sumInt &gt;<span class="number"> 0</span> {</div><div class="line">		fmt.Printf(<span class="string">"first packet at %s\n"</span>, captureTime.Format(time.UnixDate))</div><div class="line">	}</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	capTm = <span class="typename">float64</span>(captureTime.Unix()-offTm) + <span class="typename">float64</span>(captureTime.Nanosecond())<span class="number">*1e-9</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来是从全局哈希表<code>flows</code>中查找流，如果没有则创建一个新的流，如果反向流已经存在，则设置反向流。如果反向流不存在，不处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">fstr := srcStr + <span class="string">"+"</span> + dstStr</div><div class="line">fr, ok := flows[fstr]</div><div class="line"><span class="keyword">if</span> !ok { <span class="comment">// 新流</span></div><div class="line">    <span class="comment">// 如果流的数量大于 maxFlows，则返回</span></div><div class="line">    <span class="keyword">if</span> flowCnt &gt;= maxFlows {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    fr = &flowRec{</div><div class="line">        flowname: fstr,</div><div class="line">        min:     <span class="number"> 1e30</span>,</div><div class="line">    }</div><div class="line">    flows[fstr] = fr</div><div class="line">    flowCnt++</div><div class="line"></div><div class="line">    <span class="comment">// 如果反向流已经存在，则设置反向流</span></div><div class="line">    <span class="keyword">if</span> _, ok := flows[dstStr+<span class="string">"+"</span>+srcStr]; ok {</div><div class="line">        flows[dstStr+<span class="string">"+"</span>+srcStr].revFlow = <span class="constant">true</span></div><div class="line">        fr.revFlow = <span class="constant">true</span></div><div class="line">    }</div><div class="line">}</div><div class="line">fr.last_tm = capTm</div><div class="line"></div><div class="line"><span class="comment">// 如果反向流不存在，不处理</span></div><div class="line"><span class="keyword">if</span> !fr.revFlow {</div><div class="line">    uniDir++</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>既然找到反向流了，说明正向反向的两个packet我们都获取到了了，那么就可以利用两次的捕获时间计算 RTT 了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">// 统计流的发送字节数</span></div><div class="line">	arr_fwd := fr.bytesSnt + <span class="typename">float64</span>(pkt.Metadata().Length)</div><div class="line">	fr.bytesSnt = arr_fwd</div><div class="line">	<span class="comment">// 增加时间戳</span></div><div class="line">	<span class="keyword">if</span> !filtLocal || localIP != ipdStr {</div><div class="line">		addTS(fstr+<span class="string">"+"</span>+strconv.FormatUint(<span class="typename">uint64</span>(tsval),<span class="number"> 10</span>), &tsInfo{capTm, arr_fwd, fr.bytesDep})</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 处理对应的反向流</span></div><div class="line">	ti := getTS(dstStr + <span class="string">"+"</span> + srcStr + <span class="string">"+"</span> + strconv.FormatUint(<span class="typename">uint64</span>(tsecr),<span class="number"> 10</span>))</div><div class="line">	<span class="keyword">if</span> ti != <span class="constant">nil</span> && ti.t &gt;<span class="number"> 0.0</span> {</div><div class="line">		<span class="comment">// 这是返回的数据包的捕获时间</span></div><div class="line">		t := ti.t</div><div class="line">		rtt := capTm - t</div><div class="line">		<span class="keyword">if</span> fr.min &gt; rtt {</div><div class="line">			fr.min = rtt <span class="comment">// 跟踪最小值</span></div><div class="line">		}</div><div class="line">		<span class="comment">// fBytes 存储了从源到目标的数据流的字节数</span></div><div class="line">		fBytes := ti.fBytes</div><div class="line">		<span class="comment">// dBytes 存储了从目标到源的数据流的字节数</span></div><div class="line">		dBytes := ti.dBytes</div><div class="line">		<span class="comment">// pBytes 存储了从上一次发送到现在的数据包的字节数</span></div><div class="line">		pBytes := arr_fwd - fr.lstBytesSnt</div><div class="line">		<span class="comment">// 更新上一次发送的字节数为当前的发送字节数</span></div><div class="line">		fr.lstBytesSnt = arr_fwd</div><div class="line">		<span class="comment">// 更新反向流的依赖字节数为 fBytes</span></div><div class="line">		flows[dstStr+<span class="string">"+"</span>+srcStr].bytesDep = fBytes</div><div class="line"></div><div class="line">		<span class="keyword">if</span> machineReadable {</div><div class="line">			<span class="comment">// 打印捕获时间戳、本次rtt值、此流的最小值、字节数信息</span></div><div class="line">			fmt.Printf(<span class="string">"%d.%06d %.6f %.6f %.0f %.0f %.0f"</span>, <span class="typename">int64</span>(capTm+<span class="typename">float64</span>(offTm)), <span class="typename">int</span>((capTm-<span class="typename">float64</span>(<span class="typename">int64</span>(capTm)))<span class="number">*1e6</span>), rtt, fr.min, fBytes, dBytes, pBytes)</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="comment">// 打印捕获时间、本次rtt值、此流的最小值、流的五元组</span></div><div class="line">			fmt.Printf(<span class="string">"%s %s %s %s\n"</span>, captureTime.Format(<span class="string">"15:04:05"</span>), fmtTimeDiff(rtt), fmtTimeDiff(fr.min), fstr)</div><div class="line">		}</div><div class="line">		now := clockNow()</div><div class="line">		<span class="keyword">if</span> now-nextFlush &gt;=<span class="number"> 0</span> {</div><div class="line">			nextFlush = now + flushInt</div><div class="line">		}</div><div class="line">		ti.t = -t <span class="comment">// 将条目标记为已使用,避免再次保存这个 TSval</span></div><div class="line">	}</div><div class="line">	pktCnt++</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="清理过期数据">清理过期数据</h2>
<p>如果不清理，<code>flows</code>和<code>tsTbl</code>中的数据会越来越多，最终撑爆。<br>我们遍历，删除过期的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清理超期的数据</span></div><div class="line"><span class="keyword">func</span> cleanUp(n <span class="typename">float64</span>) {</div><div class="line">	<span class="comment">// 如果 TSval 的时间超过 tsvalMaxAge,则删除条目</span></div><div class="line">	<span class="keyword">for</span> k, ti := <span class="keyword">range</span> tsTbl {</div><div class="line">		<span class="keyword">if</span> capTm-math.Abs(ti.t) &gt; <span class="typename">float64</span>(tsvalMaxAge)/<span class="typename">float64</span>(time.Second) {</div><div class="line">			<span class="built_in">delete</span>(tsTbl, k)</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> k, fr := <span class="keyword">range</span> flows {</div><div class="line">		<span class="keyword">if</span> n-fr.last_tm &gt; <span class="typename">float64</span>(flowMaxIdle)/<span class="typename">float64</span>(time.Second) {</div><div class="line">			<span class="built_in">delete</span>(flows, k)</div><div class="line">			flowCnt--</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用_pflag_解析参数">使用 pflag 解析参数</h2>
<p>相对于标准库的 pflag, <code>github.com/spf13/pflag</code>功能更为强大。这里我们使用它解析参数，可以设置短参数和长参数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	liveInp   = pflag.StringP(<span class="string">"interface"</span>, <span class="string">"i"</span>, <span class="string">""</span>, <span class="string">"interface name"</span>)</div><div class="line">	fname     = pflag.StringP(<span class="string">"read"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"pcap captured file"</span>)</div><div class="line">	filterOpt = pflag.StringP(<span class="string">"filter"</span>, <span class="string">"f"</span>, <span class="string">""</span>, <span class="string">"pcap filter applied to packets"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	pflag.DurationVarP(&sumInt, <span class="string">"sumInt"</span>, <span class="string">"q"</span>,<span class="number"> 10</span>*time.Second, <span class="string">"interval to print summary reports to stderr"</span>)</div><div class="line">	pflag.BoolVarP(&filtLocal, <span class="string">"showLocal"</span>, <span class="string">"l"</span>, <span class="constant">false</span>, <span class="string">"show RTTs through local host applications"</span>)</div><div class="line">	pflag.DurationVarP(&timeToRun, <span class="string">"seconds"</span>, <span class="string">"s"</span>,<span class="number"> 0</span>*time.Second, <span class="string">"stop after capturing for &lt;num&gt; seconds"</span>)</div><div class="line">	pflag.IntVarP(&maxPackets, <span class="string">"count"</span>, <span class="string">"c"</span>,<span class="number"> 0</span>, <span class="string">"stop after capturing &lt;num&gt; packets"</span>)</div><div class="line">	pflag.BoolVarP(&machineReadable, <span class="string">"machine"</span>, <span class="string">"m"</span>, <span class="constant">false</span>, <span class="string">"machine readable output"</span>)</div><div class="line">	pflag.DurationVarP(&tsvalMaxAge, <span class="string">"tsvalMaxAge"</span>, <span class="string">"M"</span>,<span class="number"> 10</span>*time.Second, <span class="string">"max age of an unmatched tsval"</span>)</div><div class="line">	pflag.DurationVarP(&flowMaxIdle, <span class="string">"flowMaxIdle"</span>, <span class="string">"F"</span>,<span class="number"> 300</span>*time.Second, <span class="string">"flows idle longer than &lt;num&gt; are deleted"</span>)</div><div class="line"></div><div class="line">	pflag.Parse()</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="静态编译">静态编译</h2>
<p>差点忘了。<br>我们使用gopacket来捕获数据包，它依赖于libpcap。我们需要在编译时链接libpcap库。但是在不同的操作系统上，libpcap的位置和名称可能不同。为了解决这个问题，我们可以使用CGO来链接libpcap库，然后使用<code>go build</code>来编译我们的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> build -o pping .</div></pre></td></tr></table></figure>

<p>不过如果你使用<code>ldd</code>查看这个程序，你会发现它有很多依赖的动态库:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@cypress pping]<span class="comment"># ldd pping</span></div><div class="line">	linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffcf33e1000)</div><div class="line">	libpcap.so.<span class="number">1</span> =&gt; /lib64/libpcap.so.<span class="number">1</span> (<span class="number">0</span>x00007f4b81933000)</div><div class="line">	libresolv.so.<span class="number">2</span> =&gt; /lib64/libresolv.so.<span class="number">2</span> (<span class="number">0</span>x00007f4b81719000)</div><div class="line">	libpthread.so.<span class="number">0</span> =&gt; /lib64/libpthread.so.<span class="number">0</span> (<span class="number">0</span>x00007f4b814fd000)</div><div class="line">	libc.so.<span class="number">6</span> =&gt; /lib64/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007f4b8112f000)</div><div class="line">	/lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007f4b81b74000)</div></pre></td></tr></table></figure>

<p>我们可以采用静态链接的方式，这样编译出来的pping,可以轻松的复制到其他的Linux机器上运行，不需要安装libpcap库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@cypress pping]<span class="comment"># go build -ldflags "-linkmode external -extldflags -static" .</span></div><div class="line"><span class="comment"># github.com/smallnest/pping</span></div><div class="line">/tmp/go-link-<span class="number">79680640</span>/<span class="number">000006</span>.o：在函数‘_cgo_97ab22c4dc7b_C2func_getaddrinfo’中：</div><div class="line">/tmp/go-build/cgo-gcc-prolog:<span class="number">60</span>: 警告：Using <span class="string">'getaddrinfo'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">//usr/local/lib/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoaddr’中：</div><div class="line">/root/libpcap-<span class="number">1.10</span>.<span class="number">0</span>/./nametoaddr.c:<span class="number">181</span>: 警告：Using <span class="string">'gethostbyname'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">//usr/local/lib/libpcap.a(nametoaddr.o)：在函数‘pcap_nametonetaddr’中：</div><div class="line">/root/libpcap-<span class="number">1.10</span>.<span class="number">0</span>/./nametoaddr.c:<span class="number">270</span>: 警告：Using <span class="string">'getnetbyname_r'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">//usr/local/lib/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoproto’中：</div><div class="line">/root/libpcap-<span class="number">1.10</span>.<span class="number">0</span>/./nametoaddr.c:<span class="number">527</span>: 警告：Using <span class="string">'getprotobyname_r'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">[root@cypress pping]<span class="comment"># ldd pping</span></div><div class="line">	不是动态可执行文件</div></pre></td></tr></table></figure>

<p>它的使用方法和标准库的flag类似。这样我们就能保证和c++的pping工具一样的参数解析了。</p>
<p>基于&quot;Rust重写一切&quot;的哲学，我期望早点能看到大家用Rust实现的 pping。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家好，我是鸟窝。</p>
<p>在前一篇“pping：被动式ping,计算网络时延”一篇中，我给大家介绍了 pping 这个工具的原理和使用方法。这篇文章中，我将使用 Go 语言实现 pping 工具。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让 Rob Pike 或者字节跳动的同学实现一个红黑树]]></title>
    <link href="https://colobu.com/2024/05/19/let-Rob-Pike-write-a-Red-Black-tree/"/>
    <id>https://colobu.com/2024/05/19/let-Rob-Pike-write-a-Red-Black-tree/</id>
    <published>2024-05-19T07:24:10.000Z</published>
    <updated>2024-08-09T06:26:33.631Z</updated>
    <content type="html"><![CDATA[<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。它在1972年由鲁道夫·贝尔发明，被称为“对称二叉B树”，它现代的名字源于利奥尼达斯·J·吉巴斯和罗伯特·塞奇威克于1978年写的一篇论文。红黑树的结构复杂，以至于有些个别公司拿它当做面试题现场实现，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在<code>O(log^n)</code>时间内完成查找、插入和删除。</p>
<a id="more"></a>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ul>
<li>性质1: 节点是红色或黑色。</li>
<li>性质2: 根是黑色。</li>
<li>性质3: 所有叶子都是黑色（叶子是NIL节点）。</li>
<li>性质4: 每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）</li>
<li>性质5: 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="rbtree.png" alt=""></p>
<p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。</p>
<p>然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(<code>O(log^n)</code>)的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为<code>O(log^n)</code>次。</p>
<p>这里我们就不详细介绍红黑树了，这不是问题额度重点。重点是Go标准库中没有实现红黑树，或者说没有直接暴露一个公共的红黑树实现，我们尝试实现它。</p>
<p>当然，已经2042年了，G我们可以借助AI的能力，帮助我们实现一个基本的红黑树，然后我们再做调整。<br>我尝试使用多个AI模型，比如文心一言、通义千问、CLaude、Gemini,并借助Copilot的帮助，最终生成了一个基本的红黑树实现。</p>
<p>为了更高效的实现，我决定请AI模拟Rob Pike或者字节跳动的同学来实现一个红黑树,我的提示语如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Go语言中有 BTreeMap实现吗？如果没有，请实现一个</div></pre></td></tr></table></figure>

<p>`</p>
<p>我对实现不满意，所以我又尝试了一次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请你模拟Rob Pike, review这个实现，指出实现的问题，并提供一个优化的版本</div></pre></td></tr></table></figure>

<p>这里你可以把Rob Pike换成字节跳动的同学。</p>
<p>基本实现了一个红黑树，我看了一下，明显<code>Size</code>字段没有更新，所以我让Copilot把它实现了，包括查找和遍历的方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个红黑树没有实现<span class="variable">Size</span>，请修复。</div><div class="line">为这个红黑树提供查找方法.</div><div class="line">为这个红黑树提供遍历方法</div></pre></td></tr></table></figure>

<p>它修复了一版。</p>
<p>默认它实现的查询和遍历的方法是采用递归的方式，层级多了栈可能会有问题或者溢出，所以我又请它按照非递归的方式实现了。</p>
<p>然后我又让Copliot帮我review了实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">假定你是Rob Pike, 基于你的经验和哲学，请你review这个红黑树的实现，列出问题和可优化的项。</div></pre></td></tr></table></figure>

<p>根据反馈的结果，又做了一些优化，比如<code>Size</code>在节点为空的时候不应该<code>--</code>等。</p>
<p>好了，目前我们让Rob Pike实现了这个红黑数，可以让Copilot帮我们实现单元测试。<br>我是每一个输出方法，单独的询问Copilot，让它生成的单元测试，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">为<span class="keyword">Get</span>方法生成单元测试</div></pre></td></tr></table></figure>

<p>执行单元测试，好真的发现了一些边界情况的处理，没检查nil的情况。</p>
<p>看到中间AI产生的代码包括如此多的错误，我有点不放心了，怎么办？</p>
<p>增加 Fuzz Test, 还是让Copilot帮我实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请为这个RBTree的<span class="keyword">Insert</span>和<span class="keyword">Delete</span>方法，生成fuzz test</div></pre></td></tr></table></figure>

<p>不过生成的代码有问题，我狠狠批评了Copilot，指出它的错误，让它重新生成了Fuzz Test，这次梅问题了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> FuzzInsert(f *testing.F) {</div><div class="line">	f.Add<span class="number">(3</span>, <span class="string">"three"</span>)</div><div class="line">	f.Add<span class="number">(1</span>, <span class="string">"one"</span>)</div><div class="line">	f.Add<span class="number">(2</span>, <span class="string">"two"</span>)</div><div class="line">	f.Add<span class="number">(4</span>, <span class="string">"four"</span>)</div><div class="line"></div><div class="line">	f.Fuzz(<span class="keyword">func</span>(t *testing.T, key <span class="typename">int</span>, value <span class="typename">string</span>) {</div><div class="line">		tree := NewRBTree()</div><div class="line">		tree.Insert(key, value)</div><div class="line">		<span class="keyword">if</span> val := tree.Get(key); val != value {</div><div class="line">			t.Errorf(<span class="string">"Expected %v, got %v"</span>, value, val)</div><div class="line">		}</div><div class="line">	})</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> FuzzDelete(f *testing.F) {</div><div class="line">	f.Add<span class="number">(3</span>, <span class="string">"three"</span>)</div><div class="line">	f.Add<span class="number">(1</span>, <span class="string">"one"</span>)</div><div class="line">	f.Add<span class="number">(2</span>, <span class="string">"two"</span>)</div><div class="line">	f.Add<span class="number">(4</span>, <span class="string">"four"</span>)</div><div class="line"></div><div class="line">	f.Fuzz(<span class="keyword">func</span>(t *testing.T, key <span class="typename">int</span>, value <span class="typename">string</span>) {</div><div class="line">		tree := NewRBTree()</div><div class="line">		tree.Insert(key, value)</div><div class="line">		tree.Delete(key)</div><div class="line">		<span class="keyword">if</span> val := tree.Get(key); val != <span class="constant">nil</span> {</div><div class="line">			t.Errorf(<span class="string">"Expected nil, got %v"</span>, val)</div><div class="line">		}</div><div class="line">	})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>`</p>
<p>运行Fuzz Test:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go test <span class="variable">-fuzz=</span>FuzzInsert <span class="variable">-fuzztime=</span><span class="number">1</span>m</div><div class="line">go test <span class="variable">-fuzz=</span>FuzzDelete <span class="variable">-fuzztime=</span><span class="number">1</span>m</div></pre></td></tr></table></figure>

<p>大功告成。</p>
<p>通过这个实践，我们可以看到AI:</p>
<ul>
<li>可以让AI模拟专家的形式，生成更专业的代码</li>
<li>目前AI生成的代码还是有问题的，还需要开发者检查和甄别</li>
<li>可以让AI帮我们review代码，找出问题和优化项</li>
<li>可以让AI帮我们生成单元测试，这些枯燥的测试AI还是很擅长的</li>
</ul>
<p>实现的RBTree代码在：<a href="https://github.com/smallnest/exp/blob/master/container/maps/rbtree.go" target="_blank" rel="external">rbtree.go</a><br>单元测试代码在: [rbtree_test.go][<a href="https://github.com/smallnest/exp/blob/master/container/maps/rbtree_test.go]" target="_blank" rel="external">https://github.com/smallnest/exp/blob/master/container/maps/rbtree_test.go]</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。它在1972年由鲁道夫·贝尔发明，被称为“对称二叉B树”，它现代的名字源于利奥尼达斯·J·吉巴斯和罗伯特·塞奇威克于1978年写的一篇论文。红黑树的结构复杂，以至于有些个别公司拿它当做面试题现场实现，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在<code>O(log^n)</code>时间内完成查找、插入和删除。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sqlx: 一个优秀的rust异步SQL库]]></title>
    <link href="https://colobu.com/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/"/>
    <id>https://colobu.com/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/</id>
    <published>2024-05-12T02:42:26.000Z</published>
    <updated>2024-08-09T06:26:33.875Z</updated>
    <content type="html"><![CDATA[<p>上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的<a href="https://github.com/launchbadge/sqlx" target="_blank" rel="external">sqlx库</a>，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。</p>
<a id="more"></a>
<h2 id="概览">概览</h2>
<p>sqlx是一个为Rust语言提供的功能齐全的数据库访问和查询构建器库。它支持多种数据库,包括PostgreSQL、MySQL、SQLite等。sqlx的设计目标是成为Rust中最直观、高效且类型安全的数据库客户端。</p>
<ul>
<li><strong>真正的异步</strong>。从头开始使用 async/await 构建，以实现最大的并发性。</li>
<li><strong>编译时检查查询</strong>（如果你需要的话）。请注意，sqlx 不是 ORM。</li>
<li><strong>与数据库无关</strong>。支持 PostgreSQL、MySQL、MariaDB、SQLite。</li>
<li><strong>纯 Rust</strong>。Postgres 和 MySQL/MariaDB 驱动程序是使用零不安全的代码以纯 Rust 编写的。</li>
<li><strong>与运行时无关</strong>。在不同的运行时（async-std/tokio/actix）和 TLS 后端（native-tls，rustls）上运行。</li>
</ul>
<blockquote>
<ul>
<li>SQLite 驱动程序使用 libsqlite3 C 库。</li>
<li>sqlx 除非启用了 sqlite 功能，否则会使用 #![forbid(unsafe_code)]。SQLite 驱动程序通过 libsqlite3-sys 直接调用 SQLite3 API，这需要使用不安全的代码。</li>
</ul>
</blockquote>
<p>另外，它还有以下特性：</p>
<ul>
<li>跨平台。作为原生的 Rust 代码，sqlx 可以在任何支持 Rust 的平台上编译。</li>
<li>内建的连接池功能，使用 <code>sqlx::Pool</code>。</li>
<li>行流式处理。数据从数据库异步读取并按需解码。</li>
<li>自动的语句准备和缓存。当使用高级查询 API（<code>sqlx::query</code>）时，语句将按连接进行准备和缓存。</li>
<li>简单的（未准备）查询执行，包括将结果获取到与高级 API 使用的相同 Row 类型。支持批量执行并返回所有语句的结果。</li>
<li>传输层安全性（TLS）在支持的平台（MySQL、MariaDB 和 PostgreSQL）上可用。</li>
<li>使用 <code>LISTEN</code> 和 <code>NOTIFY</code> 以支持 PostgreSQL 异步通知。</li>
<li>支持保存点的嵌套事务。</li>
<li>任何数据库驱动程序，允许在运行时更改数据库驱动程序。<code>AnyPool</code> 根据 URL 方案连接到指定的驱动程序。</li>
</ul>
<p>sqlx 支持编译时检查的查询。然而，它并不是通过提供一个 Rust API 或 DSL（特定领域语言）来构建查询来实现这一点的。相反，它提供了宏，这些宏接受常规的 SQL 作为输入，并确保其对于您的数据库是有效的。其工作原理是，sqlx 在编译时连接到您的开发数据库，让数据库本身验证（并返回一些有关）您的 SQL 查询的信息。这有一些可能令人惊讶的含义：</p>
<ul>
<li>由于 sqlx 不需要解析 SQL 字符串本身，因此可以使用开发数据库接受的任何语法（包括数据库扩展添加的内容）</li>
<li>由于数据库允许您检索的查询信息量不同，从查询宏获得的 SQL 验证的程度取决于数据库。</li>
</ul>
<p>它不是一个ORM库，你如果想使用ORM库，可以参考<a href="https://crates.io/crates/ormx" target="_blank" rel="external">ormx</a>和<a href="https://github.com/SeaQL/sea-orm" target="_blank" rel="external">SeaORM</a>。</p>
<h2 id="安装">安装</h2>
<p>sqlx支持多种异步运行时，你可以通过选择不同的特性来使用不同的异步运行时。目前支持的异步运行时有<code>async-std</code>, <code>tokio</code>和 <code>actix</code>(其实是tokio的别名)。还支持TLS的连接：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># Cargo.toml</div><div class="line">[dependencies]</div><div class="line"># P挑选下面的一行引入sqlx:</div><div class="line"></div><div class="line"># tokio (no TLS)</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span> ] }</div><div class="line"># tokio + native-tls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span>, <span class="string">"tls-native-tls"</span> ] }</div><div class="line"># tokio + rustls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span>, <span class="string">"tls-rustls"</span> ] }</div><div class="line"></div><div class="line"># async-std (no TLS)</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span> ] }</div><div class="line"># async-std + native-tls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span>, <span class="string">"tls-native-tls"</span> ] }</div><div class="line"># async-std + rustls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span>, <span class="string">"tls-rustls"</span> ] }</div></pre></td></tr></table></figure>

<p>如果你引入了多个异步运行时，默认首选<code>tokio</code>。</p>
<p>同时你也需要引入所需的数据库特性:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"postgres"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"mysql"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"sqlite"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"any"</span> ] }</div></pre></td></tr></table></figure>

<p>以及一些其他的关于数据类型的特性等，比如<code>chrono</code>、<code>uuid</code>、<code>time</code>、<code>bstr</code>、<code>bigdecimal</code>、<code>rust_decimal</code>、<code>ipnetwork</code>等。</p>
<p><code>derive</code>支持derive类型的宏，如<code>FromRow</code>, <code>Type</code>, <code>Encode</code>, <code>Decode</code>.</p>
<p><code>macros</code> 增加了对 query*! 宏的支持，该宏允许进行编译时检查的查询。</p>
<p>一个简单的sqlx示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span> <span class="comment">// 异步运行时</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="comment">// 使用一个数据库的连接池</span></div><div class="line">    <span class="comment">// 不同的数据库选择不同的连接池构建器</span></div><div class="line">    <span class="keyword">let</span> pool = MySqlPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .connect(<span class="string">"mysql://root:password@localhost/test"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一个简单的查询</span></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT ？"</span>)</div><div class="line">        .bind(<span class="number">150_i64</span>)</div><div class="line">        .fetch_one(&pool).await?;</div><div class="line"></div><div class="line">    assert_eq!(row.<span class="number">0</span>, <span class="number">150</span>);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="连接数据库">连接数据库</h2>
<p>sqlx支持多种不同的方式来连接数据库。最常见和推荐的是使用连接池。</p>
<h3 id="建立连接池">建立连接池</h3>
<p>连接池可以显著提高应用程序的性能和并发能力。通过重用连接,减少了建立新连接的开销。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个最大5个连接的PostgreSQL连接池。<code>PgPoolOptions</code>提供了各种配置选项。</p>
<p>比如你可以不通过dsn字符串，而是通过方法进行用户名和密码设置：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> conn = PgConnectOptions::new()</div><div class="line">    .host(<span class="string">"secret-host"</span>)</div><div class="line">    .port(<span class="number">2525</span>)</div><div class="line">    .username(<span class="string">"secret-user"</span>)</div><div class="line">    .password(<span class="string">"secret-password"</span>)</div><div class="line">    .ssl_mode(PgSslMode::Require)</div><div class="line">    .connect()</div><div class="line">    .await?;</div></pre></td></tr></table></figure>

<p>甚至可以在解析dsn字符串后再修改特定的参数，如下面的mysql示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::{Connection, ConnectOptions};</div><div class="line"><span class="keyword">use</span> sqlx::mysql::{MySqlConnectOptions, MySqlConnection, MySqlPool, MySqlSslMode};</div><div class="line"></div><div class="line"><span class="comment">// dsn string</span></div><div class="line"><span class="keyword">let</span> conn = MySqlConnection::connect(<span class="string">"mysql://root:password@localhost/db"</span>).await?;</div><div class="line"></div><div class="line"><span class="comment">// 手工构造</span></div><div class="line"><span class="keyword">let</span> conn = MySqlConnectOptions::new()</div><div class="line">    .host(<span class="string">"localhost"</span>)</div><div class="line">    .username(<span class="string">"root"</span>)</div><div class="line">    .password(<span class="string">"password"</span>)</div><div class="line">    .database(<span class="string">"db"</span>)</div><div class="line">    .connect().await?;</div><div class="line"></div><div class="line"><span class="comment">// 从dsn字符串解析Options</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> opts: MySqlConnectOptions = <span class="string">"mysql://root:password@localhost/db"</span>.parse()?;</div><div class="line"></div><div class="line"><span class="comment">// 修改参数</span></div><div class="line">opts.log_statements(log::LevelFilter::Trace);</div><div class="line"></div><div class="line"><span class="comment">// 创建连接池</span></div><div class="line"><span class="keyword">let</span> pool = MySqlPool::connect_with(&opts).await?;</div></pre></td></tr></table></figure>

<h3 id="单个连接">单个连接</h3>
<p>有时您可能只需要一个简单的单连接,而不需要连接池。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgConnOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> conn = PgConnOptions::new()</div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="查询">查询</h2>
<p>在 SQL 中，查询可以分为预编译（参数化）或未预编译（简单）的。预编译查询会缓存其查询计划，使用二进制通信模式（降低带宽和更快的解码速度），并利用参数来避免 SQL 注入。未预编译的查询是简单的，并且仅用于无法使用预编译语句的情况，例如各种数据库命令（如 <code>PRAGMA</code>、<code>SET</code> 或 <code>BEGIN</code>）。</p>
<p>sqlx 支持使用这两种类型的查询进行所有操作。在 sqlx 中，一个 <code>&amp;str</code> 被当作未预编译的查询来处理，而 <code>Query</code> 或 <code>QueryAs</code> 结构体被当作预编译的查询来处理。</p>
<blockquote>
<p>在其他语言中，预编译就是 prepared statement，未预编译就是 unprepared statement。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 底层执行</span></div><div class="line">conn.execute(<span class="string">"BEGIN"</span>).await?; <span class="comment">// 未预编译，简单查询</span></div><div class="line">conn.execute(sqlx::query(<span class="string">"DELETE FROM table"</span>)).await?; <span class="comment">// 预编译，此连接会缓存查询</span></div></pre></td></tr></table></figure>

<p>我们应该尽可能使用高级查询接口。为了使这更加容易，这些类型上有终结器（finalizers），这样就不需要使用执行器（executor）来包装它们。<br>换句话说，sqlx 提供了高级查询接口，这些接口使得与数据库的交互更加简洁和直观。这些接口被设计为可以独立工作，而不需要显式地创建一个执行器对象来执行查询。终结器（在这里可能指的是一些内部机制或方法）确保了这些高级接口在使用后可以正确地清理和关闭相关资源，从而简化了开发者的工作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqlx::query(<span class="string">"DELETE FROM table"</span>).execute(&<span class="keyword">mut</span> conn).await?;</div><div class="line">sqlx::query(<span class="string">"DELETE FROM table"</span>).execute(&pool).await?;</div></pre></td></tr></table></figure>

<p>在 sqlx 中，执行查询（execute）的终结器会返回受影响的行数（如果有的话），并丢弃所有接收到的结果。此外，还提供了 <code>fetch</code>、<code>fetch_one</code>、<code>fetch_optional</code> 和 <code>fetch_all</code> 方法来接收结果。</p>
<p><code>sqlx::query</code> 返回的 <code>Query</code> 类型, 它会从数据库中返回 <code>Row&lt;&#39;conn&gt;</code>。可以使用 <code>row.get()</code> 方法通过索引或名称访问列值。由于 <code>Row</code> 保持了对连接的不可变借用，因此一次只能存在一个 <code>Row</code>。</p>
<p><code>fetch</code> 查询的终结器返回一个类似流的类型，该类型会遍历结果集中的行。你可以通过迭代这个流来访问每一行数据。这通常用于处理查询结果集中有多行数据的情况。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 提供 `try_next`</span></div><div class="line"><span class="keyword">use</span> futures::TryStreamExt;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rows = sqlx::query(<span class="string">"SELECT * FROM users WHERE email = ?"</span>)</div><div class="line">    .bind(email)</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">let</span> Some(row) = rows.try_next().await? {</div><div class="line">    <span class="comment">// 将row映射到用户定义的领域类型</span></div><div class="line">    <span class="keyword">let</span> email: &<span class="keyword">str</span> = row.try_get(<span class="string">"email"</span>)?;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了将row映射到领域类型，可以使用以下两种模式之一：</p>
<ol>
<li>手工映射</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stream = sqlx::query(<span class="string">"SELECT * FROM users"</span>)</div><div class="line">    .map(|row: PgRow| {</div><div class="line">        <span class="comment">// 映射row到用户定义的领域类型</span></div><div class="line">    })</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>query_as</code>和<code>bind</code>方法</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(sqlx::FromRow)]</span></div><div class="line"><span class="keyword">struct</span> User { name: String, id: <span class="keyword">i64</span> }</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stream = sqlx::query_as::&lt;<span class="number">_</span>, User&gt;(<span class="string">"SELECT * FROM users WHERE email = ? OR name = ?"</span>)</div><div class="line">    .bind(user_email)</div><div class="line">    .bind(user_name)</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div></pre></td></tr></table></figure>

<p>除了使用类似流的类型来遍历结果集之外(<code>fetch</code>)，我们还可以使用 <code>fetch_one</code> 或 <code>fetch_optional</code> 来从数据库中请求一个必需的或可选的结果。</p>
<ul>
<li><code>fetch_one</code>: 这个方法会尝试从结果集中获取第一行数据。如果结果集为空（即没有数据），那么 <code>fetch_one</code> 通常会返回一个错误。这个方法适用于你期望查询结果只有一行数据的情况。</li>
<li><code>fetch_optional</code>: 这个方法类似于 <code>fetch_one</code>，但它返回一个可选的结果（<code>Option&lt;Row&gt;</code> 或 <code>Option&lt;T&gt;</code>，如果使用了类型映射）。如果结果集为空，它将返回 <code>None</code> 而不是错误。这使得它在处理可能返回零行或多行数据的查询时更加灵活，但你又只关心第一行数据（如果存在）的情况下特别有用。</li>
</ul>
<p>使用这两个方法可以帮助你更直接地处理那些只返回单个结果（或可能不返回结果）的查询</p>
<h3 id="原生查询和参数化查询">原生查询和参数化查询</h3>
<p>sqlx支持执行原生SQL查询,也支持使用绑定参数进行参数化查询,后者有助于防止SQL注入攻击。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="comment">// 原生查询</span></div><div class="line">    <span class="keyword">let</span> name: String = sqlx::query_scalar(<span class="string">"SELECT name FROM users WHERE id = 1"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 参数化查询 </span></div><div class="line">    <span class="keyword">let</span> count: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT COUNT(*) FROM users WHERE email LIKE $1"</span>)</div><div class="line">        .bind(<span class="string">"%@example.com"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="流式查询">流式查询</h3>
<p>sqlx支持流式查询，这意味着你可以在查询结果返回时立即处理它们，而不需要等待整个结果集加载完毕。这对于处理大量数据或需要实时处理数据的情况非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rows = sqlx::query(<span class="string">"SELECT id, name FROM users"</span>)</div><div class="line">        .fetch(&pool);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">let</span> Some(row) = rows.try_next().await? {</div><div class="line">        <span class="keyword">let</span> id: <span class="keyword">i32</span> = row.try_get(<span class="number">0</span>)?;</div><div class="line">        <span class="keyword">let</span> name: &<span class="keyword">str</span> = row.try_get(<span class="number">1</span>)?;</div><div class="line">        println!(<span class="string">"{} {}"</span>, id, name);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="查询结果映射到Rust数据结构">查询结果映射到Rust数据结构</h3>
<p>最常见的查询方式是将结果映射到一个Rust数据结构,比如结构体或元组结构体。sqlx会自动将数据库列映射到结构体字段。</p>
<p>比如下面这个例子是查询一个用户的信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(FromRow)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    email: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> user = sqlx::query_as::&lt;<span class="number">_</span>, User&gt;(<span class="string">"SELECT id, name, email FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(<span class="number">42</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, user);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>又比如下面这个例子查询一组书籍的信息:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(FromRow)]</span></div><div class="line"><span class="keyword">struct</span> Book {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    title: String,</div><div class="line">    author: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> books = sqlx::query_as::&lt;<span class="number">_</span>, Book&gt;(<span class="string">"SELECT * FROM books"</span>)</div><div class="line">        .fetch_all(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> books {</div><div class="line">        println!(<span class="string">"{} - {} ({})"</span>, book.id, book.title, book.author);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="执行语句">执行语句</h2>
<p>除了查询,sqlx还支持执行其他SQL语句,如INSERT、UPDATE和DELETE等。它提供了多种执行这些语句的方法,包括支持事务。</p>
<h3 id="执行语句-1">执行语句</h3>
<p>最简单的执行语句方式是使用<code>execute</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> inserted_rows = sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2)"</span>)</div><div class="line">        .bind(<span class="string">"User1"</span>).bind(<span class="string">"user1@example.com"</span>)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Inserted {} rows"</span>, inserted_rows);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面这个例子是插入一行数据到<code>users</code>表中，并打印出插入的行数。</p>
<blockquote>
<p>不要被<code>sqlx::query</code>这个名字所误导,它不仅仅用于查询,还可以用于执行其他SQL语句。</p>
</blockquote>
<p>下面是一个插入/更新/删除数据的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    email: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 插入新用户</span></div><div class="line">    <span class="keyword">let</span> user = User { id: <span class="number">0</span>, name: <span class="string">"NewUser"</span>.into(), email: <span class="string">"new@example.com"</span>.into() };</div><div class="line">    <span class="keyword">let</span> id = sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(&user.name).bind(&user.email)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    println!(<span class="string">"Inserted user with id: {}"</span>, id);</div><div class="line"></div><div class="line">    <span class="comment">// 更新用户</span></div><div class="line">    <span class="keyword">let</span> updated_rows = sqlx::query(<span class="string">"UPDATE users SET email=$1 WHERE id=$2"</span>)</div><div class="line">        .bind(<span class="string">"updated@example.com"</span>).bind(id)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Updated {} rows"</span>, updated_rows);</div><div class="line"></div><div class="line">    <span class="comment">// 删除用户</span></div><div class="line">    <span class="keyword">let</span> deleted_rows = sqlx::query(<span class="string">"DELETE FROM users WHERE id=$1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Deleted {} rows"</span>, deleted_rows);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="事务">事务</h3>
<p>sqlx支持事务,你可以使用<code>transaction</code>方法来执行一个事务。<br>要执行多个语句作为一个原子事务,您可以使用<code>begin</code>、<code>commit</code>和<code>rollback</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tx = pool.begin().await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"UPDATE users SET email=$1 WHERE id=$2"</span>)</div><div class="line">        .bind(<span class="string">"new@email.com"</span>).bind(<span class="number">42</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> tx)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"DELETE FROM users WHERE id=$1"</span>)</div><div class="line">        .bind(<span class="number">43</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> tx)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    tx.commit().await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的示例首先开始一个新事务,然后执行两个语句,最后提交事务。如果中间任何一步失败,可以调用<code>rollback</code>回滚整个事务。</p>
<p>面是一个使用sqlx中事务和回滚(rollback)的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::Error;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 开始一个事务</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> transaction = pool.begin().await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一些操作</span></div><div class="line">    sqlx::query(<span class="string">"UPDATE accounts SET balance = balance - $1 WHERE id = $2"</span>)</div><div class="line">        .bind(<span class="number">100.0</span>) <span class="comment">// 从账号中扣除100元</span></div><div class="line">        .bind(<span class="number">1</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> transaction)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"UPDATE accounts SET balance = balance + $1 WHERE id = $2"</span>)</div><div class="line">        .bind(<span class="number">100.0</span>) <span class="comment">// 将100元转账到另一个账号</span></div><div class="line">        .bind(<span class="number">2</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> transaction)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟一个错误情况</span></div><div class="line">    <span class="keyword">if</span> should_rollback() {</div><div class="line">        <span class="comment">// 回滚事务</span></div><div class="line">        transaction.rollback().await?;</div><div class="line">        println!(<span class="string">"Transaction rolled back"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 提交事务</span></div><div class="line">        transaction.commit().await?;</div><div class="line">        println!(<span class="string">"Transaction committed"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">should_rollback</span></span>() -&gt; <span class="keyword">bool</span> {</div><div class="line">    <span class="comment">// 一些条件判断，决定是否需要回滚</span></div><div class="line">    <span class="comment">// 这里为了演示，我们随机返回true或false</span></div><div class="line">    rand::thread_rng().gen_bool(<span class="number">0.5</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们首先使用<code>pool.begin()</code>开始一个新的事务。然后,我们执行两个查询,分别从一个账户扣除100元,并将这100元转账到另一个账户。<br>接下来,我们调用<code>should_rollback()</code>函数来模拟一个错误情况。如果<code>should_rollback()</code>返回true,我们就调用<code>transaction.rollback().await?</code>来回滚整个事务。否则,我们调用<code>transaction.commit().await?</code>来提交事务。</p>
<p>在真实情况下,您可能会在遇到某些异常或错误时触发回滚,例如:</p>
<ul>
<li>违反了某些业务规则或数据完整性约束</li>
<li>发生了意外的异常或错误</li>
<li>用户取消或中断了操作</li>
<li>出于某些原因,整个事务需要被回滚</li>
</ul>
<p>通过使用事务和回滚,您可以确保数据库中的更改要么全部成功,要么完全回滚,从而保持数据的一致性和完整性。这对于处理敏感操作或需要多个步骤的复杂操作非常重要。</p>
<h2 id="连接池和并发">连接池和并发</h2>
<p>sqlx内置了连接池支持,这使得它天生就支持高效的并发查询。通过连接池,可以避免为每个查询创建新连接的开销。</p>
<h3 id="连接池管理">连接池管理</h3>
<p>sqlx中的连接池由<code>PgPool</code>之类的类型表示。您可以直接创建一个连接池实例,也可以使用<code>PgPoolOptions</code>来定制配置:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">    .max_connections(<span class="number">10</span>)</div><div class="line">    .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">    .await?;</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个最大连接数为10的PostgreSQL连接池。<code>PgPoolOptions</code>提供了各种配置选项,如最大连接数、最小连接数、连接超时等。</p>
<h3 id="并发查询">并发查询</h3>
<p>由于sqlx内置了连接池,因此并发查询变得非常简单。你只需要在多个异步任务中并行执行查询即可:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> std::time::Instant;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line">    <span class="keyword">let</span> tasks = (<span class="number">0</span>..<span class="number">10</span>)</div><div class="line">        .map(|<span class="number">_</span>| {</div><div class="line">            <span class="keyword">let</span> pool = pool.clone();</div><div class="line">            tokio::spawn(async move { <span class="comment">// 并发</span></div><div class="line">                <span class="keyword">let</span> now = Instant::now();</div><div class="line">                <span class="keyword">let</span> <span class="number">_</span> = sqlx::query(<span class="string">"SELECT pg_sleep(1)"</span>).execute(&pool).await;</div><div class="line">                println!(<span class="string">"Task completed in {:?}"</span>, now.elapsed());</div><div class="line">            })</div><div class="line">        })</div><div class="line">        .collect::&lt;Vec&lt;<span class="number">_</span>&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks {</div><div class="line">        task.await?;</div><div class="line">    }</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个包含10个任务的并发查询。每个任务都会执行一个简单的查询,然后打印出执行时间。通过并发查询,您可以同时执行多个查询,从而提高查询效率。</p>
<p>下面是一个更实际的示例,模拟了并发处理多个Web请求的场景:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgRow};</div><div class="line"><span class="keyword">use</span> std::io;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> requests = vec![</div><div class="line">        <span class="string">"SELECT * FROM users WHERE id = $1"</span>,</div><div class="line">        <span class="string">"SELECT * FROM products WHERE category = $1"</span>,</div><div class="line">        <span class="string">"SELECT * FROM orders WHERE user_id = $1"</span>,</div><div class="line">    ];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> request <span class="keyword">in</span> requests {</div><div class="line">        <span class="keyword">let</span> rows = sqlx::query(request)</div><div class="line">            .bind(<span class="number">42</span>)</div><div class="line">            .fetch_all(&pool)</div><div class="line">            .await?;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows {</div><div class="line">            print_row(row);</div><div class="line">        }</div><div class="line"></div><div class="line">        println!();</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_row</span></span>(row: PgRow) {</div><div class="line">    <span class="keyword">let</span> cols = row.columns();</div><div class="line">    <span class="keyword">let</span> values: Vec&lt;&<span class="keyword">str</span>&gt; = row.get_refs(cols).into_iter().map(|v| v.unwrap()).collect();</div><div class="line">    println!(<span class="string">"{}"</span>, values.join(<span class="string">", "</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们模拟了处理多个Web请求的场景。我们定义了一个包含多个查询的请求列表,然后并发执行这些查询。每个查询都会返回一组行数据,我们将这些行数据打印出来。通过并发查询,我们可以同时处理多个请求,从而提高系统的性能和效率。</p>
<h2 id="JSON支持">JSON支持</h2>
<p>现代数据库广泛支持 JSON 数据类型,sqlx也为此提供了非常好的支持。您可以方便地查询JSON类型以及将查询结果映射为 JSON。</p>
<h3 id="查询_JSON_类型">查询 JSON 类型</h3>
<p>在数据库中,JSON 类型通常被存储为文本。sqlx允许你直接查询和处理 JSON 数据:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> json_data: serde_json::Value = sqlx::query(r#<span class="string">"</span></div><div class="line">        SELECT '[{"id<span class="string">": 1, "</span>name<span class="string">": "</span>Product <span class="number">1</span><span class="string">"}, {"</span>id<span class="string">": 2, "</span>name<span class="string">": "</span>Product <span class="number">2</span><span class="string">"}]'::json</span></div><div class="line">    "#)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, json_data);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子查询了一个JSON数组,并将其直接映射为 <code>serde_json::Value</code>。</p>
<h3 id="将查询结果映射为JSON">将查询结果映射为JSON</h3>
<p>您还可以将常规的查询结果映射为JSON格式。这对于构建API或与前端交互非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> serde::{Serialize, Deserialize};</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Deserialize, Serialize)]</span></div><div class="line"><span class="keyword">struct</span> Product {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    price: <span class="keyword">f64</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> products: Vec&lt;Product&gt; = sqlx::query_as(</div><div class="line">        <span class="string">"SELECT id, name, price FROM products"</span></div><div class="line">    )</div><div class="line">    .fetch_all(&pool)</div><div class="line">    .await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> json = serde_json::to_string(&products)?;</div><div class="line">    println!(<span class="string">"{}"</span>, json);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子查询了产品列表,并使用<code>serde_json</code>将其序列化为JSON格式。</p>
<h3 id="使用_PostgreSQL_的_JSON_类型">使用 PostgreSQL 的 JSON 类型</h3>
<p>这是一个更全面的示例,展示了如何在 PostgreSQL 中使用 JSON 类型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> serde::{Deserialize, Serialize};</div><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::types::JsonValue;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Serialize, Deserialize)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    profile: JsonValue,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 插入用户及其JSON配置文件</span></div><div class="line">    <span class="keyword">let</span> profile = serde_json::json!({</div><div class="line">        <span class="string">"bio"</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">        <span class="string">"interests"</span>: [<span class="string">"coding"</span>, <span class="string">"reading"</span>]</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> user = User {</div><div class="line">        id: <span class="number">0</span>,</div><div class="line">        name: <span class="string">"NewUser"</span>.into(),</div><div class="line">        profile: profile.into(),</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> id = sqlx::query(<span class="string">"INSERT INTO users (name, profile) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(&user.name)</div><div class="line">        .bind(&user.profile)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 查询并打印用户及其配置文件</span></div><div class="line">    <span class="keyword">let</span> user: User = sqlx::query_as(<span class="string">"SELECT id, name, profile FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, user);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们首先使用<code>serde_json</code>创建了一个JSON 值,作为用户配置文件。然后,我们将这个JSON 值 插入到数据库中。最后,我们查询用户并将配置文件作为 <code>JsonValue</code> 类型获取。</p>
<h2 id="通知和监听">通知和监听</h2>
<p>sqlx提供了在数据库中监听通知(<code>NOTIFY/LISTEN</code>)的功能,这使得构建基于事件的、实时应用程序成为可能。</p>
<p><strong>数据库通知</strong><br>数据库通知是一种机制,允许应用程序在数据库中发生某些事件时接收通知。这种功能在构建基于事件的系统(如聊天应用程序或实时仪表板)时非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 在数据库中触发通知</div><div class="line">NOTIFY channel_name, 'hello';</div></pre></td></tr></table></figure>

<p><strong>使用监听器</strong><br>sqlx通过<code>DatabaseNotification</code>结构体来表示接收到的通知。您可以在应用程序中设置一个监听器,以接收并处理这些通知。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgListener;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> listener = PgListener::bind(<span class="string">"postgresql://localhost/"</span>).await?;</div><div class="line">    listener.listen(<span class="string">"channel_name"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> notification = listener.recv().await?;</div><div class="line">        println!(</div><div class="line">            <span class="string">"Received notification: {} ({})"</span>,</div><div class="line">            notification.payload, notification.payload_pretty(),</div><div class="line">        );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的示例创建了一个<code>PostgreSQL</code>监听器,并开始监听名为<code>channel_name</code>的通道。当接收到通知时,它会打印出通知的有效负载。</p>
<p>这是一个更完整的示例,展示了如何在PostgreSQL中设置通知并在应用程序中监听它们:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgListener};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line">    <span class="keyword">let</span> listener = PgListener::bind(<span class="string">"postgresql://localhost/"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个通知通道</span></div><div class="line">    sqlx::query(<span class="string">"LISTEN channel_name"</span>).execute(&pool).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 在另一个连接上触发通知</span></div><div class="line">    sqlx::query(<span class="string">"NOTIFY channel_name, 'hello'"</span>).execute(&pool).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 等待并处理通知</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Some(notification) = listener.recv().await? {</div><div class="line">        println!(<span class="string">"Received notification: {}"</span>, notification.payload);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们首先创建了一个PostgreSQL监听器,并在数据库中设置了一个名为<code>channel_name</code>的通知通道。然后,我们在另一个连接上触发了一个通知。最后,监听器接收到通知并打印出了它的有效负载。</p>
<h2 id="测试">测试</h2>
<p>编写测试对于任何健壮的软件系统都是必不可少的,sqlx也不例外。幸运的是,sqlx提供了多种方式来测试与数据库交互的代码。</p>
<h3 id="测试连接">测试连接</h3>
<p>最基本的测试是确保您的应用程序能够成功连接到数据库。您可以使用sqlx提供的<code>try_connect</code>函数进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_connection</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::try_connect(<span class="string">"postgres://postgres:@localhost"</span>).await.unwrap();</div><div class="line">    <span class="comment">// 执行一些操作来测试连接...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="测试查询">测试查询</h3>
<p>您还可以测试查询,以确保它们能够正确地执行并返回预期的结果。您可以使用<code>query</code>和<code>query_as</code>函数来测试查询:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_query</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await.unwrap();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT 1"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    assert_eq!(row.<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用内存数据库">使用内存数据库</h3>
<p>sqlx支持使用内存数据库进行测试,例如SQLite内存数据库。这种方式快速、轻量,非常适合单元测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_query</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = sqlx::SqlitePool::connect(<span class="string">":memory:"</span>).await.unwrap();</div><div class="line">    <span class="comment">// 执行测试...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于更全面的集成测试,您可以在测试用例中创建一个临时的测试数据库,执行所需的操作,然后在测试结束时清理该数据库。这种方式更接近真实的生产环境。</p>
<h3 id="使用mock数据库">使用mock数据库</h3>
<p>如<code>msql-srv</code>、<code>opensrv-clickhouse</code>、<code>opensrv-mysql</code>、</p>
<p>下面是一个使用集成测试数据库进行测试的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgRow};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_user_operations</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = create_test_pool().await;</div><div class="line"></div><div class="line">    <span class="comment">// 准备测试数据</span></div><div class="line">    sqlx::query(<span class="string">"CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT, email TEXT)"</span>)</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 插入新用户</span></div><div class="line">    <span class="keyword">let</span> name = <span class="string">"Test User"</span>.to_owned();</div><div class="line">    <span class="keyword">let</span> email = <span class="string">"test@example.com"</span>.to_owned();</div><div class="line">    <span class="keyword">let</span> id = insert_user(&pool, &name, &email).await;</div><div class="line"></div><div class="line">    <span class="comment">// 查询并验证用户数据</span></div><div class="line">    <span class="keyword">let</span> row: PgRow = sqlx::query_as(<span class="string">"SELECT id, name, email FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    assert_eq!(row.get::&lt;<span class="keyword">i32</span>, <span class="number">_</span>&gt;(<span class="number">0</span>), id);</div><div class="line">    assert_eq!(row.get::&lt;String, <span class="number">_</span>&gt;(<span class="number">1</span>), name);</div><div class="line">    assert_eq!(row.get::&lt;String, <span class="number">_</span>&gt;(<span class="number">2</span>), email);</div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">insert_user</span></span>(pool: &PgPool, name: &<span class="keyword">str</span>, email: &<span class="keyword">str</span>) -&gt; <span class="keyword">i32</span> {</div><div class="line">    sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(name)</div><div class="line">        .bind(email)</div><div class="line">        .fetch_one(pool)</div><div class="line">        .await</div><div class="line">        .unwrap()</div><div class="line">        .get(<span class="number">0</span>)</div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">create_test_pool</span></span>() -&gt; PgPool {</div><div class="line">    <span class="keyword">let</span> db_name = <span class="string">"test_database"</span>;</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(&format!(<span class="string">"postgres://postgres:@localhost/{}"</span>, db_name))</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 清理并重新创建测试数据库</span></div><div class="line">    sqlx::query(&format!(<span class="string">"DROP DATABASE IF EXISTS {}"</span>, db_name))</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line">    sqlx::query(&format!(<span class="string">"CREATE DATABASE {}"</span>, db_name))</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    pool</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们首先创建了一个专用的测试数据库。然后我们在这个数据库中创建了一个users表,并进行了插入、查询等操作,最后验证了查询结果。</p>
<h2 id="高级主题">高级主题</h2>
<p>除了基础功能外,sqlx还提供了一些高级功能,如自定义类型映射、编译时检查和性能分析等,可以进一步提高您的生产力和应用程序的性能。</p>
<h3 id="自定义类型映射">自定义类型映射</h3>
<p>sqlx允许您定义自定义的数据类型映射规则,将数据库中的数据类型映射到Rust中的类型。这对于处理一些特殊的数据类型或实现自定义的逻辑非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::types::Type;</div><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgTypeInfo, PgValueRef};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyType(String);</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Type&lt;PgTypeInfo&gt; <span class="keyword">for</span> MyType {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">type_info</span></span>() -&gt; PgTypeInfo {</div><div class="line">        PgTypeInfo::with_name(<span class="string">"mytype"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable_name</span></span>() -&gt; String {</div><div class="line">        <span class="string">"MyType"</span>.into()</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span>&lt;'r&gt; PgValueRef&lt;'r&gt; <span class="keyword">for</span> MyType {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_pg_value</span></span>(value: Option&lt;&'r [<span class="keyword">u8</span>]&gt;) -&gt; Option&lt;MyType&gt; {</div><div class="line">        value.map(|bytes| MyType(String::from_utf8_lossy(bytes).into_owned()))</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_pg_value</span></span>(&<span class="keyword">self</span>) -&gt; Option&lt;Vec&lt;<span class="keyword">u8</span>&gt;&gt; {</div><div class="line">        Some(<span class="keyword">self</span>.<span class="number">0</span>.as_bytes().to_vec())</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们定义了一个名为<code>MyType</code>的自定义数据类型,并实现了<code>Type</code>和<code>PgValueRef</code> trait。这样,我们就可以将数据库中的<code>mytype</code>类型映射到Rust中的<code>MyType</code>类型。</p>
<h3 id="编译时检查">编译时检查</h3>
<p>sqlx提供了一些宏和编译时检查功能,可以在编译时捕获一些错误,而不是在运行时才发现。这有助于提高代码质量和安全性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::query;</div><div class="line"></div><div class="line"><span class="preprocessor">#[rustfmt::skip]</span></div><div class="line"><span class="keyword">let</span> query = query!(</div><div class="line">    <span class="string">"</span></div><div class="line">    SELECT id, name, email</div><div class="line">    FROM users</div><div class="line">    WHERE id = ?</div><div class="line">    ",</div><div class="line">    <span class="number">42</span></div><div class="line">);</div></pre></td></tr></table></figure>

<p>上面的<code>query!</code>宏可以在编译时检查SQL语句的语法错误,并验证绑定参数的数量和类型。这样可以避免在运行时才发现这些问题。</p>
<p>类似的宏还有<code>query_as!</code>、<code>query_scalar!</code>、<code>query_file!</code>、<code>query_file!</code>、<code>query_file_scalar!</code>以及它们的变种<code>query_xxx_unchecked!</code>。</p>
<h3 id="执行时间">执行时间</h3>
<p>你可以通过计时来分析查询的性能,并根据结果进行优化。sqlx提供了一些工具来帮助您分析查询的性能,如<code>log_statements</code>、<code>log_slow_statements</code>等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::query;</div><div class="line"><span class="keyword">use</span> sqlx::postgres::PgQueryAs;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> query = query_as!(</div><div class="line">        User,</div><div class="line">        r#<span class="string">"</span></div><div class="line">        SELECT id, name, email</div><div class="line">        FROM users</div><div class="line">        WHERE id = $1</div><div class="line">        "#</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> time = std::time::Instant::now();</div><div class="line">        <span class="keyword">let</span> <span class="number">_u</span>sers: Vec&lt;User&gt; = query.bind(<span class="number">42</span>).fetch_all(&pool).await?;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> elapsed = time.elapsed();</div><div class="line">        println!(<span class="string">"Query attempt {attempt} took: {elapsed:?}"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="打印日志">打印日志</h3>
<p><code>ConnectOptions</code>提供了两个设置日志的方法：</p>
<ul>
<li>log_statements: 使用指定的级别打印执行语句</li>
<li>log_slow_statements: 使用指定的级别打印执行时间超过指定阈值的SQL语句。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .log_statements(log::LevelFilter::Debug) <span class="comment">// 记录所有SQL语句</span></div><div class="line">        .log_slow_statements(log::LevelFilter::Warn, std::time::Duration::from_millis(<span class="number">100</span>)) <span class="comment">// 记录执行时间超过100ms的慢查询</span></div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一些查询</span></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT 42"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"Result: {}"</span>, row.<span class="number">0</span>);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最佳实践和故障排除">最佳实践和故障排除</h2>
<p>再啰嗦几句。</p>
<p>在使用sqlx时,遵循一些最佳实践可以帮助您编写更加安全、高效和可维护的代码。此外,掌握一些常见错误和故障排除技巧也很有帮助。</p>
<h3 id="sqlx最佳实践">sqlx最佳实践</h3>
<ul>
<li>使用参数化查询: 始终使用带参数的查询,而不是字符串插值。这可以防止SQL注入攻击。</li>
<li>监控连接池指标: 监控连接池的指标,如活跃连接数、获取连接等待时间等,以确保连接池配置正确。</li>
<li>避免ORM: sqlx是一个查询构建器,而不是完整的对象关系映射(ORM)库。尽量避免在sqlx中复制ORM功能。</li>
<li>使用流式查询: 对于大型查询结果集,使用流式查询可以避免一次性加载所有数据到内存中。</li>
<li>利用编译时检查: 使用sqlx提供的query!和query_as!宏,可以在编译时捕获SQL语法错误和类型不匹配等问题。</li>
<li>测试覆盖: 为您的数据库交互代码编写单元测试和集成测试,以确保正确性和稳定性。</li>
</ul>
<h3 id="常见错误和故障排除">常见错误和故障排除</h3>
<ul>
<li>连接池耗尽: 如果出现&quot;连接池耗尽&quot;错误,可能是因为并发请求过多或连接池配置不当导致的。检查连接池指标并适当调整<code>max_connections</code>。</li>
<li>死锁: 在事务中执行多个查询时,可能会遇到死锁情况。确保正确使用事务,并实现重试逻辑。</li>
<li>类型不匹配: 如果遇到&quot;无法将PostgreSQL类型映射到Rust类型&quot;之类的错误,检查您的结构体字段类型是否与数据库列类型匹配。</li>
<li>SQL语法错误: 如果出现SQL语法错误,首先检查您是否使用了参数化查询。如果使用了query!宏,也可能是宏解析出现了问题。</li>
<li>查询性能差: 如果查询性能较差,可以使用sqlx提供的查询追踪功能分析查询执行情况,并优化慢查询。如果频繁创建连接，检查连接池配置是否合理，比如<code>min_connections</code>是否过小</li>
</ul>
<h3 id="生产就绪建议">生产就绪建议</h3>
<ul>
<li>启用日志记录: 在生产环境中合理启用sqlx的日志记录,以便更好地调试和监控应用程序。</li>
<li>监控指标: 监控数据库和连接池指标,如查询执行时间、错误率、连接池利用率等。</li>
<li>进行负载测试: 在部署之前,对您的应用程序进行全面的负载测试,以确保其能够在生产环境中良好运行。</li>
<li>实施安全最佳实践: 遵循安全最佳实践,如使用参数化查询、限制数据库权限、加密敏感数据等。</li>
<li>准备故障转移计划: 制定数据库故障转移计划,以确保应用程序在数据库出现故障时能够正常运行。</li>
<li>持续集成和交付: 将sqlx集成测试纳入您的持续集成和交付流程,以确保代码质量。</li>
</ul>
<h2 id="sqlx生态">sqlx生态</h2>
<p>有一些其他数据库的扩展和支持，比如<code>sqlx-rxqlite</code>、<code>sqlx-clickhouse-ext</code>。</p>
<p><code>sqlx-crud</code>提供常见的数据库操作的CRUD操作的derive宏:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"><span class="keyword">use</span> sqlx_crud::SqlxCrud;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug, FromRow, SqlxCrud)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    user_id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> Some(user) = User::by_id(&pool, <span class="number">42</span>) {</div><div class="line">    println!(<span class="string">"Found user user_id=42: {:?}"</span>, user);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sqlx-error</code>提供了对<code>sqlx::Error</code>的包装。</p>
<p>当然还有一些其他的库，不过当前关注度还不是很高。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的<a href="https://github.com/launchbadge/sqlx" target="_blank" rel="external">sqlx库</a>，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sqlx: 扩展标准sql库]]></title>
    <link href="https://colobu.com/2024/05/10/sqlx-a-brief-introduction/"/>
    <id>https://colobu.com/2024/05/10/sqlx-a-brief-introduction/</id>
    <published>2024-05-10T14:08:45.000Z</published>
    <updated>2024-08-09T06:26:33.875Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/jmoiron/sqlx" target="_blank" rel="external">sqlx</a>是一个用于扩展标准库database/sql的库，它提供了一些额外的功能，使得在Go中使用sql更加方便。sqlx的目标是保持database/sql的简单性，同时提供更多的功能。<br><a id="more"></a><br><code>sqlx</code> 为 Go 的标准 <code>database/sql</code> 库提供了一组扩展。sqlx 中的 <code>sql.Conn</code>、<code>sql.DB</code>、<code>sql.TX</code>、<code>sql.Stmt</code>、<code>sql.Rows</code>、<code>sql.Row</code> 等版本都保留了底层接口不变，因此它们的接口是标准接口的超集。这使得将使用 <code>database/sql</code> 的现有代码库与 <code>sqlx</code> 集成相对容易。</p>
<p>主要的额外概念有：</p>
<ul>
<li>将行映射到结构体（支持嵌入结构体）、Map和切片</li>
<li>支持命名参数，包括预编译语句</li>
<li>使用 <code>Get</code> 和 <code>Select</code> 快速从查询到结构体/切片</li>
</ul>
<p><code>sqlx</code> 的目的是无缝地封装 database/sql，并提供在开发数据库驱动的应用程序时有用的便捷方法。它不会改变任何底层的 <code>database/sql</code> 方法。相反，所有扩展行为都是通过在包装类型上定义的新方法来实现的。<br>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> {</div><div class="line">	*sql.Conn</div><div class="line">	driverName <span class="typename">string</span></div><div class="line">	unsafe     <span class="typename">bool</span></div><div class="line">	Mapper     *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> {</div><div class="line">	*sql.DB</div><div class="line">	driverName <span class="typename">string</span></div><div class="line">	unsafe     <span class="typename">bool</span></div><div class="line">	Mapper     *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> {</div><div class="line">	*sql.Stmt</div><div class="line">	unsafe <span class="typename">bool</span></div><div class="line">	Mapper *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> {</div><div class="line">	*sql.Tx</div><div class="line">	driverName <span class="typename">string</span></div><div class="line">	unsafe     <span class="typename">bool</span></div><div class="line">	Mapper     *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> Rows <span class="keyword">struct</span> {</div><div class="line">	*sql.Rows <span class="comment">// 嵌入</span></div><div class="line">	unsafe <span class="typename">bool</span></div><div class="line">	Mapper *reflectx.Mapper</div><div class="line">	<span class="comment">// these fields cache memory use for a rows during iteration w/ structScan</span></div><div class="line">	started <span class="typename">bool</span></div><div class="line">	fields  [][]<span class="typename">int</span></div><div class="line">	values  []<span class="keyword">interface</span>{}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，它的核心类型都是对标准库的封装，然后在此基础上提供了更多的功能。</p>
<p>它是2013年发布，已经有11年的历史了，也许为了保持兼容，它没有对泛型提供支持，甚至<code>interface{}</code>也没有改为<code>any</code>，还支持Go 1.10的版本。</p>
<p>本文假定你已经有了Go开发数据库程序的基础。如果你还不了解，建议你阅读下面的材料：</p>
<ul>
<li><a href="https://golang.org/pkg/database/sql/" target="_blank" rel="external">database/sql documentation</a></li>
<li><a href="http://go-database-sql.org/" target="_blank" rel="external">go-database-sql tutorial</a></li>
</ul>
<blockquote>
<p>本文是编译自作者写的<a href="https://jmoiron.github.io/sqlx/" target="_blank" rel="external">sqlx图解指南</a>。</p>
</blockquote>
<p>引入<code>sqlx</code>库以及sqlite3驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/jmoiron/sqlx</div><div class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/mattn/<span class="keyword">go</span>-sqlite3</div></pre></td></tr></table></figure>

<p><code>sqlx</code> 的设计初衷是让用户感觉与 <code>database/sql</code> 一样。它主要有 5 种 handler 类型：</p>
<ul>
<li><code>sqlx.Conn</code> - 类似于 <code>sql.Conn</code>，表示一个数据库连接</li>
<li><code>sqlx.DB</code> - 类似于 <code>sql.DB</code>，表示一个数据库连接池</li>
<li><code>sqlx.Tx</code> - 类似于 <code>sql.Tx</code>，表示一个事务</li>
<li><code>sqlx.Stmt</code> - 类似于 <code>sql.Stmt</code>，表示一个预处理语句</li>
<li><code>sqlx.NamedStmt</code> - 表示一个支持命名参数的预处理语句</li>
</ul>
<p>这些 handler 类型都嵌入了它们的 <code>database/sql</code>对应类型，这意味着当你调用 <code>sqlx.DB.Query</code> 时，你实际上调用的是与 <code>sql.DB.Query</code> 相同的代码。这使得它易于引入现有的代码库中。</p>
<p>除了这些，还有 2 种游标类型：</p>
<ul>
<li><code>sqlx.Rows</code> - 类似于 <code>sql.Rows</code>，是从 <code>Queryx</code> 返回的游标，多行结果</li>
<li><code>sqlx.Row</code> - 类似于 <code>sql.Row</code>，是从 <code>QueryRowx</code> 返回的结果,单行结果</li>
</ul>
<p>与 handler 类型一样，<code>sqlx.Rows</code> 嵌入了 <code>sql.Rows</code>。由于无法访问底层实现，<code>sqlx.Row</code> 是对 <code>sql.Row</code> 的部分重新实现，同时保留了标准接口。</p>
<h2 id="连接数据库">连接数据库</h2>
<p>一个 <code>DB</code> 实例并不是连接，而是一个表示数据库的抽象。这就是为什么创建 <code>DB</code> 时不会返回错误也不会引发恐慌（<code>panic</code>）。它在内部维护了一个连接池，并会在首次需要连接时尝试连接。你可以通过 <code>Open</code> 方法创建一个 <code>sqlx.DB</code>，或者通过 <code>NewDb</code> 方法从现有的 <code>sql.DB</code> 创建一个新的<code>sqlx.DB</code>  handler :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> db *sqlx.DB</div><div class="line"> </div><div class="line"><span class="comment">// 完全与内置的一样</span></div><div class="line">db = sqlx.Open(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 从现有的sql.DB创建一个新的sqlx.DB</span></div><div class="line">db = sqlx.NewDb(sql.Open(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>), <span class="string">"sqlite3"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 强制连接并测试是否成功</span></div><div class="line">err = db.Ping()</div></pre></td></tr></table></figure>

<p>在某些情况下，你可能希望同时打开数据库并建立连接，例如，在初始化阶段捕获配置问题。你可以使用 <code>Connect</code> 方法一次性完成这个操作，它会打开一个新的数据库并尝试进行 <code>Ping</code> 操作。<code>MustConnect</code> 变种在遇到错误时会触发 <code>panic</code>，适合在你的包的模块级别使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err error</div><div class="line"></div><div class="line"><span class="comment">// 打开并连接数据库</span></div><div class="line">db, err = sqlx.Connect(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 打开并连接数据库，遇到错误时触发panic</span></div><div class="line">db = sqlx.MustConnect(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div></pre></td></tr></table></figure>

<h2 id="基本查询">基本查询</h2>
<p><code>sqlx</code> 中的 handler 类型实现了与 <code>database/sql</code> 相同的基本动词来查询你的数据库：</p>
<ul>
<li><code>Exec(...) (sql.Result, error)</code> - 与 <code>database/sql</code> 中的方法没有变化</li>
<li><code>Query(...) (*sql.Rows, error)</code> - 与 <code>database/sql</code> 中的方法没有变化</li>
<li><code>QueryRow(...) *sql.Row</code> - 与 <code>database/sql</code> 中的方法没有变化</li>
</ul>
<p>以下是内置方法的扩展：</p>
<ul>
<li><code>MustExec() sql.Result</code> -- 执行 <code>Exec</code>，但遇到错误时会触发 <code>panic</code></li>
<li><code>Queryx(...) (*sqlx.Rows, error)</code> - 执行 <code>Query</code>，但返回一个 <code>sqlx.Rows</code></li>
<li><code>QueryRowx(...) *sqlx.Row</code> -- 执行 <code>QueryRow</code>，但返回一个 <code>sqlx.Row</code></li>
</ul>
<p>还有以下新的语义：</p>
<ul>
<li><code>Get(dest interface{}, ...) error</code></li>
<li><code>Select(dest interface{}, ...) error</code></li>
</ul>
<p>现在，我们从未改变的接口开始，一直介绍到新的语义，并解释它们的使用方法。</p>
<h3 id="执行_Exec">执行 Exec</h3>
<p><code>Exec</code> 和 <code>MustExec</code> 从连接池中获取一个连接，并在服务器上执行提供的语句。对于不支持即席（ad-hoc）查询执行的驱动程序，可能会在幕后创建一个预处理语句来执行。在返回结果之前，连接会被返回到连接池中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">schema := <span class="string">`CREATE TABLE place (</span></div><div class="line">    country text,</div><div class="line">    city text NULL,</div><div class="line">    telcode integer);`</div><div class="line"> </div><div class="line"><span class="comment">// 执行一个查询</span></div><div class="line">result, err := db.Exec(schema)</div><div class="line"> </div><div class="line"><span class="comment">// 或者，你可以使用MustExec，在错误时会触发panic</span></div><div class="line">cityState := <span class="string">`INSERT INTO place (country, telcode) VALUES (?, ?)`</span></div><div class="line">countryCity := <span class="string">`INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)`</span></div><div class="line">db.MustExec(cityState, <span class="string">"Hong Kong"</span>,<span class="number"> 852</span>)</div><div class="line">db.MustExec(cityState, <span class="string">"Singapore"</span>,<span class="number"> 65</span>)</div><div class="line">db.MustExec(countryCity, <span class="string">"South Africa"</span>, <span class="string">"Johannesburg"</span>,<span class="number"> 27</span>)</div></pre></td></tr></table></figure>

<p><code>Result</code>有两种可能的数据：<code>LastInsertId()</code> 或 <code>RowsAffected()</code>，这些数据的可用性取决于驱动程序。例如，在 MySQL 中，如果插入的表有自增主键，则 <code>LastInsertId()</code> 将可用，但在 PostgreSQL 中，这些信息只能通过使用 <code>RETURNING</code> 子句从普通行游标中检索。</p>
<h4 id="绑定变量_bindvars">绑定变量 bindvars</h4>
<p>内部称为绑定变量的 <code>?</code> 查询占位符非常重要；您应该始终使用这些占位符向数据库发送值，因为它们可以防止 SQL 注入攻击。<code>database/sql</code> 不会对查询文本进行任何验证；它会原样发送到服务器，同时发送编码后的参数。除非驱动程序实现了特殊接口，否则查询会在执行之前先在服务器上准备。因此，绑定变量是特定于数据库的：</p>
<ul>
<li>MySQL 使用上面展示的 <code>?</code> 变体</li>
<li>PostgreSQL 使用枚举的 <code>$1</code>,<code>$2</code>等绑定变量语法</li>
<li>SQLite 接受 <code>?</code> 和 <code>$1</code> 语法</li>
<li>Oracle 使用 <code>:name</code> 语法</li>
<li>其他数据库可能有所不同。您可以使用 <code>sqlx.DB.Rebind(string) string</code>函数和 <code>?</code> 绑定变量语法来获取适合在当前数据库类型上执行的查询。<br>关于绑定变量的一个常见误解是它们用于插值。它们仅用于参数化，并且<a href="https://use-the-index-luke.com/sql/where-clause/bind-parameters" target="_blank" rel="external">不允许</a>更改 SQL 语句的结构。例如，使用绑定变量来尝试参数化列名或表名将无法工作：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无法工作</span></div><div class="line">db.Query(<span class="string">"SELECT * FROM ?"</span>, <span class="string">"mytable"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 也无法工作</span></div><div class="line">db.Query(<span class="string">"SELECT ?, ? FROM people"</span>, <span class="string">"name"</span>, <span class="string">"location"</span>)</div></pre></td></tr></table></figure>

<h3 id="查询_Query">查询 Query</h3>
<p><code>Query</code> 是使用 <code>database/sql</code> 执行查询并返回行结果的主要方法。<code>Query</code> 返回一个 <code>sql.Rows</code> 对象和一个错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从数据库获取所有地点</span></div><div class="line">rows, err := db.Query(<span class="string">"SELECT country, city, telcode FROM place"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 遍历每一行</span></div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="keyword">var</span> country <span class="typename">string</span></div><div class="line">    <span class="comment">// 注意city可能为NULL，所以我们使用NullString类型</span></div><div class="line">    <span class="keyword">var</span> city    sql.NullString</div><div class="line">    <span class="keyword">var</span> telcode <span class="typename">int</span></div><div class="line">    err = rows.Scan(&country, &city, &telcode)</div><div class="line">}</div><div class="line"><span class="comment">// 检查错误</span></div><div class="line">err = rows.Err()</div></pre></td></tr></table></figure>

<p>你应该把 <code>Rows</code> 当作数据库游标来处理，而不是一个具体化的结果列表。尽管驱动程序缓冲行为可能有所不同，但通过 <code>Next()</code> 进行迭代是限制大型结果集内存使用量的好方法，因为你一次只扫描一行。<code>Scan()</code> 使用反射将 SQL 列返回类型映射到 Go 类型，如 <code>string</code>、<code>[]byte</code> 等。如果你没有遍历完整个结果集，请确保调用 <code>rows.Close()</code> 将连接返回给连接池！</p>
<p><code>Query</code> 返回的错误是可能在服务器准备或执行期间发生的任何错误。这可能包括从连接池中获取了有问题的连接，尽管 <code>database/sql</code> 会重试 <a href="https://golang.org/src/pkg/database/sql/sql.go?s=23888:23957#L885" target="_blank" rel="external">10 次</a>以尝试找到或创建一个工作连接。一般来说，错误会由于错误的 SQL 语法、类型不匹配或不正确的字段和表名导致。</p>
<p>在大多数情况下，<code>Rows.Scan</code> 会复制它从驱动程序获取的数据，因为它不知道驱动程序如何重用其缓冲区。可以使用特殊类型 <code>sql.RawBytes</code> 来从驱动程序实际返回的数据中获取零拷贝的字节切片。在下次调用 <code>Next()</code> 之后，这样的值将不再有效，因为驱动程序可能已经覆盖了那段内存。</p>
<p><code>Query</code> 使用的连接在通过 Next 迭代完所有行之前或调用 <code>rows.Close()</code> 之后一直保持活动状态，之后该连接将被释放。有关更多信息，请参阅关于<a href="https://jmoiron.github.io/sqlx/#connectionPool" target="_blank" rel="external">连接池</a>的部分。</p>
<p><code>sqlx</code> 扩展的 <code>Queryx</code> 行为与 <code>Query</code> 完全一样，但返回的是 <code>sqlx.Rows</code>，它具有扩展的扫描行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Place <span class="keyword">struct</span> {</div><div class="line">    Country       <span class="typename">string</span></div><div class="line">    City          sql.NullString</div><div class="line">    TelephoneCode <span class="typename">int</span> <span class="string">`db:"telcode"`</span></div><div class="line">}</div><div class="line"> </div><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="keyword">var</span> p Place</div><div class="line">    err = rows.StructScan(&p)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sqlx.Rows</code> 的主要扩展方法是 <code>StructScan()</code>，它可以自动将查询结果扫描到结构体的字段中。请注意，为了让 <code>sqlx</code> 能够写入这些字段，这些字段必须是导出的（即首字母大写），这是 Go 中所有序列化器（<code>marshaller</code>）的共同要求。你可以使用 <code>db</code> 结构标签来指定哪个列名映射到结构体的哪个字段，或者使用 <code>db.MapperFunc()</code> 设置新的默认映射规则。默认行为是使用 <code>strings.ToLower</code> 对字段名进行小写转换以匹配列名。有关 <code>StructScan</code>、<code>SliceScan</code> 和 <code>MapScan</code> 的更多信息，请参阅高级扫描部分。</p>
<h2 id="查询单行_QueryRow">查询单行 QueryRow</h2>
<p><code>QueryRow</code> 从服务器获取一行数据。它从连接池中获取一个连接，并使用 <code>Query</code> 执行查询，返回一个 <code>Row</code> 对象，该对象具有自己的内部 <code>Rows</code> 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">row := db.QueryRow(<span class="string">"SELECT * FROM place WHERE telcode=?"</span>,<span class="number"> 852</span>)</div><div class="line"><span class="keyword">var</span> telcode <span class="typename">int</span></div><div class="line">err = row.Scan(&telcode)</div></pre></td></tr></table></figure>

<p>与 <code>Query</code> 不同，<code>QueryRow</code> 返回一个 <code>Row</code> 类型的结果而不返回错误，这使得可以安全地从返回结果中链式调用 <code>Scan</code> 方法。如果执行查询时发生错误，该错误将由 <code>Scan</code> 返回。如果没有行，<code>Scan</code> 会返回 <code>sql.ErrNoRows</code>。如果扫描本身失败（例如，由于类型不匹配），也会返回该错误。</p>
<p><code>Row</code> 结果内部的 <code>Rows</code> 结构在 <code>Scan</code> 时会被关闭，这意味着 <code>QueryRow</code> 使用的连接会在结果被扫描之前一直保持打开状态。这也意味着 <code>sql.RawBytes</code> 在这里不可用，因为引用的内存属于驱动程序，在控制权返回给调用者时可能已经无效。</p>
<p><code>sqlx</code> 扩展的 <code>QueryRowx</code> 将返回一个<code>sqlx.Row</code> 而不是 <code>sql.Row</code>，它实现了与 <code>Rows</code> 相同的扫描扩展，上面已经说过，并在高级扫描部分有详细解释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p Place</div><div class="line">err := db.QueryRowx(<span class="string">"SELECT city, telcode FROM place LIMIT 1"</span>).StructScan(&p)</div></pre></td></tr></table></figure>

<h2 id="Get_和_Select">Get 和 Select</h2>
<p><code>Get</code> 和 <code>Select</code> 是针对 handler 类型的省时的扩展，它们将查询执行与灵活的扫描语义结合起来。为了清楚地解释它们，我们需要谈谈什么是可扫描的：</p>
<ul>
<li>如果一个值不是结构体，比如字符串（<code>string</code>）、整数（<code>int</code>），那么它就是可扫描的。</li>
<li>如果一个值实现了 <code>sql.Scanner</code> 接口，那么它就是可扫描的。</li>
<li>如果一个值是结构体，但没有导出的字段（例如 <code>time.Time</code>），那么它也是可扫描的。</li>
</ul>
<p><code>Get</code> 和 <code>Select</code> 在可扫描类型上使用 <code>rows.Scan</code>，在非可扫描类型上使用 <code>rows.StructScan</code>。它们大致分别对应于 <code>QueryRow</code> 和 <code>Query</code>，其中 <code>Get</code> 用于获取单个结果并进行扫描，而 <code>Select</code> 用于获取结果的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">p := Place{}</div><div class="line">pp := []Place{}</div><div class="line"> </div><div class="line"><span class="comment">//这将直接将第一个地点拉取到p中</span></div><div class="line">err = db.Get(&p, <span class="string">"SELECT * FROM place LIMIT 1"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 这将把telcode大于50的地点拉取到切片pp中</span></div><div class="line">err = db.Select(&pp, <span class="string">"SELECT * FROM place WHERE telcode &gt; ?"</span>,<span class="number"> 50</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 也可以使用普通类型</span></div><div class="line"><span class="keyword">var</span> id <span class="typename">int</span></div><div class="line">err = db.Get(&id, <span class="string">"SELECT count(*) FROM place"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 获取最多10个地点名称</span></div><div class="line"><span class="keyword">var</span> names []<span class="typename">string</span></div><div class="line">err = db.Select(&names, <span class="string">"SELECT name FROM place LIMIT 10"</span>)</div></pre></td></tr></table></figure>

<blockquote>
<p>这两个方法基本可以把我前一篇封装的helper函数替代掉了。</p>
</blockquote>
<p><code>Get</code> 和 <code>Select</code> 都会在查询执行过程中关闭它们创建的 <code>Rows</code>，并返回在此过程中任何步骤遇到的错误。由于它们内部使用 <code>StructScan</code>，因此高级扫描部分中的细节也适用于 <code>Get</code> 和 <code>Select</code>。</p>
<p><code>Select</code> 可以为您节省大量输入，但要小心！它在语义上与 <code>Queryx</code> 不同，因为<strong>它会一次性将整个结果集加载到内存中</strong>。如果查询没有将结果集限制在合理的大小，那么最好使用经典的 <code>Queryx/StructScan</code> 迭代方式。</p>
<blockquote>
<p>试想你要处理几千万行的数据，一条一条的拉取和处理，比一次性读入到内存中处理，资源使用更友好。</p>
</blockquote>
<h2 id="事务_Transaction">事务 Transaction</h2>
<p>要使用事务，您必须使用 <code>DB.Begin()</code> 创建一个事务 handler 。像这样的代码将不会工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这将不会工作，如果连接池&gt;1</span></div><div class="line">db.MustExec(<span class="string">"BEGIN;"</span>)</div><div class="line">db.MustExec(...)</div><div class="line">db.MustExec(<span class="string">"COMMIT;"</span>)</div></pre></td></tr></table></figure>

<p>请记住，<code>Exec</code> 和其他所有查询动词每次都会向数据库请求一个连接，并在使用后将其返回给连接池。因此，无法保证您会收到执行 <code>BEGIN</code> 语句时使用的同一个连接。要使用事务，您必须使用<code>DB.Begin()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tx, err := db.Begin()</div><div class="line">err = tx.Exec(...)</div><div class="line">err = tx.Commit()</div></pre></td></tr></table></figure>

<p><code>DB</code>  handler 还有 <code>Beginx()</code> 和 <code>MustBegin()</code> 扩展方法，它们返回一个 <code>sqlx.Tx</code> 而不是 <code>sql.Tx</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tx := db.MustBegin()</div><div class="line">tx.MustExec(...)</div><div class="line">err = tx.Commit()</div></pre></td></tr></table></figure>

<p><code>sqlx.Tx</code> 拥有 <code>sqlx.DB</code> 的所有 handler 扩展。</p>
<p>由于事务是连接状态，<code>Tx</code> 对象必须从连接池中绑定并控制一个单一的连接。在整个生命周期中，<code>Tx</code> 将维持这个单一的连接，只有在调用 <code>Commit()</code> 或 <code>Rollback()</code> 时才会释放它。你应该至少调用这两个函数之一，否则连接将一直被占用，直到垃圾收集器回收。</p>
<p>因为在一个事务中你只能使用一个连接，所以你一次只能执行一个语句；在执行另一个查询之前，必须分别扫描或关闭 <code>Row</code> 和 <code>Rows</code> 类型的游标。如果你尝试在服务器向你发送结果时向服务器发送数据，它可能会破坏连接。</p>
<p>最后，<code>Tx</code> 对象并不实际上在服务器上执行任何行为；它们只是执行一个 <code>BEGIN</code> 语句并绑定一个单一的连接。事务的实际行为，包括锁定和隔离等，完全是未指定的，并且依赖于数据库。</p>
<h2 id="预编译语句_Prepared_Statement">预编译语句 Prepared Statement</h2>
<p>在大多数数据库中，当执行查询时，实际上会在幕后准备语句。但是，您也可以使用 <code>sqlx.DB.Prepare()</code> 明确地准备语句以便在其他地方重用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stmt, err := db.Prepare(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line">row = stmt.QueryRow<span class="number">(65</span>)</div><div class="line"> </div><div class="line">tx, err := db.Begin()</div><div class="line">txStmt, err := tx.Prepare(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line">row = txStmt.QueryRow<span class="number">(852</span>)</div></pre></td></tr></table></figure>

<p><code>Prepare</code> 实际上是在数据库上执行准备操作的，因此它需要一个连接和连接状态。<code>database/sql</code> 为你抽象了这些，允许你通过在新连接上自动创建语句，从单个 <code>Stmt</code> 对象在多个连接上并发执行。<code>Preparex()</code> 返回一个 <code>sqlx.Stmt</code>，它拥有 <code>sqlx.DB</code> 和 <code>sqlx.Tx</code>的所有 handler 扩展功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stmt, err := db.Preparex(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line"><span class="keyword">var</span> p Place</div><div class="line">err = stmt.Get(&p,<span class="number"> 852</span>)</div></pre></td></tr></table></figure>

<p>标准的 <code>sql.Tx</code> 对象还有一个 <code>Stmt()</code> 方法，该方法可以从预先存在的语句中返回一个特定于事务的语句。<code>sqlx.Tx</code> 有一个 <code>Stmtx</code> 版本，可以从现有的 <code>sql.Stmt</code> 或 <code>sqlx.Stmt</code> 创建一个新的特定于事务的 <code>sqlx.Stmt</code>。</p>
<h2 id="查询辅助方法_Query_Helper">查询辅助方法 Query Helper</h2>
<p><code>database/sql</code> 包不会对您的实际查询文本进行任何处理。这使得在您的代码中使用特定于后端的特性变得轻而易举；您可以像在数据库提示符中一样编写查询。虽然这非常灵活，但它使得编写某些类型的查询变得困难。</p>
<h3 id="&quot;In&quot;_子句">&quot;In&quot; 子句</h3>
<p>由于 <code>database/sql</code> 不会检查您的查询，而是直接将参数传递给驱动程序，因此处理带有 <code>IN</code> 子句的查询会变得困难：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM users WHERE level IN (?);</div></pre></td></tr></table></figure>

<p>当在后端将其准备为语句时，绑定变量 ? 只会对应一个参数，但通常我们希望它根据某个切片的长度来对应可变数量的参数，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levels = []<span class="typename">int</span><span class="number">{4</span>,<span class="number"> 6</span>,<span class="number"> 7</span>}</div><div class="line">rows, err := db.Query(<span class="string">"SELECT * FROM users WHERE level IN (?);"</span>, levels)</div></pre></td></tr></table></figure>

<p>通过使用 sqlx.In 预先处理查询语句，可以实现这种模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levels = []<span class="typename">int</span><span class="number">{4</span>,<span class="number"> 6</span>,<span class="number"> 7</span>}</div><div class="line">query, args, err := sqlx.In(<span class="string">"SELECT * FROM users WHERE level IN (?);"</span>, levels)</div><div class="line"> </div><div class="line"><span class="comment">// sqlx.In返回带有`?`绑定变量的查询，我们可以重新绑定它以适应我们的后端</span></div><div class="line">query = db.Rebind(query)</div><div class="line">rows, err := db.Query(query, args...)</div></pre></td></tr></table></figure>

<p>使用 <code>sqlx.In</code> 预先处理查询语句可以实现这种模式：<code>sqlx.In</code> 会扩展传递给它的查询中的任何绑定变量（<code>bindvars</code>），这些绑定变量对应于参数中的切片，并扩展到与切片长度相同数量的占位符，然后将这些切片元素追加到一个新的参数列表中。它仅对 <code>?</code> 绑定变量执行此操作；您可以使用 <code>db.Rebind</code> 来获取适合您后端的查询语句。</p>
<h3 id="命名查询_Named_Query">命名查询 Named Query</h3>
<p>命名查询在许多其他数据库包中都很常见。它们允许您使用绑定变量语法，该语法通过结构体字段的名称或映射键来绑定查询中的变量，而不是按位置引用所有内容。结构体字段的命名约定遵循 <code>StructScan</code> 的规则，使用 <code>NameMapper</code> 和 <code>db</code> 结构体标签。与命名查询相关的有两个额外的查询动词：</p>
<ul>
<li><code>NamedQuery(...) (*sqlx.Rows, error)</code> - 类似于 Queryx，但使用命名绑定变量</li>
<li><code>NamedExec(...) (sql.Result, error)</code> - 类似于 Exec，但使用命名绑定变量</li>
</ul>
<p>还有一个额外的 handler 类型：</p>
<ul>
<li><code>NamedStmt</code> - 一个 <code>sqlx.Stmt</code>，可以使用命名绑定变量进行准备</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用结构体的命名查询</span></div><div class="line">p := Place{Country: <span class="string">"South Africa"</span>}</div><div class="line">rows, err := db.NamedQuery(<span class="string">`SELECT * FROM place WHERE country=:country`</span>, p)</div><div class="line"> </div><div class="line"><span class="comment">// 使用map的命名查询</span></div><div class="line">m := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}{<span class="string">"city"</span>: <span class="string">"Johannesburg"</span>}</div><div class="line">result, err := db.NamedExec(<span class="string">`SELECT * FROM place WHERE city=:city`</span>, m)</div></pre></td></tr></table></figure>

<p>命名查询的执行和准备适用于结构体和Map。如果你想要完整的查询操作集，可以准备一个命名语句并使用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p := Place{TelephoneCode:<span class="number"> 50</span>}</div><div class="line">pp := []Place{}</div><div class="line"> </div><div class="line"><span class="comment">// 查询所有telcode大于50的地点</span></div><div class="line">nstmt, err := db.PrepareNamed(<span class="string">`SELECT * FROM place WHERE telcode &gt; :telcode`</span>)</div><div class="line">err = nstmt.Select(&pp, p)</div></pre></td></tr></table></figure>

<p>命名查询支持是通过解析查询中的 <code>:param</code> 语法，并将其替换为底层数据库支持的绑定变量来实现的，然后在执行时执行映射，因此它可以在 <code>sqlx</code> 支持的任何数据库上使用。你还可以使用 <code>sqlx.Named</code>，它使用 <code>?</code> 绑定变量，并且可以与 <code>sqlx.In</code> 组合使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arg := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}{</div><div class="line">    <span class="string">"published"</span>: <span class="constant">true</span>,</div><div class="line">    <span class="string">"authors"</span>: []<span class="number">{8</span>,<span class="number"> 19</span>,<span class="number"> 32</span>,<span class="number"> 44</span>},</div><div class="line">}</div><div class="line">query, args, err := sqlx.Named(<span class="string">"SELECT * FROM articles WHERE published=:published AND author_id IN (:authors)"</span>, arg)</div><div class="line">query, args, err := sqlx.In(query, args...)</div><div class="line">query = db.Rebind(query)</div><div class="line">db.Query(query, args...)</div></pre></td></tr></table></figure>

<h2 id="高级扫描_Advanced_Scanning">高级扫描 Advanced Scanning</h2>
<p><code>StructScan</code> 相当复杂但具有欺骗性。它支持嵌入的结构体，并使用与 Go 用于嵌入属性和方法访问相同的优先级规则为字段赋值。这种用法的一个常见例子是在多个表之间共享表模型的公共部分，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> AutoIncr <span class="keyword">struct</span> {</div><div class="line">    ID       <span class="typename">uint64</span></div><div class="line">    Created  time.Time</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">type</span> Place <span class="keyword">struct</span> {</div><div class="line">    Address <span class="typename">string</span></div><div class="line">    AutoIncr</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</div><div class="line">    Name <span class="typename">string</span></div><div class="line">    AutoIncr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用上述结构体，<code>Person</code> 和 <code>Place</code> 都能够从 <code>StructScan</code> 中接收 <code>id</code> 和 <code>created</code> 列，因为它们都嵌入了定义了这些列的 <code>AutoIncr</code> 结构体。这个功能可以让你快速地为连接操作创建一个临时的表。它还可以递归地工作；以下结构体可以通过 Go 的点运算符和 <code>StructScan</code> 访问 <code>Person</code> 的 <code>Name</code> <code>字段、AutoIncr</code> 的 <code>ID</code> 和 <code>Created</code> 字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> {</div><div class="line">    BossID <span class="typename">uint64</span></div><div class="line">    EmployeeID <span class="typename">uint64</span></div><div class="line">    Person</div><div class="line">}</div></pre></td></tr></table></figure>

<p>请注意，<code>sqlx</code> 历史上一度支持此功能用于非嵌入结构体，但这最终变得令人困惑，因为用户使用此功能来定义关系，并两次嵌入相同的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> {</div><div class="line">    Father Person</div><div class="line">    Mother Person</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这会引起一些问题。在 Go 语言中，隐藏后代字段是合法的；如果嵌入示例中的 <code>Employee</code> 定义了一个 <code>Name</code> 字段，那么它会优先于 <code>Person</code> 的 <code>Name</code> 字段。但是，模糊的选择器是非法的，并且会导致运行时错误。如果我们想为 <code>Person</code> 和 <code>Place</code> 创建一个快速的 <code>JOIN</code> 类型，那么我们应该在哪里放置 <code>id</code> 列，这两个类型都通过嵌入的 <code>AutoIncr</code> 定义了 <code>id</code> 列？是否会出现错误？</p>
<p>由于 <code>sqlx</code> 构建字段名到字段地址映射的方式，在将结果扫描到结构体时，它不再知道在遍历结构体树时是否遇到过两次相同的字段名。因此，与 Go <code>语言不同，StructScan</code> 会选择遇到的<strong>第一个具有该名称的字段</strong>。由于 Go 语言的结构体字段是从上到下排序的，而 <code>sqlx</code> 为了保持优先级规则，采用广度优先遍历，因此会选择<strong>最浅、最顶部</strong>的定义。例如，在以下类型中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PersonPlace <span class="keyword">struct</span> {</div><div class="line">    Person</div><div class="line">    Place</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>StructScan</code> 会将 <code>id</code> 列的结果设置在 <code>Person.AutoIncr.ID</code> 中，也可以通过 <code>Person.ID</code> 访问。为了避免混淆，建议你在 <code>SQL</code> 中使用 <code>AS</code> 来创建列别名。</p>
<h3 id="安全扫描目的字段">安全扫描目的字段</h3>
<p>默认情况下，如果某一列无法映射到目标结构体中的字段，<code>StructScan</code> 将返回一个错误。这模仿了 Go 中对未使用变量的处理方式，但与标准库中的序列化器（如 <code>encoding/json</code>）的行为不符。由于 SQL 通常以比解析 JSON 更受控的方式执行，并且这些错误通常是编码错误，因此决定默认返回错误。</p>
<p>与未使用的变量类似，忽略的列会浪费网络和数据库资源，而且在没有映射器通知未找到某些内容的情况下，很难在早期检测到不兼容的映射或结构标签中的拼写错误。</p>
<p>尽管如此，在某些情况下，可能希望忽略没有目标字段的列。为此，每种 Handle 类型都有一个 Unsafe 方法，它返回该 handler 的新副本，并关闭此安全检查：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p Person</div><div class="line"><span class="comment">// 由于place列没有字段目标，所以这里的err不是nil</span></div><div class="line">err = db.Get(&p, <span class="string">"SELECT * FROM person, place LIMIT 1;"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 这不会返回错误，即使place列没有目标</span></div><div class="line">udb := db.Unsafe()</div><div class="line">err = udb.Get(&p, <span class="string">"SELECT * FROM person, place LIMIT 1;"</span>)</div></pre></td></tr></table></figure>

<h3 id="控制命名映射">控制命名映射</h3>
<p>用作 <code>StructScan</code> 目标的结构体字段必须大写以便 <code>sqlx</code> 能够访问。因此，<code>sqlx</code> 使用了一个 <code>NameMapper</code>，该映射器将字段名应用 <code>strings.ToLower</code> 函数以将它们映射到行结果中的列。但是，这并不总是符合需求的，这取决于你的数据库模式，因此 <code>sqlx</code> 允许以多种方式自定义映射。</p>
<p>最简单的方式是通过使用 <code>sqlx.DB.MapperFunc</code> 为数据库 handler 设置映射器，该方法接收一个类型为 <code>func(string) string</code> 的参数。如果你的库需要特定的映射器，并且你不想污染你接收到的 <code>sqlx.DB</code>，你可以为库创建一个副本以确保使用特定的默认映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果我们的数据库模式使用大写列，我们可以使用普通字段</span></div><div class="line">db.MapperFunc(strings.ToUpper)</div><div class="line"> </div><div class="line"><span class="comment">// 假定一个库使用小写列，我们可以创建一个副本</span></div><div class="line"><span class="built_in">copy</span> := sqlx.NewDb(db.DB, db.DriverName())</div><div class="line"><span class="built_in">copy</span>.MapperFunc(strings.ToLower)</div></pre></td></tr></table></figure>

<p>每个 <code>sqlx.DB</code> 使用 <code>sqlx/reflectx</code> 包的 <code>Mapper</code> 来实现这种映射，并将活动的映射器公开为 <code>sqlx.DB.Mapper</code>。你可以通过直接设置来进一步自定义 DB 上的映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/jmoiron/sqlx/reflectx"</span></div><div class="line"> </div><div class="line"><span class="comment">// 创建一个新的映射器，它将使用结构字段标签“json”而不是“db”</span></div><div class="line">db.Mapper = reflectx.NewMapperFunc(<span class="string">"json"</span>, strings.ToLower)</div></pre></td></tr></table></figure>

<h3 id="替代扫描类型">替代扫描类型</h3>
<p>除了使用 <code>Scan</code> 和 <code>StructScan`</code>，sqlx<code>的</code>Row<code>或</code>Rows` 还可以用于自动返回结果切片或Map：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="comment">// cols 代表所有列结果的[]interface{}</span></div><div class="line">    cols, err := rows.SliceScan()</div><div class="line">}</div><div class="line"> </div><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{})</div><div class="line">    err = rows.MapScan(results)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>SliceScan</code> 返回一个 <code>[]interface{}</code>，其中包含所有列的数据，这在你代表第三方执行查询且无法知道可能会返回哪些列的情况下非常有用。<code>MapScan</code> 的行为类似，但它将列名映射到 <code>interface{}</code> 类型的值上。这里有一个重要的注意事项：<code>rows.Columns()</code>返回的结果不包括完全限定的名称，因此执行如 <code>SELECT a.id, b.id FROM a NATURAL JOIN b</code> <code>的查询时，Columns</code> 的结果将是 <code>[]string{&quot;id&quot;, &quot;id&quot;}</code>，这会导致你的Map中其中一个结果会被覆盖。</p>
<h2 id="自定义类型">自定义类型</h2>
<p>上面的例子都使用了内置类型来进行扫描和查询，但 <code>database/sql</code> 提供了接口，允许你使用任何自定义类型：</p>
<ul>
<li><code>sql.Scanner</code> 允许你在 <code>Scan()</code> 中使用自定义类型</li>
<li><code>driver.Valuer</code> 允许你在 <code>Query/QueryRow/Exec</code> 中使用自定义类型</li>
</ul>
<p>这些是标准接口，使用它们可以确保与任何可能在 <code>database/sql</code> 之上提供服务的库的兼容性。要详细了解如何使用它们，请阅读<a href="http://jmoiron.net/blog/built-in-interfaces" target="_blank" rel="external">这篇博客文章</a>或查看 <a href="https://github.com/jmoiron/sqlx/blob/master/types/types.go" target="_blank" rel="external">sqlx/types</a> 包，该包实现了一些标准的有用类型。</p>
<h2 id="连接池">连接池</h2>
<p>语句准备和查询执行需要一个连接，DB 对象将管理一个连接池，以便它可以安全地用于并发查询。在 Go 1.2 及更高版本中，有两种方式控制连接池的大小：</p>
<ul>
<li>DB.SetMaxIdleConns(n int)</li>
<li>DB.SetMaxOpenConns(n int)</li>
</ul>
<p>默认情况下，连接池会无限制地增长，并且当池中没有空闲连接可用时，就会创建新的连接。你可以使用 <code>DB.SetMaxOpenConns</code> 来设置池的最大大小。未被使用的连接会被标记为空闲状态，如果不再需要，它们就会被关闭。为了避免频繁地创建和关闭连接，请使用 <code>DB.SetMaxIdleConns</code> 将最大空闲大小设置为适合你的查询负载的大小。</p>
<p>如果不小心持有连接，很容易遇到麻烦。为了避免这种情况：</p>
<ul>
<li>确保你使用 <code>Scan()</code> 扫描每个 <code>Row</code> 对象</li>
<li>确保你通过 <code>Close()</code> 或完全迭代 <code>Next()</code> 来处理每个 <code>Rows</code> 对象</li>
<li>确保每个事务都通过 <code>Commit()</code> 或 <code>Rollback()</code> 返回其连接</li>
</ul>
<p>如果你忽略了这些操作中的任何一个，它们所使用的连接可能会被保持到垃圾回收，而你的数据库将最终创建大量连接以补偿正在使用的连接。请注意，<code>Rows.Close()</code> 可以安全地多次调用，因此不必担心在可能不必要的地方调用它。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/jmoiron/sqlx" target="_blank" rel="external">sqlx</a>是一个用于扩展标准库database/sql的库，它提供了一些额外的功能，使得在Go中使用sql更加方便。sqlx的目标是保持database/sql的简单性，同时提供更多的功能。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
