<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://colobu.com/"/>
  <updated>2024-07-04T05:54:56.943Z</updated>
  <id>https://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Redka - 父亲是Redis，母亲是SQLite]]></title>
    <link href="https://colobu.com/2024/06/04/redka-redis-with-sqlite/"/>
    <id>https://colobu.com/2024/06/04/redka-redis-with-sqlite/</id>
    <published>2024-06-03T23:28:39.000Z</published>
    <updated>2024-07-03T03:41:24.521Z</updated>
    <content type="html"><![CDATA[<p>Redka旨在使用SQLite重新实现Redis的优秀部分,同时保持与Redis API的兼容性。</p>
<p>有意思的特性:</p>
<ul>
<li>数据不必完全装载在内存中。</li>
<li>支持ACID事务。</li>
<li>使用SQL视图以便于内省和报告。</li>
<li>同时提供进程内(Go API)和独立(RESP)服务器。</li>
<li>兼容Redis的命令和线路协议。</li>
</ul>
<p>Redia 并不期望完全达到 Redis 那么高的性能，但是性能上也并不会落后很多。它的主要功能还是 SQL + Redis 的功能，集成了两种优秀产品 SQLite 和 Redis 的盛世美颜。</p>
<a id="more"></a>
<h2 id="支持的_Redis_命令">支持的 Redis 命令</h2>
<h3 id="字符串">字符串</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Command      Go API                 Description</div><div class="line"><span class="comment">-------      ------                 -----------</span></div><div class="line">DECR         DB.Str().Incr          Decrements <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="constant">one</span>.</div><div class="line">DECRBY       DB.Str().Incr          Decrements <span class="operator">a</span> <span class="built_in">number</span> <span class="built_in">from</span> <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">GET          DB.Str().Get           Returns <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">GETSET       DB.Str().SetWith       Sets <span class="operator">the</span> key <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">new</span> <span class="built_in">value</span> <span class="operator">and</span> returns <span class="operator">the</span> prev <span class="built_in">value</span>.</div><div class="line">INCR         DB.Str().Incr          Increments <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="constant">one</span>.</div><div class="line">INCRBY       DB.Str().Incr          Increments <span class="operator">the</span> <span class="keyword">integer</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="operator">a</span> <span class="built_in">number</span>.</div><div class="line">INCRBYFLOAT  DB.Str().IncrFloat     Increments <span class="operator">the</span> float <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key <span class="keyword">by</span> <span class="operator">a</span> <span class="built_in">number</span>.</div><div class="line">MGET         DB.Str().GetMany       Returns <span class="operator">the</span> values <span class="operator">of</span> <span class="constant">one</span> <span class="operator">or</span> more <span class="built_in">keys</span>.</div><div class="line">MSET         DB.Str().SetMany       Sets <span class="operator">the</span> values <span class="operator">of</span> <span class="constant">one</span> <span class="operator">or</span> more <span class="built_in">keys</span>.</div><div class="line">PSETEX       DB.Str().SetExpires    Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">and</span> expiration <span class="built_in">time</span> (<span class="operator">in</span> ms) <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">SET          DB.Str().Set           Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">SETEX        DB.Str().SetExpires    Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">and</span> expiration (<span class="operator">in</span> <span class="built_in">sec</span>) <span class="built_in">time</span> <span class="operator">of</span> <span class="operator">a</span> key.</div><div class="line">SETNX        DB.Str().SetWith       Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">a</span> key when <span class="operator">the</span> key doesn<span class="string">'t exist.</span></div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">APPEND</span>  GETDEL  GETEX  GETRANGE  LCS  MSETNX  SETRANGE  STRLEN  SUBSTR</div></pre></td></tr></table></figure>

<h3 id="列表">列表</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Command      Go API                      Description</div><div class="line"><span class="comment">-------      ------                      -----------</span></div><div class="line">LINDEX       DB.List().Get               Returns <span class="operator">an</span> <span class="keyword">element</span> <span class="keyword">by</span> its index.</div><div class="line">LINSERT      DB.List().Insert*           Inserts <span class="operator">an</span> <span class="keyword">element</span> <span class="keyword">before</span> <span class="operator">or</span> <span class="keyword">after</span> another <span class="keyword">element</span>.</div><div class="line">LLEN         DB.List().Len               Returns <span class="operator">the</span> <span class="built_in">length</span> <span class="operator">of</span> <span class="operator">a</span> list.</div><div class="line">LPOP         DB.List().PopFront          Returns <span class="operator">the</span> <span class="keyword">first</span> <span class="keyword">element</span> <span class="keyword">after</span> removing <span class="keyword">it</span>.</div><div class="line">LPUSH        DB.List().PushFront         Prepends <span class="operator">an</span> <span class="keyword">element</span> <span class="built_in">to</span> <span class="operator">a</span> list.</div><div class="line">LRANGE       DB.List().Range             Returns <span class="operator">a</span> range <span class="operator">of</span> elements.</div><div class="line">LREM         DB.List().Delete*           Removes elements <span class="built_in">from</span> <span class="operator">a</span> list.</div><div class="line">LSET         DB.List().Set               Sets <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">an</span> <span class="keyword">element</span> <span class="keyword">by</span> its index.</div><div class="line">LTRIM        DB.List().Trim              Removes elements <span class="built_in">from</span> both <span class="operator">ends</span> <span class="operator">a</span> list.</div><div class="line">RPOP         DB.List().PopBack           Returns <span class="operator">the</span> <span class="keyword">last</span> <span class="keyword">element</span> <span class="keyword">after</span> removing <span class="keyword">it</span>.</div><div class="line">RPOPLPUSH    DB.List().PopBackPushFront  Removes <span class="operator">the</span> <span class="keyword">last</span> <span class="keyword">element</span> <span class="operator">and</span> pushes <span class="keyword">it</span> <span class="built_in">to</span> another list.</div><div class="line">RPUSH        DB.List().PushBack          Appends <span class="operator">an</span> <span class="keyword">element</span> <span class="built_in">to</span> <span class="operator">a</span> list.</div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">BLMOVE</span>  BLMPOP  BLPOP  BRPOP  BRPOPLPUSH  LMOVE  LMPOP</div><div class="line">LPOS  LPUSHX  RPUSHX</div></pre></td></tr></table></figure>

<h3 id="Set">Set</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Command      Go API                 Description</div><div class="line"><span class="comment">-------      ------                 -----------</span></div><div class="line">SADD         DB.Set().Add           Adds one or more members to a <span class="operator"><span class="keyword">set</span>.</span></div><div class="line">SCARD        DB.<span class="keyword">Set</span>().<span class="keyword">Len</span>           <span class="keyword">Returns</span> the <span class="built_in">number</span> <span class="keyword">of</span> members <span class="keyword">in</span> a <span class="keyword">set</span>.</div><div class="line">SDIFF        DB.<span class="keyword">Set</span>().Diff          <span class="keyword">Returns</span> the <span class="keyword">difference</span> <span class="keyword">of</span> multiple sets.</div><div class="line">SDIFFSTORE   DB.<span class="keyword">Set</span>().DiffStore     Stores the <span class="keyword">difference</span> <span class="keyword">of</span> multiple sets.</div><div class="line">SINTER       DB.<span class="keyword">Set</span>().Inter         <span class="keyword">Returns</span> the intersection <span class="keyword">of</span> multiple sets.</div><div class="line">SINTERSTORE  DB.<span class="keyword">Set</span>().InterStore    Stores the intersection <span class="keyword">of</span> multiple sets.</div><div class="line">SISMEMBER    DB.<span class="keyword">Set</span>().<span class="keyword">Exists</span>        Determines whether a member belongs <span class="keyword">to</span> a <span class="keyword">set</span>.</div><div class="line">SMEMBERS     DB.<span class="keyword">Set</span>().Items         <span class="keyword">Returns</span> <span class="keyword">all</span> members <span class="keyword">of</span> a <span class="keyword">set</span>.</div><div class="line">SMOVE        DB.<span class="keyword">Set</span>().Move          Moves a member <span class="keyword">from</span> one <span class="keyword">set</span> <span class="keyword">to</span> another.</div><div class="line">SPOP         DB.<span class="keyword">Set</span>().Pop           <span class="keyword">Returns</span> a random member <span class="keyword">after</span> removing it.</div><div class="line">SRANDMEMBER  DB.<span class="keyword">Set</span>().Random        <span class="keyword">Returns</span> a random member <span class="keyword">from</span> a <span class="keyword">set</span>.</div><div class="line">SREM         DB.<span class="keyword">Set</span>().<span class="keyword">Delete</span>        Removes one <span class="keyword">or</span> more members <span class="keyword">from</span> a <span class="keyword">set</span>.</div><div class="line">SSCAN        DB.<span class="keyword">Set</span>().Scanner       Iterates over members <span class="keyword">of</span> a <span class="keyword">set</span>.</div><div class="line">SUNION       DB.<span class="keyword">Set</span>().<span class="keyword">Union</span>         <span class="keyword">Returns</span> the <span class="keyword">union</span> <span class="keyword">of</span> multiple sets.</div><div class="line">SUNIONSTORE  DB.<span class="keyword">Set</span>().UnionStore    Stores the <span class="keyword">union</span> <span class="keyword">of</span> multiple sets.</div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">SINTERCARD</span>  SMISMEMBER</div></pre></td></tr></table></figure>

<h3 id="Hash">Hash</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="variable">Command</span>       <span class="variable">Go</span> <span class="variable">API</span>                  <span class="variable">Description</span></div><div class="line"><span class="pp">-------       ------------------      -----------</span></div><div class="line">HDEL          DB.<span class="variable">Hash</span>().<span class="variable">Delete</span>        <span class="variable">Deletes</span> one or more fields <span class="keyword">and</span> their values.</div><div class="line"><span class="variable">HEXISTS</span>       <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Exists</span>        <span class="variable">Determines</span> whether a field exists.</div><div class="line"><span class="variable">HGET</span>          <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Get</span>           <span class="variable">Returns</span> the value <span class="keyword">of</span> a field.</div><div class="line"><span class="variable">HGETALL</span>       <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Items</span>         <span class="variable">Returns</span> all fields <span class="keyword">and</span> values.</div><div class="line"><span class="variable">HINCRBY</span>       <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Incr</span>          <span class="variable">Increments</span> the integer value <span class="keyword">of</span> a field.</div><div class="line"><span class="variable">HINCRBYFLOAT</span>  <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">IncrFloat</span>     <span class="variable">Increments</span> the float value <span class="keyword">of</span> a field.</div><div class="line"><span class="variable">HKEYS</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Keys</span>          <span class="variable">Returns</span> all fields.</div><div class="line"><span class="variable">HLEN</span>          <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Len</span>           <span class="variable">Returns</span> the number <span class="keyword">of</span> fields.</div><div class="line"><span class="variable">HMGET</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">GetMany</span>       <span class="variable">Returns</span> the values <span class="keyword">of</span> multiple fields.</div><div class="line"><span class="variable">HMSET</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">SetMany</span>       <span class="variable">Sets</span> the values <span class="keyword">of</span> multiple fields.</div><div class="line"><span class="variable">HSCAN</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Scanner</span>       <span class="variable">Iterates</span> over fields <span class="keyword">and</span> values.</div><div class="line"><span class="variable">HSET</span>          <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">SetMany</span>       <span class="variable">Sets</span> the values <span class="keyword">of</span> one or more fields.</div><div class="line"><span class="variable">HSETNX</span>        <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">SetNotExists</span>  <span class="variable">Sets</span> the value <span class="keyword">of</span> a field <span class="keyword">when</span> it doesn't exist.</div><div class="line"><span class="variable">HVALS</span>         <span class="variable">DB</span>.<span class="variable">Hash</span>().<span class="variable">Exists</span>        <span class="variable">Returns</span> all values.</div></pre></td></tr></table></figure>

<p>暂时不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">HRANDFIELD</span>  HSTRLEN</div></pre></td></tr></table></figure>

<h3 id="Sorted_Set">Sorted Set</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Command           Go API                  Description</div><div class="line"><span class="comment">-------           ------                  -----------</span></div><div class="line">ZADD              DB.ZSet().AddMany       Adds <span class="operator">or</span> updates <span class="constant">one</span> <span class="operator">or</span> more members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZCARD             DB.ZSet().Len           Returns <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> members <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZCOUNT            DB.ZSet().Count         Returns <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores.</div><div class="line">ZINCRBY           DB.ZSet().Incr          Increments <span class="operator">the</span> score <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZINTER            DB.ZSet().InterWith     Returns <span class="operator">the</span> intersection <span class="operator">of</span> multiple sets.</div><div class="line">ZINTERSTORE       DB.ZSet().InterWith     Stores <span class="operator">the</span> intersection <span class="operator">of</span> multiple sets <span class="operator">in</span> <span class="operator">a</span> key.</div><div class="line">ZRANGE            DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> indexes.</div><div class="line">ZRANGEBYSCORE     DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores.</div><div class="line">ZRANK             DB.ZSet().GetRank       Returns <span class="operator">the</span> index <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span> ordered <span class="keyword">by</span> <span class="keyword">ascending</span> scores.</div><div class="line">ZREM              DB.ZSet().Delete        Removes <span class="constant">one</span> <span class="operator">or</span> more members <span class="built_in">from</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZREMRANGEBYRANK   DB.ZSet().DeleteWith    Removes members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> indexes.</div><div class="line">ZREMRANGEBYSCORE  DB.ZSet().DeleteWith    Removes members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores.</div><div class="line">ZREVRANGE         DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> indexes <span class="operator">in</span> reverse order.</div><div class="line">ZREVRANGEBYSCORE  DB.ZSet().RangeWith     Returns members <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span> <span class="operator">within</span> <span class="operator">a</span> range <span class="operator">of</span> scores <span class="operator">in</span> reverse order.</div><div class="line">ZREVRANK          DB.ZSet().GetRankRev    Returns <span class="operator">the</span> index <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span> ordered <span class="keyword">by</span> <span class="keyword">descending</span> scores.</div><div class="line">ZSCAN             DB.ZSet().Scan          Iterates over members <span class="operator">and</span> scores <span class="operator">of</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZSCORE            DB.ZSet().GetScore      Returns <span class="operator">the</span> score <span class="operator">of</span> <span class="operator">a</span> member <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">set</span>.</div><div class="line">ZUNION            DB.ZSet().UnionWith     Returns <span class="operator">the</span> <span class="built_in">union</span> <span class="operator">of</span> multiple sets.</div><div class="line">ZUNIONSTORE       DB.ZSet().UnionWith     Stores <span class="operator">the</span> <span class="built_in">union</span> <span class="operator">of</span> multiple sets <span class="operator">in</span> <span class="operator">a</span> key.</div></pre></td></tr></table></figure>

<p>不支持的命令</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">BZMPOP</span>  BZPOPMAX  BZPOPMIN  ZDIFF  ZDIFFSTORE  ZINTERCARD</div><div class="line">ZLEXCOUNT  ZMPOP  ZMSCORE  ZPOPMAX  ZPOPMIN  ZRANDMEMBER</div><div class="line">ZRANGEBYLEX  ZRANGESTORE  ZREMRANGEBYLEX  ZREVRANGEBYLEX</div></pre></td></tr></table></figure>

<h3 id="Key">Key</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Command    Go API                    Description</div><div class="line">-------    ------                    -----------</div><div class="line">DBSIZE     DB.<span class="keyword">Key</span>().Len              Returns the total number <span class="keyword">of</span> keys.</div><div class="line">DEL        DB.<span class="keyword">Key</span>().Delete           Deletes one <span class="keyword">or</span> more keys.</div><div class="line">EXISTS     DB.<span class="keyword">Key</span>().Count            Determines whether one <span class="keyword">or</span> more keys exist.</div><div class="line">EXPIRE     DB.<span class="keyword">Key</span>().Expire           Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> (<span class="keyword">in</span> seconds).</div><div class="line">EXPIREAT   DB.<span class="keyword">Key</span>().ExpireAt         Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> <span class="keyword">to</span> a Unix timestamp.</div><div class="line">FLUSHDB    DB.<span class="keyword">Key</span>().DeleteAll        Deletes all keys <span class="keyword">from</span> the database.</div><div class="line">KEYS       DB.<span class="keyword">Key</span>().Keys             Returns all <span class="keyword">key</span> names that match a pattern.</div><div class="line">PERSIST    DB.<span class="keyword">Key</span>().Persist          Removes the expiration time <span class="keyword">of</span> a <span class="keyword">key</span>.</div><div class="line">PEXPIRE    DB.<span class="keyword">Key</span>().Expire           Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> <span class="keyword">in</span> ms.</div><div class="line">PEXPIREAT  DB.<span class="keyword">Key</span>().ExpireAt         Sets the expiration time <span class="keyword">of</span> a <span class="keyword">key</span> <span class="keyword">to</span> a Unix ms timestamp.</div><div class="line">RANDOMKEY  DB.<span class="keyword">Key</span>().Random           Returns a random <span class="keyword">key</span> name <span class="keyword">from</span> the database.</div><div class="line">RENAME     DB.<span class="keyword">Key</span>().Rename           Renames a <span class="keyword">key</span> <span class="keyword">and</span> overwrites the destination.</div><div class="line">RENAMENX   DB.<span class="keyword">Key</span>().RenameNotExists  Renames a <span class="keyword">key</span> only <span class="keyword">when</span> the target <span class="keyword">key</span> name doesn<span class="comment">'t exist.</span></div><div class="line">SCAN       DB.<span class="keyword">Key</span>().Scanner          Iterates over the <span class="keyword">key</span> names <span class="keyword">in</span> the database.</div><div class="line">TTL        DB.<span class="keyword">Key</span>().<span class="keyword">Get</span>              Returns the expiration time <span class="keyword">in</span> seconds <span class="keyword">of</span> a <span class="keyword">key</span>.</div><div class="line">TYPE       DB.<span class="keyword">Key</span>().<span class="keyword">Get</span>              Returns the type <span class="keyword">of</span> value stored at a <span class="keyword">key</span>.</div></pre></td></tr></table></figure>

<p>不支持的命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">COPY</span>  <span class="keyword">DUMP</span>  EXPIRETIME  MIGRATE  MOVE  OBJECT  PEXPIRETIME</div><div class="line">PTTL  RESTORE  <span class="keyword">SORT</span>  SORT_RO  TOUCH  TTL  TYPE  UNLINK</div><div class="line">WAIT  WAITAOF</div></pre></td></tr></table></figure>

<h3 id="事务">事务</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Command    Go API                 Description</div><div class="line">-------    ------                 -----------</div><div class="line">DISCARD    <span class="pseudo">DB</span>.View / <span class="pseudo">DB</span>.Update    Discards a transaction.</div><div class="line">EXEC       <span class="pseudo">DB</span>.View / <span class="pseudo">DB</span>.Update    Executes all commands <span class="keyword">in</span> a transaction.</div><div class="line">MULTI      <span class="pseudo">DB</span>.View / <span class="pseudo">DB</span>.Update    Starts a transaction.</div></pre></td></tr></table></figure>

<p>与 Redis 不同，Redka 的事务完全符合 ACID 属性，在发生故障时会自动回滚。</p>
<p>不支持的命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">UNWATCH</span>  WATCH</div></pre></td></tr></table></figure>

<h3 id="连接管理">连接管理</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Command    Go API                Description</div><div class="line"><span class="comment">-------    ------                -----------</span></div><div class="line">ECHO       -                     Returns <span class="operator">the</span> given <span class="keyword">string</span>.</div><div class="line">PING       -                     Returns <span class="operator">the</span> server<span class="string">'s liveliness response.</span></div></pre></td></tr></table></figure>

<h2 id="安装">安装</h2>
<p>你可以以独立的服务的形式安装。官方文档提供了方便的 Linux、macOS 的安装脚本，你也可以使用 docker 进行部署。</p>
<p>也可以在你的 Go 程序中当成一个库引用: <code>go get github.com/nalgeon/redka</code>，当然了你也必须引入 sqlite 的库，比如 <code>github.com/mattn/go-sqlite3</code> 或者 <code>modernc.org/sqlite</code>。</p>
<h2 id="运行">运行</h2>
<p>你可以使用 <code>redka [-h host] [-p port] [db-path]</code> 启动一个 redka 服务，比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./redka</div><div class="line">./redka data.db</div><div class="line">./redka -h <span class="number">0.0</span>.<span class="number">0.0</span> -p <span class="number">6379</span> data.db</div></pre></td></tr></table></figure>

<p>如果没有指定数据库文件，那么它就完全使用内存的方式。</p>
<p>如果当成一个库引入使用，你可以像这样在进程内使用:\</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"log"</span></div><div class="line"></div><div class="line">    _ <span class="string">"github.com/mattn/go-sqlite3"</span></div><div class="line">    <span class="string">"github.com/nalgeon/redka"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// Open or create the data.db file.</span></div><div class="line">    db, err := redka.Open(<span class="string">"data.db"</span>, <span class="constant">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line">    <span class="comment">// Always close the database when you are finished.</span></div><div class="line">    <span class="keyword">defer</span> db.Close()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果是使用内存的方式，可以指定 sqlite 使用内存的方式打开:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// All data is lost when the database is closed.</div><div class="line">redka.Open(<span class="string">"file:redka?mode=memory&cache=shared"</span>)</div></pre></td></tr></table></figure>

<p>然后代码中就可以直接调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">db.Str().Set(<span class="string">"name"</span>, <span class="string">"alice"</span>)</div><div class="line">db.Str().Set(<span class="string">"age"</span>,<span class="number"> 25</span>)</div><div class="line"></div><div class="line">count, err := db.Key().Count(<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"city"</span>)</div><div class="line">slog.Info(<span class="string">"count"</span>, <span class="string">"count"</span>, count, <span class="string">"err"</span>, err)</div><div class="line"></div><div class="line">name, err := db.Str().Get(<span class="string">"name"</span>)</div><div class="line">slog.Info(<span class="string">"get"</span>, <span class="string">"name"</span>, name, <span class="string">"err"</span>, err)</div></pre></td></tr></table></figure>

<p>下面的代码是使用事务的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">updCount :=<span class="number"> 0</span></div><div class="line">err := db.Update(<span class="keyword">func</span>(tx *redka.Tx) error {</div><div class="line">    err := tx.Str().Set(<span class="string">"name"</span>, <span class="string">"bob"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line">    updCount++</div><div class="line"></div><div class="line">    err = tx.Str().Set(<span class="string">"age"</span>,<span class="number"> 50</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line">    updCount++</div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">})</div><div class="line">slog.Info(<span class="string">"updated"</span>, <span class="string">"count"</span>, updCount, <span class="string">"err"</span>, err)</div></pre></td></tr></table></figure>

<h2 id="性能">性能</h2>
<p>作者在 Apple M1 8-core CPU, 16GB RAM 的苹果机器和 Redis 进行了性能比较。<br>使用下面的场景进行比较(<code>redis-benchmark -p 6379 -q -c 10 -n 1000000 -r 10000 -t get,set</code>)：</p>
<ul>
<li>10 parallel connections</li>
<li>1000000 requests</li>
<li>10000 randomized keys</li>
<li>GET/SET commands</li>
</ul>
<p>比 Redis 慢 2~5 倍，这也合理，毕竟底层采用一个关系数据库进行存储。</p>
<h2 id="给我们的启发">给我们的启发</h2>
<p>Redka 使用 redcon 进行 Redis 命令的解析，然后针对每种大类的 Redis 命令，会有一个单独的表进行存储。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">rkey</div><div class="line"><span class="comment">---</span></div><div class="line">id       <span class="keyword">integer</span> primary key</div><div class="line">key      <span class="keyword">text</span> <span class="operator">not</span> <span class="constant">null</span></div><div class="line">type     <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- 1 string, 2 list, 3 set, 4 hash, 5 sorted set</span></div><div class="line"><span class="built_in">version</span>  <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- incremented when the key value is updated</span></div><div class="line">etime    <span class="keyword">integer</span>             <span class="comment">-- expiration timestamp in unix milliseconds</span></div><div class="line">mtime    <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- modification timestamp in unix milliseconds</span></div><div class="line"><span class="built_in">len</span>      <span class="keyword">integer</span>             <span class="comment">-- number of child elements</span></div><div class="line"></div><div class="line">rstring</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line"><span class="built_in">value</span>    blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rlist</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">pos      real <span class="operator">not</span> <span class="constant">null</span>       <span class="comment">-- is used for ordering, but is not an index</span></div><div class="line">elem     blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rset</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">elem     blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rhash</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">field    <span class="keyword">text</span> <span class="operator">not</span> <span class="constant">null</span></div><div class="line"><span class="built_in">value</span>    blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line"></div><div class="line">rzset</div><div class="line"><span class="comment">---</span></div><div class="line">kid      <span class="keyword">integer</span> <span class="operator">not</span> <span class="constant">null</span>    <span class="comment">-- FK -&gt; rkey.id</span></div><div class="line">elem     blob <span class="operator">not</span> <span class="constant">null</span></div><div class="line">score    real <span class="operator">not</span> <span class="constant">null</span></div></pre></td></tr></table></figure>

<p>既然它支持 sqlite, 我们可以把它 port 到其它的数据库上，比如 clickhouse，这样我们就可以支持巨量的数据了。</p>
<p>当然更深一步，我们还可以接入其他的 NoSQL 数据库，比如 RocksDB 等，类似的项目都有很多了。</p>
<p>这是一个很有意思的项目。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redka旨在使用SQLite重新实现Redis的优秀部分,同时保持与Redis API的兼容性。</p>
<p>有意思的特性:</p>
<ul>
<li>数据不必完全装载在内存中。</li>
<li>支持ACID事务。</li>
<li>使用SQL视图以便于内省和报告。</li>
<li>同时提供进程内(Go API)和独立(RESP)服务器。</li>
<li>兼容Redis的命令和线路协议。</li>
</ul>
<p>Redia 并不期望完全达到 Redis 那么高的性能，但是性能上也并不会落后很多。它的主要功能还是 SQL + Redis 的功能，集成了两种优秀产品 SQLite 和 Redis 的盛世美颜。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[命令分发模式]]></title>
    <link href="https://colobu.com/2024/06/03/command-dispacher-pattern/"/>
    <id>https://colobu.com/2024/06/03/command-dispacher-pattern/</id>
    <published>2024-06-02T23:53:37.000Z</published>
    <updated>2024-07-03T03:41:24.498Z</updated>
    <content type="html"><![CDATA[<p>命令分发模式 (command dispatcher pattern)不属于23种经典的设计模式。它是一种不太为人所知的设计模式,它主要用于构建可扩展、可插拔的系统架构,将请求与执行请求的操作对象解耦。它类似于命令模式(Command Pattern),但更加灵活和动态。</p>
<p>虽然Command Dispatch Pattern不属于那23种经典模式,但它确实是一种很有价值的模式,可以应用于需要在运行时动态添加、修改或删除操作的系统中,使系统更加灵活和可扩展。</p>
<p>这种模式通过允许方便的添加、替换或移除任何命令处理器, 非常的灵活，将命令调用和命令处理解耦。而且每个命令可以由单独的命令处理器处理，代码组织和维护也很方便。</p>
<p>实际上，对于 Gopher 来讲，必然已经接触到这个模式了，只不过少有人指出或者梳理这种模式，但是在标准库和一些知名的项目中，其实已经自然的应用了，而且看起来整个架构也非常的清爽。</p>
<a id="more"></a>
<p>让我们看一个标准库实现 web 服务的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义 HTTP 处理程序函数</span></div><div class="line"><span class="keyword">func</span> homeHandler(w http.ResponseWriter, r *http.Request) {</div><div class="line">	fmt.Fprint(w, <span class="string">"Welcome to the home page!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> aboutHandler(w http.ResponseWriter, r *http.Request) {</div><div class="line">	fmt.Fprint(w, <span class="string">"This is the about page."</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="comment">// 创建一个新的 ServeMux 实例</span></div><div class="line">	mux := http.NewServeMux()</div><div class="line"></div><div class="line">	<span class="comment">// 注册处理程序函数</span></div><div class="line">	mux.HandleFunc(<span class="string">"/"</span>, homeHandler)</div><div class="line">	mux.HandleFunc(<span class="string">"/about"</span>, aboutHandler)</div><div class="line"></div><div class="line">	<span class="comment">// 启动 HTTP 服务器</span></div><div class="line">	fmt.Println(<span class="string">"Starting server at :8080"</span>)</div><div class="line">	http.ListenAndServe(<span class="string">":8080"</span>, mux)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们可以把 <code>http.ServeMux</code> 看作是 <strong>Command Dispatcher</strong>,而 HTTP 请求就是一个命令。</p>
<p>通过 <code>mux.HandleFunc</code> ，将命令 (path，请求路径) 与命令处理程序  (handler, 处理程序函数) 进行绑定的过程。</p>
<p>新增一个命令，就注册一个新的处理程序。<br>移除一条命令，就删除那一条绑定语句。<br>修改一条命令，就替换对应的处理程序。</p>
<p>Http server 收到 HTTP 请求后，解析出路径信息，然后从注册的信息中找到这个路径对应的处理程序，然后调用这个处理程序。</p>
<p>这是一个经典的命令分发模式的应用。对于贝尔实验室出来的 Rob Pike、Russ Cox 来说，它们和 GoF 设计模式的这一派属于两个门派，所以在 Go 语言中 Rob Pike、Russ Cox 很少会讲到面向对象的设计模式，但是这种 HTTP 的这种实现方法我们可以把它归类为命令分发模式，而且是一个标准的模式实现。</p>
<p>接下来，我再给你介绍几种知名项目中使用这种模式的例子。毕竟，这种设计模式应用的场景之一就是微服务：</p>
<ul>
<li><strong>分布式系统</strong>：在分布式系统中，命令分发模式可以用于将命令分配到不同的服务或节点进行处理。</li>
<li><strong>微服务架构</strong>：在微服务架构中，命令分发模式可以用于协调不同微服务之间的命令处理。</li>
<li><strong>复杂应用</strong>：在复杂应用中，命令分发模式可以用于解耦命令的发出者和处理者，提高系统的灵活性和可维护性。</li>
</ul>
<h2 id="Rpc_中处理">Rpc 中处理</h2>
<p>Go 生态圈中知名的微服务框架之一 <a href="https://rpcx.io" target="_blank" rel="external">rpcx</a> 实现了两种命令分发方式：</p>
<ul>
<li>类似 Go 标准库的 rpc, 通过发射的方式找到对应的微服务方法，然后调用</li>
<li>第二种是类似 Go 标准库这种路由绑定的方法，通过绑定 handler 方式</li>
</ul>
<p>这两种方式都属于命令分发的设计模式，但是第二种更直观。比如下面一个微服务的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcxio/rpcx-examples"</span></div><div class="line">	<span class="string">"github.com/smallnest/rpcx/server"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	addr = flag.String(<span class="string">"addr"</span>, <span class="string">"localhost:8972"</span>, <span class="string">"server address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> mul(ctx *server.Context) error {</div><div class="line">	<span class="keyword">var</span> args example.Args</div><div class="line">	err := ctx.Bind(&args)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> reply example.Reply</div><div class="line">	reply.C = args.A * args.B</div><div class="line"></div><div class="line">	ctx.Write(reply)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	s := server.NewServer()</div><div class="line"></div><div class="line">	s.AddHandler(<span class="string">"Arith"</span>, <span class="string">"Mul"</span>, mul)</div><div class="line"></div><div class="line">	err := s.Serve(<span class="string">"tcp"</span>, *addr)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里例子以一个 <code>乘法</code> 的微服务做例子。函数 <code>mul</code> 是命令(微服务)处理函数。<code>s.AddHandler</code> 将微服务和命令处理函数进行绑定。这和 HTTP 的例子非常的类似。</p>
<p><code>server</code> 就是一个分发器，它收到客户端的微服务请求，解析出微服务的名称 (名字和方法名)，找到注册的 handler, 把参数传给 handler 去处理。</p>
<p>lesismal 实现的一个高性能的 Go 微服务框架 <a href="https://github.com/lesismal/arpc" target="_blank" rel="external">arpc</a> 也是采用的这种方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/lesismal/arpc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	svr := arpc.NewServer()</div><div class="line"></div><div class="line">	<span class="comment">// register router</span></div><div class="line">	svr.Handler.Handle(<span class="string">"/echo/sync"</span>, <span class="keyword">func</span>(ctx *arpc.Context) {</div><div class="line">		str := <span class="string">""</span></div><div class="line">		err := ctx.Bind(&str)</div><div class="line">		ctx.Write(str)</div><div class="line">		log.Printf(<span class="string">"/echo/sync: \"%v\", error: %v"</span>, str, err)</div><div class="line">	})</div><div class="line"></div><div class="line">	<span class="comment">// register router</span></div><div class="line">	svr.Handler.Handle(<span class="string">"/echo/async"</span>, <span class="keyword">func</span>(ctx *arpc.Context) {</div><div class="line">		str := <span class="string">""</span></div><div class="line">		err := ctx.Bind(&str)</div><div class="line">		<span class="keyword">go</span> ctx.Write(str)</div><div class="line">		log.Printf(<span class="string">"/echo/async: \"%v\", error: %v"</span>, str, err)</div><div class="line">	})</div><div class="line"></div><div class="line">	svr.Run(<span class="string">"localhost:8888"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理微服务、web 路由等这些场景。在基础架构的软件开发中，这种模式对于实现命令式的基础服务组件，也非常的合适，接下来我给你介绍实现自研 memcached 和 redis 服务的基于命令分发模式实现的架构。</p>
<h2 id="在自研基础架构产品中的应用">在自研基础架构产品中的应用</h2>
<h3 id="自研类_memcached_的缓存系统">自研类 memcached 的缓存系统</h3>
<p>Memcached是一种分布式内存对象缓存系统,用于加速动态Web应用程序的响应速度。它基于一种高效的基于内存的键值对存储,设计用于缓存小的数据块。</p>
<p>Memcached的主要优势包括:</p>
<ul>
<li><strong>高性能</strong>:基于内存操作,能够提供非常高的读写性能。</li>
<li><strong>减少服务器负载</strong>:通过缓存数据减轻了数据库的访问压力。</li>
<li><strong>可扩展性</strong>:支持分布式集群部署,能够线性扩展。</li>
</ul>
<p>Memcached的作者是Brad Fitzpatrick。也曾是 Go 开发团队成员之一，维护 Go HTTP 库等。也是 Go memcached client 库 <a href="https://github.com/bradfitz/gomemcache" target="_blank" rel="external">bradfitz/gomemcache:</a> 的作者。</p>
<p>这里我们介绍的是 Go memcached 服务端的库，在你实现类似 Memcached 服务的时候很有用。</p>
<p>Memcached 有文本和二进制两种协议，这里我们介绍的是文本协议，它比较简单，而且也方便使用 telenet 等命令测试。下面是一些常用的Memcached命令:</p>
<ol>
<li><strong>存储命令</strong>:<ul>
<li><code>set key flags exptime bytes [noreply]</code>: 存储一个键值对,并设置可选的标志、过期时间、数据长度和noreply。</li>
<li><code>add key flags exptime bytes [noreply]</code>: 仅当键不存在时添加一个新的键值对。</li>
<li><code>replace key flags exptime bytes [noreply]</code>: 仅当键已存在时替换键的值。</li>
</ul>
</li>
<li><strong>检索命令</strong>:<ul>
<li><code>get key [key ...]</code>: 获取一个或多个键的值。</li>
<li><code>gets key</code>: 获取带有CAS令牌的键值对,用于检查并设置操作。</li>
</ul>
</li>
<li><strong>操作命令</strong>:<ul>
<li><code>incr key value [noreply]</code>: 将键的数值增加给定的值。</li>
<li><code>decr key value [noreply]</code>: 将键的数值减少给定的值。</li>
<li><code>append key flags exptime bytes [noreply]</code>: 将数据追加到一个已存在的键的值中。</li>
<li><code>prepend key flags exptime bytes [noreply]</code>: 将数据添加到一个现有键的值的开始部分。</li>
<li><code>cas keyflags exptime bytes unique-cas-token [noreply]</code>: 使用CAS令牌实现检查并设置操作。</li>
</ul>
</li>
<li><strong>删除命令</strong>:<ul>
<li><code>delete key [noreply]</code>: 删除一个键值对。</li>
</ul>
</li>
<li><strong>统计命令</strong>:<ul>
<li><code>stats</code>: 获取Memcached服务器统计信息。</li>
<li><code>stats reset</code>: 重置Memcached服务器统计信息。</li>
</ul>
</li>
<li><strong>其他命令</strong>:<ul>
<li><code>flush_all [delay] [noreply]</code>: 清空整个Memcached服务器中的所有键值对数据。</li>
<li><code>version</code>: 获取Memcached服务器版本信息。</li>
<li><code>quit</code>: 关闭Memcached连接。</li>
</ul>
</li>
</ol>
<p>这些命令通过TCP连接以文本形式发送给Memcached服务器,服务器也以文本形式返回响应结果。例如,成功的响应以&quot;OK&quot;开头,错误响应以&quot;ERROR&quot;或&quot;SERVER_ERROR&quot;开头。</p>
<p><a href="https://github.com/smallnest/gomemcached" target="_blank" rel="external">smallnest/gomemcached</a> 是实现 memcache server 端的一个库，我们来看它的一个简单例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mockServer = NewServer(addr)</div><div class="line">mockServer.RegisterFunc(<span class="string">"get"</span>, DefaultGet)</div><div class="line">mockServer.RegisterFunc(<span class="string">"gets"</span>, DefaultGet)</div><div class="line">mockServer.RegisterFunc(<span class="string">"set"</span>, DefaultSet)</div><div class="line">mockServer.RegisterFunc(<span class="string">"delete"</span>, DefaultDelete)</div><div class="line">mockServer.RegisterFunc(<span class="string">"incr"</span>, DefaultIncr)</div><div class="line">mockServer.RegisterFunc(<span class="string">"flush_all"</span>, DefaultFlushAll)</div><div class="line">mockServer.RegisterFunc(<span class="string">"version"</span>, DefaultVersion)</div><div class="line">mockServer.Start()</div></pre></td></tr></table></figure>

<p>Server 是一个命令分发器，你可以注册你实现的命令处理函数。<br>你甚至扩展，为你的缓存产品增加 memcached 不支持的命令，比如 <code>auth</code> 等等。</p>
<h3 id="自研类_Redis_的系统">自研类 Redis 的系统</h3>
<p>如果你要开发类似 Redis 的服务，也有一个非常知名的库，甚至可以说是 Go 生态圈的首选，就是 <a href="https://github.com/tidwall/redcon" target="_blank" rel="external">tidwall/redcon</a></p>
<p>它基于命令分发模式，提供了一个通用的 Redis 服务端框架，下面是一个它的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/tidwall/redcon"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> addr = <span class="string">":6380"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> mu sync.RWMutex</div><div class="line">	<span class="keyword">var</span> items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>][]<span class="typename">byte</span>)</div><div class="line">	<span class="keyword">var</span> ps redcon.PubSub</div><div class="line">	<span class="keyword">go</span> log.Printf(<span class="string">"started server at %s"</span>, addr)</div><div class="line">	err := redcon.ListenAndServe(addr,</div><div class="line">		<span class="keyword">func</span>(conn redcon.Conn, cmd redcon.Command) {</div><div class="line">			<span class="keyword">switch</span> strings.ToLower(<span class="typename">string</span>(cmd.Args<span class="number">[0</span>])) {</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				conn.WriteError(<span class="string">"ERR unknown command '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"'"</span>)</div><div class="line">			<span class="keyword">case</span> <span class="string">"ping"</span>:</div><div class="line">				conn.WriteString(<span class="string">"PONG"</span>)</div><div class="line">			<span class="keyword">case</span> <span class="string">"quit"</span>:</div><div class="line">				conn.WriteString(<span class="string">"OK"</span>)</div><div class="line">				conn.Close()</div><div class="line">			<span class="keyword">case</span> <span class="string">"set"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 3</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				mu.Lock()</div><div class="line">				items[<span class="typename">string</span>(cmd.Args<span class="number">[1</span>])] = cmd.Args<span class="number">[2</span>]</div><div class="line">				mu.Unlock()</div><div class="line">				conn.WriteString(<span class="string">"OK"</span>)</div><div class="line">			<span class="keyword">case</span> <span class="string">"get"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 2</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				mu.RLock()</div><div class="line">				val, ok := items[<span class="typename">string</span>(cmd.Args<span class="number">[1</span>])]</div><div class="line">				mu.RUnlock()</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					conn.WriteNull()</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					conn.WriteBulk(val)</div><div class="line">				}</div><div class="line">			<span class="keyword">case</span> <span class="string">"del"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 2</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				mu.Lock()</div><div class="line">				_, ok := items[<span class="typename">string</span>(cmd.Args<span class="number">[1</span>])]</div><div class="line">				<span class="built_in">delete</span>(items, <span class="typename">string</span>(cmd.Args<span class="number">[1</span>]))</div><div class="line">				mu.Unlock()</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					conn.WriteInt<span class="number">(0</span>)</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					conn.WriteInt<span class="number">(1</span>)</div><div class="line">				}</div><div class="line">			<span class="keyword">case</span> <span class="string">"publish"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) !=<span class="number"> 3</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				conn.WriteInt(ps.Publish(<span class="typename">string</span>(cmd.Args<span class="number">[1</span>]), <span class="typename">string</span>(cmd.Args<span class="number">[2</span>])))</div><div class="line">			<span class="keyword">case</span> <span class="string">"subscribe"</span>, <span class="string">"psubscribe"</span>:</div><div class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(cmd.Args) &lt;<span class="number"> 2</span> {</div><div class="line">					conn.WriteError(<span class="string">"ERR wrong number of arguments for '"</span> + <span class="typename">string</span>(cmd.Args<span class="number">[0</span>]) + <span class="string">"' command"</span>)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				command := strings.ToLower(<span class="typename">string</span>(cmd.Args<span class="number">[0</span>]))</div><div class="line">				<span class="keyword">for</span> i :=<span class="number"> 1</span>; i &lt; <span class="built_in">len</span>(cmd.Args); i++ {</div><div class="line">					<span class="keyword">if</span> command == <span class="string">"psubscribe"</span> {</div><div class="line">						ps.Psubscribe(conn, <span class="typename">string</span>(cmd.Args[i]))</div><div class="line">					} <span class="keyword">else</span> {</div><div class="line">						ps.Subscribe(conn, <span class="typename">string</span>(cmd.Args[i]))</div><div class="line">					}</div><div class="line">				}</div><div class="line">			}</div><div class="line">		},</div><div class="line">		<span class="keyword">func</span>(conn redcon.Conn) <span class="typename">bool</span> {</div><div class="line">			<span class="comment">// Use this function to accept or deny the connection.</span></div><div class="line">			<span class="comment">// log.Printf("accept: %s", conn.RemoteAddr())</span></div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		},</div><div class="line">		<span class="keyword">func</span>(conn redcon.Conn, err error) {</div><div class="line">			<span class="comment">// This is called when the connection has been closed</span></div><div class="line">			<span class="comment">// log.Printf("closed: %s, err: %v", conn.RemoteAddr(), err)</span></div><div class="line">		},</div><div class="line">	)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>redcon.ListenAndServe 是一个命令分发器，你可以注册你实现的命令处理函数。<br>在上面的例子中，每一个<code>switch case</code>是一种命令的处理，这里的例子很简单，就没有把每种命令的处理逻辑写成一个个独立的handler,而是直接在case中直接处理。如果我们要实现一个类Redis系统，最好的方式是把每种命令的处理逻辑写成一个个独立的handler，这样代码更清晰，更易维护。<br>这些handler最好按照redis命令的分类，分成几个文件，分别处理string、set等类型。</p>
<p>这样的设计，不仅符合命令分发模式，而且符合单一职责原则，代码更易维护。</p>
<p>从上面的几个例子来看，命令分发模式在实现类似 Memcached、Redis 这种基础架构产品中非常适用，它可以帮助我们实现一个灵活、可扩展的系统架构。本周的另外一篇文章，介绍一个基于SQLite的类Redisa的实现，也是采用了命令分发模式,请关注“鸟窝聊技术”公众号，及时获取最新的文章。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>命令分发模式 (command dispatcher pattern)不属于23种经典的设计模式。它是一种不太为人所知的设计模式,它主要用于构建可扩展、可插拔的系统架构,将请求与执行请求的操作对象解耦。它类似于命令模式(Command Pattern),但更加灵活和动态。</p>
<p>虽然Command Dispatch Pattern不属于那23种经典模式,但它确实是一种很有价值的模式,可以应用于需要在运行时动态添加、修改或删除操作的系统中,使系统更加灵活和可扩展。</p>
<p>这种模式通过允许方便的添加、替换或移除任何命令处理器, 非常的灵活，将命令调用和命令处理解耦。而且每个命令可以由单独的命令处理器处理，代码组织和维护也很方便。</p>
<p>实际上，对于 Gopher 来讲，必然已经接触到这个模式了，只不过少有人指出或者梳理这种模式，但是在标准库和一些知名的项目中，其实已经自然的应用了，而且看起来整个架构也非常的清爽。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Rust捕获和解析网络包]]></title>
    <link href="https://colobu.com/2024/05/22/parse-tcp-timestamp-in-Rust/"/>
    <id>https://colobu.com/2024/05/22/parse-tcp-timestamp-in-Rust/</id>
    <published>2024-05-22T14:14:30.000Z</published>
    <updated>2024-07-03T03:41:24.520Z</updated>
    <content type="html"><![CDATA[<p>前两篇文章介绍了C++和Go中利用TCP Option中的时间戳实现计算网络时延。基于“用Rust重写一切”的哲学，今天我们来看看Rust中如何做这个事情。夜深人静，再肝一篇关于网络编程的文章。<br><a id="more"></a></p>
<p>Rust中还没有和 gopacket一样功能强大的包，它的<a href="https://crates.io/crates/pcap" target="_blank" rel="external">pcap</a>用来捕获网络包没有问题，但是缺乏解析的能力，所以我们使用另外一个包<a href="https://docs.rs/pdu/latest/pdu/" target="_blank" rel="external">pdu</a>来实现网络包的解析。</p>
<blockquote>
<p>当然rust生态圈中还有其他的包捕获库如<a href="https://github.com/libpnet/libpnet" target="_blank" rel="external">pnet</a>、包解析库如<a href="https://crates.io/crates/etherparse" target="_blank" rel="external">etherparse</a>等，但是我选择了pcap和pdu，因为针对这篇文章的场景，它们用起来很顺手。</p>
</blockquote>
<p>为了简单起见，我们不像前两篇文章那样的程序那么复杂，还要解析参数，针对参数做不同的处理，这次Rust实现的程序中，我们主要实现其最核心的功能：</p>
<ul>
<li>捕获 TCP 包</li>
<li>解析TCP选项中的时间戳</li>
<li>计算时延</li>
</ul>
<p>我是在Mac mini的进行开发和运行的，理论在Linux上也是可以运行的。</p>
<p>你可能需要安装<code>libpcap</code>库。</p>
<p>Mac上可能你需要临时设置权限，才有可能正常运行程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">sudo</span> chmod <span class="number">666</span> /dev/bpf*</div></pre></td></tr></table></figure>

<p>首先看看程序运行的效果：<br><img src="pping.png" alt=""></p>
<p>那么程序一开始，我们开始要使用pcap捕获包：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::net::{Ipv4Addr,Ipv6Addr};</div><div class="line"><span class="keyword">use</span> std::ops::Sub;</div><div class="line"><span class="keyword">use</span> std::time::{Duration, UNIX_EPOCH};</div><div class="line"><span class="keyword">use</span> chrono::{DateTime, Local};</div><div class="line"></div><div class="line"><span class="keyword">use</span> macaddr::MacAddr;</div><div class="line"><span class="keyword">use</span> pcap;</div><div class="line"><span class="keyword">use</span> pdu::*;</div><div class="line"><span class="keyword">use</span> libc;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// 这个用来记录flow已经它被捕获的时间</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = std::collections::HashMap::new();</div><div class="line"></div><div class="line">    <span class="comment">// 在Mac上，使用en1网卡</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cap = pcap::Capture::from_device(<span class="string">"en1"</span>)</div><div class="line">        .unwrap()</div><div class="line">        .immediate_mode(<span class="keyword">true</span>)</div><div class="line">        .open()</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 你可以设置filter，这里我们简化不进行设置了</span></div><div class="line">    <span class="comment">// cap.filter("host 127.0.0.1", true).unwrap();</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">let</span> Ok(packet) = cap.next_packet() {</div><div class="line">        <span class="comment">// 得到捕获的包信息</span></div><div class="line"></div><div class="line">        ......</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>目前我们只能得到捕获的包信息，包括pcap增加的头信息(捕获时间、包长度等)和包的数据。</p>
<p>我们需要解析包的数据，得到TCP包，然后解析TCP选项中的时间戳。目前pcap不能帮助我们了。</p>
<p>我们在那个while循环中一步一步补充省略的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ethernet = EthernetPdu::new(&packet.data).unwrap();</div><div class="line"></div><div class="line"><span class="comment">// 实现代码，输出源和目的MAC地址,转换成MacAddr类型</span></div><div class="line"><span class="keyword">let</span> <span class="number">_</span>src_mac = MacAddr::from(ethernet.source_address());</div><div class="line"><span class="keyword">let</span> <span class="number">_</span>dst_mac = MacAddr::from(ethernet.destination_address());</div><div class="line"></div><div class="line"><span class="comment">// println!("ethernet: src_mac={}, dst_mac={}", src_mac, dst_mac);</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> ei = ethernet.inner();</div><div class="line"><span class="keyword">let</span> (src_ip,dst_ip, tcp) = <span class="keyword">match</span> ei {</div><div class="line">    Ok(Ethernet::Ipv4(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv4Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv4Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv4::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line">        </div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    Ok(Ethernet::Ipv6(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv6Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv6Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv6::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line"></div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    <span class="number">_</span> =&gt; (String::new(),String::new(),None)</div><div class="line">    </div><div class="line">};</div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure>

<p>首先解析出<code>ethernet</code>层,和gopacket调用方法不同，但是一样很简洁。</p>
<p><code>ethernet</code>中包含源目的Mac地址，如果你需要，你可以调用相应的方法获取它们。本程序不需要这两个信息，忽略即可。</p>
<p>接下来解析<code>IP</code>层,这会涉及到ipv4和ipv6两种情况，我们分别处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ei = ethernet.inner();</div><div class="line"><span class="keyword">let</span> (src_ip,dst_ip, tcp) = <span class="keyword">match</span> ei {</div><div class="line">    Ok(Ethernet::Ipv4(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv4Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv4Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv4::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line">        </div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    Ok(Ethernet::Ipv6(<span class="keyword">ref</span> ip)) =&gt; {</div><div class="line">        <span class="keyword">let</span> src_ip = Ipv6Addr::from(ip.source_address()).to_string();</div><div class="line">        <span class="keyword">let</span> dst_ip = Ipv6Addr::from(ip.destination_address()).to_string();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> tcp = <span class="keyword">match</span> ip.inner() {</div><div class="line">            Ok(Ipv6::Tcp(tcp)) =&gt; Some(tcp),</div><div class="line">            <span class="number">_</span> =&gt; None</div><div class="line">        };</div><div class="line"></div><div class="line">        (src_ip,dst_ip,tcp)</div><div class="line">    }</div><div class="line">    <span class="number">_</span> =&gt; (String::new(),String::new(),None)</div><div class="line">    </div><div class="line">};</div><div class="line">    </div><div class="line"><span class="keyword">if</span> tcp.is_none() {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"><span class="keyword">let</span> tcp = tcp.unwrap();</div></pre></td></tr></table></figure>

<p>调用<code>inner</code>方法就可以得到<code>IP</code>层的信息，我们处理ipv4和ipv6两种情况，分别获取源目的IP地址和TCP层这三个数据。</p>
<p>因为一开始我们没有设置filter,所以这里捕获的包很多，比如UDP的包、ARP的包，我们在这里检查包是否是TCP包，如果不是，我们忽略这个包。当然最好是一开始就设置filter，性能会更好。</p>
<p>接下来我们解析TCP选项中的时间戳：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ts = tcp.options().find_map(|option| {</div><div class="line">    <span class="keyword">match</span> option {</div><div class="line">        TcpOption::Timestamp{val,ecr} =&gt; {</div><div class="line">            Some((val, ecr))</div><div class="line">        }</div><div class="line">        <span class="number">_</span> =&gt; None</div><div class="line">    }</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">if</span> ts.is_none() {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> ts.unwrap().<span class="number">1</span> == <span class="number">0</span> && !tcp.syn(){</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>pdu</code>库的好处是方便解析TCP以及它的选项。TCP的选项可能有好几个，我们只match时间戳的那个，得到时间戳的值和echo reply的值。</p>
<p>接下来我们处理数据。首先根据五元组和<code>tval</code>为key,将这个flow的信息存储到map中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> key = format!(<span class="string">"{}:{}-&gt;{}:{}-{}"</span>,  src_ip, tcp.source_port(),dst_ip,tcp.destination_port(),ts.unwrap().<span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> !map.contains_key(key.as_str()) {</div><div class="line">    map.insert(key, packet.header.ts);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后我们找反向的key,如果存在，就说明有去向，当前处理的是回向，我们计算两个捕获的值的差，就是时延：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> reverse_key = format!(<span class="string">"{}:{}-&gt;{}:{}-{}"</span>, dst_ip, tcp.destination_port(),src_ip,tcp.source_port(),ts.unwrap().<span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> map.contains_key(reverse_key.as_str()) {</div><div class="line">    map.get(reverse_key.as_str()).map(|ts| {</div><div class="line">        <span class="keyword">let</span> rtt = timeval_diff_str(ts,&packet.header.ts);</div><div class="line">        println!(<span class="string">"{} {} {}:{}-&gt;{}:{}"</span>, timeval_to_current_time_str(&packet.header.ts), rtt,dst_ip, tcp.destination_port(),src_ip,tcp.source_port());</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然为了避免<code>map</code>中的数据越积越多，我们可以定期清理一下，这里我们根据map中的元素的数量决定要不要清理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> map.len() &gt; <span class="number">10_000</span> {</div><div class="line">    map.retain(|<span class="number">_</span>,v| {</div><div class="line">        <span class="keyword">let</span> now = std::time::SystemTime::now();</div><div class="line">        <span class="keyword">let</span> duration = now.duration_since(UNIX_EPOCH).unwrap();</div><div class="line">        <span class="keyword">let</span> ts = Duration::new(v.tv_sec <span class="keyword">as</span> <span class="keyword">u64</span>, v.tv_usec <span class="keyword">as</span> <span class="keyword">u32</span> * <span class="number">1000</span>);</div><div class="line">        duration.sub(ts).as_secs() &lt; <span class="number">60</span></div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后补充两个计算时间的辅助程序，这就是这个程序的全部代码了:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">timeval_to_current_time_str</span></span>(tv: &libc::timeval) -&gt; String {</div><div class="line">    <span class="keyword">let</span> secs = tv.tv_sec <span class="keyword">as</span> <span class="keyword">u64</span>;</div><div class="line">    <span class="keyword">let</span> nsecs = (tv.tv_usec <span class="keyword">as</span> <span class="keyword">u32</span> * <span class="number">1000</span>) <span class="keyword">as</span> <span class="keyword">u64</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> duration = UNIX_EPOCH + std::time::Duration::new(secs, nsecs <span class="keyword">as</span> <span class="keyword">u32</span>);</div><div class="line">    <span class="keyword">let</span> datetime = DateTime::&lt;Local&gt;::from(duration);</div><div class="line"></div><div class="line">    datetime.format(<span class="string">"%H:%M:%S"</span>).to_string()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">timeval_diff_str</span></span>(start: &libc::timeval, end: &libc::timeval) -&gt; String {</div><div class="line">    <span class="keyword">let</span> secs = end.tv_sec <span class="keyword">as</span> <span class="keyword">i64</span> - start.tv_sec <span class="keyword">as</span> <span class="keyword">i64</span>;</div><div class="line">    <span class="keyword">let</span> usecs = end.tv_usec <span class="keyword">as</span> <span class="keyword">i64</span> - start.tv_usec <span class="keyword">as</span> <span class="keyword">i64</span>;</div><div class="line">    <span class="keyword">let</span> (secs, usecs) = <span class="keyword">if</span> usecs &lt; <span class="number">0</span> {</div><div class="line">        (secs - <span class="number">1</span>, usecs + <span class="number">1_000_000</span>)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        (secs, usecs)</div><div class="line">    };</div><div class="line"></div><div class="line">    format_duration(secs, usecs <span class="keyword">as</span> <span class="keyword">u32</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">format_duration</span></span>(secs: <span class="keyword">i64</span>, usecs: <span class="keyword">u32</span>) -&gt; String {</div><div class="line">    <span class="keyword">let</span> duration = secs * <span class="number">1_000_000</span> + usecs <span class="keyword">as</span> <span class="keyword">i64</span>;</div><div class="line">    <span class="keyword">match</span> duration {</div><div class="line">        <span class="number">0</span>..=<span class="number">999_999</span> =&gt; format!(<span class="string">"{:.3}ms"</span>, duration <span class="keyword">as</span> <span class="keyword">f64</span> / <span class="number">1_000.0</span>),</div><div class="line">        <span class="number">_</span> =&gt; format!(<span class="string">"{:.6}s"</span>, duration <span class="keyword">as</span> <span class="keyword">f64</span> / <span class="number">1_000_000.0</span>),</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你对Rust实现的 pping 有什么看法，欢迎在评论区留下你宝贵的意见。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前两篇文章介绍了C++和Go中利用TCP Option中的时间戳实现计算网络时延。基于“用Rust重写一切”的哲学，今天我们来看看Rust中如何做这个事情。夜深人静，再肝一篇关于网络编程的文章。<br>]]>
    
    </summary>
    
      <category term="Rust" scheme="https://colobu.com/categories/Rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go语言实现 pping]]></title>
    <link href="https://colobu.com/2024/05/20/implemenmt-pping-in-go/"/>
    <id>https://colobu.com/2024/05/20/implemenmt-pping-in-go/</id>
    <published>2024-05-20T15:15:55.000Z</published>
    <updated>2024-07-03T03:41:24.514Z</updated>
    <content type="html"><![CDATA[<p>大家好，我是鸟窝。</p>
<p>在前一篇“pping：被动式ping,计算网络时延”一篇中，我给大家介绍了 pping 这个工具的原理和使用方法。这篇文章中，我将使用 Go 语言实现 pping 工具。<br><a id="more"></a><br>通过这篇文章，你将了解到：</p>
<ul>
<li>如何使用gopacket来捕获和解析网络数据包</li>
<li>如何设置捕获时长和过滤捕获的数据包</li>
<li>如何在CGO下静态编译库，如libpcap</li>
<li>了解TCP/IP协议栈的基本知识，如TCP Option</li>
<li>如何进行数据的统计和定时输出和清理</li>
<li>如何使用 pflag 来解析命令行参数</li>
<li><img src="pping.png" alt=""></li>
</ul>
<p>代码在: <a href="https://github.com/smallnest/pping-go" target="_blank" rel="external">github.com/smallnest/pping-go</a></p>
<h2 id="使用libpcap捕获数据包，并进行包过滤">使用libpcap捕获数据包，并进行包过滤</h2>
<p>我们并不直接使用libpcap，而是使用封装好的<a href="https://github.com/google/gopacket" target="_blank" rel="external">gopacket</a>。</p>
<p><code>gopacket</code>是一个用于处理数据包的库，它提供了一个高级的API，可以用来处理数据包的解析、分析和生成。它支持多种数据包格式，包括Ethernet、IPv4、IPv6、TCP、UDP、ICMP等。</p>
<p>我们可以使用<code>gopacket</code>来捕获数据包，然后使用<code>gopacket/layers</code>包来解析数据包的各个部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建一个新的非活动 pcap 句柄, *liveInp是网卡的名称</span></div><div class="line">inactive, _ := pcap.NewInactiveHandle(*liveInp)</div><div class="line"><span class="comment">// 使用 defer 关键字确保在函数结束时清理非活动句柄</span></div><div class="line"><span class="keyword">defer</span> inactive.CleanUp()</div><div class="line"></div><div class="line"><span class="comment">// 设置捕获的数据包的最大长度</span></div><div class="line">inactive.SetSnapLen(snapLen)</div><div class="line"></div><div class="line"><span class="comment">// 激活非活动句柄，返回一个活动句柄和可能的错误</span></div><div class="line">snif, err = inactive.Activate()</div><div class="line"><span class="comment">// 如果在激活句柄时出现错误，我们打印错误并退出程序</span></div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	fmt.Printf(<span class="string">"couldn't open %s: %v\n"</span>, *fname, err)</div><div class="line">	os.Exit<span class="number">(1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然你也可以从一个tcpdump这样的工具捕获的pcap文件中解析包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 pcap.OpenOffline 函数打开一个离线 pcap 文件，返回一个 pcap 句柄和可能的错误</span></div><div class="line">		snif, err = pcap.OpenOffline(*fname)</div><div class="line">		<span class="comment">// 如果在打开文件时出现错误，我们打印错误并退出程序</span></div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			fmt.Printf(<span class="string">"couldn't open %s: %v\n"</span>, *fname, err)</div><div class="line">			os.Exit<span class="number">(1</span>)</div><div class="line">		}</div></pre></td></tr></table></figure>

<p>之后设置filter进行包过滤, filter的格式和tcpdump使用的过滤格式一样，默认它会加上<code>TCP</code>,只处理TCP的包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// 使用 SetBPFFilter 方法设置 BPF 过滤器，过滤器的规则由变量 filter 定义</span></div><div class="line">snif.SetBPFFilter(filter)</div></pre></td></tr></table></figure>

<p>之后处理这个包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">src := gopacket.NewPacketSource(snif, layers.LayerTypeEthernet)</div><div class="line"><span class="comment">// 使用 src.Packets() 获取一个数据包通道，我们可以从这个通道中读取数据包</span></div><div class="line">packets := src.Packets()</div><div class="line"><span class="keyword">for</span> packet := <span class="keyword">range</span> packets {</div><div class="line">	processPacket(packet)</div><div class="line"></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="comment">// 如果结束或者需要定期打印统计信息，可以使用下面的代码</span></div><div class="line">   ......</div><div class="line"></div><div class="line">   <span class="comment">// 如果需要清理过期的数据</span></div><div class="line">   ......</div></pre></td></tr></table></figure>

<h2 id="解析包">解析包</h2>
<p>从TCP Option中解析时间戳的函数是<code>getTSFromTCPOpts</code>，它的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getTSFromTCPOpts 用于从 TCP 选项中获取时间戳信息</span></div><div class="line"><span class="keyword">func</span> getTSFromTCPOpts(tcp *layers.TCP) (<span class="typename">uint32</span>, <span class="typename">uint32</span>) {</div><div class="line">	<span class="keyword">var</span> tsval, tsecr <span class="typename">uint32</span></div><div class="line">	opts := tcp.Options</div><div class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts {</div><div class="line">		<span class="keyword">if</span> opt.OptionType == layers.TCPOptionKindTimestamps && opt.OptionLength ==<span class="number"> 10</span> { <span class="comment">// Timestamp 选项长度为 10 字节</span></div><div class="line">			tsval = binary.BigEndian.Uint32(opt.OptionData<span class="number">[0</span><span class="number">:4</span>])</div><div class="line">			tsecr = binary.BigEndian.Uint32(opt.OptionData<span class="number">[4</span><span class="number">:8</span>])</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> tsval, tsecr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>解析IP和TCP包，并从TCP包的Option解析出时间戳：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// processPacket 用于处理捕获到的数据包</span></div><div class="line"><span class="keyword">func</span> processPacket(pkt gopacket.Packet) {</div><div class="line">	<span class="comment">// 从数据包中获取 TCP 层</span></div><div class="line">	tcpLayer := pkt.Layer(layers.LayerTypeTCP)</div><div class="line">	<span class="keyword">if</span> tcpLayer == <span class="constant">nil</span> {</div><div class="line">		not_tcp++</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	tcp, _ := tcpLayer.(*layers.TCP)</div><div class="line"></div><div class="line">	<span class="comment">// 从 TCP 选项中获取时间戳信息</span></div><div class="line">	<span class="comment">// 如果 TSval 为 0 或者 TSecr 为 0 并且不是 SYN 包，则不处理该数据包</span></div><div class="line">	tsval, tsecr := getTSFromTCPOpts(tcp)</div><div class="line">	<span class="keyword">if</span> tsval ==<span class="number"> 0</span> || (tsecr ==<span class="number"> 0</span> && !tcp.SYN) {</div><div class="line">		no_TS++</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 从数据包中获取网络层</span></div><div class="line">	<span class="comment">// 如果网络层不是 IPv4 或 IPv6，则不处理该数据包</span></div><div class="line">	netLayer := pkt.Layer(layers.LayerTypeIPv4)</div><div class="line">	<span class="keyword">if</span> netLayer == <span class="constant">nil</span> {</div><div class="line">		netLayer = pkt.Layer(layers.LayerTypeIPv6)</div><div class="line">		<span class="keyword">if</span> netLayer == <span class="constant">nil</span> {</div><div class="line">			not_v4or6++</div><div class="line">			<span class="keyword">return</span></div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>目前为止我们从包中解析除了IP包和TCP包，接下里我们得到源目IP和源目端口，以及捕获时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从网络层中获取源 IP 和目的 IP</span></div><div class="line"><span class="comment">// 从 TCP 层中获取源端口和目的端口</span></div><div class="line"><span class="comment">// 用于构建流的源和目的</span></div><div class="line"><span class="keyword">var</span> ipsStr, ipdStr <span class="typename">string</span></div><div class="line"><span class="keyword">if</span> ip, ok := netLayer.(*layers.IPv4); ok {</div><div class="line">	ipsStr = ip.SrcIP.String()</div><div class="line">	ipdStr = ip.DstIP.String()</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	ip := netLayer.(*layers.IPv6)</div><div class="line">	ipsStr = ip.SrcIP.String()</div><div class="line">	ipdStr = ip.DstIP.String()</div><div class="line">}</div><div class="line">srcStr := ipsStr + <span class="string">":"</span> + strconv.Itoa(<span class="typename">int</span>(tcp.SrcPort))</div><div class="line">dstStr := ipdStr + <span class="string">":"</span> + strconv.Itoa(<span class="typename">int</span>(tcp.DstPort))</div><div class="line"></div><div class="line"><span class="comment">// 从数据包中获取捕获时间</span></div><div class="line">captureTime := pkt.Metadata().CaptureInfo.Timestamp</div><div class="line"></div><div class="line"><span class="comment">// 如果 offTm 小于 0，则将捕获时间设置为 offTm</span></div><div class="line"><span class="keyword">if</span> offTm &lt;<span class="number"> 0</span> {</div><div class="line">	offTm = captureTime.Unix()</div><div class="line">	startm = <span class="typename">float64</span>(captureTime.Nanosecond()) *<span class="number"> 1e-9</span></div><div class="line">	<span class="comment">// 如果 sumInt 大于 0，则打印第一个数据包的时间</span></div><div class="line">	capTm = startm</div><div class="line">	<span class="keyword">if</span> sumInt &gt;<span class="number"> 0</span> {</div><div class="line">		fmt.Printf(<span class="string">"first packet at %s\n"</span>, captureTime.Format(time.UnixDate))</div><div class="line">	}</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">	capTm = <span class="typename">float64</span>(captureTime.Unix()-offTm) + <span class="typename">float64</span>(captureTime.Nanosecond())<span class="number">*1e-9</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来是从全局哈希表<code>flows</code>中查找流，如果没有则创建一个新的流，如果反向流已经存在，则设置反向流。如果反向流不存在，不处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">fstr := srcStr + <span class="string">"+"</span> + dstStr</div><div class="line">fr, ok := flows[fstr]</div><div class="line"><span class="keyword">if</span> !ok { <span class="comment">// 新流</span></div><div class="line">    <span class="comment">// 如果流的数量大于 maxFlows，则返回</span></div><div class="line">    <span class="keyword">if</span> flowCnt &gt;= maxFlows {</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    fr = &flowRec{</div><div class="line">        flowname: fstr,</div><div class="line">        min:     <span class="number"> 1e30</span>,</div><div class="line">    }</div><div class="line">    flows[fstr] = fr</div><div class="line">    flowCnt++</div><div class="line"></div><div class="line">    <span class="comment">// 如果反向流已经存在，则设置反向流</span></div><div class="line">    <span class="keyword">if</span> _, ok := flows[dstStr+<span class="string">"+"</span>+srcStr]; ok {</div><div class="line">        flows[dstStr+<span class="string">"+"</span>+srcStr].revFlow = <span class="constant">true</span></div><div class="line">        fr.revFlow = <span class="constant">true</span></div><div class="line">    }</div><div class="line">}</div><div class="line">fr.last_tm = capTm</div><div class="line"></div><div class="line"><span class="comment">// 如果反向流不存在，不处理</span></div><div class="line"><span class="keyword">if</span> !fr.revFlow {</div><div class="line">    uniDir++</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>既然找到反向流了，说明正向反向的两个packet我们都获取到了了，那么就可以利用两次的捕获时间计算 RTT 了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">// 统计流的发送字节数</span></div><div class="line">	arr_fwd := fr.bytesSnt + <span class="typename">float64</span>(pkt.Metadata().Length)</div><div class="line">	fr.bytesSnt = arr_fwd</div><div class="line">	<span class="comment">// 增加时间戳</span></div><div class="line">	<span class="keyword">if</span> !filtLocal || localIP != ipdStr {</div><div class="line">		addTS(fstr+<span class="string">"+"</span>+strconv.FormatUint(<span class="typename">uint64</span>(tsval),<span class="number"> 10</span>), &tsInfo{capTm, arr_fwd, fr.bytesDep})</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 处理对应的反向流</span></div><div class="line">	ti := getTS(dstStr + <span class="string">"+"</span> + srcStr + <span class="string">"+"</span> + strconv.FormatUint(<span class="typename">uint64</span>(tsecr),<span class="number"> 10</span>))</div><div class="line">	<span class="keyword">if</span> ti != <span class="constant">nil</span> && ti.t &gt;<span class="number"> 0.0</span> {</div><div class="line">		<span class="comment">// 这是返回的数据包的捕获时间</span></div><div class="line">		t := ti.t</div><div class="line">		rtt := capTm - t</div><div class="line">		<span class="keyword">if</span> fr.min &gt; rtt {</div><div class="line">			fr.min = rtt <span class="comment">// 跟踪最小值</span></div><div class="line">		}</div><div class="line">		<span class="comment">// fBytes 存储了从源到目标的数据流的字节数</span></div><div class="line">		fBytes := ti.fBytes</div><div class="line">		<span class="comment">// dBytes 存储了从目标到源的数据流的字节数</span></div><div class="line">		dBytes := ti.dBytes</div><div class="line">		<span class="comment">// pBytes 存储了从上一次发送到现在的数据包的字节数</span></div><div class="line">		pBytes := arr_fwd - fr.lstBytesSnt</div><div class="line">		<span class="comment">// 更新上一次发送的字节数为当前的发送字节数</span></div><div class="line">		fr.lstBytesSnt = arr_fwd</div><div class="line">		<span class="comment">// 更新反向流的依赖字节数为 fBytes</span></div><div class="line">		flows[dstStr+<span class="string">"+"</span>+srcStr].bytesDep = fBytes</div><div class="line"></div><div class="line">		<span class="keyword">if</span> machineReadable {</div><div class="line">			<span class="comment">// 打印捕获时间戳、本次rtt值、此流的最小值、字节数信息</span></div><div class="line">			fmt.Printf(<span class="string">"%d.%06d %.6f %.6f %.0f %.0f %.0f"</span>, <span class="typename">int64</span>(capTm+<span class="typename">float64</span>(offTm)), <span class="typename">int</span>((capTm-<span class="typename">float64</span>(<span class="typename">int64</span>(capTm)))<span class="number">*1e6</span>), rtt, fr.min, fBytes, dBytes, pBytes)</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="comment">// 打印捕获时间、本次rtt值、此流的最小值、流的五元组</span></div><div class="line">			fmt.Printf(<span class="string">"%s %s %s %s\n"</span>, captureTime.Format(<span class="string">"15:04:05"</span>), fmtTimeDiff(rtt), fmtTimeDiff(fr.min), fstr)</div><div class="line">		}</div><div class="line">		now := clockNow()</div><div class="line">		<span class="keyword">if</span> now-nextFlush &gt;=<span class="number"> 0</span> {</div><div class="line">			nextFlush = now + flushInt</div><div class="line">		}</div><div class="line">		ti.t = -t <span class="comment">// 将条目标记为已使用,避免再次保存这个 TSval</span></div><div class="line">	}</div><div class="line">	pktCnt++</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="清理过期数据">清理过期数据</h2>
<p>如果不清理，<code>flows</code>和<code>tsTbl</code>中的数据会越来越多，最终撑爆。<br>我们遍历，删除过期的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清理超期的数据</span></div><div class="line"><span class="keyword">func</span> cleanUp(n <span class="typename">float64</span>) {</div><div class="line">	<span class="comment">// 如果 TSval 的时间超过 tsvalMaxAge,则删除条目</span></div><div class="line">	<span class="keyword">for</span> k, ti := <span class="keyword">range</span> tsTbl {</div><div class="line">		<span class="keyword">if</span> capTm-math.Abs(ti.t) &gt; <span class="typename">float64</span>(tsvalMaxAge)/<span class="typename">float64</span>(time.Second) {</div><div class="line">			<span class="built_in">delete</span>(tsTbl, k)</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> k, fr := <span class="keyword">range</span> flows {</div><div class="line">		<span class="keyword">if</span> n-fr.last_tm &gt; <span class="typename">float64</span>(flowMaxIdle)/<span class="typename">float64</span>(time.Second) {</div><div class="line">			<span class="built_in">delete</span>(flows, k)</div><div class="line">			flowCnt--</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用_pflag_解析参数">使用 pflag 解析参数</h2>
<p>相对于标准库的 pflag, <code>github.com/spf13/pflag</code>功能更为强大。这里我们使用它解析参数，可以设置短参数和长参数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	liveInp   = pflag.StringP(<span class="string">"interface"</span>, <span class="string">"i"</span>, <span class="string">""</span>, <span class="string">"interface name"</span>)</div><div class="line">	fname     = pflag.StringP(<span class="string">"read"</span>, <span class="string">"r"</span>, <span class="string">""</span>, <span class="string">"pcap captured file"</span>)</div><div class="line">	filterOpt = pflag.StringP(<span class="string">"filter"</span>, <span class="string">"f"</span>, <span class="string">""</span>, <span class="string">"pcap filter applied to packets"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	pflag.DurationVarP(&sumInt, <span class="string">"sumInt"</span>, <span class="string">"q"</span>,<span class="number"> 10</span>*time.Second, <span class="string">"interval to print summary reports to stderr"</span>)</div><div class="line">	pflag.BoolVarP(&filtLocal, <span class="string">"showLocal"</span>, <span class="string">"l"</span>, <span class="constant">false</span>, <span class="string">"show RTTs through local host applications"</span>)</div><div class="line">	pflag.DurationVarP(&timeToRun, <span class="string">"seconds"</span>, <span class="string">"s"</span>,<span class="number"> 0</span>*time.Second, <span class="string">"stop after capturing for &lt;num&gt; seconds"</span>)</div><div class="line">	pflag.IntVarP(&maxPackets, <span class="string">"count"</span>, <span class="string">"c"</span>,<span class="number"> 0</span>, <span class="string">"stop after capturing &lt;num&gt; packets"</span>)</div><div class="line">	pflag.BoolVarP(&machineReadable, <span class="string">"machine"</span>, <span class="string">"m"</span>, <span class="constant">false</span>, <span class="string">"machine readable output"</span>)</div><div class="line">	pflag.DurationVarP(&tsvalMaxAge, <span class="string">"tsvalMaxAge"</span>, <span class="string">"M"</span>,<span class="number"> 10</span>*time.Second, <span class="string">"max age of an unmatched tsval"</span>)</div><div class="line">	pflag.DurationVarP(&flowMaxIdle, <span class="string">"flowMaxIdle"</span>, <span class="string">"F"</span>,<span class="number"> 300</span>*time.Second, <span class="string">"flows idle longer than &lt;num&gt; are deleted"</span>)</div><div class="line"></div><div class="line">	pflag.Parse()</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="静态编译">静态编译</h2>
<p>差点忘了。<br>我们使用gopacket来捕获数据包，它依赖于libpcap。我们需要在编译时链接libpcap库。但是在不同的操作系统上，libpcap的位置和名称可能不同。为了解决这个问题，我们可以使用CGO来链接libpcap库，然后使用<code>go build</code>来编译我们的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> build -o pping .</div></pre></td></tr></table></figure>

<p>不过如果你使用<code>ldd</code>查看这个程序，你会发现它有很多依赖的动态库:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@cypress pping]<span class="comment"># ldd pping</span></div><div class="line">	linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffcf33e1000)</div><div class="line">	libpcap.so.<span class="number">1</span> =&gt; /lib64/libpcap.so.<span class="number">1</span> (<span class="number">0</span>x00007f4b81933000)</div><div class="line">	libresolv.so.<span class="number">2</span> =&gt; /lib64/libresolv.so.<span class="number">2</span> (<span class="number">0</span>x00007f4b81719000)</div><div class="line">	libpthread.so.<span class="number">0</span> =&gt; /lib64/libpthread.so.<span class="number">0</span> (<span class="number">0</span>x00007f4b814fd000)</div><div class="line">	libc.so.<span class="number">6</span> =&gt; /lib64/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007f4b8112f000)</div><div class="line">	/lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007f4b81b74000)</div></pre></td></tr></table></figure>

<p>我们可以采用静态链接的方式，这样编译出来的pping,可以轻松的复制到其他的Linux机器上运行，不需要安装libpcap库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@cypress pping]<span class="comment"># go build -ldflags "-linkmode external -extldflags -static" .</span></div><div class="line"><span class="comment"># github.com/smallnest/pping</span></div><div class="line">/tmp/go-link-<span class="number">79680640</span>/<span class="number">000006</span>.o：在函数‘_cgo_97ab22c4dc7b_C2func_getaddrinfo’中：</div><div class="line">/tmp/go-build/cgo-gcc-prolog:<span class="number">60</span>: 警告：Using <span class="string">'getaddrinfo'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">//usr/local/lib/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoaddr’中：</div><div class="line">/root/libpcap-<span class="number">1.10</span>.<span class="number">0</span>/./nametoaddr.c:<span class="number">181</span>: 警告：Using <span class="string">'gethostbyname'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">//usr/local/lib/libpcap.a(nametoaddr.o)：在函数‘pcap_nametonetaddr’中：</div><div class="line">/root/libpcap-<span class="number">1.10</span>.<span class="number">0</span>/./nametoaddr.c:<span class="number">270</span>: 警告：Using <span class="string">'getnetbyname_r'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">//usr/local/lib/libpcap.a(nametoaddr.o)：在函数‘pcap_nametoproto’中：</div><div class="line">/root/libpcap-<span class="number">1.10</span>.<span class="number">0</span>/./nametoaddr.c:<span class="number">527</span>: 警告：Using <span class="string">'getprotobyname_r'</span> <span class="keyword">in</span> statically linked applications requires at runtime the shared libraries from the glibc version used <span class="keyword">for</span> linking</div><div class="line">[root@cypress pping]<span class="comment"># ldd pping</span></div><div class="line">	不是动态可执行文件</div></pre></td></tr></table></figure>

<p>它的使用方法和标准库的flag类似。这样我们就能保证和c++的pping工具一样的参数解析了。</p>
<p>基于&quot;Rust重写一切&quot;的哲学，我期望早点能看到大家用Rust实现的 pping。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家好，我是鸟窝。</p>
<p>在前一篇“pping：被动式ping,计算网络时延”一篇中，我给大家介绍了 pping 这个工具的原理和使用方法。这篇文章中，我将使用 Go 语言实现 pping 工具。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让 Rob Pike 或者字节跳动的同学实现一个红黑树]]></title>
    <link href="https://colobu.com/2024/05/19/let-Rob-Pike-write-a-Red-Black-tree/"/>
    <id>https://colobu.com/2024/05/19/let-Rob-Pike-write-a-Red-Black-tree/</id>
    <published>2024-05-19T07:24:10.000Z</published>
    <updated>2024-07-03T03:41:24.516Z</updated>
    <content type="html"><![CDATA[<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。它在1972年由鲁道夫·贝尔发明，被称为“对称二叉B树”，它现代的名字源于利奥尼达斯·J·吉巴斯和罗伯特·塞奇威克于1978年写的一篇论文。红黑树的结构复杂，以至于有些个别公司拿它当做面试题现场实现，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在<code>O(log^n)</code>时间内完成查找、插入和删除。</p>
<a id="more"></a>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ul>
<li>性质1: 节点是红色或黑色。</li>
<li>性质2: 根是黑色。</li>
<li>性质3: 所有叶子都是黑色（叶子是NIL节点）。</li>
<li>性质4: 每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）</li>
<li>性质5: 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="rbtree.png" alt=""></p>
<p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。</p>
<p>然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(<code>O(log^n)</code>)的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为<code>O(log^n)</code>次。</p>
<p>这里我们就不详细介绍红黑树了，这不是问题额度重点。重点是Go标准库中没有实现红黑树，或者说没有直接暴露一个公共的红黑树实现，我们尝试实现它。</p>
<p>当然，已经2042年了，G我们可以借助AI的能力，帮助我们实现一个基本的红黑树，然后我们再做调整。<br>我尝试使用多个AI模型，比如文心一言、通义千问、CLaude、Gemini,并借助Copilot的帮助，最终生成了一个基本的红黑树实现。</p>
<p>为了更高效的实现，我决定请AI模拟Rob Pike或者字节跳动的同学来实现一个红黑树,我的提示语如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Go语言中有 BTreeMap实现吗？如果没有，请实现一个</div></pre></td></tr></table></figure>

<p>`</p>
<p>我对实现不满意，所以我又尝试了一次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请你模拟Rob Pike, review这个实现，指出实现的问题，并提供一个优化的版本</div></pre></td></tr></table></figure>

<p>这里你可以把Rob Pike换成字节跳动的同学。</p>
<p>基本实现了一个红黑树，我看了一下，明显<code>Size</code>字段没有更新，所以我让Copilot把它实现了，包括查找和遍历的方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个红黑树没有实现<span class="variable">Size</span>，请修复。</div><div class="line">为这个红黑树提供查找方法.</div><div class="line">为这个红黑树提供遍历方法</div></pre></td></tr></table></figure>

<p>它修复了一版。</p>
<p>默认它实现的查询和遍历的方法是采用递归的方式，层级多了栈可能会有问题或者溢出，所以我又请它按照非递归的方式实现了。</p>
<p>然后我又让Copliot帮我review了实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">假定你是Rob Pike, 基于你的经验和哲学，请你review这个红黑树的实现，列出问题和可优化的项。</div></pre></td></tr></table></figure>

<p>根据反馈的结果，又做了一些优化，比如<code>Size</code>在节点为空的时候不应该<code>--</code>等。</p>
<p>好了，目前我们让Rob Pike实现了这个红黑数，可以让Copilot帮我们实现单元测试。<br>我是每一个输出方法，单独的询问Copilot，让它生成的单元测试，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">为<span class="keyword">Get</span>方法生成单元测试</div></pre></td></tr></table></figure>

<p>执行单元测试，好真的发现了一些边界情况的处理，没检查nil的情况。</p>
<p>看到中间AI产生的代码包括如此多的错误，我有点不放心了，怎么办？</p>
<p>增加 Fuzz Test, 还是让Copilot帮我实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请为这个RBTree的<span class="keyword">Insert</span>和<span class="keyword">Delete</span>方法，生成fuzz test</div></pre></td></tr></table></figure>

<p>不过生成的代码有问题，我狠狠批评了Copilot，指出它的错误，让它重新生成了Fuzz Test，这次梅问题了:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> FuzzInsert(f *testing.F) {</div><div class="line">	f.Add<span class="number">(3</span>, <span class="string">"three"</span>)</div><div class="line">	f.Add<span class="number">(1</span>, <span class="string">"one"</span>)</div><div class="line">	f.Add<span class="number">(2</span>, <span class="string">"two"</span>)</div><div class="line">	f.Add<span class="number">(4</span>, <span class="string">"four"</span>)</div><div class="line"></div><div class="line">	f.Fuzz(<span class="keyword">func</span>(t *testing.T, key <span class="typename">int</span>, value <span class="typename">string</span>) {</div><div class="line">		tree := NewRBTree()</div><div class="line">		tree.Insert(key, value)</div><div class="line">		<span class="keyword">if</span> val := tree.Get(key); val != value {</div><div class="line">			t.Errorf(<span class="string">"Expected %v, got %v"</span>, value, val)</div><div class="line">		}</div><div class="line">	})</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> FuzzDelete(f *testing.F) {</div><div class="line">	f.Add<span class="number">(3</span>, <span class="string">"three"</span>)</div><div class="line">	f.Add<span class="number">(1</span>, <span class="string">"one"</span>)</div><div class="line">	f.Add<span class="number">(2</span>, <span class="string">"two"</span>)</div><div class="line">	f.Add<span class="number">(4</span>, <span class="string">"four"</span>)</div><div class="line"></div><div class="line">	f.Fuzz(<span class="keyword">func</span>(t *testing.T, key <span class="typename">int</span>, value <span class="typename">string</span>) {</div><div class="line">		tree := NewRBTree()</div><div class="line">		tree.Insert(key, value)</div><div class="line">		tree.Delete(key)</div><div class="line">		<span class="keyword">if</span> val := tree.Get(key); val != <span class="constant">nil</span> {</div><div class="line">			t.Errorf(<span class="string">"Expected nil, got %v"</span>, val)</div><div class="line">		}</div><div class="line">	})</div><div class="line">}</div></pre></td></tr></table></figure>

<p>`</p>
<p>运行Fuzz Test:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go test <span class="variable">-fuzz=</span>FuzzInsert <span class="variable">-fuzztime=</span><span class="number">1</span>m</div><div class="line">go test <span class="variable">-fuzz=</span>FuzzDelete <span class="variable">-fuzztime=</span><span class="number">1</span>m</div></pre></td></tr></table></figure>

<p>大功告成。</p>
<p>通过这个实践，我们可以看到AI:</p>
<ul>
<li>可以让AI模拟专家的形式，生成更专业的代码</li>
<li>目前AI生成的代码还是有问题的，还需要开发者检查和甄别</li>
<li>可以让AI帮我们review代码，找出问题和优化项</li>
<li>可以让AI帮我们生成单元测试，这些枯燥的测试AI还是很擅长的</li>
</ul>
<p>实现的RBTree代码在：<a href="https://github.com/smallnest/exp/blob/master/container/maps/rbtree.go" target="_blank" rel="external">rbtree.go</a><br>单元测试代码在: [rbtree_test.go][<a href="https://github.com/smallnest/exp/blob/master/container/maps/rbtree_test.go]" target="_blank" rel="external">https://github.com/smallnest/exp/blob/master/container/maps/rbtree_test.go]</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。它在1972年由鲁道夫·贝尔发明，被称为“对称二叉B树”，它现代的名字源于利奥尼达斯·J·吉巴斯和罗伯特·塞奇威克于1978年写的一篇论文。红黑树的结构复杂，以至于有些个别公司拿它当做面试题现场实现，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在<code>O(log^n)</code>时间内完成查找、插入和删除。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sqlx: 一个优秀的rust异步SQL库]]></title>
    <link href="https://colobu.com/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/"/>
    <id>https://colobu.com/2024/05/12/sqlx-an-async-pure-Rust-SQL-crate/</id>
    <published>2024-05-12T02:42:26.000Z</published>
    <updated>2024-07-03T03:41:24.521Z</updated>
    <content type="html"><![CDATA[<p>上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的<a href="https://github.com/launchbadge/sqlx" target="_blank" rel="external">sqlx库</a>，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。</p>
<a id="more"></a>
<h2 id="概览">概览</h2>
<p>sqlx是一个为Rust语言提供的功能齐全的数据库访问和查询构建器库。它支持多种数据库,包括PostgreSQL、MySQL、SQLite等。sqlx的设计目标是成为Rust中最直观、高效且类型安全的数据库客户端。</p>
<ul>
<li><strong>真正的异步</strong>。从头开始使用 async/await 构建，以实现最大的并发性。</li>
<li><strong>编译时检查查询</strong>（如果你需要的话）。请注意，sqlx 不是 ORM。</li>
<li><strong>与数据库无关</strong>。支持 PostgreSQL、MySQL、MariaDB、SQLite。</li>
<li><strong>纯 Rust</strong>。Postgres 和 MySQL/MariaDB 驱动程序是使用零不安全的代码以纯 Rust 编写的。</li>
<li><strong>与运行时无关</strong>。在不同的运行时（async-std/tokio/actix）和 TLS 后端（native-tls，rustls）上运行。</li>
</ul>
<blockquote>
<ul>
<li>SQLite 驱动程序使用 libsqlite3 C 库。</li>
<li>sqlx 除非启用了 sqlite 功能，否则会使用 #![forbid(unsafe_code)]。SQLite 驱动程序通过 libsqlite3-sys 直接调用 SQLite3 API，这需要使用不安全的代码。</li>
</ul>
</blockquote>
<p>另外，它还有以下特性：</p>
<ul>
<li>跨平台。作为原生的 Rust 代码，sqlx 可以在任何支持 Rust 的平台上编译。</li>
<li>内建的连接池功能，使用 <code>sqlx::Pool</code>。</li>
<li>行流式处理。数据从数据库异步读取并按需解码。</li>
<li>自动的语句准备和缓存。当使用高级查询 API（<code>sqlx::query</code>）时，语句将按连接进行准备和缓存。</li>
<li>简单的（未准备）查询执行，包括将结果获取到与高级 API 使用的相同 Row 类型。支持批量执行并返回所有语句的结果。</li>
<li>传输层安全性（TLS）在支持的平台（MySQL、MariaDB 和 PostgreSQL）上可用。</li>
<li>使用 <code>LISTEN</code> 和 <code>NOTIFY</code> 以支持 PostgreSQL 异步通知。</li>
<li>支持保存点的嵌套事务。</li>
<li>任何数据库驱动程序，允许在运行时更改数据库驱动程序。<code>AnyPool</code> 根据 URL 方案连接到指定的驱动程序。</li>
</ul>
<p>sqlx 支持编译时检查的查询。然而，它并不是通过提供一个 Rust API 或 DSL（特定领域语言）来构建查询来实现这一点的。相反，它提供了宏，这些宏接受常规的 SQL 作为输入，并确保其对于您的数据库是有效的。其工作原理是，sqlx 在编译时连接到您的开发数据库，让数据库本身验证（并返回一些有关）您的 SQL 查询的信息。这有一些可能令人惊讶的含义：</p>
<ul>
<li>由于 sqlx 不需要解析 SQL 字符串本身，因此可以使用开发数据库接受的任何语法（包括数据库扩展添加的内容）</li>
<li>由于数据库允许您检索的查询信息量不同，从查询宏获得的 SQL 验证的程度取决于数据库。</li>
</ul>
<p>它不是一个ORM库，你如果想使用ORM库，可以参考<a href="https://crates.io/crates/ormx" target="_blank" rel="external">ormx</a>和<a href="https://github.com/SeaQL/sea-orm" target="_blank" rel="external">SeaORM</a>。</p>
<h2 id="安装">安装</h2>
<p>sqlx支持多种异步运行时，你可以通过选择不同的特性来使用不同的异步运行时。目前支持的异步运行时有<code>async-std</code>, <code>tokio</code>和 <code>actix</code>(其实是tokio的别名)。还支持TLS的连接：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># Cargo.toml</div><div class="line">[dependencies]</div><div class="line"># P挑选下面的一行引入sqlx:</div><div class="line"></div><div class="line"># tokio (no TLS)</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span> ] }</div><div class="line"># tokio + native-tls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span>, <span class="string">"tls-native-tls"</span> ] }</div><div class="line"># tokio + rustls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-tokio"</span>, <span class="string">"tls-rustls"</span> ] }</div><div class="line"></div><div class="line"># async-std (no TLS)</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span> ] }</div><div class="line"># async-std + native-tls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span>, <span class="string">"tls-native-tls"</span> ] }</div><div class="line"># async-std + rustls</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"runtime-async-std"</span>, <span class="string">"tls-rustls"</span> ] }</div></pre></td></tr></table></figure>

<p>如果你引入了多个异步运行时，默认首选<code>tokio</code>。</p>
<p>同时你也需要引入所需的数据库特性:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"postgres"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"mysql"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"sqlite"</span> ] }</div><div class="line">sqlx = { version = <span class="string">"0.7"</span>, features = [ <span class="string">"any"</span> ] }</div></pre></td></tr></table></figure>

<p>以及一些其他的关于数据类型的特性等，比如<code>chrono</code>、<code>uuid</code>、<code>time</code>、<code>bstr</code>、<code>bigdecimal</code>、<code>rust_decimal</code>、<code>ipnetwork</code>等。</p>
<p><code>derive</code>支持derive类型的宏，如<code>FromRow</code>, <code>Type</code>, <code>Encode</code>, <code>Decode</code>.</p>
<p><code>macros</code> 增加了对 query*! 宏的支持，该宏允许进行编译时检查的查询。</p>
<p>一个简单的sqlx示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span> <span class="comment">// 异步运行时</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="comment">// 使用一个数据库的连接池</span></div><div class="line">    <span class="comment">// 不同的数据库选择不同的连接池构建器</span></div><div class="line">    <span class="keyword">let</span> pool = MySqlPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .connect(<span class="string">"mysql://root:password@localhost/test"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一个简单的查询</span></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT ？"</span>)</div><div class="line">        .bind(<span class="number">150_i64</span>)</div><div class="line">        .fetch_one(&pool).await?;</div><div class="line"></div><div class="line">    assert_eq!(row.<span class="number">0</span>, <span class="number">150</span>);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="连接数据库">连接数据库</h2>
<p>sqlx支持多种不同的方式来连接数据库。最常见和推荐的是使用连接池。</p>
<h3 id="建立连接池">建立连接池</h3>
<p>连接池可以显著提高应用程序的性能和并发能力。通过重用连接,减少了建立新连接的开销。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个最大5个连接的PostgreSQL连接池。<code>PgPoolOptions</code>提供了各种配置选项。</p>
<p>比如你可以不通过dsn字符串，而是通过方法进行用户名和密码设置：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> conn = PgConnectOptions::new()</div><div class="line">    .host(<span class="string">"secret-host"</span>)</div><div class="line">    .port(<span class="number">2525</span>)</div><div class="line">    .username(<span class="string">"secret-user"</span>)</div><div class="line">    .password(<span class="string">"secret-password"</span>)</div><div class="line">    .ssl_mode(PgSslMode::Require)</div><div class="line">    .connect()</div><div class="line">    .await?;</div></pre></td></tr></table></figure>

<p>甚至可以在解析dsn字符串后再修改特定的参数，如下面的mysql示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::{Connection, ConnectOptions};</div><div class="line"><span class="keyword">use</span> sqlx::mysql::{MySqlConnectOptions, MySqlConnection, MySqlPool, MySqlSslMode};</div><div class="line"></div><div class="line"><span class="comment">// dsn string</span></div><div class="line"><span class="keyword">let</span> conn = MySqlConnection::connect(<span class="string">"mysql://root:password@localhost/db"</span>).await?;</div><div class="line"></div><div class="line"><span class="comment">// 手工构造</span></div><div class="line"><span class="keyword">let</span> conn = MySqlConnectOptions::new()</div><div class="line">    .host(<span class="string">"localhost"</span>)</div><div class="line">    .username(<span class="string">"root"</span>)</div><div class="line">    .password(<span class="string">"password"</span>)</div><div class="line">    .database(<span class="string">"db"</span>)</div><div class="line">    .connect().await?;</div><div class="line"></div><div class="line"><span class="comment">// 从dsn字符串解析Options</span></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> opts: MySqlConnectOptions = <span class="string">"mysql://root:password@localhost/db"</span>.parse()?;</div><div class="line"></div><div class="line"><span class="comment">// 修改参数</span></div><div class="line">opts.log_statements(log::LevelFilter::Trace);</div><div class="line"></div><div class="line"><span class="comment">// 创建连接池</span></div><div class="line"><span class="keyword">let</span> pool = MySqlPool::connect_with(&opts).await?;</div></pre></td></tr></table></figure>

<h3 id="单个连接">单个连接</h3>
<p>有时您可能只需要一个简单的单连接,而不需要连接池。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgConnOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> conn = PgConnOptions::new()</div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="查询">查询</h2>
<p>在 SQL 中，查询可以分为预编译（参数化）或未预编译（简单）的。预编译查询会缓存其查询计划，使用二进制通信模式（降低带宽和更快的解码速度），并利用参数来避免 SQL 注入。未预编译的查询是简单的，并且仅用于无法使用预编译语句的情况，例如各种数据库命令（如 <code>PRAGMA</code>、<code>SET</code> 或 <code>BEGIN</code>）。</p>
<p>sqlx 支持使用这两种类型的查询进行所有操作。在 sqlx 中，一个 <code>&amp;str</code> 被当作未预编译的查询来处理，而 <code>Query</code> 或 <code>QueryAs</code> 结构体被当作预编译的查询来处理。</p>
<blockquote>
<p>在其他语言中，预编译就是 prepared statement，未预编译就是 unprepared statement。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 底层执行</span></div><div class="line">conn.execute(<span class="string">"BEGIN"</span>).await?; <span class="comment">// 未预编译，简单查询</span></div><div class="line">conn.execute(sqlx::query(<span class="string">"DELETE FROM table"</span>)).await?; <span class="comment">// 预编译，此连接会缓存查询</span></div></pre></td></tr></table></figure>

<p>我们应该尽可能使用高级查询接口。为了使这更加容易，这些类型上有终结器（finalizers），这样就不需要使用执行器（executor）来包装它们。<br>换句话说，sqlx 提供了高级查询接口，这些接口使得与数据库的交互更加简洁和直观。这些接口被设计为可以独立工作，而不需要显式地创建一个执行器对象来执行查询。终结器（在这里可能指的是一些内部机制或方法）确保了这些高级接口在使用后可以正确地清理和关闭相关资源，从而简化了开发者的工作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqlx::query(<span class="string">"DELETE FROM table"</span>).execute(&<span class="keyword">mut</span> conn).await?;</div><div class="line">sqlx::query(<span class="string">"DELETE FROM table"</span>).execute(&pool).await?;</div></pre></td></tr></table></figure>

<p>在 sqlx 中，执行查询（execute）的终结器会返回受影响的行数（如果有的话），并丢弃所有接收到的结果。此外，还提供了 <code>fetch</code>、<code>fetch_one</code>、<code>fetch_optional</code> 和 <code>fetch_all</code> 方法来接收结果。</p>
<p><code>sqlx::query</code> 返回的 <code>Query</code> 类型, 它会从数据库中返回 <code>Row&lt;&#39;conn&gt;</code>。可以使用 <code>row.get()</code> 方法通过索引或名称访问列值。由于 <code>Row</code> 保持了对连接的不可变借用，因此一次只能存在一个 <code>Row</code>。</p>
<p><code>fetch</code> 查询的终结器返回一个类似流的类型，该类型会遍历结果集中的行。你可以通过迭代这个流来访问每一行数据。这通常用于处理查询结果集中有多行数据的情况。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 提供 `try_next`</span></div><div class="line"><span class="keyword">use</span> futures::TryStreamExt;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rows = sqlx::query(<span class="string">"SELECT * FROM users WHERE email = ?"</span>)</div><div class="line">    .bind(email)</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">let</span> Some(row) = rows.try_next().await? {</div><div class="line">    <span class="comment">// 将row映射到用户定义的领域类型</span></div><div class="line">    <span class="keyword">let</span> email: &<span class="keyword">str</span> = row.try_get(<span class="string">"email"</span>)?;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了将row映射到领域类型，可以使用以下两种模式之一：</p>
<ol>
<li>手工映射</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stream = sqlx::query(<span class="string">"SELECT * FROM users"</span>)</div><div class="line">    .map(|row: PgRow| {</div><div class="line">        <span class="comment">// 映射row到用户定义的领域类型</span></div><div class="line">    })</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>query_as</code>和<code>bind</code>方法</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[derive(sqlx::FromRow)]</span></div><div class="line"><span class="keyword">struct</span> User { name: String, id: <span class="keyword">i64</span> }</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> stream = sqlx::query_as::&lt;<span class="number">_</span>, User&gt;(<span class="string">"SELECT * FROM users WHERE email = ? OR name = ?"</span>)</div><div class="line">    .bind(user_email)</div><div class="line">    .bind(user_name)</div><div class="line">    .fetch(&<span class="keyword">mut</span> conn);</div></pre></td></tr></table></figure>

<p>除了使用类似流的类型来遍历结果集之外(<code>fetch</code>)，我们还可以使用 <code>fetch_one</code> 或 <code>fetch_optional</code> 来从数据库中请求一个必需的或可选的结果。</p>
<ul>
<li><code>fetch_one</code>: 这个方法会尝试从结果集中获取第一行数据。如果结果集为空（即没有数据），那么 <code>fetch_one</code> 通常会返回一个错误。这个方法适用于你期望查询结果只有一行数据的情况。</li>
<li><code>fetch_optional</code>: 这个方法类似于 <code>fetch_one</code>，但它返回一个可选的结果（<code>Option&lt;Row&gt;</code> 或 <code>Option&lt;T&gt;</code>，如果使用了类型映射）。如果结果集为空，它将返回 <code>None</code> 而不是错误。这使得它在处理可能返回零行或多行数据的查询时更加灵活，但你又只关心第一行数据（如果存在）的情况下特别有用。</li>
</ul>
<p>使用这两个方法可以帮助你更直接地处理那些只返回单个结果（或可能不返回结果）的查询</p>
<h3 id="原生查询和参数化查询">原生查询和参数化查询</h3>
<p>sqlx支持执行原生SQL查询,也支持使用绑定参数进行参数化查询,后者有助于防止SQL注入攻击。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="comment">// 原生查询</span></div><div class="line">    <span class="keyword">let</span> name: String = sqlx::query_scalar(<span class="string">"SELECT name FROM users WHERE id = 1"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 参数化查询 </span></div><div class="line">    <span class="keyword">let</span> count: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT COUNT(*) FROM users WHERE email LIKE $1"</span>)</div><div class="line">        .bind(<span class="string">"%@example.com"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="流式查询">流式查询</h3>
<p>sqlx支持流式查询，这意味着你可以在查询结果返回时立即处理它们，而不需要等待整个结果集加载完毕。这对于处理大量数据或需要实时处理数据的情况非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rows = sqlx::query(<span class="string">"SELECT id, name FROM users"</span>)</div><div class="line">        .fetch(&pool);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">let</span> Some(row) = rows.try_next().await? {</div><div class="line">        <span class="keyword">let</span> id: <span class="keyword">i32</span> = row.try_get(<span class="number">0</span>)?;</div><div class="line">        <span class="keyword">let</span> name: &<span class="keyword">str</span> = row.try_get(<span class="number">1</span>)?;</div><div class="line">        println!(<span class="string">"{} {}"</span>, id, name);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="查询结果映射到Rust数据结构">查询结果映射到Rust数据结构</h3>
<p>最常见的查询方式是将结果映射到一个Rust数据结构,比如结构体或元组结构体。sqlx会自动将数据库列映射到结构体字段。</p>
<p>比如下面这个例子是查询一个用户的信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(FromRow)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    email: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> user = sqlx::query_as::&lt;<span class="number">_</span>, User&gt;(<span class="string">"SELECT id, name, email FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(<span class="number">42</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, user);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>又比如下面这个例子查询一组书籍的信息:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(FromRow)]</span></div><div class="line"><span class="keyword">struct</span> Book {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    title: String,</div><div class="line">    author: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> books = sqlx::query_as::&lt;<span class="number">_</span>, Book&gt;(<span class="string">"SELECT * FROM books"</span>)</div><div class="line">        .fetch_all(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> books {</div><div class="line">        println!(<span class="string">"{} - {} ({})"</span>, book.id, book.title, book.author);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="执行语句">执行语句</h2>
<p>除了查询,sqlx还支持执行其他SQL语句,如INSERT、UPDATE和DELETE等。它提供了多种执行这些语句的方法,包括支持事务。</p>
<h3 id="执行语句-1">执行语句</h3>
<p>最简单的执行语句方式是使用<code>execute</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> inserted_rows = sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2)"</span>)</div><div class="line">        .bind(<span class="string">"User1"</span>).bind(<span class="string">"user1@example.com"</span>)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Inserted {} rows"</span>, inserted_rows);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面这个例子是插入一行数据到<code>users</code>表中，并打印出插入的行数。</p>
<blockquote>
<p>不要被<code>sqlx::query</code>这个名字所误导,它不仅仅用于查询,还可以用于执行其他SQL语句。</p>
</blockquote>
<p>下面是一个插入/更新/删除数据的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    email: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 插入新用户</span></div><div class="line">    <span class="keyword">let</span> user = User { id: <span class="number">0</span>, name: <span class="string">"NewUser"</span>.into(), email: <span class="string">"new@example.com"</span>.into() };</div><div class="line">    <span class="keyword">let</span> id = sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(&user.name).bind(&user.email)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    println!(<span class="string">"Inserted user with id: {}"</span>, id);</div><div class="line"></div><div class="line">    <span class="comment">// 更新用户</span></div><div class="line">    <span class="keyword">let</span> updated_rows = sqlx::query(<span class="string">"UPDATE users SET email=$1 WHERE id=$2"</span>)</div><div class="line">        .bind(<span class="string">"updated@example.com"</span>).bind(id)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Updated {} rows"</span>, updated_rows);</div><div class="line"></div><div class="line">    <span class="comment">// 删除用户</span></div><div class="line">    <span class="keyword">let</span> deleted_rows = sqlx::query(<span class="string">"DELETE FROM users WHERE id=$1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .execute(&pool)</div><div class="line">        .await?</div><div class="line">        .rows_affected();</div><div class="line"></div><div class="line">    println!(<span class="string">"Deleted {} rows"</span>, deleted_rows);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="事务">事务</h3>
<p>sqlx支持事务,你可以使用<code>transaction</code>方法来执行一个事务。<br>要执行多个语句作为一个原子事务,您可以使用<code>begin</code>、<code>commit</code>和<code>rollback</code>函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tx = pool.begin().await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"UPDATE users SET email=$1 WHERE id=$2"</span>)</div><div class="line">        .bind(<span class="string">"new@email.com"</span>).bind(<span class="number">42</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> tx)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"DELETE FROM users WHERE id=$1"</span>)</div><div class="line">        .bind(<span class="number">43</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> tx)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    tx.commit().await?;</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的示例首先开始一个新事务,然后执行两个语句,最后提交事务。如果中间任何一步失败,可以调用<code>rollback</code>回滚整个事务。</p>
<p>面是一个使用sqlx中事务和回滚(rollback)的示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::Error;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 开始一个事务</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> transaction = pool.begin().await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一些操作</span></div><div class="line">    sqlx::query(<span class="string">"UPDATE accounts SET balance = balance - $1 WHERE id = $2"</span>)</div><div class="line">        .bind(<span class="number">100.0</span>) <span class="comment">// 从账号中扣除100元</span></div><div class="line">        .bind(<span class="number">1</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> transaction)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    sqlx::query(<span class="string">"UPDATE accounts SET balance = balance + $1 WHERE id = $2"</span>)</div><div class="line">        .bind(<span class="number">100.0</span>) <span class="comment">// 将100元转账到另一个账号</span></div><div class="line">        .bind(<span class="number">2</span>)</div><div class="line">        .execute(&<span class="keyword">mut</span> transaction)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 模拟一个错误情况</span></div><div class="line">    <span class="keyword">if</span> should_rollback() {</div><div class="line">        <span class="comment">// 回滚事务</span></div><div class="line">        transaction.rollback().await?;</div><div class="line">        println!(<span class="string">"Transaction rolled back"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 提交事务</span></div><div class="line">        transaction.commit().await?;</div><div class="line">        println!(<span class="string">"Transaction committed"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">should_rollback</span></span>() -&gt; <span class="keyword">bool</span> {</div><div class="line">    <span class="comment">// 一些条件判断，决定是否需要回滚</span></div><div class="line">    <span class="comment">// 这里为了演示，我们随机返回true或false</span></div><div class="line">    rand::thread_rng().gen_bool(<span class="number">0.5</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们首先使用<code>pool.begin()</code>开始一个新的事务。然后,我们执行两个查询,分别从一个账户扣除100元,并将这100元转账到另一个账户。<br>接下来,我们调用<code>should_rollback()</code>函数来模拟一个错误情况。如果<code>should_rollback()</code>返回true,我们就调用<code>transaction.rollback().await?</code>来回滚整个事务。否则,我们调用<code>transaction.commit().await?</code>来提交事务。</p>
<p>在真实情况下,您可能会在遇到某些异常或错误时触发回滚,例如:</p>
<ul>
<li>违反了某些业务规则或数据完整性约束</li>
<li>发生了意外的异常或错误</li>
<li>用户取消或中断了操作</li>
<li>出于某些原因,整个事务需要被回滚</li>
</ul>
<p>通过使用事务和回滚,您可以确保数据库中的更改要么全部成功,要么完全回滚,从而保持数据的一致性和完整性。这对于处理敏感操作或需要多个步骤的复杂操作非常重要。</p>
<h2 id="连接池和并发">连接池和并发</h2>
<p>sqlx内置了连接池支持,这使得它天生就支持高效的并发查询。通过连接池,可以避免为每个查询创建新连接的开销。</p>
<h3 id="连接池管理">连接池管理</h3>
<p>sqlx中的连接池由<code>PgPool</code>之类的类型表示。您可以直接创建一个连接池实例,也可以使用<code>PgPoolOptions</code>来定制配置:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">    .max_connections(<span class="number">10</span>)</div><div class="line">    .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">    .await?;</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个最大连接数为10的PostgreSQL连接池。<code>PgPoolOptions</code>提供了各种配置选项,如最大连接数、最小连接数、连接超时等。</p>
<h3 id="并发查询">并发查询</h3>
<p>由于sqlx内置了连接池,因此并发查询变得非常简单。你只需要在多个异步任务中并行执行查询即可:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> std::time::Instant;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line">    <span class="keyword">let</span> tasks = (<span class="number">0</span>..<span class="number">10</span>)</div><div class="line">        .map(|<span class="number">_</span>| {</div><div class="line">            <span class="keyword">let</span> pool = pool.clone();</div><div class="line">            tokio::spawn(async move { <span class="comment">// 并发</span></div><div class="line">                <span class="keyword">let</span> now = Instant::now();</div><div class="line">                <span class="keyword">let</span> <span class="number">_</span> = sqlx::query(<span class="string">"SELECT pg_sleep(1)"</span>).execute(&pool).await;</div><div class="line">                println!(<span class="string">"Task completed in {:?}"</span>, now.elapsed());</div><div class="line">            })</div><div class="line">        })</div><div class="line">        .collect::&lt;Vec&lt;<span class="number">_</span>&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks {</div><div class="line">        task.await?;</div><div class="line">    }</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码创建了一个包含10个任务的并发查询。每个任务都会执行一个简单的查询,然后打印出执行时间。通过并发查询,您可以同时执行多个查询,从而提高查询效率。</p>
<p>下面是一个更实际的示例,模拟了并发处理多个Web请求的场景:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgRow};</div><div class="line"><span class="keyword">use</span> std::io;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> requests = vec![</div><div class="line">        <span class="string">"SELECT * FROM users WHERE id = $1"</span>,</div><div class="line">        <span class="string">"SELECT * FROM products WHERE category = $1"</span>,</div><div class="line">        <span class="string">"SELECT * FROM orders WHERE user_id = $1"</span>,</div><div class="line">    ];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> request <span class="keyword">in</span> requests {</div><div class="line">        <span class="keyword">let</span> rows = sqlx::query(request)</div><div class="line">            .bind(<span class="number">42</span>)</div><div class="line">            .fetch_all(&pool)</div><div class="line">            .await?;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows {</div><div class="line">            print_row(row);</div><div class="line">        }</div><div class="line"></div><div class="line">        println!();</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_row</span></span>(row: PgRow) {</div><div class="line">    <span class="keyword">let</span> cols = row.columns();</div><div class="line">    <span class="keyword">let</span> values: Vec&lt;&<span class="keyword">str</span>&gt; = row.get_refs(cols).into_iter().map(|v| v.unwrap()).collect();</div><div class="line">    println!(<span class="string">"{}"</span>, values.join(<span class="string">", "</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们模拟了处理多个Web请求的场景。我们定义了一个包含多个查询的请求列表,然后并发执行这些查询。每个查询都会返回一组行数据,我们将这些行数据打印出来。通过并发查询,我们可以同时处理多个请求,从而提高系统的性能和效率。</p>
<h2 id="JSON支持">JSON支持</h2>
<p>现代数据库广泛支持 JSON 数据类型,sqlx也为此提供了非常好的支持。您可以方便地查询JSON类型以及将查询结果映射为 JSON。</p>
<h3 id="查询_JSON_类型">查询 JSON 类型</h3>
<p>在数据库中,JSON 类型通常被存储为文本。sqlx允许你直接查询和处理 JSON 数据:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> json_data: serde_json::Value = sqlx::query(r#<span class="string">"</span></div><div class="line">        SELECT '[{"id<span class="string">": 1, "</span>name<span class="string">": "</span>Product <span class="number">1</span><span class="string">"}, {"</span>id<span class="string">": 2, "</span>name<span class="string">": "</span>Product <span class="number">2</span><span class="string">"}]'::json</span></div><div class="line">    "#)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, json_data);</div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子查询了一个JSON数组,并将其直接映射为 <code>serde_json::Value</code>。</p>
<h3 id="将查询结果映射为JSON">将查询结果映射为JSON</h3>
<p>您还可以将常规的查询结果映射为JSON格式。这对于构建API或与前端交互非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> serde::{Serialize, Deserialize};</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Deserialize, Serialize)]</span></div><div class="line"><span class="keyword">struct</span> Product {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    price: <span class="keyword">f64</span>,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> products: Vec&lt;Product&gt; = sqlx::query_as(</div><div class="line">        <span class="string">"SELECT id, name, price FROM products"</span></div><div class="line">    )</div><div class="line">    .fetch_all(&pool)</div><div class="line">    .await?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> json = serde_json::to_string(&products)?;</div><div class="line">    println!(<span class="string">"{}"</span>, json);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子查询了产品列表,并使用<code>serde_json</code>将其序列化为JSON格式。</p>
<h3 id="使用_PostgreSQL_的_JSON_类型">使用 PostgreSQL 的 JSON 类型</h3>
<p>这是一个更全面的示例,展示了如何在 PostgreSQL 中使用 JSON 类型:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> serde::{Deserialize, Serialize};</div><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPool;</div><div class="line"><span class="keyword">use</span> sqlx::types::JsonValue;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Serialize, Deserialize)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">    profile: JsonValue,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 插入用户及其JSON配置文件</span></div><div class="line">    <span class="keyword">let</span> profile = serde_json::json!({</div><div class="line">        <span class="string">"bio"</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">        <span class="string">"interests"</span>: [<span class="string">"coding"</span>, <span class="string">"reading"</span>]</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> user = User {</div><div class="line">        id: <span class="number">0</span>,</div><div class="line">        name: <span class="string">"NewUser"</span>.into(),</div><div class="line">        profile: profile.into(),</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> id = sqlx::query(<span class="string">"INSERT INTO users (name, profile) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(&user.name)</div><div class="line">        .bind(&user.profile)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?</div><div class="line">        .get(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 查询并打印用户及其配置文件</span></div><div class="line">    <span class="keyword">let</span> user: User = sqlx::query_as(<span class="string">"SELECT id, name, profile FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"{:?}"</span>, user);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们首先使用<code>serde_json</code>创建了一个JSON 值,作为用户配置文件。然后,我们将这个JSON 值 插入到数据库中。最后,我们查询用户并将配置文件作为 <code>JsonValue</code> 类型获取。</p>
<h2 id="通知和监听">通知和监听</h2>
<p>sqlx提供了在数据库中监听通知(<code>NOTIFY/LISTEN</code>)的功能,这使得构建基于事件的、实时应用程序成为可能。</p>
<p><strong>数据库通知</strong><br>数据库通知是一种机制,允许应用程序在数据库中发生某些事件时接收通知。这种功能在构建基于事件的系统(如聊天应用程序或实时仪表板)时非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-- 在数据库中触发通知</div><div class="line">NOTIFY channel_name, 'hello';</div></pre></td></tr></table></figure>

<p><strong>使用监听器</strong><br>sqlx通过<code>DatabaseNotification</code>结构体来表示接收到的通知。您可以在应用程序中设置一个监听器,以接收并处理这些通知。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgListener;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> listener = PgListener::bind(<span class="string">"postgresql://localhost/"</span>).await?;</div><div class="line">    listener.listen(<span class="string">"channel_name"</span>).await?;</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> notification = listener.recv().await?;</div><div class="line">        println!(</div><div class="line">            <span class="string">"Received notification: {} ({})"</span>,</div><div class="line">            notification.payload, notification.payload_pretty(),</div><div class="line">        );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的示例创建了一个<code>PostgreSQL</code>监听器,并开始监听名为<code>channel_name</code>的通道。当接收到通知时,它会打印出通知的有效负载。</p>
<p>这是一个更完整的示例,展示了如何在PostgreSQL中设置通知并在应用程序中监听它们:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgListener};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await?;</div><div class="line">    <span class="keyword">let</span> listener = PgListener::bind(<span class="string">"postgresql://localhost/"</span>).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个通知通道</span></div><div class="line">    sqlx::query(<span class="string">"LISTEN channel_name"</span>).execute(&pool).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 在另一个连接上触发通知</span></div><div class="line">    sqlx::query(<span class="string">"NOTIFY channel_name, 'hello'"</span>).execute(&pool).await?;</div><div class="line"></div><div class="line">    <span class="comment">// 等待并处理通知</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Some(notification) = listener.recv().await? {</div><div class="line">        println!(<span class="string">"Received notification: {}"</span>, notification.payload);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们首先创建了一个PostgreSQL监听器,并在数据库中设置了一个名为<code>channel_name</code>的通知通道。然后,我们在另一个连接上触发了一个通知。最后,监听器接收到通知并打印出了它的有效负载。</p>
<h2 id="测试">测试</h2>
<p>编写测试对于任何健壮的软件系统都是必不可少的,sqlx也不例外。幸运的是,sqlx提供了多种方式来测试与数据库交互的代码。</p>
<h3 id="测试连接">测试连接</h3>
<p>最基本的测试是确保您的应用程序能够成功连接到数据库。您可以使用sqlx提供的<code>try_connect</code>函数进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_connection</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::try_connect(<span class="string">"postgres://postgres:@localhost"</span>).await.unwrap();</div><div class="line">    <span class="comment">// 执行一些操作来测试连接...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="测试查询">测试查询</h3>
<p>您还可以测试查询,以确保它们能够正确地执行并返回预期的结果。您可以使用<code>query</code>和<code>query_as</code>函数来测试查询:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::PgPool;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_query</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(<span class="string">"postgres://postgres:@localhost"</span>).await.unwrap();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT 1"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    assert_eq!(row.<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="使用内存数据库">使用内存数据库</h3>
<p>sqlx支持使用内存数据库进行测试,例如SQLite内存数据库。这种方式快速、轻量,非常适合单元测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_query</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = sqlx::SqlitePool::connect(<span class="string">":memory:"</span>).await.unwrap();</div><div class="line">    <span class="comment">// 执行测试...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>对于更全面的集成测试,您可以在测试用例中创建一个临时的测试数据库,执行所需的操作,然后在测试结束时清理该数据库。这种方式更接近真实的生产环境。</p>
<h3 id="使用mock数据库">使用mock数据库</h3>
<p>如<code>msql-srv</code>、<code>opensrv-clickhouse</code>、<code>opensrv-mysql</code>、</p>
<p>下面是一个使用集成测试数据库进行测试的例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgPool, PgRow};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::test]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">test_user_operations</span></span>() {</div><div class="line">    <span class="keyword">let</span> pool = create_test_pool().await;</div><div class="line"></div><div class="line">    <span class="comment">// 准备测试数据</span></div><div class="line">    sqlx::query(<span class="string">"CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT, email TEXT)"</span>)</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 插入新用户</span></div><div class="line">    <span class="keyword">let</span> name = <span class="string">"Test User"</span>.to_owned();</div><div class="line">    <span class="keyword">let</span> email = <span class="string">"test@example.com"</span>.to_owned();</div><div class="line">    <span class="keyword">let</span> id = insert_user(&pool, &name, &email).await;</div><div class="line"></div><div class="line">    <span class="comment">// 查询并验证用户数据</span></div><div class="line">    <span class="keyword">let</span> row: PgRow = sqlx::query_as(<span class="string">"SELECT id, name, email FROM users WHERE id = $1"</span>)</div><div class="line">        .bind(id)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    assert_eq!(row.get::&lt;<span class="keyword">i32</span>, <span class="number">_</span>&gt;(<span class="number">0</span>), id);</div><div class="line">    assert_eq!(row.get::&lt;String, <span class="number">_</span>&gt;(<span class="number">1</span>), name);</div><div class="line">    assert_eq!(row.get::&lt;String, <span class="number">_</span>&gt;(<span class="number">2</span>), email);</div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">insert_user</span></span>(pool: &PgPool, name: &<span class="keyword">str</span>, email: &<span class="keyword">str</span>) -&gt; <span class="keyword">i32</span> {</div><div class="line">    sqlx::query(<span class="string">"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id"</span>)</div><div class="line">        .bind(name)</div><div class="line">        .bind(email)</div><div class="line">        .fetch_one(pool)</div><div class="line">        .await</div><div class="line">        .unwrap()</div><div class="line">        .get(<span class="number">0</span>)</div><div class="line">}</div><div class="line"></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">create_test_pool</span></span>() -&gt; PgPool {</div><div class="line">    <span class="keyword">let</span> db_name = <span class="string">"test_database"</span>;</div><div class="line">    <span class="keyword">let</span> pool = PgPool::connect(&format!(<span class="string">"postgres://postgres:@localhost/{}"</span>, db_name))</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    <span class="comment">// 清理并重新创建测试数据库</span></div><div class="line">    sqlx::query(&format!(<span class="string">"DROP DATABASE IF EXISTS {}"</span>, db_name))</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line">    sqlx::query(&format!(<span class="string">"CREATE DATABASE {}"</span>, db_name))</div><div class="line">        .execute(&pool)</div><div class="line">        .await</div><div class="line">        .unwrap();</div><div class="line"></div><div class="line">    pool</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个示例中,我们首先创建了一个专用的测试数据库。然后我们在这个数据库中创建了一个users表,并进行了插入、查询等操作,最后验证了查询结果。</p>
<h2 id="高级主题">高级主题</h2>
<p>除了基础功能外,sqlx还提供了一些高级功能,如自定义类型映射、编译时检查和性能分析等,可以进一步提高您的生产力和应用程序的性能。</p>
<h3 id="自定义类型映射">自定义类型映射</h3>
<p>sqlx允许您定义自定义的数据类型映射规则,将数据库中的数据类型映射到Rust中的类型。这对于处理一些特殊的数据类型或实现自定义的逻辑非常有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::types::Type;</div><div class="line"><span class="keyword">use</span> sqlx::postgres::{PgTypeInfo, PgValueRef};</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyType(String);</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Type&lt;PgTypeInfo&gt; <span class="keyword">for</span> MyType {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">type_info</span></span>() -&gt; PgTypeInfo {</div><div class="line">        PgTypeInfo::with_name(<span class="string">"mytype"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">readable_name</span></span>() -&gt; String {</div><div class="line">        <span class="string">"MyType"</span>.into()</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">impl</span>&lt;'r&gt; PgValueRef&lt;'r&gt; <span class="keyword">for</span> MyType {</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from_pg_value</span></span>(value: Option&lt;&'r [<span class="keyword">u8</span>]&gt;) -&gt; Option&lt;MyType&gt; {</div><div class="line">        value.map(|bytes| MyType(String::from_utf8_lossy(bytes).into_owned()))</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_pg_value</span></span>(&<span class="keyword">self</span>) -&gt; Option&lt;Vec&lt;<span class="keyword">u8</span>&gt;&gt; {</div><div class="line">        Some(<span class="keyword">self</span>.<span class="number">0</span>.as_bytes().to_vec())</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中,我们定义了一个名为<code>MyType</code>的自定义数据类型,并实现了<code>Type</code>和<code>PgValueRef</code> trait。这样,我们就可以将数据库中的<code>mytype</code>类型映射到Rust中的<code>MyType</code>类型。</p>
<h3 id="编译时检查">编译时检查</h3>
<p>sqlx提供了一些宏和编译时检查功能,可以在编译时捕获一些错误,而不是在运行时才发现。这有助于提高代码质量和安全性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::query;</div><div class="line"></div><div class="line"><span class="preprocessor">#[rustfmt::skip]</span></div><div class="line"><span class="keyword">let</span> query = query!(</div><div class="line">    <span class="string">"</span></div><div class="line">    SELECT id, name, email</div><div class="line">    FROM users</div><div class="line">    WHERE id = ?</div><div class="line">    ",</div><div class="line">    <span class="number">42</span></div><div class="line">);</div></pre></td></tr></table></figure>

<p>上面的<code>query!</code>宏可以在编译时检查SQL语句的语法错误,并验证绑定参数的数量和类型。这样可以避免在运行时才发现这些问题。</p>
<p>类似的宏还有<code>query_as!</code>、<code>query_scalar!</code>、<code>query_file!</code>、<code>query_file!</code>、<code>query_file_scalar!</code>以及它们的变种<code>query_xxx_unchecked!</code>。</p>
<h3 id="执行时间">执行时间</h3>
<p>你可以通过计时来分析查询的性能,并根据结果进行优化。sqlx提供了一些工具来帮助您分析查询的性能,如<code>log_statements</code>、<code>log_slow_statements</code>等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::query;</div><div class="line"><span class="keyword">use</span> sqlx::postgres::PgQueryAs;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = <span class="comment">/* 连接池初始化 */</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> query = query_as!(</div><div class="line">        User,</div><div class="line">        r#<span class="string">"</span></div><div class="line">        SELECT id, name, email</div><div class="line">        FROM users</div><div class="line">        WHERE id = $1</div><div class="line">        "#</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</div><div class="line">        <span class="keyword">let</span> time = std::time::Instant::now();</div><div class="line">        <span class="keyword">let</span> <span class="number">_u</span>sers: Vec&lt;User&gt; = query.bind(<span class="number">42</span>).fetch_all(&pool).await?;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> elapsed = time.elapsed();</div><div class="line">        println!(<span class="string">"Query attempt {attempt} took: {elapsed:?}"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="打印日志">打印日志</h3>
<p><code>ConnectOptions</code>提供了两个设置日志的方法：</p>
<ul>
<li>log_statements: 使用指定的级别打印执行语句</li>
<li>log_slow_statements: 使用指定的级别打印执行时间超过指定阈值的SQL语句。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::postgres::PgPoolOptions;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; Result&lt;(), sqlx::Error&gt; {</div><div class="line">    <span class="keyword">let</span> pool = PgPoolOptions::new()</div><div class="line">        .max_connections(<span class="number">5</span>)</div><div class="line">        .log_statements(log::LevelFilter::Debug) <span class="comment">// 记录所有SQL语句</span></div><div class="line">        .log_slow_statements(log::LevelFilter::Warn, std::time::Duration::from_millis(<span class="number">100</span>)) <span class="comment">// 记录执行时间超过100ms的慢查询</span></div><div class="line">        .connect(<span class="string">"postgres://postgres:@localhost"</span>)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    <span class="comment">// 执行一些查询</span></div><div class="line">    <span class="keyword">let</span> row: (<span class="keyword">i64</span>,) = sqlx::query_as(<span class="string">"SELECT 42"</span>)</div><div class="line">        .fetch_one(&pool)</div><div class="line">        .await?;</div><div class="line"></div><div class="line">    println!(<span class="string">"Result: {}"</span>, row.<span class="number">0</span>);</div><div class="line"></div><div class="line">    Ok(())</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="最佳实践和故障排除">最佳实践和故障排除</h2>
<p>再啰嗦几句。</p>
<p>在使用sqlx时,遵循一些最佳实践可以帮助您编写更加安全、高效和可维护的代码。此外,掌握一些常见错误和故障排除技巧也很有帮助。</p>
<h3 id="sqlx最佳实践">sqlx最佳实践</h3>
<ul>
<li>使用参数化查询: 始终使用带参数的查询,而不是字符串插值。这可以防止SQL注入攻击。</li>
<li>监控连接池指标: 监控连接池的指标,如活跃连接数、获取连接等待时间等,以确保连接池配置正确。</li>
<li>避免ORM: sqlx是一个查询构建器,而不是完整的对象关系映射(ORM)库。尽量避免在sqlx中复制ORM功能。</li>
<li>使用流式查询: 对于大型查询结果集,使用流式查询可以避免一次性加载所有数据到内存中。</li>
<li>利用编译时检查: 使用sqlx提供的query!和query_as!宏,可以在编译时捕获SQL语法错误和类型不匹配等问题。</li>
<li>测试覆盖: 为您的数据库交互代码编写单元测试和集成测试,以确保正确性和稳定性。</li>
</ul>
<h3 id="常见错误和故障排除">常见错误和故障排除</h3>
<ul>
<li>连接池耗尽: 如果出现&quot;连接池耗尽&quot;错误,可能是因为并发请求过多或连接池配置不当导致的。检查连接池指标并适当调整<code>max_connections</code>。</li>
<li>死锁: 在事务中执行多个查询时,可能会遇到死锁情况。确保正确使用事务,并实现重试逻辑。</li>
<li>类型不匹配: 如果遇到&quot;无法将PostgreSQL类型映射到Rust类型&quot;之类的错误,检查您的结构体字段类型是否与数据库列类型匹配。</li>
<li>SQL语法错误: 如果出现SQL语法错误,首先检查您是否使用了参数化查询。如果使用了query!宏,也可能是宏解析出现了问题。</li>
<li>查询性能差: 如果查询性能较差,可以使用sqlx提供的查询追踪功能分析查询执行情况,并优化慢查询。如果频繁创建连接，检查连接池配置是否合理，比如<code>min_connections</code>是否过小</li>
</ul>
<h3 id="生产就绪建议">生产就绪建议</h3>
<ul>
<li>启用日志记录: 在生产环境中合理启用sqlx的日志记录,以便更好地调试和监控应用程序。</li>
<li>监控指标: 监控数据库和连接池指标,如查询执行时间、错误率、连接池利用率等。</li>
<li>进行负载测试: 在部署之前,对您的应用程序进行全面的负载测试,以确保其能够在生产环境中良好运行。</li>
<li>实施安全最佳实践: 遵循安全最佳实践,如使用参数化查询、限制数据库权限、加密敏感数据等。</li>
<li>准备故障转移计划: 制定数据库故障转移计划,以确保应用程序在数据库出现故障时能够正常运行。</li>
<li>持续集成和交付: 将sqlx集成测试纳入您的持续集成和交付流程,以确保代码质量。</li>
</ul>
<h2 id="sqlx生态">sqlx生态</h2>
<p>有一些其他数据库的扩展和支持，比如<code>sqlx-rxqlite</code>、<code>sqlx-clickhouse-ext</code>。</p>
<p><code>sqlx-crud</code>提供常见的数据库操作的CRUD操作的derive宏:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> sqlx::FromRow;</div><div class="line"><span class="keyword">use</span> sqlx_crud::SqlxCrud;</div><div class="line"></div><div class="line"><span class="preprocessor">#[derive(Debug, FromRow, SqlxCrud)]</span></div><div class="line"><span class="keyword">struct</span> User {</div><div class="line">    user_id: <span class="keyword">i32</span>,</div><div class="line">    name: String,</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> Some(user) = User::by_id(&pool, <span class="number">42</span>) {</div><div class="line">    println!(<span class="string">"Found user user_id=42: {:?}"</span>, user);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sqlx-error</code>提供了对<code>sqlx::Error</code>的包装。</p>
<p>当然还有一些其他的库，不过当前关注度还不是很高。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇我介绍了Go生态圈的sqlx库。 Rust生态圈也有一个知名的<a href="https://github.com/launchbadge/sqlx" target="_blank" rel="external">sqlx库</a>，今天给大家介绍一下。这两个没有什么关联啊，纯粹属于名称相同而已。</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sqlx: 扩展标准sql库]]></title>
    <link href="https://colobu.com/2024/05/10/sqlx-a-brief-introduction/"/>
    <id>https://colobu.com/2024/05/10/sqlx-a-brief-introduction/</id>
    <published>2024-05-10T14:08:45.000Z</published>
    <updated>2024-07-03T03:41:24.521Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/jmoiron/sqlx" target="_blank" rel="external">sqlx</a>是一个用于扩展标准库database/sql的库，它提供了一些额外的功能，使得在Go中使用sql更加方便。sqlx的目标是保持database/sql的简单性，同时提供更多的功能。<br><a id="more"></a><br><code>sqlx</code> 为 Go 的标准 <code>database/sql</code> 库提供了一组扩展。sqlx 中的 <code>sql.Conn</code>、<code>sql.DB</code>、<code>sql.TX</code>、<code>sql.Stmt</code>、<code>sql.Rows</code>、<code>sql.Row</code> 等版本都保留了底层接口不变，因此它们的接口是标准接口的超集。这使得将使用 <code>database/sql</code> 的现有代码库与 <code>sqlx</code> 集成相对容易。</p>
<p>主要的额外概念有：</p>
<ul>
<li>将行映射到结构体（支持嵌入结构体）、Map和切片</li>
<li>支持命名参数，包括预编译语句</li>
<li>使用 <code>Get</code> 和 <code>Select</code> 快速从查询到结构体/切片</li>
</ul>
<p><code>sqlx</code> 的目的是无缝地封装 database/sql，并提供在开发数据库驱动的应用程序时有用的便捷方法。它不会改变任何底层的 <code>database/sql</code> 方法。相反，所有扩展行为都是通过在包装类型上定义的新方法来实现的。<br>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> {</div><div class="line">	*sql.Conn</div><div class="line">	driverName <span class="typename">string</span></div><div class="line">	unsafe     <span class="typename">bool</span></div><div class="line">	Mapper     *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> {</div><div class="line">	*sql.DB</div><div class="line">	driverName <span class="typename">string</span></div><div class="line">	unsafe     <span class="typename">bool</span></div><div class="line">	Mapper     *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> Stmt <span class="keyword">struct</span> {</div><div class="line">	*sql.Stmt</div><div class="line">	unsafe <span class="typename">bool</span></div><div class="line">	Mapper *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Tx <span class="keyword">struct</span> {</div><div class="line">	*sql.Tx</div><div class="line">	driverName <span class="typename">string</span></div><div class="line">	unsafe     <span class="typename">bool</span></div><div class="line">	Mapper     *reflectx.Mapper</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> Rows <span class="keyword">struct</span> {</div><div class="line">	*sql.Rows <span class="comment">// 嵌入</span></div><div class="line">	unsafe <span class="typename">bool</span></div><div class="line">	Mapper *reflectx.Mapper</div><div class="line">	<span class="comment">// these fields cache memory use for a rows during iteration w/ structScan</span></div><div class="line">	started <span class="typename">bool</span></div><div class="line">	fields  [][]<span class="typename">int</span></div><div class="line">	values  []<span class="keyword">interface</span>{}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，它的核心类型都是对标准库的封装，然后在此基础上提供了更多的功能。</p>
<p>它是2013年发布，已经有11年的历史了，也许为了保持兼容，它没有对泛型提供支持，甚至<code>interface{}</code>也没有改为<code>any</code>，还支持Go 1.10的版本。</p>
<p>本文假定你已经有了Go开发数据库程序的基础。如果你还不了解，建议你阅读下面的材料：</p>
<ul>
<li><a href="https://golang.org/pkg/database/sql/" target="_blank" rel="external">database/sql documentation</a></li>
<li><a href="http://go-database-sql.org/" target="_blank" rel="external">go-database-sql tutorial</a></li>
</ul>
<blockquote>
<p>本文是编译自作者写的<a href="https://jmoiron.github.io/sqlx/" target="_blank" rel="external">sqlx图解指南</a>。</p>
</blockquote>
<p>引入<code>sqlx</code>库以及sqlite3驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/jmoiron/sqlx</div><div class="line">$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/mattn/<span class="keyword">go</span>-sqlite3</div></pre></td></tr></table></figure>

<p><code>sqlx</code> 的设计初衷是让用户感觉与 <code>database/sql</code> 一样。它主要有 5 种 handler 类型：</p>
<ul>
<li><code>sqlx.Conn</code> - 类似于 <code>sql.Conn</code>，表示一个数据库连接</li>
<li><code>sqlx.DB</code> - 类似于 <code>sql.DB</code>，表示一个数据库连接池</li>
<li><code>sqlx.Tx</code> - 类似于 <code>sql.Tx</code>，表示一个事务</li>
<li><code>sqlx.Stmt</code> - 类似于 <code>sql.Stmt</code>，表示一个预处理语句</li>
<li><code>sqlx.NamedStmt</code> - 表示一个支持命名参数的预处理语句</li>
</ul>
<p>这些 handler 类型都嵌入了它们的 <code>database/sql</code>对应类型，这意味着当你调用 <code>sqlx.DB.Query</code> 时，你实际上调用的是与 <code>sql.DB.Query</code> 相同的代码。这使得它易于引入现有的代码库中。</p>
<p>除了这些，还有 2 种游标类型：</p>
<ul>
<li><code>sqlx.Rows</code> - 类似于 <code>sql.Rows</code>，是从 <code>Queryx</code> 返回的游标，多行结果</li>
<li><code>sqlx.Row</code> - 类似于 <code>sql.Row</code>，是从 <code>QueryRowx</code> 返回的结果,单行结果</li>
</ul>
<p>与 handler 类型一样，<code>sqlx.Rows</code> 嵌入了 <code>sql.Rows</code>。由于无法访问底层实现，<code>sqlx.Row</code> 是对 <code>sql.Row</code> 的部分重新实现，同时保留了标准接口。</p>
<h2 id="连接数据库">连接数据库</h2>
<p>一个 <code>DB</code> 实例并不是连接，而是一个表示数据库的抽象。这就是为什么创建 <code>DB</code> 时不会返回错误也不会引发恐慌（<code>panic</code>）。它在内部维护了一个连接池，并会在首次需要连接时尝试连接。你可以通过 <code>Open</code> 方法创建一个 <code>sqlx.DB</code>，或者通过 <code>NewDb</code> 方法从现有的 <code>sql.DB</code> 创建一个新的<code>sqlx.DB</code>  handler :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> db *sqlx.DB</div><div class="line"> </div><div class="line"><span class="comment">// 完全与内置的一样</span></div><div class="line">db = sqlx.Open(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 从现有的sql.DB创建一个新的sqlx.DB</span></div><div class="line">db = sqlx.NewDb(sql.Open(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>), <span class="string">"sqlite3"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 强制连接并测试是否成功</span></div><div class="line">err = db.Ping()</div></pre></td></tr></table></figure>

<p>在某些情况下，你可能希望同时打开数据库并建立连接，例如，在初始化阶段捕获配置问题。你可以使用 <code>Connect</code> 方法一次性完成这个操作，它会打开一个新的数据库并尝试进行 <code>Ping</code> 操作。<code>MustConnect</code> 变种在遇到错误时会触发 <code>panic</code>，适合在你的包的模块级别使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err error</div><div class="line"></div><div class="line"><span class="comment">// 打开并连接数据库</span></div><div class="line">db, err = sqlx.Connect(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 打开并连接数据库，遇到错误时触发panic</span></div><div class="line">db = sqlx.MustConnect(<span class="string">"sqlite3"</span>, <span class="string">":memory:"</span>)</div></pre></td></tr></table></figure>

<h2 id="基本查询">基本查询</h2>
<p><code>sqlx</code> 中的 handler 类型实现了与 <code>database/sql</code> 相同的基本动词来查询你的数据库：</p>
<ul>
<li><code>Exec(...) (sql.Result, error)</code> - 与 <code>database/sql</code> 中的方法没有变化</li>
<li><code>Query(...) (*sql.Rows, error)</code> - 与 <code>database/sql</code> 中的方法没有变化</li>
<li><code>QueryRow(...) *sql.Row</code> - 与 <code>database/sql</code> 中的方法没有变化</li>
</ul>
<p>以下是内置方法的扩展：</p>
<ul>
<li><code>MustExec() sql.Result</code> -- 执行 <code>Exec</code>，但遇到错误时会触发 <code>panic</code></li>
<li><code>Queryx(...) (*sqlx.Rows, error)</code> - 执行 <code>Query</code>，但返回一个 <code>sqlx.Rows</code></li>
<li><code>QueryRowx(...) *sqlx.Row</code> -- 执行 <code>QueryRow</code>，但返回一个 <code>sqlx.Row</code></li>
</ul>
<p>还有以下新的语义：</p>
<ul>
<li><code>Get(dest interface{}, ...) error</code></li>
<li><code>Select(dest interface{}, ...) error</code></li>
</ul>
<p>现在，我们从未改变的接口开始，一直介绍到新的语义，并解释它们的使用方法。</p>
<h3 id="执行_Exec">执行 Exec</h3>
<p><code>Exec</code> 和 <code>MustExec</code> 从连接池中获取一个连接，并在服务器上执行提供的语句。对于不支持即席（ad-hoc）查询执行的驱动程序，可能会在幕后创建一个预处理语句来执行。在返回结果之前，连接会被返回到连接池中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">schema := <span class="string">`CREATE TABLE place (</span></div><div class="line">    country text,</div><div class="line">    city text NULL,</div><div class="line">    telcode integer);`</div><div class="line"> </div><div class="line"><span class="comment">// 执行一个查询</span></div><div class="line">result, err := db.Exec(schema)</div><div class="line"> </div><div class="line"><span class="comment">// 或者，你可以使用MustExec，在错误时会触发panic</span></div><div class="line">cityState := <span class="string">`INSERT INTO place (country, telcode) VALUES (?, ?)`</span></div><div class="line">countryCity := <span class="string">`INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)`</span></div><div class="line">db.MustExec(cityState, <span class="string">"Hong Kong"</span>,<span class="number"> 852</span>)</div><div class="line">db.MustExec(cityState, <span class="string">"Singapore"</span>,<span class="number"> 65</span>)</div><div class="line">db.MustExec(countryCity, <span class="string">"South Africa"</span>, <span class="string">"Johannesburg"</span>,<span class="number"> 27</span>)</div></pre></td></tr></table></figure>

<p><code>Result</code>有两种可能的数据：<code>LastInsertId()</code> 或 <code>RowsAffected()</code>，这些数据的可用性取决于驱动程序。例如，在 MySQL 中，如果插入的表有自增主键，则 <code>LastInsertId()</code> 将可用，但在 PostgreSQL 中，这些信息只能通过使用 <code>RETURNING</code> 子句从普通行游标中检索。</p>
<h4 id="绑定变量_bindvars">绑定变量 bindvars</h4>
<p>内部称为绑定变量的 <code>?</code> 查询占位符非常重要；您应该始终使用这些占位符向数据库发送值，因为它们可以防止 SQL 注入攻击。<code>database/sql</code> 不会对查询文本进行任何验证；它会原样发送到服务器，同时发送编码后的参数。除非驱动程序实现了特殊接口，否则查询会在执行之前先在服务器上准备。因此，绑定变量是特定于数据库的：</p>
<ul>
<li>MySQL 使用上面展示的 <code>?</code> 变体</li>
<li>PostgreSQL 使用枚举的 <code>$1</code>,<code>$2</code>等绑定变量语法</li>
<li>SQLite 接受 <code>?</code> 和 <code>$1</code> 语法</li>
<li>Oracle 使用 <code>:name</code> 语法</li>
<li>其他数据库可能有所不同。您可以使用 <code>sqlx.DB.Rebind(string) string</code>函数和 <code>?</code> 绑定变量语法来获取适合在当前数据库类型上执行的查询。<br>关于绑定变量的一个常见误解是它们用于插值。它们仅用于参数化，并且<a href="https://use-the-index-luke.com/sql/where-clause/bind-parameters" target="_blank" rel="external">不允许</a>更改 SQL 语句的结构。例如，使用绑定变量来尝试参数化列名或表名将无法工作：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无法工作</span></div><div class="line">db.Query(<span class="string">"SELECT * FROM ?"</span>, <span class="string">"mytable"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 也无法工作</span></div><div class="line">db.Query(<span class="string">"SELECT ?, ? FROM people"</span>, <span class="string">"name"</span>, <span class="string">"location"</span>)</div></pre></td></tr></table></figure>

<h3 id="查询_Query">查询 Query</h3>
<p><code>Query</code> 是使用 <code>database/sql</code> 执行查询并返回行结果的主要方法。<code>Query</code> 返回一个 <code>sql.Rows</code> 对象和一个错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从数据库获取所有地点</span></div><div class="line">rows, err := db.Query(<span class="string">"SELECT country, city, telcode FROM place"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 遍历每一行</span></div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="keyword">var</span> country <span class="typename">string</span></div><div class="line">    <span class="comment">// 注意city可能为NULL，所以我们使用NullString类型</span></div><div class="line">    <span class="keyword">var</span> city    sql.NullString</div><div class="line">    <span class="keyword">var</span> telcode <span class="typename">int</span></div><div class="line">    err = rows.Scan(&country, &city, &telcode)</div><div class="line">}</div><div class="line"><span class="comment">// 检查错误</span></div><div class="line">err = rows.Err()</div></pre></td></tr></table></figure>

<p>你应该把 <code>Rows</code> 当作数据库游标来处理，而不是一个具体化的结果列表。尽管驱动程序缓冲行为可能有所不同，但通过 <code>Next()</code> 进行迭代是限制大型结果集内存使用量的好方法，因为你一次只扫描一行。<code>Scan()</code> 使用反射将 SQL 列返回类型映射到 Go 类型，如 <code>string</code>、<code>[]byte</code> 等。如果你没有遍历完整个结果集，请确保调用 <code>rows.Close()</code> 将连接返回给连接池！</p>
<p><code>Query</code> 返回的错误是可能在服务器准备或执行期间发生的任何错误。这可能包括从连接池中获取了有问题的连接，尽管 <code>database/sql</code> 会重试 <a href="https://golang.org/src/pkg/database/sql/sql.go?s=23888:23957#L885" target="_blank" rel="external">10 次</a>以尝试找到或创建一个工作连接。一般来说，错误会由于错误的 SQL 语法、类型不匹配或不正确的字段和表名导致。</p>
<p>在大多数情况下，<code>Rows.Scan</code> 会复制它从驱动程序获取的数据，因为它不知道驱动程序如何重用其缓冲区。可以使用特殊类型 <code>sql.RawBytes</code> 来从驱动程序实际返回的数据中获取零拷贝的字节切片。在下次调用 <code>Next()</code> 之后，这样的值将不再有效，因为驱动程序可能已经覆盖了那段内存。</p>
<p><code>Query</code> 使用的连接在通过 Next 迭代完所有行之前或调用 <code>rows.Close()</code> 之后一直保持活动状态，之后该连接将被释放。有关更多信息，请参阅关于<a href="https://jmoiron.github.io/sqlx/#connectionPool" target="_blank" rel="external">连接池</a>的部分。</p>
<p><code>sqlx</code> 扩展的 <code>Queryx</code> 行为与 <code>Query</code> 完全一样，但返回的是 <code>sqlx.Rows</code>，它具有扩展的扫描行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Place <span class="keyword">struct</span> {</div><div class="line">    Country       <span class="typename">string</span></div><div class="line">    City          sql.NullString</div><div class="line">    TelephoneCode <span class="typename">int</span> <span class="string">`db:"telcode"`</span></div><div class="line">}</div><div class="line"> </div><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="keyword">var</span> p Place</div><div class="line">    err = rows.StructScan(&p)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sqlx.Rows</code> 的主要扩展方法是 <code>StructScan()</code>，它可以自动将查询结果扫描到结构体的字段中。请注意，为了让 <code>sqlx</code> 能够写入这些字段，这些字段必须是导出的（即首字母大写），这是 Go 中所有序列化器（<code>marshaller</code>）的共同要求。你可以使用 <code>db</code> 结构标签来指定哪个列名映射到结构体的哪个字段，或者使用 <code>db.MapperFunc()</code> 设置新的默认映射规则。默认行为是使用 <code>strings.ToLower</code> 对字段名进行小写转换以匹配列名。有关 <code>StructScan</code>、<code>SliceScan</code> 和 <code>MapScan</code> 的更多信息，请参阅高级扫描部分。</p>
<h2 id="查询单行_QueryRow">查询单行 QueryRow</h2>
<p><code>QueryRow</code> 从服务器获取一行数据。它从连接池中获取一个连接，并使用 <code>Query</code> 执行查询，返回一个 <code>Row</code> 对象，该对象具有自己的内部 <code>Rows</code> 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">row := db.QueryRow(<span class="string">"SELECT * FROM place WHERE telcode=?"</span>,<span class="number"> 852</span>)</div><div class="line"><span class="keyword">var</span> telcode <span class="typename">int</span></div><div class="line">err = row.Scan(&telcode)</div></pre></td></tr></table></figure>

<p>与 <code>Query</code> 不同，<code>QueryRow</code> 返回一个 <code>Row</code> 类型的结果而不返回错误，这使得可以安全地从返回结果中链式调用 <code>Scan</code> 方法。如果执行查询时发生错误，该错误将由 <code>Scan</code> 返回。如果没有行，<code>Scan</code> 会返回 <code>sql.ErrNoRows</code>。如果扫描本身失败（例如，由于类型不匹配），也会返回该错误。</p>
<p><code>Row</code> 结果内部的 <code>Rows</code> 结构在 <code>Scan</code> 时会被关闭，这意味着 <code>QueryRow</code> 使用的连接会在结果被扫描之前一直保持打开状态。这也意味着 <code>sql.RawBytes</code> 在这里不可用，因为引用的内存属于驱动程序，在控制权返回给调用者时可能已经无效。</p>
<p><code>sqlx</code> 扩展的 <code>QueryRowx</code> 将返回一个<code>sqlx.Row</code> 而不是 <code>sql.Row</code>，它实现了与 <code>Rows</code> 相同的扫描扩展，上面已经说过，并在高级扫描部分有详细解释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p Place</div><div class="line">err := db.QueryRowx(<span class="string">"SELECT city, telcode FROM place LIMIT 1"</span>).StructScan(&p)</div></pre></td></tr></table></figure>

<h2 id="Get_和_Select">Get 和 Select</h2>
<p><code>Get</code> 和 <code>Select</code> 是针对 handler 类型的省时的扩展，它们将查询执行与灵活的扫描语义结合起来。为了清楚地解释它们，我们需要谈谈什么是可扫描的：</p>
<ul>
<li>如果一个值不是结构体，比如字符串（<code>string</code>）、整数（<code>int</code>），那么它就是可扫描的。</li>
<li>如果一个值实现了 <code>sql.Scanner</code> 接口，那么它就是可扫描的。</li>
<li>如果一个值是结构体，但没有导出的字段（例如 <code>time.Time</code>），那么它也是可扫描的。</li>
</ul>
<p><code>Get</code> 和 <code>Select</code> 在可扫描类型上使用 <code>rows.Scan</code>，在非可扫描类型上使用 <code>rows.StructScan</code>。它们大致分别对应于 <code>QueryRow</code> 和 <code>Query</code>，其中 <code>Get</code> 用于获取单个结果并进行扫描，而 <code>Select</code> 用于获取结果的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">p := Place{}</div><div class="line">pp := []Place{}</div><div class="line"> </div><div class="line"><span class="comment">//这将直接将第一个地点拉取到p中</span></div><div class="line">err = db.Get(&p, <span class="string">"SELECT * FROM place LIMIT 1"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 这将把telcode大于50的地点拉取到切片pp中</span></div><div class="line">err = db.Select(&pp, <span class="string">"SELECT * FROM place WHERE telcode &gt; ?"</span>,<span class="number"> 50</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 也可以使用普通类型</span></div><div class="line"><span class="keyword">var</span> id <span class="typename">int</span></div><div class="line">err = db.Get(&id, <span class="string">"SELECT count(*) FROM place"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 获取最多10个地点名称</span></div><div class="line"><span class="keyword">var</span> names []<span class="typename">string</span></div><div class="line">err = db.Select(&names, <span class="string">"SELECT name FROM place LIMIT 10"</span>)</div></pre></td></tr></table></figure>

<blockquote>
<p>这两个方法基本可以把我前一篇封装的helper函数替代掉了。</p>
</blockquote>
<p><code>Get</code> 和 <code>Select</code> 都会在查询执行过程中关闭它们创建的 <code>Rows</code>，并返回在此过程中任何步骤遇到的错误。由于它们内部使用 <code>StructScan</code>，因此高级扫描部分中的细节也适用于 <code>Get</code> 和 <code>Select</code>。</p>
<p><code>Select</code> 可以为您节省大量输入，但要小心！它在语义上与 <code>Queryx</code> 不同，因为<strong>它会一次性将整个结果集加载到内存中</strong>。如果查询没有将结果集限制在合理的大小，那么最好使用经典的 <code>Queryx/StructScan</code> 迭代方式。</p>
<blockquote>
<p>试想你要处理几千万行的数据，一条一条的拉取和处理，比一次性读入到内存中处理，资源使用更友好。</p>
</blockquote>
<h2 id="事务_Transaction">事务 Transaction</h2>
<p>要使用事务，您必须使用 <code>DB.Begin()</code> 创建一个事务 handler 。像这样的代码将不会工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这将不会工作，如果连接池&gt;1</span></div><div class="line">db.MustExec(<span class="string">"BEGIN;"</span>)</div><div class="line">db.MustExec(...)</div><div class="line">db.MustExec(<span class="string">"COMMIT;"</span>)</div></pre></td></tr></table></figure>

<p>请记住，<code>Exec</code> 和其他所有查询动词每次都会向数据库请求一个连接，并在使用后将其返回给连接池。因此，无法保证您会收到执行 <code>BEGIN</code> 语句时使用的同一个连接。要使用事务，您必须使用<code>DB.Begin()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tx, err := db.Begin()</div><div class="line">err = tx.Exec(...)</div><div class="line">err = tx.Commit()</div></pre></td></tr></table></figure>

<p><code>DB</code>  handler 还有 <code>Beginx()</code> 和 <code>MustBegin()</code> 扩展方法，它们返回一个 <code>sqlx.Tx</code> 而不是 <code>sql.Tx</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tx := db.MustBegin()</div><div class="line">tx.MustExec(...)</div><div class="line">err = tx.Commit()</div></pre></td></tr></table></figure>

<p><code>sqlx.Tx</code> 拥有 <code>sqlx.DB</code> 的所有 handler 扩展。</p>
<p>由于事务是连接状态，<code>Tx</code> 对象必须从连接池中绑定并控制一个单一的连接。在整个生命周期中，<code>Tx</code> 将维持这个单一的连接，只有在调用 <code>Commit()</code> 或 <code>Rollback()</code> 时才会释放它。你应该至少调用这两个函数之一，否则连接将一直被占用，直到垃圾收集器回收。</p>
<p>因为在一个事务中你只能使用一个连接，所以你一次只能执行一个语句；在执行另一个查询之前，必须分别扫描或关闭 <code>Row</code> 和 <code>Rows</code> 类型的游标。如果你尝试在服务器向你发送结果时向服务器发送数据，它可能会破坏连接。</p>
<p>最后，<code>Tx</code> 对象并不实际上在服务器上执行任何行为；它们只是执行一个 <code>BEGIN</code> 语句并绑定一个单一的连接。事务的实际行为，包括锁定和隔离等，完全是未指定的，并且依赖于数据库。</p>
<h2 id="预编译语句_Prepared_Statement">预编译语句 Prepared Statement</h2>
<p>在大多数数据库中，当执行查询时，实际上会在幕后准备语句。但是，您也可以使用 <code>sqlx.DB.Prepare()</code> 明确地准备语句以便在其他地方重用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stmt, err := db.Prepare(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line">row = stmt.QueryRow<span class="number">(65</span>)</div><div class="line"> </div><div class="line">tx, err := db.Begin()</div><div class="line">txStmt, err := tx.Prepare(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line">row = txStmt.QueryRow<span class="number">(852</span>)</div></pre></td></tr></table></figure>

<p><code>Prepare</code> 实际上是在数据库上执行准备操作的，因此它需要一个连接和连接状态。<code>database/sql</code> 为你抽象了这些，允许你通过在新连接上自动创建语句，从单个 <code>Stmt</code> 对象在多个连接上并发执行。<code>Preparex()</code> 返回一个 <code>sqlx.Stmt</code>，它拥有 <code>sqlx.DB</code> 和 <code>sqlx.Tx</code>的所有 handler 扩展功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stmt, err := db.Preparex(<span class="string">`SELECT * FROM place WHERE telcode=?`</span>)</div><div class="line"><span class="keyword">var</span> p Place</div><div class="line">err = stmt.Get(&p,<span class="number"> 852</span>)</div></pre></td></tr></table></figure>

<p>标准的 <code>sql.Tx</code> 对象还有一个 <code>Stmt()</code> 方法，该方法可以从预先存在的语句中返回一个特定于事务的语句。<code>sqlx.Tx</code> 有一个 <code>Stmtx</code> 版本，可以从现有的 <code>sql.Stmt</code> 或 <code>sqlx.Stmt</code> 创建一个新的特定于事务的 <code>sqlx.Stmt</code>。</p>
<h2 id="查询辅助方法_Query_Helper">查询辅助方法 Query Helper</h2>
<p><code>database/sql</code> 包不会对您的实际查询文本进行任何处理。这使得在您的代码中使用特定于后端的特性变得轻而易举；您可以像在数据库提示符中一样编写查询。虽然这非常灵活，但它使得编写某些类型的查询变得困难。</p>
<h3 id="&quot;In&quot;_子句">&quot;In&quot; 子句</h3>
<p>由于 <code>database/sql</code> 不会检查您的查询，而是直接将参数传递给驱动程序，因此处理带有 <code>IN</code> 子句的查询会变得困难：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM users WHERE level IN (?);</div></pre></td></tr></table></figure>

<p>当在后端将其准备为语句时，绑定变量 ? 只会对应一个参数，但通常我们希望它根据某个切片的长度来对应可变数量的参数，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levels = []<span class="typename">int</span><span class="number">{4</span>,<span class="number"> 6</span>,<span class="number"> 7</span>}</div><div class="line">rows, err := db.Query(<span class="string">"SELECT * FROM users WHERE level IN (?);"</span>, levels)</div></pre></td></tr></table></figure>

<p>通过使用 sqlx.In 预先处理查询语句，可以实现这种模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levels = []<span class="typename">int</span><span class="number">{4</span>,<span class="number"> 6</span>,<span class="number"> 7</span>}</div><div class="line">query, args, err := sqlx.In(<span class="string">"SELECT * FROM users WHERE level IN (?);"</span>, levels)</div><div class="line"> </div><div class="line"><span class="comment">// sqlx.In返回带有`?`绑定变量的查询，我们可以重新绑定它以适应我们的后端</span></div><div class="line">query = db.Rebind(query)</div><div class="line">rows, err := db.Query(query, args...)</div></pre></td></tr></table></figure>

<p>使用 <code>sqlx.In</code> 预先处理查询语句可以实现这种模式：<code>sqlx.In</code> 会扩展传递给它的查询中的任何绑定变量（<code>bindvars</code>），这些绑定变量对应于参数中的切片，并扩展到与切片长度相同数量的占位符，然后将这些切片元素追加到一个新的参数列表中。它仅对 <code>?</code> 绑定变量执行此操作；您可以使用 <code>db.Rebind</code> 来获取适合您后端的查询语句。</p>
<h3 id="命名查询_Named_Query">命名查询 Named Query</h3>
<p>命名查询在许多其他数据库包中都很常见。它们允许您使用绑定变量语法，该语法通过结构体字段的名称或映射键来绑定查询中的变量，而不是按位置引用所有内容。结构体字段的命名约定遵循 <code>StructScan</code> 的规则，使用 <code>NameMapper</code> 和 <code>db</code> 结构体标签。与命名查询相关的有两个额外的查询动词：</p>
<ul>
<li><code>NamedQuery(...) (*sqlx.Rows, error)</code> - 类似于 Queryx，但使用命名绑定变量</li>
<li><code>NamedExec(...) (sql.Result, error)</code> - 类似于 Exec，但使用命名绑定变量</li>
</ul>
<p>还有一个额外的 handler 类型：</p>
<ul>
<li><code>NamedStmt</code> - 一个 <code>sqlx.Stmt</code>，可以使用命名绑定变量进行准备</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用结构体的命名查询</span></div><div class="line">p := Place{Country: <span class="string">"South Africa"</span>}</div><div class="line">rows, err := db.NamedQuery(<span class="string">`SELECT * FROM place WHERE country=:country`</span>, p)</div><div class="line"> </div><div class="line"><span class="comment">// 使用map的命名查询</span></div><div class="line">m := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}{<span class="string">"city"</span>: <span class="string">"Johannesburg"</span>}</div><div class="line">result, err := db.NamedExec(<span class="string">`SELECT * FROM place WHERE city=:city`</span>, m)</div></pre></td></tr></table></figure>

<p>命名查询的执行和准备适用于结构体和Map。如果你想要完整的查询操作集，可以准备一个命名语句并使用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p := Place{TelephoneCode:<span class="number"> 50</span>}</div><div class="line">pp := []Place{}</div><div class="line"> </div><div class="line"><span class="comment">// 查询所有telcode大于50的地点</span></div><div class="line">nstmt, err := db.PrepareNamed(<span class="string">`SELECT * FROM place WHERE telcode &gt; :telcode`</span>)</div><div class="line">err = nstmt.Select(&pp, p)</div></pre></td></tr></table></figure>

<p>命名查询支持是通过解析查询中的 <code>:param</code> 语法，并将其替换为底层数据库支持的绑定变量来实现的，然后在执行时执行映射，因此它可以在 <code>sqlx</code> 支持的任何数据库上使用。你还可以使用 <code>sqlx.Named</code>，它使用 <code>?</code> 绑定变量，并且可以与 <code>sqlx.In</code> 组合使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arg := <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}{</div><div class="line">    <span class="string">"published"</span>: <span class="constant">true</span>,</div><div class="line">    <span class="string">"authors"</span>: []<span class="number">{8</span>,<span class="number"> 19</span>,<span class="number"> 32</span>,<span class="number"> 44</span>},</div><div class="line">}</div><div class="line">query, args, err := sqlx.Named(<span class="string">"SELECT * FROM articles WHERE published=:published AND author_id IN (:authors)"</span>, arg)</div><div class="line">query, args, err := sqlx.In(query, args...)</div><div class="line">query = db.Rebind(query)</div><div class="line">db.Query(query, args...)</div></pre></td></tr></table></figure>

<h2 id="高级扫描_Advanced_Scanning">高级扫描 Advanced Scanning</h2>
<p><code>StructScan</code> 相当复杂但具有欺骗性。它支持嵌入的结构体，并使用与 Go 用于嵌入属性和方法访问相同的优先级规则为字段赋值。这种用法的一个常见例子是在多个表之间共享表模型的公共部分，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> AutoIncr <span class="keyword">struct</span> {</div><div class="line">    ID       <span class="typename">uint64</span></div><div class="line">    Created  time.Time</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">type</span> Place <span class="keyword">struct</span> {</div><div class="line">    Address <span class="typename">string</span></div><div class="line">    AutoIncr</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</div><div class="line">    Name <span class="typename">string</span></div><div class="line">    AutoIncr</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用上述结构体，<code>Person</code> 和 <code>Place</code> 都能够从 <code>StructScan</code> 中接收 <code>id</code> 和 <code>created</code> 列，因为它们都嵌入了定义了这些列的 <code>AutoIncr</code> 结构体。这个功能可以让你快速地为连接操作创建一个临时的表。它还可以递归地工作；以下结构体可以通过 Go 的点运算符和 <code>StructScan</code> 访问 <code>Person</code> 的 <code>Name</code> <code>字段、AutoIncr</code> 的 <code>ID</code> 和 <code>Created</code> 字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> {</div><div class="line">    BossID <span class="typename">uint64</span></div><div class="line">    EmployeeID <span class="typename">uint64</span></div><div class="line">    Person</div><div class="line">}</div></pre></td></tr></table></figure>

<p>请注意，<code>sqlx</code> 历史上一度支持此功能用于非嵌入结构体，但这最终变得令人困惑，因为用户使用此功能来定义关系，并两次嵌入相同的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> {</div><div class="line">    Father Person</div><div class="line">    Mother Person</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这会引起一些问题。在 Go 语言中，隐藏后代字段是合法的；如果嵌入示例中的 <code>Employee</code> 定义了一个 <code>Name</code> 字段，那么它会优先于 <code>Person</code> 的 <code>Name</code> 字段。但是，模糊的选择器是非法的，并且会导致运行时错误。如果我们想为 <code>Person</code> 和 <code>Place</code> 创建一个快速的 <code>JOIN</code> 类型，那么我们应该在哪里放置 <code>id</code> 列，这两个类型都通过嵌入的 <code>AutoIncr</code> 定义了 <code>id</code> 列？是否会出现错误？</p>
<p>由于 <code>sqlx</code> 构建字段名到字段地址映射的方式，在将结果扫描到结构体时，它不再知道在遍历结构体树时是否遇到过两次相同的字段名。因此，与 Go <code>语言不同，StructScan</code> 会选择遇到的<strong>第一个具有该名称的字段</strong>。由于 Go 语言的结构体字段是从上到下排序的，而 <code>sqlx</code> 为了保持优先级规则，采用广度优先遍历，因此会选择<strong>最浅、最顶部</strong>的定义。例如，在以下类型中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PersonPlace <span class="keyword">struct</span> {</div><div class="line">    Person</div><div class="line">    Place</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>StructScan</code> 会将 <code>id</code> 列的结果设置在 <code>Person.AutoIncr.ID</code> 中，也可以通过 <code>Person.ID</code> 访问。为了避免混淆，建议你在 <code>SQL</code> 中使用 <code>AS</code> 来创建列别名。</p>
<h3 id="安全扫描目的字段">安全扫描目的字段</h3>
<p>默认情况下，如果某一列无法映射到目标结构体中的字段，<code>StructScan</code> 将返回一个错误。这模仿了 Go 中对未使用变量的处理方式，但与标准库中的序列化器（如 <code>encoding/json</code>）的行为不符。由于 SQL 通常以比解析 JSON 更受控的方式执行，并且这些错误通常是编码错误，因此决定默认返回错误。</p>
<p>与未使用的变量类似，忽略的列会浪费网络和数据库资源，而且在没有映射器通知未找到某些内容的情况下，很难在早期检测到不兼容的映射或结构标签中的拼写错误。</p>
<p>尽管如此，在某些情况下，可能希望忽略没有目标字段的列。为此，每种 Handle 类型都有一个 Unsafe 方法，它返回该 handler 的新副本，并关闭此安全检查：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p Person</div><div class="line"><span class="comment">// 由于place列没有字段目标，所以这里的err不是nil</span></div><div class="line">err = db.Get(&p, <span class="string">"SELECT * FROM person, place LIMIT 1;"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// 这不会返回错误，即使place列没有目标</span></div><div class="line">udb := db.Unsafe()</div><div class="line">err = udb.Get(&p, <span class="string">"SELECT * FROM person, place LIMIT 1;"</span>)</div></pre></td></tr></table></figure>

<h3 id="控制命名映射">控制命名映射</h3>
<p>用作 <code>StructScan</code> 目标的结构体字段必须大写以便 <code>sqlx</code> 能够访问。因此，<code>sqlx</code> 使用了一个 <code>NameMapper</code>，该映射器将字段名应用 <code>strings.ToLower</code> 函数以将它们映射到行结果中的列。但是，这并不总是符合需求的，这取决于你的数据库模式，因此 <code>sqlx</code> 允许以多种方式自定义映射。</p>
<p>最简单的方式是通过使用 <code>sqlx.DB.MapperFunc</code> 为数据库 handler 设置映射器，该方法接收一个类型为 <code>func(string) string</code> 的参数。如果你的库需要特定的映射器，并且你不想污染你接收到的 <code>sqlx.DB</code>，你可以为库创建一个副本以确保使用特定的默认映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果我们的数据库模式使用大写列，我们可以使用普通字段</span></div><div class="line">db.MapperFunc(strings.ToUpper)</div><div class="line"> </div><div class="line"><span class="comment">// 假定一个库使用小写列，我们可以创建一个副本</span></div><div class="line"><span class="built_in">copy</span> := sqlx.NewDb(db.DB, db.DriverName())</div><div class="line"><span class="built_in">copy</span>.MapperFunc(strings.ToLower)</div></pre></td></tr></table></figure>

<p>每个 <code>sqlx.DB</code> 使用 <code>sqlx/reflectx</code> 包的 <code>Mapper</code> 来实现这种映射，并将活动的映射器公开为 <code>sqlx.DB.Mapper</code>。你可以通过直接设置来进一步自定义 DB 上的映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/jmoiron/sqlx/reflectx"</span></div><div class="line"> </div><div class="line"><span class="comment">// 创建一个新的映射器，它将使用结构字段标签“json”而不是“db”</span></div><div class="line">db.Mapper = reflectx.NewMapperFunc(<span class="string">"json"</span>, strings.ToLower)</div></pre></td></tr></table></figure>

<h3 id="替代扫描类型">替代扫描类型</h3>
<p>除了使用 <code>Scan</code> 和 <code>StructScan`</code>，sqlx<code>的</code>Row<code>或</code>Rows` 还可以用于自动返回结果切片或Map：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="comment">// cols 代表所有列结果的[]interface{}</span></div><div class="line">    cols, err := rows.SliceScan()</div><div class="line">}</div><div class="line"> </div><div class="line">rows, err := db.Queryx(<span class="string">"SELECT * FROM place"</span>)</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{})</div><div class="line">    err = rows.MapScan(results)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>SliceScan</code> 返回一个 <code>[]interface{}</code>，其中包含所有列的数据，这在你代表第三方执行查询且无法知道可能会返回哪些列的情况下非常有用。<code>MapScan</code> 的行为类似，但它将列名映射到 <code>interface{}</code> 类型的值上。这里有一个重要的注意事项：<code>rows.Columns()</code>返回的结果不包括完全限定的名称，因此执行如 <code>SELECT a.id, b.id FROM a NATURAL JOIN b</code> <code>的查询时，Columns</code> 的结果将是 <code>[]string{&quot;id&quot;, &quot;id&quot;}</code>，这会导致你的Map中其中一个结果会被覆盖。</p>
<h2 id="自定义类型">自定义类型</h2>
<p>上面的例子都使用了内置类型来进行扫描和查询，但 <code>database/sql</code> 提供了接口，允许你使用任何自定义类型：</p>
<ul>
<li><code>sql.Scanner</code> 允许你在 <code>Scan()</code> 中使用自定义类型</li>
<li><code>driver.Valuer</code> 允许你在 <code>Query/QueryRow/Exec</code> 中使用自定义类型</li>
</ul>
<p>这些是标准接口，使用它们可以确保与任何可能在 <code>database/sql</code> 之上提供服务的库的兼容性。要详细了解如何使用它们，请阅读<a href="http://jmoiron.net/blog/built-in-interfaces" target="_blank" rel="external">这篇博客文章</a>或查看 <a href="https://github.com/jmoiron/sqlx/blob/master/types/types.go" target="_blank" rel="external">sqlx/types</a> 包，该包实现了一些标准的有用类型。</p>
<h2 id="连接池">连接池</h2>
<p>语句准备和查询执行需要一个连接，DB 对象将管理一个连接池，以便它可以安全地用于并发查询。在 Go 1.2 及更高版本中，有两种方式控制连接池的大小：</p>
<ul>
<li>DB.SetMaxIdleConns(n int)</li>
<li>DB.SetMaxOpenConns(n int)</li>
</ul>
<p>默认情况下，连接池会无限制地增长，并且当池中没有空闲连接可用时，就会创建新的连接。你可以使用 <code>DB.SetMaxOpenConns</code> 来设置池的最大大小。未被使用的连接会被标记为空闲状态，如果不再需要，它们就会被关闭。为了避免频繁地创建和关闭连接，请使用 <code>DB.SetMaxIdleConns</code> 将最大空闲大小设置为适合你的查询负载的大小。</p>
<p>如果不小心持有连接，很容易遇到麻烦。为了避免这种情况：</p>
<ul>
<li>确保你使用 <code>Scan()</code> 扫描每个 <code>Row</code> 对象</li>
<li>确保你通过 <code>Close()</code> 或完全迭代 <code>Next()</code> 来处理每个 <code>Rows</code> 对象</li>
<li>确保每个事务都通过 <code>Commit()</code> 或 <code>Rollback()</code> 返回其连接</li>
</ul>
<p>如果你忽略了这些操作中的任何一个，它们所使用的连接可能会被保持到垃圾回收，而你的数据库将最终创建大量连接以补偿正在使用的连接。请注意，<code>Rows.Close()</code> 可以安全地多次调用，因此不必担心在可能不必要的地方调用它。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/jmoiron/sqlx" target="_blank" rel="external">sqlx</a>是一个用于扩展标准库database/sql的库，它提供了一些额外的功能，使得在Go中使用sql更加方便。sqlx的目标是保持database/sql的简单性，同时提供更多的功能。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“测试 Rust 的 I/O 性能”]]></title>
    <link href="https://colobu.com/2024/05/10/Linux-File-IO-using-Rust/"/>
    <id>https://colobu.com/2024/05/10/Linux-File-IO-using-Rust/</id>
    <published>2024-05-09T23:38:13.000Z</published>
    <updated>2024-07-03T03:41:24.495Z</updated>
    <content type="html"><![CDATA[<p>我们将尝试使用 Rust 来比较读取文件的各种不同方法。除了 <code>wc -l</code> 之外，我们将使用 <code>criterion</code> 对每个函数运行 10 次，然后取平均值。</p>
<p>以下基准测试的代码存放在 <a href="https://github.com/deepankarsharma/shatranj/blob/main/benches/bench.rs" target="_blank" rel="external">Benchmark code for Linux IO using Rust</a>。<br>在以下代码中，BUFFER_SIZE 为 8192，NUM_BUFFERS 为 32。</p>
<p>原文: <a href="[Linux File IO using Rust (opdroid.org"># Linux File IO using Rust</a>](<a href="https://opdroid.org/rust-io.html)" target="_blank" rel="external">https://opdroid.org/rust-io.html)</a>) by opdroid</p>
<a id="more"></a>
<h2 id="测试机器细节">测试机器细节</h2>
<ol>
<li>Framework 16 笔记本，带有锐龙 7840 HS 处理器和 64 G 内存的电脑。电源已接通并启用了性能模式。（这个笔记本是一个模块化的笔记本）</li>
<li>SSD: WD_BLACK SN850X 4000GB。使用Gnome Disks进行测试显示读取速度为3.6 GB/s(样本大小为1000MB,共100个样本)。</li>
<li>文件系统：btrfs</li>
<li>操作系统版本 (uname 结果)：Linux fedora 6.8.8-300. Fc 40. X 86_64 #1 SMP PREEMPT_DYNAMIC Sat Apr 27 17:53:31 UTC 2024 x 86_64 GNU/Linux</li>
</ol>
<h2 id="文件细节">文件细节</h2>
<ul>
<li>未压缩大小：22G</li>
<li>行数：200,000,000 </li>
<li>使用 btrfs 压缩（zstd）后的压缩大小：5.3G</li>
</ul>
<h2 id="对于不耐烦的读者：结果概述">对于不耐烦的读者：结果概述</h2>
<table>
<thead>
<tr>
<th>读取方法</th>
<th>时间 (单位：秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mmap with AVX512</td>
<td>2.61</td>
</tr>
<tr>
<td>Mmap with AVX2</td>
<td>2.64</td>
</tr>
<tr>
<td>io_uring with Vectored IO</td>
<td>2.86</td>
</tr>
<tr>
<td>Vectored IO</td>
<td>2.89</td>
</tr>
<tr>
<td>Mmap</td>
<td>3.43</td>
</tr>
<tr>
<td>io_uring</td>
<td>5.26</td>
</tr>
<tr>
<td>wc -l (baseline)</td>
<td>8.01</td>
</tr>
<tr>
<td>Direct IO</td>
<td>10.56</td>
</tr>
<tr>
<td>BufReader without appends</td>
<td>15.94</td>
</tr>
<tr>
<td>BufReader with lines().count()</td>
<td>33.50</td>
</tr>
</tbody>
</table>
<p>一个有趣的观察是，AVX512 需要 2.61 秒，文件大小约为 22G，而 SSD 基准测试显示读取速度为 3.6 GB/s。这意味着文件应该在大约 6 秒内被读取完毕。但 AVX512 的实现实际上是以约 8.4 GB/s 的速度读取文件。</p>
<p><strong>这是怎么回事呢？比磁盘的读取速度都快不少？不科学啊？</strong></p>
<p>原来 Fedora 使用了 btrfs 文件系统，它默认启用了 zstd 压缩。实际的磁盘上大小可以使用 <code>compsize</code> 命令来查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">opdroid<span class="variable">@box</span><span class="symbol">:~/tmp</span><span class="variable">$ </span>sudo compsize data </div><div class="line"><span class="constant">Processed</span> <span class="number">1</span> file, <span class="number">177437</span> regular extents (<span class="number">177437</span> refs), <span class="number">0</span> inline.</div><div class="line"><span class="constant">Type</span>       <span class="constant">Perc</span>     <span class="constant">Disk</span> <span class="constant">Usage</span>   <span class="constant">Uncompressed</span> <span class="constant">Referenced</span>  </div><div class="line"><span class="constant">TOTAL</span>       <span class="number">24</span>%      <span class="number">5.3</span>G          <span class="number">21</span>G          <span class="number">21</span>G       </div><div class="line">none       <span class="number">100</span>%       <span class="number">32</span>K          <span class="number">32</span>K          <span class="number">32</span>K       </div><div class="line">zstd        <span class="number">24</span>%      <span class="number">5.3</span>G          <span class="number">21</span>G          <span class="number">21</span>G</div></pre></td></tr></table></figure>

<p><strong>感谢这些优秀的人</strong>  </p>
<ul>
<li>@alextjensen - 感谢他指导我使用 <code>BufReader</code> 的合理默认值，并编译为本机架构。  </li>
<li>@aepau2 - 感谢他发现了 <code>wc</code> 数字中的一个明显错误。我在使用 <code>wc</code> 测量之前忘记了清空缓存。  </li>
<li>@rflaherty71 - 感谢他建议我使用更多且更大的缓冲区（64 x 64k）。  </li>
<li>@daniel_c0deb0t - 感谢他建议我使用更大的缓冲区。 </li>
<li></li>
</ul>
<p>不使用我们编写的代码作为基线总是一个好主意，这样比较客观。</p>
<h2 id="使用_wc_-l_作为基线">使用 <code>wc -l</code> 作为基线</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">opdroid<span class="variable">@box</span><span class="symbol">:~/tmp</span><span class="variable">$ </span>time wc -l data</div><div class="line"><span class="number">200000000</span> data</div><div class="line"></div><div class="line">real    0m8.<span class="number">010</span>s</div><div class="line">user    0m<span class="number">0</span>.<span class="number">193</span>s</div><div class="line">sys 0m7.<span class="number">591</span>s</div></pre></td></tr></table></figure>

<p>在每个函数的末尾，我们使用以下命令重置文件缓存。我还没有弄清楚如何在 criterion 中使用 teardown 函数，以便这个时间不被计入总耗时。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// TODO: move to a teardown function in criterion</div><div class="line">fn reset_file_caches() {</div><div class="line">    // <span class="operator"><span class="keyword">Execute</span> the command <span class="keyword">to</span> <span class="keyword">reset</span> file caches</span></div><div class="line">    let <span class="keyword">output</span> = Command::new(<span class="string">"sudo"</span>)</div><div class="line">        .arg(<span class="string">"sh"</span>)</div><div class="line">        .arg(<span class="string">"-c"</span>)</div><div class="line">        .arg(<span class="string">"echo 3 &gt; /proc/sys/vm/drop_caches"</span>)</div><div class="line">        .<span class="keyword">output</span>()</div><div class="line">        .expect(<span class="string">"Failed to reset file caches"</span>);</div><div class="line"></div><div class="line">    // <span class="operator"><span class="keyword">Check</span> <span class="keyword">if</span> the command executed successfully</span></div><div class="line">    <span class="keyword">if</span> !<span class="keyword">output</span>.<span class="keyword">status</span>.success() {</div><div class="line">        panic!(<span class="string">"Failed to reset file caches: {:?}"</span>, <span class="keyword">output</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="方法1：使用_BufReader_读取文件，并使用_reader-lines()-count()_计算行数">方法1：使用 <code>BufReader</code> 读取文件，并使用 <code>reader.lines().count()</code> 计算行数</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_standard</span></span>(filename: &<span class="keyword">str</span>) -&gt; Result&lt;usize, std::io::Error&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(filename)?;</div><div class="line">    <span class="keyword">let</span> reader = BufReader::with_capacity(<span class="number">16</span> * <span class="number">1024</span>, file);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newline_count = reader.lines().count();</div><div class="line"></div><div class="line">    reset_file_caches();</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这需要大约 36.5 秒的时间。</p>
<p><img src="1.png" alt=""><br>在 <code>count_newlines_standard</code> 函数中，字符串拼接（String appends）可能是导致性能问题的原因。</p>
<h2 id="方法_2：使用_BufReader_读取文件并避免字符串拼接">方法 2：使用 <code>BufReader</code> 读取文件并避免字符串拼接</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_standard_non_appending</span></span>(filename: &<span class="keyword">str</span>) -&gt; Result&lt;usize, std::io::Error&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(filename)?;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> reader = BufReader::with_capacity(<span class="number">64</span> * <span class="number">1024</span>, file);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newline_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> len = {</div><div class="line">            <span class="keyword">let</span> buffer = reader.fill_buf()?;</div><div class="line">            <span class="keyword">if</span> buffer.is_empty() {</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">            newline_count += buffer.iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line">            buffer.len()</div><div class="line">        };</div><div class="line"></div><div class="line">        reader.consume(len);</div><div class="line">    }</div><div class="line"></div><div class="line">    reset_file_caches();</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这大约需要 15.94 秒。这比使用字符串拼接的版本快了一半以上。</p>
<p>当我们查看火焰图时，我们可以确认字符串拼接的操作已经不存在了。<br><img src="2.png" alt=""></p>
<h2 id="方法_3：使用_Direct_I/O_读取文件">方法 3：使用 Direct I/O 读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_direct_io</span></span>(filename: &<span class="keyword">str</span>) -&gt; Result&lt;usize, Error&gt; {</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> open_options = File::options();</div><div class="line">    open_options.read(<span class="keyword">true</span>).custom_flags(libc::O_DIRECT);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = open_options.open(filename)?;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffer = vec![<span class="number">0</span>; BUFFER_SIZE];</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newline_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> bytes_read = file.read(&<span class="keyword">mut</span> buffer)?;</div><div class="line">        <span class="keyword">if</span> bytes_read == <span class="number">0</span> {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">let</span> chunk_newline_count = buffer[..bytes_read].iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line">        newline_count += chunk_newline_count;</div><div class="line">    }</div><div class="line">    reset_file_caches();</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这大约需要 35.7 秒。</p>
<h2 id="方法_4：使用内存映射（Mmap）读取文件">方法 4：使用内存映射（Mmap）读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_memmap</span></span>(filename: &<span class="keyword">str</span>) -&gt; Result&lt;usize, Error&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(filename)?;</div><div class="line">    <span class="keyword">let</span> mmap = <span class="keyword">unsafe</span> { Mmap::map(&file)? };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newline_count = mmap.iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line">    reset_file_caches();</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这大约需要 8.3 秒。</p>
<h2 id="方法_5：使用内存映射（Mmap）和_AVX2_指令集读取文件">方法 5：使用内存映射（Mmap）和 AVX2 指令集读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_memmap_avx2</span></span>(filename: &<span class="keyword">str</span>) -&gt; Result&lt;usize, Error&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(filename)?;</div><div class="line">    <span class="keyword">let</span> mmap = <span class="keyword">unsafe</span> { Mmap::map(&file)? };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newline_byte = b<span class="string">'\n'</span>;</div><div class="line">    <span class="keyword">let</span> newline_vector = <span class="number">_</span>mm256_set1_epi8(newline_byte <span class="keyword">as</span> <span class="keyword">i8</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newline_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ptr = mmap.as_ptr();</div><div class="line">    <span class="keyword">let</span> end_ptr = <span class="keyword">unsafe</span> { ptr.add(mmap.len()) };</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ptr &lt;= end_ptr.sub(<span class="number">32</span>) {</div><div class="line">        <span class="keyword">let</span> data = <span class="keyword">unsafe</span> { <span class="number">_</span>mm256_loadu_si256(ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="number">__</span>m256i) };</div><div class="line">        <span class="keyword">let</span> cmp_result = <span class="number">_</span>mm256_cmpeq_epi8(data, newline_vector);</div><div class="line">        <span class="keyword">let</span> mask = <span class="number">_</span>mm256_movemask_epi8(cmp_result);</div><div class="line">        newline_count += mask.count_ones() <span class="keyword">as</span> usize;</div><div class="line">        ptr = <span class="keyword">unsafe</span> { ptr.add(<span class="number">32</span>) };</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Count remaining bytes</span></div><div class="line">    <span class="keyword">let</span> remaining_bytes = end_ptr <span class="keyword">as</span> usize - ptr <span class="keyword">as</span> usize;</div><div class="line">    newline_count += mmap[mmap.len() - remaining_bytes..].iter().filter(|&&b| b == newline_byte).count();</div><div class="line"></div><div class="line">    reset_file_caches();</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个方法在我的机器上大约耗时 2.64 秒。</p>
<h2 id="方法_6：使用内存映射（Mmap）和_AVX-512_指令集读取文件">方法 6：使用内存映射（Mmap）和 AVX-512 指令集读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_memmap_avx512</span></span>(filename: &<span class="keyword">str</span>) -&gt; Result&lt;usize, Error&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(filename)?;</div><div class="line">    <span class="keyword">let</span> mmap = <span class="keyword">unsafe</span> { Mmap::map(&file)? };</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newline_byte = b<span class="string">'\n'</span>;</div><div class="line">    <span class="keyword">let</span> newline_vector = <span class="number">_</span>mm512_set1_epi8(newline_byte <span class="keyword">as</span> <span class="keyword">i8</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newline_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ptr = mmap.as_ptr();</div><div class="line">    <span class="keyword">let</span> end_ptr = <span class="keyword">unsafe</span> { ptr.add(mmap.len()) };</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ptr &lt;= end_ptr.sub(<span class="number">64</span>) {</div><div class="line">        <span class="keyword">let</span> data = <span class="keyword">unsafe</span> { <span class="number">_</span>mm512_loadu_si512(ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>) };</div><div class="line">        <span class="keyword">let</span> cmp_result = <span class="number">_</span>mm512_cmpeq_epi8_mask(data, newline_vector);</div><div class="line">        newline_count += cmp_result.count_ones() <span class="keyword">as</span> usize;</div><div class="line">        ptr = <span class="keyword">unsafe</span> { ptr.add(<span class="number">64</span>) };</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Count remaining bytes</span></div><div class="line">    <span class="keyword">let</span> remaining_bytes = end_ptr <span class="keyword">as</span> usize - ptr <span class="keyword">as</span> usize;</div><div class="line">    newline_count += mmap[mmap.len() - remaining_bytes..].iter().filter(|&&b| b == newline_byte).count();</div><div class="line"></div><div class="line">    reset_file_caches();</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个方法在我的机器上大约需要 2.61 秒。</p>
<h2 id="方法_7：使用向量_I/O_读取文件">方法 7：使用向量 I/O 读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_newlines_vectored_io</span></span>(path: &<span class="keyword">str</span>) -&gt; Result&lt;usize, Error&gt;  {</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(path)?;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffers_: Vec&lt;<span class="number">_</span>&gt; = (<span class="number">0</span>..<span class="number">16</span>).map(|<span class="number">_</span>| vec![<span class="number">0</span>; BUFFER_SIZE]).collect();</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffers: Vec&lt;<span class="number">_</span>&gt; = buffers_.iter_mut().map(|buf| io::IoSliceMut::new(buf)).collect();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newline_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> bytes_read = file.read_vectored(&<span class="keyword">mut</span> buffers)?;</div><div class="line">        <span class="keyword">if</span> bytes_read == <span class="number">0</span> {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Calculate how many buffers were filled</span></div><div class="line">        <span class="keyword">let</span> filled_buffers = bytes_read / BUFFER_SIZE;</div><div class="line"></div><div class="line">        <span class="comment">// Process the fully filled buffers</span></div><div class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> &buffers[..filled_buffers] {</div><div class="line">            newline_count += buf.iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Handle the potentially partially filled last buffer</span></div><div class="line">        <span class="keyword">if</span> filled_buffers &lt; buffers.len() {</div><div class="line">            <span class="keyword">let</span> last_buffer = &buffers[filled_buffers];</div><div class="line">            <span class="keyword">let</span> end = bytes_read % BUFFER_SIZE;</div><div class="line">            newline_count += last_buffer[..end].iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    Ok(newline_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这大约需要 7.7 秒。</p>
<h2 id="方法_8：使用_io_uring_读取文件">方法 8：使用 <code>io_uring</code> 读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_lines_io_uring</span></span>(path: &<span class="keyword">str</span>) -&gt; io::Result&lt;usize&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(path)?;</div><div class="line">    <span class="keyword">let</span> fd = file.as_raw_fd();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ring = IoUring::new(<span class="number">8</span>)?;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> line_count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = vec![<span class="number">0</span>; <span class="number">4096</span>];</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> read_size = buf.len();</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> sqe = opcode::Read::new(types::Fd(fd), buf.as_mut_ptr(), read_size <span class="keyword">as</span> <span class="number">_</span>)</div><div class="line">            .offset(offset <span class="keyword">as</span> <span class="number">_</span>)</div><div class="line">            .build()</div><div class="line">            .user_data(line_count <span class="keyword">as</span> <span class="number">_</span>);</div><div class="line"></div><div class="line">        <span class="keyword">unsafe</span> {</div><div class="line">            ring.submission()</div><div class="line">                .push(&<span class="keyword">mut</span> sqe)</div><div class="line">                .expect(<span class="string">"submission queue is full"</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        ring.submit_and_wait(<span class="number">1</span>)?;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> cqe = ring.completion().next().expect(<span class="string">"completion queue is empty"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> bytes_read = cqe.result() <span class="keyword">as</span> usize;</div><div class="line">        line_count = cqe.user_data() <span class="keyword">as</span> usize;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> bytes_read == <span class="number">0</span> {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">let</span> data = &buf[..bytes_read];</div><div class="line">        line_count += data.iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line"></div><div class="line">        offset += bytes_read <span class="keyword">as</span> <span class="keyword">u64</span>;</div><div class="line">        read_size = (buf.len() - (offset <span class="keyword">as</span> usize % buf.len())) <span class="keyword">as</span> usize;</div><div class="line">    }</div><div class="line">    Ok(line_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这大约需要 10.5 秒。</p>
<h2 id="方法_9：使用带有向量_I/O_的_io_uring_读取文件">方法 9：使用带有向量 I/O 的 <code>io_uring</code> 读取文件</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">count_lines_io_uring_vectored</span></span>(path: &<span class="keyword">str</span>) -&gt; io::Result&lt;usize&gt; {</div><div class="line">    <span class="keyword">let</span> file = File::open(path)?;</div><div class="line">    <span class="keyword">let</span> fd = file.as_raw_fd();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ring = IoUring::new(NUM_BUFFERS <span class="keyword">as</span> <span class="keyword">u32</span>)?;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> line_count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buffers = vec![vec![<span class="number">0</span>; <span class="number">8192</span>]; NUM_BUFFERS];</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> iovecs: Vec&lt;iovec&gt; = buffers</div><div class="line">        .iter_mut()</div><div class="line">        .map(|buf| iovec {</div><div class="line">            iov_base: buf.as_mut_ptr() <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="number">_</span>,</div><div class="line">            iov_len: buf.len(),</div><div class="line">        })</div><div class="line">        .collect();</div><div class="line"></div><div class="line">    <span class="keyword">loop</span> {</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> sqe = opcode::Readv::new(types::Fd(fd), iovecs.as_mut_ptr(), iovecs.len() <span class="keyword">as</span> <span class="number">_</span>)</div><div class="line">            .offset(offset <span class="keyword">as</span> <span class="number">_</span>)</div><div class="line">            .build()</div><div class="line">            .user_data(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">unsafe</span> {</div><div class="line">            ring.submission()</div><div class="line">                .push(&<span class="keyword">mut</span> sqe)</div><div class="line">                .expect(<span class="string">"submission queue is full"</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        ring.submit_and_wait(<span class="number">1</span>)?;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> cqe = ring.completion().next().expect(<span class="string">"completion queue is empty"</span>);</div><div class="line">        <span class="keyword">let</span> bytes_read = cqe.result() <span class="keyword">as</span> usize;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> bytes_read == <span class="number">0</span> {</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> buffer_line_count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> remaining_bytes = bytes_read;</div><div class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> &buffers[..iovecs.len()] {</div><div class="line">            <span class="keyword">let</span> buf_size = buf.len();</div><div class="line">            <span class="keyword">let</span> data_size = remaining_bytes.min(buf_size);</div><div class="line">            <span class="keyword">let</span> data = &buf[..data_size];</div><div class="line">            buffer_line_count += data.iter().filter(|&&b| b == b<span class="string">'\n'</span>).count();</div><div class="line">            remaining_bytes -= data_size;</div><div class="line">            <span class="keyword">if</span> remaining_bytes == <span class="number">0</span> {</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        line_count += buffer_line_count;</div><div class="line"></div><div class="line">        offset += bytes_read <span class="keyword">as</span> <span class="keyword">u64</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    Ok(line_count)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上，这大约需要 7.6 秒。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们将尝试使用 Rust 来比较读取文件的各种不同方法。除了 <code>wc -l</code> 之外，我们将使用 <code>criterion</code> 对每个函数运行 10 次，然后取平均值。</p>
<p>以下基准测试的代码存放在 <a href="https://github.com/deepankarsharma/shatranj/blob/main/benches/bench.rs" target="_blank" rel="external">Benchmark code for Linux IO using Rust</a>。<br>在以下代码中，BUFFER_SIZE 为 8192，NUM_BUFFERS 为 32。</p>
<p>原文: <a href="[Linux File IO using Rust (opdroid.org"># Linux File IO using Rust</a>](<a href="https://opdroid.org/rust-io.html)" target="_blank" rel="external">https://opdroid.org/rust-io.html)</a>) by opdroid</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重复了很多次，我终于不再忍了]]></title>
    <link href="https://colobu.com/2024/05/08/db-query-helpers/"/>
    <id>https://colobu.com/2024/05/08/db-query-helpers/</id>
    <published>2024-05-08T15:49:39.000Z</published>
    <updated>2024-07-03T03:41:24.498Z</updated>
    <content type="html"><![CDATA[<p>虽然我不做管理系统，但是在项目中和数据库打交道还是比较多的，经常会从数据库中 (比如 Mysql 、ClickHouse 等) 查询一些记录，偶尔也会写入一些数据，但是不多。</p>
<a id="more"></a>
<p>每次从数据库中查询一些数据，套路几乎是一样的，无非是：</p>
<ul>
<li>定义和表相关的 struct (Entity)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">	ID   <span class="typename">int</span>    <span class="string">`db:"id" json:"id,omitempty"`</span></div><div class="line">	Name <span class="typename">string</span> <span class="string">`db:"name" json:"name,omitempty"`</span></div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>根据 dsn 创建 sql. DB</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db, err := sql.Open(<span class="string">"mysql"</span>,<span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> db.Close()</div></pre></td></tr></table></figure>

<ul>
<li>执行查询, 获得一组Row</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	id <span class="typename">int</span></div><div class="line">	name <span class="typename">string</span></div><div class="line">)</div><div class="line">rows, err := db.Query(<span class="string">"select id, name from users where id = ?"</span>,<span class="number"> 1</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div><div class="line"><span class="keyword">defer</span> rows.Close()</div></pre></td></tr></table></figure>

<ul>
<li>遍历 rows, 读取数据,并填充struct</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> users []User</div><div class="line"><span class="keyword">for</span> rows.Next() {</div><div class="line">    <span class="keyword">var</span> user User</div><div class="line">	err := rows.Scan(&user.ID, &user.Name)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(err)</div><div class="line">	}</div><div class="line">	</div><div class="line">    users = <span class="built_in">append</span>(users, user)</div><div class="line">}</div><div class="line">err = rows.Err()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatal(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>每一次，都是这个套路，套路用多了，也烦了。</p>
<p>当然也可以用 orm 库，比如 gorm, 减少一些代码。但是我还是想用原始的 sql 和最精简的代码，把查询这一块能抽象出一个通用的代码。</p>
<p>那么梳理一下我的需求：</p>
<ol>
<li>提供一个 raw sql 语句</li>
<li>返回一个指定类型的 struct、或者是一个指定类型的struct 的切片</li>
</ol>
<p><img src="1.png" alt=""></p>
<p>但是等等，好歹也得提供数据库的连接信息吧，或者提供一个连接好的 sql. DB, 所以输入变成了两项：<br><img src="2.png" alt=""></p>
<p>那么是输入 dsn 还是创建好的 sql. DB 呢？我最终选择了 sql. DB, 原因有两点：</p>
<ul>
<li>可以重用创建好的 sql. DB, 多个地方可以共享使用</li>
<li>用户可以在外部配置 sql. DB </li>
</ul>
<p>输入输出确定了，那么就是实现了。相关的代码在 <a href="https://github.com/blockloop/scan" target="_blank" rel="external">smallnest/exp</a> 让我们看看它是怎么封装的。</p>
<h2 id="查询多条记录">查询多条记录</h2>
<p><code>func Rows[T any](ctx context.Context, db *sql.DB, query string, args ...any) ([]T, error)</code></p>
<ul>
<li><code>ctx</code> 可以设置超时时间，或者不想设置的话用 <code>context.Background</code> 即可</li>
<li><code>db</code> 外部已经创建好的数据库连接</li>
<li><code>query</code>  sql 查询语句</li>
<li><code>args</code> sql 中的参数，可选</li>
</ul>
<p>返回结果就是 <code>[]T</code>, 如果查询失败，返回 <code>error</code></p>
<p>本质上，这个函数也没啥，就是执行查询，遍历 rows, 利用反射将数据库记录转换成 <code>T</code> 类型的结构体，所以我把它称之为 helper 函数，减少我的重复工作量。</p>
<p>其实底层我没也没有从零去写，而是使用了 <a href="github.com/blockloop/scan">blockloop/scan</a> , 封装的更方便使用，同时支持泛型。</p>
<p>一个例子如下, 演示了查询多个  <code>person</code> 的方法以及只查某个字段的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</div><div class="line">	ID   <span class="typename">int</span>    <span class="string">`db:"id" json:"id,omitempty"`</span></div><div class="line">	Name <span class="typename">string</span> <span class="string">`json:"name,omitempty"`</span> <span class="comment">// `db:"name" json:"name,omitempty"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> TestRows(t *testing.T) {</div><div class="line">	db := exampleDB(t)</div><div class="line"></div><div class="line">	persons, err := Rows[person](context.Background(), db, <span class="string">"SELECT * FROM persons order by id"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	require.Equal(t,<span class="number"> 2</span>, <span class="built_in">len</span>(persons))</div><div class="line">	assert.Equal(t,<span class="number"> 1</span>, persons<span class="number">[0</span>].ID)</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, persons<span class="number">[0</span>].Name)</div><div class="line">	assert.Equal(t,<span class="number"> 2</span>, persons<span class="number">[1</span>].ID)</div><div class="line">	assert.Equal(t, <span class="string">"fred"</span>, persons<span class="number">[1</span>].Name)</div><div class="line"></div><div class="line">	names, err := Rows[<span class="typename">string</span>](context.Background(), db, <span class="string">"SELECT name FROM persons order by id"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	assert.Equal(t,<span class="number"> 2</span>, <span class="built_in">len</span>(names))</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, names<span class="number">[0</span>])</div><div class="line">	assert.Equal(t, <span class="string">"fred"</span>, names<span class="number">[1</span>])</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="查询单条记录">查询单条记录</h2>
<p>如果查询单条记录，你可以使用 <code>Row</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Row[T any](ctx context.Context, db *sql.DB, query <span class="typename">string</span>, args ...any) (T, error)</div></pre></td></tr></table></figure>

<p>和查询多条记录类似，只不过它返回一个 struct 而已。</p>
<p>也是使用了 <a href="github.com/blockloop/scan">blockloop/scan</a> , 同时支持泛型。</p>
<p>查询例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestRow(t *testing.T) {</div><div class="line">	db := exampleDB(t)</div><div class="line"></div><div class="line">	person, err := Row[person](context.Background(), db, <span class="string">"SELECT * FROM persons order by id limit 1"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	assert.Equal(t,<span class="number"> 1</span>, person.ID)</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, person.Name)</div><div class="line"></div><div class="line">	name, err := Row[<span class="typename">string</span>](context.Background(), db, <span class="string">"SELECT name FROM persons order by id limit 1"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, name)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>总得来说，这两个函数基本满足了我的日常查询需求，也减少了很多重复的代码，同时也提高了代码的可读性，同时它们还实现了简单的ORM的功能，把数据库的记录转换成了结构体。</p>
<p>这里你可能注意到了，我最开始定义了所需的结构体，如果你想更懒一些，你可以不定义结构体，直接使用 <code>map[string]any</code> 来接收查询结果, 但是这样会失去类型检查，只推荐在特定的场景下使用。</p>
<p>下面的提供了两个函数，和上面的函数，但是返回的是 <code>map[string]any</code>。</p>
<h2 id="返回_map_类型">返回 map 类型</h2>
<p>为了方便，我给<code>map[string]any</code>起了一个别名:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Record is a type alias for map[string]any.</span></div><div class="line"><span class="keyword">type</span> Record = <span class="keyword">map</span>[<span class="typename">string</span>]any</div></pre></td></tr></table></figure>

<p>Record代表一条记录，key是字段名，value是字段的值。</p>
<p>查询多条记录的函数如下，这里我没有依赖第三方的库，而是直接实现，遍历 rows, 读取数据,并填充 <code>map[string]any</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> RowsMap(ctx context.Context, db *sql.DB, query <span class="typename">string</span>, args ...any) ([]Record, error) {</div><div class="line">	rows, err := db.QueryContext(ctx, query, args...)</div><div class="line">	<span class="keyword">defer</span> rows.Close()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line"></div><div class="line">	colNames, err := rows.Columns()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">	}</div><div class="line">	cols := <span class="built_in">make</span>([]any, <span class="built_in">len</span>(colNames))</div><div class="line">	colPtrs := <span class="built_in">make</span>([]any, <span class="built_in">len</span>(colNames))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(colNames); i++ {</div><div class="line">		colPtrs[i] = &cols[i]</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">var</span> ret []Record</div><div class="line">	<span class="keyword">for</span> rows.Next() {</div><div class="line">		err = rows.Scan(colPtrs...)</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">return</span> <span class="constant">nil</span>, err</div><div class="line">		}</div><div class="line"></div><div class="line">		row := <span class="built_in">make</span>(Record)</div><div class="line">		<span class="keyword">for</span> i, col := <span class="keyword">range</span> cols {</div><div class="line">			row[colNames[i]] = col</div><div class="line">		}</div><div class="line">		ret = <span class="built_in">append</span>(ret, row)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ret, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>查询单条记录类似，只不过返回的是 <code>Record</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> RowMap(ctx context.Context, db *sql.DB, query <span class="typename">string</span>, args ...any) (Record, error)</div></pre></td></tr></table></figure>

<p>接下来。我们看一个例子。这个例子和上面的例子类似，只不过调用我们这里介绍的两个函数，返回的是 <code>map[string]any</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TestRowsMap(t *testing.T) {</div><div class="line">	db := exampleDB(t)</div><div class="line"></div><div class="line">	persons, err := RowsMap(context.Background(), db, <span class="string">"SELECT * FROM persons order by id"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	require.Equal(t,<span class="number"> 2</span>, <span class="built_in">len</span>(persons))</div><div class="line">	assert.Equal(t, <span class="typename">int64</span><span class="number">(1</span>), persons<span class="number">[0</span>][<span class="string">"id"</span>])</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, persons<span class="number">[0</span>][<span class="string">"name"</span>])</div><div class="line">	assert.Equal(t, <span class="typename">int64</span><span class="number">(2</span>), persons<span class="number">[1</span>][<span class="string">"id"</span>])</div><div class="line">	assert.Equal(t, <span class="string">"fred"</span>, persons<span class="number">[1</span>][<span class="string">"name"</span>])</div><div class="line"></div><div class="line">	names, err := RowsMap(context.Background(), db, <span class="string">"SELECT name FROM persons order by id"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	assert.Equal(t,<span class="number"> 2</span>, <span class="built_in">len</span>(names))</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, names<span class="number">[0</span>][<span class="string">"name"</span>])</div><div class="line">	assert.Equal(t, <span class="string">"fred"</span>, names<span class="number">[1</span>][<span class="string">"name"</span>])</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> TestRowMap(t *testing.T) {</div><div class="line">	db := exampleDB(t)</div><div class="line"></div><div class="line">	person, err := RowMap(context.Background(), db, <span class="string">"SELECT * FROM persons order by id limit 1"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	assert.Equal(t, <span class="typename">int64</span><span class="number">(1</span>), person[<span class="string">"id"</span>])</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, person[<span class="string">"name"</span>])</div><div class="line"></div><div class="line">	name, err := Row[<span class="typename">string</span>](context.Background(), db, <span class="string">"SELECT name FROM persons order by id limit 1"</span>)</div><div class="line">	assert.NoError(t, err)</div><div class="line">	assert.Equal(t, <span class="string">"brett"</span>, name)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用这里介绍的函数，直接引用<code>github.com/smallnest/exp/db</code>即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我不做管理系统，但是在项目中和数据库打交道还是比较多的，经常会从数据库中 (比如 Mysql 、ClickHouse 等) 查询一些记录，偶尔也会写入一些数据，但是不多。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sqids: 简短唯一ID生成器]]></title>
    <link href="https://colobu.com/2024/05/05/Sqids-short-unique-identifiers-generators/"/>
    <id>https://colobu.com/2024/05/05/Sqids-short-unique-identifiers-generators/</id>
    <published>2024-05-05T02:35:59.000Z</published>
    <updated>2024-07-03T03:41:24.498Z</updated>
    <content type="html"><![CDATA[<p>Sqids（发音为<code>squids</code>, 鱿鱼）是一个开源库，允许您从<strong>数字</strong>中生成简短的唯一且看起来随机的标识符, 而且这些ID是URL安全的，你可以同时编码几个数字， 也可以剔除常见的脏话或者政治敏感的单词。你可以把它想象成一个十进制到十六进制的转换器，但它还具备一些额外的功能。<br>比如：<code>https://example.com/Lqj8a0</code></p>
<p>先前它叫做<code>Hashids</code>, 但是由于商标问题，我不得不更改名称。Sqids是<code>Short Quick Unique Identifiers</code>的缩写。<br><a id="more"></a></p>
<h2 id="为什么需要简短的唯一ID">为什么需要简短的唯一ID</h2>
<p><strong>适合场景</strong></p>
<ul>
<li>短链接缩</li>
<li>为日志生成唯一的事件 ID</li>
<li>为网站上的产品/对象生成 ID（如 YouTube 为视频所做的那样）</li>
<li>为文本消息生成短 ID</li>
<li>电子邮件中的确认码</li>
<li>商品优惠码</li>
<li>起止时间戳合并缩写</li>
<li>地理位置编码</li>
<li>临时的token</li>
</ul>
<p><strong>不适合场景</strong></p>
<ul>
<li>任何敏感数据</li>
<li>生成的 ID 不是哈希值，可以解码回数字。例如，它们可能不是用户 ID 的好选择，因为一旦解码，它们可能会泄露你的应用程序的用户数量</li>
</ul>
<h2 id="Sqids的特性">Sqids的特性</h2>
<p>🆔 从<strong>非负数字</strong>生成短 ID<br>✅ 易于编码和解码<br>🫣 自动生成的 ID 不包含常见的禁用词<br>🎲 支持通过打乱字母顺序来自定义 ID<br>🥳 44个语言库， 比如Go、Rust、C、C++、Bash、Java、Python、JavaScript等<br>📌 每个版本都生成相同的 ID<br>🍻 带有宽松许可的小型库 (MIT许可)</p>
<p>Sqids 你可以可以自定义字母表。更长的字母表产生的ID更短，更短的字母表产生的ID更长。默认字母表包含大写和小写字母，因此默认ID是区分大小写的。</p>
<p>使用同样的输入和相同的字母表，生成的ID是唯一的。</p>
<p>Sqids可以将一个或多个非负数编码为单个ID。您可以编码的数字数量没有限制，但可以编码的数字大小有限（取决于实现语言）。<br>比如您可以编码开始时间和结束时间的UNIX时间戳为一个ID，或者您可以将数据库分片号与主键一起编码，并节省额外的数据库查询。</p>
<h2 id="Sqids_有什么限制">Sqids 有什么限制</h2>
<ul>
<li>Sqids 不能编码负数。</li>
<li>最小字母表长度是 3 个字符。</li>
<li>字母表中不能包含任何多字节字符。</li>
<li>Sqids 不能生成固定长度的 ID，只能生成至少达到某个长度的 ID。最小长度参数范围在 0 到 255 之间。</li>
<li>Sqids 可以尝试重新生成长度最多为字母表长度减一的 ID。</li>
</ul>
<h2 id="屏蔽列表">屏蔽列表</h2>
<p>屏蔽列表可以防止某些单词出现在您的 ID 中。这是有益的，因为生成的 ID 可能会出现在公共场所，如 URL 中。</p>
<p>Sqids 附带了一个默认屏蔽列表，其中包含了几种语言中最基本的不雅和不当词汇。当然，您也可以用自己的词汇来扩展这个屏蔽列表。</p>
<p>屏蔽列表中的单词匹配是不区分大小写的。</p>
<p>少于 3 个字符的短单词不会被屏蔽。长度为 3 个字符的单词必须与 ID 完全匹配。如果 4 个或更多字符的单词是 ID 的子字符串，则会触发匹配。</p>
<p>如果屏蔽列表中的单词包含数字（leet 术语），则只有当它们位于 ID 的开头或结尾时才会触发匹配。</p>
<h2 id="ID_是否合法">ID 是否合法</h2>
<p>解码 ID 通常会产生某种数值输出，但这并不一定意味着该 ID 是规范的。为了检查 ID 是否有效，您可以重新编码解码后的数字，并检查 ID 是否匹配。</p>
<p>不自动执行此操作的原因是，如果将来默认屏蔽列表发生更改，我们不希望自动使过去生成的、现在可能与新屏蔽列表单词匹配的 ID 失效。</p>
<h2 id="Go示例">Go示例</h2>
<p>官方提供了一个Go语言的库:<a href="https://github.com/sqids/sqids-go" target="_blank" rel="external">sqids/sqids-go</a>。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/sqids/sqids-go"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s, _ := sqids.New()</div><div class="line"></div><div class="line">	id, _ := s.Encode([]<span class="typename">uint64</span><span class="number">{1234567890</span>}) <span class="comment">// "PcHfYmv"</span></div><div class="line">	fmt.Println(id)</div><div class="line"></div><div class="line">	start := time.Now().Unix()</div><div class="line">	end := time.Now().Add<span class="number">(24</span> * time.Hour).Unix()</div><div class="line"></div><div class="line">	id, _ = s.Encode([]<span class="typename">uint64</span>{<span class="typename">uint64</span>(start), <span class="typename">uint64</span>(end)}) <span class="comment">// "s6eUn008oGU27p"</span></div><div class="line">	fmt.Println(id)</div><div class="line"></div><div class="line">	numbers := s.Decode(id) <span class="comment">// [1714879533 1714965933]</span></div><div class="line">	fmt.Println(numbers)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>New</code>函数还提供额外的参数，用来定制字母表、最小长度和黑名单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> {</div><div class="line">	Alphabet  <span class="typename">string</span></div><div class="line">	MinLength <span class="typename">uint8</span></div><div class="line">	Blocklist []<span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s, _ := sqids.New(sqids.Options{</div><div class="line">	Alphabet: <span class="string">"FxnXM1kBN6cuhsAvjW3Co7l2RePyY8DwaU04Tzt9fHQrqSVKdpimLGIJOgb5ZE"</span>,</div><div class="line">})</div><div class="line">id, _ := s.Encode([]<span class="typename">uint64</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}) <span class="comment">// "B4aajs"</span></div><div class="line">numbers := s.Decode(id)              <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Sqids（发音为<code>squids</code>, 鱿鱼）是一个开源库，允许您从<strong>数字</strong>中生成简短的唯一且看起来随机的标识符, 而且这些ID是URL安全的，你可以同时编码几个数字， 也可以剔除常见的脏话或者政治敏感的单词。你可以把它想象成一个十进制到十六进制的转换器，但它还具备一些额外的功能。<br>比如：<code>https://example.com/Lqj8a0</code></p>
<p>先前它叫做<code>Hashids</code>, 但是由于商标问题，我不得不更改名称。Sqids是<code>Short Quick Unique Identifiers</code>的缩写。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rust Tokio 任务取消模式]]></title>
    <link href="https://colobu.com/2024/05/04/Rust-tokio-task-cancellation-patterns/"/>
    <id>https://colobu.com/2024/05/04/Rust-tokio-task-cancellation-patterns/</id>
    <published>2024-05-04T03:00:15.000Z</published>
    <updated>2024-07-03T03:41:24.497Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://cybernetist.com/2024/04/19/rust-tokio-task-cancellation-patterns/?continueFlag=018a29c7cbd9dd57a67b0fff6b1f07f4" target="_blank" rel="external">Rust tokio task cancellation patterns</a></p>
<p>我最近一直在尝试重新学习 Rust。开始时进展有些缓慢，但我觉得我终于开始感受到累积效应在起作用了。也许这只是我的大脑在跟我开玩笑，但现在写 Rust 时我感觉比几周前轻松多了。</p>
<a id="more"></a>
<p>我过去曾对 Rust 有所了解，但从未构建过任何“实质性”的东西，而往往最大的学习成果都来源于这些大型项目，因为你会遇到在小规模项目中不会出现的问题。但这并不是说构建小型项目没有用！相反！它们是让你熟悉任何新语言的绝佳方式！只是小型项目通常不会突出显示你在构建它们时不需要的某些语言领域的知识不足。</p>
<p>对我来说，其中一个领域是并发性。Rust 支持<a href="https://rust-lang.github.io/async-book/" target="_blank" rel="external">异步编程</a>，允许你启动异步任务，然后通过运行时执行器在 OS 线程之间调度执行。和 Rust 中的其他所有内容一样，异步编程也必须是内存安全的，所以你需要确保借用检查器（<code>borrow checker</code>）满意。这有时是一个真正的挑战。</p>
<p>在 Rust 领域，更奇怪的是，虽然异步编程是一等公民，但标准库（即 <code>async_std</code>）相当有限，或者至少对于一个像我这样的未经训练的初学者来说是这样。</p>
<p>结果人们倾向于使用 <a href="https://tokio.rs/" target="_blank" rel="external">tokio</a> crate，它提供了丰富的功能，并有一个非常棒的教程。我对 Rust 异步编程的大部分了解都是通过遵循 <a href="https://tokio.rs/tokio/tutorial" target="_blank" rel="external">tokio 教程</a>学到的。</p>
<p>教程中没有详细介绍的一点是任务取消，这是我在一个项目中需要的功能。具体来说，我需要启动一堆工作任务，并需要一种方法来取消其中的任何一个或全部。我做了一些研究和破解，并想出了一些模式，我想把它们放在我可以轻松访问的地方。</p>
<p>我写这篇博客文章和配套的 <a href="https://github.com/milosgajdos/cancellation-patterns" target="_blank" rel="external">GitHub 仓库</a>的目的是记录这些模式，并希望这篇文章能像一份活的文档一样，基于我未来希望学习的新的 tokio 技巧不断得到更新。正如我所说，我目前是一个 Rust 菜鸟，所以这些“模式”可能完全不靠谱——如果你发现它们是这样的，请在文章末尾留下评论，我会很乐意更新它。</p>
<h2 id="Select_和_Channel">Select 和 Channel</h2>
<p>这些模式的核心是 tokio 的两个特性（假设你已经熟悉任务的创建）：</p>
<ul>
<li><code>channel</code>：用于任务间通信</li>
<li><code>select</code>：用于等待多个异步计算（不一定是任务！）</li>
<li>乍一看，它们与 Go 的 <code>channel</code> 和 <code>select</code> 惊人地相似，但魔鬼藏在细节中。虽然 Go 提供了一个单一的 channel 构造，但其语义（<strong>发送</strong>/<strong>接收</strong>）是通过可选的 <code>&lt;-</code>/<code>-&gt;</code> 运算符“调整”的（仅当明确写出时，编译器才会检查——不幸的是，这很容易忘记，而且往往会被许多 Go 程序员省略）；tokio 的 <code>channel</code> 看似更复杂一些，但在内存安全和程序韧性方面更为强大。</li>
</ul>
<p>Tokio 的 <code>channel</code> 创建了两个不同的对象用于任务间通信。你不能使用单个 channel 同时进行接收和发送。这防止了我在 Go 编程中多次遇到的一类问题，比如当你意外地省略了可选的 channel 语义，并向一个只应接收数据的 channel 发送数据时——Go 编译器看不出有什么问题，但你却要花上几个小时调试为什么事情不起作用。</p>
<p>从 Go 程序员的角度来看，另一个有趣的特性是，你可以创建多生产者单消费者channel（通过 <code>mpsc</code> 缩写表示），这可以防止我在 Go 程序中遇到的另一类问题：多个接收者修改同一个对象，从而导致难以发现的数据竞争。在 Go 中，你可以轻松地将一个指针通过channel发送给多个消费者，并承诺它是只读的，或者你永远不会尝试修改它；问题在于，Go 编译器不会强制执行这些规则——这实际上只是一种你希望使用你代码的人遵循的约定/未成文规则。拥有一个可以帮助你强制执行这些规则的编译器非常实用，并且与 Rust 的内存安全原则相契合。实际上，并发类型安全的故事更加有趣，涉及讨论 <code>Send</code> 和 <code>Sync</code> 特性，但本文是关于任务取消模式的，因此我会让你自己去深入研究这些特性。</p>
<p>如果你确实需要将多个值发送给多个消费者，Tokio 已经为你准备好了，不用担心：Tokio 提供了 broadcast channel。</p>
<p>一般来说，Tokio 实际上提供了四种类型的channel：</p>
<ul>
<li><code>mpsc</code>：多生产者单消费者，如上所述</li>
<li><code>oneshot</code>：用于发送和接收单个值；一旦发送，channel就会关闭</li>
<li><code>broadcast</code>：如上所述——多个发送者，多个消费者</li>
<li><code>watch</code>：单生产者，多消费者</li>
</ul>
<p>正如我所说，这些在 Tokio 教程中都有很好的文档和讨论。我花了些时间来消化这些概念，因为我自然倾向于将它们与它们在 Go 语言中的等价物进行比较，但它们之间有一些微妙的差异。但无论如何，让我们继续探讨利用 <code>select</code> 和 <code>channel</code>的实际取消模式。</p>
<p>以下是我提出的一些模式的不完整列表。对于经验丰富的 Rust 程序员来说，其中一些可能看起来有些牵强，但对我来说它们相当有效，正如我所说，我还是 Rust 的新手，所以我可能做错了什么。接下来是这些模式！</p>
<h2 id="drop_JoinHandle_不会取消任务">drop <code>JoinHandle</code> 不会取消任务</h2>
<p><strong>注意</strong>：<a href="https://www.reddit.com/user/colorfulchew/" target="_blank" rel="external">colorfulchew</a> 在 Reddit 上<a href="https://www.reddit.com/r/rust/comments/1c7xv7l/comment/l0awrtz/" target="_blank" rel="external">正确地指出</a>，使用 <code>drop</code> 实际上并不会取消任务，但当句柄超出作用域时丢弃它确实会——请参见本示例下方的示例。<a href="https://www.reddit.com/user/abcSilverline/" target="_blank" rel="external">abcSilverline</a> 提到我误解了<a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinHandle.html#" target="_blank" rel="external">官方文档</a>，该文档明确指出：</p>
<blockquote>
<p>当 JoinHandle 被丢弃时，它会分离与其关联的任务，这意味着不再有任何指向该任务的句柄，也无法再等待它完成。</p>
</blockquote>
<p>每次你在 tokio 中启动(<code>spawn</code>)一个任务时，你都会得到一个 <code>JoinHandle</code>。你可以使用 <code>join</code> 句柄来等待任务完成，但我原以为你可以仅仅通过丢弃它来强制终止任务。下面是一个愚蠢的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::time::{<span class="keyword">self</span>, Duration};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> handle = tokio::spawn(async {</div><div class="line">        <span class="comment">// do some work</span></div><div class="line">        tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)).await;</div><div class="line">        println!(<span class="string">"Task completed"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Cancel the task after 1 second</span></div><div class="line">    time::sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line">    drop(handle);</div><div class="line"></div><div class="line">    println!(<span class="string">"Task was cancelled"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我也错误地以为我可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::time::{<span class="keyword">self</span>, Duration};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    {</div><div class="line">        <span class="keyword">let</span> handle = tokio::spawn(async {</div><div class="line">            <span class="comment">// do some work</span></div><div class="line">            tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)).await;</div><div class="line">            println!(<span class="string">"Task completed"</span>);</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="comment">// Cancel the task after 100ms</span></div><div class="line">        time::sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line">    }</div><div class="line"></div><div class="line">    println!(<span class="string">"Task was cancelled"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>唉，不是的，<strong>丢弃句柄并不会取消正在运行的任务</strong>！</p>
<h2 id="终止任务">终止任务</h2>
<p>这是取消任务的最极端方式，不给清理工作留下任何空间：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::time::{<span class="keyword">self</span>, Duration};</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> handle = tokio::spawn(async {</div><div class="line">        <span class="comment">// do some work</span></div><div class="line">        tokio::time::sleep(Duration::from_secs(<span class="number">1</span>)).await;</div><div class="line">        println!(<span class="string">"Task completed"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Cancel the task after 100 milliseconds</span></div><div class="line">    time::sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line">    handle.abort();</div><div class="line">    time::sleep(Duration::from_secs(<span class="number">2</span>)).await;</div><div class="line"></div><div class="line">    println!(<span class="string">"Task was cancelled"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用_oneshot">使用 <code>oneshot</code></h2>
<p>如果你只需要一次性地将取消信号广播给多个任务，那么 <code>oneshot</code> channel 就能很好地满足你的需求。</p>
<p><code>oneshot</code> channel允许在channel上进行一次发送，多个接收者可以监听这次发送。与直接丢弃句柄不同，这种模式允许你的channel进行一些清理工作。以下是一个示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::time::Duration;</div><div class="line"><span class="keyword">use</span> tokio::sync::oneshot;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> (tx, rx) = oneshot::channel();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task = tokio::spawn(async move {</div><div class="line">        tokio::select! {</div><div class="line">            <span class="number">_</span> = rx =&gt; {</div><div class="line">                println!(<span class="string">"Task is cancelling..."</span>);</div><div class="line">            }</div><div class="line">            <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                println!(<span class="string">"Task completed normally"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line"></div><div class="line">    <span class="comment">// Send a cancellation signal</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = tx.send(());</div><div class="line"></div><div class="line">    <span class="comment">// Wait for the tasks to finish</span></div><div class="line">    <span class="comment">// NOTE: we could do this instead:</span></div><div class="line">    <span class="comment">// let _ = tokio::join!(task);</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = task.await;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在，如果你运行这个程序，你会得到类似这样的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Task <span class="keyword">is</span> cancelling...</div><div class="line">Task <span class="keyword">is</span> cleaning <span class="keyword">up</span></div></pre></td></tr></table></figure>

<p><code>oneshot</code> channel 的局限性在于，你不能使用它来取消多个任务。它实际上是为一次性通知而设计和优化的。所以请注意这一点！</p>
<h2 id="使用_broadcast_取消多个任务">使用 <code>broadcast</code> 取消多个任务</h2>
<p>如果你想要取消多个任务，你可以使用 broadcast channel。你可以有多个生产者向channel发送数据，同时也有多个消费者从channel接收数据。每个消费者都能看到channel上发送的每个值。非常方便！</p>
<p>以下是一个简单的示例，展示了如何使用 broadcast channel来取消多个任务并让它们进行清理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::sync::broadcast;</div><div class="line"><span class="keyword">use</span> tokio::time::Duration;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx1) = broadcast::channel(<span class="number">1</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rx2 = tx.subscribe();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task1 = tokio::spawn(async move {</div><div class="line">        tokio::select! {</div><div class="line">            <span class="number">_</span> = rx1.recv() =&gt; {</div><div class="line">                println!(<span class="string">"Task 1 is cancelling..."</span>);</div><div class="line">            }</div><div class="line">            <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                println!(<span class="string">"Task 1 completed normally"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task 1 is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task2 = tokio::spawn(async move {</div><div class="line">        tokio::select! {</div><div class="line">            <span class="number">_</span> = rx2.recv() =&gt; {</div><div class="line">                println!(<span class="string">"Task 2 is cancelling..."</span>);</div><div class="line">            }</div><div class="line">            <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                println!(<span class="string">"Task 2 completed normally"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task 2 is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line"></div><div class="line">    <span class="comment">// Send a cancellation signal</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = tx.send(());</div><div class="line"></div><div class="line">    <span class="comment">// Wait for the tasks to finish</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = tokio::join!(task1, task2);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你运行这个程序，你会得到类似这样的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Task <span class="number">2</span> <span class="keyword">is</span> cancelling...</div><div class="line">Task <span class="number">2</span> <span class="keyword">is</span> cleaning <span class="keyword">up</span></div><div class="line">Task <span class="number">1</span> <span class="keyword">is</span> cancelling...</div><div class="line">Task <span class="number">1</span> <span class="keyword">is</span> cleaning <span class="keyword">up</span></div></pre></td></tr></table></figure>

<p>请注意，在你运行时，取消的顺序可能会有所不同，因为任务可能会以不同的顺序被取消！</p>
<p>请注意，取消的顺序可能会因你的情况而异，因为任务可能会以不同的顺序被取消！</p>
<p>如果你只是想从单个任务向多个任务发送取消信号，那么使用 broadcast channel可能会有点过度，因为它提供了在多个任务之间传递消息的所有机制。</p>
<p>如果你既需要消息传递又需要取消功能，那么 broadcast channel会很有用。但如果你只需要取消功能，那么有更好的方式（或者说可能不一定是更好的，但开销更少），那就是 watch channel。</p>
<h2 id="使用_watch_取消多个任务">使用 <code>watch</code> 取消多个任务</h2>
<p>watch channel是一个单生产者多消费者channel。同样，watch channel给了任务在取消后自行清理的机会。但缺点是，消费者只能看到channel上发送的最新值——这意味着，如果你的任务在channel上发送值之后才启动，它可能会错过这个值，因此不会被取消，所以请注意这一点。以下是一个简单的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::sync::watch;</div><div class="line"><span class="keyword">use</span> tokio::time::Duration;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx1) = watch::channel(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rx2 = tx.subscribe();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task1 = tokio::spawn(async move {</div><div class="line">        <span class="keyword">loop</span> {</div><div class="line">            tokio::select! {</div><div class="line">                <span class="number">_</span> = rx1.changed() =&gt; {</div><div class="line">                    <span class="keyword">if</span> *rx1.borrow() {</div><div class="line">                        println!(<span class="string">"Task 1 is cancelling..."</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                    println!(<span class="string">"Task 1 completed normally"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task 1 is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task2 = tokio::spawn(async move {</div><div class="line">        <span class="keyword">loop</span> {</div><div class="line">            tokio::select! {</div><div class="line">                <span class="number">_</span> = rx2.changed() =&gt; {</div><div class="line">                    <span class="keyword">if</span> *rx2.borrow() {</div><div class="line">                        println!(<span class="string">"Task 2 is cancelling..."</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                    println!(<span class="string">"Task 2 completed normally"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task 2 is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line"></div><div class="line">    <span class="comment">// Send a cancellation signal</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = tx.send(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Wait for the tasks to finish</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = tokio::join!(task1, task2);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个channel被设计用来监视程序中的变化。有点像特定数据的发布/订阅模式：文档提到将配置更改作为标准示例进行监视，但你也可以将其用于取消操作。</p>
<p>请注意，我们在初始化channel时发送了 false，并且我们使用 true 来发送取消信号。每个任务都需要检查是否收到了 true，因为它们也可能会收到 false。我们也可以发送一些枚举或字符串，如 <code>Foo::cancel</code> 或 <code>&quot;cancel&quot;</code>，但同样，每个任务都需要检查是否是取消信号，如果是，则进行一些清理然后退出。</p>
<h2 id="取消令牌">取消令牌</h2>
<p>官方文档在关于<a href="https://tokio.rs/tokio/topics/shutdown" target="_blank" rel="external">优雅关闭</a>的文章中列出了一个名为 <code>CancellationToken</code> 的东西。这在 <code>tokio crate</code> 本身中不可用，而是在相关的 <a href="https://docs.rs/tokio-util/latest/tokio_util/index.html" target="_blank" rel="external">toko_util</a> crate 中。</p>
<p>我没有在任何项目中用过它，因为我试图避免引入比我已经使用的更多的依赖关系，但这是另一个有趣的选择，实际上是针对取消的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> tokio::time::{sleep, Duration};</div><div class="line"><span class="keyword">use</span> tokio_util::sync::CancellationToken;</div><div class="line"></div><div class="line"><span class="preprocessor">#[tokio::main]</span></div><div class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</div><div class="line">    <span class="comment">// Create a CancellationToken</span></div><div class="line">    <span class="keyword">let</span> token = CancellationToken::new();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> token1 = token.clone();</div><div class="line">    <span class="keyword">let</span> token2 = token.clone();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task1 = tokio::spawn(async move {</div><div class="line">        <span class="keyword">loop</span> {</div><div class="line">            tokio::select! {</div><div class="line">                <span class="number">_</span> = token1.cancelled() =&gt; {</div><div class="line">                        println!(<span class="string">"Task 1 is cancelling..."</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                    println!(<span class="string">"Task 1 completed normally"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task 1 is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">let</span> task2 = tokio::spawn(async move {</div><div class="line">        <span class="keyword">loop</span> {</div><div class="line">            tokio::select! {</div><div class="line">                <span class="number">_</span> = token2.cancelled() =&gt; {</div><div class="line">                        println!(<span class="string">"Task 2 is cancelling..."</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                <span class="number">_</span> = tokio::time::sleep(Duration::from_secs(<span class="number">10</span>)) =&gt; {</div><div class="line">                    println!(<span class="string">"Task 2 completed normally"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        println!(<span class="string">"Task 2 is cleaning up"</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">    sleep(Duration::from_millis(<span class="number">100</span>)).await;</div><div class="line"></div><div class="line">    <span class="comment">// Send a cancellation signal</span></div><div class="line">    token.cancel();</div><div class="line"></div><div class="line">    <span class="comment">// Wait for the tasks to finish</span></div><div class="line">    <span class="keyword">let</span> <span class="number">_</span> = tokio::join!(task1, task2);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>请注意我们是如何克隆令牌的，以便将其移动到单独的异步任务中。值得一提的是，还有一个叫做 <a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html#method.child_token" target="_blank" rel="external">child_token</a> 的东西，用官方文档的话来说：</p>
<blockquote>
<p>与克隆的 <code>CancellationToken</code> 不同，取消子令牌不会取消父令牌。</p>
</blockquote>
<h2 id="结论">结论</h2>
<p>这是我过去几周在学习 <code>tokio</code> 的过程中整理的取消选项列表。正如我所说，这绝不是一份完整的列表，而且很可能还有更多可供选择的选项，我迫切希望了解它们，所以请不要害羞，在评论中告诉我。你可以在 <a href="https://github.com/milosgajdos/cancellation-patterns" target="_blank" rel="external">GitHub</a> 上找到这篇博客文章中列出的所有代码示例作为参考。不要害羞，用新的模式或修复现有模式打开一个 PR（Pull Request）吧！</p>
<p>更新：<br><strong>2024/04/19</strong></p>
<ul>
<li>colorfulchew 在 <a href="https://www.reddit.com/r/rust/comments/1c7xv7l/" target="_blank" rel="external">Reddit</a> 上正确地指出，使用 <code>drop</code> 来丢弃任务句柄实际上并不会取消任务——你必须使用 <code>abort()</code> 来取消任务。</li>
<li>abcSilverline 提到我误解了<a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinHandle.html#" target="_blank" rel="external">官方文档</a>，文档明确说明：“当它被丢弃时，意味着不再有任何指向该任务的句柄，也无法对其进行 join 操作。”</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://cybernetist.com/2024/04/19/rust-tokio-task-cancellation-patterns/?continueFlag=018a29c7cbd9dd57a67b0fff6b1f07f4" target="_blank" rel="external">Rust tokio task cancellation patterns</a></p>
<p>我最近一直在尝试重新学习 Rust。开始时进展有些缓慢，但我觉得我终于开始感受到累积效应在起作用了。也许这只是我的大脑在跟我开玩笑，但现在写 Rust 时我感觉比几周前轻松多了。</p>
]]>
    
    </summary>
    
      <category term="rust" scheme="https://colobu.com/tags/rust/"/>
    
      <category term="rust" scheme="https://colobu.com/categories/rust/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go heap profile 怎么了]]></title>
    <link href="https://colobu.com/2024/04/30/what-s-wrong-with-go-heap-profile/"/>
    <id>https://colobu.com/2024/04/30/what-s-wrong-with-go-heap-profile/</id>
    <published>2024-04-30T01:01:36.000Z</published>
    <updated>2024-07-03T03:41:24.521Z</updated>
    <content type="html"><![CDATA[<p>Go heap profile 是尝尝用来检查内存泄露和内存占用大问题的问题的手段，而且非常惯用。</p>
<p>而且，我们也经常创建两个间隔较长的 heap profile, 获取它们的差值来方便查看内存泄露: <a href="https://colobu.com/2019/08/20/use-pprof-to-compare-go-memory-usage/" target="_blank" rel="external">Hi, 使用多年的go pprof检查内存泄漏的方法居然是错的?! </a></p>
<p>今天，度厂的一位同学提出了一个很有意思的案例，让我们对 heap profile 有了更深的理解。</p>
<a id="more"></a>
<h2 id="问题:_heap_profile_不能正确反应当前分配的内存?">问题: heap profile 不能正确反应当前分配的内存?</h2>
<p>这个同学举了一个简单的 Go 程序的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	_ <span class="string">"net/http/pprof"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		http.ListenAndServe(<span class="string">"localhost:8080"</span>, <span class="constant">nil</span>)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="comment">// 每秒打印内存分配情况</span></div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">var</span> m runtime.MemStats</div><div class="line">			runtime.ReadMemStats(&m)</div><div class="line">			fmt.Printf(<span class="string">"Alloc = %v MiB"</span>, bToMb(m.Alloc))</div><div class="line">			fmt.Printf(<span class="string">"\tTotalAlloc = %v MiB"</span>, bToMb(m.TotalAlloc))</div><div class="line">			fmt.Printf(<span class="string">"\tSys = %v MiB"</span>, bToMb(m.Sys))</div><div class="line">			fmt.Printf(<span class="string">"\tNumGC = %v\n"</span>, m.NumGC)</div><div class="line">			time.Sleep<span class="number">(1</span> * time.Second)</div><div class="line">		}</div><div class="line"></div><div class="line">	}()</div><div class="line">	time.Sleep<span class="number">(5</span> * time.Second)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"start test"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个 200 MiB 的切片</span></div><div class="line">	<span class="keyword">var</span> memoryLeaks [][]<span class="typename">int32</span></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		leak := <span class="built_in">make</span>([]<span class="typename">int32</span>,<span class="number"> 5</span><span class="number">*1024</span><span class="number">*1024</span>) <span class="comment">// 分配 5*1M*4bytes = 20 MiB</span></div><div class="line">		memoryLeaks = <span class="built_in">append</span>(memoryLeaks, leak)</div><div class="line">		time.Sleep<span class="number">(1</span> * time.Second) <span class="comment">// 延迟一秒观察内存分配情况</span></div><div class="line">	}</div><div class="line">	<span class="comment">// 期望至少分配了 200 MiB 内存</span></div><div class="line">	fmt.Println(<span class="string">"end test"</span>)</div><div class="line">	<span class="comment">// 看到上面的文字后，打开go pprof 工具，查看工具的分析</span></div><div class="line">	<span class="comment">// go tool pprof -http :8972 http://127.0.0.1:8080/debug/pprof/heap</span></div><div class="line"></div><div class="line"></div><div class="line">	time.Sleep<span class="number">(1</span> * time.Hour)</div><div class="line">	fmt.Println(<span class="string">"test"</span>, memoryLeaks<span class="number">[9</span>]<span class="number">[5</span><span class="number">*1024</span><span class="number">*1024</span><span class="number">-1</span>]) <span class="comment">// 避免垃圾回收和优化</span></div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> bToMb(b <span class="typename">uint64</span>) <span class="typename">uint64</span> {</div><div class="line">	<span class="keyword">return</span> b /<span class="number"> 1024</span> /<span class="number"> 1024</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个程序首先创建一个监听 8080 端口的web 服务，主要利用它访问 http heap profile，所以你看导入了 <code>_ &quot;net/http/pprof&quot;</code> 包。</p>
<p>然后创建了了一个切片，切片包含 10 个元素，每个元素又是一个 <code>[]int32</code> 的切片。每个元素占用 20 MiB 的大小 (<code>int32</code> 是 4 个字节，5*1024*1024 是 5 M, 所以是 4*5 MiB=20 Mib)。</p>
<p>所以我们期望 10 个循环创建完毕后，至少此程序会占用 200 MiB 内存，另外在加一些栈、网络、运行时等一些额外的内存的话，略微会比 200MiB 大一些。</p>
<p>运行这个程序，我们看程序每秒的内存占用统计：<br><img src="1.png" alt=""></p>
<p>可以看到使用 <code>runtime.MemStats</code> 统计的内存分配情况还是比较准的， 200MiB，符合预期。</p>
<p>当你看到 <code>end test</code> 时，表明 200MiB 已经分配，你可以运行下面的命令打开 heap profile:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool pprof -http :<span class="number">8972</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span>/debug/pprof/heap</div></pre></td></tr></table></figure>

<blockquote>
<p>如果你使用 Mac 电脑, 可能你还需要手工安装 graphviz:<br> <code>brew install graphviz</code></p>
</blockquote>
<p>等等，<strong>不对呀</strong>！怎么 heap profile 才显示 160 MB 的内存？<strong>少了 40 MB</strong>。和期望的不符。</p>
<p><img src="2.png" alt=""></p>
<p>这 160 MB 内存的确是在创建元素的时候分配的：<br><img src="3.png" alt=""></p>
<p>可那 40 MB 呢？如果 Heap Profile 数据不准，可就动摇了我们一直以来分析内存泄露的技术基础？</p>
<p>那肯定不会是 Go 实现的问题，否则这个问题早就被暴露和修复了。</p>
<p>接下来我们就介绍根因，讲两个知识点。</p>
<h2 id="把40_MiB_的分配的内存找回来">把40 MiB 的分配的内存找回来</h2>
<p>如果你再等一会，大约在命令行中看到 <code>end test</code> 两分钟后吧，当然再等长一点的时间更佳，你在重新执行命令，查看 heap profile:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool pprof -http :<span class="number">8972</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span>/debug/pprof/heap</div></pre></td></tr></table></figure>

<p>这个时候浏览器中显示出了 <strong>200 MB</strong> 的内存分配，符合预期了：<br><img src="4.png" alt=""></p>
<p>神奇啊，等待一段时间之后，heap profile 就显示正常了。难道过了一会才分配的内存？那不可能。因为命令行中 <code>runtime.MemStats</code> 已经显示结束测试前内存已经分配好了。</p>
<p>看到 <code>end test</code> 之后，程序也没做啥呀，就是休眠了 1 小时。<br>2 分钟很像是垃圾回收搞的鬼，2 分钟强制回收一次。</p>
<p>怀疑归怀疑，我们验证一下，在 <code>end test</code> 之后强制垃圾回收一下，再立即打开 heap profile 是不是显示 200 MiB。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fmt.Println(<span class="string">"end test"</span>)</div><div class="line">runtime.GC()</div></pre></td></tr></table></figure>

<p><img src="5.png" alt=""></p>
<p>既然知道是垃圾回收搞得鬼，那么我们就强制垃圾回收，就可以立即显示当前已分配的内存了，不用再等待。<br>但是线上运行的程序中也不可能随心所欲的让我们在任意的地方动态加 <code>runtime.GC()</code> 呀。</p>
<p>没关系，访问 heap profile 我们加上 <code>gc=1</code> 的参数即可 (大于 0 的数都可以)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool pprof -http :<span class="number">8972</span> <span class="string">"http://127.0.0.1:8080/debug/pprof/heap?gc=1"</span></div></pre></td></tr></table></figure>

<p>你可以在程序中把 <code>runtime.GC()</code> 那一行去掉，使用上面的方式访问 heap profile 验证，我就不重复贴图了。</p>
<blockquote>
<p>顺便说一下，你还可以加上 debug=1 (非 0 的参数)，可以已文字的方式查看内存分配以及 runtime.MemStats 数据。<br>如 <a href="http://127.0.0.1:8080/debug/pprof/heap?gc=1&amp;debug=1" target="_blank" rel="external">http://127.0.0.1:8080/debug/pprof/heap?gc=1&amp;debug=1</a></p>
</blockquote>
<p><strong>为啥?</strong></p>
<p>Heap profile 其实调用的 `runtime.MemProfile 进行统计:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> writeHeapInternal(w io.Writer, debug <span class="typename">int</span>, defaultSampleType <span class="typename">string</span>) error {</div><div class="line">	......</div><div class="line">	<span class="keyword">var</span> p []runtime.MemProfileRecord</div><div class="line">	n, ok := runtime.MemProfile(<span class="constant">nil</span>, <span class="constant">true</span>)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		p = <span class="built_in">make</span>([]runtime.MemProfileRecord, n<span class="number">+50</span>)</div><div class="line">		n, ok = runtime.MemProfile(p, <span class="constant">true</span>)</div><div class="line">		<span class="keyword">if</span> ok {</div><div class="line">			p = p<span class="number">[0</span>:n]</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">    ....</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>MemProfile</code> 的方法签名如下，它负责统计内存的分配情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> MemProfile(p []MemProfileRecord, inuseZero <span class="typename">bool</span>) (n <span class="typename">int</span>, ok <span class="typename">bool</span>)</div></pre></td></tr></table></figure>

<p>注意它的文档有一条：</p>
<blockquote>
<p>The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.</p>
</blockquote>
<p>翻译过来：</p>
<blockquote>
<p>返回的性能分析数据可能<strong>最多延迟两个垃圾回收周期</strong>。这样做是为了避免对内存分配产生偏差;因为内存分配是实时发生的,但释放操作直到垃圾回收器进行清理时才会延迟进行,所以性能分析只会统计那些已经有机会被垃圾回收器回收的内存分配。</p>
</blockquote>
<p>所以才会重现一开始的问题。我们看到 <code>end test</code> 立即查看 heap profile, 还没有进行垃圾回收，相关的内存统计数据还没有计算出来，所以才看到 160 MB 的内存，而不是 200MB 的内存。</p>
<p><code>system.GC</code>会强制进行垃圾回收，并且会发布新的heap profile，所以可以看到 200MB 的内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> GC() {</div><div class="line">	......</div><div class="line">	<span class="comment">// Now we're really done with sweeping, so we can publish the</span></div><div class="line">	<span class="comment">// stable heap profile. Only do this if we haven't already hit</span></div><div class="line">	<span class="comment">// another mark termination.</span></div><div class="line">	mp := acquirem()</div><div class="line">	cycle := work.cycles.Load()</div><div class="line">	<span class="keyword">if</span> cycle == n<span class="number">+1</span> || (gcphase == _GCmark && cycle == n<span class="number">+2</span>) {</div><div class="line">		mProf_PostSweep()</div><div class="line">	}</div><div class="line">	releasem(mp)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第一个知识点已经介绍完了，也解答了最初的问题。</p>
<p>现在让我们来看第二个知识点。</p>
<h2 id="Heap_Profile_是采样的？采啥样？">Heap Profile 是采样的？采啥样？</h2>
<p>heap profile 实际上在内存分配时做采样统计的，默认情况下并不会记录所有的内存分配。</p>
<p>这里我们需要关注 <code>runtime.MemProfileRate</code> 这个变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MemProfileRate controls the fraction of memory allocations</span></div><div class="line"><span class="comment">// that are recorded and reported in the memory profile.</span></div><div class="line"><span class="comment">// The profiler aims to sample an average of</span></div><div class="line"><span class="comment">// one allocation per MemProfileRate bytes allocated.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// To include every allocated block in the profile, set MemProfileRate to 1.</span></div><div class="line"><span class="comment">// To turn off profiling entirely, set MemProfileRate to 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The tools that process the memory profiles assume that the</span></div><div class="line"><span class="comment">// profile rate is constant across the lifetime of the program</span></div><div class="line"><span class="comment">// and equal to the current value. Programs that change the</span></div><div class="line"><span class="comment">// memory profiling rate should do so just once, as early as</span></div><div class="line"><span class="comment">// possible in the execution of the program (for example,</span></div><div class="line"><span class="comment">// at the beginning of main).</span></div><div class="line"><span class="keyword">var</span> MemProfileRate <span class="typename">int</span> =<span class="number"> 512</span> *<span class="number"> 1024</span></div></pre></td></tr></table></figure>

<p>翻译过来：</p>
<blockquote>
<p>MemProfileRate控制了在内存分析中记录和报告的内存分配的比例。分析器的目标是每分配MemProfileRate字节时,采样记录一次分配。</p>
<p>如果要在分析中包含每一个分配的内存块,可以将MemProfileRate设置为1。如果要完全关闭内存分析,可以将MemProfileRate设置为0。</p>
<p>处理内存分析数据的工具假设分析的采样率在程序的整个生命周期中保持不变,并等于当前设置的值。如果程序需要改变内存分析的采样率,应该只改变一次,并且尽可能早地在程序执行的开始阶段(例如在main函数的开始部分)进行设置。</p>
</blockquote>
<p>如果我们把每次分配的大小改小一点，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   ......</div><div class="line"><span class="keyword">var</span> memoryLeaks [][]<span class="typename">int32</span></div><div class="line"><span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 1000</span>; i++ {</div><div class="line">	leak := <span class="built_in">make</span>([]<span class="typename">int32</span>,<span class="number"> 60</span><span class="number">*1024</span>) <span class="comment">// allocat 60*1K*4bytes = 240 KiB</span></div><div class="line">	memoryLeaks = <span class="built_in">append</span>(memoryLeaks, leak)</div><div class="line">}</div><div class="line"></div><div class="line">   runtime.GC()</div><div class="line">   ......</div></pre></td></tr></table></figure>

<p>这个时候查看 heap profile，你会发现heap profile和<code>runtime.MemStats</code>统计的内存分配情况不一样，因为 <code>runtime.MemStats</code> 是实时统计的，而 heap profile 是采样统计的。<br><img src="6.png" alt=""></p>
<p><img src="7.png" alt=""></p>
<p>可以看到 <code>234 MiB</code> 和 <code>230.36</code> 是不一致的。</p>
<p>如果在程序一开始加上 <code>runtime.MemProfileRate = 1</code>,  heap profle 数据变成了 <code>234MB</code>, 有一致了。<br><img src="8.png" alt=""></p>
<p>但是也需要注意，将 <code>runtime.MemProfileRate</code> 设置为 1，对每一次内存都进行采样统计，对性能的影响也相应的增大了，非必要不用更改这个值。</p>
<p>所以，我们默认看到 heap profile, 都是在默认值 <code>512 * 1024</code> 这个阈值下采样统计的，和实际的 heap 上的内存分配可能会有些出入，但是对于我们分析内存泄露，影响不大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go heap profile 是尝尝用来检查内存泄露和内存占用大问题的问题的手段，而且非常惯用。</p>
<p>而且，我们也经常创建两个间隔较长的 heap profile, 获取它们的差值来方便查看内存泄露: <a href="https://colobu.com/2019/08/20/use-pprof-to-compare-go-memory-usage/" target="_blank" rel="external">Hi, 使用多年的go pprof检查内存泄漏的方法居然是错的?! </a></p>
<p>今天，度厂的一位同学提出了一个很有意思的案例，让我们对 heap profile 有了更深的理解。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言编程技巧 1.0 发布了]]></title>
    <link href="https://colobu.com/2024/04/28/gotips-1-0-is-released/"/>
    <id>https://colobu.com/2024/04/28/gotips-1-0-is-released/</id>
    <published>2024-04-28T00:47:56.000Z</published>
    <updated>2024-07-03T03:41:24.501Z</updated>
    <content type="html"><![CDATA[<p>经过和众多Gopher的努力，Go语言编程技巧 1.0 版本终于发布了。这是一个Go语言编程技巧的集合，涵盖了Go语言的各个方面，包括语法、并发、性能、工具、库等等。这个项目的目的是帮助Go语言开发者更好地理解Go语言，提高Go语言编程技巧。</p>
<a id="more"></a>
<p>在线阅读: <a href="https://github.com/smallnest/gotips" target="_blank" rel="external">gotips</a>。<br>下载pdf: <a href="https://github.com/smallnest/ebooks/blob/master/gotips.pdf" target="_blank" rel="external">gotips.pdf</a></p>
<p><img src="gotips-cover.png" alt=""></p>
<p>这是 <a href="https://twitter.com/func25" target="_blank" rel="external">Phuong Le</a> 在X上发布的一系列的技巧。<br>Phuong Le也将推文整理成到了一个github仓库中<a href="https://github.com/func25/go-practical-tips" target="_blank" rel="external">go-practical-tips</a></p>
<p>征得作者同意，翻译成了中文。 </p>
<p>本书是基于Phuong Le的推文进行翻译的，同时也会新建一个说明页，按照作者github项目上的划分整理各个tip。</p>
<p>感谢以下网友共同进行了翻译，翻译进展迅速。</p>
<p>正如作者所说，有些tip可能有一些错误：</p>
<blockquote>
<p> Some of the tips were awkward, with typos and naive explanations.</p>
</blockquote>
<p>我们翻译的时候也发现了作者的一些手误，或者错误，及时做了注解和纠正。难免还有一些问题，欢迎大家到github提issue或者提Pull request.</p>
<p><img src="contributors.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经过和众多Gopher的努力，Go语言编程技巧 1.0 版本终于发布了。这是一个Go语言编程技巧的集合，涵盖了Go语言的各个方面，包括语法、并发、性能、工具、库等等。这个项目的目的是帮助Go语言开发者更好地理解Go语言，提高Go语言编程技巧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言编程技巧和参与开源项目]]></title>
    <link href="https://colobu.com/2024/04/21/gotips-and-open-source/"/>
    <id>https://colobu.com/2024/04/21/gotips-and-open-source/</id>
    <published>2024-04-21T14:51:11.000Z</published>
    <updated>2024-07-03T03:41:24.514Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/smallnest/gotips" target="_blank" rel="external">Go语言编程技巧</a> 一个翻译项目， 主要翻译<a href="https://twitter.com/func25" target="_blank" rel="external">Phuong Le</a>的 Golang Tips系列。<br>翻译后的网站是: <a href="https://colobu.com/gotips/" target="_blank" rel="external">https://colobu.com/gotips/</a></p>
<a id="more"></a>
<h2 id="项目背景">项目背景</h2>
<p>如果一个人能分享一条关于Go语言的技巧，那是非常有意思的一件事情。<br>如果一个人能分享十条关于Go语言的技巧，那是非常有心值得大家称赞的事情。<br>如果一个人能分享一百条关于Go语言的技巧，那是值得大家顶礼膜拜的事情。<br>实际上，这需要相当大的毅力坚持下来，不少人可能写了一二十条就半途而废了。如果持续输出高质量的编程技巧，说明作者工作中非常有心做总结，作者也有丰富的Go编程经验，才能持续高质量的输出。</p>
<p>Phuong Le已经坚持写了78条Go编程技巧了，而且还在持续输出，非常的赞。</p>
<p>我也征得了Phuong Le的同意，将这些技巧翻译成中文，方便更多的人学习Go语言的技巧，了解Go语言的陷阱。</p>
<p>当然，Phuong Le也希望能够以项目仓库的方式来翻译这些技巧。</p>
<p>我在githun上创建了一个仓库: github.com/smallnest/gotips, 用于翻译Phuong Le的Go编程技巧。</p>
<p>因为有70条的条目，翻译起来也需要花一些时间，我也希望有更多的人参与进来，一起翻译这些技巧。在熊厂内部也有很多Go语言的爱好者，大家也希望能够参与进来，厂外的朋友也可以参与进来。</p>
<p>因为Phuong Le的Golang tips系列每一个技巧都是独立的，而且每一个都是简短的几句话或者几段话，再加上几张代码图片，所以翻译起来也比较容易，也非常适合大家翻译。</p>
<p>目前翻译进度是 45%, 也欢迎大家积极参与进来，按照这个速度，五一之后很快就可以翻译完了。</p>
<h2 id="为大家协作做的一些工作">为大家协作做的一些工作</h2>
<p>为了方便大家参与到翻译项目，我做了一些工作，让大家可以更容易的参与进来。</p>
<h3 id="制定翻译规则">制定翻译规则</h3>
<ol>
<li>设置项目布局，基于mdbook的方式进行管理</li>
<li>每一个tip一个markdown文件，内容格式保持统一</li>
<li>参与者首先创建issue，说明要翻译的tip，然后fork项目，翻译完成后提交PR</li>
<li>允许先进行机翻，但是一定要经过人工润色，保证翻译质量</li>
<li>认领一个星期未提交或者修改的tip，将会被关闭，无论多么接近完成状态</li>
</ol>
<p>同时设置了github actions，合并后自动进行编译发布，第一时间可以在 <a href="http://colobu.com/gotips/" target="_blank" rel="external">http://colobu.com/gotips/</a> 看到最新的翻译。</p>
<p>为了鼓励大家的积极性，我还配置贡献者插件，将贡献者的图标加入到README中。 翻译最后我还准备制作一个翻译数量的统计。</p>
<h2 id="为什么要参与开源项目">为什么要参与开源项目</h2>
<p>本来在上星期的QCON大会，我准备分享一些关于开源项目的心得，但是因为时间关系，没有分享出来。我也想借这个开源项目，和大家聊一聊为什么我们要参与开源项目，尤其是对那些还未参加过开源项目的同学。</p>
<blockquote>
<p>我总是想提供一些参与开源项目的机会给身边的同学，但是我从不苦口婆心的规劝同学到开源项目中来。因为我觉得自有主动的人才能真正的享受到开源项目的乐趣，也能真正的从中受益。</p>
</blockquote>
<h3 id="参与开源项目，可以让开发者接触到更广阔的技术领域和更先进的技术理念。">参与开源项目，可以让开发者接触到更广阔的技术领域和更先进的技术理念。</h3>
<p>通过参与开源社区，开发者可以与全球的技术同行进行交流和合作，共享知识和经验，不断提升自己的技术水平。这种交流和合作不仅能够拓宽开发者的视野，还能够激发创新思维，推动技术的进步和发展。<br>我曾经对Go并发库中的Once实现有疑问， Ian Taylor当天就在论坛上回答了我的问题，这种能得到大牛的指导是非常难得的，无论你是参与到Go、Linux、Redis等知名的项目，还是一些小众的软件中，都有可能得到一些业界大牛和经验丰富开发者的知道、帮助和讨论。<br>参与开源项目，也也能够得到技术的提升，比如你参与翻译这个Golang Tips系列，肯定会比你自己看一本Go语言的书籍要更深入的了解Go语言的一些细节和陷阱。</p>
<p>参与开源项目，还可以提高开发者的编程能力和解决问题的能力。</p>
<h3 id="参与开源项目能够提升开发者的个人影响力和知名度。">参与开源项目能够提升开发者的个人影响力和知名度。</h3>
<p>比如Go生态圈，你极有可能通过Go的贡献者名单，了解到一些赫赫有名的Go技术大牛。如果你在Go的项目中有过贡献，你的名字也会出现在贡献者名单中，这对于你的个人影响力和知名度是非常有帮助的。<br>在开源社区中，优秀的贡献者往往会受到广泛的认可和赞誉，这对于开发者个人职业发展来说是非常有利的。通过参与开源项目，开发者可以展示自己的技术实力和团队协作能力，吸引更多的关注和机会。<br>大部分的招聘者在看到你在github上的贡献之后，印象分会更好，你的简历也会更有竞争力。</p>
<h3 id="参与开源项目还能够培养开发者的责任心和使命感。">参与开源项目还能够培养开发者的责任心和使命感。</h3>
<p>开源项目往往承载着社区成员的共同愿景和使命，参与其中需要承担一定的责任和义务。通过履行这些责任和义务，开发者可以培养自己的责任心和使命感，为社区的发展贡献自己的力量。<br>比如你认领了一个工作，如果你积极的去完成，你会感到一种责任感，你会感到一种使命感，你会感到一种成就感，大家也会对你的贡献表示感谢。<br>如果你认领了一个工作，拖拖拉拉，最后没有完成，大家会对你感到失望，你自己也会缺乏这种责任感。</p>
<h3 id="参与开源项目还能够拓展开发者的人脉和社交圈。">参与开源项目还能够拓展开发者的人脉和社交圈。</h3>
<p>通过参与开源项目，开发者可以结识更多的技术同行和志同道合的朋友，建立起更广泛的人脉和社交圈。这些人脉和社交圈不仅能够为开发者提供技术支持和资源共享，还能够为开发者提供更多的机会和发展空间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/smallnest/gotips" target="_blank" rel="external">Go语言编程技巧</a> 一个翻译项目， 主要翻译<a href="https://twitter.com/func25" target="_blank" rel="external">Phuong Le</a>的 Golang Tips系列。<br>翻译后的网站是: <a href="https://colobu.com/gotips/" target="_blank" rel="external">https://colobu.com/gotips/</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gotips 002: 多阶段 defer]]></title>
    <link href="https://colobu.com/2024/04/16/gotips-002-Multistage-defer/"/>
    <id>https://colobu.com/2024/04/16/gotips-002-Multistage-defer/</id>
    <published>2024-04-16T01:27:10.000Z</published>
    <updated>2024-07-03T03:41:24.500Z</updated>
    <content type="html"><![CDATA[<p>通过简单的&#39;defer&#39;关键字，你可以借助一个小技巧实现在另一个函数的开头和结尾处执行一个函数。下面的图片展示了这一实现方式。</p>
<a id="more"></a>
<p><img src="defer.png" alt=""></p>
<hr>
<p><strong>补充信息</strong></p>
<p>在上一个 tip 中的补充材料中，我已经介绍了这种方法的使用。这里我再举一个例子。</p>
<p>在 Java 等编程·语言生态圈中，有一些单元测试的框架如 JUint, 可以为单元测试开始前设置一些初始环境 (<code>Setup</code> 方法)，单元测试结束时执行一些清理动作 (<code>Teardown</code> 方法)，在 Go 语言中该怎么实现呢？</p>
<p>我们就可以使用 tip #002 这种方式实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> setupTestCase(t *testing.T, msg <span class="typename">string</span>) <span class="keyword">func</span>(t *testing.T) {</div><div class="line">	t.Log(msg + <span class="string">": setup test case"</span>)</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(t *testing.T) {</div><div class="line">		t.Log(msg + <span class="string">": teardown test case"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> TestSetupTestCase(t *testing.T) {</div><div class="line">	<span class="keyword">defer</span> setupTestCase(t, <span class="string">"TestSetupTestCase"</span>)(t)</div><div class="line"></div><div class="line">	t.Log(<span class="string">"Run test"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以专门为你的某个单元测试写一个 <code>setupTestCase</code>, 执行特定的初始化和清理逻辑，也可以为一批单元测试函数写一个通用的初始化和清理逻辑。</p>
<p>说起清理，官方 <code>testing</code> 库中有 <code>t.Cleanup</code>、<code>b.Cleanup</code> 、<code>tb.Cleanup</code>、<code>f.Cleanup</code> 方法，可以注册多个清理函数，执行完测试或者子测试后就会被调用，后进先出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过简单的&#39;defer&#39;关键字，你可以借助一个小技巧实现在另一个函数的开头和结尾处执行一个函数。下面的图片展示了这一实现方式。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gotips 001: 一行代码测量函数的执行时间]]></title>
    <link href="https://colobu.com/2024/04/15/gotips-001-Measure-the-execution-time-of-a-function-in-just-one-line-of-code/"/>
    <id>https://colobu.com/2024/04/15/gotips-001-Measure-the-execution-time-of-a-function-in-just-one-line-of-code/</id>
    <published>2024-04-15T01:15:18.000Z</published>
    <updated>2024-07-03T03:41:24.499Z</updated>
    <content type="html"><![CDATA[<p> Golang Tips 是翻译的 Phuong Le  <a href="https://twitter.com/func25" target="_blank" rel="external">@func25</a> 陆陆续续的发表的推文，目前已经发表 70+了。我征得Phuong Le 的同意后，会逐步把这些推翻翻译过来，发布到公众号上。</p>
<p> 因为是推文，可能原作者的内容比较简单，比如第一个 tip 就一张图片，我会相应的进行扩充，丰富其内容。<br> 后续也会在 github 建立一个项目，大家都可以参与进行翻译。</p>
<a id="more"></a>
<p>我们可以通过 <code>defer</code>，实现一行代码来测量某个函数的执行时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> TrackTime(time.Now()) <span class="comment">// 一行代码</span></div><div class="line">	</div><div class="line">	time.Sleep(time.Second)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> TrackTime(start time.Time) time.Duration {</div><div class="line">	elapsed := time.Since(start)</div><div class="line">	fmt.Println(<span class="string">"elapsed:"</span>, elapsed)</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> elapsed</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// elapsed: 1.000704416s</span></div></pre></td></tr></table></figure>

<p>这个 <code>defer</code> 的函数 <code>TraceTime</code> 放在函数内需要测量的起始点，它的参数(<code>start</code>)在此时就会计算出来，在函数返回的时候，它的函数体就会被调用，这是 <code>end</code> 时间也知道了，这样就可以巧妙的计算出来函数执行的时间了。</p>
<p><strong>以下是补充材料</strong></p>
<hr>
<p>我们还可以使用下面的写法，但是更好更通用些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> TrackTime(name <span class="typename">string</span>) <span class="keyword">func</span>() {</div><div class="line">	start := time.Now()</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="keyword">func</span>() {</div><div class="line">		fmt.Printf(<span class="string">"%s took %v\n"</span>, name, time.Since(start))</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">defer</span> TrackTime(<span class="string">"main"</span>)() <span class="comment">// 也是一行代码</span></div><div class="line">	time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个 <code>defer</code> 的 <code>TraceTime</code> 传入一个辅助信息字符串，方便打日志的能和其它的测量函数所区分。<br><code>TraceTime</code> 返回一个类型为 <code>func()</code> 函数匿名函数，这才是 <code>defer</code> 真正调用的函数，它会打印出要测量的函数真正花费的时间。</p>
<p>相比较上面的测量方法，这个函数可以传入辅助字符串，并且不需要自己再调用 <code>time.Now()</code> 获得开始时间。</p>
<hr>
<p>另外，我还想补充一个测试性能的时候的辅助库：<a href="https://github.com/loov/hrtime" target="_blank" rel="external">hrtime</a>)。<br>一般我们会写 Benchmark 的测试代码来测试一段代码逻辑(一般是一个函数，但是也可以是多个函数和语句组成的一段代码逻辑)的性能，但是有的时候，我们可能想写一个程序，更灵活的进行测试，甚至希望得到时间花费的分布情况， hrtime 就是干这个的，就像它的简介中所说，它是Go语言中的高精度计时与基准测试库。</p>
<p>首先我们看一下它的使用方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/loov/hrtime"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    start := hrtime.Now()</div><div class="line">    time.Sleep<span class="number">(1000</span> * time.Nanosecond)</div><div class="line">    fmt.Println(hrtime.Since(start))</div><div class="line"></div><div class="line">    <span class="keyword">const</span> numberOfExperiments =<span class="number"> 4096</span></div><div class="line"></div><div class="line">    bench := hrtime.NewBenchmark(numberOfExperiments)</div><div class="line">    <span class="keyword">for</span> bench.Next() {</div><div class="line">        time.Sleep<span class="number">(1000</span> * time.Nanosecond)</div><div class="line">    }</div><div class="line">    fmt.Println(bench.Histogram<span class="number">(10</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>单纯的测量一段代码的执行时间，和常规的我们使用 time package 方法一样，你也可以采用前面介绍的方法，实现一行代码的封装。</p>
<p>同时，类似标准库的 Benchmark 的测量性能的方法，你也可以利用 <code>bench := hrtime.NewBenchmark(numberOfExperiments)</code> 生成一个 <code>bench</code>，进行性能测试，最后通过 <code>bench.Histogram(10)</code> 生成直方图。比如这个例子，我们测试 Sleep 1 微秒时，实际程序会休眠多少微秒。</p>
<p>在我的 Mac mini 的机器上测试，可以看到真正休眠在 5 微秒左右，绝大部分时间落在了 15 微秒以内。</p>
<p><img src="hrtime.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> Golang Tips 是翻译的 Phuong Le  <a href="https://twitter.com/func25" target="_blank" rel="external">@func25</a> 陆陆续续的发表的推文，目前已经发表 70+了。我征得Phuong Le 的同意后，会逐步把这些推翻翻译过来，发布到公众号上。</p>
<p> 因为是推文，可能原作者的内容比较简单，比如第一个 tip 就一张图片，我会相应的进行扩充，丰富其内容。<br> 后续也会在 github 建立一个项目，大家都可以参与进行翻译。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类型安全的Pool]]></title>
    <link href="https://colobu.com/2024/04/10/a-generic-sync-Pool/"/>
    <id>https://colobu.com/2024/04/10/a-generic-sync-Pool/</id>
    <published>2024-04-09T23:44:14.000Z</published>
    <updated>2024-07-03T03:41:24.498Z</updated>
    <content type="html"><![CDATA[<p>池（<code>sync.Pool</code>）是一组可单独保存(<code>Set</code>)和检索(<code>Get</code>)的临时对象集合。</p>
<p>存储在池中的任何项都可能在任何时候自动移除而无需通知。如果池在移除项时持有该对象的唯一引用，那么这个对象可能会被释放掉。</p>
<p>池能够确保在多个goroutine同时访问时的安全性。</p>
<p>池的目的在于缓存已分配但未使用的对象以便后续复用，减轻垃圾收集器的压力。</p>
<a id="more"></a>
<p>也就是说池的功能是为了重用对象，目的是减轻GC的压力。</p>
<h2 id="类型不安全？">类型不安全？</h2>
<p>你看<code>sync.Pool</code>提供的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> {</div><div class="line">	New <span class="keyword">func</span>() any</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pool) Get() any</div><div class="line"><span class="keyword">func</span> (p *Pool) Put(x any)</div></pre></td></tr></table></figure>

<p>它存储的对象类型是<code>any</code>，这样的话，我们在使用的时候就需要进行类型转换，这样就会导致类型不安全，或者说使用起来很麻烦。</p>
<p>比就以官方的例子为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> bufPool = sync.Pool{</div><div class="line">	New: <span class="keyword">func</span>() any {</div><div class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</div><div class="line">	},</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> timeNow() time.Time {</div><div class="line">	<span class="keyword">return</span> time.Unix<span class="number">(1136214245</span>,<span class="number"> 0</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Log(w io.Writer, key, val <span class="typename">string</span>) {</div><div class="line">	b := bufPool.Get().(*bytes.Buffer) <span class="comment">// 类型转换!!!!</span></div><div class="line">	b.Reset()</div><div class="line"></div><div class="line">	b.WriteString(timeNow().UTC().Format(time.RFC3339))</div><div class="line">	b.WriteByte(<span class="string">' '</span>)</div><div class="line">	b.WriteString(key)</div><div class="line">	b.WriteByte(<span class="string">'='</span>)</div><div class="line">	b.WriteString(val)</div><div class="line">	w.Write(b.Bytes())</div><div class="line">	bufPool.Put(b)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	Log(os.Stdout, <span class="string">"path"</span>, <span class="string">"/search?q=flowers"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>每次我们从<code>sync.Pool</code>中获取对象时，我们都需要进行类型转换，有一点点麻烦，而且是非类型安全的，有潜在的风险，比如误从另外一个包含其它类型的<code>sync.Pool</code>中获取对象。</p>
<p>其实我们可以使用泛型进行改造，但是为啥官方实现没有实现泛型呢？</p>
<p>那是因为Go的泛型实现的比较晚，所以当时只能使用<code>interface{}</code>（后来的<code>any</code>类型）来实现泛型，这样就会导致类型不安全。</p>
<h2 id="类型安全的Pool">类型安全的Pool</h2>
<p>我们可以通过泛型来解决这个问题，我们可以定义一个泛型的<code>Pool</code>，这样我们就可以直接使用泛型类型了。</p>
<p>事实上<a href="https://github.com/mkmik/syncpool/blob/main/pool.go" target="_blank" rel="external">mkmik/syncpool</a>就实现了一个泛型的<code>Pool</code>，通过巧妙的包装，简单几行代码就实现了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> syncpool</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Pool[T any] <span class="keyword">struct</span> {</div><div class="line">	pool sync.Pool</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> New[T any](fn <span class="keyword">func</span>() T) Pool[T] {</div><div class="line">	<span class="keyword">return</span> Pool[T]{</div><div class="line">		pool: sync.Pool{New: <span class="keyword">func</span>() <span class="keyword">interface</span>{} { <span class="keyword">return</span> fn() }},</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pool[T]) Get() T {</div><div class="line">	<span class="keyword">return</span> p.pool.Get().(T)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pool[T]) Put(x T) {</div><div class="line">	p.pool.Put(x)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里你可能有个疑问，<code>Get</code>方法在把接口类型转换为泛型类型时，为什么不需要进行错误检查呢:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c, ok := p.pool.Get().(T)</div></pre></td></tr></table></figure>

<p>嗯，其实是没必要的，因为我们的泛型Pool已经保证了保存的对象都是<code>T</code>类型的。</p>
<blockquote>
<p>我写这篇文章主要源自 Phuong Le 最新的推文 &quot;Golang Tip #71: sync.Pool, make it typed-safe with generics.&quot;<br>他的Golang Tip系列文章非常有价值，我已经获得作者授权，后续会翻译一些文章，希望对大家有所帮助。</p>
</blockquote>
<h2 id="还是有装箱/拆箱操作">还是有装箱/拆箱操作</h2>
<p>既然使用底层的<code>snyc.Pool</code>, 那自然还有装箱/拆箱操作，也就是说，当我们保存一个<code>T</code>类型的对象，它会转换成接口类型，当我们取出一个对象时，又会把接口类型转换成<code>T</code>类型。<br>从性能上讲，这个操作是有开销的，那么<code>sync.Pool</code>是否会修改成泛型呢，目前看是不会的，因为Go要保持向下兼容，基于这个承诺，已经没机会改了。</p>
<p>那么我们能否基于<code>sync.Pool</code>自己修改呢？难度很大，主要在于下面一点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	runtime_registerPoolCleanup(poolCleanup)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Implemented in runtime.</span></div><div class="line"><span class="keyword">func</span> runtime_registerPoolCleanup(cleanup <span class="keyword">func</span>())</div></pre></td></tr></table></figure>

<p><code>sync.Pool</code>在运行时中插入了一个桩子，运行时在垃圾回收的时候，会调用函数做对象的清理，而且这个函数是单例的，只处理<code>sync.Pool</code>类型(你新创建的sync.Pool都会放到一个全局列表中，被这个函数做对象回收)。</p>
<p>不是太容易<code>hack</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>池（<code>sync.Pool</code>）是一组可单独保存(<code>Set</code>)和检索(<code>Get</code>)的临时对象集合。</p>
<p>存储在池中的任何项都可能在任何时候自动移除而无需通知。如果池在移除项时持有该对象的唯一引用，那么这个对象可能会被释放掉。</p>
<p>池能够确保在多个goroutine同时访问时的安全性。</p>
<p>池的目的在于缓存已分配但未使用的对象以便后续复用，减轻垃圾收集器的压力。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[goroutine调度器揭秘 2]]></title>
    <link href="https://colobu.com/2024/03/24/goroutine-scheduler-2/"/>
    <id>https://colobu.com/2024/03/24/goroutine-scheduler-2/</id>
    <published>2024-03-24T09:10:48.000Z</published>
    <updated>2024-03-26T09:37:28.187Z</updated>
    <content type="html"><![CDATA[<p>我翻译了<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a>, 这篇文章发表于1月2号，作者在文章最后说：</p>
<blockquote>
<p>在接下来的部分,我们将更深入地探讨抢占式调度,并分析调度程序在运行期间所采取的每一步骤。</p>
</blockquote>
<a id="more"></a>
<p>接下来快三个月了，也没有下文了，貌似鸽了。<br>为了不让读者等待，我接下来把相关的内容补上。</p>
<p>当然，Go的调度器也在演化之中，你看几年前的代码，或者几年后的代码，可能就没有办法一一对应了，我们以1.21.1版本讲解。</p>
<h2 id="schedule_函数">schedule 函数</h2>
<p>函数<code>schedule</code>执行一次调度器循环，找到一个可运行的goroutine并执行它。这个函数永不返回。当一个 <code>goroutine</code> 执行完毕，它会再次调用 <code>schedule</code> 函数来选择下一个要执行的 <code>goroutine</code>。这就是为什么 <code>schedule</code> 函数看起来像是永不返回：它总是在选择和执行 <code>goroutine</code>，除非没有更多的 <code>goroutine</code> 可以执行。</p>
<p><code>schedule</code> 函数并不是通过常规的函数调用栈来调度 <code>goroutine</code> 的。当一个 <code>goroutine</code> 结束执行，它并不是通过返回到 <code>schedule</code> 函数来调度下一个 <code>goroutine</code>，而是通过一种称为 &quot;栈切换&quot; 的技术。</p>
<p>在具体实现上，每个 <code>goroutine</code> 都有自己的栈，当它开始执行时，运行时系统会将当前的栈指针切换到这个 <code>goroutine</code> 的栈，当它结束执行时，运行时系统会将栈指针切换回原来的栈（通常是所谓的 &quot;系统栈&quot; 或 &quot;调度器栈&quot;）。这样，每个 <code>goroutine</code> 的函数调用栈都是独立的，它们不会互相影响，也不会导致栈溢出。</p>
<p>因此，尽管从代码上看 <code>schedule</code> 函数像是在递归调用，但实际上它并不会导致栈溢出，因为每次调用 <code>schedule</code> 都是在一个新的 <code>goroutine</code> 的栈上，而不是在同一个函数调用栈上。</p>
<p><a href="https://github.com/golang/go/blob/c2c4a32f9e57ac9f7102deeba8273bcd2b205d3c/src/runtime/proc.go#L3857" target="_blank" rel="external">proc.go#schedule</a></p>
<p>以下是一些可能会调用 schedule 函数的函数和它们的使用场景：</p>
<ol>
<li><code>goexit</code>(goexit1-&gt;goexit0)：当一个 <code>goroutine</code> 结束执行时，它会调用 <code>goexit</code> 函数来清理资源并退出。在 <code>goexit</code> 函数中，会调用 <code>schedule</code> 函数来选择下一个要执行的 <code>goroutine</code>。</li>
<li><code>preemptPark</code>：<code>preemptPark</code> 函数被用于实现抢占式调度。当运行时系统决定当前正在执行的 <code>goroutine</code> 需要被抢占时，它会设置 goroutine 的状态为 <code>_Gpreempted</code>，并调用 <code>preemptPark</code> 函数将 <code>goroutine</code> 挂起。</li>
<li><code>park_m</code>: <code>park_m</code> 函数被用于将当前的操作系统线程（M）挂起，直到有新的 <code>goroutine</code> 可以运行。比如没有<code>goroutine</code>可运行时，或者因为每个条件阻塞时。</li>
<li><code>goschedImpl</code>：调用<code>runtime.Gosched</code> 函数时，它被用于让当前的 <code>goroutine</code> 主动让出 CPU，让其他 <code>goroutine</code> 有机会执行。</li>
<li><code>goyield_m</code>: 类似<code>runtime.Gosched</code> 函数, <code>goyield_m</code> 函数也被用于让当前的 <code>goroutine</code> 主动让出 CPU，让其他 <code>goroutine</code> 有机会执行。但是它会把当前的goroutine放到local run queue,而不像<code>Gosched</code>放到global run queue。</li>
<li><code>mstart1</code>：创建的操作系统线程（M）开始执行时被调用的。b比如新创建M时，或者M不够用的时候。它的主要任务是初始化线程的环境，并开始执行调度循环。</li>
<li><code>exitsyscall0</code>: <code>exitsyscall0</code> 函数在一个 <code>goroutine</code> 完成<strong>系统调用</strong>并准备返回到 Go 空间时被调用。系统调用的goroutine返回后，会尝试找一个空闲的P去执行当前的G(和M), 否则会把当前的G放到global run queue中。</li>
</ol>
<p>这些函数都是 Go 语言运行时系统中的内部函数，它们的具体实现可能会因 Go 语言的版本和运行时系统的配置而不同。</p>
<p>在<code>schedule</code>函数中，重要的是调用了<code>findRunnable</code>, 找到一个可以执行的<code>goroutine</code>。必须要找到一个，否则会阻塞直到找到一个<code>goroutine</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></div></pre></td></tr></table></figure>

<p>那么，接下来我们跟踪<code>findRunnable</code>函数,了解它的每一个步骤，这是调度器工作的重点。</p>
<h2 id="findRunnable_函数">findRunnable 函数</h2>
<p><img src="findRunnable.svg" alt=""></p>
<p><code>findRunnable</code> 函数是调度器的核心函数之一，它的主要任务是找到一个可以执行的 <code>goroutine</code>。</p>
<p><code>findRunnable</code> 函数的实现非常复杂，因为它需要考虑很多因素，比如当前的 <code>goroutine</code> 是否需要被抢占，当前的 <code>goroutine</code> 是否需要让出 CPU，当前的 <code>goroutine</code> 是否需要被挂起，当前的 <code>goroutine</code> 是否需要被唤醒，当前的 <code>goroutine</code> 是否需要被移动到其他的 <code>P</code>，等等。我们暂时不考虑这些复杂的情况，只关注最简单的情况：怎么找到一个可以执行的 <code>goroutine</code>。</p>
<h3 id="可以寻找的goroutine">可以寻找的goroutine</h3>
<p>重点它寻找一个可以执行的<code>goroutine</code>，这些goroutine都是存在什么地方内？</p>
<ul>
<li><code>local run queue</code>: 每个P都有一个local run queue，用于存放当前P上的goroutine。</li>
<li><code>global run queue</code>: 所有的P共享一个global run queue，用于存放所有的goroutine。</li>
<li><code>netpoll</code>: 用于处理网络事件的goroutine。</li>
<li><code>timer</code>: 用于处理定时器事件的goroutine。</li>
<li><code>syscall</code>: 用于处理系统调用的goroutine。</li>
</ul>
<p>处于性能优化的目的，每个处理器（P）确实包含一个<strong>四叉堆</strong>（heap），用于保存定时器（timer）。。<br>每个定时器都有一个到期时间，当到达这个时间时，定时器关联的函数就会被调用。四叉堆的结构使得运行时系统可以快速地找到最早到期的定时器，这对于定时器的处理非常重要。<br>当你在 Go 代码中使用 time.After，time.Sleep 或 time.AfterFunc 等函数时，就会创建一个定时器，并将其添加到当前 P 的 timers 四叉堆中。</p>
<p>全局还有一个网络轮询器（netpoller），它用于处理网络事件。每个findRunnable调用的时候也可能去访问它。</p>
<h3 id="findRunnable_寻找goroutine的步骤">findRunnable 寻找goroutine的步骤</h3>
<p><img src="findRunnable-flowchart.svg" alt=""></p>
<p><code>findRunnable</code>函数寻找goroutine过程既复杂又简单。<br>说它复杂，是因为它需要考虑很多因素，做各种检查，执行不同的策略去寻找goroutine。<br>说它简单，是因为它的逻辑很清晰，只是一步一步地检查，直到找到一个可以执行的goroutine。一旦找到goroutine，就直接返回。</p>
<p>根据这个函数的实现，我把大致的逻辑画了一个流程图，如上图所示，下面我们一步一步地解释这个流程图，忽略其中的一些条件检查，我们主要关注它的大的逻辑。</p>
<ol>
<li>首先定义了一个<code>top</code>标签，因为在后面的代码中，需要从头开始重新检查，类似一个for循环，但是这里使用<code>goto</code>语句更清晰。</li>
<li>检查Timer,如果有到期的timer,则执行timer相关的goroutine。如果程序中有大量的Timer也不太好，如果Timer大量的增删或者日期变化，会导致性能问题。</li>
<li>检查tracer, 跟踪调用的goroutine，如果符合条件，执行。</li>
<li>检查是否有gc worker要执行，如果有，执行。</li>
<li>如果tick(嘀嗒)计数器到了61次，并且global run queue中有goroutine，那么执行global run queue中的goroutine。</li>
<li>如有必要，唤醒finalizer</li>
<li>如有必要，执行cgo_yield，让执行cgo系统调用的goroutine让出CPU。</li>
<li>检查local run queue, 如果有goroutine，执行。</li>
<li>再次检查global run queue, 如果有goroutine，执行。</li>
<li>检查netpoll, 如果网络事件需要处理，唤醒相关的goroutine。</li>
<li>从其他P的local run queue中偷取goroutine，如果有goroutine，执行。</li>
<li>如有必要，执行idle-time marking, 执行GC的标记阶段。</li>
<li>wasm相关的逻辑处理</li>
<li>再次检查global run queue, 如果有goroutine，执行。</li>
<li>如有需要，再次从头检查</li>
<li>再次检查netpoll</li>
<li>如果没有找到可以执行的goroutine，阻塞等待</li>
</ol>
<p>总体上看， findRunnable 函数实现了一个通用的goroutine调度逻辑。</p>
<p>也许，针对不同的场景，你可以在这个调度器上微调，尝试获取更高性能调度：</p>
<ol>
<li>调整寻找goroutine的顺序、频次等</li>
<li>进行goroutine的优先级调度、进行NUMA等CPU架构的优化</li>
</ol>
<p>这样，我们把原作者的许诺的分享中的调度步骤的内容补上了，接下来补上最后一部分的内容：抢占式调度。请关注公众号 “鸟窝聊技术” 获取最新文章。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我翻译了<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a>, 这篇文章发表于1月2号，作者在文章最后说：</p>
<blockquote>
<p>在接下来的部分,我们将更深入地探讨抢占式调度,并分析调度程序在运行期间所采取的每一步骤。</p>
</blockquote>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[goroutine调度器揭秘]]></title>
    <link href="https://colobu.com/2024/03/19/goroutine-scheduler-revealed/"/>
    <id>https://colobu.com/2024/03/19/goroutine-scheduler-revealed/</id>
    <published>2024-03-19T15:45:25.000Z</published>
    <updated>2024-03-26T09:37:28.192Z</updated>
    <content type="html"><![CDATA[<p>你以前可能听说过 Goroutine 调度器，但你对它的工作原理了解多少？它如何将 goroutine 与线程配对？</p>
<p>原文:<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a><br><a id="more"></a></p>
<p><img src="behind-goroutines.webp" alt=""></p>
<p>不用着急理解上面的图像,因为我们要从最基本的开始。</p>
<p>goroutine 被分配到线程中运行,这由 goroutine 调度器在后台处理。根据我们之前的讨论,我们了解到以下关于 goroutine 的几点:</p>
<ul>
<li>就原始执行速度而言,goroutine 并不一定比线程更快,因为它们需要在实际线程上运行。</li>
<li>goroutine 真正的优势在于上下文切换、内存占用、创建和销毁的成本等方面。</li>
</ul>
<p>你可能以前听说过 goroutine 调度器,但我们真正了解它的工作原理吗?它是如何将 goroutine 与线程配对的?</p>
<p>现在让我们一步一步地分解调度器的工作原理。</p>
<h2 id="goroutine_M:N_调度器模型">goroutine M:N 调度器模型</h2>
<p>Go 团队真的为我们简化了并发编程,想想看:创建一个 goroutine 只需要在函数前加上 go 关键字就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> doWork()</div></pre></td></tr></table></figure>

<p>但在这个简单的步骤背后,有一个更深层次的系统在运作。</p>
<p>一开始,Go 就没有简单地为我们提供线程。相反,中间有一个助手,即 goroutine 调度器,它是 Go 运行时的关键部分。</p>
<p><img src="scheduler.webp" alt=""></p>
<p>那么<code>M:N</code>这个标签是什么意思呢?</p>
<p>它体现了Go调度器在将<code>M</code>个goroutine映射到<code>N</code>个内核线程方面的作用,形成了<code>M:N</code>模型。操作系统线程的数量可以多于CPU核心数,就像goroutine的数量也可以多于操作系统线程一样。</p>
<p>在深入探讨调度器之前,让我们先区分一下经常混淆的两个概念:并发和并行。</p>
<ul>
<li><strong>并发</strong>: 指同时处理多个任务,这些任务都在运行,但不一定在同一时间运行。</li>
<li><strong>并行</strong>: 指多个任务在同一时刻真正同时运行,通常使用多个CPU核心。<br><img src="cp.webp" alt=""></li>
</ul>
<p>让我们看看 Go Scheduler 如何使用线程。</p>
<h2 id="PMG模型">PMG模型</h2>
<p>在我们解开内部工作原理之前,让我们先解释一下P、M和G分别代表什么意思。</p>
<h3 id="G_(goroutine)">G (goroutine)</h3>
<p>goroutine是Go中最小的执行单元,类似于一个轻量级线程。</p>
<p>在Go运行时,它由一个名为<code>g</code>的struct表示。一旦创建,它就会被放入逻辑处理器P的本地可运行队列(或全局队列),之后P会将它分配给一个实际的内核线程(M)。</p>
<p>goroutine通常存在三种主要状态:</p>
<ul>
<li><strong>Waiting</strong>:在这个阶段,goroutine处于静止状态,可能是由于等待某个操作(如channel或锁),或者是被系统调用阻塞。</li>
<li><strong>Runnable</strong>:goroutine已准备就绪,但尚未开始运行,它正在等待轮到在线程(M)上运行。</li>
<li><strong>Running</strong>:现在goroutine正在线程(M)上积极执行。它将一直运行直到任务完成,除非调度器中断它或其他事物阻碍了它的运行。</li>
</ul>
<p><img src="goroutine-states.webp" alt=""></p>
<p>goroutine不是一次性使用后就被丢弃的。</p>
<p>相反,当启动一个新的goroutine时,Go的运行时会从goroutine池中选择一个,如果池中没有,它会创建一个新的。然后,这个新的goroutine会加入某个P的可运行队列。</p>
<h3 id="P(逻辑处理器)">P(逻辑处理器)</h3>
<p>在Go调度器中,当我们提到&quot;处理器&quot;时,指的是一个逻辑实体,而不是物理实体。</p>
<p>默认情况下,P的数量设置为可用的CPU核心数,你可以使用runtime.GOMAXPROCS(int)检查或更改这些处理器的数量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">runtime.GOMAXPROCS<span class="number">(0</span>) <span class="comment">// get the current allowed number of logical processors</span></div><div class="line"></div><div class="line"><span class="comment">// Output: 8 (depends on your machine)</span></div></pre></td></tr></table></figure>

<p>如果你想修改P的数量,最好在应用程序启动时就这样做,因为如果在运行时修改,它会导致<code>STW</code>(stopTheWorld),所有操作都会暂停,直到处理器大小调整完成。</p>
<p>每个P都有自己的可运行goroutine列表,称为本地运行队列(Local Run Queue),最多可容纳256个goroutine。<br><img src="p.webp" alt=""></p>
<p>如果P的队列已满(256个goroutine),还有一个名为全局运行队列(Global Run Queue)的共享队列,不过我们稍后再讨论这个。</p>
<blockquote>
<p>&quot;那么,&#39;P&#39;的数量真正显示了什么呢?&quot;</p>
</blockquote>
<p>它表示可以并发运行的goroutine数量 - 想象它们并排运行。</p>
<h3 id="M(机器线程_-_操作系统线程)">M(机器线程 - 操作系统线程)</h3>
<p>一个典型的Go程序最多可使用10,000个线程。</p>
<p>没错,我说的是线程而不是goroutine。如果超过这个限制,你的Go应用程序就有崩溃的风险。</p>
<blockquote>
<p>&quot;线程是何时创建的呢?&quot;</p>
</blockquote>
<p>想象这种情况:一个goroutine处于可运行状态并需要一个线程。</p>
<p>如果所有线程都已被阻塞,可能是由于系统调用或不可抢占的操作,会发生什么?在这种情况下,调度器会介入并为该goroutine创建一个新线程。</p>
<p>(<em>需要注意的一点是:如果一个线程只是在进行昂贵的计算或长时间运行的任务,它不被视为陷入困境或被阻塞</em>)</p>
<p>如果你想改变默认的线程限制,可以使用<code>runtime/debug.SetMaxThreads()</code>函数,它允许你设置Go程序可使用的最大操作系统线程数。</p>
<p>另外,值得一提的是,线程会被重用,因为创建或删除线程是一个资源密集型的操作。</p>
<h3 id="MPG是如何协同工作的">MPG是如何协同工作的</h3>
<p>让我们通过以下步骤一步步理解M、P和G是如何协同工作的。</p>
<p>在这里我不会深入探讨每一个细节,但在后续的文章中会更深入地探讨。如果你对此感兴趣,请关注我的公众号。</p>
<p><img src="scheduler-works.webp" alt=""></p>
<ol>
<li>初始化一个goroutine:使用go func()命令时,Go运行时会新建一个goroutine或从池中选择一个已存在的goroutine。</li>
<li>入队排位:goroutine会寻找一个队列来加入,如果所有逻辑处理器(P)的本地队列都已满,该goroutine会被放入全局队列。</li>
<li>线程配对:这就是M发挥作用的地方。它获取一个P,并开始从P的本地队列处理goroutine。当M与这个goroutine交互时,其关联的P就会被占用,无法分配给其他M。</li>
<li>窃取行为:如果一个P的队列被耗尽,M会试图从另一个P的队列&quot;借用&quot;一半可运行的goroutine。如果失败,它会检查全局队列,然后是网络轮询器(参见下面的&quot;窃取过程&quot;图)。</li>
<li>资源分配:在M选择一个goroutine(G)后,它会为运行这个G获取所需的所有资源。</li>
</ol>
<blockquote>
<p>&quot;如果一个线程被阻塞了怎么办?&quot;</p>
</blockquote>
<p>如果一个goroutine启动了一个需要一段时间的系统调用(比如读取文件),M会一直等待。</p>
<p>但调度器不喜欢一直等待,它会将被阻塞的M从它的P上分离,然后将队列中另一个可运行的goroutine连接到一个新的或已存在的M上,M再与P团队合作。<br><img src="blocked.webp" alt=""></p>
<h3 id="窃取过程">窃取过程</h3>
<p>当一个线程(M)完成了它的任务,没有其他事情可做时,它不会就这样闲置。</p>
<p>相反,它会主动寻找更多工作,方法是查看其他处理器并接手它们一半的任务,让我们来分解一下这个过程:</p>
<p><img src="steal.webp" alt=""></p>
<ol>
<li>每61个嘀嗒,一个M会检查全局可运行队列,以确保公平执行。如果在全局队列中找到了可运行的goroutine,就停止。</li>
<li>该线程M现在会检查与它所在的处理器P相连的本地运行队列,看看有没有可运行的goroutine需要处理。</li>
<li>如果该线程发现它的队列为空,它就会查看全局队列,看看是否有任何等待中的任务。</li>
<li>然后,该线程会向网络轮询器询问是否有任何与网络相关的工作。</li>
<li>如果该线程在检查完网络轮询器后仍然没有找到任何任务,它就会进入主动搜索模式,我们可以将其视为自旋状态。</li>
<li>在这种状态下,该线程会尝试从其他处理器的队列中&quot;借用&quot;任务。</li>
<li>经过这些步骤后,如果该线程仍然没有找到任何工作,它就会停止主动搜索。</li>
<li>现在,如果有新的任务到来,并且有空闲的处理器没有正在搜索的线程,另一个线程就可以开始工作。</li>
</ol>
<p>需要注意的一点是,全局队列实际上被检查了两次:一次是每61个嘀嗒检查一次以保证公平性,另一次是在本地队列为空时检查。</p>
<blockquote>
<p>&quot;如果M已与其P绑定,它怎么能从其他处理器获取任务呢?M会改变它的P吗?&quot;</p>
</blockquote>
<p>答案是不会。</p>
<p>即使M从另一个P的队列中获取任务,它也是使用原来的P来运行该任务。因此,尽管M获取了新任务,但它仍然忠于自己的P。</p>
<blockquote>
<p>&quot;为什么是61?&quot;</p>
</blockquote>
<p>在设计算法时,尤其是哈希算法时,通常会选择素数,因为素数除了1和自身之外没有其他因子。</p>
<p>这可以减少出现模式或规律性的可能性,从而避免发生&quot;冲突&quot;或其他不希望出现的行为。</p>
<p>如果时间过短,系统可能会频繁浪费资源检查全局运行队列。如果时间过长,goroutine可能会在执行前过度等待。</p>
<h3 id="网络轮询器(Network_Poller)">网络轮询器(Network Poller)</h3>
<p>我们还没有太多讨论这个网络轮询器,但它出现在了窃取过程的示意图中。</p>
<p>与Go调度器一样,网络轮询器也是Go运行时的一个组件,负责处理与网络相关的调用(例如网络I/O)。</p>
<p>让我们比较一下两种系统调用类型:</p>
<ul>
<li>与网络相关的系统调用: 当一个goroutine执行网络I/O操作时,它不会阻塞当前线程,而是向网络轮询器注册。轮询器异步等待操作完成,一旦完成,该goroutine就可以再次变为可运行状态,并在某个线程上继续执行。</li>
<li>其他系统调用: 如果它们可能会阻塞且没有由网络轮询器处理,它们可能会导致goroutine将执行卸载到一个操作系统线程上。只有该特定的操作系统线程会被阻塞,Go运行时调度器可以在其他线程上执行其他goroutine。</li>
</ul>
<p>在后续部分,我们将更深入地探讨抢占式调度,并分析调度器在运行过程中所采取的每一步骤。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>你以前可能听说过 Goroutine 调度器，但你对它的工作原理了解多少？它如何将 goroutine 与线程配对？</p>
<p>原文:<a href="https://blog.devtrovert.com/p/goroutine-scheduler-revealed-youll" target="_blank" rel="external">Goroutine Scheduler Revealed: Never See Goroutines the Same Way Again</a><br>]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更强大的Go执行跟踪能力]]></title>
    <link href="https://colobu.com/2024/03/18/execution-traces-2024/"/>
    <id>https://colobu.com/2024/03/18/execution-traces-2024/</id>
    <published>2024-03-18T13:32:11.000Z</published>
    <updated>2024-03-26T09:37:28.180Z</updated>
    <content type="html"><![CDATA[<p>Go官方博客:<a href="https://go.dev/blog/execution-traces-2024" target="_blank" rel="external">More powerful Go execution traces</a> by Michael Knyszek.</p>
<a id="more"></a>
<p><a href="https://go.dev/pkg/runtime/trace" target="_blank" rel="external">runtime/trace包</a>包含了一个强大的工具,可用于理解和调试Go程序。该功能允许我们在一段时间内对每个goroutine的执行进行跟踪。使用<a href="https://go.dev/pkg/cmd/trace" target="_blank" rel="external">go tool trace命令</a>(或优秀的开源工具<a href="https://gotraceui.dev/" target="_blank" rel="external">gotraceui</a>),我们就可以可视化和探索这些跟踪数据。</p>
<p>跟踪的魔力在于,它可以轻松揭示程序中一些通过其他方式很难发现的问题。例如,大量goroutine在同一个channel上阻塞导致的并发瓶颈,在CPU分析中可能很难发现,因为没有执行(<code>execution</code>)需要采样。但在执行跟踪中,执行的缺失将被清晰地呈现,而阻塞goroutine的堆栈跟踪会快速指出问题所在。</p>
<p><img src="gotooltrace.png" alt=""></p>
<p>Go开发者甚至可以在自己的程序中使用<a href="https://go.dev/pkg/runtime/trace#Task" target="_blank" rel="external">Task</a>、<a href="https://go.dev/pkg/runtime/trace#WithRegion" target="_blank" rel="external">Region</a>和<a href="https://go.dev/pkg/runtime/trace#Log" target="_blank" rel="external">Log</a>进行检测,从而将他们关注的高级问题与低级执行细节联系起来。</p>
<h2 id="问题">问题</h2>
<p>不幸的是,执行跟踪中丰富的信息往往难以获取。历史上,以下四个主要问题一直阻碍着跟踪的使用:</p>
<ul>
<li>跟踪开销很高。</li>
<li>跟踪的扩展性差,分析时可能会变得太大。</li>
<li>通常难以确定何时开始跟踪以捕获特定的错误行为。</li>
<li>由于缺乏解析和解释执行跟踪的公共包,只有最勇敢的gopher才能以编程方式分析跟踪。</li>
</ul>
<p>如果你在过去几年使用过跟踪,可能会因上述一个或多个问题而感到沮丧。但我们很高兴地分享,在最近两个Go版本中,我们在这四个领域都取得了重大进展。</p>
<h2 id="低开销跟踪">低开销跟踪</h2>
<p>在Go 1.21之前,对许多应用程序而言,跟踪的运行时开销约在<strong>10-20%</strong>的CPU范围内,这限制了跟踪只能被选择性使用,而不能像<code>CPU profiling</code>那样持续使用。事实证明,跟踪的大部分成本归结于traceback(跟踪回溯，在计算机编程中，它通常指的是程序运行时发生错误或异常时，系统生成的调用栈信息，用于帮助开发者定位问题的源头。)。运行时产生的许多事件都附带了堆栈跟踪,这对于实际识别关键执行时刻goroutine的行为是非常有价值的。</p>
<p>感谢<strong>Felix Geisendörfer</strong>和<strong>Nick Ripley</strong>在优化traceback效率方面所做的工作,执行跟踪的运行时CPU开销已经显著降低,对许多应用程序而言,降至1-2%。你可以在Felix关于这个主题的<a href="https://blog.felixge.de/reducing-gos-execution-tracer-overhead-with-frame-pointer-unwinding/" target="_blank" rel="external">精彩博文</a>中阅读更多相关工作的细节。</p>
<h2 id="可扩展的跟踪">可扩展的跟踪</h2>
<p>跟踪格式及其事件的设计侧重于相对高效的发送,但需要工具来解析并维护整个跟踪的状态。分析数百MB的跟踪可能需要几GB的内存!</p>
<p>这个问题从根本上说是由于跟踪生成的方式造成的。为了保持运行时开销低,所有事件都被写入类似线程本地缓冲区。但这意味着事件出现的顺序与真实发生的顺序不一致,跟踪工具需要负担重任来弄清楚真正发生的情况。</p>
<p>在保持低开销的同时使跟踪可扩展的关键在于,偶尔分割正在生成的跟踪。每个分割点的行为有点像同时禁用和重新启用跟踪。到目前为止的所有跟踪数据代表一个完整且独立的跟踪,而新的跟踪数据将无缝地从中断处继续。</p>
<p>你可能已经想到,解决这个问题需要<a href="https://go.dev/issue/60773" target="_blank" rel="external">反思和重写运行时中跟踪实现的大量基础部分</a>。我们很高兴地说,这项工作在Go 1.22中完成并现已正式推出。<a href="https://go.dev/doc/go1.22#runtime/trace" target="_blank" rel="external">重写带来了许多良好的改进</a>,包括对go tool trace命令的一些改进。如果你有兴趣,所有详细内容都在<a href="https://github.com/golang/proposal/blob/master/design/60773-execution-tracer-overhaul.md" target="_blank" rel="external">设计文档</a>中。</p>
<p>(注:go tool trace仍会将整个跟踪加载到内存中,但对于由Go 1.22+程序生成的跟踪,<a href="https://go.dev/issue/65315" target="_blank" rel="external">移除此限制</a>现已变为可行。)</p>
<h2 id="飞行记录">飞行记录</h2>
<p>假设你在开发一个web服务,一个RPC花费了非常长的时间。当你意识到RPC已经运行很久时,你无法在那时开始跟踪,因为导致请求变慢的根本原因已经发生并且没有被记录下来。</p>
<p>有一种称为飞行记录(<code>flight recording</code>)的技术可以帮助解决这个问题,你可能已经在其他编程环境中接触过了。飞行记录的思路是持续开启跟踪,并一直保留最新的跟踪数据,以防万一。然后,一旦发生有趣的事情,程序就可以直接写出它所拥有的数据!</p>
<p>在可以分割跟踪之前,这基本上是行不通的。但由于低开销使得连续跟踪变得可行,而且现在运行时可以随时分割跟踪,因此实现飞行记录变得很直接。</p>
<p>因此,我们很高兴地宣布在<a href="https://go.dev/pkg/golang.org/x/exp/trace#FlightRecorder" target="_blank" rel="external">golang.org/x/exp/trace</a>包中提供了一个飞行记录器实验。</p>
<p>请尝试使用它!下面是一个设置飞行记录器来捕获长时间HTTP请求的示例,可以帮助你入门。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置飞行记录器</span></div><div class="line">fr := trace.NewFlightRecorder()</div><div class="line">fr.Start()</div><div class="line"></div><div class="line"><span class="comment">// 设置和运行HTTP服务器</span></div><div class="line"><span class="keyword">var</span> once sync.Once</div><div class="line">http.HandleFunc(<span class="string">"/my-endpoint"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    start := time.Now()</div><div class="line"></div><div class="line">    <span class="comment">// 干些事情</span></div><div class="line">    doWork(w, r)</div><div class="line"></div><div class="line">    <span class="comment">// 盼到了长耗时请求，来个快照</span></div><div class="line">    <span class="keyword">if</span> time.Since(start) &gt;<span class="number"> 300</span>*time.Millisecond {</div><div class="line">        <span class="comment">// 这里我们为了简化只做一次，实际上你可以做多次</span></div><div class="line">        once.Do(<span class="keyword">func</span>() {</div><div class="line">            <span class="comment">// 抓取快照</span></div><div class="line">            <span class="keyword">var</span> b bytes.Buffer</div><div class="line">            _, err = fr.WriteTo(&b)</div><div class="line">            <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                log.Print(err)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line">            <span class="comment">// 把快照写入文件</span></div><div class="line">            <span class="keyword">if</span> err := os.WriteFile(<span class="string">"trace.out"</span>, b.Bytes(),<span class="number"> 0</span>o755); err != <span class="constant">nil</span> {</div><div class="line">                log.Print(err)</div><div class="line">                <span class="keyword">return</span></div><div class="line">            }</div><div class="line">        })</div><div class="line">    }</div><div class="line">})</div><div class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>))</div></pre></td></tr></table></figure>

<p>果您有任何反馈，无论是正面的还是负面的，请分享到<a href="https://go.dev/issue/63185" target="_blank" rel="external">提案问题</a>中！</p>
<h2 id="跟踪读取器API">跟踪读取器API</h2>
<p>随着对跟踪实现的重写,我们也努力清理了其他的跟踪内部组件,比如go tool trace。这催生了一次尝试,目标是创建一个足够好的可共享跟踪读取器API,使跟踪更易于访问。</p>
<p>就像飞行记录器一样,我们很高兴地宣布,我们也有一个实验性的跟踪读取器API,希望能与大家分享。它与飞行记录器位于同一个包中,即<a href="https://go.dev/pkg/golang.org/x/exp/trace#Reader" target="_blank" rel="external">golang.org/x/exp/trace</a>。</p>
<p>我们认为它已经足够好,可以在此基础上构建东西了,所以请务必试用!下面是一个示例,它测量了由于等待网络而阻塞的goroutine阻塞事件的比例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始从标准输入读取跟踪数据。</span></div><div class="line">r, err := trace.NewReader(os.Stdin)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    log.Fatal(err)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> blocked <span class="typename">int</span></div><div class="line"><span class="keyword">var</span> blockedOnNetwork <span class="typename">int</span></div><div class="line"><span class="keyword">for</span> {</div><div class="line">    <span class="comment">// 读取事件</span></div><div class="line">    ev, err := r.ReadEvent()</div><div class="line">    <span class="keyword">if</span> err == io.EOF {</div><div class="line">        <span class="keyword">break</span></div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 处理它</span></div><div class="line">    <span class="keyword">if</span> ev.Kind() == trace.EventStateTransition {</div><div class="line">        st := ev.StateTransition()</div><div class="line">        <span class="keyword">if</span> st.Resource.Kind == trace.ResourceGoroutine {</div><div class="line">            id := st.Resource.Goroutine()</div><div class="line">            from, to := st.GoroutineTransition()</div><div class="line"></div><div class="line">            <span class="comment">// 查找阻塞的goroutine, 统计计数</span></div><div class="line">            <span class="keyword">if</span> from.Executing() && to == trace.GoWaiting {</div><div class="line">                blocked++</div><div class="line">                <span class="keyword">if</span> strings.Contains(st.Reason, <span class="string">"network"</span>) {</div><div class="line">                    blockedOnNetwork++</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// 打印我们所需</span></div><div class="line">p :=<span class="number"> 100</span> * <span class="typename">float64</span>(blockedOnNetwork) / <span class="typename">float64</span>(blocked)</div><div class="line">fmt.Printf(<span class="string">"%2.3f%% instances of goroutines blocking were to block on the network\n"</span>, p)</div></pre></td></tr></table></figure>

<p>就像飞行记录器一样,有一个<a href="https://go.dev/issue/62627" target="_blank" rel="external">提案问题</a>可以作为留下反馈的好地方!</p>
<p>我们想特别提及Dominik Honnef,他很早就试用了这个API,提供了宝贵的反馈,并为API贡献了对旧版本跟踪的支持。</p>
<h2 id="感谢!">感谢!</h2>
<p>这项工作能够完成,在很大程度上要感谢一年多前成立的<a href="https://go.dev/issue/57175" target="_blank" rel="external">诊断工作组</a>的帮助,该小组由来自Go社区各界的利益相关者组成,并向公众开放。</p>
<p>我们要借此机会感谢在过去一年中定期参加诊断会议的社区成员:Felix Geisendörfer、Nick Ripley、Rhys Hiltner、Dominik Honnef、Bryan Boreham和thepudds。</p>
<p>你们所做的讨论、反馈和工作是我们走到今天这一步的关键推动力。再次感谢!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go官方博客:<a href="https://go.dev/blog/execution-traces-2024" target="_blank" rel="external">More powerful Go execution traces</a> by Michael Knyszek.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="https://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
