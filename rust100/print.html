<!DOCTYPE HTML>
<html lang="zh_CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>100个练习题学习Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro/00_welcome.html"><strong aria-hidden="true">1.</strong> 欢迎</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_intro/01_syntax.html"><strong aria-hidden="true">1.1.</strong> 语法</a></li></ol></li><li class="chapter-item expanded "><a href="02_basic_calculator/00_intro.html"><strong aria-hidden="true">2.</strong> 一个简单的计算器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_basic_calculator/01_integers.html"><strong aria-hidden="true">2.1.</strong> 整数</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/02_variables.html"><strong aria-hidden="true">2.2.</strong> 变量</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/03_if_else.html"><strong aria-hidden="true">2.3.</strong> 分支: if/else</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/04_panics.html"><strong aria-hidden="true">2.4.</strong> Panic</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/05_factorial.html"><strong aria-hidden="true">2.5.</strong> 阶乘</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/06_while.html"><strong aria-hidden="true">2.6.</strong> 循环: while</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/07_for.html"><strong aria-hidden="true">2.7.</strong> 循环: for</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/08_overflow.html"><strong aria-hidden="true">2.8.</strong> 溢出</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/09_saturating.html"><strong aria-hidden="true">2.9.</strong> 饱和运算</a></li><li class="chapter-item expanded "><a href="02_basic_calculator/10_as_casting.html"><strong aria-hidden="true">2.10.</strong> 转换: as</a></li></ol></li><li class="chapter-item expanded "><a href="03_ticket_v1/00_intro.html"><strong aria-hidden="true">3.</strong> Ticket 第一版</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_ticket_v1/01_struct.html"><strong aria-hidden="true">3.1.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/02_validation.html"><strong aria-hidden="true">3.2.</strong> 校验</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/03_modules.html"><strong aria-hidden="true">3.3.</strong> 模块</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/04_visibility.html"><strong aria-hidden="true">3.4.</strong> 可见性</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/05_encapsulation.html"><strong aria-hidden="true">3.5.</strong> 封装</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/06_ownership.html"><strong aria-hidden="true">3.6.</strong> 所有权</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/07_setters.html"><strong aria-hidden="true">3.7.</strong> 设置器</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/08_stack.html"><strong aria-hidden="true">3.8.</strong> 栈</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/09_heap.html"><strong aria-hidden="true">3.9.</strong> 堆</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/10_references_in_memory.html"><strong aria-hidden="true">3.10.</strong> References in memory</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/11_destructor.html"><strong aria-hidden="true">3.11.</strong> 解构</a></li><li class="chapter-item expanded "><a href="03_ticket_v1/12_outro.html"><strong aria-hidden="true">3.12.</strong> 总结回顾</a></li></ol></li><li class="chapter-item expanded "><a href="04_traits/00_intro.html"><strong aria-hidden="true">4.</strong> Trait</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_traits/01_trait.html"><strong aria-hidden="true">4.1.</strong> 特性</a></li><li class="chapter-item expanded "><a href="04_traits/02_orphan_rule.html"><strong aria-hidden="true">4.2.</strong> 孤儿规则</a></li><li class="chapter-item expanded "><a href="04_traits/03_operator_overloading.html"><strong aria-hidden="true">4.3.</strong> 操作符重载</a></li><li class="chapter-item expanded "><a href="04_traits/04_derive.html"><strong aria-hidden="true">4.4.</strong> 派生宏</a></li><li class="chapter-item expanded "><a href="04_traits/05_str_slice.html"><strong aria-hidden="true">4.5.</strong> 字符串特性</a></li><li class="chapter-item expanded "><a href="04_traits/06_deref.html"><strong aria-hidden="true">4.6.</strong> Deref 特性</a></li><li class="chapter-item expanded "><a href="04_traits/07_sized.html"><strong aria-hidden="true">4.7.</strong> Sized 特性</a></li><li class="chapter-item expanded "><a href="04_traits/08_from.html"><strong aria-hidden="true">4.8.</strong> From 特性</a></li><li class="chapter-item expanded "><a href="04_traits/09_assoc_vs_generic.html"><strong aria-hidden="true">4.9.</strong> 关联类型和相关类型</a></li><li class="chapter-item expanded "><a href="04_traits/10_clone.html"><strong aria-hidden="true">4.10.</strong> Clone 特性</a></li><li class="chapter-item expanded "><a href="04_traits/11_copy.html"><strong aria-hidden="true">4.11.</strong> Copy 特性</a></li><li class="chapter-item expanded "><a href="04_traits/12_drop.html"><strong aria-hidden="true">4.12.</strong> Drop 特性</a></li><li class="chapter-item expanded "><a href="04_traits/13_outro.html"><strong aria-hidden="true">4.13.</strong> 总结回顾</a></li></ol></li><li class="chapter-item expanded "><a href="05_ticket_v2/00_intro.html"><strong aria-hidden="true">5.</strong> Ticket 第二版</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_ticket_v2/01_enum.html"><strong aria-hidden="true">5.1.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/02_match.html"><strong aria-hidden="true">5.2.</strong> 分支: match</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/03_variants_with_data.html"><strong aria-hidden="true">5.3.</strong> 持有数据的变体</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/04_if_let.html"><strong aria-hidden="true">5.4.</strong> 分支: if let 和 let/else</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/05_nullability.html"><strong aria-hidden="true">5.5.</strong> 空值处理</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/06_fallibility.html"><strong aria-hidden="true">5.6.</strong> 失败处理</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/07_unwrap.html"><strong aria-hidden="true">5.7.</strong> Unwrap</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/08_error_enums.html"><strong aria-hidden="true">5.8.</strong> Error 枚举</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/09_error_trait.html"><strong aria-hidden="true">5.9.</strong> Error 特性</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/10_packages.html"><strong aria-hidden="true">5.10.</strong> 包</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/11_dependencies.html"><strong aria-hidden="true">5.11.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/12_thiserror.html"><strong aria-hidden="true">5.12.</strong> thiserror</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/13_try_from.html"><strong aria-hidden="true">5.13.</strong> TryFrom 特性</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/14_source.html"><strong aria-hidden="true">5.14.</strong> Error::source</a></li><li class="chapter-item expanded "><a href="05_ticket_v2/15_outro.html"><strong aria-hidden="true">5.15.</strong> 总结回顾</a></li></ol></li><li class="chapter-item expanded "><a href="06_ticket_management/00_intro.html"><strong aria-hidden="true">6.</strong> Ticket 管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_ticket_management/01_arrays.html"><strong aria-hidden="true">6.1.</strong> 数组</a></li><li class="chapter-item expanded "><a href="06_ticket_management/02_vec.html"><strong aria-hidden="true">6.2.</strong> 动态数组 Vector</a></li><li class="chapter-item expanded "><a href="06_ticket_management/03_resizing.html"><strong aria-hidden="true">6.3.</strong> 调整大小</a></li><li class="chapter-item expanded "><a href="06_ticket_management/04_iterators.html"><strong aria-hidden="true">6.4.</strong> 迭代器</a></li><li class="chapter-item expanded "><a href="06_ticket_management/05_iter.html"><strong aria-hidden="true">6.5.</strong> Iter方法</a></li><li class="chapter-item expanded "><a href="06_ticket_management/06_lifetimes.html"><strong aria-hidden="true">6.6.</strong> 生命周期</a></li><li class="chapter-item expanded "><a href="06_ticket_management/07_combinators.html"><strong aria-hidden="true">6.7.</strong> 组合子</a></li><li class="chapter-item expanded "><a href="06_ticket_management/08_impl_trait.html"><strong aria-hidden="true">6.8.</strong> impl Trait 第一部分</a></li><li class="chapter-item expanded "><a href="06_ticket_management/09_impl_trait_2.html"><strong aria-hidden="true">6.9.</strong> impl Trait 第二部分</a></li><li class="chapter-item expanded "><a href="06_ticket_management/10_slices.html"><strong aria-hidden="true">6.10.</strong> 切片</a></li><li class="chapter-item expanded "><a href="06_ticket_management/11_mutable_slices.html"><strong aria-hidden="true">6.11.</strong> 可变切片</a></li><li class="chapter-item expanded "><a href="06_ticket_management/12_two_states.html"><strong aria-hidden="true">6.12.</strong> 两种状态</a></li><li class="chapter-item expanded "><a href="06_ticket_management/13_index.html"><strong aria-hidden="true">6.13.</strong> Index 特性</a></li><li class="chapter-item expanded "><a href="06_ticket_management/14_index_mut.html"><strong aria-hidden="true">6.14.</strong> IndexMut 特性</a></li><li class="chapter-item expanded "><a href="06_ticket_management/15_hashmap.html"><strong aria-hidden="true">6.15.</strong> HashMap</a></li><li class="chapter-item expanded "><a href="06_ticket_management/16_btreemap.html"><strong aria-hidden="true">6.16.</strong> BTreeMap</a></li></ol></li><li class="chapter-item expanded "><a href="07_threads/00_intro.html"><strong aria-hidden="true">7.</strong> 线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_threads/01_threads.html"><strong aria-hidden="true">7.1.</strong> 线程</a></li><li class="chapter-item expanded "><a href="07_threads/02_static.html"><strong aria-hidden="true">7.2.</strong> 'static 生命周期</a></li><li class="chapter-item expanded "><a href="07_threads/03_leak.html"><strong aria-hidden="true">7.3.</strong> 内存泄露</a></li><li class="chapter-item expanded "><a href="07_threads/04_scoped_threads.html"><strong aria-hidden="true">7.4.</strong> Scoped thread</a></li><li class="chapter-item expanded "><a href="07_threads/05_channels.html"><strong aria-hidden="true">7.5.</strong> 通道</a></li><li class="chapter-item expanded "><a href="07_threads/06_interior_mutability.html"><strong aria-hidden="true">7.6.</strong> 内部可变性</a></li><li class="chapter-item expanded "><a href="07_threads/07_ack.html"><strong aria-hidden="true">7.7.</strong> 双向通信</a></li><li class="chapter-item expanded "><a href="07_threads/08_client.html"><strong aria-hidden="true">7.8.</strong> 客户端</a></li><li class="chapter-item expanded "><a href="07_threads/09_bounded.html"><strong aria-hidden="true">7.9.</strong> 有界通道</a></li><li class="chapter-item expanded "><a href="07_threads/10_patch.html"><strong aria-hidden="true">7.10.</strong> 打补丁</a></li><li class="chapter-item expanded "><a href="07_threads/11_locks.html"><strong aria-hidden="true">7.11.</strong> Mutex, Send 和 Arc</a></li><li class="chapter-item expanded "><a href="07_threads/12_rw_lock.html"><strong aria-hidden="true">7.12.</strong> RwLock</a></li><li class="chapter-item expanded "><a href="07_threads/13_without_channels.html"><strong aria-hidden="true">7.13.</strong> 设计回顾</a></li><li class="chapter-item expanded "><a href="07_threads/14_sync.html"><strong aria-hidden="true">7.14.</strong> Sync 特性</a></li></ol></li><li class="chapter-item expanded "><a href="08_futures/00_intro.html"><strong aria-hidden="true">8.</strong> Future</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_futures/01_async_fn.html"><strong aria-hidden="true">8.1.</strong> 异步函数</a></li><li class="chapter-item expanded "><a href="08_futures/02_spawn.html"><strong aria-hidden="true">8.2.</strong> 创建任务</a></li><li class="chapter-item expanded "><a href="08_futures/03_runtime.html"><strong aria-hidden="true">8.3.</strong> 运行时</a></li><li class="chapter-item expanded "><a href="08_futures/04_future.html"><strong aria-hidden="true">8.4.</strong> Future 特性</a></li><li class="chapter-item expanded "><a href="08_futures/05_blocking.html"><strong aria-hidden="true">8.5.</strong> 阻塞运行时</a></li><li class="chapter-item expanded "><a href="08_futures/06_async_aware_primitives.html"><strong aria-hidden="true">8.6.</strong> Async-aware primitives</a></li><li class="chapter-item expanded "><a href="08_futures/07_cancellation.html"><strong aria-hidden="true">8.7.</strong> 取消</a></li><li class="chapter-item expanded "><a href="08_futures/08_outro.html"><strong aria-hidden="true">8.8.</strong> 总结回顾</a></li></ol></li><li class="chapter-item expanded "><a href="going_further.html"><strong aria-hidden="true">9.</strong> 更进一步学习</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">100个练习题学习Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/smallnest/100-exercises-to-learn-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div id="01_intro-00_welcome"></div><h1 id="01_intro-00_welcome-欢迎"><a class="header" href="#01_intro-00_welcome-欢迎">欢迎</a></h1>
<p>欢迎来到 <strong>“学习Rust的100个练习”</strong>！</p>
<p>本课程将通过每次一个练习的方式，教你Rust的核心概念。
你将学习Rust的语法、类型系统、标准库和生态系统。</p>
<p>我们不会假设你有任何Rust的先验知识，但我们假设你至少知道另一种编程语言。
我们同样不会假设你有任何系统编程或内存管理的先验知识。这些主题将在课程中涵盖。</p>
<p>换句话说，我们将从零开始！
你将通过小且可控的步骤逐步建立你的Rust知识。到课程结束时，你将解决大约100个练习，足以让你感觉能够舒适地处理小到中等规模的Rust项目。</p>
<h2 id="01_intro-00_welcome-方法论"><a class="header" href="#01_intro-00_welcome-方法论">方法论</a></h2>
<p>本课程基于“边做边学”的原则。
它被设计成互动且亲自动手的形式。</p>
<p><a href="https://mainmatter.com/rust-consulting/">Mainmatter</a> 开发了这门课程, 能够在四天内的课堂环境中进行授课：每位参与者按照自己的进度推进课程，由经验丰富的讲师提供指导，回答问题，并根据需要深入讨论主题。
如果你对我们的培训课程感兴趣，或者想将这门课程引入你的公司，请与我们联系。</p>
<p>你也可以自己跟随课程学习，但我们建议你找一个朋友或导师在遇到困难时帮助你。你也可以在GitHub仓库的<a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/solutions">solutions分支</a>中找到所有练习的解决方案。</p>
<p>这个课程的中文翻译由<a href="https://colobu.com/">鸟窝</a>完成，中文在线版可以访问 [<a href="https://colobu.com/rust100">rust100</a>](https://colobu.com/rust100)。</p>
<h2 id="01_intro-00_welcome-结构"><a class="header" href="#01_intro-00_welcome-结构">结构</a></h2>
<p>在屏幕的左侧，你可以看到课程被划分为多个章节。每个章节都会介绍Rust语言的一个新概念或特性。
为了检验你的理解程度，每个章节都配套有一个你需要完成的练习。</p>
<p>你可以在配套的<a href="https://github.com/mainmatter/100-exercises-to-learn-rust">GitHub仓库</a>中找到这些练习。
开始课程之前，请确保将仓库克隆到你的本地机器上：</p>
<pre><code class="language-shell"># 如果你已经为GitHub设置了SSH密钥
git clone git@github.com:mainmatter/100-exercises-to-learn-rust.git

# 否则，使用HTTPS链接：
git clone https://github.com/mainmatter/100-exercises-to-learn-rust.git
</code></pre>
<p>我们还建议你在分支上进行操作，这样可以轻松跟踪你的进度，并在需要时从主仓库拉取更新：</p>
<pre><code class="language-shell">cd 100-exercises-to-learn-rust
git checkout -b my-solutions
</code></pre>
<p>所有练习都位于<code>exercises</code>文件夹内。每个练习都被构建成一个Rust包的形式。这个包包含了练习本身、操作指南（位于<code>src/lib.rs</code>中）以及一套测试套件来自动验证你的解决方案。</p>
<h3 id="01_intro-00_welcome-workshop运行器-wr"><a class="header" href="#01_intro-00_welcome-workshop运行器-wr">Workshop运行器 wr</a></h3>
<p>为了验证你的答案，我们提供了一个工具，它将引导你完成整个课程。这就是wr命令行工具（全称为"workshop runner"）。通过以下命令安装：</p>
<pre><code class="language-shell">cargo install --locked workshop-runner
</code></pre>
<p>新开一个终端，回到仓库的顶层目录，运行<code>wr</code>命令以启动课程：</p>
<pre><code>wr
</code></pre>
<p><code>wr</code>会验证当前练习的解答。</p>
<p>在未解决当前章节的练习前，不要继续到下一章节。</p>
<blockquote>
<p>我们建议随着课程的进行，将你的解决方案提交到Git，这样可以方便地追踪进度，并在需要时“从已知点”重新开始。</p>
</blockquote>
<p>祝学习愉快！</p>
<h2 id="01_intro-00_welcome-参考"><a class="header" href="#01_intro-00_welcome-参考">参考</a></h2>
<p>本章节的练习位于<code>exercises/01_intro/00_welcome</code></p>
<h2 id="01_intro-00_welcome-作者"><a class="header" href="#01_intro-00_welcome-作者">作者</a></h2>
<p>本课程由<a href="https://mainmatter.com/rust-consulting/">Mainmatter</a>的首席工程顾问<a href="https://www.lpalmieri.com/">Luca Palmieri</a>编写。
Luca自2018年起就开始使用Rust，最初在TrueLayer公司工作，之后在AWS工作。
Luca是《从零到生产环境的Rust》一书的作者，这是学习如何用Rust构建后端应用的首选资源。
他也是多个开源Rust项目的作者和维护者，包括<code>cargo-chef</code>、<code>Pavex</code>和<code>wiremock</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="01_intro-01_syntax"></div><h1 id="01_intro-01_syntax-语法"><a class="header" href="#01_intro-01_syntax-语法">语法</a></h1>
<div class="warning">
<p>别跳过哦!<br />
在开始这一部分之前,请先完成上一部分的练习。
它位于<a href="https://github.com/mainmatter/100-exercises-to-learn-rust">课程GitHub仓库</a>中的<code>exercises/01_intro/00_welcome</code>。<br />
使用<a href="#01_intro-00_welcome-wr-the-workshop-runner"><code>wr</code></a>来开始课程并验证你的解决方案。</p>
</div>
<p>前一个任务甚至都不算是一个练习,但它已经让你接触到了不少Rust的<strong>语法</strong>。
我们不会涵盖之前练习中使用的每一个Rust语法细节。
相反,我们会涵盖<strong>足够的</strong>内容,以便继续前进而不会陷入细节中。
一步一步来!</p>
<h2 id="01_intro-01_syntax-注释"><a class="header" href="#01_intro-01_syntax-注释">注释</a></h2>
<p>你可以使用<code>//</code>来编写单行注释:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这是一行单行注释
// 后面跟着另一行单行注释
<span class="boring">}</span></code></pre></pre>
<h2 id="01_intro-01_syntax-函数"><a class="header" href="#01_intro-01_syntax-函数">函数</a></h2>
<p>Rust中的函数使用fn关键字定义,后面跟着函数名称、输入参数和返回类型。
函数体用大括号{}括起来。
在前一个练习中,你看到了greeting函数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `fn` &lt;function_name&gt; ( &lt;input parameters&gt; ) -&gt; &lt;return_type&gt; { &lt;body&gt; }
fn greeting() -&gt; &amp;'static str {
    // TODO: fix me 👇
    "I'm ready to __!"
}
<span class="boring">}</span></code></pre></pre>
<p><code>greeting</code>没有输入参数,返回一个字符串切片引用<code>(&amp;'static str)</code>。</p>
<h3 id="01_intro-01_syntax-返回类型"><a class="header" href="#01_intro-01_syntax-返回类型">返回类型</a></h3>
<p>如果函数不返回任何值(即返回Rust的单元类型())的话,返回类型可以从签名中省略。
这就是test_welcome函数的情况:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_welcome() {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<p>上述代码等同于:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 显式地写出单元返回类型
//                   👇
fn test_welcome() -&gt; () {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="01_intro-01_syntax-返回值"><a class="header" href="#01_intro-01_syntax-返回值">返回值</a></h3>
<p>函数中的最后一个表达式会被隐式地返回:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // 这是函数中的最后一个表达式
    // 因此它的值会被`greeting`返回
    "I'm ready to learn Rust!"
}
<span class="boring">}</span></code></pre></pre>
<p>你也可以使用<code>return</code>关键字提前返回一个值:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeting() -&gt; &amp;'static str {
    // 注意行尾的分号!
    return "I'm ready to learn Rust!";
}
<span class="boring">}</span></code></pre></pre>
<p>当可能时,省略<code>return</code>关键字被认为是惯用的写法。</p>
<h3 id="01_intro-01_syntax-输入参数"><a class="header" href="#01_intro-01_syntax-输入参数">输入参数</a></h3>
<p>输入参数在函数名后面的括号<code>()</code>内声明。
每个参数都用其名称、一个冒号<code>:</code>和它的类型来声明。
例如,下面的<code>greet</code>函数接受一个类型为<code>&amp;str</code>(字符串切片)的<code>name</code>参数:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个输入参数
//        👇
fn greet(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}
<span class="boring">}</span></code></pre></pre>
<p>如果有多个输入参数,它们必须用逗号分隔开。</p>
<h3 id="01_intro-01_syntax-类型注解"><a class="header" href="#01_intro-01_syntax-类型注解">类型注解</a></h3>
<p>既然我们已经提到了"类型"几次,让我们明确一下:Rust是一种<strong>静态类型语言</strong>。
Rust中的每个值都有一个类型,并且该类型在编译时必须为编译器所知。</p>
<p>类型是一种<strong>静态分析</strong>的形式。</p>
<p>你可以将类型看作是编译器附加在你程序中每个值上的<strong>标签</strong>。根据这个标签,编译器可以强制执行不同的规则——例如,你不能将一个字符串加到一个数字上,但你可以将两个数字相加。</p>
<p>如果使用正确,类型可以防止整个类别的运行时错误。</p>
<h2 id="01_intro-01_syntax-参考资料"><a class="header" href="#01_intro-01_syntax-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/01_intro/01_syntax</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-00_intro"></div><h1 id="02_basic_calculator-00_intro-一个基本计算器"><a class="header" href="#02_basic_calculator-00_intro-一个基本计算器">一个基本计算器</a></h1>
<p>在本章中,我们将学习如何将Rust用作<strong>计算器</strong>。这可能听起来没什么大不了的,但它将让我们有机会涵盖Rust的许多基础知识,例如:</p>
<ul>
<li>如何定义和调用函数</li>
<li>如何声明和使用变量</li>
<li>基本类型(整数和布尔值)</li>
<li>算术运算符(包括上溢和下溢行为)</li>
<li>比较运算符</li>
<li>控制流</li>
<li>异常</li>
</ul>
<p>通过几个练习掌握基础知识,语言就会在你的手指下流畅运行。当我们继续讨论更复杂的主题时,例如特征和所有权,你将能够专注于新概念,而不会被语法或其他琐碎的细节拖累。</p>
<h2 id="02_basic_calculator-00_intro-参考资料"><a class="header" href="#02_basic_calculator-00_intro-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于<code>exercises/02_basic_calculator/00_intro</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-01_integers"></div><h1 id="02_basic_calculator-01_integers-类型第1部分"><a class="header" href="#02_basic_calculator-01_integers-类型第1部分">类型,第1部分</a></h1>
<p>在<a href="#01_intro-01_syntax">"语法"部分</a>中,<code>compute</code>的输入参数类型为 <code>u32</code>。让我们来解开这个是什么意思。</p>
<h2 id="02_basic_calculator-01_integers-基本类型"><a class="header" href="#02_basic_calculator-01_integers-基本类型">基本类型</a></h2>
<p><code>u32</code>是Rust的<strong>基本类型</strong>之一。基本类型是语言最基本的构建模块。它们内置于语言本身中——也就是说,它们不是由其他类型定义的。</p>
<p>你可以组合这些基本类型来创建更复杂的类型。我们很快就会看到怎么做。</p>
<h2 id="02_basic_calculator-01_integers-整数"><a class="header" href="#02_basic_calculator-01_integers-整数">整数</a></h2>
<p>具体来说,<code>u32</code>是一个<strong>无符号32位整数</strong>。</p>
<p>整数是一个不包含小数部分的数字。例如,<code>1</code>是一个整数,而<code>1.2</code>不是。</p>
<h3 id="02_basic_calculator-01_integers-有符号与无符号"><a class="header" href="#02_basic_calculator-01_integers-有符号与无符号">有符号与无符号</a></h3>
<p>整数可以是<strong>有符号</strong>或<strong>无符号</strong>的。无符号整数只能表示非负数(即<code>0</code>或更大)。有符号整数可以表示正数和负数(例如<code>-1</code>、<code>12</code>等)。</p>
<p><code>u32</code>中的<code>u</code>代表<strong>无符号</strong>。等效的有符号整数类型是<code>i32</code>,其中<code>i</code>代表整数(即任何整数,正数或负数)。</p>
<h3 id="02_basic_calculator-01_integers-位宽"><a class="header" href="#02_basic_calculator-01_integers-位宽">位宽</a></h3>
<p><code>u32</code>中的<code>32</code>是指用于在内存中表示该数字的<strong>位数<sup class="footnote-reference"><a href="#02_basic_calculator-01_integers-bit">1</a></sup></strong>。位数越多,可以表示的数字范围就越大。</p>
<p>Rust支持多个位宽的整数:<code>8</code>、<code>16</code>、<code>32</code>、<code>64</code>、<code>128</code>。</p>
<p>用32位,<code>u32</code>可以表示从<code>0</code>到<code>2^32 - 1</code>(又称<a href="https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX"><code>u32::MAX</code></a>)的数字。
用相同的位数,有符号整数(<code>i32</code>)可以表示从<code>-2^31</code>到<code>2^31 - 1</code>的数字(即从<a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN"><code>i32::MIN</code></a>到<a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX"><code>i32::MAX</code></a>)。
<code>i32</code>的最大值小于<code>u32</code>的最大值,因为一个位用于表示数字的符号。
更多关于有符号整数在内存中是如何表示的详细信息,请查看<a href="https://en.wikipedia.org/wiki/Two%27s_complement">二补码</a>表示。</p>
<h3 id="02_basic_calculator-01_integers-总结"><a class="header" href="#02_basic_calculator-01_integers-总结">总结</a></h3>
<p>将有符号/无符号和位宽两个变量结合,我们得到以下整数类型:</p>
<div class="table-wrapper"><table><thead><tr><th>位宽</th><th>有符号</th><th>无符号</th></tr></thead><tbody>
<tr><td>8位</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16位</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32位</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64位</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128位</td><td><code>i128</code></td><td><code>u128</code></td></tr>
</tbody></table>
</div>
<h2 id="02_basic_calculator-01_integers-字面值"><a class="header" href="#02_basic_calculator-01_integers-字面值">字面值</a></h2>
<p><strong>字面值</strong>是在源代码中表示固定值的符号。例如,<code>42</code>是Rust中表示四十二这个数字的字面值。</p>
<h3 id="02_basic_calculator-01_integers-字面值的类型注解"><a class="header" href="#02_basic_calculator-01_integers-字面值的类型注解">字面值的类型注解</a></h3>
<p>但是Rust中所有值都有类型,所以...<code>42</code>是什么类型呢?</p>
<p>Rust编译器会尝试根据使用环境来推断字面值的类型。如果你不提供任何上下文信息,编译器将默认为<code>i32</code>整数字面值。如果你想使用其他类型,你可以在字面值后面添加所需的整数类型作为后缀——例如<code>2u64</code>表示一个显式声明为<code>u64</code>类型的2。</p>
<h3 id="02_basic_calculator-01_integers-字面值中的下划线"><a class="header" href="#02_basic_calculator-01_integers-字面值中的下划线">字面值中的下划线</a></h3>
<p>你可以使用下划线<code>_</code>来提高大数字的可读性。例如,<code>1_000_000</code>和<code>1000000</code>是相同的。</p>
<h2 id="02_basic_calculator-01_integers-算术运算符"><a class="header" href="#02_basic_calculator-01_integers-算术运算符">算术运算符</a></h2>
<p>Rust支持以下用于整数的算术运算符<sup class="footnote-reference"><a href="#02_basic_calculator-01_integers-traits">2</a></sup>:</p>
<ul>
<li><code>+</code>用于加法</li>
<li><code>-</code>用于减法</li>
<li><code>*</code>用于乘法</li>
<li><code>/</code>用于除法</li>
<li><code>%</code>用于取余</li>
</ul>
<p>这些运算符的优先级和结合性规则与数学中的相同。你可以使用括号来覆盖默认的优先级,例如<code>2 * (3 + 4)</code>。</p>
<blockquote>
<p>⚠️ <strong>警告</strong></p>
<p>当用于整数类型时,除法运算符<code>/</code>执行整数除法。 换句话说,结果会被截断为0。例如,<code>5 / 2</code>的结果是<code>2</code>,而不是<code>2.5</code>。</p>
</blockquote>
<h2 id="02_basic_calculator-01_integers-没有自动类型强制转换"><a class="header" href="#02_basic_calculator-01_integers-没有自动类型强制转换">没有自动类型强制转换</a></h2>
<p>正如我们在上一个练习中讨论的,Rust是一种静态类型语言。具体来说,Rust对类型强制转换非常严格。即使转换是无损的,它也不会自动将一个值从一种类型转换为另一种类型<sup class="footnote-reference"><a href="#02_basic_calculator-01_integers-coercion">3</a></sup>,你必须显式地进行转换。</p>
<p>例如,你不能将一个<code>u8</code>值赋给类型为<code>u32</code>的变量,即使所有的<code>u8</code>值都是有效的<code>u32</code>值:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: u8 = 100;
let a: u32 = b;
<span class="boring">}</span></code></pre></pre>
<p>它会抛出编译错误:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
</code></pre>
<p>我们将在本课程的<a href="#04_traits-08_from">后面</a>看到如何在不同类型之间进行转换。</p>
<h2 id="02_basic_calculator-01_integers-参考资料"><a class="header" href="#02_basic_calculator-01_integers-参考资料">参考资料</a></h2>
<p>本节的练习位于 <code>exercises/02_basic_calculator/01_integers</code></p>
<h2 id="02_basic_calculator-01_integers-进一步阅读"><a class="header" href="#02_basic_calculator-01_integers-进一步阅读">进一步阅读</a></h2>
<p>好的,以下是这些内容的翻译:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">官方Rust书籍中的整数类型部分</a></li>
</ul>
<div class="footnote-definition" id="02_basic_calculator-01_integers-bit"><sup class="footnote-definition-label">1</sup>
<p>位是计算机中最小的数据单位。它只能有两个值:0或1。</p>
</div>
<div class="footnote-definition" id="02_basic_calculator-01_integers-traits"><sup class="footnote-definition-label">2</sup>
<p>Rust不允许你定义自定义运算符,但它让你可以控制内置运算符的行为。在我们讨论了特征之后,将会在本课程的后面讨论运算符重载。</p>
</div>
<div class="footnote-definition" id="02_basic_calculator-01_integers-coercion"><sup class="footnote-definition-label">3</sup>
<p>对于这个规则也有一些例外,主要与引用、智能指针和人体工程学有关。我们将<a href="#02_basic_calculator-(..-04_traits-06_deref)">稍后</a>介绍这些内容。目前,"所有转换都是显式的"这个心智模型将为你提供很好的服务。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-02_variables"></div><h1 id="02_basic_calculator-02_variables-变量"><a class="header" href="#02_basic_calculator-02_variables-变量">变量</a></h1>
<p>在 Rust 中，你可以使用 <code>let</code> 关键字来声明<strong>变量</strong>。<br />
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
<span class="boring">}</span></code></pre></pre>
<p>上面我们定义了一个变量 <code>x</code> 并给它赋值为 <code>42</code>。</p>
<h2 id="02_basic_calculator-02_variables-类型"><a class="header" href="#02_basic_calculator-02_variables-类型">类型</a></h2>
<p>Rust 中的每个变量都必须具有一个类型，这个类型可以由编译器推断定，或者由开发者显式指定。</p>
<h3 id="02_basic_calculator-02_variables-显式类型标注"><a class="header" href="#02_basic_calculator-02_variables-显式类型标注">显式类型标注</a></h3>
<p>你可以通过在变量名后加上 <code>:</code> 再跟上类型的方式来指定变量的类型。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let &lt;variable_name&gt;: &lt;type&gt; = &lt;expression&gt;;
let x: u32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>在上述示例中，我们明确地将 <code>x</code> 的类型约束为 <code>u32</code>。</p>
<h3 id="02_basic_calculator-02_variables-类型推断"><a class="header" href="#02_basic_calculator-02_variables-类型推断">类型推断</a></h3>
<p>如果我们不指定变量的类型，编译器会根据变量使用的上下文尝试推断其类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let y: u32 = x;
<span class="boring">}</span></code></pre></pre>
<p>在上面的例子中，我们没有指定 <code>x</code> 的类型。</p>
<p>由于 <code>x</code> 被赋给了显式类型为 <code>u32</code> 的 <code>y</code>，且 Rust 不会自动类型转换，编译器因此推断定 <code>x</code> 的类型为 <code>u32</code> —— 和 <code>y</code> 的类型一致，这样才能保证程序编译不报错。</p>
<h3 id="02_basic_calculator-02_variables-推断限制"><a class="header" href="#02_basic_calculator-02_variables-推断限制">推断限制</a></h3>
<p>有时编译器需要一些辅助信息来基于变量的使用情况推断正确的类型。</p>
<p>这种情况下，你会遇到编译错误，编译器会要求你提供显式类型提示以消除歧义。</p>
<h2 id="02_basic_calculator-02_variables-函数参数也是变量"><a class="header" href="#02_basic_calculator-02_variables-函数参数也是变量">函数参数也是变量</a></h2>
<p>不是所有英雄都穿披风衣，也不是所有变量都用 <code>let</code>声明。</p>
<p>函数参数也是变量！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one(x: u32) -&gt; u32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>在上述示例中，<code>x</code> 是类型为 <code>u32</code> 的变量。</p>
<p><code>x</code> 和用 <code>let</code> 声明的变量唯一区别在于，函数参数<strong>必须</strong>显式*声明类型。编译器不会为你推断。</p>
<p>这一约束使得 Rust 编译器（以及我们人类！）能在不看实现细节的情况下理解函数的签名，大大提升了编译速度<sup class="footnote-reference"><a href="#02_basic_calculator-02_variables-speed">1</a></sup>！</p>
<h2 id="02_basic_calculator-02_variables-初始化"><a class="header" href="#02_basic_calculator-02_variables-初始化">初始化</a></h2>
<p>声明变量时不必立即初始化。</p>
<p>例如:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
<span class="boring">}</span></code></pre></pre>
<p>是一个有效的变量声明。</p>
<p>但是，在使用变量之前必须初始化它。否则编译器会报错：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32;
let y = x + 1;
<span class="boring">}</span></code></pre></pre>
<p>会导致编译错误：</p>
<pre><code class="language-text">error[E0381]: used binding `x` isn't initialized
 --&gt; src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
</code></pre>
<h2 id="02_basic_calculator-02_variables-参考"><a class="header" href="#02_basic_calculator-02_variables-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/02_basic_calculator/02_variables</code></li>
</ul>
<div class="footnote-definition" id="02_basic_calculator-02_variables-speed"><sup class="footnote-definition-label">1</sup>
<p>Rust 编译器在提升编译速度方面需要一切可能的帮助。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-03_if_else"></div><h1 id="02_basic_calculator-03_if_else-控制制流第一部分"><a class="header" href="#02_basic_calculator-03_if_else-控制制流第一部分">控制制流，第一部分</a></h1>
<p>迄今为止，我们的所有程序都相当直接。</p>
<p>一系列指令自上而下执行，仅此而已。</p>
<p>现在是引入<strong>分支</strong>的时候了。</p>
<h2 id="02_basic_calculator-03_if_else-if-表达式"><a class="header" href="#02_basic_calculator-03_if_else-if-表达式"><code>if</code> 表达式</a></h2>
<p><code>if</code> 关键字用于仅在条件为真时执行一段代码。</p>
<p>这里有个简单示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number &lt; 5 {
    println!("`number` 小于5");
}
<span class="boring">}</span></code></pre></pre>
<p>此程序会打印 <code>number 小于5</code>，因为条件 <code>number &lt; 5</code> 为真。</p>
<p>与多数编程语言一样，Rust 支持可选的 <code>else</code> 分支，在 <code>if</code> 表达式中的条件为假时执行代码块。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;

if number &lt; 5 {
    println!("`number` 小于5");
} else {
    println!("`number` 大于或等于5");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="02_basic_calculator-03_if_else-布尔值"><a class="header" href="#02_basic_calculator-03_if_else-布尔值">布尔值</a></h2>
<p><code>if</code> 表达式中的条件必须为类型 <code>bool</code>，即布尔值。</p>
<p>布尔值，与整数一样，在 Rust 中是原始类型。</p>
<p>布尔值有两个可能：<code>true</code> 或 <code>false</code>。</p>
<h3 id="02_basic_calculator-03_if_else-真值与非真值"><a class="header" href="#02_basic_calculator-03_if_else-真值与非真值">真值与非真值</a></h3>
<p>如果 <code>if</code> 表达式中的条件不是布尔值，你会遇到编译错误。</p>
<p>例如，以下代码无法编译：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;
if number {
    println!("`number` 不为零");
}
<span class="boring">}</span></code></pre></pre>
<p>你会得到以下编译错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:8
  |
3 |     if number {
  |        ^^^^^^ expected `bool`, found integer
</code></pre>
<p>这源自 Rust 的类型强制哲学：不存在从非布尔类型到布尔类型的自动转换。
不像JavaScript 或 Python， Rust 不具备 <code>真值</code> 或 <code>假值</code> 的概念。
你需要明确你想检查的条件。</p>
<h2 id="02_basic_calculator-03_if_else-比较运算符"><a class="header" href="#02_basic_calculator-03_if_else-比较运算符">比较运算符</a></h2>
<p>使用比较运算符构建if 表达式的条件非常常见。
在处理整数时，Rust 提供以下比较运算符：</p>
<ul>
<li><code>==</code>：等于</li>
<li><code>!=</code>：不等于</li>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;=</code>：小于或等于</li>
<li><code>&gt;=</code>：大于或等于</li>
</ul>
<h2 id="02_basic_calculator-03_if_else-参考"><a class="header" href="#02_basic_calculator-03_if_else-参考">参考</a></h2>
<p>本节练习位于 <code>exercises/02_basic_calculator/03_if_else</code></p>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-04_panics"></div><h1 id="02_basic_calculator-04_panics-panic-恐慌"><a class="header" href="#02_basic_calculator-04_panics-panic-恐慌">Panic 恐慌</a></h1>
<p>让我们回顾一下在<a href="#02_basic_calculator-(..-02_variables-readme">“变量”</a>章节中编写的 <code>speed</code> 函数。大概像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn speed(start: u32, end: u32, time_elapsed: u32) -&gt; u32 {
    let distance = end - start;
    distance / time_elapsed
}
<span class="boring">}</span></code></pre></pre>
<p>如果你观察细致的话，可能会发现一个问题<sup class="footnote-reference"><a href="#02_basic_calculator-04_panics-one">1</a></sup>：如果 <code>time_elapsed </code>为零怎么办？</p>
<p>你可以在<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=36e5ddbe3b3f741dfa9f74c956622bac">Rust playground</a>上试一试。程序会以以下错误退出：</p>
<pre><code class="language-text">thread 'main' panicked at src/main.rs:3:5:
attempt to divide by zero
</code></pre>
<p>这就是所谓的<strong>panic</strong>。</p>
<p><strong>panic</strong>是Rust表明出现了严重错误，程序无法继续执行，是不可恢复的错误<sup class="footnote-reference"><a href="#02_basic_calculator-04_panics-catching">2</a></sup>。除以零属于这类错误。</p>
<h2 id="02_basic_calculator-04_panics-panic-宏"><a class="header" href="#02_basic_calculator-04_panics-panic-宏">panic! 宏</a></h2>
<p>你可以通过调用 <code>panic!</code> 宏<sup class="footnote-reference"><a href="#02_basic_calculator-04_panics-macro">3</a></sup>故意触发恐慌:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!("This is a panic!");
    // The line below will never be executed
    let x = 1 + 2;
}</code></pre></pre>
<p>Rust 还有其他处理可恢复错误的机制，我们将在稍后<a href="#02_basic_calculator-(..-05_ticket_v2-06_fallibility)">讨论</a>。
目前，我们将使用恐慌作为简单但直接的临时解决方案。</p>
<h2 id="02_basic_calculator-04_panics-参考"><a class="header" href="#02_basic_calculator-04_panics-参考">参考</a></h2>
<p>本节练习位于 <code>exercises/02_basic_calculator/04_panics</code></p>
<h2 id="02_basic_calculator-04_panics-深入一步阅读"><a class="header" href="#02_basic_calculator-04_panics-深入一步阅读">深入一步阅读</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.panic.html">panic! 宏</a></li>
</ul>
<div class="footnote-definition" id="02_basic_calculator-04_panics-one"><sup class="footnote-definition-label">1</sup>
<p><code>speed</code> 还有另一个问题，我们很快会解决。你能发现吗？</p>
</div>
<div class="footnote-definition" id="02_basic_calculator-04_panics-catching"><sup class="footnote-definition-label">2</sup>
<p>你可以尝试捕获恐慌，但这应作为最后的手段，仅保留于特定情况。</p>
</div>
<div class="footnote-definition" id="02_basic_calculator-04_panics-macro"><sup class="footnote-definition-label">3</sup>
<p>如果后面跟着 <code>!</code>，那便是宏的调用法。目前可以把宏想象为加了调料的函数。我们将在课程后面更深入地讲解它们。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-05_factorial"></div><h1 id="02_basic_calculator-05_factorial-阶乘"><a class="header" href="#02_basic_calculator-05_factorial-阶乘">阶乘</a></h1>
<p>迄今为止，你已经学到了：</p>
<ul>
<li>如何定义函数</li>
<li>如何调用函数</li>
<li>Rust 中有哪些整数类型可用</li>
<li>整数运算提供了哪些算术操作符</li>
<li>如何通过比较和 if/else 表达式来执行条件逻辑</li>
</ul>
<p>看来你已经准备好应对阶乘啦！</p>
<h2 id="02_basic_calculator-05_factorial-参考资料"><a class="header" href="#02_basic_calculator-05_factorial-参考资料">参考资料</a></h2>
<p>本节练习位于 <code>exercises/02_basic_calculator/05_factorial</code></p>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-06_while"></div><h1 id="02_basic_calculator-06_while-循环第一部分while"><a class="header" href="#02_basic_calculator-06_while-循环第一部分while">循环，第一部分：<code>while</code></a></h1>
<p>你的阶乘实现被迫采用了递归方法。</p>
<p>如果你来自函数式编程背景，这对你来说可能感觉很自然。或者，如果你习惯了C或Python这样的命令式语言，这可能会觉得有些奇怪。</p>
<p>让我们看看如何使用循环来实现相同的功能。</p>
<h2 id="02_basic_calculator-06_while-while-循环"><a class="header" href="#02_basic_calculator-06_while-while-循环"><code>while</code> 循环</a></h2>
<p>while``循环是一种在条件为真时执行代码块的方法。</p>
<p>一般语法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while &lt;condition&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<p>例如，我们可能想计算1到5的数字之和：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 0;
let i = 1;
// "while i is less than or equal to 5"
while i &lt;= 5 {
    // `+=` is a shorthand for `sum = sum + i`
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>这会持续将1加到<code>sum</code>上，直到<code>i</code>不再小于或等于<code>5</code>为止。</p>
<h2 id="02_basic_calculator-06_while-mut-关键字"><a class="header" href="#02_basic_calculator-06_while-mut-关键字"><code>mut</code> 关键字</a></h2>
<p>上面的例子直接放在这里是不会编译的。你会得到一个错误，类似于：</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `sum`
 --&gt; src/main.rs:7:9
  |
2 |     let sum = 0;
  |         ---
  |         |
  |         first assignment to `sum`
  |         help: consider making this binding mutable: `mut sum`
...
7 |         sum += i;
  |         ^^^^^^^^ cannot assign twice to immutable variable

error[E0384]: cannot assign twice to immutable variable `i`
 --&gt; src/main.rs:8:9
  |
3 |     let i = 1;
  |         -
  |         |
  |         first assignment to `i`
  |         help: consider making this binding mutable: `mut i`
...
8 |         i += 1;
  |         ^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>这是因为Rust中的变量默认是<strong>不可变</strong>的。</p>
<p>一旦<strong>赋值</strong>后，就不能改变其值。</p>
<p>如果你想允许修改，就需要使用<code>mut</code>关键字声明变量为可变：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `sum` and `i` are mutable now!
let mut sum = 0;
let mut i = 1;

while i &lt;= 5 {
    sum += i;
    i += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>这样就能正常编译和运行了。</p>
<h2 id="02_basic_calculator-06_while-参考资料"><a class="header" href="#02_basic_calculator-06_while-参考资料">参考资料</a></h2>
<p>本节练习位于 <code>exercises/02_basic_calculator/06_while</code></p>
<h2 id="02_basic_calculator-06_while-进一步阅读"><a class="header" href="#02_basic_calculator-06_while-进一步阅读">进一步阅读</a></h2>
<p><a href="#02_basic_calculator-(https:-doc.rust-lang.org-std-keyword.while">关于while循环的文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-07_for"></div><h1 id="02_basic_calculator-07_for-循环第二部分for"><a class="header" href="#02_basic_calculator-07_for-循环第二部分for">循环，第二部分：<code>for</code></a></h1>
<p>手动递增计数器变量略显繁琐，而且这种模式极为普遍！为了简化这一过程，Rust提供了一种更简洁的方式来遍历一系列值：<code>for</code>循环。</p>
<h2 id="02_basic_calculator-07_for-for循环"><a class="header" href="#02_basic_calculator-07_for-for循环">for循环</a></h2>
<p>for循环是一种针对迭代器<sup class="footnote-reference"><a href="#02_basic_calculator-07_for-iterator">1</a></sup>中每个元素执行代码块的方式1。</p>
<p>基本语法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for &lt;element&gt; in &lt;iterator&gt; {
    // code to execute
}
<span class="boring">}</span></code></pre></pre>
<h2 id="02_basic_calculator-07_for-区间"><a class="header" href="#02_basic_calculator-07_for-区间">区间</a></h2>
<p>Rust的标准库提供了<strong>区间类型</strong>，可用于遍历一系列数字<sup class="footnote-reference"><a href="#02_basic_calculator-07_for-weird-ranges">2</a></sup>。</p>
<p>例如，如果我们想计算1到5的数字之和：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..=5 {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<p>每次循环运行时，<code>i</code>都会被赋予区间的下一个值，然后执行代码块。</p>
<p>Rust中有五种类型的区间：</p>
<ul>
<li><code>1..5</code>：半开区间。包含从1到4的所有数字。不包括最后一个值，即5。</li>
<li><code>1..=5</code>：包含结束值的区间。包含从1到5的所有数字，包括最后一个值，即5。</li>
<li><code>1..</code>：开放式区间。从1开始，理论上到整数最大值的所有数字（实际上是直到整数类型的上限）。</li>
<li><code>..5</code>：从整数类型的最小值开始，到4的所有数字。不包括最后一个值，即5。</li>
<li><code>..=5</code>：从整数类型的最小值开始，到5的所有数字。包括最后一个值，即5。</li>
</ul>
<p>你可以使用<code>for</code>循环配合前三种区间，其中起始点是明确指定的。最后两种区间类型则用于其他情境，我们将在后续学习中覆盖。</p>
<p>区间的极端值不必是整数字面量——它们也可以是变量或表达式！</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end = 5;
let mut sum = 0;

for i in 1..(end + 1) {
    sum += i;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="02_basic_calculator-07_for-参考资料"><a class="header" href="#02_basic_calculator-07_for-参考资料">参考资料</a></h2>
<p>本节练习位于 <code>exercises/02_basic_calculator/07_for</code></p>
<h2 id="02_basic_calculator-07_for-进一步阅读"><a class="header" href="#02_basic_calculator-07_for-进一步阅读">进一步阅读</a></h2>
<p><a href="https://doc.rust-lang.org/std/keyword.for.html?spm=5176.28103460.0.0.297c3da2Vss4UV">关于for循环的文档</a></p>
<div class="footnote-definition" id="02_basic_calculator-07_for-iterator"><sup class="footnote-definition-label">1</sup>
<p>在课程后期，我们将给出“迭代器”的精确定义。目前，可以将其理解为一个你可以遍历的值序列。</p>
</div>
<div class="footnote-definition" id="02_basic_calculator-07_for-weird-ranges"><sup class="footnote-definition-label">2</sup>
<p>区间也可以与其他类型一起使用（比如字符和IP地址），但在日常的Rust编程中，整数无疑是最常见的应用场景。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-08_overflow"></div><h1 id="02_basic_calculator-08_overflow-溢出"><a class="header" href="#02_basic_calculator-08_overflow-溢出">溢出</a></h1>
<p>一个数的阶乘增长速度相当快。例如，20的阶乘是2,432,902,008,176,640,000，这已经超过了32位整数的最大值2,147,483,647。</p>
<p>当算术操作的结果超过给定整数类型的极限值时，我们就遇到了<strong>整数溢出</strong>的问题。</p>
<p>整数溢出是个问题，因为它违背了算术操作的约定。两个特定类型整数之间的算术操作结果应该还是同类型的另一个整数。但数学上正确的结果却超出了那个整数类型能表示的范围！</p>
<blockquote>
<p>如果结果小于给定整数类型的最小值，我们称其为<strong>整数下溢</strong>。<br />
为了简洁，本节余下的部分我们将只讨论整数溢出，但请记住，我们所说的一切同样适用于整数下溢。</p>
<p>你在<a href="#02_basic_calculator-02_variables">"变量"部分</a>编写的<code>speed</code>函数在某些输入组合下发生了下溢。<br />
例如，如果<code>end</code>小于<code>start</code>，那么<code>end - start</code>将会导致<code>u32</code>类型下溢，因为结果应该是负数，而<code>u32</code>无法表示负数。</p>
</blockquote>
<h2 id="02_basic_calculator-08_overflow-无自动提升"><a class="header" href="#02_basic_calculator-08_overflow-无自动提升">无自动提升</a></h2>
<p>一种可能的处理方式是自动将结果提升到更大的整数类型。<br />
例如，当你相加两个<code>u8</code>整数，如果结果是256（<code>u8::MAX + 1</code>），Rust可以选择将结果解释为<code>u16</code>，这是足够容纳256的下一个整数类型。</p>
<p>然而，正如我们之前讨论的，Rust对类型转换相当严格。自动整数提升并不是Rust解决整数溢出问题的方法。</p>
<h2 id="02_basic_calculator-08_overflow-替代方案"><a class="header" href="#02_basic_calculator-08_overflow-替代方案">替代方案</a></h2>
<p>既然排除了自动提升，当发生整数溢出时我们能做什么呢？<br />
归结起来有两种不同的方法：</p>
<ul>
<li>拒绝该操作</li>
<li>提出一个“合理”的结果，使其适应预期的整数类型</li>
</ul>
<h3 id="02_basic_calculator-08_overflow-拒绝操作"><a class="header" href="#02_basic_calculator-08_overflow-拒绝操作">拒绝操作</a></h3>
<p>这是最保守的方法：当发生整数溢出时停止程序。<br />
这是通过我们在<a href="#02_basic_calculator-04_panics">"恐慌"部分</a>已经见过的恐慌机制来实现的。</p>
<h3 id="02_basic_calculator-08_overflow-提出一个合理的结果"><a class="header" href="#02_basic_calculator-08_overflow-提出一个合理的结果">提出一个“合理”的结果</a></h3>
<p>当算术操作的结果超过给定整数类型的最大值时，你可以选择<strong>环绕</strong>。<br />
如果你将给定整数类型的所有可能值想象成一个圆圈，环绕就意味着当你达到最大值时，你又从最小值开始。</p>
<p>例如，如果你在1和255（=<code>u8::MAX</code>）之间进行<strong>环绕加法</strong>，结果是0（=<code>u8::MIN</code>）。如果你使用有符号整数，同样的原则适用。例如，将1加到127（=<code>i8::MAX</code>）并采用环绕，将给你-128（=<code>i8::MIN</code>）。</p>
<h2 id="02_basic_calculator-08_overflow-overflow-checks"><a class="header" href="#02_basic_calculator-08_overflow-overflow-checks"><code>overflow-checks</code></a></h2>
<p>Rust让你，作为开发者，选择当整数溢出时采取哪种方法。<br />
这种行为由<code>overflow-checks</code>配置设置控制。</p>
<p>如果<code>overflow-checks</code>设置为<code>true</code>，Rust在整数操作溢出时将在<strong>运行时恐慌</strong>。如果<code>overflow-checks</code>设置为<code>false</code>，Rust在整数操作溢出时将<strong>环绕</strong>。</p>
<p>你可能想知道——配置文件设置是什么？让我们来了解一下！</p>
<h2 id="02_basic_calculator-08_overflow-配置文件"><a class="header" href="#02_basic_calculator-08_overflow-配置文件">配置文件</a></h2>
<p>一个<strong>配置文件</strong>是一组配置选项，可以用来定制Rust代码的编译方式。</p>
<p>Cargo提供了两个内置的配置文件：<code>dev</code>和<code>release</code>。<br />
<code>dev</code>配置文件在每次你运行<code>cargo build</code>、<code>cargo run</code>或<code>cargo test</code>时使用。它旨在本地开发，因此牺牲了运行时性能以换取更快的编译时间和更好的调试体验。<br />
相反，<code>release</code>配置文件针对运行时性能进行了优化，但会导致更长的编译时间。你需要通过<code>--release</code>标志明确请求——例如，<code>cargo build --release</code>或<code>cargo run --release</code>。</p>
<blockquote>
<p>“你是否以发布模式构建了你的项目？”几乎成了Rust社区的一个梗。<br />
它指的是不熟悉Rust并在社交媒体（如Reddit、Twitter等）上抱怨其性能，却没意识到自己还没以发布模式构建项目的开发者。</p>
</blockquote>
<p>你还可以定义自定义配置文件或自定义内置文件。</p>
<h3 id="02_basic_calculator-08_overflow-overflow-check-设置"><a class="header" href="#02_basic_calculator-08_overflow-overflow-check-设置"><code>overflow-check</code> 设置</a></h3>
<p>默认情况下，<code>overflow-checks</code>设置为：</p>
<ul>
<li>对于<code>dev</code>配置文件设为<code>true</code></li>
<li>对于<code>release</code>配置文件设为<code>false</code></li>
</ul>
<p>这符合两个配置文件的目标。<br />
<code>dev</code>旨在本地开发，因此它会在尽可能早的时候出现潜在问题时恐慌。<br />
而<code>release</code>则是为运行时性能优化：检查溢出会减慢程序，所以它更倾向于环绕。</p>
<p>同时，两个配置文件的不同行为可能导致微妙的bug。<br />
我们的建议是对两个配置文件都启用<code>overflow-checks</code>：宁可崩溃也不要默默地产生错误结果。在大多数情况下，运行时性能的影响微乎其微；如果你正在开发对性能要求严格的应用程序，你可以运行基准测试来决定是否能够接受这一点。</p>
<h2 id="02_basic_calculator-08_overflow-参考资料"><a class="header" href="#02_basic_calculator-08_overflow-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于<code>exercises/02_basic_calculator/08_overflow</code></li>
</ul>
<h2 id="02_basic_calculator-08_overflow-进一步阅读"><a class="header" href="#02_basic_calculator-08_overflow-进一步阅读">进一步阅读</a></h2>
<ul>
<li>查看<a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">"关于Rust中整数溢出的神话与传说"</a>深入了解Rust中的整数溢出。</li>
</ul>
<div class="footnote-definition" id="02_basic_calculator-08_overflow-catching"><sup class="footnote-definition-label">1</sup>
<p>你可以尝试捕捉恐慌，但这应该是仅在非常特殊的情况下才考虑的最后手段。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-09_saturating"></div><h1 id="02_basic_calculator-09_saturating-根据具体情况的行为"><a class="header" href="#02_basic_calculator-09_saturating-根据具体情况的行为">根据具体情况的行为</a></h1>
<p><code>overflow-checks</code>是一个较为粗糙的工具：它是一个全局设置，影响整个程序。<br />
通常情况下，你可能希望根据不同的上下文来区别处理整数溢出：有时环绕是正确的选择，而有时恐慌更为可取。</p>
<h2 id="02_basic_calculator-09_saturating-wrapping_-方法"><a class="header" href="#02_basic_calculator-09_saturating-wrapping_-方法"><code>wrapping_</code> 方法</a></h2>
<p>你可以通过使用 <code>wrapping_</code> 方法<sup class="footnote-reference"><a href="#02_basic_calculator-09_saturating-method">1</a></sup>在每次操作的基础上选择执行环绕算术。<br />
例如，你可以使用 <code>wrapping_add</code> 来带环绕地添加两个整数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.wrapping_add(y);
assert_eq!(sum, 0);
<span class="boring">}</span></code></pre></pre>
<h2 id="02_basic_calculator-09_saturating-saturating_-方法"><a class="header" href="#02_basic_calculator-09_saturating-saturating_-方法"><code>saturating_</code> 方法</a></h2>
<p>或者，你可以使用 <code>saturating_</code> 方法选择执行<strong>饱和算术</strong>。<br />
饱和算术不会进行环绕，而是会返回整数类型的最大或最小值。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 255u8;
let y = 1u8;
let sum = x.saturating_add(y);
assert_eq!(sum, 255);
<span class="boring">}</span></code></pre></pre>
<p>由于 <code>255 + 1</code> 等于 <code>256</code>，这超过了 <code>u8::MAX</code>，所以结果就是 <code>u8::MAX</code>（即255）。<br />
对于下溢也是如此：<code>0 - 1</code> 是 <code>-1</code>，这小于 <code>u8::MIN</code>，因此结果就是 <code>u8::MIN</code>（即0）。</p>
<p>你无法通过 <code>overflow-checks</code> 配置文件设置来获得饱和算术——在执行算术操作时，你必须明确选择它。</p>
<h2 id="02_basic_calculator-09_saturating-参考资料"><a class="header" href="#02_basic_calculator-09_saturating-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/02_basic_calculator/09_saturating</code></li>
</ul>
<div class="footnote-definition" id="02_basic_calculator-09_saturating-method"><sup class="footnote-definition-label">1</sup>
<p>你可以将方法视为“附着”到特定类型的函数。
我们将在下一章中涵盖方法（以及如何定义它们）。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="02_basic_calculator-10_as_casting"></div><h1 id="02_basic_calculator-10_as_casting-类型转换第一部分"><a class="header" href="#02_basic_calculator-10_as_casting-类型转换第一部分">类型转换，第一部分</a></h1>
<p>我们已经多次强调过，Rust 不会为整数执行隐式类型转换。<br />
那么，如何进行<strong>显式</strong>转换呢？</p>
<h2 id="02_basic_calculator-10_as_casting-as关键字"><a class="header" href="#02_basic_calculator-10_as_casting-as关键字"><code>as</code>关键字</a></h2>
<p>你可以使用 <code>as</code> 关键字在整数类型之间进行转换。<br />
<code>as</code> 转换是<strong>不会失败</strong>的。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u32 = 10;

// 将 `a` 转换为 `u64` 类型
let b = a as u64;

// 你可以使用 `_` 作为目标类型
// 如果编译器能正确推断出来的话
// 比如：
let c: u64 = a as _;
<span class="boring">}</span></code></pre></pre>
<p>这种转换的语义是你所期望的：所有 <code>u32</code> 的值都是有效的 <code>u64</code> 值。</p>
<h3 id="02_basic_calculator-10_as_casting-截断"><a class="header" href="#02_basic_calculator-10_as_casting-截断">截断</a></h3>
<p>如果我们反向进行就会更有趣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个太大以至于无法放入 `u8` 的数字
let a: u16 = 255 + 1;
let b = a as u8;
<span class="boring">}</span></code></pre></pre>
<p>此程序将无问题运行，因为 <code>as</code> 转换是绝对不会失败的。
但 <code>b</code> 的值是多少呢？
从较大的整数类型转换到较小的类型时，Rust 编译器会执行<strong>截断</strong>。</p>
<p>要了解发生了什么，我们先来看 <code>256u16</code> 在内存中是如何表示的，即一系列位：</p>
<pre><code class="language-text"> 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
|               |               |
+---------------+---------------+
  高8位           低8位
</code></pre>
<p>转换为 <code>u8</code> 时，Rust 编译器将保留 <code>u16</code> 内存表示的最后8位：</p>
<pre><code class="language-text"> 0 0 0 0 0 0 0 0 
|               |
+---------------+
  低8位   
</code></pre>
<p>因此，<code>256 as u8</code> 等于 <code>0</code>。这在大多数场景下...不太理想。
实际上，如果编译器看到你试图进行会导致截断的字面值转换，它会主动阻止你：</p>
<pre><code class="language-text">错误：字面值超出 `i8` 的范围
  |
4 |     let a = 255 as i8;
  |             ^^^
  |
  = 注意：字面值 `255` 无法放入范围为 `-128..=127` 的 `i8` 类型中
  = 帮助：考虑使用类型 `u8` 代替
  = 注意：默认启用了 `#[deny(overflowing_literals)]`
</code></pre>
<h3 id="02_basic_calculator-10_as_casting-建议"><a class="header" href="#02_basic_calculator-10_as_casting-建议">建议</a></h3>
<p>总的来说，使用 <code>as</code> 转换要非常小心。<br />
<strong>仅限于</strong>从较小类型转换到较大类型时使用。若要从较大整数类型转换到较小的整数类型，请依赖于我们将在课程后期探索的可<strong>失败的</strong>转换机制。</p>
<h3 id="02_basic_calculator-10_as_casting-局限性"><a class="header" href="#02_basic_calculator-10_as_casting-局限性">局限性</a></h3>
<p>令人惊讶的行为并不是 <code>as</code> 转换的唯一缺点。它也相当有限：你只能依靠 <code>as</code> 转换用于原始类型和其他少数特殊情况。<br />
在处理复合类型时，你将需要依赖于不同的转换机制（<a href="#05_ticket_v2-13_try_from">可失败的</a> 和 <a href="#04_traits-08_from">不可失败的</a>），我们将在后续内容中探讨。</p>
<h2 id="02_basic_calculator-10_as_casting-参考资料"><a class="header" href="#02_basic_calculator-10_as_casting-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/02_basic_calculator/10_as_casting</code></li>
</ul>
<h2 id="02_basic_calculator-10_as_casting-进一步阅读"><a class="header" href="#02_basic_calculator-10_as_casting-进一步阅读">进一步阅读</a></h2>
<ul>
<li>查阅 Rust 官方参考文档的<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#numeric-cast">这一部分</a>，了解每种源类型和目标类型组合下 <code>as</code> 转换的确切行为，以及所有允许的转换列表。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-00_intro"></div><h1 id="03_ticket_v1-00_intro-模拟建一个票务系统"><a class="header" href="#03_ticket_v1-00_intro-模拟建一个票务系统">模拟建一个票务系统</a></h1>
<p>第一章应已让你对Rust的基本类型、操作符和控制流程构造有了良好的掌握。<br />
本章，我们将更进一步探讨使Rust真正独特之处：<strong>所有权</strong><br />
所有权让Rust既内存安全，又高效，无需垃圾回收器。</p>
<p>以一个票务系统（类似JIRA）为例，你用于跟踪软件项目中的错误、特性或任务。<br />
我们将尝试用Rust建模它。这只是初版，不完美，也不够地道，章节末。但足够挑战！<br />
前进需掌握几个Rust概念：</p>
<ul>
<li><code>struct</code>，定义自定义类型的方式之一</li>
<li>所有权和借用</li>
<li>内存管理：栈、指针、数据布局、析构</li>
<li>模块和可见性- 字符串</li>
</ul>
<h2 id="03_ticket_v1-00_intro-参考"><a class="header" href="#03_ticket_v1-00_intro-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/00_intro</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-01_struct"></div><h1 id="03_ticket_v1-01_struct-结构体struct"><a class="header" href="#03_ticket_v1-01_struct-结构体struct">结构体（Struct）</a></h1>
<p>我们需要为每个工单追踪三部分信息：</p>
<ul>
<li>标题</li>
<li>描述</li>
<li>状态</li>
</ul>
<p>我们可以先使用 <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> 来表示它们。<code>String</code>是Rust标准库中定义的类型，用于表示<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8编码</a>的文本。</p>
<p>但是，我们如何将这三部分信息<strong>合并</strong>为一个实体呢？</p>
<h2 id="03_ticket_v1-01_struct-定义一个struct"><a class="header" href="#03_ticket_v1-01_struct-定义一个struct">定义一个<code>struct</code></a></h2>
<p><code>struct</code>定义了一个<strong>新的Rust类型</strong>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p><code>struct</code>与你在其他编程语言中称为类或对象的东西非常相似。</p>
<h2 id="03_ticket_v1-01_struct-定义字段"><a class="header" href="#03_ticket_v1-01_struct-定义字段">定义字段</a></h2>
<p>新类型是通过组合其他类型作为<strong>字段</strong>建立的。<br />
每个字段都需要一个名字和一个类型，中间用冒号分隔开：<code>:</code>如果有多个字段，则用逗号<code>,</code>分隔开。</p>
<p>字段不必是同一类型，如下面的<code>Configuration</code>结构体所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
    version: u32,
    active: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="03_ticket_v1-01_struct-实例化"><a class="header" href="#03_ticket_v1-01_struct-实例化">实例化</a></h2>
<p>通过为每个字段指定值可以创建一个<code>struct</code>的实例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 语法：&lt;StructName&gt; { &lt;field_name&gt;: &lt;value&gt;, ... }
let ticket = Ticket {
    title: "建立一个工单系统".into(),
    description: "创建一个可以在看板上管理工单的系统".into(),
    status: "打开".into()};
<span class="boring">}</span></code></pre></pre>
<h2 id="03_ticket_v1-01_struct-访问字段"><a class="header" href="#03_ticket_v1-01_struct-访问字段">访问字段</a></h2>
<p>你可以使用<code>.</code>操作符访问<code>struct</code>的字段：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 字段访问
let x = ticket.description;
<span class="boring">}</span></code></pre></pre>
<h2 id="03_ticket_v1-01_struct-方法"><a class="header" href="#03_ticket_v1-01_struct-方法">方法</a></h2>
<p>我们可以通过定义<strong>方法</strong>为我们的<code>struct</code>附加行为。<br />
以<code>Ticket</code>结构体为例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    fn is_open(&amp;self) -&gt; bool {
        self.status == "Open"
    }
}

// 语法：
// impl &lt;StructName&gt; {
//    fn &lt;method_name&gt;(&amp;self, &lt;parameters&gt;) -&gt; &lt;return_type&gt; {
//        // 方法体
//    }
// }
<span class="boring">}</span></code></pre></pre>
<p>方法与函数很相似，但有两个关键区别：</p>
<ol>
<li>方法必须在**<code>impl</code>块内定义</li>
<li>方法可以使用<code>self</code>作为它们的第一个参数。
<code>self</code>是一个关键字，代表调用其调用方法的<code>struct</code>实例。</li>
</ol>
<h3 id="03_ticket_v1-01_struct-self"><a class="header" href="#03_ticket_v1-01_struct-self"><code>self</code></a></h3>
<p>如果方法以<code>self</code>作为其第一个参数，它可以使用<strong>方法调用语法</strong>调用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 方法调用语法： &lt;instance&gt;.&lt;method_name&gt;(&lt;parameters&gt;)
let is_open = ticket.is_open();
<span class="boring">}</span></code></pre></pre>
<p>这与上一章中对<code>u32</code>值执行饱和算术操作使用的调用语法相同<a href="#03_ticket_v1-02_basic_calculator-09_saturating">02_basic_calculator/09_saturating.md</a>。</p>
<h3 id="03_ticket_v1-01_struct-静态方法"><a class="header" href="#03_ticket_v1-01_struct-静态方法">静态方法</a></h3>
<p>如果方法不以<code>self</code>作为其第一个参数，它是一个<strong>静态方法</strong>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Configuration {
    version: u32,
    active: bool,
}

impl Configuration {
    // `default` 是 `Configuration` 上的静态方法
    fn default() -&gt; Configuration {
        Configuration { version: 0, active: false }
    }
<span class="boring">}</span></code></pre></pre>
<p>调用静态方法的唯一方式是使用<strong>函数调用语法</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 函数调用语法： &lt;StructName&gt;::&lt;method_name&gt;(&lt;parameters&gt;)
let default_config = Configuration::default();
<span class="boring">}</span></code></pre></pre>
<h3 id="03_ticket_v1-01_struct-等价性"><a class="header" href="#03_ticket_v1-01_struct-等价性">等价性</a></h3>
<p>即使以<code>self</code>作为第一个参数的方法，你也可以使用函数调用语法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 函数调用语法： &lt;StructName&gt;::&lt;method_name&gt;(&lt;instance&gt;, &lt;parameters&gt;)
let is_open = Ticket::is_open(ticket);
<span class="boring">}</span></code></pre></pre>
<p>函数调用语法清晰地表明<code>ticket</code>作为<code>self</code>，方法的第一个参数在使用，但确实更冗长。可能时优先使用方法调用语法。</p>
<h2 id="03_ticket_v1-01_struct-参考资料"><a class="header" href="#03_ticket_v1-01_struct-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/01_struct</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-02_validation"></div><h1 id="03_ticket_v1-02_validation-校验"><a class="header" href="#03_ticket_v1-02_validation-校验">校验</a></h1>
<p>回到我们的工单定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>我们在<code>Ticket</code>结构体的字段中使用了“原始”类型。这意味着用户可以创建一个标题为空、描述超级长或状态无意义（例如"Funny"）的工单。我们可以做得更好！</p>
<h2 id="03_ticket_v1-02_validation-参考资料"><a class="header" href="#03_ticket_v1-02_validation-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/02_validation</code></li>
</ul>
<h2 id="03_ticket_v1-02_validation-进一步阅读"><a class="header" href="#03_ticket_v1-02_validation-进一步阅读">进一步阅读</a></h2>
<ul>
<li>查看<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code>的文档</a>详细了解它提供的方法。你做练习时会用到的！</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-03_modules"></div><h1 id="03_ticket_v1-03_modules-模块"><a class="header" href="#03_ticket_v1-03_modules-模块">模块</a></h1>
<p>你刚定义的<code>new</code>方法试图对<code>Ticket</code>的字段值实施一些<strong>约束</strong>。但这些约束真的被执行了吗？有什么能阻止开发者不通过<code>Ticket::new</code>直接创建<code>Ticket</code>呢？</p>
<p>要实现真正的<strong>封装</strong>，你需要了解两个新概念：<strong>可见性</strong>和<strong>模块</strong>。我们先从模块开始讲起。</p>
<h2 id="03_ticket_v1-03_modules-什么是模块"><a class="header" href="#03_ticket_v1-03_modules-什么是模块">什么是模块？</a></h2>
<p>在Rust中，<strong>模块</strong>是一种将相关代码组织在一起的方式，置于一个共同的命名空间下（即模块名）。你已经看过模块的实践了：验证代码正确性的单元测试被定义在一个不同的模块里，名为<code>tests</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="03_ticket_v1-03_modules-内联模块"><a class="header" href="#03_ticket_v1-03_modules-内联模块">内联模块</a></h2>
<p>上面的<code>tests</code>模块是<strong>内联模块</strong>的例子：模块声明（<code>mod tests</code>）和模块内容（里面的内容<code>{ ... }</code>）紧挨着一起。</p>
<h2 id="03_ticket_v1-03_modules-模块树"><a class="header" href="#03_ticket_v1-03_modules-模块树">模块树</a></h2>
<p>模块可以嵌套，形成<strong>树状结构</strong>。树的根是<strong>crate</strong>本身**，即包含所有其他模块的顶级模块。对于库，根模块通常是<code>src/lib.rs</code>（除非位置被自定义过）。</p>
<p>根模块也被称为<strong>crate根</strong>。</p>
<p>根模块可以有子模块，它们反过来也有自己的子模块，以此类推。</p>
<h2 id="03_ticket_v1-03_modules-外部模块和文件系统"><a class="header" href="#03_ticket_v1-03_modules-外部模块和文件系统">外部模块和文件系统</a></h2>
<p>内联模块对小段代码很有用，但随着项目成长，你会想把代码拆分成多个文件。在父模块里，你用<code>mod</code>关键字声明子模块的存在。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod dog;
<span class="boring">}</span></code></pre></pre>
<p>Rust的构建工具<code>cargo</code>则负责找到包含模块实现的文件。如果你的模块声明在crate的根目录（如<code>src/lib.rs</code>或<code>src/main.rs</code>），<code>cargo</code>期待文件命名为：</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module&gt;/mod.rs</code></li>
</ul>
<p>如果你的模块是另一个模块的子模块，文件应命名为：</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module&gt;.rs</code></li>
<li><code>[..]/&lt;module&gt;/mod.rs</code></li>
</ul>
<p>比如，如果是<code>animals</code>的子模块，那么<code>src/animals/dog.rs</code>或<code>src/og/mod.rs</code>。</p>
<p>你的IDE可能在你用<code>mod</code>关键字声明新模块时自动帮你创建这些文件。</p>
<h2 id="03_ticket_v1-03_modules-项路径和use语句"><a class="header" href="#03_ticket_v1-03_modules-项路径和use语句">项路径和<code>use</code>语句</a></h2>
<p>同一模块里的项可以直接访问，不需要特别语法。直接用它们的名字就行。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    // [...]
}

// 这里不需要限定`Ticket`的任何方式
//因为我们处于同一模块
fn mark_ticket_done(ticket: Ticket) {
    // [...]}
<span class="boring">}</span></code></pre></pre>
<p>但如果你想从不同模块访问实体就不是这样了。你得用指向要访问实体的<strong>路径</strong>。</p>
<p>路径可以用多种方式组合：</p>
<ul>
<li>从当前crate根开始，比如 <code>crate::module_1::module_2::MyStruct</code></li>
<li>从父模块开始，比如 <code>super::my_function</code></li>
<li>从当前模块开始，比如 <code>sub_module::MyStruct</code></li>
</ul>
<p>每次引用类型都写全路径可能很繁琐。为了方便，你可以引入<code>use</code>语句来把实体引入作用域。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 引入MyStruct`到作用域
use crate::module_1::module_2::MyStruct;

// 现在可以直接引用`MyStruct`
fn a_function(s: MyStruct) {
     // [...]}
<span class="boring">}</span></code></pre></pre>
<h3 id="03_ticket_v1-03_modules-星号导入"><a class="header" href="#03_ticket_v1-03_modules-星号导入">星号导入</a></h3>
<p>你也可以用一个<code>use</code>语句导入一个模块的所有项。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::module_1::module_2::*;
<span class="boring">}</span></code></pre></pre>
<p>这称为<strong>星号导入</strong>。<br />
通常不鼓励这样做因为它可能会污染当前命名空间，使得难以理解每个名字来自哪里，并且潜在地引起名称冲突。<br />
尽管如此，在某些情况它还是有用的，比如写单元测试时。你可能注意到多数测试模块以<code>use super::*;</code>开始，引入父模块（被测试的模块）的所有项到作用域。</p>
<h2 id="03_ticket_v1-03_modules-参考资料"><a class="header" href="#03_ticket_v1-03_modules-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/03_modules</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-04_visibility"></div><h1 id="03_ticket_v1-04_visibility-可见性"><a class="header" href="#03_ticket_v1-04_visibility-可见性">可见性</a></h1>
<p>当你开始将代码分解成多个模块时，就需要开始考虑<strong>可见性</strong>的问题了。可见性决定了你的代码（或其他人的代码）中哪些部分能够访问给定的实体，不论是结构体、函数、字段等。</p>
<h2 id="03_ticket_v1-04_visibility-默认私有"><a class="header" href="#03_ticket_v1-04_visibility-默认私有">默认私有</a></h2>
<p>Rust中，默认一切都是<strong>私有的</strong>。<br />
私有实体只能在以下情况下被访问：</p>
<ol>
<li>定义它的同一个模块内部，或</li>
<li>其子模块之一</li>
</ol>
<p>在之前的练习中，我们广泛使用了这一点：</p>
<ul>
<li><code>create_todo_ticket</code> 工作正常（一旦你添加了<code>use</code>语句），因为<code>helpers</code>是crate根模块的子模块，而<code>Ticket</code>在那里被定义。因此，<code>create_todo_ticket</code>可以无障碍地访问<code>Ticket</code>，即便<code>Ticket</code>是私有的。</li>
<li>所有单元测试都定义在其测试代码的子模块中，因此可以不受限制地访问一切。</li>
</ul>
<h2 id="03_ticket_v1-04_visibility-可见性修饰符"><a class="header" href="#03_ticket_v1-04_visibility-可见性修饰符">可见性修饰符</a></h2>
<p>你可以使用<strong>可见性修饰符</strong>来修改实体的默认可见性。一些常见的可见性修饰符包括：</p>
<ul>
<li><code>pub</code>：使实体<strong>公开</strong>，即在定义它的模块之外也能访问，可能还允许其他crate访问。</li>
<li><code>pub(crate)</code>：在同一个<strong>crate</strong>内部公开实体，但不允许外部访问。</li>
<li><code>pub(super)</code>：在父模块中公开实体。</li>
<li><code>pub(in path::to::module)</code>：在指定的模块中公开实体。</li>
</ul>
<p>你可以在模块、结构体、函数、字段等上使用这些修饰符。
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Configuration {
    pub(crate) version: u32,
    active: bool,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Configuration</code>是公开的，但你只能在同一crate内访问<code>version</code>字段。
相反，<code>active</code>字段是私有的，只能在同一个模块或其子模块内部访问。</p>
<h2 id="03_ticket_v1-04_visibility-参考资料"><a class="header" href="#03_ticket_v1-04_visibility-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/04_visibility</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-05_encapsulation"></div><h1 id="03_ticket_v1-05_encapsulation-封装"><a class="header" href="#03_ticket_v1-05_encapsulation-封装">封装</a></h1>
<p>现在我们对模块和可见性有了基本的了解，让我们回到<strong>封装</strong>的概念上来。封装是隐藏对象内部表示的做法，最常用于强制执行对象状态的一些<strong>不变量</strong>。</p>
<p>回到我们的<code>Ticket</code>结构体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>如果所有字段都是公开的，就没有封装。你必须假设字段可以在任何时候被修改为由其类型允许的任何值。你不能排除票证明确实可能有空标题或没有意义的状态。</p>
<p>为了执行更严格的规则，我们必须保持字段私有<sup class="footnote-reference"><a href="#03_ticket_v1-05_encapsulation-newtype">1</a></sup>。然后，我们可以提供公共方法来与<code>Ticket</code>实例交互。那些公共方法将负责维护我们的不变量（例如，标题不能为空）。</p>
<p>如果所有字段都是私有的，那么就不能直接使用结构体实例化语法创建<code>Ticket</code>实例了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这样做不行！
let ticket = Ticket {
    title: "建立一个工单系统".into(),
    description: "创建一个可以在看板上管理工单的系统".into(),
    status: "打开".into()}
<span class="boring">}</span></code></pre></pre>
<p>在前面关于可见性的练习中你已经看到了这个操作。我们现在需要提供一个或多个<strong>构造函数</strong>，即可以从模块外部使用的静态方法或函数来创建结构体的新实例。幸运的是，我们已经有了一个：<code>Ticket::new</code>，如之前练习中实现的<a href="#02_validation-readme">这里</a>。</p>
<h2 id="03_ticket_v1-05_encapsulation-访问器方法"><a class="header" href="#03_ticket_v1-05_encapsulation-访问器方法">访问器方法</a></h2>
<p>总结一下：</p>
<ul>
<li><code>Ticket</code>的所有字段都是私有的</li>
<li>我们提供了一个构造函数，<code>Ticket::new</code>，它在创建时强制执行了我们的验证规则</li>
</ul>
<p>这是一个好的开始，但还不够：除了创建<code>Ticket</code>之外，我们还需要与其交互。但如果字段是私有的，我们怎么访问呢？</p>
<p>我们需要提供<strong>访问器方法</strong>。访问器方法是公共方法，允许你读取私有结构体字段（或字段）的值。</p>
<p>Rust不像其他一些语言那样内置了为你生成访问器方法的方式。你需要自己编写它们——它们只是常规的方法。</p>
<h2 id="03_ticket_v1-05_encapsulation-参考"><a class="header" href="#03_ticket_v1-05_encapsulation-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/05_encapsulation</code></li>
</ul>
<div class="footnote-definition" id="03_ticket_v1-05_encapsulation-newtype"><sup class="footnote-definition-label">1</sup>
<p>或者细化它们的类型，这是我们将在后面探索的技术<a href="#05_ticket_v2-15_outro">这里</a>。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-06_ownership"></div><h1 id="03_ticket_v1-06_ownership-所有权"><a class="header" href="#03_ticket_v1-06_ownership-所有权">所有权</a></h1>
<p>如果你按照本课程目前所学的内容解决了上一个练习，你的访问器方法可能看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(self) -&gt; String {
        self.title
    }

    pub fn description(self) -&gt; String {
        self.description
    }

    pub fn status(self) -&gt; String {
        self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这些方法可以编译通过，并且足以让测试通过，但在实际场景中，它们不会让你走得太远。考虑这段代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ticket.status() == "待办" {
    // 尽管我们还没讲到 `println!` 宏，
    // 但目前只需知道它会将（模板化的）消息打印到控制台
    println!("你的下一个任务是: {}", ticket.title());
}
<span class="boring">}</span></code></pre></pre>
<p>如果你尝试编译它，你会得到一个错误：</p>
<pre><code class="language-text">错误[E0382]: 使用了已移动的值: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ `ticket` 因为此处类型为 `Ticket` 而被移动，
   |                此类型未实现 `Copy` 特征
26 |     if ticket.status() == "待办" {
   |               -------- `ticket` 因为此方法调用而被移动
...
30 |         println!("你的下一个任务是: {}", ticket.title());
   |                                           ^^^^^^ 在移动后此处再次使用了值
   |
注意: `Ticket::status` 接收者 `self` 采用所有权，这导致 `ticket` 被移动
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>恭喜，这是你遇到的第一个借用检查器错误！</p>
<h2 id="03_ticket_v1-06_ownership-rust所有权系统的优点"><a class="header" href="#03_ticket_v1-06_ownership-rust所有权系统的优点">Rust所有权系统的优点</a></h2>
<p>Rust的所有权系统旨在确保：</p>
<ul>
<li>数据在被读取时从不被修改</li>
<li>数据在被修改时从不被读取</li>
<li>数据被销毁后不再被访问</li>
</ul>
<p>这些约束由<strong>借用检查器</strong>强制执行，它是Rust编译器的一个子系统，经常成为Rust社区中笑话和梗的主题。</p>
<p>所有权是Rust中的一个关键概念，也是使该语言独特的原因。所有权使得Rust能够在<strong>不牺牲性能的情况下提供内存安全性</strong>。对于Rust来说，以下所有内容同时都是真实的：</p>
<ol>
<li>没有运行时垃圾收集器</li>
<li>作为开发者，你很少需要直接管理内存</li>
<li>你无法造成悬挂指针、重复释放以及其他与内存相关的错误</li>
</ol>
<p>像Python、JavaScript和Java这样的语言给你2.和3.，但不提供1.。像C或C++这样的语言给你1.，但不提供2.和3.。</p>
<p>根据你的背景，3.听起来可能有点神秘：什么是“悬挂指针”？什么是“重复释放”？为什么它们危险？别担心：我们将在课程的其余部分更详细地讨论这些概念。</p>
<p>不过，目前，让我们先专注于学习如何在Rust的所有权系统下工作。</p>
<h2 id="03_ticket_v1-06_ownership-所有者"><a class="header" href="#03_ticket_v1-06_ownership-所有者">所有者</a></h2>
<p>在Rust中，每个值都有一个<strong>所有者</strong>，在编译时静态确定。在任何给定时间，每个值只有一个所有者。</p>
<h2 id="03_ticket_v1-06_ownership-移动语义"><a class="header" href="#03_ticket_v1-06_ownership-移动语义">移动语义</a></h2>
<p>所有权可以转移。</p>
<p>如果你拥有一个值，例如，你可以将其所有权转移到另一个变量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 42; // &lt;--- `a` 是值 `42` 的所有者
let b = a;  // &lt;--- `b` 现在是值 `42` 的所有者
<span class="boring">}</span></code></pre></pre>
<p>Rust的所有权系统内置于类型系统中：每个函数都必须在其签名中声明它打算如何与其参数交互。</p>
<p>到目前为止，我们所有的方法和函数都<strong>消耗</strong>了它们的参数：它们获取了参数的所有权。
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn description(self) -&gt; String {
        self.description
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Ticket::description</code> 获取调用它的<code>Ticket</code>实例的所有权。这被称为<strong>移动语义</strong>：值(<code>self</code>)的所有权从调用者<strong>转移到</strong>被调用者，调用者不能再使用它了。</p>
<p>这正是我们在前面看到的编译器错误信息中所使用的语言：</p>
<pre><code class="language-text">错误[E0382]: 使用了已移动的值: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ 因为 `ticket` 类型为 `Ticket`，在此发生移动，
   |                此类型未实现 `Copy` 特征
26 |     if ticket.status() == "待办" {
   |               -------- `ticket` 因为此方法调用而被移动
...
30 |         println!("你的下一个任务是: {}", ticket.title());
   |                                           ^^^^^^ 在移动后此处再次使用了值
   |
注意: `Ticket::status` 接收者 `self` 采用所有权，导致 `ticket` 被移动
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>具体来说，当我们调用<code>ticket.status()</code>时，事件序列如下：</p>
<ul>
<li><code>Ticket::status</code> 获取<code>Ticket</code>实例的所有权</li>
<li><code>Ticket::status</code> 从<code>self</code>提取<code>status</code>并将<code>status</code>的所有权转移回调用者</li>
<li>剩余的<code>Ticket</code>实例部分被丢弃（<code>title</code>和<code>description</code>）</li>
</ul>
<p>当我们尝试再次通过<code>ticket.title()</code>使用<code>ticket</code>时，编译器会抱怨：<code>ticket</code>值现在已经没了，我们不再拥有它，因此不能再使用它。</p>
<p>要构建<strong>有用的</strong>访问器方法，我们需要开始使用<strong>引用</strong>。</p>
<h2 id="03_ticket_v1-06_ownership-借用"><a class="header" href="#03_ticket_v1-06_ownership-借用">借用</a></h2>
<p>拥有一些不获取其所有权就能读取变量值的方法是可取的。否则编程将受到很大限制。在Rust中，这是通过<strong>借用</strong>来完成的。</p>
<p>每次你借用一个值时，都会得到它的<strong>引用</strong>。引用带有它们的权限标签<sup class="footnote-reference"><a href="#03_ticket_v1-06_ownership-refine">1</a></sup>：</p>
<ul>
<li>不可变引用(<code>&amp;</code>)允许你读取值，但不允许修改它</li>
<li>可变引用(<code>&amp;mut</code>)允许你读取并修改值</li>
</ul>
<p>回到Rust所有权系统的目标：</p>
<ul>
<li>数据在被读取时从不被修改</li>
<li>数据在被修改时从不被读取</li>
</ul>
<p>为了确保这两点，Rust必须对引用引入一些限制：</p>
<ul>
<li>你不能同时拥有对同一值的可变引用和不可变引用</li>
<li>你不能同时拥有对同一值的多个可变引用</li>
<li>所有者在值被借用期间不能修改值</li>
<li>只要有不可变引用，你可以拥有任意数量的不可变引用，只要没有可变引用</li>
</ul>
<p>在某种程度上，你可以将不可变引用视为值上的“只读”锁，而可变引用则像是“读写”锁。</p>
<p>所有这些限制都由借用检查器在编译时强制执行。</p>
<h3 id="03_ticket_v1-06_ownership-语法"><a class="header" href="#03_ticket_v1-06_ownership-语法">语法</a></h3>
<p>实际上如何借用一个值呢？</p>
<p>通过在变量<strong>前</strong>添加<code>&amp;</code>或<code>&amp;mut</code>，你就是在借用它的值。但要注意！相同的符号（<code>&amp;</code>和<code>&amp;mut</code>）在<strong>类型的前面</strong>有不同的含义：它们表示原始类型的引用，即引用类型本身。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust">struct 配置 {
    版本: u32,
    活动: bool,
}

fn main() {
    let 配置 = 配置 {
        版本: 1,
        活动: true,
    };
    // `b` 是对 `config` 的 `版本` 字段的引用。
    // `b` 的类型是 `&amp;u32`，因为它包含对 `u32` 值的引用。
    // 我们通过借用 `config.版本` 并使用 `&amp;` 运算符创建引用。
    // 同样的符号（`&amp;`），根据上下文有不同的含义！
    let b: &amp;u32 = &amp;配置.版本;
    //     ^ 类型注解不是必需的，
    //       它只是为了阐明正在发生的事情
}</code></pre></pre>
<p>同样的概念适用于函数参数和返回类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `f` 接受一个 `u32` 的可变引用作为参数，绑定到名为 `number`
fn f(number: &amp;mut u32) -&gt; &amp;u32 {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="03_ticket_v1-06_ownership-深呼吸"><a class="header" href="#03_ticket_v1-06_ownership-深呼吸">深呼吸</a></h2>
<p>Rust的所有权系统一开始可能会让人有些不知所措。但别担心：通过实践它会变得自然而然。在本章剩余部分以及整个课程中，你将获得大量的实践机会！我们将多次回顾每个概念，确保你熟悉它们并真正理解它们的工作原理。</p>
<p>在本章末尾，我们会解释为什么Rust的所有权系统设计成这样。目前，集中精力理解<strong>如何</strong>做。把每一个编译器错误都当作一次学习机会！</p>
<h2 id="03_ticket_v1-06_ownership-参考"><a class="header" href="#03_ticket_v1-06_ownership-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/06_ownership</code></li>
</ul>
<div class="footnote-definition" id="03_ticket_v1-06_ownership-refine"><sup class="footnote-definition-label">1</sup>
<p>这是一个很好的入门心理模型，但它没有捕捉到完整的画面。
我们将在课程的后续部分<a href="#07_threads-06_interior_mutability">深化</a>对引用的理解。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-07_setters"></div><h1 id="03_ticket_v1-07_setters-可变引用"><a class="header" href="#03_ticket_v1-07_setters-可变引用">可变引用</a></h1>
<p>现在，你的访问器方法应该看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }

    pub fn description(&amp;self) -&gt; &amp;String {
        &amp;self.description
    }

    pub fn status(&amp;self) -&gt; &amp;String {
        &amp;self.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在这里那里撒上一点<code>&amp;</code>就搞定了！我们现在有一种方式可以在不消耗<code>Ticket</code>实例的过程中访问其字段。接下来，让我们看看如何通过添加<strong>设置器方法</strong>来增强我们的<code>Ticket</code>结构体。</p>
<h2 id="03_ticket_v1-07_setters-设置器"><a class="header" href="#03_ticket_v1-07_setters-设置器">设置器</a></h2>
<p>设置器方法允许用户更改<code>Ticket</code>的私有字段值，同时确保其不变性得到尊重（例如，你不能将<code>Ticket</code>的标题设置为空字符串）。</p>
<p>在Rust中有两种常见的设置器实现方式：</p>
<ul>
<li>将<code>self</code>作为输入。</li>
<li>将<code>&amp;mut self</code>作为输入。</li>
</ul>
<h3 id="03_ticket_v1-07_setters-将self作为输入"><a class="header" href="#03_ticket_v1-07_setters-将self作为输入">将<code>self</code>作为输入</a></h3>
<p>第一种方法如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(mut self, new_title: String) -&gt; Self {
        // 验证新标题 [...]
        self.title = new_title;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<p>它获取<code>self</code>的所有权，更改标题，并返回修改后的<code>Ticket</code>实例。你可以这样使用它：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("标题".into(), "描述".into(), "待办".into());
let ticket = ticket.set_title("新标题".into());
<span class="boring">}</span></code></pre></pre>
<p>由于<code>set_title</code>获取<code>self</code>的所有权（即<strong>消耗</strong>它），我们需要将结果重新赋值给一个变量。在上面的例子中，我们利用<strong>变量覆盖</strong>来重用相同的变量名：当你使用与现有变量相同的名字声明新变量时，新变量会<strong>覆盖</strong>旧变量。这是Rust代码中的一个常见模式。</p>
<p>当需要一次性更改多个字段时，<code>self</code>-设置器工作得相当不错：你可以将多个调用串联在一起！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = ticket
    .set_title("新标题".into())
    .set_description("新描述".into())
    .set_status("进行中".into());
<span class="boring">}</span></code></pre></pre>
<h3 id="03_ticket_v1-07_setters-将mut-self作为输入"><a class="header" href="#03_ticket_v1-07_setters-将mut-self作为输入">将<code>&amp;mut self</code>作为输入</a></h3>
<p>第二种设置器方法，使用<code>&amp;mut self</code>，则是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn set_title(&amp;mut self, new_title: String) {
        // 验证新标题 [...]
        
        self.title = new_title;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这次，该方法以可变引用的形式接收<code>self</code>作为输入，更改标题，就这样。没有返回任何东西。</p>
<p>你可以这样使用它：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ticket = Ticket::new("标题".into(), "描述".into(), "待办".into());
ticket.set_title("新标题".into());

// 使用已修改的ticket
<span class="boring">}</span></code></pre></pre>
<p>所有权保留在调用者手中，所以原始的<code>ticket</code>变量仍然是有效的。我们不需要重新分配结果。但是，我们需要将<code>ticket</code>标记为可变的，因为我们正在对其采取可变引用。</p>
<p><code>&amp;mut</code>-设置器有一个缺点：你不能链式调用多个设置。由于它们不返回修改后的<code>Ticket</code>实例，你不能在第一个调用的结果上再调用另一个设置器。你必须分别调用每个设置器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ticket.set_title("新标题".into());
ticket.set_description("新描述".into());
ticket.set_status("进行中".into());
<span class="boring">}</span></code></pre></pre>
<h2 id="03_ticket_v1-07_setters-参考"><a class="header" href="#03_ticket_v1-07_setters-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/07_setters</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-08_stack"></div><h1 id="03_ticket_v1-08_stack-内存布局"><a class="header" href="#03_ticket_v1-08_stack-内存布局">内存布局</a></h1>
<p>我们从操作的角度探讨了所有权和引用——你能用它们做什么和不能做什么。现在是时候深入了解幕后情况了：让我们谈谈<strong>内存</strong>。</p>
<h2 id="03_ticket_v1-08_stack-栈与堆"><a class="header" href="#03_ticket_v1-08_stack-栈与堆">栈与堆</a></h2>
<p>在讨论内存时，你经常会听到人们谈论<strong>栈</strong>和<strong>堆</strong>。这两个不同的内存区域被程序用来存储数据。</p>
<p>让我们从栈开始说起。</p>
<h2 id="03_ticket_v1-08_stack-栈"><a class="header" href="#03_ticket_v1-08_stack-栈">栈</a></h2>
<p><strong>栈</strong>是一种<strong>后进先出</strong>（Last In, First Out, LIFO）的数据结构。当你调用一个函数时，一个新的<strong>栈帧</strong>会被添加到栈顶。这个栈帧存储了函数的参数、局部变量和一些“簿记”值。当函数返回时，这个栈帧就会从栈中弹出<sup class="footnote-reference"><a href="#03_ticket_v1-08_stack-stack-overflow">1</a></sup>。</p>
<pre><code class="language-text">                                 +-----------------+
                       func2     | frame for func2 |   func2
+-----------------+  is called   +-----------------+  returns   +-----------------+
| frame for func1 | -----------&gt; | frame for func1 | ---------&gt; | frame for func1 |
+-----------------+              +-----------------+            +-----------------+
</code></pre>
<p>从操作角度看，栈的分配/释放<strong>非常快</strong>。我们总是在栈顶推入和弹出数据，因此不需要搜索空闲内存。我们也不必担心碎片化问题：栈是一块连续的内存。</p>
<h3 id="03_ticket_v1-08_stack-rust中的栈"><a class="header" href="#03_ticket_v1-08_stack-rust中的栈">Rust中的栈</a></h3>
<p>Rust经常在栈上分配数据。你的函数有一个<code>u32</code>类型的输入参数吗？那32位就会在栈上。你定义了一个<code>i64</code>类型的局部变量吗？那64位也会在栈上。这一切运作得很顺利，因为这些整数的大小在编译时就已经知道了，因此编译后的程序知道需要为它们在栈上预留多少空间。</p>
<h3 id="03_ticket_v1-08_stack-stdmemsize_of"><a class="header" href="#03_ticket_v1-08_stack-stdmemsize_of"><code>std::mem::size_of</code></a></h3>
<p>你可以使用<a href="https://doc.rust-lang.org/std/mem/fn.size_of.html"><code>std::mem::size_of</code></a>函数验证类型在栈上会占用多少空间。</p>
<p>比如对于<code>u8</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 我们稍后会解释这种有趣的语法（`::&lt;String&gt;`）。现在先忽略它。
assert_eq!(std::mem::size_of::&lt;u8&gt;(), 1);
<span class="boring">}</span></code></pre></pre>
<p>1是合理的，因为<code>u8</code>是8位长，或者说1字节。</p>
<h2 id="03_ticket_v1-08_stack-参考"><a class="header" href="#03_ticket_v1-08_stack-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/08_stack</code></li>
</ul>
<div class="footnote-definition" id="03_ticket_v1-08_stack-stack-overflow"><sup class="footnote-definition-label">1</sup>
<p>如果你有嵌套的函数调用，每个函数在被调用时都会将自己的数据推到栈上，但直到最内层的函数返回才将其弹出。
如果嵌套的函数调用太多，可能会耗尽栈空间——栈不是无限大的！这就是所谓的<strong>栈溢出</strong>。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-09_heap"></div><h1 id="03_ticket_v1-09_heap-堆"><a class="header" href="#03_ticket_v1-09_heap-堆">堆</a></h1>
<p>栈很棒，但它不能解决所有问题。那些在编译时大小未知的数据怎么办呢？集合、字符串和其他动态大小的数据无法完全在栈上分配。这时就需要引入<strong>堆</strong>了。</p>
<h2 id="03_ticket_v1-09_heap-堆分配"><a class="header" href="#03_ticket_v1-09_heap-堆分配">堆分配</a></h2>
<p>你可以将堆想象成一大块内存——如果愿意的话，就像一个巨大的数组。每当需要在堆上存储数据时，你就要向一个特殊的程序请求，即<strong>分配器</strong>，为你保留堆中的一部分。我们将这种交互（以及你保留的内存）称为<strong>堆分配</strong>。如果分配成功，分配器会给你指向已预留块起始位置的<strong>指针</strong>。</p>
<h2 id="03_ticket_v1-09_heap-无自动解除分配"><a class="header" href="#03_ticket_v1-09_heap-无自动解除分配">无自动解除分配</a></h2>
<p>堆的结构与栈大不相同。堆分配不是连续的，它们可以位于堆内的任意位置。</p>
<pre><code>+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
</code></pre>
<p>跟踪堆的哪些部分正在使用，哪些部分是空闲的是分配器的工作。然而，分配器不会自动释放你分配的内存：你需要主动去做这件事，再次调用分配器来<strong>释放</strong>不再需要的内存。</p>
<h2 id="03_ticket_v1-09_heap-性能"><a class="header" href="#03_ticket_v1-09_heap-性能">性能</a></h2>
<p>堆的灵活性是有代价的：堆分配比栈分配<strong>慢</strong>。涉及更多的管理操作！如果你阅读关于性能优化的文章，往往会建议你尽量减少堆分配，并尽可能优先使用栈上分配的数据。</p>
<h2 id="03_ticket_v1-09_heap-string的内存布局"><a class="header" href="#03_ticket_v1-09_heap-string的内存布局"><code>String</code>的内存布局</a></h2>
<p>当你创建一个类型为<code>String</code>的局部变量时，Rust被迫在堆上分配<sup class="footnote-reference"><a href="#03_ticket_v1-09_heap-empty">1</a></sup>：它事先不知道你要放入多少文本，因此无法在栈上预留正确大小的空间。但<code>String</code>并非完全堆分配，它也在栈上保留了一些数据。具体来说：</p>
<ul>
<li>指向你在堆上预留区域的<strong>指针</strong>。</li>
<li>字符串的<strong>长度</strong>，即字符串中有多少字节。</li>
<li>字符串的<strong>容量</strong>，即在堆上预留了多少字节。</li>
</ul>
<p>让我们通过一个例子更好地理解这一点：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
<span class="boring">}</span></code></pre></pre>
<p>如果运行这段代码，内存将如下布局：</p>
<pre><code>      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>我们要求一个可以容纳最多5字节文本的<code>String</code>。<code>String::with_capacity</code>去到分配器那里请求5字节的堆内存。分配器返回指向该内存块起始位置的指针。不过，<code>String</code>是空的。在栈上，我们通过区分长度和容量来记录这个信息：这个<code>String</code>最多可以容纳5字节，但目前它实际持有0字节的文本。</p>
<p>如果你向<code>String</code>中推送一些文本，情况就会改变：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push_str("Hey");
<span class="boring">}</span></code></pre></pre>
<pre><code>      +---------+--------+----------+
Stack | pointer | length | capacity |
      |    |    |   3    |    5     |
      +----|----+--------+----------+
           |       
           |       
           v       
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p><code>s</code>现在持有3字节的文本。它的长度更新为3，但容量保持为5。堆上的5个字节中有3个用于存储字符<code>嘿</code>。</p>
<h3 id="03_ticket_v1-09_heap-usize"><a class="header" href="#03_ticket_v1-09_heap-usize"><code>usize</code></a></h3>
<p>我们在栈上存储指针、长度和容量需要多少空间？这取决于你运行机器的<strong>架构</strong>。</p>
<p>机器上的每个内存位置都有一个<a href="https://en.wikipedia.org/wiki/Memory_address"><strong>地址</strong></a>，通常表示为无符号整数。根据地址空间的最大大小（即你的机器可以寻址多少内存），这个整数可以有不同的大小。大多数现代机器使用32位或64位地址空间。</p>
<p>Rust通过提供<code>usize</code>类型抽象了这些与架构相关的细节：一个无符号整数，其大小与在你的机器上所需寻址内存的字节数相同。在32位机器上，<code>usize</code>等同于<code>u32</code>。在64位机器上，它匹配<code>u64</code>。</p>
<p>容量、长度和指针在Rust中都表示为<code>usize</code><sup class="footnote-reference"><a href="#03_ticket_v1-09_heap-equivalence">2</a></sup>。</p>
<h3 id="03_ticket_v1-09_heap-堆上没有stdmemsize_of"><a class="header" href="#03_ticket_v1-09_heap-堆上没有stdmemsize_of">堆上没有<code>std::mem::size_of</code></a></h3>
<p><code>std::mem::size_of</code>返回类型在栈上会占用的空间量，这也被称为<strong>类型的大小</strong>。</p>
<blockquote>
<p>那么<code>String</code>在堆上管理的内存缓冲区呢？难道那不是<code>String</code>大小的一部分吗？</p>
</blockquote>
<p>不！那个堆分配是<code>String</code>正在管理的一个<strong>资源</strong>。编译器并不将其视为<code>String</code>类型的一部分。</p>
<p><code>std::mem::size_of</code>不知道（也不关心）类型可能通过指针管理或引用的额外堆分配数据，如<code>String</code>的情况，因此它不跟踪其大小。</p>
<p>不幸的是，没有<code>std::mem::size_of</code>的等价物来衡量某个值在运行时分配的堆内存量。某些类型可能提供了检查其堆使用情况的方法（例如<code>String</code>的<code>capacity</code>方法），但在Rust中没有通用的“API”来检索运行时堆使用情况。然而，你可以使用内存分析工具（例如<a href="https://valgrind.org/docs/manual/dh-manual.html">DHAT</a>或<a href="https://docs.rs/dhat/latest/dhat/">自定义分配器</a>）来检查程序的堆使用情况。</p>
<h2 id="03_ticket_v1-09_heap-参考"><a class="header" href="#03_ticket_v1-09_heap-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/09_heap</code></li>
</ul>
<div class="footnote-definition" id="03_ticket_v1-09_heap-empty"><sup class="footnote-definition-label">1</sup>
<p>如果你创建一个<strong>空</strong>的<code>String</code>（即<code>String::new()</code>），标准库实际上并不会分配堆内存。首次向其中推送数据时才会预留堆内存。</p>
</div>
<div class="footnote-definition" id="03_ticket_v1-09_heap-equivalence"><sup class="footnote-definition-label">2</sup>
<p>指针的大小也取决于操作系统。在某些环境中，指针比内存地址<strong>大</strong>（例如<a href="https://blog.acolyer.org/2019/05/28/cheri-abi/">CHERI</a>）。Rust做了一个简化的假设，即指针和内存地址的大小相同，这对大多数你可能遇到的现代系统来说都是正确的。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-10_references_in_memory"></div><h1 id="03_ticket_v1-10_references_in_memory-引用"><a class="header" href="#03_ticket_v1-10_references_in_memory-引用">引用</a></h1>
<p>那么引用，如 <code>&amp;String</code> 或 <code>&amp;mut String</code>，它们在内存中是如何表示的呢？</p>
<p>Rust 中的大多数引用<sup class="footnote-reference"><a href="#03_ticket_v1-10_references_in_memory-fat">1</a></sup>在内存中都是以指向内存位置的指针形式表示的。因此，它们的大小与指针的大小相同，即 <code>usize</code>。</p>
<p>你可以使用 <code>std::mem::size_of</code> 来验证这一点：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(std::mem::size_of::&lt;&amp;String&gt;(), 8);
assert_eq!(std::mem::size_of::&lt;&amp;mut String&gt;(), 8);
<span class="boring">}</span></code></pre></pre>
<p>特别是，一个 <code>&amp;String</code> 是指向存储 <code>String</code> 元数据的内存位置的指针。如果你运行这段代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("嘿");
let r = &amp;s;
<span class="boring">}</span></code></pre></pre>
<p>在内存中你会得到类似这样的布局：</p>
<pre><code>           --------------------------------------
           |                                    |         
      +----v----+--------+----------+      +----|----+
Stack | pointer | length | capacity |      | pointer |
      |    |    |   3    |    5     |      |         |
      +----|----+--------+----------+      +---------+
           |        s                           r
           |       
           v       
       +---+---+---+---+---+
Heap   | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>可以说，这是一个指向指向堆分配数据的指针的指针。<code>&amp;mut String</code> 的情况也是如此。</p>
<h2 id="03_ticket_v1-10_references_in_memory-并非所有指针都指向堆"><a class="header" href="#03_ticket_v1-10_references_in_memory-并非所有指针都指向堆">并非所有指针都指向堆</a></h2>
<p>上述例子澄清了一点：并非所有指针都指向堆。它们只是指向一个内存位置，这个位置_可能_在堆上，但不一定是。</p>
<h2 id="03_ticket_v1-10_references_in_memory-参考"><a class="header" href="#03_ticket_v1-10_references_in_memory-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/10_references_in_memory</code></li>
</ul>
<div class="footnote-definition" id="03_ticket_v1-10_references_in_memory-fat"><sup class="footnote-definition-label">1</sup>
<p>在课程的<a href="#04_traits-05_str_slice">后续部分</a>中，我们将讨论<strong>胖指针</strong>，即带有附加元数据的指针。顾名思义，它们比本章讨论的指针（也称为<strong>瘦指针</strong>）更大。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-11_destructor"></div><h1 id="03_ticket_v1-11_destructor-析构函数"><a class="header" href="#03_ticket_v1-11_destructor-析构函数">析构函数</a></h1>
<p>在介绍堆时，我们提到你需要负责释放你分配的内存。在介绍借用检查器时，我们也说过，在Rust中你很少需要直接管理内存。</p>
<p>这两个陈述起初可能看似矛盾。让我们通过引入<strong>作用域</strong>和<strong>析构函数</strong>来看看它们是如何结合在一起的。</p>
<h2 id="03_ticket_v1-11_destructor-作用域"><a class="header" href="#03_ticket_v1-11_destructor-作用域">作用域</a></h2>
<p>变量的<strong>作用域</strong>是指Rust代码中该变量有效或<strong>存活</strong>的区域。</p>
<p>变量的作用域从其声明开始。当以下之一发生时结束：</p>
<ol>
<li>变量被声明的代码块（即<code>{}</code>之间）结束
<pre><pre class="playground"><code class="language-rust">fn main() {
   // `x` is not yet in scope here
   let y = "Hello".to_string();
   let x = "World".to_string(); // &lt;-- x's scope starts here...
   let h = "!".to_string(); //   |
} //  &lt;-------------- ...and ends here</code></pre></pre>
</li>
<li>变量的所有权转移到其他人（例如，函数或其他变量）
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
   // Do something [...]
}

fn main() {
    let s = "Hello".to_string(); // &lt;-- s's scope starts here...
                //                    | 
    compute(s); // &lt;------------------- ..and ends here
                //   because `s` is moved into `compute`
} </code></pre></pre>
</li>
</ol>
<h2 id="03_ticket_v1-11_destructor-析构函数-1"><a class="header" href="#03_ticket_v1-11_destructor-析构函数-1">析构函数</a></h2>
<p>当一个值的所有者超出作用域时，Rust会调用其<strong>析构函数</strong>。析构函数试图清理该值使用的资源，尤其是它分配的内存。</p>
<p>你可以通过将值传递给<code>std::mem::drop</code>来手动调用析构函数。这就是为什么Rust开发者常会说某个值已经被<strong>丢弃</strong>，以此来表达一个值已经超出作用域且其析构函数已被调用。</p>
<h3 id="03_ticket_v1-11_destructor-可视化解构点"><a class="header" href="#03_ticket_v1-11_destructor-可视化解构点">可视化解构点</a></h3>
<p>我们可以通过插入显式的<code>drop</code>调用来“拼写”出编译器为我们所做的操作。回到之前的例子：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
}</code></pre></pre>
<p>这等同于：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
   // Variables are dropped in reverse order of declaration
   drop(h);
   drop(x);
   drop(y);
}</code></pre></pre>
<p>来看第二个例子，其中<code>s</code>的所有权被转移到<code>compute</code>：</p>
<pre><pre class="playground"><code class="language-rust">fn compute(s: String) {
   // Do something [...]
}

fn main() {
   let s = "Hello".to_string();
   compute(s);
}</code></pre></pre>
<p>它等同于：</p>
<pre><pre class="playground"><code class="language-rust">fn compute(t: String) {
    // Do something [...]
    drop(t); // &lt;-- Assuming `t` wasn't dropped or moved 
             //     before this point, the compiler will call 
             //     `drop` here, when it goes out of scope
}

fn main() {
    let s = "Hello".to_string();
    compute(s);
}</code></pre></pre>
<p>注意区别：尽管在<code>main</code>中调用<code>compute</code>后<code>s</code>不再有效，但在<code>main</code>中并没有<code>s</code>的<code>drop(s)</code>。
当你将值的所有权转移到函数时，你也正在<strong>转移清理它的责任</strong>。</p>
<p>这确保了一个值的析构函数<strong>至多被调用一次</strong>，设计上防止了<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory">双重释放漏洞</a>。</p>
<h3 id="03_ticket_v1-11_destructor-丢弃后的使用"><a class="header" href="#03_ticket_v1-11_destructor-丢弃后的使用">丢弃后的使用</a></h3>
<p>如果你尝试在值被丢弃后使用它会发生什么？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "Hello".to_string();
drop(x);
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>如果你尝试编译这段代码，你会收到错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:4:20
  |
3 |     drop(x);
  |          - value moved here
4 |     println!("{}", x);
  |                    ^ value used here after move
<span class="boring">}</span></code></pre></pre>
<p>Drop<strong>消耗</strong>掉它被调用的对象，意味着调用后该对象不再有效。因此，编译器会阻止你使用它，避免了<a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">释放后使用漏洞</a>。</p>
<h3 id="03_ticket_v1-11_destructor-引用的丢弃"><a class="header" href="#03_ticket_v1-11_destructor-引用的丢弃">引用的丢弃</a></h3>
<p>如果变量包含引用会怎样？
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42i32;
let y = &amp;x;
drop(y);
<span class="boring">}</span></code></pre></pre>
<p>当你调用<code>drop(y)</code>...什么也没发生。如果你真的尝试编译这段代码，你会收到警告：</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference 
         instead of an owned value does nothing
 --&gt; src/main.rs:4:5
  |
4 |     drop(y);
  |     ^^^^^-^
  |          |
  |          argument has type `&amp;i32`
  |
</code></pre>
<p>这回到了我们之前所说：我们只想调用一次析构函数。你可能对同一个值有多个引用——如果我们中的一个超出作用域时就调用它们指向的值的析构函数，其他引用会怎么样？
它们会指向一个不再有效的内存位置：一个所谓的<a href="https://en.wikipedia.org/wiki/Dangling_pointer"><strong>悬挂指针</strong></a>，是<a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><strong>释放后使用漏洞</strong></a>的近亲。Rust的所有权制度从设计上排除了这类漏洞。</p>
<h2 id="03_ticket_v1-11_destructor-参考资料"><a class="header" href="#03_ticket_v1-11_destructor-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/03_ticket_v1/11_destructor</code></li>
</ul>
<div class="footnote-definition" id="03_ticket_v1-11_destructor-leak"><sup class="footnote-definition-label">1</sup>
<p>Rust不保证析构函数一定会执行。例如，如果你选择<a href="#07_threads-03_leak">故意泄露内存</a>，它们就不会执行。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="03_ticket_v1-12_outro"></div><h1 id="03_ticket_v1-12_outro-总结回顾"><a class="header" href="#03_ticket_v1-12_outro-总结回顾">总结回顾</a></h1>
<p>本章中，我们已经涵盖了Rust的许多基础概念。在继续前进之前，让我们通过最后一个练习来巩固所学的知识。这次你将得到最少的指引——仅有的是练习描述和测试用例来引导你。</p>
<h2 id="03_ticket_v1-12_outro-练习参考"><a class="header" href="#03_ticket_v1-12_outro-练习参考">练习参考</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/03_ticket_v1/12_outro</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-00_intro"></div><h1 id="04_traits-00_intro-特性trait"><a class="header" href="#04_traits-00_intro-特性trait">特性（Trait）</a></h1>
<p>在前一章中，我们学习了Rust的类型和所有权系统的基础知识。现在是时候深入研究一下了：我们将探索<strong>特质</strong>，Rust对接口的理解。</p>
<p>一旦你了解了特质，你就会开始到处看到它们的踪迹。实际上，你已经在前一章中看到了特质的实际应用，比如<code>.into()</code>调用以及诸如<code>==</code>和<code>+</code>这样的运算符。</p>
<p>除了特质这一概念之外，我们还将涵盖Rust标准库中定义的一些关键特质：</p>
<ul>
<li>运算符特质（例如 <code>Add</code>、<code>Sub</code>、<code>PartialEq</code> 等）</li>
<li><code>From</code> 和 <code>Into</code>，用于不可失败的转换</li>
<li><code>Clone</code> 和 <code>Copy</code>，用于复制值</li>
<li><code>Deref</code> 和解引用强制转换</li>
<li><code>Sized</code>，标记具有已知大小的类型</li>
<li><code>Drop</code>，用于自定义清理逻辑</li>
</ul>
<p>既然我们将要讨论转换，我们也会借此机会填补前一章中的一些“知识空白”——比如，<code>"A title"</code>确切是什么？也是时候更深入学习切片了！</p>
<h2 id="04_traits-00_intro-参考资料"><a class="header" href="#04_traits-00_intro-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/04_traits/00_intro</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-01_trait"></div><p>让我们再次审视我们的 <code>Ticket</code> 类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>迄今为止，我们的所有测试都是使用 <code>Ticket</code> 的字段进行断言的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(ticket.title(), "一个新的标题");
<span class="boring">}</span></code></pre></pre>
<p>如果我们想直接比较两个 <code>Ticket</code> 实例会怎样呢？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket1 = Ticket::new(/* ... */);
let ticket2 = Ticket::new(/* ... */);
ticket1 == ticket2
<span class="boring">}</span></code></pre></pre>
<p>编译器会阻止我们：</p>
<pre><code class="language-text">error[E0369]: binary operation `==` cannot be applied to type `Ticket`
  --&gt; src/main.rs:18:13
   |
18 |     ticket1 == ticket2
   |     ------- ^^ ------- Ticket
   |     |
   |     Ticket
   |
note: an implementation of `PartialEq` might be missing for `Ticket`
</code></pre>
<p><code>Ticket</code> 是一个新类型。开箱即用，它<strong>没有任何行为</strong>附着于其上**。Rust 不会神奇地推断如何比较两个 <code>Ticket</code> 实例，仅仅因为它们包含了 <code>String</code>s。</p>
<p>不过，Rust 编译器正把我们推向正确的方向：它提示我们可能缺少了 <code>PartialEq</code> 的实现。<code>PartialEq</code> 是一个<strong>特性</strong>！</p>
<h2 id="04_traits-01_trait-特性是什么"><a class="header" href="#04_traits-01_trait-特性是什么">特性是什么？</a></h2>
<p>特性是Rust定义<strong>接口</strong>的方式。<br />
特性定义了一组类型必须实现的方法，以满足特性的契约。</p>
<h3 id="04_traits-01_trait-定义特性"><a class="header" href="#04_traits-01_trait-定义特性">定义特性</a></h3>
<p>特性定义的语法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait &lt;TraitName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>例如，我们可能会定义一个名为 <code>MaybeZero</code> 的特性，要求其实现者定义一个 <code>is_zero</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MaybeZero {
    fn is_zero(self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="04_traits-01_trait-实现特性"><a class="header" href="#04_traits-01_trait-实现特性">实现特性</a></h3>
<p>为类型实现特性时，我们使用 <code>impl</code> 关键字，就像我们为常规<sup class="footnote-reference"><a href="#04_traits-01_trait-inherent">1</a></sup>方法那样，但语法略有不同：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;TraitName&gt; for &lt;TypeName&gt; {
    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
        // Method body
    }
}
<span class="boring">}</span></code></pre></pre>
<p>例如，为自定义数字类型 <code>WrappingU32</code> 实现 <code>MaybeZero</code> 特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WrappingU32 {
    inner: u32,
}

impl MaybeZero for WrappingU32 {
    fn is_zero(self) -&gt; bool {
        self.inner == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="04_traits-01_trait-调用特性方法"><a class="header" href="#04_traits-01_trait-调用特性方法">调用特性方法</a></h3>
<p>调用特性方法时，我们使用<code>.</code>操作符，就像调用常规方法一样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = WrappingU32 { inner: 5 };
assert!(!x.is_zero());
<span class="boring">}</span></code></pre></pre>
<p>要调用特性方法，两件事必须为真：</p>
<ul>
<li>类型必须实现了该特性。</li>
<li>特性必须在作用域内。</li>
</ul>
<p>为满足后者，你可能需要添加一个 <code>use</code> 语句来引入特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::MaybeZero;
<span class="boring">}</span></code></pre></pre>
<p>如果：</p>
<ul>
<li>特性在调用发生的同一模块中定义。</li>
<li>特性定义在标准库的<strong>预置</strong>中。预置是一组自动导入到每个Rust程序中的特性和类型。这就像是在每个Rust模块开头添加了 <code>use std::prelude::*;</code>。</li>
</ul>
<p>你可以在Rust文档中找到预置中特性和类型的列表：<a href="https://doc.rust-lang.org/std/prelude/index.html">https://doc.rust-lang.org/std/prelude/index.html</a>。</p>
<h2 id="04_traits-01_trait-参考资料"><a class="header" href="#04_traits-01_trait-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/04_traits/01_trait</code></li>
</ul>
<div class="footnote-definition" id="04_traits-01_trait-inherent"><sup class="footnote-definition-label">1</sup>
<p>直接定义在一个类型上，而不使用特性的方法，也称为<strong>固有方法</strong>。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-02_orphan_rule"></div><h1 id="04_traits-02_orphan_rule-实现特性"><a class="header" href="#04_traits-02_orphan_rule-实现特性">实现特性</a></h1>
<p>当一个类型是在另一个crate中定义的（例如，来自Rust标准库的<code>u32</code>），你不能直接为它定义新的方法。如果你尝试这样做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl u32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会报错：</p>
<pre><code class="language-text">error[E0390]: cannot define inherent `impl` for primitive types
  |
1 | impl u32 {
  | ^^^^^^^^
  |
  = help: consider using an extension trait instead
</code></pre>
<h2 id="04_traits-02_orphan_rule-扩展特性"><a class="header" href="#04_traits-02_orphan_rule-扩展特性">扩展特性</a></h2>
<p><strong>扩展特性</strong>是一种主要目的是向外部类型（如<code>u32</code>）附加新方法的特性。这正是你在上一个练习中采用的模式，通过定义<code>IsEven</code>特性然后为<code>i32</code>和<code>u32</code>实现它。只要<code>IsEven</code>在作用域内，你就可以自由地在这些类型上调用<code>is_even</code>方法。</p>
<pre><pre class="playground"><code class="language-rust">// 引入特性
use my_library::IsEven;

fn main() {
    // 在实现了它的类型上调用其方法
    if 4.is_even() {
        // [...]
    }
}</code></pre></pre>
<h2 id="04_traits-02_orphan_rule-单一实现"><a class="header" href="#04_traits-02_orphan_rule-单一实现">单一实现</a></h2>
<p>在你能编写的特性实现中存在一些限制。最简单且最直接的一个是：你不能在一个crate中，为同一个类型两次实现同一个特性。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        true
    }
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会拒绝它：</p>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `IsEven` for type `u32`
   |
5  | impl IsEven for u32 {
   | ------------------- first implementation here
...
11 | impl IsEven for u32 {
   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`
</code></pre>
<p>当在<code>u32</code>值上调用<code>IsEven::is_even</code>时，不能存在任何关于应该使用哪个特性实现的歧义，因此只能有一个。</p>
<h2 id="04_traits-02_orphan_rule-孤儿规则"><a class="header" href="#04_traits-02_orphan_rule-孤儿规则">孤儿规则</a></h2>
<p>当涉及多个crate时，情况变得更加微妙。特别地，以下至少有一项必须为真：</p>
<ul>
<li>特性在当前crate中定义</li>
<li>实现者类型在当前crate中定义</li>
</ul>
<p>这被称为Rust的<strong>孤儿规则</strong>。其目的是使方法解析过程无歧义。</p>
<p>想象以下情形：</p>
<ul>
<li>Crate <code>A</code> 定义了<code>IsEven</code>特性</li>
<li>Crate <code>B</code> 为<code>u32</code>实现了<code>IsEven</code></li>
<li>Crate <code>C</code> 提供了<code>IsEven</code>特性针对<code>u32</code>的不同实现</li>
<li>Crate <code>D</code> 同时依赖于<code>B</code>和<code>C</code>，并调用<code>1.is_even()</code></li>
</ul>
<p>应该使用哪个实现？是<code>B</code>中定义的吗？还是<code>C</code>中定义的？没有明确的答案，因此定义了孤儿规则以防止这种情况发生。得益于孤儿规则，无论是crate <code>B</code>还是crate <code>C</code>都不会编译成功。</p>
<h2 id="04_traits-02_orphan_rule-参考资料"><a class="header" href="#04_traits-02_orphan_rule-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/04_traits/02_orphan_rule</code></li>
</ul>
<h2 id="04_traits-02_orphan_rule-进一步阅读"><a class="header" href="#04_traits-02_orphan_rule-进一步阅读">进一步阅读</a></h2>
<ul>
<li>如上所述的孤儿规则有一些例外和注意事项。如果你想了解其细节，请查阅<a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence">参考文档</a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-03_operator_overloading"></div><h1 id="04_traits-03_operator_overloading-运算符重载"><a class="header" href="#04_traits-03_operator_overloading-运算符重载">运算符重载</a></h1>
<p>既然我们对特质（traits）有了基本的认识，现在让我们回过头来探讨一下<strong>运算符重载</strong>（operator overloading）。</p>
<p>运算符重载是指为诸如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>==</code>、<code>!=</code>等运算符定义自定义行为的能力。</p>
<p>在Rust中，运算符是通过特质来实现的。对于每个运算符，都存在一个相应的特质来定义该运算符的行为。通过为你的类型实现这些特质，你就能<strong>解锁</strong>使用对应的运算符。</p>
<p>例如，<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code>特质</a>定义了<code>==</code>和<code>!=</code>这两个运算符的行为：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 从Rust标准库中简化得来的`PartialEq`特质定义
pub trait PartialEq {
    // 必须实现的方法
    // `Self`是一个Rust关键字，表示“实现该特质的类型”
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    // 默认提供的方法
    fn ne(&amp;self, other: &amp;Self) -&gt; bool { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>当你编写<code>x == y</code>时，编译器会查找<code>x</code>和<code>y</code>类型的<code>PartialEq</code>特质的实现，并将<code>x == y</code>替换为<code>x.eq(y)</code>。这是一种语法糖！</p>
<p>以下是主要运算符与其对应特质的对照表：</p>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>特质</th></tr></thead><tbody>
<tr><td><code>+</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr>
<tr><td><code>-</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr>
<tr><td><code>*</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr>
<tr><td><code>/</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr>
<tr><td><code>%</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr>
<tr><td><code>==</code> 和 <code>!=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td></tr>
<tr><td><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td></tr>
</tbody></table>
</div>
<p>算术运算符位于<code>std::ops</code>模块中，而比较运算符则位于<code>std::cmp</code>模块。</p>
<h3 id="04_traits-03_operator_overloading-默认实现"><a class="header" href="#04_traits-03_operator_overloading-默认实现">默认实现</a></h3>
<p>关于<code>PartialEq::ne</code>的注释说明它是“提供的方法”。这意味着<code>PartialEq</code>在其特质定义中为<code>ne</code>提供了一个<strong>默认实现</strong>——即定义片段中的省略号<code>{ ... }</code>所代表的部分。如果展开这部分，它看起来是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        !self.eq(other)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这正如你所料：<code>ne</code>是<code>eq</code>的否定。由于提供了默认实现，当你为自己的类型实现<code>PartialEq</code>时，可以省略实现<code>ne</code>。实现<code>eq</code>就足够了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WrappingU8 {
    inner: u8,
}

impl PartialEq for WrappingU8 {
    fn eq(&amp;self, other: &amp;WrappingU8) -&gt; bool {
        self.inner == other.inner
    }
    
    // 这里没有`ne`的实现
}
<span class="boring">}</span></code></pre></pre>
<p>然而，你并不一定要使用默认实现。在实现特质时，你可以选择覆盖它：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyType;

impl PartialEq for MyType {
    fn eq(&amp;self, other: &amp;MyType) -&gt; bool {
        // 自定义实现
    }

    fn ne(&amp;self, other: &amp;MyType) -&gt; bool {
        // 自定义实现
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="04_traits-03_operator_overloading-参考练习"><a class="header" href="#04_traits-03_operator_overloading-参考练习">参考练习</a></h3>
<ul>
<li>本节的练习位于<code>exercises/04_traits/03_operator_overloading</code>目录下。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-04_derive"></div><h1 id="04_traits-04_derive-派生宏"><a class="header" href="#04_traits-04_derive-派生宏">派生宏</a></h1>
<p>实现<code>PartialEq</code>对于<code>Ticket</code>来说有点繁琐，对吧？你不得不手动比较结构体中的每一个字段。</p>
<h2 id="04_traits-04_derive-解构语法"><a class="header" href="#04_traits-04_derive-解构语法">解构语法</a></h2>
<p>而且，这种实现方式很脆弱：如果结构体的定义发生变化（比如添加了一个新字段），你还得记得更新<code>PartialEq</code>的实现。</p>
<p>为了降低风险，你可以使用<strong>解构</strong>来将结构体分解为各个字段：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果<code>Ticket</code>的定义发生了变化，编译器将会报错，提示你的解构不再全面。你也可以重命名结构体字段，以避免变量遮蔽：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq for Ticket {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        let Ticket {
            title,
            description,
            status,
        } = self;
        let Ticket {
            title: other_title,
            description: other_description,
            status: other_status,
        } = other;
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>解构是一个有用的编程模式，但还有一种更便捷的方式：<strong>派生宏</strong>（derive macros）。</p>
<h2 id="04_traits-04_derive-宏"><a class="header" href="#04_traits-04_derive-宏">宏</a></h2>
<p>在之前的练习中，你已经遇到过一些宏：</p>
<ul>
<li>测试用例中的<code>assert_eq!</code>和<code>assert!</code></li>
<li>向控制台打印的<code>println!</code></li>
</ul>
<p>Rust的宏是<strong>代码生成器</strong>。它们根据你提供的输入生成新的Rust代码，这段生成的代码随后会与程序的其他部分一起被编译。有些宏是内置在Rust标准库中的，但你也可以编写自己的宏。虽然本课程不涉及创建宏，但你可以在“进一步阅读”部分找到一些有用的信息。</p>
<h3 id="04_traits-04_derive-检视宏"><a class="header" href="#04_traits-04_derive-检视宏">检视宏</a></h3>
<p>一些集成开发环境（IDE）允许你展开宏以检查生成的代码。如果IDE不支持此功能，你可以使用<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>工具。</p>
<h3 id="04_traits-04_derive-派生宏-1"><a class="header" href="#04_traits-04_derive-派生宏-1">派生宏</a></h3>
<p><strong>派生宏</strong>是Rust宏的一种特殊形式。它作为属性放在结构体定义的顶部。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq)]
struct Ticket {
    title: String,
    description: String,
    status: String,
}
<span class="boring">}</span></code></pre></pre>
<p>派生宏用于自动为自定义类型实现一些常见（且显而易见）的特质。在上面的例子中，<code>PartialEq</code>特质自动为<code>Ticket</code>实现。如果你展开这个宏，会看到生成的代码在功能上等同于你手动编写的代码，尽管读起来可能稍显复杂：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[automatically_derived]
impl ::core::cmp::PartialEq for Ticket {
    #[inline]
    fn eq(&amp;self, other: &amp;Ticket) -&gt; bool {
        self.title == other.title &amp;&amp; self.description == other.description
            &amp;&amp; self.status == other.status
    }
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会在可能的情况下提示你使用派生特质。</p>
<h2 id="04_traits-04_derive-参考资料"><a class="header" href="#04_traits-04_derive-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于<code>exercises/04_traits/04_derive</code>目录下。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-05_str_slice"></div><h1 id="04_traits-05_str_slice-字符串切片"><a class="header" href="#04_traits-05_str_slice-字符串切片">字符串切片</a></h1>
<p>在之前的章节中，你已经见过不少<strong>字符串字面量</strong>被用于代码中，比如 <code>"待办事项"</code> 或 <code>"票据描述"</code>。它们后面常常跟着 <code>.to_string()</code> 或 <code>.into()</code> 的调用。现在是时候理解这么做的原因了！</p>
<h2 id="04_traits-05_str_slice-字符串字面量"><a class="header" href="#04_traits-05_str_slice-字符串字面量">字符串字面量</a></h2>
<p>通过将原始文本包含在双引号中，你可以定义一个字符串字面量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "你好，世界！";
<span class="boring">}</span></code></pre></pre>
<p><code>s</code> 的类型是 <code>&amp;str</code>，即<strong>指向字符串切片的引用</strong>。</p>
<h2 id="04_traits-05_str_slice-内存布局"><a class="header" href="#04_traits-05_str_slice-内存布局">内存布局</a></h2>
<p><code>&amp;str</code> 和 <code>String</code> 是不同的类型——它们不能互换。让我们回顾一下之前探索过的 <code>String</code> 的<a href="#03_ticket_v1-09_heap">内存布局</a>。如果我们运行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
<span class="boring">}</span></code></pre></pre>
<p>在内存中会得到这样的情况：</p>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>如果你还记得，我们<a href="#03_ticket_v1-10_references_in_memory">也检查过</a> <code>&amp;String</code> 在内存中的布局：</p>
<pre><code class="language-text">      --------------------------------------
      |                                    |         
 +----v----+--------+----------+      +----|----+
 | pointer | length | capacity |      | pointer |
 |    |    |   5    |    5     |      |         |
 +----|----+--------+----------+      +---------+
      |        s                          &amp;s 
      |       
      v       
    +---+---+---+---+---+
    | H | e | l | l | o |
    +---+---+---+---+---+
</code></pre>
<p><code>&amp;String</code> 指向存储 <code>String</code> 元数据的内存位置。如果我们跟随指针，就能到达堆分配的数据，特别是字符串的第一个字节 <code>你</code>。</p>
<p>如果我们想要一个类型来表示 <code>s</code> 的<strong>子字符串</strong>呢？比如在 <code>"你好"</code> 中的 <code>"好世界"</code>？</p>
<h2 id="04_traits-05_str_slice-字符串切片-1"><a class="header" href="#04_traits-05_str_slice-字符串切片-1">字符串切片</a></h2>
<p><code>&amp;str</code> 是对字符串的一个<strong>视图</strong>，是对存储在别处的 UTF-8 字节序列的<strong>引用</strong>。例如，你可以像这样从 <code>String</code> 创建一个 <code>&amp;str</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("你好");
// 从 `String` 创建一个字符串切片引用，跳过第一个字节。
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>在内存中，它看起来像这样：</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p><code>slice</code> 在堆栈上存储了两部分信息：</p>
<ul>
<li>指向切片第一个字节的指针。</li>
<li>切片的长度。</li>
</ul>
<p><code>slice</code> 并不拥有数据，它只是指向数据：它是对 <code>String</code> 堆分配数据的<strong>引用</strong>。当 <code>slice</code> 被丢弃时，堆分配的数据不会被释放，因为它仍由 <code>s</code> 所拥有。这就是为什么 <code>slice</code> 没有 <code>容量</code> 字段的原因：它不拥有数据，所以不需要知道为数据分配了多少空间；它只关心它所引用的数据。</p>
<h2 id="04_traits-05_str_slice-str-与-string-的区别"><a class="header" href="#04_traits-05_str_slice-str-与-string-的区别"><code>&amp;str</code> 与 <code>&amp;String</code> 的区别</a></h2>
<p>一般来说，当你需要对文本数据的引用时，优先使用 <code>&amp;str</code> 而不是 <code>&amp;String</code>。<code>&amp;str</code> 更加灵活，并且通常被认为是 Rust 代码中更符合习惯的用法。</p>
<p>如果一个方法返回 <code>&amp;String</code>，你是在承诺某处存在与你返回引用所匹配的堆分配的 UTF-8 文本。相反，如果一个方法返回 <code>&amp;str</code>，则拥有更多的灵活性：你只是说某处有一段文本数据，并且其中的一部分与你需要的匹配，因此你返回对这部分的引用。</p>
<h2 id="04_traits-05_str_slice-参考练习"><a class="header" href="#04_traits-05_str_slice-参考练习">参考练习</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/05_str_slice</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-06_deref"></div><h1 id="04_traits-06_deref-deref-特性"><a class="header" href="#04_traits-06_deref-deref-特性"><code>Deref</code> 特性</a></h1>
<p>在上一练习中，你其实没做太多工作，对吧？将</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;String {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>修改为</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn title(&amp;self) -&gt; &amp;str {
        &amp;self.title
    }
}
<span class="boring">}</span></code></pre></pre>
<p>就是为了让代码编译通过并使测试成功。不过，你的脑海中或许会响起警钟。</p>
<h2 id="04_traits-06_deref-看似不应行得通却偏偏可行"><a class="header" href="#04_traits-06_deref-看似不应行得通却偏偏可行">看似不应行得通，却偏偏可行</a></h2>
<p>让我们回顾一下事实：</p>
<ul>
<li><code>self.title</code> 是一个 <code>String</code></li>
<li>因此，<code>&amp;self.title</code> 是一个 <code>&amp;String</code></li>
<li>修改后的 <code>title</code> 方法输出的是 <code>&amp;str</code></li>
</ul>
<p>你可能会期待编译错误，对吧？比如“预期 &amp;String，发现 &amp;str”之类的。然而，它就这么正常工作了。<strong>为何</strong>如此**？</p>
<h2 id="04_traits-06_deref-deref-特性来救援"><a class="header" href="#04_traits-06_deref-deref-特性来救援"><code>Deref</code> 特性来救援</a></h2>
<p><code>Deref</code> 特性是名为<strong>解引用强制</strong>（deref 强制）这一语言特性的背后机制。该特性在标准库的 <code>std::ops</code> 模块中定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 我暂时简化了定义。
// 后面我们会看到完整定义。
pub trait Deref {
    type Target;
    
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}</span></code></pre></pre>
<p><code>type Target</code> 是一个<strong>关联类型</strong>，它是实现特质时必须指定的具体类型占位符。</p>
<h2 id="04_traits-06_deref-解引用强制"><a class="header" href="#04_traits-06_deref-解引用强制">解引用强制</a></h2>
<p>通过为类型 <code>T</code> 实现 <code>Deref&lt;Target = U&gt;</code>，你实际上是告诉编译器 <code>&amp;T</code> 和 <code>&amp;U</code> 在某种程度上可以互换。具体而言，你会得到以下行为：</p>
<ul>
<li>对 <code>T</code> 的引用会被隐式转换为对 <code>U</code> 的引用（即 <code>&amp;T</code> 变为 <code>&amp;U</code>）</li>
<li>你可以对 <code>&amp;T</code> 调用所有在 <code>U</code> 上定义的接受 <code>&amp;self</code> 作为输入的方法。</li>
</ul>
<p>关于解引用操作符 <code>*</code> 还有一点，但我们目前不需要了解（如果好奇可以查阅<code>std</code> 的文档）。</p>
<h2 id="04_traits-06_deref-string-实现了-deref"><a class="header" href="#04_traits-06_deref-string-实现了-deref"><code>String</code> 实现了 <code>Deref</code></a></h2>
<p><code>String</code> 通过 <code>Target = str</code> 实现了 <code>Deref</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Deref for String {
    type Target = str;
    
    fn deref(&amp;self) -&gt; &amp;str {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>得益于这个实现和解引用强制，当需要时 <code>&amp;String</code> 会自动转换为 <code>&amp;str</code>。</p>
<h2 id="04_traits-06_deref-不要慎用解引用强制"><a class="header" href="#04_traits-06_deref-不要慎用解引用强制">不要慎用解引用强制</a></h2>
<p>解引用强制是一个强大的特性，但也可能导致混淆。自动类型转换会使代码更难读且难以理解。如果同一名称的方法既定义在 <code>T</code> 上也在 <code>U</code> 上，到底会调用哪个？</p>
<p>在课程的后续部分，我们将探讨解引用强制最安全的使用场景：智能指针。</p>
<h2 id="04_traits-06_deref-参考资料"><a class="header" href="#04_traits-06_deref-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/06_deref</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-07_sized"></div><h1 id="04_traits-07_sized-sized-特性深入探讨"><a class="header" href="#04_traits-07_sized-sized-特性深入探讨"><code>Sized</code> 特性深入探讨</a></h1>
<p>即使在研究了 <code>deref</code> 强制转换之后，<code>&amp;str</code> 仍然有着更多不为人知的细节。根据我们之前关于<a href="#03_ticket_v1-10_references_in_memory">内存布局</a>的讨论，将 <code>&amp;str</code> 表示为堆栈上的单一 <code>usize</code>（一个指针）似乎是合理的。然而事实并非如此。<code>&amp;str</code> 在指针旁边存储了一些<strong>元数据</strong>：它所指向切片的长度。回顾<a href="#04_traits-05_str_slice">前一节</a>中的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::with_capacity(5);
s.push_str("Hello");
// 从 `String` 创建一个字符串切片引用，跳过第一个字节。
let slice: &amp;str = &amp;s[1..];
<span class="boring">}</span></code></pre></pre>
<p>在内存中，我们得到如下布局：</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p>这是怎么回事？</p>
<h2 id="04_traits-07_sized-动态大小类型"><a class="header" href="#04_traits-07_sized-动态大小类型">动态大小类型</a></h2>
<p><code>str</code> 是一个<strong>动态大小类型</strong>（Dynamically Sized Type, DST）。DST是一种其大小在编译时未知的类型。每当你拥有一个指向DST的引用，比如<code>&amp;str</code>时，它必须包含额外的关于所指数据的信息。它是一个<strong>胖指针</strong>。对于<code>&amp;str</code>而言，它存储了所指向切片的长度。在课程的其余部分中，我们将看到更多DST的例子。</p>
<h2 id="04_traits-07_sized-sized-特性"><a class="header" href="#04_traits-07_sized-sized-特性"><code>Sized</code> 特性</a></h2>
<p>Rust的标准库定义了一个叫做 <code>Sized</code> 的特性。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sized {
    // 这是一个空特性，无需实现任何方法。}
<span class="boring">}</span></code></pre></pre>
<p>如果一个类型的大小在编译时已知，则它是 <code>Sized</code> 的。换句话说，它不是DST。</p>
<h3 id="04_traits-07_sized-标记号特质"><a class="header" href="#04_traits-07_sized-标记号特质">标记号特质</a></h3>
<p><code>Sized</code> 是你遇到的第一个<strong>标记特质</strong>的例子。标记特质不需要实现任何方法。它不定义任何行为。它仅用于<strong>标记</strong>类型具有某些属性。
这个标记随后被编译器利用，以启用特定行为或优化。</p>
<h3 id="04_traits-07_sized-自动特质"><a class="header" href="#04_traits-07_sized-自动特质">自动特质</a></h3>
<p>特别地，<code>Sized</code> 也是一个<strong>自动特质</strong>。你不需要显式实现它；编译器会根据类型的定义自动为你实现。</p>
<h3 id="04_traits-07_sized-示例"><a class="header" href="#04_traits-07_sized-示例">示例</a></h3>
<p>迄今为止我们见过的所有类型都是 <code>Sized</code> 的：<code>u32</code>、<code>String</code>、<code>bool</code> 等。</p>
<p>正如我们刚看到的，<code>str</code> 不是 <code>Sized</code> 的。<br />
然而，<code>&amp;str</code> 是 <code>Sized</code>！我们在编译时知道它的大小：两个 <code>usize</code>，一个用于指针，一个用于长度。</p>
<h2 id="04_traits-07_sized-参考资料"><a class="header" href="#04_traits-07_sized-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/07_sized</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-08_from"></div><h1 id="04_traits-08_from-from-和-into"><a class="header" href="#04_traits-08_from-from-和-into"><code>From</code> 和 <code>Into</code></a></h1>
<p>让我们回到旅程的起点：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ticket = Ticket::new("A title".into(), "A description".into(), "To-Do".into());
<span class="boring">}</span></code></pre></pre>
<p>我们现在足以解开<code>.into()</code>在这里的作用了。</p>
<h2 id="04_traits-08_from-问题所在"><a class="header" href="#04_traits-08_from-问题所在">问题所在</a></h2>
<p>这是<code>new</code>方法的签名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>我们也了解到字符串字面量，如<code>"一个标题"</code>是类型<code>&amp;str</code>。这里类型不匹配：期望一个<code>String</code>，但我们有一个<code>&amp;str</code>。这次没有魔法会拯救我们，我们需要进行<strong>转换</strong>。</p>
<h2 id="04_traits-08_from-from-和-into-1"><a class="header" href="#04_traits-08_from-from-和-into-1"><code>From</code> 和 <code>Into</code></a></h2>
<p>Rust<code>标准库为**可转换**定义了两个特性：</code>From<code>和</code>Into<code>，位于</code>std::convert`模块中。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait From&lt;T&gt; {
    fn from(value: T) -&gt; Self;}

pub trait&lt;T&gt; {
    fn into(self) -&gt; T;}
<span class="boring">}</span></code></pre></pre>
<p>这些定义展示了我们之前未见过的几个概念：<strong>Supertrait</strong>、<strong>泛型</strong>和<strong>隐式约束</strong>。我们先来拆解这些。</p>
<h3 id="04_traits-08_from-supertrait--subtrait"><a class="header" href="#04_traits-08_from-supertrait--subtrait"><code>Supertrait</code> / <code>Subtrait</code></a></h3>
<p><code>From: Sized</code>语法意味着<code>From</code>是一个<strong>Subtrait</strong><code>Sized</code>：任何实现了<code>From</code>的类型也必须实现<code>Sized</code>。或者可以说<code>Sized</code>是<code>From</code>的<strong>Supertrait</strong>。</p>
<h3 id="04_traits-08_from-泛型"><a class="header" href="#04_traits-08_from-泛型">泛型</a></h3>
<p><code>From</code>和<code>Into</code>都是<strong>泛型</strong>特性**。它们带有一个参数<code>T</code>，代表转换的类型。<code>T</code>是一个占位符，实际类型，将在实现或使用特性时指定。</p>
<h3 id="04_traits-08_from-隐式约束"><a class="header" href="#04_traits-08_from-隐式约束">隐式约束</a></h3>
<p>每次有泛型参数时，编译器都默认它实现了<code>Sized</code>。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo&lt;T&gt; {
    inner: T,
}````

实际上等同于：

```rust
pub struct Foo&lt;T&gt; 
where
    T: Sized,
    // ^^^^^^ 这被称为**约束**
    // 它指定此实现仅适用于 // 类型T`实现`Sized`
    // 你可以要求多个特性被实现 // 使用+`符号 // 如`Sized + PartialEq&lt;T&gt;`
{
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>你可以通过<strong>负约束</strong>(<code>negative trait bound</code>)来选择退出这个行为：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 你也可以内联行约束，
// 而不是使用`where`子句

pub struct Foo&lt;Sized&gt; {
    // ^^^^^^ // 这是一个负约束
    // 它读作“T`可能不是”Sized”， // 并允许你绑定T到 DST（如`Foo&lt;str&gt;）
    inner: T,
}
<span class="boring">}</span></code></pre></pre>
<p>在<code>From&lt;T&gt;</code>情况下，我们希望<code>T</code>和实现<code>From&lt;T&gt;</code>类型都<code>Sized</code>，尽管后者是隐式的。</p>
<h2 id="04_traits-08_from-str-到-string"><a class="header" href="#04_traits-08_from-str-到-string"><code>&amp;str</code> 到 <code>String</code></a></h2>
<p>在<code>std</code>的<a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors">文档</a>中，你可以看到哪些类型实现了<code>From</code>特性。你会发现<code>&amp;str</code>实现了<code>From&lt;&amp;str&gt; for String</code>。因此，我们可以写：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let title = String::from("A title");
<span class="boring">}</span></code></pre></pre>
<p>我们主要使用了<code>.into()</code>。如果你查看[Into<T><code>的实现](https://doc.rust-lang.org/std/convert/trait.Into.html)，找不到</code>Into&lt;&amp;str&gt; for String`。怎么回事？</p>
<p><code>From</code>和<code>Into</code>是<strong>对称特性</strong>。特别是，任何实现了<code>From</code>的类型都会自动实现一个**空白实现<code>Into</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
<span class="boring">}</span></code></pre></pre>
<p>如果类型<code>T</code>实现了<code>From&lt;U&gt;</code>，那么<code>Into&lt;U&gt; for T</code>会自动实现。这就是我们能写<code>let title = "A title".into();</code>的原因。</p>
<h2 id="04_traits-08_from-into"><a class="header" href="#04_traits-08_from-into"><code>.into()</code></a></h2>
<p>每次看到<code>.into()</code>，你都在见证了一次类型间的转换。目标类型是什么？</p>
<p>大多数情况下，目标类型是：</p>
<ul>
<li>函数/方法签名指定（如上例<code>Ticket::new</code>）- 变量声明时类型注解（例<code>let title: String = "A title".into()</code>）。</li>
</ul>
<p>只要编译器能无歧义地从上下文中推断目标类型，<code>.into()</code>就会工作。</p>
<h2 id="04_traits-08_from-参考资料"><a class="header" href="#04_traits-08_from-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/08_from</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-09_assoc_vs_generic"></div><h1 id="04_traits-09_assoc_vs_generic-关联类型和相关类型"><a class="header" href="#04_traits-09_assoc_vs_generic-关联类型和相关类型">关联类型和相关类型</a></h1>
<p>让我们重新审视目前为止学习过的两个特性<code>From</code>和<code>Deref</code>的定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(value: T) -&gt; Self;}
trait Deref {
    type Target;
    fn deref(&amp;self) -&gt; &amp;Self::Target;}
<span class="boring">}</span></code></pre></pre>
<p>它们都涉及到类型。在<code>From</code>的情况下，它是泛型参数<code>T</code>。在<code>Deref</code>的情况下，它是相关类型<code>Target</code>。</p>
<p>有什么不同？为什么要用一个而非另一个？</p>
<h2 id="04_traits-09_assoc_vs_generic-最多实现"><a class="header" href="#04_traits-09_assoc_vs_generic-最多实现">最多实现</a></h2>
<p>由于deref强制转换的工作原理，给定类型只能有一个"目标"类型"。例如，<code>String</code>只能<code>Deref</code>到<code>str</code>。这是为了避免歧义：如果你能多次实现<code>Deref</code>，当调用<code>self</code>方法时编译器应该选择哪个<code>Target</code>？</p>
<p>这就是<code>Deref</code>使用相关类型的原因，<code>Target</code>。相关类型是由<strong>特性实现唯一确定</strong>的。因为你不能实现<code>Deref</code>超过一次，你只能为给定类型指定一个<code>Target</code>，不会有歧义。</p>
<h2 id="04_traits-09_assoc_vs_generic-泛型特性"><a class="header" href="#04_traits-09_assoc_vs_generic-泛型特性">泛型特性</a></h2>
<p>另一方面，你可以为类型多次实现<code>From</code>，**只要输入类型<code>不同即可。例如，你可以用</code>u32<code>和</code>u16<code>作为输入类型为</code>WrappingU32<code>实现</code>From`：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u32&gt; for WrappingU32 {
    fn from(value: u32) -&gt; Self {
        WrappingU32 { inner: value }
impl&lt;u16&gt; for WrappingU32 {
    fn from(value: u16) -&gt; Self {
        WrappingU32 { inner: value.into()}
<span class="boring">}</span></code></pre></pre>
<p>这可行，因为<code>From&lt;u16&gt;</code>和<code>From&lt;u32&gt;</code>被视为<strong>不同特性</strong>。没有歧义：编译器可以根据转换值的类型决定使用哪个实现。</p>
<h2 id="04_traits-09_assoc_vs_generic-案案例分析add"><a class="header" href="#04_traits-09_assoc_vs_generic-案案例分析add">案案例分析：<code>Add</code></a></h2>
<p>作为结束示例，考虑标准库中的<code>Add</code>特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;RHS = Self&gt; {
    type Output;
    fn add(self, rhs: RHS) -&gt; Self::Output;}
<span class="boring">}</span></code></pre></pre>
<p>它使用了两种机制：</p>
<ul>
<li>有一个泛型参数<code>RHS</code>（右手边），默认为<code>Self</code></li>
<li>有一个相关类型<code>Output</code>，加法的结果类型</li>
</ul>
<h3 id="04_traits-09_assoc_vs_generic-rhs"><a class="header" href="#04_traits-09_assoc_vs_generic-rhs"><code>RHS</code></a></h3>
<p><code>RHS</code>是一个泛型，允许不同类型相加在一起。例如，在标准库中你会发现这两个实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;u32&gt; for u32 {
    type Output = u32;
    fn add(self, u32) -&gt; u32 {
      [...]}
impl&lt;&amp;u32&gt; for u32 {
    type Output = u32;
    fn add(self, &amp;u32) -&gt; u32 {
        [...]}
<span class="boring">}</span></code></pre></pre>
<p>这让下面的代码可以编译：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5u32 + &amp;5u32 + 6u32
<span class="boring">}</span></code></pre></pre>
<p>因为<code>u32</code>实现在实现了<code>Add&lt;&amp;u32&gt;</code>和<code>以及</code>Add<u32>`。</p>
<h3 id="04_traits-09_assoc_vs_generic-output"><a class="header" href="#04_traits-09_assoc_vs_generic-output"><code>Output</code></a></h3>
<p>另一方面，<strong>必须</strong>在操作数类型已知时唯一确定。这就是它作为相关类型而不是第二个泛型参数的原因。</p>
<p>总结：</p>
<ul>
<li>当类型必须为给定实现时使用<strong>相关类型</strong>。</li>
<li>当想允许同一类型有**多个实现时使用泛型，输入类型不同。</li>
</ul>
<h2 id="04_traits-09_assoc_vs_generic-参考资料"><a class="header" href="#04_traits-09_assoc_vs_generic-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/09_assoc_vs_generic</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-10_clone"></div><h1 id="04_traits-10_clone-复制值第1部分"><a class="header" href="#04_traits-10_clone-复制值第1部分">复制值，第1部分</a></h1>
<p>在上一章中，我们介绍了所有权和借用的概念，并特别指出：</p>
<ul>
<li>在任何给定时间每个值都有一个所有者。</li>
<li>当函数取得某个值的所有权（“消耗它”后，调用者就无法再使用该值了。</li>
</ul>
<p>这些限制可能有些局限性。有时我们可能需要调用一个会取走值所有权的函数，但之后仍需使用那个值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* ... */ }fn example() {
     let mut s = String::from("hello");
     consumer(s);
     s.push_str("!"); // 错误：值已被移动}}
<span class="boring">}</span></code></pre></pre>
<p>这时<code>Clone</code>就登场了。</p>
<h2 id="04_traits-10_clone-clone"><a class="header" href="#04_traits-10_clone-clone"><code>Clone</code></a></h2>
<p><code>Clone</code>是Rust`标准库中定义的一个特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;}
<span class="boring">}</span></code></pre></pre>
<p>它的方法<code>clone</code>接受一个引用<code>self</code>并返回一个<strong>相同类型的</strong>新<strong>拥有</strong>实例。</p>
<h2 id="04_traits-10_clone-实战"><a class="header" href="#04_traits-10_clone-实战">实战</a></h2>
<p>回到上面的例子，我们可以在调用<code>clone</code>创建一个新的<code>String</code>实例后再调用<code>consumer</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: String) { /* ... */ }fn example() {
     let mut s = String::from("hello");
     let t = s.clone();
     consumer(t);
     s.push_str("!"); // 正常}}
<span class="boring">}</span></code></pre></pre>
<p>我们不是将<code>s</code>的所有权交给<code>consumer</code>，而是通过<code>s</code>克隆创建一个新的<code>String</code>(通过<code>s.clone</code>)并将其给<code>consumer</code>。这样<code>s</code>在调用<code>consumer</code>之后依然有效并可使用。</p>
<h2 id="04_traits-10_clone-内存"><a class="header" href="#04_traits-10_clone-内存">内存</a></h2>
<p>让我们看看上面例子中内存里发生了什么。执行<code>let mut s = String::from("hello");</code>时，内存如下：</p>
<pre><code class="language-text">                    s
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>执行<code>let t = s.clone()</code>时，堆上分配了一个新区域以存储数据的副本：</p>
<pre><code class="language-text">                    s                                    s
      +---------+--------+----------+      +---------+--------+----------+
Stack | pointer | length | capacity |      | pointer | length | capacity |
      |  |      |   5    |    5     |      |  |      |   5    |    5     |
      +--|------+--------+----------+      +--|------+--------+----------+
         |                                    |
         |                                    |
         v                                    v
       +---+---+---+---+---+                +---+---+---+---+---+
Heap:  | H | e | l | l | o |                | H | e | l | l | o |
       +---+---+---+---+---+                +---+---+---+---+---+
</code></pre>
<p>如果你来自像Java这样的语言，可以把<code>clone</code>想象成深拷贝对象的一种方式。</p>
<h2 id="04_traits-10_clone-实现clone"><a class="header" href="#04_traits-10_clone-实现clone">实现<code>Clone</code></a></h2>
<p>要让一个类型<code>Clone</code>，我们必须为其实现<code>Clone</code>特性。通常通过派生成功现<code>Clone</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct MyType {
    // 字段落}
<span class="boring">}</span></code></pre></pre>
<p>编译器为你的<code>MyType</code>实现了<code>Clone</code>，如同所期望：克隆了<code>MyType</code>的逐个字段并构造新<code>MyType</code>。记住可以用<code>cargo expand</code>或<code>IDE</code>探索由<code>derive</code>宏生成的代码。</p>
<h2 id="04_traits-10_clone-参考资料"><a class="header" href="#04_traits-10_clone-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/0_clone</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-11_copy"></div><h1 id="04_traits-11_copy-复制值第二部分"><a class="header" href="#04_traits-11_copy-复制值第二部分">复制值，第二部分</a></h1>
<p>让我们考虑与之前相同的例子，但稍作调整：使用<code>u32</code>代替<code>String</code>作为类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer(s: u32) { /* ... */ }fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1; // 无错误！}}
<span class="boring">}</span></code></pre></pre>
<p>这将无误编译！这是怎么回事？<code>String</code>和<code>u32</code>之间的区别是什么，使得后者无需<code>.clone()</code>就能工作？</p>
<h2 id="04_traits-11_copy-copy"><a class="header" href="#04_traits-11_copy-copy"><code>Copy</code></a></h2>
<p><code>Copy</code>是Rust标准库中定义的另一个特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>它是一个标记特性，类似于<code>Sized</code>。</p>
<p>如果一个类型实现了<code>Copy</code>，创建该类型的实例时就不需要显式调用<code>.clone()</code>：Rust会<strong>隐式</strong>地为你处理。<code>u32</code>就是一个实现<code>Copy</code>的类型示例，因此上述代码能无误编译：当调用<code>consumer(s)</code>时，Rust通过对<code>s</code>进行<strong>位级复制</strong>来创建一个新的<code>u32</code>实例，然后将这个新实例传递给<code>consumer</code>。这一切都在幕后自动完成，无需你的介入。</p>
<h2 id="04_traits-11_copy-什么可以是copy"><a class="header" href="#04_traits-11_copy-什么可以是copy">什么可以是<code>Copy</code>？</a></h2>
<p><code>Copy</code>并不等同于“自动克隆”，尽管它暗示了这一点。类型必须满足一些条件才能被允许实现<code>Copy</code>。</p>
<p>首先，它必须实现<code>Clone</code>，因为<code>Copy</code>是<code>Clone</code>的子特性。
这是有道理的：如果Rust能够_隐式_创建类型的实例，那么通过调用<code>.clone()</code>也应该能够_显式_创建新实例。</p>
<p>但这还不是全部。还需满足几个其他条件：</p>
<ol>
<li>类型不管理任何额外资源（如堆内存、文件句柄等），除了它在内存中占用的<code>std::mem::size_of</code>字节。</li>
<li>类型不是可变引用（<code>&amp;mut T</code>）。</li>
</ol>
<p>如果这两个条件都满足，那么Rust就可以通过执行原实例的<strong>位级复制</strong>安全地创建一个新实例——这常被称为<code>memcpy</code>操作，源自C标准库中执行位级复制的函数。</p>
<h3 id="04_traits-11_copy-案例研究1string"><a class="header" href="#04_traits-11_copy-案例研究1string">案例研究1：<code>String</code></a></h3>
<p><code>String</code>是一个不实现<code>Copy</code>的类型。
为什么？因为它管理着额外的资源：用于存储字符串数据的堆分配内存缓冲区。</p>
<p>假设Rust允许<code>String</code>实现<code>Copy</code>。
那么，当通过位级复制原始实例创建新的<code>String</code>实例时，原始实例和新实例都将指向同一内存缓冲区：</p>
<pre><code class="language-text">               s                                 copied_s
 +---------+--------+----------+      +---------+--------+----------+
 | pointer | length | capacity |      | pointer | length | capacity |
 |  |      |   5    |    5     |      |  |      |   5    |    5     |
 +--|------+--------+----------+      +--|------+--------+----------+
    |                                    |
    |                                    |
    v                                    |
  +---+---+---+---+---+                  |
  | H | e | l | l | o |                  |
  +---+---+---+---+---+                  |
    ^                                    |
    |                                    |
    +------------------------------------+
</code></pre>
<p>这很糟糕！
两个<code>String</code>实例都会在超出作用域时尝试释放内存缓冲区，导致重复释放错误。
你也可能创建两个指向同一内存缓冲区的不同可变<code>&amp;mut String</code>引用，违反了Rust的借用规则。</p>
<h3 id="04_traits-11_copy-案例研究2u32"><a class="header" href="#04_traits-11_copy-案例研究2u32">案例研究2：<code>u32</code></a></h3>
<p><code>u32</code>实现了<code>Copy</code>。实际上，所有整数类型都是如此。
一个整数就是内存中代表数字的那些字节。没有别的！
如果复制那些字节，就会得到另一个完全有效的整数实例。
没有任何不良后果，所以Rust允许这样做。</p>
<h3 id="04_traits-11_copy-案例研究3mut-u32"><a class="header" href="#04_traits-11_copy-案例研究3mut-u32">案例研究3：<code>&amp;mut u32</code></a></h3>
<p>当我们介绍所有权和可变借用时，明确了一条规则：任何时候对一个值只能有一个<em>可变借用</em>。
这就是<code>&amp;mut u32</code>不实现<code>Copy</code>的原因，即便<code>u32</code>本身实现了。</p>
<p>如果<code>&amp;mut u32</code>实现了<code>Copy</code>，你就可以创建多个指向同一值的可变引用，并同时在多处修改它。
这将违反Rust的借用规则！因此，无论<code>T</code>是什么，<code>&amp;mut T</code>都不实现<code>Copy</code>。</p>
<h2 id="04_traits-11_copy-实现copy"><a class="header" href="#04_traits-11_copy-实现copy">实现<code>Copy</code></a></h2>
<p>大多数情况下，你不需要手动实现<code>Copy</code>。
你可以这样派生它：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="04_traits-11_copy-参考资料"><a class="header" href="#04_traits-11_copy-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/11_copy</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-12_drop"></div><h1 id="04_traits-12_drop-drop-特性"><a class="header" href="#04_traits-12_drop-drop-特性"><code>Drop</code> 特性</a></h1>
<p>当我们引入<a href="04_traits/../../02_ticket_v11_destructor/README.html">析构器</a>时，我们提到了<code>drop</code>函数：</p>
<ol>
<li>回收回应类型的内存（即<code>std::mem::size_of</code>字节）</li>
<li>清理值可能正在管理的任何额外资源（例如<code>String</code>的堆缓冲区）</li>
</ol>
<p>步骤2. 就是<code>Drop</code>特性发挥作用的地方。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);}
<span class="boring">}</span></code></pre></pre>
<p><code>Drop</code>特性是一种机制，让你为类型定义<strong>额外</strong>清理逻辑**，超出编译器自动为你做的部分。你在<code>drop</code>方法中放入的任何内容都会在值超出作用域时被执行。</p>
<h2 id="04_traits-12_drop-drop与copy"><a class="header" href="#04_traits-12_drop-drop与copy"><code>Drop</code>与<code>Copy</code></a></h2>
<p>谈论<code>Copy</code>特性时，我们说类型如果管理的资源超出了它在内存中占据的<code>std::mem::size_of</code>字节，就不能实现<code>Copy</code>。</p>
<p>你可能好奇：编译器怎么知道类型是否管理资源？
没错：<code>Drop</code>特性的实现！如果你的类型有显式的<code>Drop</code>实现，编译器会认为你的类型附加了额外资源，并不允许你实现<code>Copy</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这是一个单元结构体，即无字段的结构体。
#[derive(Clone, Copy)]
struct MyType;

impl Drop for MyType {
    fn drop(&amp;mut self) {
       // 我们不需要在这里做什么，
       // 有"空"Drop"实现就足够了
    }
<span class="boring">}</span></code></pre></pre>
<p>编译器会报此错误信息：</p>
<pre><code class="language-text">error[E0184]: `Copy`特性不能为此类型实现；该类型具有析构器
--&gt; src/lib.rs:2:7
 2 | #[derive(Clone, Copy)]
  |              ^^^^ `Copy`不允许有析构器的类型上使用
</code></pre>
<h2 id="04_traits-12_drop-参考资料"><a class="header" href="#04_traits-12_drop-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/12_drop</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="04_traits-13_outro"></div><h1 id="04_traits-13_outro-封装起来"><a class="header" href="#04_traits-13_outro-封装起来">封装起来</a></h1>
<p>本章我们已经覆盖了不少不同的特性——而仅仅触及皮毛皮！你可能会感觉有许多要记的东西，但别担心：当你编写Rust代码时，你会频繁遇到这些特性以至于它们很快变得自然而然。</p>
<p>继续前进之前，让我们通过最后一个练习巩固所学的内容。这次你将得到最少的指引——只有练习描述和测试指导你。</p>
<h2 id="04_traits-13_outro-参考"><a class="header" href="#04_traits-13_outro-参考">参考</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/04_traits/13_outro</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-00_intro"></div><h1 id="05_ticket_v2-00_intro-建模-ticket-系统第二部分"><a class="header" href="#05_ticket_v2-00_intro-建模-ticket-系统第二部分">建模 Ticket 系统，第二部分</a></h1>
<p>我们在前几章中工作的<code>Ticket</code>结构体是一个良好的开端，但它仍然透露出“我是Rust新手！”的气息。</p>
<p>我们将利用这一章节来提升我们的Rust领域建模技能。一路上，我们需要引入几个额外的概念：</p>
<ul>
<li><code>enum</code>，Rust数据建模中最为强大的特性之一</li>
<li><code>Option</code>类型，用来建模可空值</li>
<li><code>Result</code>类型，用来建模可恢复的错误</li>
<li><code>Debug</code>和<code>Display</code>特质，用于打印输出</li>
<li><code>Error</code>特质，用于标记错误类型</li>
<li><code>TryFrom</code>和<code>TryInto</code>特质，用于可能失败的转换</li>
<li>Rust的包管理系统，解释什么是库、什么是二进制文件，以及如何使用第三方库</li>
</ul>
<h2 id="05_ticket_v2-00_intro-参考资料"><a class="header" href="#05_ticket_v2-00_intro-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/00_intro</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-01_enum"></div><h1 id="05_ticket_v2-01_enum-枚举类型"><a class="header" href="#05_ticket_v2-01_enum-枚举类型">枚举类型</a></h1>
<p>根据您在<a href="05_ticket_v2/../../02_ticket_v1/02_validation">前一章节</a>中编写的验证逻辑，一张票证（ticket）只有几种有效状态：<code>待办（To-Do）</code>、<code>进行中（InProgress）</code>和<code>已完成（Done）</code>。然而，如果我们查看<code>Ticket</code>结构体中的<code>status</code>字段或<code>new</code>方法中<code>status</code>参数的类型，这一点并不明显。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Ticket {
    title: String,
    description: String,
    status: String,
}

impl Ticket {
    pub fn new(title: String, description: String, status: String) -&gt; Self {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>在这两种情况中，我们都使用<code>String</code>来表示<code>status</code>字段。<code>String</code>是一个非常通用的类型，它并不能立即传达出<code>status</code>字段的可能值是有限的信息。更糟糕的是，调用<code>Ticket::new</code>方法的用户只能在<strong>运行时</strong>发现他们提供的状态是否有效。</p>
<p>使用<strong>枚举（enumerations）</strong>，我们可以做得更好。</p>
<h2 id="05_ticket_v2-01_enum-enum"><a class="header" href="#05_ticket_v2-01_enum-enum"><code>enum</code></a></h2>
<p>枚举是一种可以有固定值集合的类型，这些值被称为<strong>变体（variants）</strong>。在Rust中，你可以使用<code>enum</code>关键字来定义枚举：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>就像<code>struct</code>一样，<code>enum</code>也定义了一个<strong>新的Rust类型</strong>。</p>
<h2 id="05_ticket_v2-01_enum-参考资料"><a class="header" href="#05_ticket_v2-01_enum-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/05_ticket_v2/01_enum</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-02_match"></div><h1 id="05_ticket_v2-02_match-匹配match"><a class="header" href="#05_ticket_v2-02_match-匹配match"><code>匹配（match）</code></a></h1>
<p>你可能在想，枚举（enum）究竟能<strong>做</strong>些什么？最常见的操作就是**匹配（match）**它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done
}

impl Status {
    fn is_done(&amp;self) -&gt; bool {
        match self {
            Status::Done =&gt; true,
            // The `|` operator lets you match multiple patterns.
            // It reads as "either `Status::ToDo` or `Status::InProgress`".
            Status::InProgress | Status::ToDo =&gt; false
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>match</code>语句让你能把Rust值与一系列<strong>模式</strong>进行比较。你可以把它想象成类型级别的<code>if</code>。如果<code>status</code>是<code>已完成</code>变体，执行第一块代码；如果是<code>进行中</code>或<code>待办</code>变体，则执行第二块代码。</p>
<h2 id="05_ticket_v2-02_match-完备性"><a class="header" href="#05_ticket_v2-02_match-完备性">完备性</a></h2>
<p>这里的关键点在于<code>match</code>是<strong>完备的</strong>。你必须处理所有枚举变体。如果你遗漏了某个变体，Rust会在<strong>编译时</strong>阻止你并报错。</p>
<p>例如，如果我们忘记处理<code>待办</code>变体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match self {
    Status::Done =&gt; true,
    Status::InProgress =&gt; false,
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会报错：</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `ToDo` not covered
 --&gt; src/main.rs:5:9
  |
5 |     match status {
  |     ^^^^^^^^^^^^ pattern `ToDo` not covered
</code></pre>
<p>这是一个大优点！代码库随着时间发展，你可能后续会添加新状态，比如<code>Blocked</code>。Rust编译器会对每个缺失新变体逻辑的<code>match</code>语句发出错误。这就是为什么Rust开发者经常夸赞“编译器驱动重构”——编译器告诉你接下来要做什么，你只需修复它报告的问题即可。</p>
<h2 id="05_ticket_v2-02_match-通配符"><a class="header" href="#05_ticket_v2-02_match-通配符">通配符</a></h2>
<p>如果你不关心一个或多个变体，可以使用<code>_</code>模式作为通配符：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::Done =&gt; true,
    _ =&gt; false
}
<span class="boring">}</span></code></pre></pre>
<p><code>_</code>模式匹配所有之前模式未匹配到的情况。</p>
<h2 id="05_ticket_v2-02_match-参考资料"><a class="header" href="#05_ticket_v2-02_match-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/02_match</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-03_variants_with_data"></div><h1 id="05_ticket_v2-03_variants_with_data-变体可以持有数据"><a class="header" href="#05_ticket_v2-03_variants_with_data-变体可以持有数据">变体可以持有数据</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress,
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p>我们的<code>Status</code>枚举通常被称为<strong>C风格枚举</strong>。每个变体都是一个简单的标签，有点像命名常量。你可以在许多编程语言中找到这种枚举，如C、C++、Java、C#、Python等。</p>
<p>不过，Rust的枚举可以更进一步。我们可以在每个变体<strong>附加数据</strong>。</p>
<h2 id="05_ticket_v2-03_variants_with_data-变体"><a class="header" href="#05_ticket_v2-03_variants_with_data-变体">变体</a></h2>
<p>假设我们想存储当前正在处理票证的人的名字。只有当票证处于进行中状态时，我们才有此信息。对于待办或已完成的票证则不会有此信息。我们可以通过在<code>InProgress</code>变体上附加一个<code>String</code>字段来模拟这个模型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Status {
    ToDo,
    InProgress {
        assigned_to: String,
    },
    Done,
}
<span class="boring">}</span></code></pre></pre>
<p><code>InProgress</code>现在变成了一个<strong>类似结构体的变体</strong>。语法实际上反映了我们定义结构体时使用的语法——只是作为变体“内联”在枚举中。</p>
<h2 id="05_ticket_v2-03_variants_with_data-访问变体数据"><a class="header" href="#05_ticket_v2-03_variants_with_data-访问变体数据">访问变体数据</a></h2>
<p>如果我们尝试访问<code>Status</code>实例上的<code>assigned_to</code>，</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status: Status = /* */;

// This won't compile
println!("Assigned to: {}", status.assigned_to);
<span class="boring">}</span></code></pre></pre>
<p>编译器会阻止我们：</p>
<pre><code class="language-text">error[E0609]: no field `assigned_to` on type `Status`
 --&gt; src/main.rs:5:40
  |
5 |     println!("Assigned to: {}", status.assigned_to);
  |                                        ^^^^^^^^^^^ unknown field
</code></pre>
<p><code>assigned_to</code>是<strong>特定于变体</strong>的，不是所有<code>Status</code>实例都可用。要访问<code>assigned_to</code>，我们需要使用<strong>模式匹配</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to } =&gt; {
        println!("Assigned to: {}", assigned_to);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="05_ticket_v2-03_variants_with_data-绑定"><a class="header" href="#05_ticket_v2-03_variants_with_data-绑定">绑定</a></h2>
<p>在匹配模式<code>Status::InProgress { assigned_to }</code>中，<code>assigned_to</code>是一个<strong>绑定</strong>。我们正在<strong>解构</strong><code>Status::InProgress</code>变体并将<code>assigned_to</code>字段绑定到一个新变量，也称为<code>assigned_to</code>。如果我们愿意，我们可以将字段绑定到一个不同的变量名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match status {
    Status::InProgress { assigned_to: person } =&gt; {
        println!("Assigned to: {}", person);
    },
    Status::ToDo | Status::Done =&gt; {
        println!("Done");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="05_ticket_v2-03_variants_with_data-参考资料"><a class="header" href="#05_ticket_v2-03_variants_with_data-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/03_variants_with_data</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-04_if_let"></div><h1 id="05_ticket_v2-04_if_let-简洁的分支判断"><a class="header" href="#05_ticket_v2-04_if_let-简洁的分支判断">简洁的分支判断</a></h1>
<p>你对上一练习的解答可能如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        match &amp;self.status {
            Status::InProgress { assigned_to } =&gt; assigned_to,
            Status::Done | Status::ToDo =&gt; {
                panic!("Only `In-Progress` tickets can be assigned to someone"),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>你只关心<code>Status::InProgress</code>变体。真的需要匹配所有其他变体吗？</p>
<p>有新的构造来帮忙！</p>
<h2 id="05_ticket_v2-04_if_let-if-let"><a class="header" href="#05_ticket_v2-04_if_let-if-let"><code>if let</code></a></h2>
<p><code>if let</code>构造允许你仅匹配枚举的一个变体，而不必处理所有其他变体。</p>
<p>你可以这样使用<code>if let</code>来简化<code>assigned_to</code>方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        if let Status::InProgress { assigned_to } = &amp;self.status {
            assigned_to
        } else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="05_ticket_v2-04_if_let-letelse"><a class="header" href="#05_ticket_v2-04_if_let-letelse"><code>let/else</code></a></h2>
<p>如果<code>else</code>分支旨在提前返回（恐慌也算作提前返回！），你可以使用<code>let/else</code>构造：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn assigned_to(&amp;self) -&gt; &amp;str {
        let Status::InProgress { assigned_to } = &amp;self.status else {
            panic!("Only `In-Progress` tickets can be assigned to someone");
        };
        assigned_to
    }
}
<span class="boring">}</span></code></pre></pre>
<p>它允许你分配解构后的变量，而不会引起任何“向右偏移”，即变量在与其前面代码相同缩进级别被赋值。</p>
<h2 id="05_ticket_v2-04_if_let-样式"><a class="header" href="#05_ticket_v2-04_if_let-样式">样式</a></h2>
<p><code>if let</code>和<code>let/else</code>都是惯用的Rust构造。根据需要使用它们来提高代码的可读性，但不要过度：当你需要时，<code>match</code>总是在那里。</p>
<h2 id="05_ticket_v2-04_if_let-参考资料"><a class="header" href="#05_ticket_v2-04_if_let-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/04_if_let</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-05_nullability"></div><h1 id="05_ticket_v2-05_nullability-空值处理"><a class="header" href="#05_ticket_v2-05_nullability-空值处理">空值处理</a></h1>
<p>我们对<code>assigned</code>方法的实现相当直接：对于待办和已完成的票证采用恐慌处理远非理想。通过使用<strong>Rust的<code>Option</code>类型</strong>，我们可以做得更好。</p>
<h2 id="05_ticket_v2-05_nullability-option"><a class="header" href="#05_ticket_v2-05_nullability-option"><code>Option</code></a></h2>
<p><code>Option</code>是Rust中表示<strong>可空值</strong>的类型。它是Rust标准库中定义的一个枚举：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option</code>编码了值可能存在（<code>Some(T)</code>）或不存在（<code>None</code>）的概念。它还强制你<strong>明确处理两种情况</strong>。如果你在处理可空值时忘记处理<code>None</code>情况，编译器会报错。这相比其他语言中“隐式”的空值处理是一个显著改进，在那些语言中，你可能会忘记检查<code>null</code>从而触发运行时错误。</p>
<h2 id="05_ticket_v2-05_nullability-option的定义"><a class="header" href="#05_ticket_v2-05_nullability-option的定义"><code>Option</code>的定义</a></h2>
<p><code>Option</code>的定义使用了一个你之前未见过的Rust结构：<strong>元组风格的变体</strong>。</p>
<h3 id="05_ticket_v2-05_nullability-元组风格的变体"><a class="header" href="#05_ticket_v2-05_nullability-元组风格的变体">元组风格的变体</a></h3>
<p><code>Option</code>有两个变体：<code>Some(T)</code>和<code>None</code>。<code>Some</code>是一个<strong>元组风格的变体</strong>：它保存了<strong>未命名的字段</strong>。</p>
<p>元组风格的变体常用于需要存储单个字段的场合，尤其是当我们面对像<code>Option</code>这样的“包装”类型时。</p>
<h3 id="05_ticket_v2-05_nullability-元组风格的结构体"><a class="header" href="#05_ticket_v2-05_nullability-元组风格的结构体">元组风格的结构体</a></h3>
<p>它们不仅限于枚举——你也可以定义元组风格的结构体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
<span class="boring">}</span></code></pre></pre>
<p>然后你可以通过位置索引来访问<code>Point</code>实例的两个字段：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = Point(3, 4);
let x = point.0;
let y = point.1;
<span class="boring">}</span></code></pre></pre>
<h3 id="05_ticket_v2-05_nullability-元组"><a class="header" href="#05_ticket_v2-05_nullability-元组">元组</a></h3>
<p>在还未见过元组的情况下就说某物像元组可能听起来有些奇怪！元组是Rust的基本类型。它们组合了一定数量的值，这些值可能具有（也可能不具有）不同的类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 两个值，相同类型
let first: (i32, i32) = (3, 4);
// 三个值，不同类型
let second: (i32, u32, u8) = (-42, 3, 8);
<span class="boring">}</span></code></pre></pre>
<p>语法很简单：你只需要在括号间列出类型，用逗号分隔。你可以使用点符号和字段索引来访问元组的字段：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(second.0, -42);
assert_eq!(second.1, 3);
assert_eq!(second.2, 8);
<span class="boring">}</span></code></pre></pre>
<p>当你懒得定义一个专用的结构体类型时，元组是将值组合在一起的一种便捷方式。</p>
<h2 id="05_ticket_v2-05_nullability-参考资料"><a class="header" href="#05_ticket_v2-05_nullability-参考资料">参考资料</a></h2>
<ul>
<li>本节的练习位于 <code>exercises/05_ticket_v2/05_nullability</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-06_fallibility"></div><h1 id="05_ticket_v2-06_fallibility-失败处理"><a class="header" href="#05_ticket_v2-06_fallibility-失败处理">失败处理</a></h1>
<p>让我们回顾一下上一练习中的<code>Ticket::new</code>函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ticket {
    pub fn new(title: String, description: String, status: Status) -&gt; Ticket {
        // ... 检查逻辑和错误处理 ...
        Ticket {
            title,
            description,
            status,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>一旦检查失败，该函数就会恐慌。这并不理想，因为它没有给调用者<strong>处理错误</strong>的机会。</p>
<p>现在是时候介绍<code>Result</code>类型了，这是Rust处理错误的主要机制。</p>
<h2 id="05_ticket_v2-06_fallibility-result类型"><a class="header" href="#05_ticket_v2-06_fallibility-result类型"><code>Result</code>类型</a></h2>
<p><code>Result</code>类型是标准库中定义的一个枚举：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>它有两个变体：</p>
<ul>
<li><code>Ok(T)</code>：表示成功执行的操作，包含操作的输出<code>T</code>。</li>
<li><code>Err(E)</code>：表示失败的操作，包含发生的错误<code>E</code>。</li>
</ul>
<p><code>Ok</code>和<code>Err</code>都是泛型，允许你为成功和错误情况指定自己的类型。</p>
<h2 id="05_ticket_v2-06_fallibility-无异常"><a class="header" href="#05_ticket_v2-06_fallibility-无异常">无异常</a></h2>
<p>Rust中的可恢复错误<strong>以值的形式表示</strong>。它们只是一个类型的实例，像任何其他值一样被传递和操作。这与其他语言（如Python或C#）使用<strong>异常</strong>来指示错误有显著不同。</p>
<p>异常创建了一个难以推理的独立控制流路径。仅凭函数签名，你无法知道它是否会抛出异常。仅凭函数签名，你也无法知道它会抛出<strong>哪种</strong>异常类型。你必须阅读函数的文档或查看其实现才能了解。</p>
<p>异常处理逻辑的局部性很差：抛出异常的代码与捕获它的代码相距甚远，两者之间没有直接联系。</p>
<h2 id="05_ticket_v2-06_fallibility-失败处理编码在类型系统中"><a class="header" href="#05_ticket_v2-06_fallibility-失败处理编码在类型系统中">失败处理编码在类型系统中</a></h2>
<p>Rust通过<code>Result</code>强制你<strong>在函数签名中编码失败的可能性</strong>。如果一个函数可能失败（并且你想让调用者有机会处理错误），它必须返回一个<code>Result</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 仅凭签名，你就能知道这个函数可能会失败。
// 你还可以检查`ParseIntError`以了解可能出现的失败类型。
fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>这就是<code>Result</code>的最大优势：它使失败显式化。</p>
<p>但是，请记住，恐慌依然存在。它们没有被类型系统跟踪，就像其他语言中的异常一样。但它们用于<strong>不可恢复的错误</strong>，应谨慎使用。</p>
<h2 id="05_ticket_v2-06_fallibility-参考资料"><a class="header" href="#05_ticket_v2-06_fallibility-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/06_fallibility</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-07_unwrap"></div><h1 id="05_ticket_v2-07_unwrap-解包处理"><a class="header" href="#05_ticket_v2-07_unwrap-解包处理">解包处理</a></h1>
<p><code>Ticket::new</code>现在在遇到无效输入时返回一个<code>Result</code>而不是恐慌。这对调用者意味着什么？</p>
<h2 id="05_ticket_v2-07_unwrap-错误不能隐式忽略"><a class="header" href="#05_ticket_v2-07_unwrap-错误不能隐式忽略">错误不能（隐式）忽略</a></h2>
<p>与异常不同，Rust的<code>Result</code>迫使你在调用地点<strong>显式处理错误</strong>。如果你调用一个返回<code>Result</code>的函数，Rust不允许你隐式忽略错误情况。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}

// 这将无法编译：我们没有处理错误情况。
// 我们必须使用`match`或`Result`提供的组合子之一来“解包”成功值或处理错误。
let number = parse_int("42") + 2;
<span class="boring">}</span></code></pre></pre>
<h2 id="05_ticket_v2-07_unwrap-得到了一个result然后呢"><a class="header" href="#05_ticket_v2-07_unwrap-得到了一个result然后呢">得到了一个<code>Result</code>，然后呢？</a></h2>
<p>当你调用返回<code>Result</code>的函数时，你有两个主要选择：</p>
<ul>
<li>如果操作失败，则恐慌。
这通常使用<code>unwrap</code>或<code>expect</code>方法完成。
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果`parse_int`返回`Err`则恐慌。
let number = parse_int("42").unwrap();
// `expect`允许你指定自定义的恐慌信息。
let number = parse_int("42").expect("解析整数失败");
<span class="boring">}</span></code></pre></pre>
</li>
<li>使用<code>match</code>表达式解构<code>Result</code>以显式处理错误情况。
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match parse_int("42") {
    Ok(number) =&gt; println!("解析的数字: {}", number),
    Err(err) =&gt; eprintln!("错误: {}", err),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="05_ticket_v2-07_unwrap-参考资料"><a class="header" href="#05_ticket_v2-07_unwrap-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/07_unwrap</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-08_error_enums"></div><h1 id="05_ticket_v2-08_error_enums-错误枚举"><a class="header" href="#05_ticket_v2-08_error_enums-错误枚举">错误枚举</a></h1>
<p>你可能感觉上一练习的解答有些笨拙：基于字符串进行匹配并不理想！如果同事修改了<code>Ticket::new</code>返回的错误信息（例如为了提高可读性），突然之间，你的调用代码就会出错。</p>
<p>你已经知道了修复这个问题所需的方法：枚举！</p>
<h2 id="05_ticket_v2-08_error_enums-针对错误做出反应"><a class="header" href="#05_ticket_v2-08_error_enums-针对错误做出反应">针对错误做出反应</a></h2>
<p>当你希望允许调用者根据发生的特定错误采取不同行为时，你可以使用枚举来表示不同的错误情况：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个错误枚举，代表从字符串解析`u32`时可能发生的
// 不同错误情况。
enum U32ParseError {
    NotANumber,
    TooLarge,
    Negative,
}
<span class="boring">}</span></code></pre></pre>
<p>使用错误枚举，你将不同的错误情况编码进了类型系统中——它们成为了可失败函数签名的一部分。这简化了调用者的错误处理，因为他们可以使用<code>match</code>表达式针对不同的错误情况进行反应：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match s.parse_u32() {
    Ok(n) =&gt; n,
    Err(U32ParseError::Negative) =&gt; 0,
    Err(U32ParseError::TooLarge) =&gt; u32::MAX,
    Err(U32ParseError::NotANumber) =&gt; {
        panic!("Not a number: {}", s);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="05_ticket_v2-08_error_enums-参考资料"><a class="header" href="#05_ticket_v2-08_error_enums-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/08_error_enums</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-09_error_trait"></div><h1 id="05_ticket_v2-09_error_trait-错误特性error-trait"><a class="header" href="#05_ticket_v2-09_error_trait-错误特性error-trait">错误特性（Error trait）</a></h1>
<h2 id="05_ticket_v2-09_error_trait-错误报告"><a class="header" href="#05_ticket_v2-09_error_trait-错误报告">错误报告</a></h2>
<p>在上一练习中，你需要解构<code>InvalidTitle</code>变体以提取错误信息，并将其传递给<code>panic!</code>宏。这是<strong>错误报告</strong>的一个（基本）示例：将错误类型转换为可以展示给用户、服务操作员或开发者的表示形式。</p>
<p>每个Rust开发者都提出自己的错误报告策略是不切实际的：这会浪费时间，而且在项目间组合效果也不好。这就是Rust提供<code>std::error::Error</code>特性的原因。</p>
<h2 id="05_ticket_v2-09_error_trait-error特性"><a class="header" href="#05_ticket_v2-09_error_trait-error特性"><code>Error</code>特性</a></h2>
<p>在<code>Result</code>中的<code>Err</code>变体类型没有约束，但使用实现了<code>Error</code>特性的类型是一个良好实践。
<code>Error</code>是Rust错误处理故事的基石：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Error`特性的简化定义
pub trait Error: Debug + Display {}
<span class="boring">}</span></code></pre></pre>
<p>你可能回想起来自<a href="#04_traits-07_sized">《Sized特性》</a>的<code>:</code>语法——它用于指定<strong>SuperTrait</strong>。对于<code>Error</code>，有两个超特性：<code>Debug</code>和<code>Display</code>。如果一个类型想要实现<code>Error</code>，它也必须实现<code>Debug</code>和<code>Display</code>。</p>
<h2 id="05_ticket_v2-09_error_trait-display和debug"><a class="header" href="#05_ticket_v2-09_error_trait-display和debug"><code>Display</code>和<code>Debug</code></a></h2>
<p>我们已经在<a href="#04_traits-04_derive">之前的练习</a>中遇到过<code>Debug</code>特性——它是<code>assert_eq!</code>在断言失败时显示其比较的变量值所使用的特性。</p>
<p>从“机械”角度看，<code>Display</code>和<code>Debug</code>是相同的——它们编码了类型应该如何转换为字符串般的表示形式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Debug`
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

// `Display`
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>它们的区别在于<em>目的</em>：<code>Display</code>返回的表示形式是为“终端用户”准备的，而<code>Debug</code>提供了更适合开发者和服务操作员的低级表示。这就是为什么<code>Debug</code>可以通过<code>#[derive(Debug)]</code>属性自动实现，而<code>Display</code><strong>需要</strong>手动实现。</p>
<h2 id="05_ticket_v2-09_error_trait-参考"><a class="header" href="#05_ticket_v2-09_error_trait-参考">参考</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/09_error_trait</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-10_packages"></div><h1 id="05_ticket_v2-10_packages-库与二进制文件"><a class="header" href="#05_ticket_v2-10_packages-库与二进制文件">库与二进制文件</a></h1>
<p>为<code>TicketNewError</code>实现<code>Error</code>特质是不是挺费劲的？手动实现<code>Display</code>，再加上一个<code>Error</code>实现块。</p>
<p>我们可以通过使用第三方库<a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>减少一些样板代码，它提供了一个<strong>过程宏</strong>来简化自定义错误类型的创建。但话说回来，<code>thiserror</code>是我们第一个依赖的第三方库！</p>
<p>在深入探讨依赖关系之前，我们先退一步谈谈Rust的打包系统。</p>
<h2 id="05_ticket_v2-10_packages-什么是包"><a class="header" href="#05_ticket_v2-10_packages-什么是包">什么是包？</a></h2>
<p>Rust包由<code>Cargo.toml</code>文件中的<code>[package]</code>部分定义，也称为<strong>清单</strong>。在<code>[package]</code>内，你可以设置包的元数据，比如名称和版本。</p>
<p>去看看这一节练习目录下的<code>Cargo.toml</code>文件吧！</p>
<h2 id="05_ticket_v2-10_packages-什么是crate"><a class="header" href="#05_ticket_v2-10_packages-什么是crate">什么是crate？</a></h2>
<p>在一个包内部，你可以有一个或多个<strong>crate</strong>，也称为<strong>目标</strong>。最常见的两种crate类型是<strong>二进制crate</strong>和<strong>库crate</strong>。</p>
<h3 id="05_ticket_v2-10_packages-二进制文件"><a class="header" href="#05_ticket_v2-10_packages-二进制文件">二进制文件</a></h3>
<p>二进制文件是可以编译成<strong>可执行文件</strong>的程序。它必须包含一个名为<code>main</code>的函数——程序的入口点。当程序被执行时，<code>main</code>函数会被调用。</p>
<h3 id="05_ticket_v2-10_packages-库"><a class="header" href="#05_ticket_v2-10_packages-库">库</a></h3>
<p>另一方面，库本身不可执行。你不能直接<strong>运行</strong>一个库，但可以从依赖它的其他包<strong>导入其代码</strong>。库将代码（如函数、类型等）组合在一起，作为<strong>依赖项</strong>供其他包使用。</p>
<p>迄今为止，你解决的所有练习都被构建为带有测试套件的库。</p>
<h3 id="05_ticket_v2-10_packages-约定"><a class="header" href="#05_ticket_v2-10_packages-约定">约定</a></h3>
<p>关于Rust包，有一些约定需要记住：</p>
<ul>
<li>包的源代码通常位于<code>src</code>目录下。</li>
<li>如果存在<code>src/lib.rs</code>文件，<code>cargo</code>将推断包包含一个库crate。</li>
<li>如果存在<code>src/main.rs</code>文件，<code>cargo</code>将推断包包含一个二进制crate。</li>
</ul>
<p>你可以通过在<code>Cargo.toml</code>文件中明确声明目标来覆盖这些默认值——更多细节见<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets">cargo文档</a>。</p>
<p>请记住，虽然一个包可以包含多个crate，但它只能包含一个库crate。</p>
<h2 id="05_ticket_v2-10_packages-构建新包的脚手架"><a class="header" href="#05_ticket_v2-10_packages-构建新包的脚手架">构建新包的脚手架</a></h2>
<p>你可以使用<code>cargo</code>命令来生成一个新的包：</p>
<pre><code class="language-bash">cargo new my-binary
</code></pre>
<p>这将在当前目录下创建一个名为<code>my-binary</code>的新文件夹，包含一个同名的Rust包和一个单一的二进制crate。</p>
<p>如果你想创建一个库crate，可以使用<code>--lib</code>标志：</p>
<pre><code class="language-bash">cargo new my-library --lib
</code></pre>
<h2 id="05_ticket_v2-10_packages-参考资料"><a class="header" href="#05_ticket_v2-10_packages-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/10_packages</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-11_dependencies"></div><h1 id="05_ticket_v2-11_dependencies-依赖管理"><a class="header" href="#05_ticket_v2-11_dependencies-依赖管理">依赖管理</a></h1>
<p>包可以通过在它的<code>Cargo.toml</code>文件的<code>[dependencies]</code>部分列出其他包来依赖它们。指定依赖最常用的方式是提供其名称和版本号：</p>
<pre><code class="language-toml">[dependencies]
thiserror = "1"
</code></pre>
<p>这样会将<code>thiserror</code>作为依赖添加到你的包中，其<strong>最低</strong>版本为<code>1.0.0</code>。<code>thiserror</code>将会从Rust的官方包注册中心<a href="https://crates.io">crates.io</a>获取。当你运行<code>cargo build</code>时，<code>cargo</code>会经历几个阶段：</p>
<ul>
<li>依赖解析</li>
<li>下载依赖</li>
<li>编译项目（包括你自己的代码和依赖）</li>
</ul>
<p>如果你的项目有<code>Cargo.lock</code>文件，并且你的清单文件未发生变化，那么依赖解析步骤将被跳过。锁定文件是<code>cargo</code>在成功完成一轮依赖解析后自动生成的，它包含了项目中所有依赖的确切版本，用于确保在不同构建环境（例如CI）中始终使用相同版本的依赖。如果你正在与多位开发者共同开发项目，应当将<code>Cargo.lock</code>文件提交到版本控制系统中。</p>
<p>你可以使用<code>cargo update</code>命令来更新<code>Cargo.lock</code>文件，使其包含所有依赖的最新（兼容）版本。</p>
<h3 id="05_ticket_v2-11_dependencies-路径依赖"><a class="header" href="#05_ticket_v2-11_dependencies-路径依赖">路径依赖</a></h3>
<p>你也可以通过<strong>路径</strong>来指定依赖，这对于处理多个本地包时非常有用。</p>
<pre><code class="language-toml">[dependencies]
my-library = { path = "../my-library" }
</code></pre>
<p>这个路径是相对于声明依赖的包的<code>Cargo.toml</code>文件而言的。</p>
<h3 id="05_ticket_v2-11_dependencies-其他来源"><a class="header" href="#05_ticket_v2-11_dependencies-其他来源">其他来源</a></h3>
<p>查阅<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo文档</a>以了解更多关于如何在<code>Cargo.toml</code>文件中指定依赖以及从何处获取依赖的信息。</p>
<h2 id="05_ticket_v2-11_dependencies-开发依赖"><a class="header" href="#05_ticket_v2-11_dependencies-开发依赖">开发依赖</a></h2>
<p>你还可以指定仅在开发过程中需要的依赖项，也就是说，只有在运行<code>cargo test</code>时它们才会被引入。这类依赖应放在<code>Cargo.toml</code>文件的<code>[dev-dependencies]</code>部分：</p>
<pre><code class="language-toml">[dev-dependencies]
static_assertions = "1.1.0"
</code></pre>
<p>本书中，我们已经使用了几个这样的依赖来简化测试代码。</p>
<h2 id="05_ticket_v2-11_dependencies-参考资料"><a class="header" href="#05_ticket_v2-11_dependencies-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/11_dependencies</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-12_thiserror"></div><h1 id="05_ticket_v2-12_thiserror-thiserror-稍微绕了个弯对吧但这是必要的现在让我们回到正轨自定义错误类型与-thiserror"><a class="header" href="#05_ticket_v2-12_thiserror-thiserror-稍微绕了个弯对吧但这是必要的现在让我们回到正轨自定义错误类型与-thiserror"><code>thiserror</code> 稍微绕了个弯，对吧？但这是必要的！现在让我们回到正轨：自定义错误类型与 <code>thiserror</code>。</a></h1>
<h2 id="05_ticket_v2-12_thiserror-自定义错误类型"><a class="header" href="#05_ticket_v2-12_thiserror-自定义错误类型">自定义错误类型</a></h2>
<p>我们已经了解了如何为自定义错误类型“手动”实现 <code>Error</code> 特性。想象一下，如果你需要在代码库中的大多数错误类型上都这样做，那将产生大量的样板代码，不是吗？</p>
<p>通过使用 Rust 仓库 <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>，我们可以减少一些这样的样板代码。它提供了一个<strong>过程宏</strong>来简化自定义错误类型的创建。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(thiserror::Error, Debug)]
enum TicketNewError {
    #[error("{0}")]
    TitleError(String),
    #[error("{0}")]
    DescriptionError(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="05_ticket_v2-12_thiserror-你可以编写自己的宏"><a class="header" href="#05_ticket_v2-12_thiserror-你可以编写自己的宏">你可以编写自己的宏</a></h2>
<p>迄今为止，我们见到的所有 <code>derive</code> 宏都是由 Rust 标准库提供的。<code>thiserror::Error</code> 是第三方 <code>derive</code> 宏的第一个示例。</p>
<p><code>derive</code> 宏是<strong>过程宏</strong>的一个子集，过程宏是一种在编译时生成 Rust 代码的方式。虽然在这个课程中我们不会深入探讨如何编写过程宏的细节，但重要的是要明白你可以自己编写它们！这是一个更高级的 Rust 课程中会涉及的主题。</p>
<h2 id="05_ticket_v2-12_thiserror-自定义语法"><a class="header" href="#05_ticket_v2-12_thiserror-自定义语法">自定义语法</a></h2>
<p>每个过程宏都可以定义自己的语法，通常在仓库的文档中进行解释。以 <code>thiserror</code> 为例，我们有：</p>
<ul>
<li><code>#[derive(thiserror::Error)]</code>：这是使用 <code>thiserror</code> 协助为自定义错误类型派生 <code>Error</code> 特性的语法。</li>
<li><code>#[error("{0}")]</code>：这是为自定义错误类型的每个变体定义 <code>Display</code> 实现的语法。<code>{0}</code> 在错误被显示时会被变体的第零个字段（在此例中为 <code>String</code>）替换。</li>
</ul>
<h2 id="05_ticket_v2-12_thiserror-参考资料"><a class="header" href="#05_ticket_v2-12_thiserror-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/12_thiserror</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-13_try_from"></div><h1 id="05_ticket_v2-13_try_from-tryfrom-和-tryinto"><a class="header" href="#05_ticket_v2-13_try_from-tryfrom-和-tryinto"><code>TryFrom</code> 和 <code>TryInto</code></a></h1>
<p>在前一章中，我们学习了 <a href="#04_traits-08_from"><code>From</code> 和 <code>Into</code> 特性</a>，这是 Rust 中用于<strong>肯定不会出错</strong>类型转换的习惯用法接口。但如果转换不能保证成功呢？</p>
<p>我们现在对错误有足够的了解，可以讨论 <code>From</code> 和 <code>Into</code> 的<strong>可能出错</strong>对应物：<code>TryFrom</code> 和 <code>TryInto</code>。</p>
<h2 id="05_ticket_v2-13_try_from-tryfrom-和-tryinto-1"><a class="header" href="#05_ticket_v2-13_try_from-tryfrom-和-tryinto-1"><code>TryFrom</code> 和 <code>TryInto</code></a></h2>
<p><code>TryFrom</code> 和 <code>TryInto</code> 都定义在 <code>std::convert</code> 模块中，和 <code>From</code> 与 <code>Into</code> 一样。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TryFrom&lt;T&gt;: Sized {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

pub trait TryInto&lt;T&gt;: Sized {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>From</code>/<code>Into</code> 与 <code>TryFrom</code>/<code>TryInto</code> 之间的主要区别在于后者返回一个 <code>Result</code> 类型。这允许转换失败，并返回错误而不是导致恐慌。</p>
<h2 id="05_ticket_v2-13_try_from-selferror"><a class="header" href="#05_ticket_v2-13_try_from-selferror"><code>Self::Error</code></a></h2>
<p><code>TryFrom</code> 和 <code>TryInto</code> 都有一个关联的 <code>Error</code> 类型。这让每个实现都能指定自己的错误类型，理想情况下，该错误类型最适合尝试进行的转换。</p>
<p><code>Self::Error</code> 是一种引用在特性自身中定义的关联错误类型的方式。</p>
<h2 id="05_ticket_v2-13_try_from-互补性"><a class="header" href="#05_ticket_v2-13_try_from-互补性">互补性</a></h2>
<p>就像 <code>From</code> 和 <code>Into</code> 一样，<code>TryFrom</code> 和 <code>TryInto</code> 也是互补的特征。如果你为某个类型实现了 <code>TryFrom</code>，那么就会免费获得 <code>TryInto</code>。</p>
<h2 id="05_ticket_v2-13_try_from-参考资料"><a class="header" href="#05_ticket_v2-13_try_from-参考资料">参考资料</a></h2>
<ul>
<li>本节练习位于 <code>exercises/05_ticket_v2/13_try_from</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-14_source"></div><h1 id="05_ticket_v2-14_source-errorsource"><a class="header" href="#05_ticket_v2-14_source-errorsource"><code>Error::source</code></a></h1>
<p>There's one more thing we need to talk about to complete our coverage of the <code>Error</code> trait: the <code>source</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Full definition this time!
pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>source</code> method is a way to access the <strong>error cause</strong>, if any.<br />
Errors are often chained, meaning that one error is the cause of another: you have a high-level error (e.g.
cannot connect to the database) that is caused by a lower-level error (e.g. can't resolve the database hostname).
The <code>source</code> method allows you to "walk" the full chain of errors, often used when capturing error context in logs.</p>
<h2 id="05_ticket_v2-14_source-implementing-source"><a class="header" href="#05_ticket_v2-14_source-implementing-source">Implementing <code>source</code></a></h2>
<p>The <code>Error</code> trait provides a default implementation that always returns <code>None</code> (i.e. no underlying cause). That's why
you didn't have to care about <code>source</code> in the previous exercises.<br />
You can override this default implementation to provide a cause for your error type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

#[derive(Debug)]
struct DatabaseError {
    source: std::io::Error
}

impl std::fmt::Display for DatabaseError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "Failed to connect to the database")
    }
}

impl std::error::Error for DatabaseError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>DatabaseError</code> wraps an <code>std::io::Error</code> as its source.
We then override the <code>source</code> method to return this source when called.</p>
<h2 id="05_ticket_v2-14_source-dyn-error--static"><a class="header" href="#05_ticket_v2-14_source-dyn-error--static"><code>&amp;(dyn Error + 'static)</code></a></h2>
<p>What's this <code>&amp;(dyn Error + 'static)</code> type?<br />
Let's unpack it:</p>
<ul>
<li><code>dyn Error</code> is a <strong>trait object</strong>. It's a way to refer to any type that implements the <code>Error</code> trait.</li>
<li><code>'static</code> is a special <strong>lifetime specifier</strong>.
<code>'static</code> implies that the reference is valid for "as long as we need it", i.e. the entire program execution.</li>
</ul>
<p>Combined: <code>&amp;(dyn Error + 'static)</code> is a reference to a trait object that implements the <code>Error</code> trait
and is valid for the entire program execution.</p>
<p>Don't worry too much about either of these concepts for now. We'll cover them in more detail in future chapters.</p>
<h2 id="05_ticket_v2-14_source-implementing-source-using-thiserror"><a class="header" href="#05_ticket_v2-14_source-implementing-source-using-thiserror">Implementing <code>source</code> using <code>thiserror</code></a></h2>
<p><code>thiserror</code> provides three ways to automatically implement <code>source</code> for your error types:</p>
<ul>
<li>A field named <code>source</code> will automatically be used as the source of the error.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        source: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A field annotated with the <code>#[source]</code> attribute will automatically be used as the source of the error.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[source]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>A field annotated with the  <code>#[from]</code> attribute will automatically be used as the source of the error <strong>and</strong>
<code>thiserror</code> will automatically generate a <code>From</code> implementation to convert the annotated type into your error type.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[from]
        inner: std::io::Error
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="05_ticket_v2-14_source-the--operator"><a class="header" href="#05_ticket_v2-14_source-the--operator">The <code>?</code> operator</a></h2>
<p>The <code>?</code> operator is a shorthand for propagating errors.<br />
When used in a function that returns a <code>Result</code>, it will return early with an error if the <code>Result</code> is <code>Err</code>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = File::open("file.txt")?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = match File::open("file.txt") {
        Ok(file) =&gt; file,
        Err(e) =&gt; {
            return Err(e);
        }
    };
    let mut contents = String::new();
    match file.read_to_string(&amp;mut contents) {
        Ok(_) =&gt; (),
        Err(e) =&gt; {
            return Err(e);
        }
    }
    Ok(contents)
}
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>?</code> operator to shorten your error handling code significantly.<br />
In particular, the <code>?</code> operator will automatically convert the error type of the fallible operation into the error type
of the function, if a conversion is possible (i.e. if there is a suitable <code>From</code> implementation)</p>
<h2 id="05_ticket_v2-14_source-references"><a class="header" href="#05_ticket_v2-14_source-references">References</a></h2>
<ul>
<li>The exercise for this section is located in <code>exercises/05_ticket_v2/14_source</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="05_ticket_v2-15_outro"></div><h1 id="05_ticket_v2-15_outro-总结回顾"><a class="header" href="#05_ticket_v2-15_outro-总结回顾">总结回顾</a></h1>
<p>在领域建模中，细节决定成败。Rust 提供了丰富的工具集，帮助你直接在类型系统中表达领域约束，但这需要通过实践来熟练掌握，以编写出既正确又符合习惯的代码。</p>
<p>让我们通过对 <code>Ticket</code> 模型的最后一次优化来结束这一章。我们将为 <code>Ticket</code> 结构体中的每个字段引入一个新的类型，以封装各自的具体约束。这样一来，每次有人访问 <code>Ticket</code> 的字段时，他们得到的都将是一个确保有效的值——比如，一个 <code>TicketTitle</code> 而非一个普通的 <code>String</code>。他们在代码的其他部分就不必担心标题为空的问题了：只要他们拥有了一个 <code>TicketTitle</code>，就可以凭借其构造方式知道它是有效的。</p>
<p>这仅仅是利用 Rust 类型系统使你的代码更安全、更具表现力的一个示例。</p>
<h2 id="05_ticket_v2-15_outro-参考练习"><a class="header" href="#05_ticket_v2-15_outro-参考练习">参考练习</a></h2>
<ul>
<li>本节相关的练习位于 <code>exercises/05_ticket_v2/15_outro</code></li>
</ul>
<h2 id="05_ticket_v2-15_outro-深入阅读"><a class="header" href="#05_ticket_v2-15_outro-深入阅读">深入阅读</a></h2>
<ul>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">解析而非验证</a></li>
<li><a href="https://www.lpalmieri.com/posts/2020-12-11-zero-to-production-6-domain-modelling/">利用类型保证领域不变量</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-00_intro"></div><h1 id="06_ticket_management-00_intro-引言"><a class="header" href="#06_ticket_management-00_intro-引言">引言</a></h1>
<p>在上一章中，我们在一个孤立的环境中对 <code>Ticket</code> 进行了建模：我们定义了其字段及其约束，学习了如何用 Rust 最好地表示它们，但我们并未考虑 <code>Ticket</code> 如何融入更大的系统中。本章将围绕 <code>Ticket</code> 构建一个简单的工作流程，引入一个基本的管理系统来存储和检索票据。</p>
<p>此任务将为我们提供探索 Rust 新概念的机会，包括：</p>
<ul>
<li>堆分配的数组</li>
<li><code>Vec</code>，一种可增长的数组类型，以及切片</li>
<li><code>Iterator</code> 和 <code>IntoIterator</code>，用于遍历集合</li>
<li>切片（<code>&amp;[T]</code>），用于操作集合的部分</li>
<li>生命周期，描述引用的有效期</li>
<li><code>HashMap</code> 和 <code>BTreeMap</code>，两种键值数据结构</li>
<li><code>Eq</code> 和 <code>Hash</code>，用于在 <code>HashMap</code> 中比较键</li>
<li><code>Ord</code> 和 <code>PartialOrd</code>，用于操作 <code>BTreeMap</code></li>
<li><code>Index</code> 和 <code>IndexMut</code>，用于访问集合中的元素</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-01_arrays"></div><h1 id="06_ticket_management-01_arrays-数组"><a class="header" href="#06_ticket_management-01_arrays-数组">数组</a></h1>
<p>一旦开始讨论“票务管理”，我们就需要考虑一种存储<strong>多个</strong>票据**的方法。这进而意味着我们需要考虑集合，尤其是同质集合：我们希望存储同一类型的多个实例。</p>
<p>在这方面，Rust 提供了哪些工具呢？</p>
<h2 id="06_ticket_management-01_arrays-数组-1"><a class="header" href="#06_ticket_management-01_arrays-数组-1">数组</a></h2>
<p>初次尝试可以是使用<strong>数组</strong>。<br />
Rust 中的数组是固定大小、元素类型相同的集合。</p>
<p>定义数组的方法如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 数组类型语法：[ &lt;类型&gt; ; &lt;元素数量&gt; ]
let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>这创建了一个包含三个整数的数组，并初始化为值 <code>1</code>、<code>2</code> 和 <code>3</code>。数组的类型是 <code>[u32; 3]</code>，意为“长度为3的 <code>u32</code> 类型数组”。</p>
<h3 id="06_ticket_management-01_arrays-访问元素"><a class="header" href="#06_ticket_management-01_arrays-访问元素">访问元素</a></h3>
<p>你可以使用方括号访问数组的元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>索引必须为 <code>usize</code>类型。数组是<strong>从零开始索引</strong>的，这在 Rust 中很常见。你之前在字符串切片和元组/类似元组变体的字段索引中见过这一点。</p>
<h3 id="06_ticket_management-01_arrays-越界访问"><a class="header" href="#06_ticket_management-01_arrays-越界访问">越界访问</a></h3>
<p>如果你试图访问越界的元素，Rust 会引发恐慌：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
let fourth = numbers[3]; // 这将引发恐慌
<span class="boring">}</span></code></pre></pre>
<p>这是通过<strong>边界检查</strong>在运行时强制执行的。它会带来一点性能开销，但也是 Rust 防止缓冲区溢出的方式。<br />
在某些场景下，Rust 编译器可以优化掉边界检查，特别是涉及到迭代器时——我们稍后会详细讨论这一点。</p>
<p>如果你不想触发恐慌，可以使用 <code>get</code> 方法，它返回 <code>Option&lt;&amp;T&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// 如果尝试访问越界索引，你会得到 `None` 而不是恐慌。
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<h3 id="06_ticket_management-01_arrays-性能"><a class="header" href="#06_ticket_management-01_arrays-性能">性能</a></h3>
<p>由于数组的大小在编译时已知，编译器可以将数组分配在栈上。如果运行以下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [u32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>你将得到以下内存布局：</p>
<pre><code class="language-text">       +---+---+---+
Stack:  | 1 | 2 | 3 |
       +---+---+---+
</code></pre>
<p>换句话说，数组的大小是 <code>std::mem::size_of::&lt;T&gt;() * N</code>，其中 <code>T</code> 是元素的类型，<code>N</code> 是元素的数量。<br />
你可以以 <code>O(1)</code> 时间复杂度访问和替换每个元素。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-02_vec"></div><h1 id="06_ticket_management-02_vec-向量"><a class="header" href="#06_ticket_management-02_vec-向量">向量</a></h1>
<p>数组的优势也恰恰是其局限所在：其大小必须在编译时预先确定。如果你尝试创建一个大小仅在运行时才知道的数组，将会遇到编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n = 10;
let numbers: [u32; n];
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error[E0435]: 尝试在常量中使用非常量值
 --&gt; src/main.rs:3:20
  |
2 | let n = 10;
3 | let numbers: [u32; n];
  |                    ^ 非常量值
</code></pre>
<p>对于票务管理系统来说，数组并不适用——我们在编译时不知道需要存储多少张票。这时候，<code>Vec</code>就派上用场了。</p>
<h2 id="06_ticket_management-02_vec-vec"><a class="header" href="#06_ticket_management-02_vec-vec"><code>Vec</code></a></h2>
<p><code>Vec</code>是标准库提供的一个可增长的数组类型。<br />
你可以使用<code>Vec::new</code>函数创建一个空的向量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers: Vec&lt;u32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>然后，你可以使用<code>push</code>方法向向量中添加元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>numbers.push(1);
numbers.push(2);
numbers.push(3);
<span class="boring">}</span></code></pre></pre>
<p>新值会被追加到向量的末尾。<br />
如果在创建时就知道元素值，也可以使用<code>vec!</code>宏来创建一个初始化的向量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-02_vec-访问元素"><a class="header" href="#06_ticket_management-02_vec-访问元素">访问元素</a></h2>
<p>访问元素的语法与数组相同：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
<span class="boring">}</span></code></pre></pre>
<p>索引必须是<code>usize</code>类型。<br />
同样，你也可以使用<code>get</code>方法，它返回一个<code>Option&lt;&amp;T&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
assert_eq!(numbers.get(0), Some(&amp;1));
// 如果尝试访问越界索引，会得到 `None` 而不是恐慌。
assert_eq!(numbers.get(3), None);
<span class="boring">}</span></code></pre></pre>
<p>访问同样进行了边界检查，复杂度为O(1)。</p>
<h2 id="06_ticket_management-02_vec-内存布局"><a class="header" href="#06_ticket_management-02_vec-内存布局">内存布局</a></h2>
<p><code>Vec</code>是一个堆分配的数据结构。<br />
当你创建一个<code>Vec</code>时，它会在堆上分配内存来存储元素。</p>
<p>如果运行以下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<p>得到的内存布局如下：</p>
<pre><code class="language-text">      +---------+--------+----------+
栈    | 指针 | 长度 | 容量 | 
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
堆:   | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p><code>Vec</code>跟踪三件事：</p>
<ul>
<li><strong>指针</strong>到你预留的堆区域。</li>
<li><strong>长度</strong>，即向量中有多少个元素。</li>
<li><strong>容量</strong>，即堆上预留空间能容纳的元素数量。</li>
</ul>
<p>这个布局应该很眼熟：它和<code>String</code>完全一样！这不是巧合：<code>String</code>本质上在内部定义为字节的向量，即<code>Vec&lt;u8&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct String {
    vec: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-03_resizing"></div><h1 id="06_ticket_management-03_resizing-重新调整大小"><a class="header" href="#06_ticket_management-03_resizing-重新调整大小">重新调整大小</a></h1>
<p>我们提到过<code>Vec</code>是一种“可增长”的向量类型，但这具体意味着什么呢？
如果尝试在一个已经达到最大容量的<code>Vec</code>中插入一个元素会发生什么？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
numbers.push(3); // 达到最大容量
numbers.push(4); // 这里会发生什么？
<span class="boring">}</span></code></pre></pre>
<p>这时，<code>Vec</code>将会<strong>自动扩容</strong>。<br />
它会向分配器请求一块新的（更大）堆内存，将所有元素复制过去，并释放旧的内存空间。</p>
<p>这个操作可能会比较昂贵，因为它涉及到了新的内存分配及现有所有元素的复制过程。</p>
<h2 id="06_ticket_management-03_resizing-vecwith_capacity"><a class="header" href="#06_ticket_management-03_resizing-vecwith_capacity"><code>Vec::with_capacity</code></a></h2>
<p>如果你对将要在<code>Vec</code>中存储多少个元素有个大概的预估，可以使用<code>Vec::with_capacity</code>方法预先分配足够的内存。<br />
这可以在<code>Vec</code>增长时避免新的内存分配操作，但如果你高估了实际使用量，也可能造成内存浪费。</p>
<p>这需要根据具体情况具体分析权衡。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-04_iterators"></div><h1 id="06_ticket_management-04_iterators-迭代"><a class="header" href="#06_ticket_management-04_iterators-迭代">迭代</a></h1>
<p>在最初的几个练习中，你已经了解到 Rust 允许你使用 <code>for</code> 循环遍历集合。当时我们处理的是范围（例如 <code>0..5</code>），但同样的规则也适用于数组和向量这样的集合。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于 `Vec` 有效
let v = vec![1, 2, 3];
for n in &amp;v {
    println!("{}", n);
}

// 对于数组也有效
let a: [u32; 3] = [1, 2, 3];
for n in a.iter() {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>现在，是时候了解这背后的原理了。</p>
<h2 id="06_ticket_management-04_iterators-for-循环的展开"><a class="header" href="#06_ticket_management-04_iterators-for-循环的展开"><code>for</code> 循环的展开</a></h2>
<p>每次你在 Rust 中编写 <code>for</code> 循环时，编译器都会将其转换为如下代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = v.into_iter();
loop {
    match iter.next() {
        Some(n) =&gt; {
            println!("{}", n);
        }
        None =&gt; break,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>loop</code> 是除了 <code>for</code> 和 <code>while</code> 外的另一种循环结构。<br />
<code>loop</code> 块会无限循环，除非你明确地使用 <code>break</code> 退出它。</p>
<h2 id="06_ticket_management-04_iterators-iterator-特性"><a class="header" href="#06_ticket_management-04_iterators-iterator-特性"><code>Iterator</code> 特性</a></h2>
<p>前面代码片段中的 <code>next</code> 方法来自 <code>Iterator</code> 特性。
<code>Iterator</code> 特性在 Rust 标准库中定义，为能够产生一系列值的类型提供了一个共享接口：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Item</code> 关联类型指定了由迭代器产生的值的类型。</p>
<p><code>next</code> 返回序列中的下一个值。<br />
如果有值返回，则返回 <code>Some(value)</code>；如果没有，则返回 <code>None</code>。</p>
<p>请注意：迭代器返回 <code>None</code> 并不能保证它已被耗尽。只有当迭代器实现了更严格的
<a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> 特性时，才会有此保证。</p>
<h2 id="06_ticket_management-04_iterators-intoiterator-特性"><a class="header" href="#06_ticket_management-04_iterators-intoiterator-特性"><code>IntoIterator</code> 特性</a></h2>
<p>并非所有类型都实现了 <code>Iterator</code>，但许多类型可以转换为实现了该特性的类型。<br />
这就是 <code>IntoIterator</code> 特性的作用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p><code>into_iter</code> 方法消耗原始值并返回其元素的迭代器。<br />
一个类型只能有一个 <code>IntoIterator</code> 的实现：对于 <code>for</code> 应该展开为什么形式不存在任何歧义。</p>
<p>一个小细节：任何实现了 <code>Iterator</code> 的类型也会自动实现 <code>IntoIterator</code>。它们只是从 <code>into_iter</code> 返回自己！</p>
<h2 id="06_ticket_management-04_iterators-边界检查"><a class="header" href="#06_ticket_management-04_iterators-边界检查">边界检查</a></h2>
<p>迭代迭代器有一个很好的副作用：设计上你不可能越界。<br />
这让 Rust 能够从生成的机器代码中移除边界检查，从而加快迭代速度。</p>
<p>换言之，</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}
<span class="boring">}</span></code></pre></pre>
<p>通常比</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for i in 0..v.len() {
    println!("{}", v[i]);
}
<span class="boring">}</span></code></pre></pre>
<p>更快。当然，也有例外：编译器有时能证明即使手动索引也不会越界，因此也会移除边界检查。但一般而言，尽可能选择迭代而非索引。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-05_iter"></div><h1 id="06_ticket_management-05_iter-iter方法"><a class="header" href="#06_ticket_management-05_iter-iter方法">iter方法</a></h1>
<p><code>IntoIterator</code> <strong>消耗</strong> <code>self</code> 以创建一个迭代器。</p>
<p>这样做的好处是：你可以从迭代器中获取<strong>拥有所有权</strong>的值。例如，如果你在一个 <code>Vec&lt;Ticket&gt;</code> 上调用 <code>.into_iter()</code>，你会得到一个返回 <code>Ticket</code> 值的迭代器。</p>
<p>但这同时也是它的缺点：在调用了 <code>.into_iter()</code> 后，你不能再使用原来的集合。
很多时候，你希望在不消耗集合的情况下遍历它，而是查看对值的<strong>引用</strong>。
以 <code>Vec&lt;Ticket&gt;</code> 为例，你可能想要遍历 <code>&amp;Ticket</code> 类型的值。</p>
<p>大多数集合都提供了一个名为 <code>.iter()</code> 的方法，它返回一个迭代器，该迭代器提供对集合元素的引用。
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// 在这里，`n` 的类型为 `&amp;u32`
for n in numbers.iter() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>这种模式可以通过为<strong>集合的引用</strong>实现 <code>IntoIterator</code> 来简化。
在上面的例子中，那就是 <code>&amp;Vec&lt;Ticket&gt;</code>。
标准库就是这样做的，所以以下代码能够工作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: Vec&lt;u32&gt; = vec![1, 2];
// 在这里，`n` 的类型为 `&amp;u32`
// 我们不必显式地调用 `.iter()`
// 在 `for` 循环中直接使用 `&amp;numbers` 就足够了
for n in &amp;numbers {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>通常情况下，提供两种选项是惯用的做法：</p>
<ul>
<li>为集合的引用实现 <code>IntoIterator</code>。</li>
<li>提供一个 <code>.iter()</code> 方法，它返回一个迭代器，该迭代器提供对集合元素的引用。</li>
</ul>
<p>前者在 <code>for</code> 循环中更为方便，后者则更加明确，可以在其他上下文中使用。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-06_lifetimes"></div><h1 id="06_ticket_management-06_lifetimes-生命周期"><a class="header" href="#06_ticket_management-06_lifetimes-生命周期">生命周期</a></h1>
<p>让我们尝试通过为 <code>&amp;TicketStore</code> 添加 <code>IntoIterator</code> 的实现来完成之前的练习，以便在 <code>for</code> 循环中获得最大的便利性。</p>
<p>首先，我们填写实现中最“明显”的部分：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoIterator for &amp;TicketStore {
    type Item = &amp;Ticket;
    type IntoIter = // 这里应该填什么类型?

    fn into_iter(self) -&gt; Self::IntoIter {
        self.tickets.iter()
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>type IntoIter</code> 应该设置为什么类型呢？直观地，它应该是由 <code>self.tickets.iter()</code> 返回的类型，即 <code>Vec::iter()</code> 返回的类型。如果你查阅标准库文档，你会发现 <code>Vec::iter()</code> 返回了一个 <code>std::slice::Iter</code>。<code>Iter</code> 的定义是：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; { /* 字段省略 */ }
<span class="boring">}</span></code></pre></pre>
<p><code>'a</code> 是一个 <strong>生命周期参数</strong>。</p>
<h2 id="06_ticket_management-06_lifetimes-生命周期参数"><a class="header" href="#06_ticket_management-06_lifetimes-生命周期参数">生命周期参数</a></h2>
<p>生命周期是 Rust 编译器用来追踪引用（无论是可变还是不可变）有效时间的 <strong>标签</strong>。<br />
引用的生命周期受到它所指向值的作用域限制。Rust 总是在编译时确保引用不会在其指向的值被丢弃后使用，以避免悬挂指针和使用已释放内存的错误。</p>
<p>这听起来应该很熟悉：在讨论所有权和借用时，我们已经看到过这些概念的应用。生命周期只是给特定引用的有效时间 <strong>命名</strong> 的方式。</p>
<p>当存在多个引用并且需要澄清它们彼此之间的 <strong>关联关系</strong> 时，命名变得重要。让我们看看 <code>Vec::iter()</code> 的签名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    // 稍作简化
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec::iter()</code> 对一个名为 <code>'a</code> 的生命周期参数是泛型的。<br />
<code>'a</code> 用来 <strong>绑定</strong> <code>Vec</code> 的生命周期和由 <code>iter()</code> 返回的 <code>Iter</code> 的生命周期。通俗地说：由 <code>iter()</code> 返回的 <code>Iter</code> 不能超过创建它的 <code>Vec</code> 引用（<code>&amp;self</code>）的生命周期。</p>
<p>这一点很重要，因为如前所述，<code>Vec::iter</code> 返回的是 <strong>对 <code>Vec</code> 元素的引用</strong>。如果 <code>Vec</code> 被丢弃，迭代器返回的引用将无效。Rust 必须确保这种情况不会发生，而生命周期就是它用来实施这一规则的工具。</p>
<h2 id="06_ticket_management-06_lifetimes-生命周期省略"><a class="header" href="#06_ticket_management-06_lifetimes-生命周期省略">生命周期省略</a></h2>
<p>Rust 有一套称为 <strong>生命周期省略规则</strong> 的规则，在很多情况下允许你省略显式的生命周期注解。例如，<code>Vec::iter</code> 在 <code>std</code> 源代码中的定义是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T&gt; Vec&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>Vec::iter()</code> 的签名中没有显式的生命周期参数。省略规则意味着 <code>iter()</code> 返回的 <code>Iter</code> 的生命周期与 <code>&amp;self</code> 引用的生命周期相关联。你可以把 <code>'_</code> 当作 <strong>占位符</strong> 来理解，代表 <code>&amp;self</code> 引用的生命周期。</p>
<p>有关生命周期省略的官方文档链接，请参阅 <a href="#06_ticket_management-06_lifetimes-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a> 部分。在大多数情况下，你可以依赖编译器告诉你何时需要添加显式的生命周期注解。</p>
<h2 id="06_ticket_management-06_lifetimes-参考资料"><a class="header" href="#06_ticket_management-06_lifetimes-参考资料">参考资料</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter">std::vec::Vec::iter</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/struct.Iter.html">std::slice::Iter</a></li>
<li><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">生命周期省略规则</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-07_combinators"></div><h1 id="06_ticket_management-07_combinators-组合子"><a class="header" href="#06_ticket_management-07_combinators-组合子">组合子</a></h1>
<p>迭代器能做的远不止是 <code>for</code> 循环！<br />
如果你查阅 <code>Iterator</code> 特性的文档，你会发现大量的方法集合，可以用来以各种方式转换、过滤和组合迭代器。</p>
<p>这里列举一些最常见的：</p>
<ul>
<li><code>map</code> 对迭代器中的每个元素应用一个函数。</li>
<li><code>filter</code> 只保留满足谓词的元素。</li>
<li><code>filter_map</code> 结合了 <code>filter</code> 和 <code>map</code> 的功能，一步完成过滤和映射。</li>
<li><code>cloned</code> 将引用迭代器转换为值迭代器，并克隆每个元素。</li>
<li><code>enumerate</code> 返回一个新的迭代器，产生 <code>(索引, 值)</code> 对。</li>
<li><code>skip</code> 跳过迭代器的前 <code>n</code> 个元素。</li>
<li><code>take</code> 在处理完 <code>n</code> 个元素后停止迭代器。</li>
<li><code>chain</code> 将两个迭代器合并为一个。</li>
</ul>
<p>这些方法被称为 <strong>组合子</strong>。<br />
它们通常被 <strong>链式调用</strong> 来以简洁且易于阅读的方式创建复杂的转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
// 偶数的平方和
let outcome: u32 = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-07_combinators-闭包"><a class="header" href="#06_ticket_management-07_combinators-闭包">闭包</a></h2>
<p>上述 <code>filter</code> 和 <code>map</code> 方法是怎么回事呢？<br />
它们接受 <strong>闭包</strong> 作为参数。</p>
<p>闭包是 <strong>匿名函数</strong>，即不由我们熟悉的 <code>fn</code> 语法定义的函数。<br />
它们使用 <code>|args| body</code> 语法定义，其中 <code>args</code> 是参数，<code>body</code> 是函数体。<code>body</code> 可以是一段代码块或单个表达式。
例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 一个给其参数加1的匿名函数
let add_one = |x| x + 1;
// 也可以用代码块写：
let add_one = |x| { x + 1 };
<span class="boring">}</span></code></pre></pre>
<p>闭包可以接受多个参数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;
let sum = add(1, 2);
<span class="boring">}</span></code></pre></pre>
<p>它们还能捕获环境中的变量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
let add_x = |y| x + y;
let sum = add_x(1);
<span class="boring">}</span></code></pre></pre>
<p>必要时，你可以指定参数和/或返回类型的类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 只指定输入类型
let add_one = |x: i32| x + 1;
// 或者同时指定输入和输出类型，使用 `fn` 语法
let add_one: fn(i32) -&gt; i32 = |x| x + 1;
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-07_combinators-collect"><a class="header" href="#06_ticket_management-07_combinators-collect"><code>collect</code></a></h2>
<p>使用组合子转换完迭代器后怎么办？<br />
你可以使用 <code>for</code> 循环遍历转换后的值，或者将它们收集到集合中。</p>
<p>后者通过 <code>collect</code> 方法完成。<br />
<code>collect</code> 消耗尽迭代器并将其元素收集到你选择的集合中。</p>
<p>例如，你可以将偶数的平方收集到一个 <code>Vec</code> 中：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3, 4, 5];
let squares_of_evens: Vec&lt;u32&gt; = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    .collect();
<span class="boring">}</span></code></pre></pre>
<p><code>collect</code> 对其 <strong>返回类型</strong> 是泛型的。<br />
因此，通常需要提供类型提示帮助编译器推断正确的类型。
在上面的例子中，我们标注了 <code>squares_of_evens</code> 的类型为 <code>Vec&lt;u32&gt;</code>。
或者，你可以使用 <strong>turbofish语法</strong> 来指定类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let squares_of_evens = numbers.iter()
    .filter(|&amp;n| n % 2 == 0)
    .map(|&amp;n| n * n)
    // turbofish语法：`&lt;method_name&gt;::&lt;type&gt;()`
    // 因为 `::&lt;&gt;` 看起来像一条鱼，故得名turbofish
    .collect::&lt;Vec&lt;u32&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-07_combinators-进一步学习"><a class="header" href="#06_ticket_management-07_combinators-进一步学习">进一步学习</a></h2>
<ul>
<li><code>Iterator</code> 的<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">文档</a>概述了标准库中迭代器可用的方法。</li>
<li><a href="https://docs.rs/itertools/">itertools 库</a>定义了更多针对迭代器的 <strong>组合子</strong>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-08_impl_trait"></div><h1 id="06_ticket_management-08_impl_trait-impl-trait"><a class="header" href="#06_ticket_management-08_impl_trait-impl-trait"><code>impl Trait</code></a></h1>
<p><code>TicketStore::to_dos</code> 返回一个 <code>Vec&lt;&amp;Ticket&gt;</code>。这样的签名导致每次调用 <code>to_dos</code> 时都会进行一次堆分配，而实际上根据调用者的后续操作，这可能是不必要的开销。如果 <code>to_dos</code> 能返回一个迭代器而不是 <code>Vec</code>，就能让调用者决定是否将结果收集到 <code>Vec</code> 中或直接进行迭代，这样会更佳。</p>
<p>但这有点棘手！下面这样实现的 <code>to_dos</code> 返回类型是什么呢？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; ??? {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-08_impl_trait-无法命名的类型"><a class="header" href="#06_ticket_management-08_impl_trait-无法命名的类型">无法命名的类型</a></h2>
<p><code>filter</code> 方法返回一个 <code>std::iter::Filter</code> 实例，其定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Filter&lt;I, P&gt; { /* 省略字段 */}
<span class="boring">}</span></code></pre></pre>
<p>这里 <code>I</code> 是被过滤的迭代器的类型，<code>P</code> 是用于过滤元素的谓词。我们知道在这个例子中 <code>I</code> 是 <code>std::slice::Iter&lt;'_, Ticket&gt;</code>，但 <code>P</code> 呢？<code>P</code> 是一个闭包，一个<strong>匿名函数</strong>。正如其名所示，闭包没有名字，所以我们无法直接在代码中写出它的类型。</p>
<p>Rust 对此提供了一个解决方案：<strong>impl Trait</strong>。</p>
<h2 id="06_ticket_management-08_impl_trait-impl-trait-1"><a class="header" href="#06_ticket_management-08_impl_trait-impl-trait-1"><code>impl Trait</code></a></h2>
<p><code>impl Trait</code> 是一个特性，允许你在不指定类型名称的情况下返回类型。你只需声明类型实现了哪些特征（trait），剩下的交给 Rust 解决。</p>
<p>在这种情况下，我们想返回一个对 <code>Ticket</code> 的引用的迭代器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TicketStore {
    pub fn to_dos(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Ticket&gt; {
        self.tickets.iter().filter(|t| t.status == Status::ToDo)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这就对了！</p>
<h2 id="06_ticket_management-08_impl_trait-泛型吗"><a class="header" href="#06_ticket_management-08_impl_trait-泛型吗">泛型吗？</a></h2>
<p>返回位置上的 <code>impl Trait</code> <strong>不是</strong> 泛型参数。</p>
<p>泛型是函数调用者填充的类型占位符。具有泛型参数的函数是<strong>多态</strong>的：它可以被不同类型的调用，并且编译器会为每种类型生成不同的实现。</p>
<p>而 <code>impl Trait</code> 不是这样。带有 <code>impl Trait</code> 的函数的返回类型在编译时是<strong>固定的</strong>，编译器会为其生成单一的实现。这也是为什么 <code>impl Trait</code> 也被称作<strong>不透明返回类型</strong>：调用者不知道返回值的确切类型，只知道它实现了指定的特征（trait）。但编译器知道确切的类型，这里不涉及多态。</p>
<h2 id="06_ticket_management-08_impl_trait-rpit"><a class="header" href="#06_ticket_management-08_impl_trait-rpit">RPIT</a></h2>
<p>如果你阅读 Rust 的 RFC 或深入探讨文章，可能会遇到 <strong>RPIT</strong> 这个缩写。它代表 <strong>"Return Position Impl Trait"</strong>，指的是在返回位置使用 <code>impl Trait</code> 的情况。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-09_impl_trait_2"></div><h1 id="06_ticket_management-09_impl_trait_2-impl-trait-作为参数位置的使用"><a class="header" href="#06_ticket_management-09_impl_trait_2-impl-trait-作为参数位置的使用"><code>impl Trait</code> 作为参数位置的使用</a></h1>
<p>在前一节中，我们了解了如何使用 <code>impl Trait</code> 在不指定具体类型名称的情况下返回类型。同样的语法也可以用于<strong>参数位置</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter(iter: impl Iterator&lt;Item = i32&gt;) {
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>print_iter</code> 函数接收一个 <code>i32</code> 类型的迭代器并打印每个元素。当在<strong>参数位置</strong>使用 <code>impl Trait</code> 时，它等同于带有特质界限的泛型参数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter&lt;T&gt;(iter: T) 
where
    T: Iterator&lt;Item = i32&gt;
{
    for i in iter {
        println!("{}", i);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-09_impl_trait_2-不利之处"><a class="header" href="#06_ticket_management-09_impl_trait_2-不利之处">不利之处</a></h2>
<p>一般而言，相较于在参数位置使用 <code>impl Trait</code>，优先考虑使用泛型更为适宜。泛型允许调用者通过涡轮鱼语法（<code>::&lt;&gt;</code>）显式指定参数的类型，这对于消除类型歧义非常有用，而这是 <code>impl Trait</code> 所不具备的。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-10_slices"></div><h1 id="06_ticket_management-10_slices-切片slices"><a class="header" href="#06_ticket_management-10_slices-切片slices">切片(Slices)</a></h1>
<p>让我们回到 <code>Vec</code> 的内存布局：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
Heap:  | 1 | 2 | ? |
       +---+---+---+
</code></pre>
<p>我们之前提到过 <code>String</code> 实际上是伪装过的 <code>Vec&lt;u8&gt;</code>。这种相似性应该促使你发问：“对于 <code>Vec</code>，是否存在类似于 <code>&amp;str</code> 的东西？”</p>
<h2 id="06_ticket_management-10_slices-t"><a class="header" href="#06_ticket_management-10_slices-t"><code>&amp;[T]</code></a></h2>
<p><code>[T]</code> 是类型为 <code>T</code> 的连续元素序列的<strong>切片</strong>。它最常以引用形式 <code>&amp;[T]</code> 出现。</p>
<p>有多种方式可以从 <code>Vec</code> 创建切片引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// 通过索引语法
let slice: &amp;[i32] = &amp;numbers[..];
// 通过方法
let slice: &amp;[i32] = numbers.as_slice();
// 或仅针对元素的子集
let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p><code>Vec</code> 使用 <code>[T]</code> 作为目标类型实现了 <code>Deref</code> 特性，因此由于解引用强制转换，你可以在 <code>Vec</code> 直接使用切片方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
// 惊喜！“iter”并不是“Vec”上的方法！
// 它实际上是 “&amp;[T]” 上的方法，但由于解引用强制，
// 你可以在 “Vec” 上直接调用它。
let sum: i32 = numbers.iter().sum();
<span class="boring">}</span></code></pre></pre>
<h3 id="06_ticket_management-10_slices-内存布局"><a class="header" href="#06_ticket_management-10_slices-内存布局">内存布局</a></h3>
<p><code>&amp;[T]</code> 是一个<strong>宽指针</strong>，就像 <code>&amp;str</code> 一样。它由指向切片第一个元素的指针和切片长度组成。</p>
<p>如果你有一个包含三个元素的 <code>Vec</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>然后创建一个切片引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slice: &amp;[i32] = &amp;numbers[1..];
<span class="boring">}</span></code></pre></pre>
<p>你会得到这样的内存布局：</p>
<pre><code class="language-text">                  numbers                          slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   3    |    4     |      |    |    |   2    |
      +----|----+--------+----------+      +----|----+--------+
           |                                    |  
           |                                    |
           v                                    | 
         +---+---+---+---+                      |
Heap:    | 1 | 2 | 3 | ? |                      |
         +---+---+---+---+                      |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<h3 id="06_ticket_management-10_slices-vect-与-t-的比较"><a class="header" href="#06_ticket_management-10_slices-vect-与-t-的比较"><code>&amp;Vec&lt;T&gt;</code> 与 <code>&amp;[T]</code> 的比较</a></h3>
<p>当你需要将 <code>Vec</code> 的不可变引用传递给函数时，优选 <code>&amp;[T]</code> 而非 <code>&amp;Vec&lt;T&gt;</code>。这使得函数能够接受任何形式的切片，而不一定是由 <code>Vec</code> 支持的。</p>
<p>例如，你可以传递 <code>Vec</code> 中元素的子集。
但不仅如此，你还可以传递<strong>数组的切片</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let slice: &amp;[i32] = &amp;array;
<span class="boring">}</span></code></pre></pre>
<p>数组切片和 <code>Vec</code> 切片是相同类型：它们都是指向连续元素序列的宽指针。对于数组来说，指针指向栈而非堆，但在使用切片时这一点并不重要。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-11_mutable_slices"></div><h1 id="06_ticket_management-11_mutable_slices-可变切片"><a class="header" href="#06_ticket_management-11_mutable_slices-可变切片">可变切片</a></h1>
<p>当我们谈及切片类型，比如字符串切片（&amp;str）和泛型切片（[T]）时，我们通常指的是它们的不可变借用形式（&amp;str 和 &amp;[T]）。但实际上，切片也支持可变形式！</p>
<p>创建可变切片的方式如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = vec![1, 2, 3];  
let slice: &amp;mut [i32] = &amp;mut numbers;
<span class="boring">}</span></code></pre></pre>
<p>之后，你就可以通过这个可变切片来修改其内部元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>slice[0] = 42;
<span class="boring">}</span></code></pre></pre>
<p>这样就将 <code>Vec</code> 中的第一个元素改为了 42。</p>
<h2 id="06_ticket_management-11_mutable_slices-限制"><a class="header" href="#06_ticket_management-11_mutable_slices-限制">限制</a></h2>
<p>在使用不可变借用时，规则相对明确：推荐优先采用切片引用（如 &amp;[T]）而非容器本身的引用（如 &amp;Vec<T>）。然而，在可变借用的场景下，情况有所不同。</p>
<p>思考以下示例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = Vec::with_capacity(2);  
let mut slice: &amp;mut [i32] = &amp;mut numbers;  
slice.push(1);
<span class="boring">}</span></code></pre></pre>
<p>这段代码将无法通过编译！原因在于，<code>push</code> 方法是属于 <code>Vec</code> 的，而不是切片的。这反映了一个普遍原则：Rust 不允许直接通过切片来增加或减少元素数量。你仅能修改已存在的元素内容。</p>
<p>从这个角度看，&amp;mut Vec 或 &amp;mut String 相较于 &amp;mut [T] 或 &amp;mut str 提供了更多的功能，因为它们允许对容器本身的结构进行修改，比如添加或移除元素。</p>
<p>因此，你应该根据实际需求选择最合适的类型：如果只需修改数据而不涉及容器结构变化，可使用可变切片；若需调整容器大小，则应采用容器本身的可变引用。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-12_two_states"></div><h1 id="06_ticket_management-12_two_states-工单编号"><a class="header" href="#06_ticket_management-12_two_states-工单编号">工单编号</a></h1>
<p>让我们再次思考一下我们的工单管理系统。目前，我们的工单模型是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>这里缺少了一样东西：一个用来<strong>唯一标识</strong>工单的<strong>编号</strong>。这个编号对每个工单都应该是唯一的。我们可以在创建新工单时自动生成编号来保证这一点。</p>
<h2 id="06_ticket_management-12_two_states-优化模型"><a class="header" href="#06_ticket_management-12_two_states-优化模型">优化模型</a></h2>
<p>编号应该存储在哪里呢？我们可以在 <code>Ticket</code> 结构体中添加一个新的字段：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>但我们在创建工单之前是不知道这个编号的。因此，一开始它不能存在。它必须是可选的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ticket {
    pub id: Option&lt;TicketId&gt;,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p>这也不是理想的情况——每次我们从存储中检索工单时，都不得不处理 <code>None</code> 的情况，尽管我们知道一旦工单被创建，编号就应该始终存在。</p>
<p>最佳的解决方案是设置工单的两种<strong>状态</strong>，由两个不同的类型表示：<code>TicketDraft</code>（工单草稿）和 <code>Ticket</code>（正式工单）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TicketDraft {
    pub title: TicketTitle,
    pub description: TicketDescription
}

pub struct Ticket {
    pub id: TicketId,
    pub title: TicketTitle,
    pub description: TicketDescription,
    pub status: Status
}
<span class="boring">}</span></code></pre></pre>
<p><code>TicketDraft</code> 是尚未创建的工单，它没有编号，也没有状态。而 <code>Ticket</code> 是已经创建的工单，它既有编号也有状态。由于 <code>TicketDraft</code> 和 <code>Ticket</code> 中的每个字段都嵌入了自己的约束，我们不需要在两个类型之间重复逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-13_index"></div><h1 id="06_ticket_management-13_index-索引"><a class="header" href="#06_ticket_management-13_index-索引">索引</a></h1>
<p><code>TicketStore::get</code> 方法针对给定的 <code>TicketId</code> 返回一个 <code>Option&lt;&amp;Ticket&gt;</code>。之前我们已经了解了如何使用 Rust 的索引语法来访问数组和向量的元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![0, 1, 2];
assert_eq!(v[0], 0);
<span class="boring">}</span></code></pre></pre>
<p>我们怎样才能为 <code>TicketStore</code> 提供类似的访问体验呢？你猜对了：我们需要实现一个特质，那就是 <code>Index</code>！</p>
<h2 id="06_ticket_management-13_index-index-特质"><a class="header" href="#06_ticket_management-13_index-index-特质"><code>Index</code> 特质</a></h2>
<p><code>Index</code> 特质是在 Rust 的标准库中定义的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 略微简化的版本
pub trait Index&lt;Idx&gt; {
    type Output;

    // 必须实现的方法
    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>它包含：</p>
<ul>
<li>一个泛型参数 <code>Idx</code>，用于表示索引类型</li>
<li>一个关联类型 <code>Output</code>，表示通过索引获取的类型</li>
</ul>
<p>注意，<code>index</code> 方法并不返回一个 <code>Option</code>。其假设是如果你尝试访问不存在的元素，<code>index</code> 会像数组和向量索引那样 panic。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-14_index_mut"></div><h1 id="06_ticket_management-14_index_mut-可变索引"><a class="header" href="#06_ticket_management-14_index_mut-可变索引">可变索引</a></h1>
<p><code>Index</code> 只提供了只读访问权限，并不允许你修改获取的值。</p>
<h2 id="06_ticket_management-14_index_mut-indexmut"><a class="header" href="#06_ticket_management-14_index_mut-indexmut"><code>IndexMut</code></a></h2>
<p>如果你想允许可变性，就需要实现 <code>IndexMut</code> 特质。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 略微简化的版本
pub trait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; {
    // 必须实现的方法
    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>只有当类型已经实现了 <code>Index</code> 特质后，才能实现 <code>IndexMut</code>，因为它解锁了额外的修改能力。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-15_hashmap"></div><h1 id="06_ticket_management-15_hashmap-hashmap"><a class="header" href="#06_ticket_management-15_hashmap-hashmap"><code>HashMap</code></a></h1>
<p>我们对 <code>Index</code>/<code>IndexMut</code> 的实现并不理想：我们需要遍历整个 <code>Vec</code> 来通过 ID 获取工单；算法复杂度为 <code>O(n)</code>，其中 <code>n</code> 是存储中工单的数量。</p>
<p>我们可以通过使用不同的数据结构 <code>HashMap&lt;K, V&gt;</code> 来改善这一情况来存储工单。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// 类型推导允许我们省略显式的类型签名（在这个例子中将是 `HashMap&lt;String, String&gt;`）。
let mut book_reviews = HashMap::new();

book_reviews.insert(
    "哈克贝利·费恩历险记".to_string(),
    "我最喜欢的书.".to_string(),
);
<span class="boring">}</span></code></pre></pre>
<p><code>HashMap</code> 通过键值对工作。它对两者都具有泛型性：<code>K</code> 是键类型的泛型参数，而 <code>V</code> 是值类型的泛型参数。</p>
<p>插入、检索和移除的预期成本是<strong>恒定的</strong>，即 <code>O(1)</code>。这听起来非常适合我们的应用场景，不是吗？</p>
<h2 id="06_ticket_management-15_hashmap-键的要求"><a class="header" href="#06_ticket_management-15_hashmap-键的要求">键的要求</a></h2>
<p>虽然 <code>HashMap</code> 的结构定义上没有特征界限，但你可以在其方法上找到一些。以 <code>insert</code> 为例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 略微简化
impl&lt;K, V&gt; HashMap&lt;K, V&gt;
where
    K: Eq + Hash,
{
    pub fn insert(&amp;mut self, k: K, v: V) -&gt; Option&lt;V&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p>键的类型必须实现 <code>Eq</code> 和 <code>Hash</code> 特征。</p>
<h2 id="06_ticket_management-15_hashmap-hash"><a class="header" href="#06_ticket_management-15_hashmap-hash"><code>Hash</code></a></h2>
<p>哈希函数（或散列器）将一个潜在无限的值集合（例如，所有可能的字符串）映射到一个有限范围内（例如，一个 <code>u64</code> 值）。有许多不同的哈希函数，各有不同的属性（速度、碰撞风险、可逆性等）。</p>
<p>顾名思义，<code>HashMap</code> 在幕后使用哈希函数。它对你的键进行哈希运算，然后使用该哈希值来存储/检索相关的值。这种策略要求键类型必须是可哈希的，因此在 <code>K</code> 上有 <code>Hash</code> 特征界限。</p>
<p>你可以在 <code>std::hash</code> 模块中找到 <code>Hash</code> 特征：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Hash {
    // 必须实现的方法
    fn hash&lt;H&gt;(&amp;self, state: &amp;mut H)
       where H: Hasher;
}
<span class="boring">}</span></code></pre></pre>
<p>你很少会手动实现 <code>Hash</code>，大多数时候你会通过派生来实现它：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-15_hashmap-eq"><a class="header" href="#06_ticket_management-15_hashmap-eq"><code>Eq</code></a></h2>
<p><code>HashMap</code> 必须能够比较键的相等性。在处理哈希碰撞时这一点尤为重要——即两个不同的键哈希到相同的值。</p>
<p>你可能疑惑：这不是 <code>PartialEq</code> 特征的作用吗？几乎！但 <code>PartialEq</code> 对于 <code>HashMap</code> 来说不够，因为它不保证自反性，即 <code>a == a</code> 总是 <code>true</code>。例如，浮点数 (<code>f32</code> 和 <code>f64</code>) 实现了 <code>PartialEq</code>，但它们不满足自反性：<code>f32::NAN == f32::NAN</code> 是 <code>false</code>。自反性对于 <code>HashMap</code> 正确工作至关重要：没有它，你将无法使用插入时的相同键从映射中检索值。</p>
<p><code>Eq</code> 特征扩展了 <code>PartialEq</code> 并包含了自反性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Eq: PartialEq {
    // 无新增方法
}
<span class="boring">}</span></code></pre></pre>
<p>它是一个标记特征：它不添加任何新方法，只是你向编译器表明在 <code>PartialEq</code> 中实现的等价逻辑是自反性的一种方式。</p>
<p>当你派生 <code>PartialEq</code> 时，也可以自动派生 <code>Eq</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq)]
struct Person {
    id: u32,
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="06_ticket_management-15_hashmap-eq-和-hash-的联系"><a class="header" href="#06_ticket_management-15_hashmap-eq-和-hash-的联系"><code>Eq</code> 和 <code>Hash</code> 的联系</a></h2>
<p><code>Eq</code> 和 <code>Hash</code> 之间存在着隐含的约定：如果两个键相等，它们的哈希值也必须相等。这对于 <code>HashMap</code> 正确工作至关重要。如果你破坏了这个约定，使用 <code>HashMap</code> 时将会得到不合逻辑的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="06_ticket_management-16_btreemap"></div><h1 id="06_ticket_management-16_btreemap-排序"><a class="header" href="#06_ticket_management-16_btreemap-排序">排序</a></h1>
<p>通过从 <code>Vec</code> 转换到 <code>HashMap</code>，我们提升了工单管理系统的性能，并在此过程中简化了代码。然而，并非一切都完美无瑕。当遍历基于 <code>Vec</code> 的存储时，我们可以确保工单按照添加的顺序返回。而对于 <code>HashMap</code> 来说则并非如此：你能够遍历工单，但是顺序是随机的。</p>
<p>我们可以通过将 <code>HashMap</code> 替换为 <code>BTreeMap</code> 来恢复一致的排序。</p>
<h2 id="06_ticket_management-16_btreemap-btreemap"><a class="header" href="#06_ticket_management-16_btreemap-btreemap"><code>BTreeMap</code></a></h2>
<p><code>BTreeMap</code> 保证了条目按其键的顺序排列。当你需要按照特定顺序遍历条目，或者需要执行范围查询（例如，“给我所有ID在10到20之间的工单”）时，这一点非常有用。</p>
<p>和 <code>HashMap</code> 一样，在 <code>BTreeMap</code> 的定义上你找不到特征界限，但是在其方法上可以找到。我们来看一看 <code>insert</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `K` 和 `V` 分别代表键和值的类型，和在 `HashMap` 中一样。
impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    pub fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt;
    where
        K: Ord,
    {
        // 实现细节
    }
}
<span class="boring">}</span></code></pre></pre>
<p>不再需要 <code>Hash</code>，取而代之的是键的类型必须实现 <code>Ord</code> 特征。</p>
<h2 id="06_ticket_management-16_btreemap-ord"><a class="header" href="#06_ticket_management-16_btreemap-ord"><code>Ord</code></a></h2>
<p><code>Ord</code> 特征用于比较值。当 <code>PartialEq</code> 用于判断相等时，<code>Ord</code> 则用于比较大小顺序。</p>
<p>它定义在 <code>std::cmp</code> 中：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ord: Eq + PartialOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p><code>cmp</code> 方法返回一个 <code>Ordering</code> 枚举，可以是 <code>Less</code>、<code>Equal</code> 或 <code>Greater</code> 中的一个。<code>Ord</code> 还要求实现另外两个特征：<code>Eq</code> 和 <code>PartialOrd</code>。</p>
<h2 id="06_ticket_management-16_btreemap-partialord"><a class="header" href="#06_ticket_management-16_btreemap-partialord"><code>PartialOrd</code></a></h2>
<p><code>PartialOrd</code> 是 <code>Ord</code> 的弱化版本，就像 <code>PartialEq</code> 是 <code>Eq</code> 的弱化版本一样。通过查看其定义可以理解这一点：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialOrd: PartialEq {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>PartialOrd::partial_cmp</code> 返回一个 <code>Option</code> —— 并不保证两个值可以被比较。例如，<code>f32</code> 不实现 <code>Ord</code> 因为 <code>NaN</code> 值不可比较，这也是 <code>f32</code> 不实现 <code>Eq</code> 的原因。</p>
<h2 id="06_ticket_management-16_btreemap-实现-ord-和-partialord"><a class="header" href="#06_ticket_management-16_btreemap-实现-ord-和-partialord">实现 <code>Ord</code> 和 <code>PartialOrd</code></a></h2>
<p><code>Ord</code> 和 <code>PartialOrd</code> 都可以为你的类型自动生成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 需要同时添加 `Eq` 和 `PartialEq`，因为 `Ord` 要求它们。
#[derive(Eq, PartialEq, Ord, PartialOrd)]
struct TicketId(u64);
<span class="boring">}</span></code></pre></pre>
<p>如果你选择（或需要）手动实现它们，请务必小心：</p>
<ul>
<li><code>Ord</code> 和 <code>PartialOrd</code> 必须与 <code>Eq</code> 和 <code>PartialEq</code> 保持一致。</li>
<li><code>Ord</code> 和 <code>PartialOrd</code> 必须彼此一致。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-00_intro"></div><h1 id="07_threads-00_intro-引言"><a class="header" href="#07_threads-00_intro-引言">引言</a></h1>
<p>Rust 的一大承诺是<em>无畏的并发</em>：让编写安全、并发的程序变得更加容易。到目前为止，我们对此还没有太多了解。迄今为止所做的所有工作都是单线程的。现在是时候做出改变了！</p>
<p>在本章中，我们将使我们的票务系统支持多线程。我们将有机会接触到 Rust 核心并发特性中的大部分内容，包括：</p>
<ul>
<li>使用 <code>std::thread</code> 模块的线程</li>
<li>使用通道进行消息传递</li>
<li>使用 <code>Arc</code>、<code>Mutex</code> 和 <code>RwLock</code> 管理共享状态</li>
<li><code>Send</code> 和 <code>Sync</code> 特性，它们编码了 Rust 的并发保证</li>
</ul>
<p>我们还将讨论多线程系统的一些设计模式及其权衡。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-01_threads"></div><h1 id="07_threads-01_threads-线程"><a class="header" href="#07_threads-01_threads-线程">线程</a></h1>
<p>在开始编写多线程代码之前，让我们先退一步，谈谈线程是什么，以及为什么我们可能想要使用它们。</p>
<h2 id="07_threads-01_threads-什么是线程"><a class="header" href="#07_threads-01_threads-什么是线程">什么是线程？</a></h2>
<p><strong>线程</strong>是由操作系统管理的执行上下文。每个线程都有自己的栈、指令指针和程序计数器。</p>
<p>单个<strong>进程</strong>可以管理多个线程。这些线程共享相同的内存空间，这意味着它们可以访问相同的数据。</p>
<p>线程是一个<strong>逻辑</strong>构造。归根结底，你只能在一个CPU核心（<strong>物理</strong>执行单元）上一次运行一套指令。由于线程数量可能远远超过CPU核心的数量，操作系统的<strong>调度器</strong>负责决定在任何给定时间运行哪个线程，通过对它们分配CPU时间来最大化吞吐量和响应速度。</p>
<h2 id="07_threads-01_threads-main"><a class="header" href="#07_threads-01_threads-main"><code>main</code></a></h2>
<p>当Rust程序启动时，它在一个单一的线程上运行，即<strong>主线程</strong>。这个线程由操作系统创建，负责运行<code>main</code>函数。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("主线程问候！");
    }
}</code></pre></pre>
<h2 id="07_threads-01_threads-stdthread"><a class="header" href="#07_threads-01_threads-stdthread"><code>std::thread</code></a></h2>
<p>Rust的标准库提供了一个模块<code>std::thread</code>，允许你创建和管理线程。</p>
<h3 id="07_threads-01_threads-spawn"><a class="header" href="#07_threads-01_threads-spawn"><code>spawn</code></a></h3>
<p>你可以使用<code>std::thread::spawn</code>来创建新线程并在其上执行代码。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("来自线程的问候！");
        }
    });
    
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("主线程问候！");
    }
}</code></pre></pre>
<p>如果在<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afedf7062298ca8f5a248bc551062eaa">Rust Playground</a>上执行这个程序，你会发现主线程和生成的线程并发运行。每个线程独立地进行。</p>
<h3 id="07_threads-01_threads-进程终止"><a class="header" href="#07_threads-01_threads-进程终止">进程终止</a></h3>
<p>当主线程完成时，整个进程将退出。生成的线程将继续运行，直到它完成或主线程完成。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("来自线程的问候！");
        }
    });

    thread::sleep(Duration::from_secs(5));
}</code></pre></pre>
<p>在上面的例子中，你期望看到大约五次“来自线程的问候！”的消息打印出来。然后，当<code>sleep</code>调用返回时，主线程将结束，生成的线程也会因为整个进程退出而被终止。</p>
<h3 id="07_threads-01_threads-join"><a class="header" href="#07_threads-01_threads-join"><code>join</code></a></h3>
<p>你也可以通过调用<code>spawn</code>返回的<code>JoinHandle</code>上的<code>join</code>方法来等待生成的线程完成。</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        println!("来自线程的问候！");
    });

    handle.join().unwrap();
}</code></pre></pre>
<p>在这个例子中，主线程将在退出之前等待生成的线程完成。这引入了一种线程间的<strong>同步</strong>形式：你保证会在程序退出前看到“来自线程的问候！”的消息被打印，因为主线程不会退出，直到生成的线程完成。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-02_static"></div><h1 id="07_threads-02_static-static"><a class="header" href="#07_threads-02_static-static"><code>'static</code></a></h1>
<p>如果你尝试从前一个练习中的向量借用切片，你可能遇到了类似这样的编译器错误：</p>
<pre><code class="language-text">error[E0597]: `v` does not live long enough
   |
11 | pub fn sum(v: Vec&lt;i32&gt;) -&gt; i32 {
   |            - binding `v` declared here
...
15 |     let right = &amp;v[split_point..];
   |                  ^ borrowed value does not live long enough
16 |     let left_handle = thread::spawn(move || left.iter().sum::&lt;i32&gt;());
   |                        ------------------------------------------------ 
                          argument requires that `v` is borrowed for `'static`
19 | }
   |  - `v` dropped here while still borrowed
</code></pre>
<p>“参数要求<code>v</code>被借用为<code>'static</code>”，这是什么意思呢？</p>
<p><code>'static</code>生命周期在Rust中是一个特殊的存在。它意味着这个值在整个程序的运行期间都是有效的。</p>
<h2 id="07_threads-02_static-脱离的线程"><a class="header" href="#07_threads-02_static-脱离的线程">脱离的线程</a></h2>
<p>通过<code>thread::spawn</code>启动的线程可以<strong>比创建它的线程更持久</strong>。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

fn f() {
    thread::spawn(|| {
        thread::spawn(|| {
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
                println!("Hello from the detached thread!");
            }
        });
    });
}
<span class="boring">}</span></code></pre></pre>
<p>在这个示例中，第一个生成的线程会进一步生成一个子线程，每秒打印一条消息。然后，第一个线程会完成并退出。当这种情况发生时，其子线程会<strong>继续运行</strong>，只要整个程序还在运行。在Rust的术语中，我们说子线程已经<strong>超过了</strong>其父线程的生命周期。</p>
<h2 id="07_threads-02_static-static生命周期"><a class="header" href="#07_threads-02_static-static生命周期"><code>'static</code>生命周期</a></h2>
<p>既然一个生成的线程能够：</p>
<ul>
<li>比生成它的线程（父线程）存活更久</li>
<li>运行到程序结束</li>
</ul>
<p>那么它就不能借用任何可能在程序结束前被丢弃的值；违反这一约束可能会使我们面临使用已释放内存的问题。这就是<code>std::thread::spawn</code>的签名要求传递给它的闭包具有<code>'static</code>生命周期的原因：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T + Send + 'static,
    T: Send + 'static
{
    // [..]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="07_threads-02_static-static不仅仅关于引用"><a class="header" href="#07_threads-02_static-static不仅仅关于引用"><code>'static</code>不仅仅关于引用</a></h2>
<p>Rust中所有值都有生命周期，不仅仅是引用。</p>
<p>特别是，一个拥有自己数据的类型（如<code>Vec</code>或<code>String</code>）满足<code>'static</code>约束：如果你拥有它，即使最初创建它的函数已经返回，你也可以随意处理它，想处理多久就处理多久。</p>
<p>因此，你可以将<code>'static</code>理解为一种表达方式：</p>
<ul>
<li>给我一个拥有权值</li>
<li>给我一个在整个程序期间都有效的引用</li>
</ul>
<p>第一种方法就是你在前一个练习中解决问题的方法：通过分配新的向量来持有原始向量的左右部分，然后将它们移动到生成的线程中。</p>
<h2 id="07_threads-02_static-static引用"><a class="header" href="#07_threads-02_static-static引用"><code>'static</code>引用</a></h2>
<p>现在讨论第二种情况，即在整个程序期间都有效的引用。</p>
<h3 id="07_threads-02_static-静态数据"><a class="header" href="#07_threads-02_static-静态数据">静态数据</a></h3>
<p>最常见的案例是指向<strong>静态数据</strong>的引用，比如字符串字面量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "你好，世界！";
<span class="boring">}</span></code></pre></pre>
<p>由于字符串字面量在编译时已知，Rust会将它们存储在可执行文件的内部，一个称为<strong>只读数据段</strong>的区域。因此，指向该区域的所有引用都会在程序运行期间保持有效；它们满足<code>'static</code>要求。</p>
<h2 id="07_threads-02_static-进一步阅读"><a class="header" href="#07_threads-02_static-进一步阅读">进一步阅读</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_segment">数据段</a>（英文维基百科页面，解释了程序的静态数据存储区域）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-03_leak"></div><h1 id="07_threads-03_leak-数据泄露"><a class="header" href="#07_threads-03_leak-数据泄露">数据泄露</a></h1>
<p>围绕将引用传递给生成的线程的主要担忧是“使用后释放”错误：即使用指向已经被释放或取消分配的内存区域的指针来访问数据。
如果你正在使用堆上分配的数据，可以通过告诉Rust你将永远不会回收那部分内存来避免这个问题——你选择<strong>故意泄露内存</strong>。</p>
<p>这可以通过使用Rust标准库中的<code>Box::leak</code>方法来实现，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 通过包装在一个`Box`中，在堆上分配一个`u32`。
let x = Box::new(41u32);
// 告诉Rust你将永远不会释放那个堆分配，
// 使用`Box::leak`。这样你就可以得到一个`'static`引用。
let static_ref: &amp;'static mut u32 = Box::leak(x);
<span class="boring">}</span></code></pre></pre>
<h2 id="07_threads-03_leak-数据泄露的影响范围是进程级的"><a class="header" href="#07_threads-03_leak-数据泄露的影响范围是进程级的">数据泄露的影响范围是进程级的</a></h2>
<p>泄露数据是危险的：如果你持续泄露内存，最终会耗尽内存并因内存不足而崩溃。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果让这段代码运行一段时间，
// 它最终会消耗掉所有可用内存。
fn 导致内存溢出() {
    loop {
        let v: Vec&lt;usize&gt; = Vec::with_capacity(1024);
        Box::leak(v);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>同时，通过<code>Box::leak</code>泄露的内存并不是真正被遗忘的。操作系统可以将每个内存区域映射到负责它的进程。当进程退出时，操作系统会回收那些内存。</p>
<p>考虑到这一点，如果满足以下条件，泄露内存是可以接受的：</p>
<ul>
<li>你需要泄露的内存量不是无限的或预先已知的，或者</li>
<li>你的进程是短暂的，并且你确信在它退出之前不会耗尽所有可用内存</li>
</ul>
<p>如果应用场景允许，“让操作系统处理它”是一种完全合理的内存管理策略。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-04_scoped_threads"></div><h1 id="07_threads-04_scoped_threads-限制生存期的线程"><a class="header" href="#07_threads-04_scoped_threads-限制生存期的线程">限制生存期的线程</a></h1>
<p>到目前为止我们讨论的所有生命周期问题都有一个共同的根源：生成的线程可能比其父线程寿命更长。我们可以通过使用**限制生存期的线程（scoped threads）**来绕过这个问题。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

std::thread::scope(|scope| {
    scope.spawn(|| {
        let first = &amp;v[..midpoint];
        println!("Here's the first half of v: {first:?}");
    });
    scope.spawn(|| {
        let second = &amp;v[midpoint..];
        println!("Here's the second half of v: {second:?}");
    });
});

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<p>下面我们来详细解析这个过程。</p>
<h2 id="07_threads-04_scoped_threads-scope"><a class="header" href="#07_threads-04_scoped_threads-scope"><code>scope</code></a></h2>
<p><code>std::thread::scope</code>函数创建一个新的<strong>作用域</strong>。它接收一个闭包作为输入，该闭包有一个参数：一个<code>Scope</code>实例。</p>
<h2 id="07_threads-04_scoped_threads-限制生存期的生成"><a class="header" href="#07_threads-04_scoped_threads-限制生存期的生成">限制生存期的生成</a></h2>
<p><code>Scope</code>提供了一个<code>spawn</code>方法。与<code>std::thread::spawn</code>不同，使用<code>Scope</code>生成的所有线程会在作用域结束时<strong>自动加入</strong>（即等待线程完成）。</p>
<p>如果我们把前面的例子用<code>std::thread::spawn</code>重写，看起来会是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let midpoint = v.len() / 2;

let handle1 = std::thread::spawn(|| {
    let first = &amp;v[..midpoint];
    println!("Here's the first half of v: {first:?}");
});
let handle2 = std::thread::spawn(|| {
    let second = &amp;v[midpoint..];
    println!("Here's the second half of v: {second:?}");
});

handle1.join().unwrap();
handle2.join().unwrap();

println!("Here's v: {v:?}");
<span class="boring">}</span></code></pre></pre>
<h2 id="07_threads-04_scoped_threads-从环境借用"><a class="header" href="#07_threads-04_scoped_threads-从环境借用">从环境借用</a></h2>
<p>然而，这个转换后的例子无法编译：编译器会抱怨说，由于<code>&amp;v</code>的生命周期不是<code>'static</code>，所以不能在生成的线程中使用它。</p>
<p>但这在使用<code>std::thread::scope</code>时不是问题——你可以<strong>安全地从环境借用</strong>。</p>
<p>在我们的例子中，<code>v</code>在生成线程之前创建。它只会在<code>scope</code>返回后被丢弃。同时，所有在<code>scope</code>内部生成的线程都保证了在<code>v</code>被丢弃前完成，因此不存在悬空引用的风险。</p>
<p>编译器不会报错！</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-05_channels"></div><h1 id="07_threads-05_channels-通道channel"><a class="header" href="#07_threads-05_channels-通道channel">通道（Channel）</a></h1>
<p>迄今为止，我们创建的所有线程都是短生命周期的。它们获取输入、执行计算、返回结果并关闭。但对于我们的票务管理系统，我们想要采取不同的方式：一种客户端-服务器架构。</p>
<p>我们将拥有<strong>一个长时间运行的服务器线程</strong>，负责管理我们的状态，即存储的票务信息。随后，我们将拥有<strong>多个客户端线程</strong>。每个客户端都能向这个有状态的线程发送<strong>命令</strong>和<strong>查询</strong>，以便改变其状态（例如，添加新票据）或检索信息（例如，获取票据的状态）。客户端线程将以并发的方式运行。</p>
<h2 id="07_threads-05_channels-通信"><a class="header" href="#07_threads-05_channels-通信">通信</a></h2>
<p>到目前为止，我们所进行的父子线程间通信还相当有限：</p>
<ul>
<li>生成的线程从父级上下文中借用或消耗数据，</li>
<li>当线程连接时，生成的线程向父级返回数据。</li>
</ul>
<p>这对于客户端-服务器设计来说是不够的。客户端需要能够在服务器线程启动后，能够与其发送和接收数据。我们可以通过使用**通道（Channels）**来解决这个问题。</p>
<h2 id="07_threads-05_channels-通道"><a class="header" href="#07_threads-05_channels-通道">通道</a></h2>
<p>Rust的标准库在其<code>std::sync::mpsc</code>模块中提供了**多生产者单消费者（Multi-Producer, Single-Consumer, 简称mpsc）**通道。通道有两种类型：有界和无界。目前我们先关注无界版本，但稍后会讨论它们各自的优缺点。</p>
<p>创建通道的代码如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::channel;

let (sender, receiver) = channel();
<span class="boring">}</span></code></pre></pre>
<p>这样你就得到了一个发送器（sender）和一个接收器（receiver）。你可以在发送器上调用<code>send</code>方法将数据推入通道，在接收器上调用<code>recv</code>方法从通道中拉取数据。</p>
<h3 id="07_threads-05_channels-多个发送者"><a class="header" href="#07_threads-05_channels-多个发送者">多个发送者</a></h3>
<p><code>Sender</code>是可以克隆的：我们可以创建多个发送器（比如，为每个客户端线程一个），它们都将数据推送到同一个通道中。</p>
<p>相反，<code>Receiver</code>是不可克隆的：对于给定的通道，只能存在一个接收器。</p>
<p>这就是<strong>mpsc</strong>（多生产者单消费者）的含义！</p>
<h3 id="07_threads-05_channels-消息类型"><a class="header" href="#07_threads-05_channels-消息类型">消息类型</a></h3>
<p><code>Sender</code>和<code>Receiver</code>都对一个类型参数<code>T</code>进行了泛型。这是可以在通道上传输的<strong>消息</strong>的类型。</p>
<p>它可以是一个<code>u64</code>、结构体、枚举等。</p>
<h3 id="07_threads-05_channels-错误处理"><a class="header" href="#07_threads-05_channels-错误处理">错误处理</a></h3>
<p><code>send</code>和<code>recv</code>都可能失败。如果接收器已经被丢弃，则<code>send</code>会返回错误；如果所有发送器都被丢弃且通道为空，则<code>recv</code>会返回错误。</p>
<p>换句话说，当通道实际上已经关闭时，<code>send</code>和<code>recv</code>就会发生错误。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-06_interior_mutability"></div><h1 id="07_threads-06_interior_mutability-内部可变性interior-mutability"><a class="header" href="#07_threads-06_interior_mutability-内部可变性interior-mutability">内部可变性（Interior Mutability）</a></h1>
<p>让我们花点时间分析一下<code>Sender</code>的<code>send</code>方法的签名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {
        // [...]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>send</code>接受<code>&amp;self</code>作为其参数。但它显然造成了状态的变更：它向通道中添加了一条新的消息。更有趣的是，<code>Sender</code>是可以克隆的：我们可以有多份<code>Sender</code>实例试图<strong>同时</strong>从不同线程修改通道的状态。</p>
<p>这正是我们构建这种客户端-服务器架构所利用的关键特性。但为什么这能行得通呢？难道它不违反了Rust关于借用的规则吗？我们是如何通过一个<strong>不可变</strong>的引用来进行修改的呢？</p>
<h2 id="07_threads-06_interior_mutability-共享而非不可变的引用"><a class="header" href="#07_threads-06_interior_mutability-共享而非不可变的引用">共享而非不可变的引用</a></h2>
<p>当我们引入借用检查器时，我们提到了Rust中可以拥有的两种类型的引用：</p>
<ul>
<li>不可变引用（<code>&amp;T</code>）</li>
<li>可变引用（<code>&amp;mut T</code>）</li>
</ul>
<p>其实更准确的说法应该是：</p>
<ul>
<li>共享引用（<code>&amp;T</code>）</li>
<li>排他引用（<code>&amp;mut T</code>）</li>
</ul>
<p>不可变/可变是一种适用于绝大多数情况的心智模型，并且它是初学Rust时非常好的入门概念。但正如你刚刚看到的，这并不是全部：<code>&amp;T</code>实际上并不保证它指向的数据是不可变的。不过别担心，Rust仍然遵守着它的承诺。只是这些术语比最初看起来的要微妙一些。</p>
<h2 id="07_threads-06_interior_mutability-unsafecell"><a class="header" href="#07_threads-06_interior_mutability-unsafecell"><code>UnsafeCell</code></a></h2>
<p>每当一个类型允许你通过共享引用修改数据时，你就是在处理<strong>内部可变性</strong>。</p>
<p>默认情况下，Rust编译器假设共享引用是不可变的。它基于这一假设<strong>优化你的代码</strong>。编译器可以重新排序操作，缓存值，并做各种魔法来加速你的代码。</p>
<p>你可以通过将数据包裹在<code>UnsafeCell</code>中告诉编译器：“不，这个共享引用实际上是可变的”。每当你看到一个允许内部可变性的类型时，你可以肯定<code>UnsafeCell</code>直接或间接地参与其中。使用<code>UnsafeCell</code>、原始指针和<code>unsafe</code>代码，你可以通过共享引用来修改数据。</p>
<p>但要明确的是：<code>UnsafeCell</code>并不是一根可以让你无视借用检查器的魔法棒！<code>unsafe</code>代码仍然受到Rust关于借用和别名规则的约束。它是一个（高级）工具，你可以利用它来构建那些安全性不能直接用Rust类型系统表达的<strong>安全抽象</strong>。每当你使用<code>unsafe</code>关键字时，你都在告诉编译器：“我知道我在做什么，我不会违反你的不变量，请相信我。”</p>
<p>每次你调用一个<code>unsafe</code>函数时，都会有关于其<strong>安全先决条件</strong>的文档说明：在什么情况下执行其<code>unsafe</code>块是安全的。你可以在<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">Rust标准库的文档</a>中找到关于<code>UnsafeCell</code>的。</p>
<p>在这个课程中，我们不会直接使用<code>UnsafeCell</code>，也不会编写<code>unsafe</code>代码。但了解它的存在、它为何存在以及它与你在Rust中每天使用的类型之间的关系是很重要的。</p>
<h2 id="07_threads-06_interior_mutability-关键示例"><a class="header" href="#07_threads-06_interior_mutability-关键示例">关键示例</a></h2>
<p>让我们浏览几个利用内部可变性的标准库类型。这些是你在Rust代码中会经常遇到的类型，尤其是当你深入了解你所使用的某些库的内部机制时。</p>
<h3 id="07_threads-06_interior_mutability-引用计数"><a class="header" href="#07_threads-06_interior_mutability-引用计数">引用计数</a></h3>
<p><code>Rc</code>是一个引用计数指针。它包裹一个值并跟踪对该值存在的引用数量。当最后一个引用被丢弃时，该值会被释放。被<code>Rc</code>包裹的值是不可变的：你只能获得对其的共享引用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let a: Rc&lt;String&gt; = Rc::new("我的字符串".to_string());
// 对字符串数据只有一个引用。
assert_eq!(Rc::strong_count(&amp;a), 1);

// 当我们调用`clone`时，字符串数据并没有被复制！
// 相反，`Rc`的引用计数被递增。
let b = Rc::clone(&amp;a);
assert_eq!(Rc::strong_count(&amp;a), 2);
assert_eq!(Rc::strong_count(&amp;b), 2);
// ^ `a`和`b`都指向相同的字符串数据
//   并共享同一个引用计数器。
<span class="boring">}</span></code></pre></pre>
<p><code>Rc</code>内部使用<code>UnsafeCell</code>来允许共享引用增加和减少引用计数。</p>
<h3 id="07_threads-06_interior_mutability-refcell"><a class="header" href="#07_threads-06_interior_mutability-refcell"><code>RefCell</code></a></h3>
<p><code>RefCell</code>是Rust中内部可变性的最常见例子之一。
它允许你即使只有一个对<code>RefCell</code>本身的不可变引用，也能修改<code>RefCell</code>包裹的值。</p>
<p>这是通过<strong>运行时借用检查</strong>实现的。<code>RefCell</code>在运行时跟踪它包含的值的引用数量（和类型）。如果你尝试在已有不可变借用的情况下可变地借用值，程序将panic，确保Rust的借用规则始终得到执行。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // 不可变借用
let z = x.borrow_mut(); // 引发恐慌！存在活跃的不可变借用。
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-07_ack"></div><h1 id="07_threads-07_ack-双向通信"><a class="header" href="#07_threads-07_ack-双向通信">双向通信</a></h1>
<p>在当前的客户端-服务器实现中，通信是单向的：从客户端到服务器。客户端无法得知服务器是否接收到消息、成功执行还是执行失败。这并不理想。</p>
<p>为了解决这个问题，我们可以引入一个双向通信系统。</p>
<h2 id="07_threads-07_ack-响应通道"><a class="header" href="#07_threads-07_ack-响应通道">响应通道</a></h2>
<p>我们需要一种方式让服务器能将响应发送回客户端。实现这一目标有多种方法，但最简单的方式是在客户端发送给服务器的消息中包含一个<code>Sender</code>通道。服务器处理完消息后，可以使用这个通道将响应发送回客户端。</p>
<p>这是构建在消息传递原语之上的Rust应用程序中相当常见的模式。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-08_client"></div><h1 id="07_threads-08_client-一个专门的-client-类型"><a class="header" href="#07_threads-08_client-一个专门的-client-类型">一个专门的 <code>Client</code> 类型</a></h1>
<p>迄今为止，客户端的所有交互都非常底层：你必须手动创建响应通道，构建命令，将其发送到服务器，然后调用响应通道上的<code>recv</code>来获取响应。这些都是可以抽象掉的模板代码，而这正是我们在本练习中将要做的。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-09_bounded"></div><h1 id="07_threads-09_bounded-有界与无界通道"><a class="header" href="#07_threads-09_bounded-有界与无界通道">有界与无界通道</a></h1>
<p>至今为止，我们一直在使用无界通道。你可以发送任意数量的消息，通道会根据需要扩容以容纳它们。但在多生产者单消费者场景下，这可能带来问题：如果生产者入队消息的速度超过消费者处理速度，通道将会不断增长，有可能消耗掉所有可用内存。</p>
<p>我们的建议是<strong>绝不在生产系统中</strong>使用无界通道。你应该总是通过<strong>有界通道</strong>对可入队消息的数量设置一个上限。</p>
<h2 id="07_threads-09_bounded-有界通道"><a class="header" href="#07_threads-09_bounded-有界通道">有界通道</a></h2>
<p>有界通道具有固定的容量。你可以通过调用<code>sync_channel</code>并传入大于零的容量来创建一个有界通道：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);
<span class="boring">}</span></code></pre></pre>
<p><code>receiver</code>的类型与之前相同，为<code>Receiver&lt;T&gt;</code>。而<code>sender</code>则是一个<code>SyncSender&lt;T&gt;</code>的实例。</p>
<h3 id="07_threads-09_bounded-发送消息"><a class="header" href="#07_threads-09_bounded-发送消息">发送消息</a></h3>
<p>通过<code>SyncSender</code>发送消息有两种不同的方法：</p>
<ul>
<li><code>send</code>：如果通道中有空间，它会将消息入队并返回<code>Ok(())</code>。如果通道已满，它会阻塞等待直到有空间可用。</li>
<li><code>try_send</code>：如果通道中有空间，它会将消息入队并返回<code>Ok(())</code>。如果通道已满，它会返回<code>Err(TrySendError::Full(value))</code>，其中<code>value</code>是未能发送的消息。</li>
</ul>
<p>根据你的应用场景，你可能选择使用其中之一。</p>
<h3 id="07_threads-09_bounded-反压"><a class="header" href="#07_threads-09_bounded-反压">反压</a></h3>
<p>使用有界通道的主要优势在于它们提供了一种<strong>反压</strong>机制。它们迫使生产者在消费者无法跟上时减速。这种反压可以进一步传播至整个系统，可能影响整体架构并防止终端用户以过多请求压垮系统。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-10_patch"></div><h1 id="07_threads-10_patch-更新操作"><a class="header" href="#07_threads-10_patch-更新操作">更新操作</a></h1>
<p>到目前为止，我们仅实现了插入和检索操作。接下来，让我们看看如何扩展系统以提供更新操作功能。</p>
<h2 id="07_threads-10_patch-旧版更新"><a class="header" href="#07_threads-10_patch-旧版更新">旧版更新</a></h2>
<p>在非线程化的系统版本中，更新操作相对直接：<code>TicketStore</code>暴露了一个<code>get_mut</code>方法，允许调用者获得对票据的可变引用，然后对其进行修改。</p>
<h2 id="07_threads-10_patch-多线程更新"><a class="header" href="#07_threads-10_patch-多线程更新">多线程更新</a></h2>
<p>在当前的多线程版本中，相同的策略将不再适用，因为可变引用需要通过通道发送。借用检查器会阻止我们这样做，因为<code>&amp;mut Ticket</code>不符合<code>SyncSender::send</code>所需的<code>'static</code>生命周期要求。</p>
<p>有几种方法可以绕过这个限制。我们将在接下来的练习中探讨其中的一些方法。</p>
<h3 id="07_threads-10_patch-打补丁"><a class="header" href="#07_threads-10_patch-打补丁">打补丁</a></h3>
<p>我们无法通过通道发送<code>&amp;mut Ticket</code>，因此无法在客户端进行修改。那我们能在服务器端进行修改吗？</p>
<p>如果告诉服务器需要更改的内容，就可以。换句话说，如果向服务器发送一个<strong>补丁</strong>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TicketPatch {
    id: TicketId,
    title: Option&lt;TicketTitle&gt;,
    description: Option&lt;TicketDescription&gt;,
    status: Option&lt;TicketStatus&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>id</code>字段是必需的，因为它用于标识需要更新的票据。所有其他字段都是可选的：</p>
<ul>
<li>如果一个字段是<code>None</code>，表示该字段不应被更改。</li>
<li>如果一个字段是<code>Some(value)</code>，表示该字段应更改为<code>value</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-11_locks"></div><h1 id="07_threads-11_locks-锁send与arc"><a class="header" href="#07_threads-11_locks-锁send与arc">锁、<code>Send</code>与<code>Arc</code></a></h1>
<p>你刚实现的打补丁策略有一个重大缺陷：它存在竞争条件。如果两个客户端几乎同时为同一张票证发送补丁，服务器将以任意顺序应用这些补丁。无论谁最后排队等候其补丁，都会覆盖另一个客户端所做的更改。</p>
<h2 id="07_threads-11_locks-版本号"><a class="header" href="#07_threads-11_locks-版本号">版本号</a></h2>
<p>我们可以通过使用<strong>版本号</strong>来尝试解决这个问题。每张票证创建时都会分配一个版本号，初始值设为<code>0</code>。每当客户端发送补丁时，他们必须包含票证的当前版本号以及期望的更改。只有当版本号与服务器存储的一致时，服务器才会应用该补丁。</p>
<p>在上述场景中，服务器会拒绝第二个补丁，因为版本号会被第一个补丁增量，从而与第二个客户端发送的不匹配。这种方法在分布式系统中相当常见（例如，当客户端和服务器不共享内存时），并被称为<strong>乐观并发控制</strong>。其思想是大多数时候冲突不会发生，因此我们可以针对常见情况进行优化。如果你愿意，你现在对Rust的了解足以让你作为额外练习自行实现这一策略。</p>
<h2 id="07_threads-11_locks-加锁"><a class="header" href="#07_threads-11_locks-加锁">加锁</a></h2>
<p>我们也可以通过引入<strong>锁</strong>来修复竞态条件。每当客户端想要更新票证时，他们必须首先获取对该票证的锁。在锁激活期间，其他客户端不能修改票证。</p>
<p>Rust标准库提供了两种不同的锁原语：<code>Mutex&lt;T&gt;</code>和<code>RwLock&lt;T&gt;</code>。我们先从<code>Mutex&lt;T&gt;</code>开始。它代表“互斥”，是最简单的锁类型：无论读取还是写入，都只允许一个线程访问数据。</p>
<p><code>Mutex&lt;T&gt;</code>包裹了它所保护的数据，并且是泛型于数据类型。你不能直接访问数据：类型系统强制你先使用<code>Mutex::lock</code>或<code>Mutex::try_lock</code>获取锁。前者直到获取锁为止会阻塞，后者如果无法获取锁则会立即返回错误。两种方法都会返回一个守卫对象，该对象解引用后可访问数据，允许你修改它。当守卫被释放时，锁也会被释放。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

// 由互斥锁保护的整数
let lock = Mutex::new(0);

// 获取互斥锁
let mut guard = lock.lock().unwrap();

// 通过守卫间接修改数据，
// 利用其`Deref`实现
*guard += 1;

// 当`guard`超出作用域时释放锁
// 可以通过显式丢弃守卫来完成
// 或者守卫自然离开作用域时隐式发生
drop(guard);
<span class="boring">}</span></code></pre></pre>
<h2 id="07_threads-11_locks-锁的粒度"><a class="header" href="#07_threads-11_locks-锁的粒度">锁的粒度</a></h2>
<p>我们的<code>Mutex</code>应该包装什么？最简单的选择是将整个<code>TicketStore</code>用单个<code>Mutex</code>包裹。这虽然可行，但会严重限制系统的性能：你无法并行读取票证，因为每次读取都必须等待锁释放。这被称为<strong>粗粒度锁定</strong>。</p>
<p>更好的做法是使用<strong>细粒度锁定</strong>，即每张票证都有自己的锁。这样，只要客户端不尝试访问同一张票证，它们就可以继续并行处理票证。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 新结构，每张票证都有自己的锁
struct TicketStore {
    tickets: BTreeMap&lt;TicketId, Mutex&lt;Ticket&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这种方法效率更高，但也有缺点：<code>TicketStore</code>必须开始<strong>意识到</strong>系统的多线程性质；到目前为止，<code>TicketStore</code>一直忽略了线程的存在。尽管如此，我们还是采用这种方法。</p>
<h2 id="07_threads-11_locks-谁持有锁"><a class="header" href="#07_threads-11_locks-谁持有锁">谁持有锁？</a></h2>
<p>为了使整个方案工作，锁必须传递给想要修改票证的客户端。客户端随后可以直接修改票证（就像他们拥有<code>&amp;mut Ticket</code>一样），并在完成后释放锁。</p>
<p>这有点棘手。我们不能通过通道发送<code>Mutex&lt;Ticket&gt;</code>，因为<code>Mutex</code>不可克隆，而且我们不能将其移出<code>TicketStore</code>。那我们能发送<code>MutexGuard</code>吗？</p>
<p>让我们用一个小例子测试这个想法：</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;
use std::sync::Mutex;
use std::sync::mpsc::sync_channel;

fn main() {
    let lock = Mutex::new(0);
    let (sender, receiver) = sync_channel(1);
    let guard = lock.lock().unwrap();

    spawn(move || {
        receiver.recv().unwrap();
    });

    // 尝试通过通道发送守卫到另一个线程
    sender.send(guard);
}</code></pre></pre>
<p>编译器对此代码不满意：</p>
<pre><code class="language-text">错误[E0277]: `MutexGuard&lt;'_, i32&gt;`不能安全地在线程间发送
   --&gt; src/main.rs:10:7
    |
10  |   spawn(move || {
    |  _-----_^
    | | |
    | | 需要此边界的调用
11  | |     receiver.recv().unwrap();;
12  | | });
    | |_^ `MutexGuard&lt;'_, i32&gt;`不能安全地在线程间发送
    |
    = 帮助: 类型`MutexGuard&lt;'_, i32&gt;`没有实现`Send`特质，这是`{closure@src/main.rs:10:7: 10:14}: Send`所需要的
    = 注意: 这是因为`std::sync::mpsc::Receiver&lt;MutexGuard&lt;'_, i32&gt;&gt;`需要实现`Send`
注意: 因为它在这个闭包内被使用
</code></pre>
<p><code>MutexGuard&lt;'_, i32&gt;</code>不是<code>Send</code>：这意味着什么？</p>
<h2 id="07_threads-11_locks-send"><a class="header" href="#07_threads-11_locks-send"><code>Send</code></a></h2>
<p><code>Send</code>是一个标记特质，表明一种类型可以安全地从一个线程转移到另一个线程。<code>Send</code>也是一个自动特质，就像<code>Sized</code>一样；编译器会根据类型的定义自动实现（或不实现）它。你也可以手动为你的类型实现<code>Send</code>，但这需要<code>unsafe</code>，因为你必须保证类型确实可以在线程间安全发送，而这是编译器无法自动验证的原因。</p>
<h3 id="07_threads-11_locks-通道需求"><a class="header" href="#07_threads-11_locks-通道需求">通道需求</a></h3>
<p><code>Sender&lt;T&gt;</code>、<code>SyncSender&lt;T&gt;</code>和<code>Receiver&lt;T&gt;</code>只有当<code>T</code>是<code>Send</code>时才是<code>Send</code>。这是因为它们用于在线程间发送值，如果值本身不是<code>Send</code>，那么在线程间发送它是不安全的。</p>
<h3 id="07_threads-11_locks-mutexguard"><a class="header" href="#07_threads-11_locks-mutexguard"><code>MutexGuard</code></a></h3>
<p><code>MutexGuard</code>不是<code>Send</code>，因为在某些平台上，<code>Mutex</code>用来实现锁的底层操作系统原语要求必须由获取它的同一线程释放锁。如果我们把<code>MutexGuard</code>发送到另一个线程，锁就会被不同的线程释放，导致未定义行为。</p>
<h2 id="07_threads-11_locks-我们的挑战"><a class="header" href="#07_threads-11_locks-我们的挑战">我们的挑战</a></h2>
<p>总结一下：</p>
<ul>
<li>我们不能通过通道发送<code>MutexGuard</code>。所以我们不能在服务器端加锁然后在客户端修改票证。</li>
<li>我们可以发送<code>Mutex</code>通过通道，只要它保护的数据是<code>Send</code>，对于<code>Ticket</code>来说就是这种情况。
同时，我们不能将<code>Mutex</code>移出<code>TicketStore</code>，也不能克隆它。</li>
</ul>
<p>我们如何解决这个难题？我们需要从不同的角度审视问题。
锁定<code>Mutex</code>时，我们不需要拥有值。共享引用就足够了，因为<code>Mutex</code>使用内部可变性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Mutex&lt;T&gt; {
    // `&amp;self`，而不是`self`！
    pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; {
        // 实现细节
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，发送给客户端一个共享引用就足够了。然而，我们不能直接这么做，因为引用必须是<code>'static</code>，而实际情况并非如此。在某种程度上，我们需要一个“拥有式的共享引用”。事实证明，Rust有一个符合要求的类型：<code>Arc</code>。</p>
<h2 id="07_threads-11_locks-arc来救援"><a class="header" href="#07_threads-11_locks-arc来救援"><code>Arc</code>来救援</a></h2>
<p><code>Arc</code>代表<strong>原子引用计数</strong>。<code>Arc</code>包裹着一个值并跟踪对这个值存在的引用数量。当最后一个引用被释放时，值就被回收。被<code>Arc</code>包裹的值是不可变的：你只能获取到它的共享引用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

let data: Arc&lt;u32&gt; = Arc::new(0);
let data_clone = Arc::clone(&amp;data);

// `Arc&lt;T&gt;`实现了`Deref&lt;T&gt;`，所以可以将`&amp;Arc&lt;T&gt;`转换为`&amp;T`，使用解引用强制转换
let data_ref: &amp;u32 = &amp;data;
<span class="boring">}</span></code></pre></pre>
<p>如果你觉得似曾相识，你是对的：<code>Arc</code>听起来非常类似于我们在讨论内部可变性时介绍的<code>Rc</code>，引用计数指针。不同之处在于线程安全性：<code>Rc</code>不是<code>Send</code>，而<code>Arc</code>是。这归结于引用计数的实现方式：<code>Rc</code>使用一个“正常”的整数，而<code>Arc</code>使用一个<strong>原子</strong>整数，可以在线程间安全共享和修改。</p>
<h2 id="07_threads-11_locks-arcmutext"><a class="header" href="#07_threads-11_locks-arcmutext"><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></a></h2>
<p>如果我们将<code>Arc</code>与<code>Mutex</code>配对，最终得到一个类型，它可以：</p>
<ul>
<li>在线程间发送，因为：
<ul>
<li>如果<code>T</code>是<code>Send</code>，则<code>Arc</code>是<code>Send</code>；</li>
<li>如果<code>T</code>是<code>Send</code>，则<code>Mutex</code>也是<code>Send</code>。</li>
<li><code>T</code>是<code>Ticket</code>，它是<code>Send</code>。</li>
</ul>
</li>
<li>可以克隆，因为无论<code>T</code>是什么，<code>Arc</code>都是<code>Clone</code>。克隆<code>Arc</code>会增加引用计数，数据不会被复制。</li>
<li>可以用来修改它包装的数据，因为<code>Arc</code>让你可以获得<code>Mutex&lt;T&gt;</code>的共享引用，进而可以获取锁。</li>
</ul>
<p>我们现在有了实现票证存储锁定策略所需的所有部件。</p>
<h2 id="07_threads-11_locks-深入阅读"><a class="header" href="#07_threads-11_locks-深入阅读">深入阅读</a></h2>
<ul>
<li>在本课程中，我们不会深入讲解原子操作的细节，但你可以在<a href="https://doc.rust-lang.org/std/sync/atomic/index.html">Rust标准库文档</a>以及<a href="https://marabos.nl/atomics/">"Rust原子操作和锁"书籍</a>中找到更多信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-12_rw_lock"></div><h1 id="07_threads-12_rw_lock-reader-与-writer"><a class="header" href="#07_threads-12_rw_lock-reader-与-writer">Reader 与 Writer</a></h1>
<p>我们新设计的<code>TicketStore</code>能够运行，但其读取性能并不理想：同一时间只有一个客户端能读取特定的票证，因为<code>Mutex&lt;T&gt;</code>并未区分读者和写者。</p>
<p>我们可以通过使用另一种锁原语<code>RwLock&lt;T&gt;</code>来解决这个问题。<code>RwLock&lt;T&gt;</code>代表<strong>读写锁</strong>，它允许多个<strong>读者</strong>同时访问数据，但同一时间只允许一个写者进行操作。</p>
<p><code>RwLock&lt;T&gt;</code>提供了两种获取锁的方法：<code>read</code>和<code>write</code>。<code>read</code>返回一个允许你读取数据的守卫，而<code>write</code>则返回一个允许你修改数据的守卫。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::RwLock;

// 由读写锁保护的整数
let lock = RwLock::new(0);

// 获取读锁
let guard1 = lock.read().unwrap();

// 在第一个读锁仍激活的情况下
// 获取**第二个**读锁
let guard2 = lock.read().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="07_threads-12_rw_lock-权衡取舍"><a class="header" href="#07_threads-12_rw_lock-权衡取舍">权衡取舍</a></h2>
<p>表面上看，<code>RwLock&lt;T&gt;</code>似乎是不二之选：它提供了<code>Mutex&lt;T&gt;</code>功能的超集。如果可以使用<code>RwLock&lt;T&gt;</code>，为什么还要用<code>Mutex&lt;T&gt;</code>呢？</p>
<p>有两个关键原因：</p>
<ul>
<li>锁定<code>RwLock&lt;T&gt;</code>比锁定<code>Mutex&lt;T&gt;</code>成本更高。这是因为<code>RwLock&lt;T&gt;</code>需要追踪活跃读者和写者的数量，而<code>Mutex&lt;T&gt;</code>只需记录锁是否被持有。如果读取操作远多于写入操作，这种性能开销不是问题，但如果工作负载偏向写入，<code>Mutex&lt;T&gt;</code>可能是更好的选择。</li>
<li><code>RwLock&lt;T&gt;</code>可能导致<strong>写者饥饿</strong>。如果有持续的读者等待获取锁，写者可能永远没有机会执行。<code>RwLock&lt;T&gt;</code>不对读者和写者获得锁的顺序提供任何保证，这取决于底层操作系统的实现策略，对写者可能不公平。</li>
</ul>
<p>在我们的案例中，预期的工作负载偏向读取（因为大多数客户端将读取票证而非修改），因此<code>RwLock&lt;T&gt;</code>是一个合适的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-13_without_channels"></div><h1 id="07_threads-13_without_channels-设计回顾"><a class="header" href="#07_threads-13_without_channels-设计回顾">设计回顾</a></h1>
<p>让我们花点时间回顾一下走过的历程。</p>
<h2 id="07_threads-13_without_channels-无锁与通道序列化"><a class="header" href="#07_threads-13_without_channels-无锁与通道序列化">无锁与通道序列化</a></h2>
<p>我们对多线程票证存储的第一个实现采用了以下方式：</p>
<ul>
<li>单一线程（服务器），持有共享状态，</li>
<li>多个客户端通过他们自己的线程通过通道向其发送请求。</li>
</ul>
<p>无需对状态加锁，因为只有服务器在修改状态。这是因为“收件箱”通道自然地<strong>序列化</strong>了进来的请求：服务器会逐一处理它们。我们已经讨论过这种方法在打补丁行为上的局限性，但我们尚未讨论原始设计的性能影响：服务器一次只能处理一个请求，包括读取。</p>
<h2 id="07_threads-13_without_channels-细粒度加锁"><a class="header" href="#07_threads-13_without_channels-细粒度加锁">细粒度加锁</a></h2>
<p>随后，我们转向了一个更复杂的设计，其中每个票证都有自己的锁保护，客户端可以独立决定他们是想读取还是原子性地修改票证，获取适当的锁。</p>
<p>该设计允许更好的并行性（即，多个客户端可以同时读取票证），但本质上仍然是<strong>串行</strong>的：服务器逐一处理命令。特别是，它逐一给客户端分配锁。</p>
<p>我们能否完全移除通道，让客户端直接访问<code>TicketStore</code>，仅依靠锁来同步访问呢？</p>
<h2 id="07_threads-13_without_channels-移除通道"><a class="header" href="#07_threads-13_without_channels-移除通道">移除通道</a></h2>
<p>我们需要解决两个问题：</p>
<ul>
<li>在线程间共享<code>TicketStore</code></li>
<li>同步访问存储</li>
</ul>
<h3 id="07_threads-13_without_channels-在线程间共享ticketstore"><a class="header" href="#07_threads-13_without_channels-在线程间共享ticketstore">在线程间共享<code>TicketStore</code></a></h3>
<p>我们希望所有线程都指向同一个状态，否则实际上并没有形成多线程系统——我们只是并行运行多个单线程系统而已。我们已经在尝试跨线程共享锁时遇到过这个问题：我们可以使用<code>Arc</code>来解决。</p>
<h3 id="07_threads-13_without_channels-同步访问存储"><a class="header" href="#07_threads-13_without_channels-同步访问存储">同步访问存储</a></h3>
<p>由于通道提供的序列化，还有一种交互仍然是无锁的：向存储中插入（或移除）票证。
如果我们移除通道，就需要引入（另一个）锁来同步对<code>TicketStore</code>本身的访问。</p>
<p>如果使用<code>Mutex</code>，那么再为每张票证添加额外的<code>RwLock</code>就没有意义了：<code>Mutex</code>已经序列化了对整个存储的访问，所以我们无论如何也无法并行读取票证。相反，如果使用<code>RwLock</code>，我们就能并行读取票证。我们只需在插入或移除票证时暂停所有读取即可。</p>
<p>让我们沿着这条路径看看它会带我们走向何方。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="07_threads-14_sync"></div><h1 id="07_threads-14_sync-sync"><a class="header" href="#07_threads-14_sync-sync"><code>Sync</code></a></h1>
<p>在结束本章之前，让我们谈谈Rust标准库中的另一个关键特性：<code>Sync</code>。</p>
<p><code>Sync</code>是一个自动特质，就像<code>Send</code>一样。它被所有类型自动实现，这些类型能够在线程间<strong>安全地共享</strong>。</p>
<p>换句话说：<code>T: Sync</code>意味着<code>&amp;T</code>是<code>Send</code>。</p>
<h2 id="07_threads-14_sync-sync并不意味着send"><a class="header" href="#07_threads-14_sync-sync并不意味着send"><code>Sync</code>并不意味着<code>Send</code></a></h2>
<p>需要注意的是，<code>Sync</code>并不意味着<code>Send</code>。例如：<code>MutexGuard</code>不是<code>Send</code>，但是它是<code>Sync</code>。</p>
<p>它不是<code>Send</code>，因为锁必须在获取它的同一个线程上释放，因此我们不希望<code>MutexGuard</code>在不同的线程上被丢弃。但它又是<code>Sync</code>，因为将<code>&amp;MutexGuard</code>传递给另一个线程并不会影响锁在哪里释放。</p>
<h2 id="07_threads-14_sync-send并不意味着sync"><a class="header" href="#07_threads-14_sync-send并不意味着sync"><code>Send</code>并不意味着<code>Sync</code></a></h2>
<p>反之亦然：<code>Send</code>并不意味着<code>Sync</code>。例如：<code>RefCell&lt;T&gt;</code>是<code>Send</code>（如果<code>T</code>是<code>Send</code>的话），但它不是<code>Sync</code>。</p>
<p><code>RefCell&lt;T&gt;</code>执行运行时借用检查，但它使用的用于跟踪借用的计数器不是线程安全的。因此，多个线程持有<code>&amp;RefCell</code>会导致数据竞争，可能会有多个线程获得对同一数据的可变引用。因此<code>RefCell</code>不是<code>Sync</code>。而<code>Send</code>是可以的，因为我们向另一个线程发送<code>RefCell</code>时，并没有留下对其包含数据的任何引用，因此没有并发修改访问的风险。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-00_intro"></div><h1 id="08_futures-00_intro-异步-rust"><a class="header" href="#08_futures-00_intro-异步-rust">异步 Rust</a></h1>
<p>线程并不是Rust中编写并发程序的唯一方式。在本章中，我们将探索另一种方法：<strong>异步编程</strong>。</p>
<p>具体而言，你将获得以下内容的介绍：</p>
<ul>
<li><code>async</code>/<code>.await</code>关键字，轻松编写异步代码</li>
<li><code>Future</code>特质，表示可能尚未完成的计算</li>
<li><code>tokio</code>，运行异步代码最受欢迎的运行时</li>
<li>Rust异步模型的合作本质，以及这对你的代码有何影响</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-01_async_fn"></div><h1 id="08_futures-01_async_fn-异步函数"><a class="header" href="#08_futures-01_async_fn-异步函数">异步函数</a></h1>
<p>迄今为止，你编写的全部函数和方法都是即时执行的。除非你调用它们，否则什么都不会发生。但一旦调用了，它们就会运行至完成：它们会做<strong>所有</strong>的工作，然后返回输出结果。</p>
<p>有时这并非理想情况。例如，如果你正在编写一个HTTP服务器，可能会有很多<strong>等待</strong>的情况：等待请求体到达、等待数据库响应、等待下游服务回复等。</p>
<p>如果在等待时可以做些其他事情会怎样？如果你可以选择中途放弃计算会怎样？如果你可以选择优先处理另一个任务而非当前任务会怎样？</p>
<p>这就是<strong>异步函数</strong>发挥作用的地方。</p>
<h2 id="08_futures-01_async_fn-async-fn"><a class="header" href="#08_futures-01_async_fn-async-fn"><code>async fn</code></a></h2>
<p>你可以使用<code>async</code>关键字来定义一个异步函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

// 这个函数是异步的
async fn bind_random() -&gt; TcpListener {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<p>如果你像调用普通函数那样调用<code>bind_random</code>会发生什么？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run() {
    // 调用 `bind_random`
    let listener = bind_random();
    // 现在怎么办？
}
<span class="boring">}</span></code></pre></pre>
<p>什么也不会发生！当你调用<code>bind_random</code>时，Rust并不会开始执行它，甚至不会作为一个后台任务来启动（这可能基于你在其他语言中的经验）。Rust中的异步函数是<strong>惰性的</strong>：它们直到你明确要求它们执行才开始做任何工作。使用Rust的术语来说，我们说<code>bind_random</code>返回了一个<strong>未来</strong>，这是一种代表可能稍后完成的计算的类型。它们之所以称为“未来”，是因为它们实现了<code>Future</code>特质，我们将在本章后面详细探讨这个接口。</p>
<h2 id="08_futures-01_async_fn-await"><a class="header" href="#08_futures-01_async_fn-await"><code>.await</code></a></h2>
<p>让异步函数执行一些工作的最常见方法是使用<code>.await</code>关键字：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

async fn bind_random() -&gt; TcpListener {
    // [...]
}

async fn run() {
    // 调用 `bind_random` 并等待它完成
    let listener = bind_random().await;
    // 现在 `listener` 已经准备好了
}
<span class="boring">}</span></code></pre></pre>
<p><code>.await</code>直到异步函数运行完成——例如，上述示例中直到<code>TcpListener</code>被创建——才会将控制权交还给调用者。</p>
<h2 id="08_futures-01_async_fn-运行时"><a class="header" href="#08_futures-01_async_fn-运行时">运行时</a></h2>
<p>如果你感到困惑，这是很正常的！我们刚刚说过异步函数的优点之一是它们不会立即做<strong>所有</strong>工作。然后我们介绍了<code>.await</code>，它要等到异步函数完成才会返回。我们是不是又重新引入了我们试图解决的问题？意义何在？</p>
<p>不尽然！在你调用<code>.await</code>时，幕后发生了许多事情！你将控制权交给了一<strong>异步运行时</strong>，也称为<strong>异步执行器</strong>。执行器是魔法发生的地点：它们负责管理你所有的正在进行的<strong>任务</strong>。具体来说，它们平衡两个不同的目标：</p>
<ul>
<li><strong>进展</strong>：确保任务在可能时取得进展。</li>
<li><strong>效率</strong>：如果一个任务在等待某事，它们尽量确保另一个任务可以在此期间运行，充分利用可用资源。</li>
</ul>
<h3 id="08_futures-01_async_fn-无默认运行时"><a class="header" href="#08_futures-01_async_fn-无默认运行时">无默认运行时</a></h3>
<p>Rust在异步编程方面采取的方法相当独特：没有默认运行时。标准库不附带运行时。你需要自己引入！</p>
<p>在大多数情况下，你会从生态系统中选择一个可用的选项。有些运行时设计得广泛适用，对大多数应用程序都是坚实的选择。<code>tokio</code>和<code>async-std</code>属于这一类。其他运行时则针对特定用例进行了优化，例如，<code>embassy</code>针对嵌入式系统。</p>
<p>在整个课程中，我们将依赖于<code>tokio</code>，这是Rust中通用异步编程最受欢迎的运行时。</p>
<h3 id="08_futures-01_async_fn-tokiomain"><a class="header" href="#08_futures-01_async_fn-tokiomain"><code>#[tokio::main]</code></a></h3>
<p>你的可执行文件的入口点，<code>main</code>函数，必须是一个同步函数。你应该在这里设置并启动你选择的异步运行时。</p>
<p>大多数运行时都提供了一个宏来简化这个过程。对于<code>tokio</code>，它是<code>tokio::main</code>：</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    // 你的异步代码放这里
}</code></pre></pre>
<p>这展开为：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(
        // 你的异步函数放这里
        // [...]
    );
}</code></pre></pre>
<h3 id="08_futures-01_async_fn-tokiotest"><a class="header" href="#08_futures-01_async_fn-tokiotest"><code>#[tokio::test]</code></a></h3>
<p>测试也是如此：它们必须是同步函数。每个测试函数都在自己的线程中运行，如果你需要在测试中运行异步代码，你需要负责设置并启动异步运行时。<code>tokio</code>提供了一个<code>#[tokio::test]</code>宏来简化这一过程：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn my_test() {
    // 你的异步测试代码放这里
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-02_spawn"></div><h1 id="08_futures-02_spawn-创建任务"><a class="header" href="#08_futures-02_spawn-创建任务">创建任务</a></h1>
<p>对于上一个练习，你的解决方案应该看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        let (mut socket, _) = listener.accept().await?;
        let (mut reader, mut writer) = socket.split();
        tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这还不错！如果两次连接请求之间间隔时间很长，<code>echo</code>函数将会处于空闲状态（因为<code>TcpListener::accept</code>是一个异步函数），从而允许执行器在此期间运行其他任务。</p>
<p>但是，我们如何实际并行运行多个任务呢？如果我们总是运行异步函数直到完成（通过使用<code>.await</code>），那么任何时候都只会有一个任务在运行。</p>
<p>这就引出了<code>tokio::spawn</code>函数的作用。</p>
<h2 id="08_futures-02_spawn-tokiospawn"><a class="header" href="#08_futures-02_spawn-tokiospawn"><code>tokio::spawn</code></a></h2>
<p><code>tokio::spawn</code>允许你将任务交给执行器处理，<strong>无需等待它完成</strong>。每次调用<code>tokio::spawn</code>时，你实际上是告诉<code>tokio</code>继续在后台运行这个被派生的任务，<strong>与派生它的任务并发</strong>进行。</p>
<p>以下是使用它并发处理多个连接的方式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;

pub async fn echo(listener: TcpListener) -&gt; Result&lt;(), anyhow::Error&gt; {
    loop {
        let (mut socket, _) = listener.accept().await?;
        // 在后台启动一个任务以处理连接
        // 从而使主任务能够立即开始接受新连接
        tokio::spawn(async move {
            let (mut reader, mut writer) = socket.split();
            tokio::io::copy(&amp;mut reader, &amp;mut writer).await?;
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="08_futures-02_spawn-异步块"><a class="header" href="#08_futures-02_spawn-异步块">异步块</a></h3>
<p>在这个例子中，我们向<code>tokio::spawn</code>传递了一个<strong>异步块</strong>：<code>async move { /* */ }</code>
异步块是一种快速标记代码区域为异步的方式，而不需要定义单独的异步函数。</p>
<h3 id="08_futures-02_spawn-joinhandle"><a class="header" href="#08_futures-02_spawn-joinhandle"><code>JoinHandle</code></a></h3>
<p><code>tokio::spawn</code>返回一个<code>JoinHandle</code>。你可以使用<code>JoinHandle</code>来<code>.await</code>后台任务，就像我们对线程使用<code>join</code>一样。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn run() {
    // 在后台启动一个任务以向远程服务器发送遥测数据
    let handle = tokio::spawn(emit_telemetry());
    // 同时做一些其他有用的工作
    do_work().await;
    // 但在遥测数据成功发送之前不要返回给调用者
    handle.await;
}

pub async fn emit_telemetry() {
    // [...]
}

pub async fn do_work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="08_futures-02_spawn-惊群边界"><a class="header" href="#08_futures-02_spawn-惊群边界">惊群边界</a></h3>
<p>如果使用<code>tokio::spawn</code>启动的任务发生了恐慌（panic），恐慌会被执行器捕获。如果你不<code>.await</code>对应的<code>JoinHandle</code>，恐慌就不会传播给启动者。即使你确实<code>.await</code>了<code>JoinHandle</code>，恐慌也不会自动传播。等待<code>JoinHandle</code>会返回一个<code>Result</code>，错误类型为<a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinError.html"><code>JoinError</code></a>。然后你可以通过调用<code>JoinError::is_panic</code>来检查任务是否发生了恐慌，并选择如何处理这个恐慌——比如记录它、忽略它或传播它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task::JoinError;

pub async fn run() {
    let handle = tokio::spawn(work());
    if let Err(e) = handle.await {
        if let Ok(reason) = e.try_into_panic() {
            // 任务已发生恐慌
            // 我们恢复恐慌的展开，
            // 因此将其传播到当前线程
            panic::resume_unwind(reason);
        }
    }
}

pub async fn work() {
    // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="08_futures-02_spawn-stdthreadspawn与tokiospawn对比"><a class="header" href="#08_futures-02_spawn-stdthreadspawn与tokiospawn对比"><code>std::thread::spawn</code>与<code>tokio::spawn</code>对比</a></h3>
<p>你可以把<code>tokio::spawn</code>想象成<code>std::thread::spawn</code>的异步兄弟。</p>
<p>注意一个关键区别：使用<code>std::thread::spawn</code>时，你将控制权委托给了操作系统调度器。你无法控制线程是如何调度的。</p>
<p>而在使用<code>tokio::spawn</code>时，你将控制权委托给了完全在用户空间运行的异步执行器。底层的操作系统调度器并不参与决定下一个运行哪个任务。现在，通过我们选择使用的执行器，我们负责这个决策。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-03_runtime"></div><h1 id="08_futures-03_runtime-运行时"><a class="header" href="#08_futures-03_runtime-运行时">运行时</a></h1>
<p>到目前为止，我们一直在将异步运行时作为一个抽象概念进行讨论。让我们深入了解一下它们的实现方式——很快你就会发现，这对我们的代码有影响。</p>
<h2 id="08_futures-03_runtime-类型"><a class="header" href="#08_futures-03_runtime-类型">类型</a></h2>
<p><code>tokio</code>提供了两种不同类型的运行时<strong>风味</strong>（flavors）**。</p>
<p>你可以通过<code>tokio::runtime::Builder</code>配置你的运行时：</p>
<ul>
<li><code>Builder::new_multi_thread</code>为你提供了一个<strong>多线程的<code>tokio</code>运行时</strong></li>
<li>而<code>Builder::new_current_thread</code>则依赖于<strong>当前线程</strong>进行执行。</li>
</ul>
<p>默认情况下，<code>#[tokio::main]</code>返回一个多线程运行时，而<code>#[tokio::test]</code>则直接使用当前线程的运行时。</p>
<h3 id="08_futures-03_runtime-当前线程运行时"><a class="header" href="#08_futures-03_runtime-当前线程运行时">当前线程运行时</a></h3>
<p>顾名思义，当前线程运行时完全依赖于启动它的操作系统线程来调度和执行任务。使用当前线程运行时，你拥有<strong>并发性</strong>但没有<strong>并行性</strong>：异步任务会交错执行，但在任何给定的时间最多只有一个任务在运行。</p>
<h3 id="08_futures-03_runtime-多线程运行时"><a class="header" href="#08_futures-03_runtime-多线程运行时">多线程运行时</a></h3>
<p>而使用多线程运行时，可以在任意给定时间最多有<code>N</code>个任务<strong>并行</strong>运行，这里的<code>N</code>是运行时使用的线程数量。默认情况下，<code>N</code>等于可用CPU核心的数量。</p>
<p>不仅如此，<code>tokio</code>还执行<strong>工作窃取</strong>。如果一个线程空闲，它不会闲置：它会尝试找到一个新的、准备好执行的任务，这可以从全局队列中获取，或者从另一个线程的本地队列中窃取。工作窃取在性能上有显著的好处，特别是在尾部延迟上，尤其是当你的应用程序处理的工作负载在各线程间并非完美平衡时。</p>
<h2 id="08_futures-03_runtime-影响"><a class="header" href="#08_futures-03_runtime-影响">影响</a></h2>
<p><code>tokio::spawn</code>是不受运行时风味限制的：无论你是在多线程还是当前线程运行时上运行，它都能工作。缺点是它的签名假定了最坏的情况（即多线程）并据此进行了约束：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>我们暂时忽略<code>Future</code>特质，专注于其余部分。<code>spawn</code>要求所有输入都是<code>Send</code>且具有<code>'static</code>生命周期。</p>
<p><code>'static</code>约束遵循与<code>std::thread::spawn</code>上<code>'static</code>约束相同的理由：被派生的任务可能会超出它被派生的上下文的生命周期，因此它不应该依赖任何可能在其派生上下文被销毁后被析构的局部数据。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner() {
    let v = vec![1, 2, 3];
    // 这样不行，因为`&amp;v`生命周期不够长。
    tokio::spawn(async { 
        for x in &amp;v {
            println!("{x}")
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p>另一方面，<code>Send</code>是<code>tokio</code>的工作窃取策略的直接结果：在一个线程<code>A</code>上派生的任务，如果线程<code>B</code>空闲，可能会被移动到<code>B</code>上执行，因此需要<code>Send</code>约束，因为我们在跨越线程边界。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawner(input: Rc&lt;u64&gt;) {
    // 这也不行，因为`Rc`不是`Send`。
    tokio::spawn(async move {
        println!("{}", input);
    })
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-04_future"></div><h1 id="08_futures-04_future-future特性"><a class="header" href="#08_futures-04_future-future特性"><code>Future</code>特性</a></h1>
<h2 id="08_futures-04_future-局部rc问题"><a class="header" href="#08_futures-04_future-局部rc问题">局部<code>Rc</code>问题</a></h2>
<p>回到<code>tokio::spawn</code>的签名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
{ /* */ }
<span class="boring">}</span></code></pre></pre>
<p>对于<code>F</code>来说，<code>Send</code>实际上意味着什么呢？正如我们在前一节中看到的，这意味着它从派生环境中捕获的任何值都必须是<code>Send</code>。但不仅如此。</p>
<p>任何_跨过<code>.await</code>点_持有的值都必须是<code>Send</code>。让我们看一个例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

fn spawner() {
    tokio::spawn(example());
}

async fn example() {
    // 一个不是`Send`的值，在异步函数内部创建
    let non_send = Rc::new(1);
    
    // 一个什么都不做的`.await`点
    yield_now().await;

    // `.await`之后仍然需要局部非`Send`值
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会拒绝这段代码：</p>
<pre><code class="language-text">错误：future不能安全地在线程间发送
    |
5   |     tokio::spawn(example());
    |                  ^^^^^^^^^ future由`example`返回的不是`Send`
    |
注意：future不是`Send`，因为此值在线程等待中被使用
    |
11  |     let non_send = Rc::new(1);
    |         -------- 类型为`Rc&lt;i32&gt;`，不是`Send`
12  |     // 一个`.await`点
13  |     yield_now().await;
    |                 ^^^^^ 等待发生在这里，`non_send`可能稍后使用
注意：`tokio::spawn`中所需的一个约束
    |
164 |     pub fn spawn&lt;F&gt;(future: F) -&gt; JoinHandle&lt;F::Output&gt;
    |            ----- 此函数所需的一个约束
165 |     where
166 |         F: Future + Send + 'static,
    |                     ^^^^ 此约束在`spawn`中所需
</code></pre>
<p>为了理解为什么会这样，我们需要深化对Rust异步模型的理解。</p>
<h2 id="08_futures-04_future-future特性-1"><a class="header" href="#08_futures-04_future-future特性-1"><code>Future</code>特性</a></h2>
<p>我们之前说过，<code>async</code>函数返回<strong>future</strong>，实现<code>Future</code>特性的类型。你可以将future视为一个<strong>状态机</strong>。它处于以下两种状态之一：</p>
<ul>
<li><strong>pending</strong>：计算尚未完成。</li>
<li><strong>ready</strong>：计算已完成，这里是输出结果。</li>
</ul>
<p>这一点在特性定义中编码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Future {
    type Output;
    
    // 目前忽略`Pin`和`Context`
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="08_futures-04_future-poll"><a class="header" href="#08_futures-04_future-poll"><code>poll</code></a></h3>
<p><code>poll</code>方法是<code>Future</code>特性的核心。future本身不做任何事情。它需要<strong>轮询</strong>才能取得进展。当你调用<code>poll</code>时，你是在要求future做一些工作。<code>poll</code>尝试取得进展，然后返回以下之一：</p>
<ul>
<li><code>Poll::Pending</code>：future还没有准备好。你需要稍后再调用<code>poll</code>。</li>
<li><code>Poll::Ready(value)</code>：future已经完成。<code>value</code>是计算的结果，类型为<code>Self::Output</code>。</li>
</ul>
<p>一旦<code>Future::poll</code>返回<code>Poll::Ready</code>，就不应再对其进行轮询：future已完成，没有更多事情要做。</p>
<h3 id="08_futures-04_future-运行时的角色"><a class="header" href="#08_futures-04_future-运行时的角色">运行时的角色</a></h3>
<p>你很少（如果有的话）会直接调用<code>poll</code>。这是你的异步运行时的工作：它拥有<code>poll</code>签名中所需的全部信息（<code>Context</code>），以确保你的future能在可能时取得进展。</p>
<h2 id="08_futures-04_future-async-fn和future"><a class="header" href="#08_futures-04_future-async-fn和future"><code>async fn</code>和future</a></h2>
<p>我们一直使用的是高层接口，即异步函数。现在我们已经查看了低层原始特性，即<code>Future</code>特性。</p>
<p>它们是如何关联的呢？</p>
<p>每次你将一个函数标记为异步时，该函数都会返回一个future。编译器会将你异步函数的主体转换为一个<strong>状态机</strong>：每个<code>.await</code>点对应一个状态。</p>
<p>回到我们的<code>Rc</code>例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use tokio::task::yield_now;

async fn example() {
    let non_send = Rc::new(1);
    yield_now().await;
    println!("{}", non_send);
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会将其转换为类似这样的枚举：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExampleFuture {
    NotStarted,
    YieldNow(Rc&lt;i32&gt;),
    Terminated,
}
<span class="boring">}</span></code></pre></pre>
<p>当调用<code>example</code>时，它返回<code>ExampleFuture::NotStarted</code>。future从未被轮询过，所以什么也没发生。
当运行时首次轮询它时，<code>ExampleFuture</code>会前进到下一个<code>.await</code>点：它会在状态机的<code>ExampleFuture::YieldNow(Rc&lt;i32&gt;)</code>阶段停止，并返回<code>Poll::Pending</code>。
当再次轮询时，它将执行剩余的代码（<code>println!</code>）并返回<code>Poll::Ready(())</code>。</p>
<p>当你查看它的状态机表示形式<code>ExampleFuture</code>时，现在就很清楚为什么<code>example</code>不是<code>Send</code>了：它持有一个<code>Rc</code>，因此不能是<code>Send</code>。</p>
<h2 id="08_futures-04_future-放弃点"><a class="header" href="#08_futures-04_future-放弃点">放弃点</a></h2>
<p>正如你刚在<code>example</code>中看到的，每一个<code>.await</code>点都会在future的生命周期中创建一个新的中间状态。
这就是为什么<code>.await</code>点也被称为<strong>yield points</strong>：你的future_将控制权_交回轮询它的运行时，允许运行时暂停它，并（如果必要）调度另一个任务进行执行，从而在多个方面同时取得进展。</p>
<p>我们将在后面的章节中回到放弃的重要性。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-05_blocking"></div><h1 id="08_futures-05_blocking-不要阻塞运行时"><a class="header" href="#08_futures-05_blocking-不要阻塞运行时">不要阻塞运行时</a></h1>
<p>让我们回到放弃点的概念上来。与线程不同，<strong>Rust的任务不能被抢先</strong>。</p>
<p><code>tokio</code>本身不能决定暂停一个任务并代之以运行另一个任务。控制权<strong>仅当</strong>任务放弃时才会回到执行器——也就是说，当<code>Future::poll</code>返回<code>Poll::Pending</code>，或者在<code>async fn</code>的情况下，当你<code>.await</code>一个future时。</p>
<p>这使运行时面临风险：如果一个任务从不放弃，运行时就永远不会能够运行另一个任务。这被称为<strong>阻塞运行时</strong>。</p>
<h2 id="08_futures-05_blocking-什么是阻塞"><a class="header" href="#08_futures-05_blocking-什么是阻塞">什么是阻塞？</a></h2>
<p>多久算太久？一个任务在不放弃之前可以花费多少时间才成为问题？</p>
<p>这取决于运行时、应用程序、正在执行的任务数量以及许多其他因素。但作为一个经验法则，尽量在放弃点之间花费少于100微秒。</p>
<h2 id="08_futures-05_blocking-后果"><a class="header" href="#08_futures-05_blocking-后果">后果</a></h2>
<p>阻塞运行时可能导致：</p>
<ul>
<li><strong>死锁</strong>：如果永不放弃的任务正在等待另一个任务完成，而那个任务又在等待第一个任务放弃，就会形成死锁。除非运行时能够在不同的线程上调度其他任务，否则无法取得进展。</li>
<li><strong>饥饿</strong>：其他任务可能无法运行，或者可能在长时间延迟后才运行，这可能导致性能不佳（例如，高尾部延迟）。</li>
</ul>
<h2 id="08_futures-05_blocking-阻塞并不总是显而易见"><a class="header" href="#08_futures-05_blocking-阻塞并不总是显而易见">阻塞并不总是显而易见</a></h2>
<p>有些操作通常应该在异步代码中避免，比如：</p>
<ul>
<li>同步I/O。你无法预测它将花费多长时间，而且很可能会超过100微秒。</li>
<li>耗时的CPU密集型计算。</li>
</ul>
<p>然而，后一类情况并不总是显而易见。例如，对含有少量元素的向量进行排序没有问题；但如果向量包含数十亿条目，这一评估就会改变。</p>
<h2 id="08_futures-05_blocking-如何避免阻塞"><a class="header" href="#08_futures-05_blocking-如何避免阻塞">如何避免阻塞</a></h2>
<p>那么，假设你<strong>必须</strong>执行一个可能被视为阻塞或有风险的操作，你如何避免阻塞运行时呢？你需要将工作移到不同的线程上。你不希望使用所谓的运行时线程，即<code>tokio</code>用来运行任务的那些线程。</p>
<p><code>tokio</code>为此目的提供了一个专用的线程池，称为<strong>阻塞池</strong>。你可以使用<code>tokio::task::spawn_blocking</code>函数在阻塞池上启动同步操作。<code>spawn_blocking</code>返回一个future，当操作完成后解析为操作的结果。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::task;

fn expensive_computation() -&gt; u64 {
    // [...]
}

async fn run() {
    let handle = task::spawn_blocking(expensive_computation);
    // 同时做其他事情
    let result = handle.await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>阻塞池是长期存在的。相较于直接通过<code>std::thread::spawn</code>创建新线程，<code>spawn_blocking</code>应该更快，因为线程初始化的成本在多次调用中被分摊了。</p>
<h2 id="08_futures-05_blocking-进一步阅读"><a class="header" href="#08_futures-05_blocking-进一步阅读">进一步阅读</a></h2>
<ul>
<li>可以查阅<a href="https://ryhl.io/blog/async-what-is-blocking/">Alice Ryhl的博客文章</a>，了解更多关于这个主题的内容。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-06_async_aware_primitives"></div><h1 id="08_futures-06_async_aware_primitives-异步感知原语"><a class="header" href="#08_futures-06_async_aware_primitives-异步感知原语">异步感知原语</a></h1>
<p>如果你浏览<code>tokio</code>的文档，你会发现它提供了很多类型，这些类型“镜像”了标准库中的那些，但加入了异步的特性：锁、通道、计时器等等。</p>
<p>在异步环境下工作时，你应该优先选择这些异步替代品，而不是它们的同步对应物。</p>
<p>为了理解原因，让我们回顾一下上一章中探讨过的互斥锁<code>Mutex</code>。</p>
<h2 id="08_futures-06_async_aware_primitives-案例研究mutex"><a class="header" href="#08_futures-06_async_aware_primitives-案例研究mutex">案例研究：<code>Mutex</code></a></h2>
<p>来看一个简单的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;){
    let guard = m.lock().unwrap();
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard`在此处被释放
}

/// 使用`v`作为HTTP请求体
async fn http_call(v: &amp;[u64]){
  // [...]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="08_futures-06_async_aware_primitives-stdsyncmutexguard与放弃点"><a class="header" href="#08_futures-06_async_aware_primitives-stdsyncmutexguard与放弃点"><code>std::sync::MutexGuard</code>与放弃点</a></h3>
<p>这段代码能编译，但存在隐患。</p>
<p>我们在异步上下文中尝试获取<code>std</code>中的<code>Mutex</code>锁，然后在<code>.await</code>（在<code>http_call</code>上）的放弃点上保持得到的<code>MutexGuard</code>。</p>
<p>假设有两个任务在单线程运行时上并发执行<code>run</code>，我们观察到以下调度事件序列：</p>
<pre><code class="language-text">      Task A          Task B
         | 
   Acquire lock
 Yields to runtime
         | 
         +--------------+
                        |
              Tries to acquire lock
</code></pre>
<p>我们遇到了死锁。任务B永远无法获得锁，因为锁目前被任务A持有，而任务A在释放锁之前已经放弃了运行时的控制权，且运行时无法抢占任务B，因此任务A不会再被调度。</p>
<h3 id="08_futures-06_async_aware_primitives-tokiosyncmutex"><a class="header" href="#08_futures-06_async_aware_primitives-tokiosyncmutex"><code>tokio::sync::Mutex</code></a></h3>
<p>通过切换到<code>tokio::sync::Mutex</code>可以解决这个问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::Mutex;

async fn run(m: Arc&lt;Mutex&lt;Vec&lt;u64&gt;&gt;){
    let guard = m.lock().await;
    http_call(&amp;guard).await;
    println!("Sent {:?} to the server", &amp;guard);
    // `guard`在此处被释放
}
<span class="boring">}</span></code></pre></pre>
<p>现在获取锁是一个异步操作，如果无法继续推进就会让出运行时。回到之前的场景，情况会变成这样：</p>
<pre><code class="language-text">        Task A          Task B
           | 
   Acquires the lock
   Starts `http_call`
   Yields to runtime
           | 
           +--------------+
                          |
              Tries to acquire the lock
               Cannot acquire the lock
                  Yields to runtime
                          |
           +--------------+
           |
 `http_call` completes      
   Releases the lock
    Yield to runtime
           |
           +--------------+
                          |
                  Acquires the lock
                        [...]
</code></pre>
<p>一切顺利！</p>
<h3 id="08_futures-06_async_aware_primitives-多线程并不能拯救你"><a class="header" href="#08_futures-06_async_aware_primitives-多线程并不能拯救你">多线程并不能拯救你</a></h3>
<p>虽然我们在前面的例子中使用了单线程运行时作为执行环境，但在使用多线程运行时时，同样的风险依然存在。
唯一的区别在于导致死锁所需的并发任务数量：在单线程运行时中，2个就足够；而在多线程运行时，我们则需要<code>N+1</code>个任务，其中<code>N</code>是运行时线程的数量。</p>
<h3 id="08_futures-06_async_aware_primitives-缺点"><a class="header" href="#08_futures-06_async_aware_primitives-缺点">缺点</a></h3>
<p>拥有异步感知的<code>Mutex</code>伴随着性能上的损失。
如果你确信锁的竞争并不激烈，并且小心地不在放弃点上持有它，你仍然可以在异步上下文中使用<code>std::sync::Mutex</code>。</p>
<p>但是，要权衡性能收益与你将承担的活性风险。</p>
<h2 id="08_futures-06_async_aware_primitives-其他原语"><a class="header" href="#08_futures-06_async_aware_primitives-其他原语">其他原语</a></h2>
<p>我们以<code>Mutex</code>为例，但这同样适用于<code>RwLock</code>、信号量等。在异步环境中工作时，应优先选择异步感知版本，以最小化潜在问题的风险。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-07_cancellation"></div><h1 id="08_futures-07_cancellation-取消"><a class="header" href="#08_futures-07_cancellation-取消">取消</a></h1>
<p>当一个挂起的future被丢弃时会发生什么？运行时将不再对其轮询，因此它不会进一步推进。换句话说，其执行已经被<strong>取消</strong>了。</p>
<p>在实际应用中，这种情况经常发生在处理超时场景中。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::timeout;
use tokio::sync::oneshot;
use std::time::Duration;

async fn http_call() {
    // [...]
}

async fn run() {
    // 用设置为10毫秒后超时的`Timeout`包裹future。
    let duration = Duration::from_millis(10);
    if let Err(_) = timeout(duration, http_call()).await {
        println!("10毫秒内未收到值");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当超时时，由<code>http_call</code>返回的future会被取消。让我们想象这是<code>http_call</code>的主体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::TcpStream;

async fn http_call() {
    let (stream, _) = TcpStream::connect(/* */).await.unwrap();
    let request: Vec&lt;u8&gt; = /* */;
    stream.write_all(&amp;request).await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>每个<code>await</code>点都变成了一个<strong>取消点</strong>。由于<code>http_call</code>不能被运行时抢占，因此只能在通过<code>.await</code>将控制权交回执行器后被丢弃。这递归适用，例如，<code>stream.write_all(&amp;request)</code>在其实现中可能有多个<code>yield</code>点。完全有可能看到<code>http_call</code>在被取消前推送了_部分_请求，从而断开连接，永远无法完成消息体的传输。</p>
<h2 id="08_futures-07_cancellation-清理"><a class="header" href="#08_futures-07_cancellation-清理">清理</a></h2>
<p>Rust的取消机制非常强大，它允许调用者无需任何来自任务本身的协作就能取消正在进行的任务。同时，这也相当危险。可能需要进行<strong>优雅的取消</strong>，以确保在中止操作之前执行某些清理任务。</p>
<p>例如，考虑这个虚构的SQL事务API：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn transfer_money(
    connection: SqlConnection,
    payer_id: u64,
    payee_id: u64,
    amount: u64
) -&gt; Result&lt;(), anyhow::Error&gt; {
    let transaction = connection.begin_transaction().await?;
    update_balance(payer_id, amount, &amp;transaction).await?;
    decrease_balance(payee_id, amount, &amp;transaction).await?;
    transaction.commit().await?;
}
<span class="boring">}</span></code></pre></pre>
<p>在取消时，理想情况下应明确地中止挂起的事务，而非使其悬而未决。遗憾的是，Rust并未提供一种针对这种<strong>异步</strong>清理操作的万无一失的机制。</p>
<p>最常见的策略是依赖<code>Drop</code>特质来安排所需的清理工作。这可以通过：</p>
<ul>
<li>在运行时上派生一个新的任务</li>
<li>在通道上排队一条消息</li>
<li>派生一个后台线程</li>
</ul>
<p>最佳选择视情况而定。</p>
<h2 id="08_futures-07_cancellation-取消已派生的任务"><a class="header" href="#08_futures-07_cancellation-取消已派生的任务">取消已派生的任务</a></h2>
<p>使用<code>tokio::spawn</code>派生任务后，你将无法再丢弃它；它属于运行时。尽管如此，如果有需要，你可以使用其<code>JoinHandle</code>来取消它：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn run() {
    let handle = tokio::spawn(/* 某个异步任务 */);
    // 取消已派生的任务
    handle.abort();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="08_futures-07_cancellation-进一步阅读"><a class="header" href="#08_futures-07_cancellation-进一步阅读">进一步阅读</a></h2>
<ul>
<li>使用<code>tokio</code>的<code>select!</code>宏来“竞速”两个不同的future时要极度小心。除非你能确保<strong>取消安全</strong>，否则在循环中重试同一任务是危险的。更多细节请查看<a href="https://docs.rs/tokio/macro.select.html"><code>select!</code>的文档</a>。
如果你需要交织两个异步数据流（如socket和通道），推荐使用<a href="https://docs.rs/tokio-stream/latest/tokio_stream/trait.StreamExt.html#method.merge"><code>StreamExt::merge</code></a>代替。</li>
<li>与“突然”的取消相比，依赖于<a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>CancellationToken</code></a>可能是更可取的。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div id="08_futures-08_outro"></div><h1 id="08_futures-08_outro-结语"><a class="header" href="#08_futures-08_outro-结语">结语</a></h1>
<p>Rust的异步模型功能强大，但也引入了额外的复杂性。花时间了解你的工具：深入探索<code>tokio</code>的文档，熟悉其原语，充分利用它。</p>
<p>同时，请记住，语言层面和<code>std</code>级别正在进行工作，以简化和完善Rust的异步故事。由于缺少某些部分，你可能在日常工作中遇到一些棘手的问题。</p>
<p>为了获得相对无痛的异步体验，这里有一些建议：</p>
<ul>
<li><strong>选择一个运行时并坚持使用。</strong><br />
某些原语（如定时器、I/O）在运行时之间不可移植。尝试混合运行时可能会给你带来麻烦。试图编写运行时无关的代码可能会显著增加代码库的复杂度。如果可以，尽量避免。</li>
<li><strong>目前还没有稳定的<code>Stream</code>/<code>AsyncIterator</code>接口。</strong><br />
从概念上讲，<code>AsyncIterator</code>是一个异步产出新项的迭代器。虽然设计工作正在进行中，但尚无共识。如果你使用<code>tokio</code>，请参考<a href="https://docs.rs/tokio-stream/latest/tokio_stream/"><code>tokio_stream</code></a>作为你的首选接口。</li>
<li><strong>小心缓冲。</strong><br />
它往往是微妙错误的根源。想了解更多详情，可以查阅<a href="https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_battles_buffered_streams.html">"Barbara对抗缓冲流"</a>。</li>
<li><strong>异步任务没有类似范围线程的等价物。</strong><br />
详情请参阅<a href="https://without.boats/blog/the-scoped-task-trilemma/">"范围任务三难困境"</a>。</li>
</ul>
<p>不要让这些注意事项吓到你：异步Rust正被大规模有效地应用于诸如AWS、Meta等基础服务中，以驱动核心业务。如果你计划构建Rust网络应用程序，掌握它是必不可少的。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="going_further"></div><h1 id="going_further-后记"><a class="header" href="#going_further-后记">后记</a></h1>
<p>我们的Rust之旅在这里告一段落。虽然内容已经相当广泛，但这远非穷尽：Rust是一门表面积广阔的语言，拥有一个更加庞大的生态系统！然而，请不要因此感到畏惧：<strong>无需掌握一切</strong>。在从事项目（后端、嵌入式、命令行界面、图形用户界面等）时，你会自然而然地学到所需的一切有效知识。</p>
<p>归根结底，没有任何捷径：如果你想擅长某事，你需要反复实践。在这门课程中，你已经编写了不少Rust代码，足以让这门语言及其语法流畅地在你的指尖流淌。要想让Rust真正成为你的得心应手之选，还需更多代码的磨练，但只要不断练习，那一刻无疑终将来临。</p>
<h2 id="going_further-进一步学习"><a class="header" href="#going_further-进一步学习">进一步学习</a></h2>
<p>让我们以一些额外资源的指引作为结束，它们或许能帮助你在继续Rust旅程时找到方向。</p>
<h3 id="going_further-练习"><a class="header" href="#going_further-练习">练习</a></h3>
<p>你可以在<a href="https://github.com/rust-lang/rustlings"><code>rustlings</code></a>项目和<a href="https://exercism.io">exercism.io</a>的Rust赛道上找到更多练习Rust的题目。</p>
<h3 id="going_further-入门材料"><a class="header" href="#going_further-入门材料">入门材料</a></h3>
<p>如果你想从不同角度学习我们课程中涵盖的概念，可以参考<a href="https://doc.rust-lang.org/book/title-page.html">Rust书籍</a>和《Programming Rust》(<a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">O'Reilly出版社</a>版)。这些资料并非完全重复，因此在学习过程中你肯定会收获新知。</p>
<h3 id="going_further-高级材料"><a class="header" href="#going_further-高级材料">高级材料</a></h3>
<p>如果你想深入语言，可以查阅<a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>和《Rust编程进阶》(<a href="https://nostarch.com/rust-rustaceans">No Starch出版社</a>版)。此外，“Decrusted”系列视频教程(<a href="https://www.youtube.com/playlist?list=PLqbS7AVVErFirH9armw8yXlE6dacF-A6z">YouTube播放列表</a>)也是深入了解许多热门Rust库内部运作的优秀资源。</p>
<h3 id="going_further-领域特定材料"><a class="header" href="#going_further-领域特定材料">领域特定材料</a></h3>
<p>若想用Rust进行后端开发，可以参考<a href="https://zero2prod.com">"从零到生产环境的Rust开发"</a>；若想进行嵌入式开发，则可以查阅<a href="https://docs.rust-embedded.org/book/">嵌入式Rust书籍</a>。</p>
<h3 id="going_further-专题精讲"><a class="header" href="#going_further-专题精讲">专题精讲</a></h3>
<p>你还能找到横跨多个领域的关键主题资源。对于测试，可以学习<a href="https://github.com/mainmatter/rust-advanced-testing-workshop">"超越基础的高级测试"</a>；对于遥测，可以参考<a href="https://github.com/mainmatter/rust-telemetry-workshop">"看不见就无法修复的问题"</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
