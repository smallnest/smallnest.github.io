<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Effective Rust 中文版</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="intro.html">介绍</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="chapter_1/item2-use-types-2.html"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="chapter_1/item9-iterators.html"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2/item10-std-traits.html"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/item14-lifetimes.html"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="chapter_3/item15-borrows.html"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="chapter_3/item17-deadlock.html"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div id="cover"></div><h1 id="cover-effective-rust"><a class="header" href="#cover-effective-rust">Effective Rust</a></h1>
<blockquote>
<p>35 Specific Ways to Improve Your Rust Code</p>
</blockquote>
<blockquote>
<p><em>编写高质量 Rust 代码的 35 个有效方法</em></p>
</blockquote>
<p>原著：<strong>David Drysdale</strong></p>
<p>翻译：<strong>lispking</strong></p>
<p><img src="./images/cover.png" alt="cover" /></p>
<div id="cover-footer" class="footer">
    <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"></a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="intro_zh"></div><h1 id="intro_zh-译著"><a class="header" href="#intro_zh-译著">译著</a></h1>
<blockquote>
<p>“代码更像是指南，而不是实际的规则。” —— Hector Barbossa</p>
</blockquote>
<p>在编程语言的江湖中，Rust 如同一颗新星，以其独树一帜的安全特性和严谨的类型系统，赢得了开发者的青睐。</p>
<p>近日，一本备受瞩目的新书《Effective Rust》横空出世，它不仅为我们揭示了 Rust 编程的深层智慧，还提供了实用的实战技巧。</p>
<p>本文将从这本书的精彩引言出发，带你领略 Rust 的优势与挑战，并预告将持续翻译分享，为读者带来 Rust 编程的全面解析。</p>
<h1 id="intro_zh-effective-rust引言简述"><a class="header" href="#intro_zh-effective-rust引言简述">《Effective Rust》引言简述</a></h1>
<h3 id="intro_zh-全书由六个部分组成"><a class="header" href="#intro_zh-全书由六个部分组成">全书由六个部分组成：</a></h3>
<ol>
<li><strong>类型</strong>：围绕 Rust 核心类型系统的建议。</li>
<li><strong>概念</strong>：构成 Rust 设计核心思想的建议。</li>
<li><strong>依赖关系</strong>：关于使用 Rust 包生态系统的建议。</li>
<li><strong>工具</strong>：关于如何通过超越 Rust 编译器来改进代码库的建议。</li>
<li><strong>异步Rust</strong>：关于使用 Rust 异步机制的建议。</li>
<li><strong>超越标准Rust</strong>：关于在超出 Rust 标准、安全环境时，如何工作的建议。</li>
</ol>
<blockquote>
<p>尽管“概念”部分可以说是比“类型”部分更基础，但它故意排在第二位，以便从开始到结束阅读的读者可以首先建立一些信心。</p>
</blockquote>
<h3 id="intro_zh-rust-的优势安全的护城河与强大的类型系统"><a class="header" href="#intro_zh-rust-的优势安全的护城河与强大的类型系统">Rust 的优势：安全的护城河与强大的类型系统</a></h3>
<ol>
<li>安全性：Rust 在类型安全和内存安全方面的卓越表现，使其在编译阶段就能抵御大量潜在的错误。这与 C++ 等语言相比，无疑是 Rust 的一大亮点。</li>
<li>类型系统：Rust 的类型系统不仅强大，而且一致，这让 Rust 程序在编译时就能捕捉到更多的错误。一个能够顺利编译的 Rust 程序，往往已经具备了较高的稳定性。</li>
</ol>
<h3 id="intro_zh-rust-的挑战攀登学习高峰与编译器的较量"><a class="header" href="#intro_zh-rust-的挑战攀登学习高峰与编译器的较量">Rust 的挑战：攀登学习高峰与编译器的较量</a></h3>
<ol>
<li>学习曲线：Rust 的生命周期、所有权和借用等概念，对于初学者来说，可能是一道难以逾越的门槛。然而，一旦掌握，这些概念将成为开发者手中的强大工具。</li>
<li>编译器斗争：尽管 Rust 编译器提供了丰富的错误诊断信息，但在与借用检查器的较量中，开发者仍需付出大量的时间和精力。这也是 Rust 编程的一大考验。</li>
</ol>
<h3 id="intro_zh-effective-rust的启示实战的蓝图与-rust-生态的探索"><a class="header" href="#intro_zh-effective-rust的启示实战的蓝图与-rust-生态的探索">《Effective Rust》的启示：实战的蓝图与 Rust 生态的探索</a></h3>
<ol>
<li>实战蓝图：《Effective Rust》一书如同一位经验丰富的向导，提供了许多关于 Rust 编程的实战技巧，这些技巧将帮助开发者更好地应对编程中的各种挑战。</li>
<li>Rust 生态探索：书中还介绍了 Rust 的包生态系统和工具链，这将有助于开发者更好地利用社区资源，提升开发效率。</li>
</ol>
<h1 id="intro_zh-结论"><a class="header" href="#intro_zh-结论">结论</a></h1>
<p>《Effective Rust》的问世，不仅为 Rust 爱好者带来了一场知识的盛宴，也为广大开发者提供了一把开启 Rust 编程之门的钥匙。</p>
<p>Rust 以其安全性和类型系统，在编程语言的世界中独领风骚。虽然面临学习曲线和编译器斗争等挑战，但 Rust 的优势使其成为值得每一位开发者投入时间和精力的语言。</p>
<p>通过持续翻译分享《Effective Rust》，我们将一起深入 Rust 的世界，掌握 Rust 编程的精髓，为未来的软件开发铺就一条坚实的道路。</p>
<div id="intro_zh-footer" class="footer">
    <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"></a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="intro"></div><h1 id="intro-引言"><a class="header" href="#intro-引言">引言</a></h1>
<blockquote>
<p>“代码更像是‘指导原则’，而不是实际规则。” —— 赫克托·巴博萨</p>
</blockquote>
<p>在众多现代编程语言的拥挤景观中，Rust 与众不同。Rust 提供了编译语言的速度，非垃圾回收语言的高效，以及函数式语言的类型安全 —— 同时还提供了解决内存安全问题的独特方案。因此，Rust 经常被评为<a href="https://survey.stackoverflow.co/2022#most-loved-dreaded-and-wanted-language-love-dread">最受欢迎的编程语言</a>。</p>
<p>Rust 的类型系统的强大和一致性意味着，如果一个 Rust 程序能够编译，那么它已经有一个不错的机会可以正常工作 —— 这种现象之前只在更学术、更不亲民的语方中观察到，如 Haskell。如果一个 Rust 程序能够编译，它也将安全地工作。</p>
<p>然而，这种安全 —— 包括类型安全和内存安全 —— 确实是有代价的。尽管基本文档的质量很高，Rust 还是因为入门坡度陡峭而闻名，新来者必须经历与借用检查器的斗争、重新设计数据结构以及被生命周期搞糊涂的入门仪式。一个能够编译的 Rust 程序可能第一次就有很大的机会正常工作，但是为了让它编译的斗争是真实的 —— 即使 Rust 编译器的错误诊断非常有帮助。</p>
<h2 id="intro-本书面向的读者"><a class="header" href="#intro-本书面向的读者">本书面向的读者</a></h2>
<p>这本书试图帮助程序员在这些他们挣扎的领域，即使他们已经具有像 C++ 这样的现有编译语言的经验。因此，与其他 Effective <Language> 书籍一样，这本书旨在成为 Rust 新手的第二本所需书籍，在他们已经在其他地方遇到基础知识之后 —— 例如，在《<a href="https://doc.rust-lang.org/book/">Rust 编程语言</a>》（Steve Klabnik和Carol Nichols，No Starch Press）或《<a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Rust 程序设计</a>》（Jim Blandy等，O'Reilly）中。</p>
<p>然而，Rust 的安全性导致这里的条目有一些不同的侧重点，特别是与 Scott Meyers 的原始 Effective C++ 系列相比。C++ 语言充满了陷阱，所以 Effective C++ 专注于避免这些陷阱的一组建议，这些建议基于在 C++ 中创建软件的实际经验。重要的是，它包含的是指导原则而不是规则，因为指导原则有例外 —— 提供指导原则的详细理由允许读者自行决定他们的特定情况是否值得违反规则。</p>
<p>在这里，提供建议及其原因的风格被保留了下来。但是，由于 Rust 几乎没有陷阱，这里的条目更多地集中在 Rust 引入的概念上。许多条目的标题像“理解…”和“熟悉自己了解…”，并帮助在编写流畅、地道的 Rust 代码的旅程中。</p>
<p>Rust 的安全性也导致完全没有标题为“永远不要…”的条目。如果你真的不应该做某事，编译器通常会阻止你这样做。</p>
<h2 id="intro-rust-版本"><a class="header" href="#intro-rust-版本">Rust 版本</a></h2>
<p>文本是为2018版的 Rust 编写的，使用稳定工具链。Rust 的后向兼容性承诺意味着任何更高版本的 Rust，包括2021版，仍然会支持为2018版编写的代码，即使那个更高版本引入了破坏性更改。Rust 现在也足够稳定，以至于2018版和2021版之间的差异很小；书中没有任何代码需要更改才能符合2021版（但是<a href="https://www.lurklurk.org/effective-rust/reflection.html">第19条</a>包括一个例外，其中较晚版本的 Rust 允许以前不可能的新行为）。</p>
<p>这里的条目没有涵盖 Rust 的任何异步功能方面，因为这涉及到更高级的概念和不那么稳定的工具链支持 —— 使用同步 Rust 已经有足够多的内容要介绍了。也许将来会出现一本《有效的异步Rust》…</p>
<p>用于代码片段和错误信息的具体 <code>rustc</code> 版本是 <code>1.70</code>。代码片段不太可能需要针对更高版本进行更改，但错误消息可能会因你特定的编译器版本而有所不同。包含在文本中的错误消息也已经手动编辑，以适应书的宽度限制，但除此之外都是编译器生成的。</p>
<p>文本中有许多对其他静态类型语言的引用和比较，如 Java、Go 和 C++，以帮助有这些语言经验的读者定位自己。（ C++ 可能是最接近等价的语言，特别是当 C++11 的移动语义发挥作用时。）</p>
<h2 id="intro-本书导读"><a class="header" href="#intro-本书导读">本书导读</a></h2>
<p>本书的章节构成分为六章：</p>
<ul>
<li>第一章 —— 类型：围绕 Rust 核心类型系统的建议</li>
<li>第二章 —— 特征：关于使用 Rust 特征的建议</li>
<li>第三章 —— 概念：构成 Rust 设计核心思想的观念</li>
<li>第四章 —— 依赖性：关于使用 Rust 包生态系统的建议</li>
<li>第五章 —— 工具：通过超越 Rust 编译器来改进代码库的建议</li>
<li>第六章 —— 超越标准 Rust：当您需要在 Rust 标准、安全环境之外工作时，给出的建议</li>
</ul>
<p>虽然“概念”章节可能比“类型”和“特征”章节更为基础，但它故意放在书的后面，以便从头到尾阅读的读者可以首先建立一些信心。</p>
<h2 id="intro-本书中使用的约定"><a class="header" href="#intro-本书中使用的约定">本书中使用的约定</a></h2>
<p>本书使用了以下排版约定：</p>
<ul>
<li>斜体：表示新术语、URL、电子邮件地址、文件名和文件扩展名。</li>
<li>固定宽度：用于程序列表，以及在段落中引用程序元素，如变量或函数名、数据库、数据类型、环境变量、语句和关键字。</li>
</ul>
<p>以下标记用于标识以某种方式不正确的代码。</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>含义</th></tr></thead><tbody>
<tr><td><img src="./images/ferris/does_not_compile.svg" style="zoom:5%;" /></td><td>这段代码无法编译！</td></tr>
<tr><td><img src="./images/ferris/not_desired_behavior.svg" style="zoom:5%;" /></td><td>这段代码没有产生期望的行为。</td></tr>
</tbody></table>
</div>
<h2 id="intro-致谢"><a class="header" href="#intro-致谢">致谢</a></h2>
<p>我要感谢那些帮助使这本书成为可能的人们：</p>
<ul>
<li>
<p>技术审阅者们对文本的所有方面提供了专业和详细的反馈：Pietro Albini, Jess Males, Mike Capp，尤其是Carol Nichols。</p>
</li>
<li>
<p>我在O'Reilly的编辑们：Jeff Bleiel, Brian Guerin, 和 Katie Tozer。</p>
</li>
<li>
<p>Tiziano Santoro，我从他那里最初学到了许多关于Rust的知识。</p>
</li>
<li>
<p>Danny Elfanbaum，他提供了处理书籍AsciiDoc格式化的重要技术支持。</p>
</li>
<li>
<p>原始网络版书籍的勤奋读者们，特别是：</p>
<ul>
<li>Julian Rosse，他在在线文本中发现了数十个拼写错误和其他错误。</li>
<li>Martin Disch，他指出了多个条目中可能的改进和不准确之处。</li>
<li>Chris Fleetwood, Sergey Kaunov, Clifford Matthews, Remo Senekowitsch, Kirill Zaborsky，以及一位匿名Proton Mail用户，他们指出了文本中的错误。</li>
</ul>
</li>
<li>
<p>我的家人，他们忍受了许多我因写作而分心的周末。</p>
</li>
</ul>
<p>原文<a href="https://www.lurklurk.org/effective-rust/preface.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div id="intro-footer" class="footer">
    <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png"></a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1"></div><h1 id="chapter_1-类型"><a class="header" href="#chapter_1-类型">类型</a></h1>
<p>这本书的第一部分涵盖了关于 Rust 类型系统的建议。Rust 的类型系统比其他主流语言的表达能力更强；它与“学术性”语言如 <a href="https://ocaml.org/">OCaml</a> 或 <a href="https://www.haskell.org/">Haskell</a> 有更多共同点。</p>
<p>其中核心的一部分是 Rust 的枚举类型（<code>enum</code>），它比其他语言中的枚举类型具有更强的表达能力，并且允许使用<a href="https://en.wikipedia.org/wiki/Algebraic_data_type">代数数据类型</a>。</p>
<p>Rust 类型系统的另一个核心支柱是特征（<code>trait</code>）类型。特征大致等同于其他语言中的接口类型，但它们也与 Rust 的 <em>泛型</em>（<a href="https://www.lurklurk.org/effective-rust/generics.html">第12条</a>）相关联，允许在不产生运行时开销的情况下重用接口。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item1-use-types"></div><h1 id="chapter_1-item1-use-types-第-1-条使用类型系统表达你的数据结构"><a class="header" href="#chapter_1-item1-use-types-第-1-条使用类型系统表达你的数据结构">第 1 条：使用类型系统表达你的数据结构</a></h1>
<blockquote>
<p>“谁叫他们是程序员，而不是打字员” —— <a href="https://twitter.com/thingskatedid/status/1400213496785108997">@thingskatedid</a></p>
</blockquote>
<p>对于来自其他静态类型编程语言（如 C++、Go 或 Java）的人来说，Rust 类型系统的基本概念是非常熟悉的。有一系列具有特定大小的整数类型，包括有符号（i8, i16, i32, i64, i128）和无符号（u8, u16, u32, u64, u128）。</p>
<p>还有两种整数类型，其大小与目标系统上的指针大小匹配：有符号（isize）和无符号（usize）。Rust 并不是那种会在指针和整数之间进行大量转换的语言，所以这种特性并不是特别相关。然而，标准集合返回它们的大小作为一个 usize（来自 .len()），所以集合索引意味着 usize 值非常常见 —— 从容量的角度来看，这是显然没有问题的，因为内存中的集合不可能有比系统上的内存地址更多的项。</p>
<p>整数类型确实让我们第一次意识到 Rust 是一个比 C++ 更严格的世界 —— 尝试将一个 quart（i32）放入 pint pot（i16）会在编译时产生错误。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 42;
let y: i16 = x;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:14:22
   |
14 |         let y: i16 = x;
   |                ---   ^ expected `i16`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i16` and panic if the converted value doesn't fit
   |
14 |         let y: i16 = x.try_into().unwrap();
   |                       ++++++++++++++++++++
<span class="boring">}</span></code></pre></pre>
<p>这让人感到安心：当程序员进行有风险的操作时，Rust 不会安静地坐视不管。这也早早地表明，尽管 Rust 有更严格的规则，但它也有助于编译器消息指向如何遵守规则的方法。</p>
<p>建议的解决方案是抛出一个问题，即如何处理转换会改变值的情况，关于<code>错误处理</code>（<a href="#chapter_1-item4-errors">第4条</a>）和使用 <code>panic!</code>（<a href="https://www.lurklurk.org/effective-rust/panic.html">第18条</a>）我们将在后面有更多的讨论。</p>
<p>Rust 也不允许一些可能看起来“安全”的操作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42i32; // Integer literal with type suffix
let y: i64 = x;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:23:22
   |
23 |         let y: i64 = x;
   |                ---   ^ expected `i64`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i64`
   |
23 |         let y: i64 = x.into();
   |                       +++++++
<span class="boring">}</span></code></pre></pre>
<p>在这里，建议的解决方案并没有提出错误处理的方法，但转换仍然需要是显式的。我们将在后面章节更详细地讨论类型转换（<a href="#chapter_1-item6-newtype">第6条</a>）。</p>
<p>现在继续探讨不出乎意料的原始类型，Rust 有布尔类型（<code>bool</code>）、浮点类型（<code>f32</code>, <code>f64</code>）和单元类型 <code>()</code>（类似于 <code>C</code> 的 <code>void</code>）。</p>
<p>更有趣的是 <code>char</code> 字符类型，它持有一个 <a href="http://www.unicode.org/glossary/#unicode_scalar_value"><code>Unicode</code> 值</a>（类似于 Go 的 <a href="https://golang.org/doc/go1#rune"><code>rune 类型</code></a>）。尽管它在内部以 <code>4 字节</code>存储，但与 <code>32 位</code>整数的转换仍然不会有静默转换。</p>
<p>类型系统中的这种精确性迫使你明确地表达你想要表达的内容 —— u32 值与 char 不同，后者又与序列 UTF-8 字节不同，这又与序列任意字节不同，而且需要你准确地指定你的意思<sup class="footnote-reference"><a href="#chapter_1-item1-use-types-1">1</a></sup>。<a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">Joel Spolsky 的著名博客</a>文章可以帮助你理解需要哪种类型。</p>
<p>当然，有一些辅助方法允许你在这不同的类型之间进行转换，但它们的签名迫使你处理（或明确忽略）失败的可能性。例如，一个 <code>Unicode</code> 代码点<sup class="footnote-reference"><a href="#chapter_1-item1-use-types-2">2</a></sup> 总是可以用 <code>32 位</code>表示，所以 <code>'a' as u32</code> 是允许的，但反向转换就比较复杂了（因为有些 u32 值不是有效的 Unicode 代码点），例如：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32">char::from_u32</a> 返回一个 <code>Option&lt;char&gt;</code>，迫使调用者处理失败的情况</li>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32_unchecked">char::from_u32_unchecked</a> 假设有效性，但由于结果是未定义的，因此被标记为<code>unsafe</code>，迫使调用者也使用<code>unsafe</code>（<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第16条</a>）。</li>
</ul>
<h2 id="chapter_1-item1-use-types-聚合类型"><a class="header" href="#chapter_1-item1-use-types-聚合类型">聚合类型</a></h2>
<p>继续讨论聚合类型，Rust 有：</p>
<ul>
<li>数组（<code>Arrays</code>），它们持有单个类型的多个实例，实例的数量在编译时已知。例如 <code>[u32; 4]</code> 是四个连续的 4 字节整数。</li>
<li>元组（<code>Tuples</code>），它们持有多个异构类型的实例，元素的数量和类型在编译时已知，例如 <code>(WidgetOffset, WidgetSize, WidgetColour)</code>。如果元组中的类型不够独特 —— 例如 <code>(i32, i32, &amp;'static str, bool)</code> —— 最好给每个元素命名并使用 …</li>
<li>结构体（<code>Structs</code>），它们也持有编译时已知的异构类型实例，但是允许通过名称来引用整个类型和各个字段。</li>
<li>元组结构体（<code>Tuple structs</code>）是结构体和元组的杂交体：整个类型有一个名称，但各个字段没有名称 —— 它们通过数字来引用：<code>s.0</code>, <code>s.1</code> 等。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TextMatch(usize, String);
let m = TextMatch(12, "needle".to_owned());
assert_eq!(m.0, 12);
<span class="boring">}</span></code></pre></pre>
<p>这让我们来到了 Rust 类型系统的皇冠上的宝石：枚举（<code>enum</code>）。</p>
<p>在其基本形式中，很难看出有什么值得兴奋的。与其他语言一样，枚举允许你指定一组互斥的值，可能附带一个数字或字符串值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum HttpResultCode {
   Ok = 200,
   NotFound = 404,
   Teapot = 418,
}
let code = HttpResultCode::NotFound;
assert_eq!(code as i32, 404);
<span class="boring">}</span></code></pre></pre>
<p>因为每个枚举定义都创建了一个独特的类型，这可以用来提高那些接受布尔参数的函数的可读性和可维护性。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_page(/* both_sides= */ true, /* colour= */ false);
<span class="boring">}</span></code></pre></pre>
<p>可以用 <code>enum</code> 替换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Sides {
   Both,
   Single,
}

pub enum Output {
   BlackAndWhite,
   Colour,
}

pub fn print_page(sides: Sides, colour: Output) {
   // ...
}
<span class="boring">}</span></code></pre></pre>
<p>在调用处更加类型安全，而且易于阅读：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_page(Sides::Both, Output::BlackAndWhite);
<span class="boring">}</span></code></pre></pre>
<p>不同于布尔版本，如果使用该库的用户不小心颠倒了参数的顺序，编译器会立即报错：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:20
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                    ^^^^^^^^^^^^^^^^^^^^^ expected enum `enums::Sides`, found enum `enums::Output`
error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:43
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                                           ^^^^^^^^^^^^^ expected enum `enums::Output`, found enum `enums::Sides`
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>使用新类型模式（<a href="#chapter_1-item7-builder">第7条</a>）来包装一个 <code>bool</code> 也可以实现类型安全和可维护性；如果语义始终是布尔型的，通常最好使用这种方式，如果将来可能会出现新的选择（例如 <code>Sides::BothAlternateOrientation</code>），则应使用<code>枚举</code>。</p>
</blockquote>
<p>Rust 枚举的类型安全性在 <code>match</code> 表达式中继续体现出以下这段代码无法编译：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = match code {
   HttpResultCode::Ok =&gt; "Ok",
   HttpResultCode::NotFound =&gt; "Not found",
   // forgot to deal with the all-important "I'm a teapot" code
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0004]: non-exhaustive patterns: `Teapot` not covered
  --&gt; use-types/src/main.rs:65:25
   |
51 | /     enum HttpResultCode {
52 | |         Ok = 200,
53 | |         NotFound = 404,
54 | |         Teapot = 418,
   | |         ------ not covered
55 | |     }
   | |_____- `HttpResultCode` defined here
...
65 |           let msg = match code {
   |                           ^^^^ pattern `Teapot` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `HttpResultCode`
<span class="boring">}</span></code></pre></pre>
<p>编译器强制程序员考虑枚举所表示的所有可能性，即使结果只是添加一个默认分支 <code>_ =&gt; {}</code>。</p>
<blockquote>
<p>注意，现代 C++ 编译器能够并且会对枚举缺失的switch分支发出警告。</p>
</blockquote>
<h2 id="chapter_1-item1-use-types-带有字段的枚举"><a class="header" href="#chapter_1-item1-use-types-带有字段的枚举">带有字段的<code>枚举</code></a></h2>
<p>Rust枚举特性的真正强大之处在于每个变体都可以携带数据，使其成为一个<a href="https://en.wikipedia.org/wiki/Algebraic_data_type">代数数据类型</a>（ADT）。这对于主流语言的程序员来说不太熟悉；在C/C++的术语中，它类似于枚举与联合的组合 —— 只是类型安全的。</p>
<p>这意味着程序数据结构的不变式可以被编码到 Rust 的类型系统中；不符合那些不变式状态的代码甚至无法编译。一个设计良好的枚举使得创建者的意图对于人类以及编译器都是清晰的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SchedulerState {
    Inert,
    Pending(HashSet&lt;Job&gt;),
    Running(HashMap&lt;CpuId, Vec&lt;Job&gt;&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>仅从类型定义来看，可以合理猜测 Job 在 Pending 状态中排队，直到调度器完全激活，此时它们被分配到某个特定 CPU 的池中。</p>
<p>这突出了本方法的中心主题，即使用 Rust 的类型系统来表达与软件设计相关的概念。</p>
<p>当一个字段或参数何时有效需要通过注释来解释时，这就是一个明显的迹象表明这种情况没有发生：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DisplayProps {
    x: u32,
    y: u32,
    monochrome: bool,
    // `fg_colour` must be (0, 0, 0) if `monochrome` is true.
    fg_colour: RgbColour,
}
<span class="boring">}</span></code></pre></pre>
<p>这是一个非常适合用带有数据的<code>枚举</code>来替换的结构体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum Colour {
    Monochrome,
    Foreground(RgbColour),
}

struct DisplayProperties {
    x: u32,
    y: u32,
    colour: Colour,
}
<span class="boring">}</span></code></pre></pre>
<p>这个简单的例子说明了一个关键的建议：让你的类型无法表达无效状态。只支持有效值组合的类型意味着整类的错误会被编译器拒绝，从而使得代码更小、更安全。</p>
<h2 id="chapter_1-item1-use-types-选项与错误"><a class="header" href="#chapter_1-item1-use-types-选项与错误">选项与错误</a></h2>
<p>回到枚举的强大功能，有两个概念非常常见，以至于Rust内置了枚举类型来表达它们。</p>
<p>第一个是Option的概念：要么存在特定类型的值（<code>Some(T)</code>），要么不存在（<code>None</code>）。始终为可能缺失的值使用 <code>Option</code>；永远不要退回到使用哨兵值（<code>-1</code>, <code>nullptr</code>, …）来试图在带内表达相同的概念。</p>
<p>然而，有一个微妙的点需要考虑。如果您处理的是事物的集合，您需要决定集合中没有任何事物是否与没有集合相同。在大多数情况下，这种区别不会出现，您可以继续使用 <code>Vec&lt;Thing&gt;</code>：零个事物意味着事物的缺失。</p>
<p>然而，确实存在其他罕见的情况，需要用 <code>Option&lt;Vec&lt;Thing&gt;&gt;</code> 来区分这两种情况 —— 例如，加密系统可能需要区分“负载单独传输”和“提供空负载”。（这与 <code>SQL</code> 中 <code>NULL</code> 标记列的争论有关。）</p>
<p>一个常见的边缘情况是 <code>String</code> 可能缺失 —— 是用 <code>""</code> 还是 <code>None</code> 来表示值的缺失更有意义？无论哪种方式都可以，但 <code>Option&lt;String&gt;</code> 清楚地传达了可能缺失该值的可能性。</p>
<p>第二个常见的概念源于<code>错误处理</code>：如果一个函数失败，应该如何报告这个失败？历史上，使用了特殊的哨兵值（例如，<code>Linux 系统调用</code> 的 <code>-errno</code> 返回值）或全局变量（<code>POSIX 系统</code>的<code>errno</code>）。近年来，支持函数返回多个或元组返回值的语言（如Go）可能有一个约定，即返回一个<code>(result, error)</code>对，假设在错误非“零”时，结果存在合适的“零”值。</p>
<p>在Rust中，始终将可能失败的操作的 结果编码为 <code>Result&lt;T, E&gt;</code>。<code>T 类型</code>保存成功的结果（在<code>Ok</code>变体中），<code>E 类型</code>在失败时保存错误详情（在<code>Err</code>变体中）。使用标准类型使得设计意图清晰，并且允许使用标准转换（<a href="#chapter_1-item3-transform">第3条</a>）和错误处理（<a href="#chapter_1-item4-errors">第4条</a>）；它还使得使用 <code>?</code> 运算符来简化错误处理成为可能。</p>
<hr />
<h4 id="chapter_1-item1-use-types-注释"><a class="header" href="#chapter_1-item1-use-types-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item1-use-types-1"><sup class="footnote-definition-label">1</sup>
<p>如果涉及到文件系统，情况会更加复杂，因为流行平台上的文件名介于任意字节和 UTF-8 序列之间：请参阅 <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">std::ffi::OsString</a> 文档。</p>
</div>
<div class="footnote-definition" id="chapter_1-item1-use-types-2"><sup class="footnote-definition-label">2</sup>
<p>技术上，是一个 Unicode 标量值，而不是代码点。</p>
</div>
<div class="footnote-definition" id="chapter_1-item1-use-types-3"><sup class="footnote-definition-label">3</sup>
<p>这也意味着在库中为一个现有枚举添加一个新的变体是一个破坏性的更改（<a href="https://www.lurklurk.org/effective-rust/semver.html">第21条</a>）：库的客户需要更改他们的代码以适应新的变体。如果一个枚举实际上只是一个旧式的值列表，可以通过将其标记为 non_exhaustive 枚举来避免这种行为；请参阅<a href="https://www.lurklurk.org/effective-rust/semver.html">第21条</a>。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/use-types.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item2-use-types-2"></div><h1 id="chapter_1-item2-use-types-2-第-2-条使用类型系统表达常见行为"><a class="header" href="#chapter_1-item2-use-types-2-第-2-条使用类型系统表达常见行为">第 2 条：使用类型系统表达常见行为</a></h1>
<p><a href="#chapter_1-item1-use-types">第1条</a>讨论了如何在类型系统中表达数据结构；本节继续讨论在 Rust 的类型系统中行为的编码。</p>
<h2 id="chapter_1-item2-use-types-2-方法-methods-"><a class="header" href="#chapter_1-item2-use-types-2-方法-methods-">方法（ Methods ）</a></h2>
<p>在 Rust 的类型系统中，行为首次出现的地方就是将方法添加到数据结构上：这些方法是对该类型实例的操作，通过 <code>self</code> 标识。这种方式以对象导向的方式将相关的数据和代码封装在一起，这与其他语言中的做法相似；然而，在 Rust 中，方法不仅可以添加到<code>结构体</code>类型上，也可以添加到<code>枚举</code>类型上，这与 Rust 枚举的普遍性质相符（<a href="#chapter_1-item1-use-types">第1条</a>）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Circle { radius: f64 },
}

impl Shape {
    pub fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Circle { radius } =&gt; std::f64::consts::PI * radius * radius,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>方法的名称为其编码的行为提供了一个标签，而方法签名提供了其输入和输出的类型信息。方法的第一个输入是 <code>self</code> 的某种变体，指示该方法可能对数据结构执行的操作：</p>
<ul>
<li><code>&amp;self</code> 参数表示可以从数据结构中读取内容，但不会修改它。</li>
<li><code>&amp;mut self</code> 参数表示该方法可能会修改数据结构的内容。</li>
<li><code>self</code> 参数表示该方法会消耗数据结构。</li>
</ul>
<h2 id="chapter_1-item2-use-types-2-抽象行为"><a class="header" href="#chapter_1-item2-use-types-2-抽象行为">抽象行为</a></h2>
<p>调用方法总是会导致相同的代码被执行；从一次调用到下一次调用所改变的一切就是方法操作的数据。这涵盖了许多可能的情况，但是如果在运行时需要代码发生变化呢？</p>
<p>Rust 在其类型系统中包括了几个特性来适应这种情况，本节将探讨这些特性。</p>
<h3 id="chapter_1-item2-use-types-2-函数指针"><a class="header" href="#chapter_1-item2-use-types-2-函数指针">函数指针</a></h3>
<p>最简单的行为抽象是<a href="https://doc.rust-lang.org/std/primitive.fn.html">函数指针</a>：一个仅指向某些代码的指针，其类型反映了函数的签名。类型在编译时进行检查，所以到程序运行时，这个值只是指针的大小。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum(x: i32, y: i32) -&gt; i32 {
    x + y
}
// Explicit coercion to `fn` type is required...
let op: fn(i32, i32) -&gt; i32 = sum;
<span class="boring">}</span></code></pre></pre>
<p>函数指针没有与之关联的其他数据，因此，可以以各种方式将它们视为值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `fn` types implement `Copy`
let op1 = op;
let op2 = op;
// `fn` types implement `Eq`
assert!(op1 == op2);
// `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.
println!("op = {:p}", op);
// Example output: "op = 0x101e9aeb0"
<span class="boring">}</span></code></pre></pre>
<div class="ferris-border">
<blockquote>
<p>一个需要注意的技术细节：需要显式地将函数强制转换为 <code>fn</code> 类型，因为仅仅使用函数的名称并不能得到 <code>fn</code> 类型的值；</p>
</blockquote>
<p>这段代码无法编译！</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let op1 = sum;
let op2 = sum;
// Both op1 and op2 are of a type that cannot be named in user code,
// and this internal type does not implement `Eq`.
assert!(op1 == op2);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0369]: binary operation `==` cannot be applied to type `fn(i32, i32) -&gt; i32 {main::sum}`
   --&gt; use-types-behaviour/src/main.rs:117:21
    |
117 |         assert!(op1 == op2);
    |                 --- ^^ --- fn(i32, i32) -&gt; i32 {main::sum}
    |                 |
    |                 fn(i32, i32) -&gt; i32 {main::sum}
    |
help: you might have forgotten to call this function
    |
117 |         assert!(op1( /* arguments */ ) == op2);
    |                    +++++++++++++++++++
help: you might have forgotten to call this function
    |
117 |         assert!(op1 == op2( /* arguments */ ));
    |                           +++++++++++++++++++

<span class="boring">}</span></code></pre></pre>
<p>相反，编译器错误表明类型类似于 <code>fn(i32, i32) -&gt; i32 {main::sum}</code>，这是一种完全内部于编译器的类型（即不能在用户代码中编写），它同时标识了特定的函数及其签名。</p>
<p>换句话说，<code>sum</code> 的类型既编码了函数的签名又编码了其位置（出于优化原因）；这种类型可以自动强制转换为 <code>fn</code> 类型（<a href="#chapter_1-item6-newtype">第6条</a>）。</p>
</div>
<h3 id="chapter_1-item2-use-types-2-闭包"><a class="header" href="#chapter_1-item2-use-types-2-闭包">闭包</a></h3>
<p>裸函数指针的使用是有限的，因为被调用函数唯一可以使用的输入是那些明确作为参数值传递的内容。</p>
<p>例如，考虑一些使用函数指针修改切片中每个元素的代码。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In real code, an `Iterator` method would be more appropriate.
pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
    for value in data {
        *value = mutator(*value);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这对于对切片进行简单的修改是有效的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add2(v: u32) -&gt; u32 {
    v + 2
}
let mut data = vec![1, 2, 3];
modify_all(&amp;mut data, add2);
assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<p>然而，如果修改依赖于任何额外的状态，那么无法隐式地将这些状态传递给函数指针。</p>
<p>这段代码无法编译！</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount_to_add = 3;
fn add_n(v: u32) -&gt; u32 {
    v + amount_to_add
}
let mut data = vec![1, 2, 3];
modify_all(&amp;mut data, add_n);
assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0434]: can't capture dynamic environment in a fn item
   --&gt; use-types-behaviour/src/main.rs:142:17
    |
142 |             v + amount_to_add
    |                 ^^^^^^^^^^^^^
    |
    = help: use the `|| { ... }` closure form instead
<span class="boring">}</span></code></pre></pre>
<p>错误信息指向了正确的工具：闭包。闭包是一段看起来像函数定义体（<code>lambda</code> 表达式）的代码，不同之处在于：</p>
<ul>
<li>它可以作为表达式的一部分构建，因此，不需要与一个名称相关联</li>
<li>输入参数以竖线 <code>|param1, param2|</code> 给出（它们的关联类型通常可以由编译器自动推导）</li>
<li>它可以捕获其周围环境的一部分。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount_to_add = 3;
let add_n = |y| {
    // a closure capturing `amount_to_add`
    y + amount_to_add
};
let z = add_n(5);
assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>为了（大致）理解捕获是如何工作的，可以想象编译器创建了一个一次性的、内部的类型，它包含了 <code>lambda</code> 表达式中提到的环境所有部分。当闭包被创建时，这个临时类型的一个实例被创建来保存相关的值，当闭包被调用时，这个实例被用作额外的上下文。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount_to_add = 3;
// *Rough* equivalent to a capturing closure.
struct InternalContext&lt;'a&gt; {
    // references to captured variables
    amount_to_add: &amp;'a u32,
}
impl&lt;'a&gt; InternalContext&lt;'a&gt; {
    fn internal_op(&amp;self, y: u32) -&gt; u32 {
        // body of the lambda expression
        y + *self.amount_to_add
    }
}
let add_n = InternalContext {
    amount_to_add: &amp;amount_to_add,
};
let z = add_n.internal_op(5);
assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>在这个概念性的上下文中持有的值通常是引用（<a href="#chapter_1-item9-iterators">第9条</a>），就像这里的例子，但它们也可以是环境中事物的可变引用，或者是通过在输入参数前使用 <code>move</code> 关键字而从环境中完全移出的值。</p>
<p>回到 <code>modify_all</code> 的例子，闭包不能用在期望函数指针的地方。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
   --&gt; use-types-behaviour/src/main.rs:165:31
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                               ^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found closure
    |
    = note: expected fn pointer `fn(u32) -&gt; u32`
                  found closure `[closure@use-types-behaviour/src/main.rs:165:31: 165:52]`
note: closures can only be coerced to `fn` types if they do not capture any variables
   --&gt; use-types-behaviour/src/main.rs:165:39
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                                       ^^^^^^^^^^^^^ `amount_to_add` captured here
<span class="boring">}</span></code></pre></pre>
<p>相反，接收闭包的代码必须接受一个实现了 <code>Fn*</code> 特征的实例。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn modify_all&lt;F&gt;(data: &amp;mut [u32], mut mutator: F)
where
    F: FnMut(u32) -&gt; u32,
{
    for value in data {
        *value = mutator(*value);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 有三种不同的 <code>Fn*</code> 特征，它们之间表达了关于环境捕获行为的一些区别。</p>
<ul>
<li><code>FnOnce</code> 描述了一个只能被调用一次的闭包。如果闭包的环境中有部分被移动到闭包内，那么这种移动只能发生一次 —— 因为源项没有其他副本可以移动 —— 因此，闭包只能被调用一次。</li>
<li><code>FnMut</code> 描述了一个可以被多次调用的闭包，它能够改变其环境，因为它会可变地借用环境。</li>
<li><code>Fn</code> 描述了一个可以被多次调用的闭包，它只从环境中不可变地借用值。</li>
</ul>
<p>编译器会为代码中的任何 <code>lambda</code> 表达式自动实现这些 <code>Fn*</code> 特征的适当子集；不可能手动实现这些特征中的任何一个<sup class="footnote-reference"><a href="#chapter_1-item2-use-types-2-1">1</a></sup>（与 <code>C++</code> 的 <code>operator()</code> 重载不同）。</p>
<p>回到上面关于闭包的粗略心理模型，编译器自动实现的特征大致对应于捕获的环境上下文是否具有：</p>
<ul>
<li><code>FnOnce</code>: 任何被移动的值</li>
<li><code>FnMut</code>: 任何对值的可变引用（<code>&amp;mut T</code>）</li>
<li><code>Fn</code>: 只是对值的普通引用（<code>&amp;T</code>）。</li>
</ul>
<p>上面列表中的后两个特征各自具有前一个特征的特征约束，当你考虑使用闭包时，这是有意义的。</p>
<ul>
<li>如果某事物只期望调用一次闭包（通过接收 <code>FnOnce</code> 表示），那么传递给它一个能够被多次调用的闭包（<code>FnMut</code>）是可以的。</li>
<li>如果某事物期望重复调用一个可能改变其环境的闭包（通过接收 <code>FnMut</code> 表示），那么传递给它一个不需要改变其环境的闭包（<code>Fn</code>）是可以的。</li>
</ul>
<p>裸函数指针类型 <code>fn</code> 也名义上属于这个列表的末尾；任何（非不安全的）<code>fn</code> 类型自动实现所有 <code>Fn*</code> 特征，因为它不借用任何环境。</p>
<p>因此，在编写接受闭包的代码时，<strong>使用最通用的 <code>Fn*</code> 特征，以允许调用者最大的灵活性</strong> —— 例如，对于只使用一次的闭包，接受 <code>FnOnce</code>。同样的推理也导致了<strong>建议优先使用 <code>Fn*</code> 特征约束而不是裸函数指针（<code>fn</code>）</strong>。</p>
<h3 id="chapter_1-item2-use-types-2-特征traits"><a class="header" href="#chapter_1-item2-use-types-2-特征traits">特征（<code>Traits</code>）</a></h3>
<p><code>Fn*</code> 特征比裸函数指针更灵活，但它们仍然只能描述单个函数的行为，并且只能在函数签名的基础上描述。
然而，它们本身就是 Rust 类型系统中描述行为的另一种机制的例子，即特征。特征定义了一组相关的方法，这些方法由一些底层项公开提供。特征中的每个方法也有一个名称，这允许编译器区分具有相同签名的方法，更重要的是，它允许程序员推断方法的目的。</p>
<p>Rust 的特征大致类似于 Go 和 Java 中的“接口”，或者 C++ 中的“抽象类”（所有虚拟方法，没有数据成员）。特征的实施必须提供所有方法（但请注意特征定义可以包括默认实现，<a href="#chapter_1-chapter_2-item13-use-default-impl">第13条</a>），并且还可以有相关联的数据，那些实现会使用这些数据。这意味着代码和数据在共同的抽象中以某种面向对象的方式一起封装。</p>
<p>接受结构体并调用其方法的代码被限制只能与特定类型一起工作。如果有多个类型实现了公共行为，那么定义一个特征来封装这种行为，并让代码使用特征的方法而不是特定结构体的方法会更加灵活。</p>
<p>这导致了与其他受面向对象<sup class="footnote-reference"><a href="#chapter_1-item2-use-types-2-2">2</a></sup>影响的语言相同的建议：<strong>如果预期未来需要灵活性，请优先接受特征类型而不是具体类型</strong>。</p>
<p>有时，你希望在某些行为中使用类型系统来区分，但这些行为无法表达为特征定义中的特定方法签名。例如，考虑一个用于排序集合的特征；一个实现可能是稳定的（比较相同的元素在排序前后的顺序不变），但没有办法在排序方法参数中表达这一点。</p>
<p>在这种情况下，使用标记特征（<code>marker trait</code>）在类型系统中跟踪这个要求仍然是值得的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sort {
    /// Re-arrange contents into sorted order.
    fn sort(&amp;mut self);
}

/// Marker trait to indicate that a [`Sortable`] sorts stably.
pub trait StableSort: Sort {}
<span class="boring">}</span></code></pre></pre>
<p>标记特征（<code>marker trait</code>）没有方法，但实现仍然需要声明它正在实现该特征 —— 这被视为实现者的承诺：“我庄严宣誓，我的实现在稳定排序。”依赖于稳定排序的代码可以指定 <code>StableSort</code> 特征约束，依赖荣誉制度来保持其不变量。<strong>使用标记特征来区分无法在特征方法签名中表达的行为</strong>。</p>
<p>一旦行为被封装到 Rust 的类型系统中作为一个特征，它可以以两种方式被使用：</p>
<ul>
<li>作为特征约束（<code>trait bound</code>），它在编译时限制了哪些类型可以接受一个泛型数据类型或方法，或者</li>
<li>作为特征对象（<code>trait object</code>），它在运行时限制了哪些类型可以存储或传递给一个方法。
<a href="#chapter_1-chapter_2-item12-generics&amp;trait-objects">第12条</a> 更详细地讨论了这两种方式的权衡。</li>
</ul>
<p>特征约束表明，当某个类型 <code>T</code> 实现了某个特定特征时，参数化为该类型 <code>T</code> 的泛型代码才能被使用。特征约束的存在意味着泛型的实现可以使用来自该特征的方法，确信编译器将确保任何可以编译的 <code>T</code> 确实具有那些方法。这种检查发生在编译时，当泛型被单态化（Rust 对 C++ 中所谓的“模板实例化”的术语）。</p>
<p>对目标类型 <code>T</code> 的这种限制是明确的，编码在特征约束中：只有满足特征约束的类型才能实现该特征。这与 C++ 中的等价情况形成对比，在 C++ 中，<code>template&lt;typename T&gt;</code> 中使用的类型 <code>T</code> 的约束是隐式的<sup class="footnote-reference"><a href="#chapter_1-item2-use-types-2-3">3</a></sup>：C++ 模板代码仍然只有在所有引用的方法在编译时都可用时才会编译，但检查纯粹基于方法和签名。（这种“<a href="https://en.wikipedia.org/wiki/Duck_typing">鸭子类型</a>”可能导致混淆；一个使用 <code>t.pop()</code> 的 C++ 模板可能为 <code>Stack</code> 或 <code>Balloon</code> 的 <code>T</code> 类型参数编译 —— 这不太可能是期望的行为。）</p>
<p>对显式特征约束的需求也意味着大部分泛型使用特征约束。要了解为什么会这样，反过来考虑一下在没有 <code>T</code> 的特征约束的情况下 <code>struct Thing&lt;T&gt;</code> 可以做什么。没有特征约束，<code>Thing</code> 只能执行适用于任何类型 <code>T</code> 的操作；这允许<code>容器</code>、<code>集合</code>和<code>智能指针</code>，但除此之外并不多。任何使用类型 <code>T</code> 的东西都需要一个特征约束。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dump_sorted&lt;T&gt;(mut collection: T)
where
    T: Sort + IntoIterator,
    T::Item: Debug,
{
    // Next line requires `T: Sort` trait bound.
    collection.sort();
    // Next line requires `T: IntoIterator` trait bound.
    for item in collection {
        // Next line requires `T::Item : Debug` trait bound
        println!("{:?}", item);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，这里的建议是使用特征约束来表达对泛型中使用的类型的要求，但这很容易遵循 —— 编译器将迫使你遵守它。</p>
<p>特征对象是利用特征定义的封装的另一种方式，但在这里，不同的特征实现是在运行时而不是编译时选择的。这种动态分派类似于 C++ 中虚拟函数的使用，在底层，Rust 有 '<code>vtable</code>' 对象，它们与 C++ 中的类似。</p>
<p>特征对象的这种动态方面也意味着它们必须始终通过间接方式处理，通过引用（<code>&amp;dyn Trait</code>）或指针（<code>Box&lt;dyn Trait&gt;</code>）。这是因为实现特征的对象大小在编译时是未知的 —— 它可能是一个巨大的结构体或一个微小的枚举 —— 因此无法为裸特征对象分配正确数量的空间。</p>
<p>类似的问题意味着用作特征对象的特征不能有返回 <code>Self</code> 类型的方法，因为预先编译的代码使用特征对象时将无法知道 <code>Self</code> 可能有多大。</p>
<p>具有泛型方法 <code>fn method&lt;T&gt;(t:T)</code> 的特征允许存在无限数量的实现方法，适用于所有可能存在的不同类型 <code>T</code>。这对于用作特征约束的特征来说是可行的，因为无限集合的可能的泛型方法在编译时变为有限的实际调用的泛型方法集合。对于特征对象来说，情况并非如此：编译时可用的代码必须应对运行时可能出现的所有可能的 <code>Ts</code>。（因此trait中不能添加泛型方法，尽管有约束，可以满足约束的类型永远会是无数个）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait foo {
    fn method&lt;T&gt;(&amp;self, t: T);
}

struct Bar;

impl Bar {
    fn new() -&gt; Self {
        Self {}
    }
}

impl foo for Bar {
    fn method&lt;T&gt;(&amp;self, t: T) {
        println!("Bar impl trait foo!");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::hash_map::VacantEntry;

    #[test]
    fn as_trait_bound() {
        let bar = Bar::new();
        bar.method(0u8);
    }

    #[test]
    fn as_trait_obj() {
        let bar = Bar::new();
        let mut v: Vec&lt;&amp;dyn foo&gt; = vec![];
        v.push(&amp;bar);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>fn as_trait_bound() 测试可以通过，没有错误。但是as_trait_obj()会报错：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0038]: the trait `foo` cannot be made into an object
  --&gt; src/lib.rs:33:20
   |
33 |         let mut v: Vec&lt;&amp;dyn foo&gt; = vec![];
   |                    ^^^^^^^^^^^^^ `foo` cannot be made into an object
   |
note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;
  --&gt; src/lib.rs:2:8
   |
1  | trait foo {
   |       --- this trait cannot be made into an object...
2  |     fn method&lt;T&gt;(&amp;self, t: T);
   |        ^^^^^^ ...because method `method` has generic type parameters
   = help: consider moving `method` to another trait
   = help: only type `Bar` implements the trait, consider using it directly instead
<span class="boring">}</span></code></pre></pre>
<p>这两个限制 —— 不能返回 <code>Self</code> 和不能有泛型方法 —— 结合成了对象安全的概念。只有对象安全的特征才能用作特征对象。</p>
<hr />
<h4 id="chapter_1-item2-use-types-2-注释"><a class="header" href="#chapter_1-item2-use-types-2-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item2-use-types-2-1"><sup class="footnote-definition-label">1</sup>
<p>至少，在撰写本文时的稳定 Rust 中是这样。实验性功能 <code>unboxed_closures</code> 和 <code>fn_traits</code> 可能在未来改变这一点。</p>
</div>
<div class="footnote-definition" id="chapter_1-item2-use-types-2-2"><sup class="footnote-definition-label">2</sup>
<p>例如，Effective Java 第64条：通过它们的接口引用对象</p>
</div>
<div class="footnote-definition" id="chapter_1-item2-use-types-2-3"><sup class="footnote-definition-label">3</sup>
<p>C++20 中添加的概念允许对模板类型上的约束进行显式指定，但检查仍然只在模板实例化时执行，而不是在声明时执行。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item3-transform"></div><h1 id="chapter_1-item3-transform-第-3-条避免匹配-option-和-result"><a class="header" href="#chapter_1-item3-transform-第-3-条避免匹配-option-和-result">第 3 条：避免匹配 Option 和 Result</a></h1>
<p><a href="#chapter_1-item1-use-types">第1条</a> 阐述了枚举（<code>enum</code>）的优点，并展示了 <code>match</code> 表达式如何强制程序员考虑所有可能性；这个方法探讨了在某些情况下，你应尽量避免使用 <code>match</code> 表达式 —— 至少是显式地。</p>
<p><a href="#chapter_1-item1-use-types">第1条</a> 还介绍了 Rust 标准库提供的两个无处不在的枚举：</p>
<ul>
<li><code>Option&lt;T&gt;</code>，表示一个值（类型为 <code>T</code>）可能存在也可能不存在。</li>
<li><code>Result&lt;T, E&gt;</code>，用于当尝试返回一个值（类型为 <code>T</code>）的操作可能失败，并可能返回一个错误（类型为 <code>E</code>）。</li>
</ul>
<p>对于这些特定的枚举，显式使用 <code>match</code> 通常会导致代码比实际需要的不够紧凑，而且不符合 Rust 的习惯用法。</p>
<p>第一种不需要使用 <code>match</code> 的情况是，当只关心值本身，而值的缺失（以及任何相关的错误）可以被忽略时。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    field: Option&lt;i32&gt;,
}

let s = S { field: Some(42) };
match &amp;s.field {
    Some(i) =&gt; println!("field is {}", i),
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>对于这种情况，使用 <code>if let</code> 表达式可以缩短一行代码，而且更重要的是，它的表达更清晰：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(i) = &amp;s.field {
    println!("field is {}", i);
}
<span class="boring">}</span></code></pre></pre>
<p>然而，大多数时候，值的缺失以及相关的错误是程序员必须处理的问题。设计软件以应对失败路径是困难的，大多数情况下这是无法通过语法支持减少的固有复杂性 —— 特别是，决定如果操作失败应该发生什么。</p>
<p>在某些情况下，正确的决定是执行一种鸵鸟策略，明确不处理失败。如果使用显式的 <code>match</code> 来这样做，会显得不必要的冗长：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::File::open("/etc/passwd");
let f = match result {
    Ok(f) =&gt; f,
    Err(_e) =&gt; panic!("Failed to open /etc/passwd!"),
};
<span class="boring">}</span></code></pre></pre>
<p>尽管如此，要明确一点：这些辅助函数仍然会引发 <code>panic!</code>，所以选择使用它们与选择直接 <code>panic!</code>（<a href="https://www.lurklurk.org/effective-rust/panic.html">第18条</a>）是一样的。</p>
<p>然而，在许多情况下，正确的错误处理决策是将决策推迟给其他人。这在编写库时尤其正确，因为库的代码可能会在库作者无法预见的各种不同环境中使用。为了使其他人的工作更容易，即使这可能涉及不同错误类型之间的转换（<a href="#chapter_1-item4-errors">第4条</a>），也更倾向于使用 <code>Result</code> 而不是 <code>Option</code>。</p>
<p><code>Result</code> 也有一个 <code>[#must_use]</code> 属性，用来引导库用户朝着正确的方向前进 —— 如果使用返回的 <code>Result</code> 的代码忽略了它，编译器将生成一个警告：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>warning: unused `Result` that must be used
  --&gt; transform/src/main.rs:32:5
   |
32 |     f.set_len(0); // Truncate the file
   |     ^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

<span class="boring">}</span></code></pre></pre>
<p>显式使用 <code>match</code> 可以让错误传播，但代价是增加了一些可见的样板代码（让人联想到 <code>Go 语言</code>）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
    let f = match std::fs::File::open("/etc/passwd") {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>减少样板代码的关键是 Rust 的问号运算符 <code>?</code>。这个语法糖可以处理匹配 <code>Err</code> 分支和返回 <code>Err(...)</code> 表达式，只用一个字符就完成了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
    let f = std::fs::File::open("/etc/passwd")?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 新手有时会对此感到困惑：问号运算符在一开始很难被注意到，导致人们怀疑这段代码怎么可能正常工作。然而，即使只有一个字符，类型系统仍然在起作用，确保覆盖了相关类型（<a href="#chapter_1-item1-use-types">第1条</a>）表达的所有可能性——让程序员可以专注于主线代码路径，不受干扰。</p>
<p>更重要的是，这些明显的方法调用通常没有额外的成本：它们都是标记为 <code>#[inline]</code> 的泛型函数，所以生成的代码通常会编译成与手动版本相同的机器代码。</p>
<p>这两个因素结合起来意味着你应该优先使用 <code>Option</code> 和 <code>Result</code> 转换，而不是显式的 <code>match</code> 表达式。</p>
<p>在之前的例子中，错误类型是一致的：内部和外部方法都使用 <code>std::io::Error</code> 表达错误。然而，情况往往并非如此；一个函数可能从各种不同的子库中累积错误，每个子库都使用不同的错误类型。</p>
<p>关于错误映射的讨论一般见<a href="#chapter_1-item4-errors">第4条</a>；现在，只需知道一个手动映射：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
    let f = match std::fs::File::open("/etc/passwd") {
        Ok(f) =&gt; f,
        Err(e) =&gt; {
            return Err(format!("Failed to open password file: {:?}", e))
        }
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>可以使用更简洁、更符合 Rust 语法的 <code>.map_err()</code> 转换来表达：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
    let f = std::fs::File::open("/etc/passwd")
        .map_err(|e| format!("Failed to open password file: {:?}", e))?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>更好的是，甚至这可能也不必要 —— 如果外部错误类型可以通过实现标准特征 <code>From</code>（<a href="#chapter_1-item5-casts">第5条</a>）从内部错误类型创建，那么编译器将自动执行转换，无需调用 <code>.map_err()</code>。</p>
<p>这类转换具有更广泛的通用性。问号运算符是一个强大的工具；使用 <code>Option</code> 和 <code>Result</code> 类型上的转换方法将它们调整到可以顺利处理的形态。</p>
<p>标准库提供了各种各样的转换方法来实现这一点，如下面的地图所示。根据<a href="https://www.lurklurk.org/effective-rust/panic.html">第18条</a>，可能引发 <code>panic!</code> 的方法用红色突出显示。</p>
<p><img src="chapter_1/../images/transform.svg" alt="转换方法" /></p>
<p>（此图的<a href="https://tinyurl.com/rust-transform">在线版本</a>可点击：每个框都会链接到相关文档。）</p>
<p>图中未涵盖的一种常见情况是处理引用。例如，考虑一个可能包含一些数据的结构。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InputData {
    payload: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这个结构上的一个方法尝试将有效载荷传递给一个加密函数，该函数的签名是 <code>(&amp;[u8]) -&gt; Vec&lt;u8&gt;</code>，如果简单地尝试获取一个引用，则会失败：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl InputData {
    pub fn encrypted(&amp;self) -&gt; Vec&lt;u8&gt; {
        encrypt(&amp;self.payload.unwrap_or(vec![]))
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0507]: cannot move out of `self.payload` which is behind a shared reference
  --&gt; transform/src/main.rs:62:22
   |
62 |             encrypt(&amp;self.payload.unwrap_or(vec![]))
   |                      ^^^^^^^^^^^^ move occurs because `self.payload` has type `Option&lt;Vec&lt;u8&gt;&gt;`, which does not implement the `Copy` trait
   |
help: consider borrowing the `Option`'s content
   |
62 |             encrypt(&amp;self.payload.as_ref().unwrap_or(vec![]))
   |                                  +++++++++
<span class="boring">}</span></code></pre></pre>
<p>错误消息准确地描述了使代码工作所需的内容，即 <code>Option</code> 上的 <code>as_ref()</code> 方法<sup class="footnote-reference"><a href="#chapter_1-item3-transform-1">1</a></sup>。这个方法将一个对 <code>Option</code> 的引用转换为对引用的 <code>Option</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn encrypted(&amp;self) -&gt; Vec&lt;u8&gt; {
    encrypt(self.payload.as_ref().unwrap_or(&amp;vec![]))
}
<span class="boring">}</span></code></pre></pre>
<p>总结一下：</p>
<ul>
<li>习惯使用 <code>Option</code> 和 <code>Result</code> 的转换，并且优先使用 <code>Result</code> 而不是 <code>Option</code>。</li>
<li>在转换涉及引用时，根据需要使用 <code>.as_ref()</code>。</li>
<li>在可能的情况下，优先使用它们而不是显式的 <code>match</code> 操作。</li>
<li>特别是，使用它们将结果类型转换成可以使用 <code>?</code> 运算符的形式。</li>
</ul>
<hr />
<h4 id="chapter_1-item3-transform-注释"><a class="header" href="#chapter_1-item3-transform-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item3-transform-1"><sup class="footnote-definition-label">1</sup>
<p>注意，这个方法与 <code>AsRef</code> 特征是分开的，尽管方法名称相同。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/transform.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item4-errors"></div><h1 id="chapter_1-item4-errors-第-4-条优先使用惯用的错误类型"><a class="header" href="#chapter_1-item4-errors-第-4-条优先使用惯用的错误类型">第 4 条：优先使用惯用的错误类型</a></h1>
<p><a href="#chapter_1-item3-transform">第 3 条</a>描述了如何使用标准库为 <code>Option</code> 和 <code>Result</code> 类型提供的转换，以允许使用 <code>?</code> 运算符简洁、惯用地处理结果类型。但它没有讨论如何最好地处理作为 <code>Result&lt;T, E&gt;</code> 第二个类型参数出现的各种不同的错误类型 <code>E</code>；这就是本章节的内容。</p>
<p>只有当有多种不同的错误类型时，这才有相关性。如果函数遇到的所有不同错误已经是同一类型，它可以只返回该类型。当有不同类型的错误时，需要做出一个决定，即是否保留子错误类型信息。</p>
<h2 id="chapter_1-item4-errors-错误特征error-trait"><a class="header" href="#chapter_1-item4-errors-错误特征error-trait">错误特征（Error Trait）</a></h2>
<p>了解标准特征（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>）总是一个好主意，这里相关的特征是 <code>std::error::Error</code>。<code>Result</code> 的 <code>E</code> 类型参数不必是实现 <code>Error</code> 的类型，但这是一个常见的约定，它允许包装器表达适当的特征约束 —— 因此，最好为您的错误类型实现 <code>Error</code>。</p>
<p>首先要注意的是，对于错误类型，唯一硬性要求是特征约束：实现 <code>Error</code> 的任何类型也必须实现以下特征：</p>
<ul>
<li>
<p><code>Display</code> 特征，意味着可以使用 <code>{}</code> 进行格式化</p>
</li>
<li>
<p><code>Debug</code> 特征，意味着可以使用 <code>{:?}</code> 进行格式化</p>
</li>
</ul>
<p>换句话说，应该能够将错误类型显示给用户和程序员。</p>
<p>特征中唯一的方法是 <code>source()</code>，<sup class="footnote-reference"><a href="#chapter_1-item4-errors-1">1</a></sup> 它允许错误类型公开一个内部的、嵌套的错误。此方法是可选的 —— 它带有一个返回 <code>None</code> 的默认实现（<a href="#chapter_1-chapter_2-item13-use-default-impl">第 13 条</a>），表示内部错误信息不可用。
最后要注意的一点是：如果您正在为 <code>no_std</code> 环境（<a href="https://www.lurklurk.org/effective-rust/no-std.html">第 33 条</a>）编写代码，可能无法实现 <code>Error</code> —— <code>Error</code> 特征目前在 <code>std</code> 中实现，而不是 <code>core</code>，因此不可用。<sup class="footnote-reference"><a href="#chapter_1-item4-errors-2">2</a></sup></p>
<h2 id="chapter_1-item4-errors-最小错误minimal-errors"><a class="header" href="#chapter_1-item4-errors-最小错误minimal-errors">最小错误（Minimal Errors）</a></h2>
<p>如果不需要嵌套错误信息，那么错误类型的实现不必比 <code>String</code> 复杂多少 —— 这是一个“字符串类型”的变量可能合适的罕见情况。但它需要比 <code>String</code> 多一点；虽然可以使用 <code>String</code> 作为 <code>E</code> 类型参数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
    let f = std::fs::File::open("/etc/passwd")
        .map_err(|e| format!("Failed to open password file: {:?}", e))?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>一个 <code>String</code> 并不实现 <code>Error</code>，我们希望是这样，以便代码的其他部分可以处理 <code>Errors</code>。为 <code>String</code> 实现 <code>Error</code> 是不可能的，因为特征（<code>trait</code>）和类型都不属于我们（所谓的孤儿规则）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::error::Error for String {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
  --&gt; src/main.rs:18:5
   |
18 |     impl std::error::Error for String {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
<span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/reference/items/type-aliases.html">类型别名</a>也无济于事，因为它并没有创建一个新的类型，所以也不会改变错误信息：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type MyError = String;

impl std::error::Error for MyError {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
  --&gt; src/main.rs:41:5
   |
41 |     impl std::error::Error for MyError {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^-------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
<span class="boring">}</span></code></pre></pre>
<p>像往常一样，编译器错误消息为解决问题提供了一个线索。定义一个包装 <code>String</code> 类型的元组结构体（"新类型模式"，<a href="#chapter_1-item6-newtype">第 6 条</a>）允许实现 <code>Error</code> 特征，前提是也实现了 <code>Debug</code> 和 <code>Display</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct MyError(String);

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for MyError {}

pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, MyError&gt; {
    let f = std::fs::File::open("/etc/passwd").map_err(|e| {
        MyError(format!("Failed to open password file: {:?}", e))
    })?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>为了方便起见，实现 <code>From&lt;String&gt;</code> 特征可能是有意义的，以便可以轻松地将字符串值转换为 <code>MyError</code> 实例（<a href="#chapter_1-item5-casts">第 5 条</a>）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;String&gt; for MyError {
    fn from(msg: String) -&gt; Self {
        Self(msg)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当编译器遇到问号运算符（<code>?</code>）时，它会自动应用任何需要的 <code>From</code> 特征实现，以便达到目标错误返回类型。这允许进一步的最小化：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, MyError&gt; {
    let f = std::fs::File::open("/etc/passwd")
        .map_err(|e| format!("Failed to open password file: {:?}", e))?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>这里的错误路径涵盖了以下步骤：</p>
<ul>
<li><code>File::open</code> 返回一个类型为 <code>std::io::Error</code> 的错误。</li>
<li><code>format!</code> 使用 <code>std::io::Error</code> 的 <code>Debug</code> 实现将其转换为 <code>String</code>。</li>
<li><code>?</code> 使编译器寻找并使用一个 <code>From</code> 实现，该实现可以将它从 <code>String</code> 转换为 <code>MyError</code>。</li>
</ul>
<h2 id="chapter_1-item4-errors-嵌套错误"><a class="header" href="#chapter_1-item4-errors-嵌套错误">嵌套错误</a></h2>
<p>另一种情况是，嵌套错误的内容重要到足以需要被保留并供调用者使用。</p>
<p>考虑一个库函数，它尝试返回文件的第一行作为字符串，只要这一行不是太长。稍微思考一下就会发现（至少）三种可能发生的不同类型的失败：</p>
<ul>
<li>文件可能不存在或者无法读取。</li>
<li>文件可能包含不是有效 <code>UTF-8</code> 的数据，因此无法转换为 <code>String</code>。</li>
<li>文件可能有一个过长的一行。</li>
</ul>
<p>根据 <a href="#chapter_1-item1-use-types">第 1 条</a>，您可以使用类型系统来表达并包含所有这些可能性作为一个<code>枚举</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum MyError {
    Io(std::io::Error),
    Utf8(std::string::FromUtf8Error),
    General(String),
}
<span class="boring">}</span></code></pre></pre>
<p>这个<code>枚举</code>定义包括了 <code>derive(Debug)</code>，但为了满足 <code>Error</code> 特征，还需要一个 <code>Display</code> s实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            MyError::Io(e) =&gt; write!(f, "IO error: {}", e),
            MyError::Utf8(e) =&gt; write!(f, "UTF-8 error: {}", e),
            MyError::General(s) =&gt; write!(f, "General error: {}", s),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>为了方便访问嵌套错误，覆盖默认的 <code>source()</code> 实现也是很有意义的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

impl Error for MyError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        match self {
            MyError::Io(e) =&gt; Some(e),
            MyError::Utf8(e) =&gt; Some(e),
            MyError::General(_) =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>使用<code>枚举</code>允许错误处理保持简洁，同时仍然保留不同错误类别的所有类型信息：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::BufRead; // for `.read_until()`

/// Maximum supported line length.
const MAX_LEN: usize = 1024;

/// Return the first line of the given file.
pub fn first_line(filename: &amp;str) -&gt; Result&lt;String, MyError&gt; {
    let file = std::fs::File::open(filename).map_err(MyError::Io)?;
    let mut reader = std::io::BufReader::new(file);

    // (A real implementation could just use `reader.read_line()`)
    let mut buf = vec![];
    let len = reader.read_until(b'\n', &amp;mut buf).map_err(MyError::Io)?;
    let result = String::from_utf8(buf).map_err(MyError::Utf8)?;
    if result.len() &gt; MAX_LEN {
        return Err(MyError::General(format!("Line too long: {}", len)));
    }
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<p>为所有子错误类型实现 <code>From</code> 特征也是一个好主意（<a href="#chapter_1-item5-casts">第 5 条</a>）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;std::io::Error&gt; for MyError {
    fn from(e: std::io::Error) -&gt; Self {
        Self::Io(e)
    }
}
impl From&lt;std::string::FromUtf8Error&gt; for MyError {
    fn from(e: std::string::FromUtf8Error) -&gt; Self {
        Self::Utf8(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这防止了库用户自己受到孤儿规则的影响：他们不允许在 <code>MyError</code> 上实现 <code>From</code>，因为特征和结构体对他们来说是外部的。</p>
<p>更好的是，实现 <code>From</code> 允许更加简洁，因为<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">问号运算符</a>将自动执行任何必要的 <code>From</code> 转换，从而消除了 <code>.map_err()</code> 的需求：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::BufRead; // for `.read_until()`

/// Maximum supported line length.
pub const MAX_LEN: usize = 1024;

/// Return the first line of the given file.
pub fn first_line(filename: &amp;str) -&gt; Result&lt;String, MyError&gt; {
    let file = std::fs::File::open(filename)?; // `From&lt;std::io::Error&gt;`
    let mut reader = std::io::BufReader::new(file);
    let mut buf = vec![];
    let len = reader.read_until(b'\n', &amp;mut buf)?; // `From&lt;std::io::Error&gt;`
    let result = String::from_utf8(buf)?; // `From&lt;string::FromUtf8Error&gt;`
    if result.len() &gt; MAX_LEN {
        return Err(MyError::General(format!("Line too long: {}", len)));
    }
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<p>编写一个完整的错误类型可能涉及相当多的样板代码，这使得它成为通过派生宏（<a href="https://www.lurklurk.org/effective-rust/macros.html">第 28 条</a>）自动化的好候选。然而，没有必要自己编写这样的宏：<strong>考虑使用 <code>David Tolnay</code> 提供的 <a href="https://docs.rs/thiserror">thiserror</a> crate</strong>，它提供了一个高质量、广泛使用的宏实现。<code>thiserror</code> 生成的代码也小心翼翼地避免在生成的 <code>API</code> 中使任何 <code>thiserror</code> 类型可见，这意味着与 <a href="https://www.lurklurk.org/effective-rust/re-export.html">第 24 条</a>相关的问题不适用。</p>
<h2 id="chapter_1-item4-errors-特质对象trait-objects"><a class="header" href="#chapter_1-item4-errors-特质对象trait-objects">特质对象（<code>Trait Objects</code>）</a></h2>
<p>第一种处理嵌套错误的方法丢弃了所有子错误的细节，只保留了某些字符串输出（<code>format!("{:?}", err</code>)）。</p>
<p>第二种方法保留了所有可能子错误的全类型信息，但需要完整枚举所有可能的子错误类型。</p>
<p>这就引出了一个问题，这两种方法之间有没有中间地带，可以在不需要手动包含每个可能的错误类型的情况下保留子错误信息？</p>
<p>将子错误信息编码为 <a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait 对象</a>避免了为每种可能性都有一个<code>枚举</code>变体的需要，但擦除了特定基础错误类型的细节。接收此类对象的调用者将能够访问 <code>Error</code> 特征及其特征约束的方法 —— <code>source()</code>、<code>Display::fmt()</code> 和 <code>Debug::fmt()</code>，依次类推 —— 但不会知道子错误原始的静态类型：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum WrappedError {
    Wrapped(Box&lt;dyn Error&gt;),
    General(String),
}

impl std::fmt::Display for WrappedError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Self::Wrapped(e) =&gt; write!(f, "Inner error: {}", e),
            Self::General(s) =&gt; write!(f, "{}", s),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>结果是这是可能的，但出奇地微妙。部分困难来自于特质对象的客观安全性约束（<a href="#chapter_1-chapter_2-item12-generics&amp;trait-objects">第 12 条</a>），但 <code>Rust</code> 的一致性规则也发挥作用，它们（大致）指出对于一种类型最多只能有一个特征的实现。</p>
<p>一个假设的 <code>WrappedError</code> 类型可能会天真地预期同时实现以下两个：</p>
<ul>
<li><code>Error</code> 特征，因为它本身就是一个错误。</li>
<li><code>From&lt;Error&gt;</code> 特征，以便子错误可以被轻松包装。</li>
</ul>
<p>这意味着可以从一个内部的 <code>WrappedError</code> 创建一个 <code>WrappedError</code>，因为 <code>WrappedError</code> 实现了 <code>Error</code>，并且这与 <code>From</code> 的泛反射实现冲突：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Error for WrappedError {}

impl&lt;E: 'static + Error&gt; From&lt;E&gt; for WrappedError {
    fn from(e: E) -&gt; Self {
        Self::Wrapped(Box::new(e))
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0119]: conflicting implementations of trait `From&lt;WrappedError&gt;` for
              type `WrappedError`
   --&gt; src/main.rs:279:5
    |
279 |     impl&lt;E: 'static + Error&gt; From&lt;E&gt; for WrappedError {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: conflicting implementation in crate `core`:
            - impl&lt;T&gt; From&lt;T&gt; for T;

<span class="boring">}</span></code></pre></pre>
<p><code>David Tolnay</code> 的 <a href="https://docs.rs/anyhow">anyhow</a> 是一个已经解决了这些问题（通过添加一个额外的间接层，<a href="https://github.com/dtolnay/anyhow/issues/63#issuecomment-582079114">通过 Box</a>）并增加了其他有用功能（如堆栈跟踪）的 <code>crate</code>。因此，它迅速成为错误处理的标准化建议 —— 在这里也得到支持：<strong>考虑在应用程序中使用 <code>anyhow</code> crate 进行错误处理。</strong></p>
<h2 id="chapter_1-item4-errors-库与应用程序"><a class="header" href="#chapter_1-item4-errors-库与应用程序">库与应用程序</a></h2>
<p>上一节的最后建议中包含了这样的限定：“……用于应用程序中的错误处理”。这是因为库中编写的代码和构成顶级应用程序的代码之间通常有一个区别。<sup class="footnote-reference"><a href="#chapter_1-item4-errors-3">3</a></sup></p>
<p>为库编写的代码无法预测代码使用的环境，因此最好发出具体、详细的错误信息，让调用者去弄清楚如何使用这些信息。这倾向于前面描述的枚举风格的嵌套错误（并且在库的公共 <code>API</code> 中避免了依赖 <code>anyhow</code>，参见<a href="https://www.lurklurk.org/effective-rust/re-export.html">第 24 条</a>）。</p>
<p>然而，应用程序代码通常需要更多地关注如何向用户呈现错误。它还可能不得不应对其依赖关系图中所有库发出的所有不同错误类型（<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）。因此，一个更动态的错误类型（如 <code>anyhow::Error</code>）使得错误处理在应用程序中更简单、更一致。</p>
<h2 id="chapter_1-item4-errors-需要记住的事情"><a class="header" href="#chapter_1-item4-errors-需要记住的事情">需要记住的事情</a></h2>
<ul>
<li>标准 <code>Error</code> 特征对您的需求很少，因此最好为您的错误类型实现它。</li>
<li>在处理异构的基础错误类型时，决定是否需要保留这些类型。
<ul>
<li>如果不是，考虑在应用程序代码中使用 <code>anyhow</code> 来包装子错误。</li>
<li>如果是，将它们编码在一个<code>枚举</code>中并提供转换。考虑使用 <code>thiserror</code> 来帮助做到这一点。</li>
</ul>
</li>
<li>考虑在应用程序代码中使用 <code>anyhow crate</code> 进行便捷、惯用的错误处理。</li>
<li>决定权在您手中，但无论您决定什么，都要在类型系统中编码它（<a href="#chapter_1-item1-use-types">第 1 条</a>）。</li>
</ul>
<h4 id="chapter_1-item4-errors-注释"><a class="header" href="#chapter_1-item4-errors-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item4-errors-1"><sup class="footnote-definition-label">1</sup>
<p>或者至少是唯一一个非废弃的、稳定的方法。</p>
</div>
<div class="footnote-definition" id="chapter_1-item4-errors-2"><sup class="footnote-definition-label">2</sup>
<p>在撰写本文时，<code>Error</code> 已经<a href="https://github.com/rust-lang/rust/issues/103765">被移动到 <code>core</code></a>，但在稳定版的 <code>Rust</code> 中尚不可用。</p>
</div>
<div class="footnote-definition" id="chapter_1-item4-errors-3"><sup class="footnote-definition-label">3</sup>
<p>本节灵感来源于 <code>Nick Groenen</code> 的文章<a href="https://nick.groenen.me/posts/rust-error-handling/">《Rust: 2020年在错误处理和结构化》</a>。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/errors.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item5-casts"></div><h1 id="chapter_1-item5-casts-第-5-条理解类型转换"><a class="header" href="#chapter_1-item5-casts-第-5-条理解类型转换">第 5 条：理解类型转换</a></h1>
<p>Rust 的类型转换分为三个类别：</p>
<ul>
<li>手动：通过实现 <code>From</code> 和 <code>Into trait</code> 提供的用户定义类型转换</li>
<li>半自动：使用 <code>as</code> 关键字在值之间进行显式转换</li>
<li>自动：隐式强制转换为新类型</li>
</ul>
<p>本章节的重点主要是第一种，即手动转换类型，因为后两种大多数情况下不适用于用户定义类型的转换。但也有一些例外，所以本章节最后的部分将讨论转换和强制类型转换 —— 包括它们如何适用于用户定义的类型。</p>
<p>请注意，与许多较旧的语言不同，<code>Rust</code> 在数值类型之间不会执行自动转换。这甚至适用于整数类型的“安全”转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 2;
let y: u64 = x;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; src/main.rs:70:18
   |
70 |     let y: u64 = x;
   |            ---   ^ expected `u64`, found `u32`
   |            |
   |            expected due to this
   |
help: you can convert a `u32` to a `u64`
   |
70 |     let y: u64 = x.into();
   |                   +++++++

<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_1-item5-casts-用户定义类型转换"><a class="header" href="#chapter_1-item5-casts-用户定义类型转换">用户定义类型转换</a></h2>
<p>与语言的其他特性（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>）一样，在不同用户定义类型值之间执行转换的能力被封装为标准 <code>trait</code> —— 或者更确切地说，是一组相关的泛型 <code>trait</code>。</p>
<p>表达类型值转换能力的四个相关 <code>trait</code> 如下：</p>
<ul>
<li><code>From&lt;T&gt;</code>：这种类型的项可以由类型 <code>T</code> 的项构建，并且转换总是成功。</li>
<li><code>TryFrom&lt;T&gt;</code>：这种类型的项可以由类型 <code>T</code> 的项构建，但转换可能不会成功。</li>
<li><code>Into&lt;T&gt;</code>：这种类型的项可以转换为类型 <code>T</code> 的项，并且转换总是成功。</li>
<li><code>TryInto&lt;T&gt;</code>：这种类型的项可以转换为类型 <code>T</code> 的项，但转换可能不会成功。</li>
</ul>
<p>鉴于<a href="#chapter_1-item1-use-types">第 1 条</a>中关于在类型系统中表达事物的讨论，发现 <code>Try...</code> 变体的区别在于，唯一的 <code>trait</code> 方法返回一个 <code>Result</code> 而不是保证的新项。<code>Try...</code> <code>trait</code> 定义还要求一个关联类型，它给出了失败情况下发出的错误 <code>E</code> 的类型。</p>
<p>因此，第一条建议是，如果可能转换失败，则<strong>实现（仅）<code>Try... trait</code></strong>，与<a href="#chapter_1-item4-errors">第 4 条</a> 一致。另一种方法是<strong>忽略错误的可能性（例如，使用 <code>.unwrap()</code>）</strong>，但这需要是深思熟虑的选择，在大多数情况下，最好将这个选择留给调用者。</p>
<p>类型转换 <code>trait</code> 具有明显的对称性：如果类型 <code>T</code> 可以转换为类型 <code>U</code>（通过 <code>Into&lt;U&gt;</code>），难道这不等于可以通过从类型 <code>T</code> 的项转换来创建类型 <code>U</code> 的项（通过 <code>From&lt;T&gt;</code>）吗？</p>
<p>确实如此，这导致了第二条建议：为转换实现 <code>From trait</code>。<code>Rust</code> 标准库必须在这两个可能性中选择一个，以防止系统在眩晕的圆圈中旋转，<sup class="footnote-reference"><a href="#chapter_1-item5-casts-1">1</a></sup> 它选择了自动提供 <code>From</code> 实现的 <code>Into</code>。</p>
<p>如果你正在使用这两个 <code>trait</code> 中的一个，作为你自己新的泛型的 <code>trait</code> 约束，那么建议是相反的：<strong>对 <code>trait</code> 约束使用 <code>Into trait</code></strong>。这样，约束将同时满足直接实现 <code>Into</code> 的内容和仅直接实现 <code>From</code> 的内容。</p>
<p><code>From</code> 和 <code>Into</code> 的文档强调了这种自动转换，但阅读标准库代码的相关部分也值得一读，这是一个泛型 <code>trait</code> 实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>将 <code>trait</code> 规范翻译成文字可以帮助理解更复杂的 <code>trait</code> 约束。在这个案例中，它相当简单："只要 <code>U</code> 已经实现了 <code>From&lt;T&gt;</code>，我就可以为类型 <code>T</code> 实现 <code>Into&lt;U&gt;</code>"。</p>
<p>标准库还包括了为标准库类型实现这些转换 <code>trait</code> 的各种情况。正如你所预期的，对于整数转换，当目标类型包括源类型的所有可能值时（例如，<code>u64</code> 的 <code>From&lt;u32&gt;</code>），会有 <code>From</code> 实现，而当源值可能不适合目标时（例如，<code>u32</code> 的 <code>TryFrom&lt;u64&gt;</code>），会有 <code>TryFrom</code> 实现。</p>
<p>除了前面显示的 <code>Into</code> 版本的泛型 <code>trait</code> 实现之外，还有各种其他的泛型 <code>trait</code> 实现主要用于智能指针类型，允许智能指针从其持有的类型的实例自动构造。这意味着接受智能指针参数的泛型方法也可以用普通的旧项调用；更多内容将在后续介绍和<a href="#chapter_1-item8-references&amp;pointer">第 8 条</a>中展开。</p>
<p><code>TryFrom trait</code> 还有一个泛型实现，适用于任何已经以相反方向实现 <code>Into trait</code> 的类型 —— 这自动包括了（如先前所示）以相同方向实现 <code>From</code> 的任何类型。换句话说，如果你可以无误地将 <code>T</code> 转换为 <code>U</code>，你也可以尝试从 <code>T</code> 获取 <code>U</code>；由于这个转换总是会成功，关联的错误类型是有帮助地命名为 <code>Infallible</code>。<sup class="footnote-reference"><a href="#chapter_1-item5-casts-2">2</a></sup></p>
<p>还有一个非常特定的泛型 <code>From</code> 实现，即反射实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
<span class="boring">}</span></code></pre></pre>
<p>翻译成文字，这仅仅是在说“给定一个 <code>T</code>，我可以得到一个 <code>T</code>。”这听起来如此显而易见，以至于值得停下来理解为什么这很有用。</p>
<p>考虑一个简单的新类型结构体（<a href="#chapter_1-item6-newtype">第 6 条</a>）和一个对其操作的函数（忽略这个函数最好表示为一个方法）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Integer value from an IANA-controlled range.
#[derive(Clone, Copy, Debug)]
pub struct IanaAllocated(pub u64);

/// Indicate whether value is reserved.
pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
    s.0 == 0 || s.0 == 65535
}
<span class="boring">}</span></code></pre></pre>
<p>这个函数可以使用结构体的实例来调用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = IanaAllocated(1);
println!("{:?} reserved? {}", s, is_iana_reserved(s));
// output: "IanaAllocated(1) reserved? false"
<span class="boring">}</span></code></pre></pre>
<p>但是，即使为新的包装类型实现了 <code>From&lt;u64&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u64&gt; for IanaAllocated {
    fn from(v: u64) -&gt; Self {
        Self(v)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>该函数不能直接为 <code>u64</code> 值调用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if is_iana_reserved(42) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; src/main.rs:77:25
   |
77 |     if is_iana_reserved(42) {
   |        ---------------- ^^ expected `IanaAllocated`, found integer
   |        |
   |        arguments to this function are incorrect
   |
note: function defined here
  --&gt; src/main.rs:7:8
   |
7  | pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
   |        ^^^^^^^^^^^^^^^^ ----------------
help: try wrapping the expression in `IanaAllocated`
   |
77 |     if is_iana_reserved(IanaAllocated(42)) {
   |                         ++++++++++++++  +
<span class="boring">}</span></code></pre></pre>
<p>然而，一个接受（并显式转换）满足 <code>Into&lt;IanaAllocated&gt;</code> 的任何内容的泛型版本的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_iana_reserved&lt;T&gt;(s: T) -&gt; bool
where
    T: Into&lt;IanaAllocated&gt;,
{
    let s = s.into();
    s.0 == 0 || s.0 == 65535
}
<span class="boring">}</span></code></pre></pre>
<p>允许这种用法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if is_iana_reserved(42) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>使用此特性绑定后，<code>From&lt;T&gt;</code> 的反射性特性实现更有意义：这意味着泛型函数可以处理已经是 <code>IanaAllocated</code> 实例的项，无需转换。</p>
<p>这种模式还解释了为什么（以及如何）<code>Rust</code> 代码有时似乎在类型之间进行隐式转换：<code>From&lt;T&gt;</code> 实现与 <code>Into&lt;T&gt;</code> 特性边界的结合导致了在调用站点看似神奇转换的代码（但在幕后仍然进行安全、显式的转换）。当与引用类型及其相关转换特性结合时，这种模式变得更为强大；更多内容见<a href="#chapter_1-item8-references&amp;pointer">第 8 条</a>。</p>
<h2 id="chapter_1-item5-casts-类型转换"><a class="header" href="#chapter_1-item5-casts-类型转换">类型转换</a></h2>
<p><code>Rust</code> 包含 <code>as</code> 关键字以在某些类型对之间执行显式转换。</p>
<p>可以通过这种方式转换的类型对构成了一个相当有限的集合，并且它包括的唯一用户定义类型是“类似 <code>C</code>”的枚举（那些只有相关联的整数值的枚举）。尽管如此，它还是包括了常规整数转换，为 <code>into()</code> 提供了一个替代方案：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 9;
let y = x as u64;
let z: u64 = x.into();
<span class="boring">}</span></code></pre></pre>
<p><code>as</code> 版本还允许进行有损转换：<sup class="footnote-reference"><a href="#chapter_1-item5-casts-3">3</a></sup></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 9;
let y = x as u16;
<span class="boring">}</span></code></pre></pre>
<p>这将会被 <code>from/into</code> 版本拒绝：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0277]: the trait bound `u16: From&lt;u32&gt;` is not satisfied
   --&gt; src/main.rs:136:20
    |
136 |     let y: u16 = x.into();
    |                    ^^^^ the trait `From&lt;u32&gt;` is not implemented for `u16`
    |
    = help: the following other types implement trait `From&lt;T&gt;`:
              &lt;u16 as From&lt;NonZeroU16&gt;&gt;
              &lt;u16 as From&lt;bool&gt;&gt;
              &lt;u16 as From&lt;u8&gt;&gt;
    = note: required for `u32` to implement `Into&lt;u16&gt;`
<span class="boring">}</span></code></pre></pre>
<p>为了保持一致性和安全性，您应该<strong>优先使用 <code>from/into</code> 转换而不是 <code>as</code> 强制转换</strong>，除非您理解并需要精确的强制转换语义（例如，用于 <code>C</code> 语言互操作性）。这个建议可以通过 <code>Clippy</code>（<a href="https://www.lurklurk.org/effective-rust/clippy.html">第 29 条</a>）得到加强，<code>Clippy</code> 包含了关于 <code>as</code> 转换的几个 <code>lint</code>；然而，这些 <code>lint</code> 默认是禁用的。</p>
<h2 id="chapter_1-item5-casts-强制转换"><a class="header" href="#chapter_1-item5-casts-强制转换">强制转换</a></h2>
<p>上一节描述的显式 <code>as</code> 强制转换是编译器会默默执行的隐式强制转换的超集：任何强制转换都可以用显式的 <code>as</code> 来强制执行，但反之则不成立。特别是，上一节执行的整体转换并不是强制转换，因此将始终需要 <code>as</code>。</p>
<p>大多数强制转换涉及指针和引用类型的隐式转换，这些转换对程序员来说是有意义且方便的，例如转换以下内容：</p>
<ul>
<li>可变引用到不可变引用（这样您就可以将 <code>&amp;mut T</code> 作为接受 <code>&amp;T</code> 的函数的参数）</li>
<li>引用到原始指针（这并不不安全 —— 不安全性发生在您足够愚蠢地去解引用一个原始指针的时候）</li>
<li>恰好没有捕获任何变量的闭包到裸函数指针（<a href="#chapter_1-item2-use-types-2">第 2 条</a>）</li>
<li>数组到切片</li>
<li>具体项到特质对象，对于具体项实现的特质</li>
<li>项的生命周期到“更短”的一个（<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>）<sup class="footnote-reference"><a href="#chapter_1-item5-casts-4">4</a></sup></li>
</ul>
<p>只有两种强制转换的行为可能受到用户定义类型的影响。第一种情况是用户定义的类型实现了 <code>Deref</code> 或 <code>DerefMut</code> 特质。这些特质表明用户定义的类型充当某种智能指针（<a href="#chapter_1-item8-references&amp;pointer">第 8 条</a>），在这种情况下，编译器会将智能指针项的引用强制转换为智能指针包含的类型的项的引用（由其 <code>Target</code> 指示）。</p>
<p>用户定义的类型的第二种强制转换发生在具体项转换为特质对象时。这个操作构建了一个指向项的胖指针；这个指针之所以胖，是因为它既包括了指向项在内存中位置的指针，也包括了指向具体类型实现特质的 <code>vtable</code> 的指针 —— 参见<a href="#chapter_1-item8-references&amp;pointer">第 8 条</a>。</p>
<h4 id="chapter_1-item5-casts-注释"><a class="header" href="#chapter_1-item5-casts-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item5-casts-1"><sup class="footnote-definition-label">1</sup>
<p>更准确地称为 <code>trait</code> 一致性规则。</p>
</div>
<div class="footnote-definition" id="chapter_1-item5-casts-2"><sup class="footnote-definition-label">2</sup>
<p>暂时如此 —— 这可能会在未来的 <code>Rust</code> 版本中被 <code>!</code> "<code>never</code>" 类型所取代。</p>
</div>
<div class="footnote-definition" id="chapter_1-item5-casts-3"><sup class="footnote-definition-label">3</sup>
<p>在 Rust 中允许有损转换可能是错误的，已经有过尝试去除这种行为的讨论。</p>
</div>
<div class="footnote-definition" id="chapter_1-item5-casts-4"><sup class="footnote-definition-label">4</sup>
<p><code>Rust</code> 将这些转换称为“子类型化”，但它与面向对象语言中“子类型化”的定义大不相同。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/casts.html">点这里</a></p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item6-newtype"></div><h2 id="chapter_1-item6-newtype-第-6-条拥抱-newtype-模式"><a class="header" href="#chapter_1-item6-newtype-第-6-条拥抱-newtype-模式">第 6 条：拥抱 newtype 模式</a></h2>
<p><a href="#chapter_1-item1-use-types">第 1 条</a>描述了<em>元组结构体</em>，它的字段没有名字，而是通过数字（<code>self.0</code>）来引用。本条着重介绍的是，只包含一个类型的元组结构体。它是一个新的类型，可以包含和内置类型一样的值。在 Rust 中，这个模式非常普遍，它叫做：<em>newtype</em> 模式。</p>
<p>newtype 模式的最简单用法，是在类型原有行为的基础上，提供<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">额外的语义</a>。想象有一个将卫星送往火星的项目。<sup class="footnote-reference"><a href="#chapter_1-item6-newtype-1">1</a></sup>这是一个大项目，不同的团队已经构建了项目的不同部分。其中一个小组负责火箭引擎的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 点燃推进器。返回产生的脉冲，单位为磅/秒。
pub fn thruster_impulse(direction: Direction) -&gt; f64 {
    // ...
    return 42.0;
}
<span class="boring">}</span></code></pre></pre>
<p>另一个团队负责惯性导航系统：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 根据提供的推力（单位：牛顿/秒）更新轨迹模型。
pub fn update_trajectory(force: f64) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>最终，结合这些不同部分：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: f64 = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force);
<span class="boring">}</span></code></pre></pre>
<p>糟糕。<sup class="footnote-reference"><a href="#chapter_1-item6-newtype-2">2</a></sup></p>
<p>Rust 有类型别名的特性，让不同的团队能够更清楚地表达他们的意图：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 推力的单位。
pub type PoundForceSeconds = f64;

/// 点燃推进器。返回产生的脉冲。
pub fn thruster_impulse(direction: Direction) -&gt; PoundForceSeconds {
    // ...
    return 42.0;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 推力的单位。
pub type NewtonSeconds = f64;

/// 更新冲力轨迹模型。
pub fn update_trajectory(force: NewtonSeconds) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>然而，实际上类型别名只是文档：它们比前面的文档注释有更强的提示，但不能阻止 <code>PoundForceSeconds</code> 值被使用在希望使用 <code>NewtonSeconds</code> 值的地方。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: PoundForceSeconds = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force);
<span class="boring">}</span></code></pre></pre>
<p>再次出现问题了。</p>
<p>这就是 newtype 模式能带来帮助的地方</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 推力的单位。
pub struct PoundForceSeconds(pub f64);

/// 点燃推进器。返回产生的脉冲。
pub fn thruster_impulse(direction: Direction) -&gt; PoundForceSeconds {
    // ...
    return PoundForceSeconds(42.0);
}
/// 推力的单位。
pub struct NewtonSeconds(pub f64);

/// 更新冲力轨迹模型。
pub fn update_trajectory(force: NewtonSeconds) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>如名称所示，newtype 是一个新类型。因此，当型不匹配时，编译器会报错。在这里，我们尝试将 <code>PoundForceSeconds</code> 值传递给期望使用 <code>NewtonSeconds</code> 值的地方：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: PoundForceSeconds = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let new_direction = update_trajectory(thruster_force);
error[E0308]: mismatched types
  --&gt; src/main.rs:76:43
   |
76 |     let new_direction = update_trajectory(thruster_force);
   |                         ----------------- ^^^^^^^^^^^^^^ expected
   |                         |        `NewtonSeconds`, found `PoundForceSeconds`
   |                         |
   |                         arguments to this function are incorrect
   |
note: function defined here
  --&gt; src/main.rs:66:8
   |
66 | pub fn update_trajectory(force: NewtonSeconds) {
   |        ^^^^^^^^^^^^^^^^^ --------------------
help: call `Into::into` on this expression to convert `PoundForceSeconds` into
      `NewtonSeconds`
   |
76 |     let new_direction = update_trajectory(thruster_force.into());
   |                                                         +++++++
<span class="boring">}</span></code></pre></pre>
<p>如在<a href="#chapter_1-item5-casts">第 5 条</a>中所述，添加标准库的 <code>From</code> 特性的实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;PoundForceSeconds&gt; for NewtonSeconds {
    fn from(val: PoundForceSeconds) -&gt; NewtonSeconds {
        NewtonSeconds(4.448222 * val.0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这样就能用 <code>.into()</code> 执行单位和类型转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: PoundForceSeconds = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force.into());
<span class="boring">}</span></code></pre></pre>
<p>使用 newtype，除了能附加「单位」语义，还可以使布尔参数更清晰。回顾<a href="#chapter_1-item1-use-types">第 1 条</a>的例子，使用newtype可以清晰地说明参数的含义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DoubleSided(pub bool);

struct ColorOutput(pub bool);

fn print_page(sides: DoubleSided, color: ColorOutput) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_page(DoubleSided(true), ColorOutput(false));
<span class="boring">}</span></code></pre></pre>
<p>如果需要考虑大小或二进制兼容性，那么 <code>#<a href="https://doc.rust-lang.org/reference/type-layout.html#the-transparent-representation">repr(transparent)</a></code> 属性能确保newtype在内存中的表示与内部类型相同。</p>
<p>这个来自<a href="#chapter_1-item1-use-types">第 1 条</a>的例子，是 newtype 的简单用法—将语义编码到类型系统中，以让编译器负责管理这些语义。</p>
<h2 id="chapter_1-item6-newtype-绕过特征的孤儿规则"><a class="header" href="#chapter_1-item6-newtype-绕过特征的孤儿规则">绕过特征的孤儿规则</a></h2>
<p>另一个<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">常见</a>但更巧妙的需要 newtype 模式的场景，是 Rust 的孤儿规则。这个规则意味着，在一个包里，以下条件之一满足时，才能为某个类型实现特性：</p>
<p>• 包定义了该特性<br />
• 包定义了该类型</p>
<p>我们来尝试为一个外部类型实现一个外部特性：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for rand::rngs::StdRng {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        write!(f, "&lt;StdRng instance&gt;")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>编译器会出错（它指出要使用 newtype）：</p>
<pre><code class="language-text">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
   --&gt; src/main.rs:146:1
    |
146 | impl fmt::Display for rand::rngs::StdRng {
    | ^^^^^^^^^^^^^^^^^^^^^^------------------
    | |                     |
    | |                     `StdRng` is not defined in the current crate
    | impl doesn't use only types from inside the current crate
    |
    = note: define and implement a trait or new type instead
</code></pre>
<p>这种限制的原因是可能发生歧义：如果依赖关系图中的两个不同的包（<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）都要实现 <code>impl std::fmt::Display for rand::rngs::StdRng</code>，那么编译器/链接器不知道选择哪个。</p>
<p>这经常会带来挫败：例如，如果你试图序列化包含来自其他包的类型的数据，孤儿规则会阻止你写 <code>impl serde::Serialize for somecrate::SomeType</code>。<sup class="footnote-reference"><a href="#chapter_1-item6-newtype-3">3</a></sup></p>
<p>但是 newtype 模式意味着你定义了一个<em>新</em>类型，这是当前包的一部分，所以就满足了孤儿规则的第二点。现在就能够实现一个外部特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyRng(rand::rngs::StdRng);

impl fmt::Display for MyRng {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        write!(f, "&lt;MyRng instance&gt;")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_1-item6-newtype-newtype-的限制"><a class="header" href="#chapter_1-item6-newtype-newtype-的限制">newtype 的限制</a></h2>
<p>newtype 模式解决了两类问题——阻止类型转换和绕过孤儿原则。但它也有一些不足——每个 newtype 的操作都需要转发到内部类型。</p>
<p>这意味着必须在所有地方都使用 <code>thing.0</code>，而不是使用 <code>thing</code>。不过这很容易做到，而且编译器会告诉你在哪里需要。</p>
<p>比较麻烦的是，内部类型的任何特征实现都会丢失：因为 newtype 是一个新类型，所以现有的内部实现都不适用。</p>
<p>对于能派生的特征，只需要 newtype 的声明上使用 <code>derive</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct NewType(InnerType);
<span class="boring">}</span></code></pre></pre>
<p>然而，对于更复杂的特征，需要一些样板代码来恢复内部类型的实现，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
impl fmt::Display for NewType {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        self.0.fmt(f)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="chapter_1-item6-newtype-注释"><a class="header" href="#chapter_1-item6-newtype-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item6-newtype-1"><sup class="footnote-definition-label">1</sup>
<p>具体来说，是火星气候轨道器。</p>
</div>
<div class="footnote-definition" id="chapter_1-item6-newtype-2"><sup class="footnote-definition-label">2</sup>
<p>参见维基百科上的“火星气候轨道器”条目，了解更多关于失败原因的信息。</p>
</div>
<div class="footnote-definition" id="chapter_1-item6-newtype-3"><sup class="footnote-definition-label">3</sup>
<p>对于serde来说，这是一个足够常见的问题，因此它包含了一种帮助机制。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/newtype.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item7-builder"></div><h1 id="chapter_1-item7-builder-第-7-条对于复杂的类型使用构造器"><a class="header" href="#chapter_1-item7-builder-第-7-条对于复杂的类型使用构造器">第 7 条：对于复杂的类型，使用构造器</a></h1>
<p>这条款项描述了构造器模式：对于复杂的数据类型提供对应的构造器类型 <code>builder type</code>，使得用户可以方便地创造该数据数据类型的实例。</p>
<p>Rust 要求开发者在创建一个新的 <code>struct</code> 实例的时候，必须填入 <code>struct</code> 的所有字段。这样可以保证结构体中永远不会存在未初始化的值，从而保证了代码的安全，然而这会比理想的情况下产生更多的冗余的代码片段。</p>
<p>例如，任何可选的字段都必须显式地使用 <code>None</code> 来标记为缺失：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Phone number in E164 format.
#[derive(Debug, Clone)]
pub struct PhoneNumberE164(pub String);

#[derive(Debug, Default)]
pub struct Details {
    pub given_name: String,
    pub preferred_name: Option&lt;String&gt;,
    pub middle_name: Option&lt;String&gt;,
    pub family_name: String,
    pub mobile_phone: Option&lt;PhoneNumberE164&gt;,
}

// ...

let dizzy = Details {
    given_name: "Dizzy".to_owned(),
    preferred_name: None,
    middle_name: None,
    family_name: "Mixer".to_owned(),
    mobile_phone: None,
};
<span class="boring">}</span></code></pre></pre>
<p>这样的样板式代码也很脆弱，因为将来要向 <code>struct</code> 中添加一个新字段的时候需要更改所有创建这个结构体的地方。</p>
<p>通过使用和实现 <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a> trait 可以显著地减少这种样板代码，如<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>中所述：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dizzy = Details {
    given_name: "Dizzy".to_owned(),
    family_name: "Mixer".to_owned(),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>使用 <code>Default</code> 还有助于减少结构体新增字段时候导致的修改，前提是新的字段本身的类型也实现了 <code>Default</code>。</p>
<p>还有一个更普遍的问题：仅当所有的字段类型都实现了 <code>Default</code> trait 的时候，结构体才能使用自动派生的 <code>Default</code> 实现。如果有任何一个字段不满足，那么 <code>derive</code> 就会失败了：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default)]
pub struct Details {
    pub given_name: String,
    pub preferred_name: Option&lt;String&gt;,
    pub middle_name: Option&lt;String&gt;,
    pub family_name: String,
    pub mobile_phone: Option&lt;PhoneNumberE164&gt;,
    pub date_of_birth: time::Date,
    pub last_seen: Option&lt;time::OffsetDateTime&gt;,
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0277]: the trait bound `Date: Default` is not satisfied
  --&gt; src/main.rs:48:9
   |
41 |     #[derive(Debug, Default)]
   |                     ------- in this derive macro expansion
...
48 |         pub date_of_birth: time::Date,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not
   |                                       implemented for `Date`
   |
   = note: this error originates in the derive macro `Default`
</code></pre>
<p>由于孤儿规则的存在，代码没办法为 <code>chrono::Utc</code> 实现 <code>Default</code>；但就算可以，也无济于事 —— 给出生日期赋一个值默认值几乎总是一个错误的选择。</p>
<p>缺少 <code>Default</code> 意味着所有字段都必须手动填写：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bob = Details {
    given_name: "Robert".to_owned(),
    preferred_name: Some("Bob".to_owned()),
    middle_name: Some("the".to_owned()),
    family_name: "Builder".to_owned(),
    mobile_phone: None,
    date_of_birth: time::Date::from_calendar_date(
        1998,
        time::Month::November,
        28,
    )
    .unwrap(),
    last_seen: None,
};
<span class="boring">}</span></code></pre></pre>
<p>如果你<strong>为复杂的数据结构实现了构造器模式</strong>，那么就可以提高这里的效率和体验。</p>
<p>构造器模式最简单的一种实现方式就是用一个额外的 <code>struct</code> 来保存构造原始复杂数据类型所需的数据。简单起见，这里的实例会直接保存一个该类型的实例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DetailsBuilder(Details);

impl DetailsBuilder {
    /// Start building a new [`Details`] object.
    /// 开始构造一个新的 [`Details`] 对象
    pub fn new(
        given_name: &amp;str,
        family_name: &amp;str,
        date_of_birth: time::Date,
    ) -&gt; Self {
        DetailsBuilder(Details {
            given_name: given_name.to_owned(),
            preferred_name: None,
            middle_name: None,
            family_name: family_name.to_owned(),
            mobile_phone: None,
            date_of_birth,
            last_seen: None,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>随后，我们可以给构造器类型增添辅助函数来填充新的字段。每一个这种函数都会消费 <code>self</code> 同时产生一个新的 <code>Self</code>，以允许对不同的构造方法进行链式调用。</p>
<p>这些辅助函数会比简单的 <code>setter</code> 函数有用多了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Update the `last_seen` field to the current date/time.
/// 把 `last_seen` 字段更新成当前日期/时间
pub fn just_seen(mut self) -&gt; Self {
    self.0.last_seen = Some(time::OffsetDateTime::now_utc());
    self
}
<span class="boring">}</span></code></pre></pre>
<p>构造器被调用的最后一个函数会消费它自身并输出所构造的对象：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Consume the builder object and return a fully built [`Details`]
/// object.
/// 消费构造器对象并返回最后创建的 [`Details`] 对象
pub fn build(self) -&gt; Details {
    self.0
}
<span class="boring">}</span></code></pre></pre>
<p>总而言之，这让构造器的使用者拥有了更符合工程学的体验：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let also_bob = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
)
.middle_name("the")
.preferred_name("Bob")
.just_seen()
.build();
<span class="boring">}</span></code></pre></pre>
<p>构造器“消费自己”的性质也导致了一些问题。首先，对象的构造过程不能独立完成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
if informal {
    builder.preferred_name("Bob");
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: use of moved value: `builder`
   --&gt; src/main.rs:256:15
    |
247 |     let builder = DetailsBuilder::new(
    |         ------- move occurs because `builder` has type `DetailsBuilder`,
    |                 which does not implement the `Copy` trait
...
254 |         builder.preferred_name("Bob");
    |                 --------------------- `builder` moved due to this method
    |                                       call
255 |     }
256 |     let bob = builder.build();
    |               ^^^^^^^ value used here after move
    |
note: `DetailsBuilder::preferred_name` takes ownership of the receiver `self`,
      which moves `builder`
   --&gt; src/main.rs:60:35
    |
27  |     pub fn preferred_name(mut self, preferred_name: &amp;str) -&gt; Self {
    |                               ^^^^
</code></pre>
<p>这个问题可以通过把被消费的构造器重新赋值给同一个变量来解决：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
if informal {
    builder = builder.preferred_name("Bob");
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>构造器的性质带来的另一个问题是你只能构造一个最终对象，对同一个构造器重复调用 <code>build()</code> 函数来创建多个实例会违反编译器的检查规则，如同你能想到的那样：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let smithy = DetailsBuilder::new(
    "Agent",
    "Smith",
    time::Date::from_calendar_date(1999, time::Month::June, 11).unwrap(),
);
let clones = vec![smithy.build(), smithy.build(), smithy.build()];
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: use of moved value: `smithy`
   --&gt; src/main.rs:159:39
    |
154 |   let smithy = DetailsBuilder::new(
    |       ------ move occurs because `smithy` has type `base::DetailsBuilder`,
    |              which does not implement the `Copy` trait
...
159 |   let clones = vec![smithy.build(), smithy.build(), smithy.build()];
    |                            -------  ^^^^^^ value used here after move
    |                            |
    |                            `smithy` moved due to this method call
</code></pre>
<p>另一种实现构造器的途径是让构造器的方法接受 <code>&amp;mut self</code> 并返回一个 <code>&amp;mut Self</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Update the `last_seen` field to the current date/time.
/// 把 `last_seen` 字段更新成当前日期/时间
pub fn just_seen(&amp;mut self) -&gt; &amp;mut Self {
    self.0.last_seen = Some(time::OffsetDateTime::now_utc());
    self
}
<span class="boring">}</span></code></pre></pre>
<p>这可以让代码免于分步构造场景下的自赋值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
if informal {
    builder.preferred_name("Bob"); // no `builder = ...`
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>然而，这个版本的实现使得构造器的构造方法和它的 <code>setter</code> 函数无法被链式调用：</p>
<div class="ferris"><img src="chapter_1/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
)
.middle_name("the")
.just_seen();
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:265:19
    |
265 |       let builder = DetailsBuilder::new(
    |  ___________________^
266 | |         "Robert",
267 | |         "Builder",
268 | |         time::Date::from_calendar_date(1998, time::Month::November, 28)
269 | |             .unwrap(),
270 | |     )
    | |_____^ creates a temporary value which is freed while still in use
271 |       .middle_name("the")
272 |       .just_seen();
    |                   - temporary value is freed at the end of this statement
273 |       let bob = builder.build();
    |                 --------------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>如同编译器错误所示，你可以通过 <code>let</code> 为构造器指定一个名字来解决这个问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
builder.middle_name("the").just_seen();
if informal {
    builder.preferred_name("Bob");
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>这种修改自身的构造器实现允许你构造多个最终对象。<code>build()</code> 方法的签名<em>不</em>需要消费 <code>self</code>，因此必须如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Construct a fully built [`Details`] object.
/// 生成一个构造完毕的 [`Details`] 对象。
pub fn build(&amp;self) -&gt; Details {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>这个可重复调用的 <code>build()</code> 的实现必须在每次被调用的时候构造一个全新的实例。如果底层类型实现了 <code>Clone</code>，这就很简单了 —— 构造器可以持有一个模板然后在每一次 <code>build()</code> 的时候执行一次 <code>clone()</code>。如果底层类型<em>没有</em>实现 <code>Clone</code>，那么构造器需要保留足够的状态信息，在每一次 <code>build()</code> 的时候手动创建一个实例返回。</p>
<p>不管是哪种构造器模式的实现，样板代码都集中在一个地方 —— 构造器本身 —— 而不是每个需要操作底层类型的地方。</p>
<p>剩下的样板代码或许还可以通过宏（<a href="https://www.lurklurk.org/effective-rust/macros.html">第 28 条</a>）进一步减少，但如果你打算在这条路上走下去，你应该看看是否有现成的包（尤其是 <a href="https://docs.rs/derive_builder/latest/derive_builder/">derive_builder</a>）已经提供了你需要的功能——如果你愿意添加一个依赖的话（<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）。</p>
<p>原文<a href="https://www.lurklurk.org/effective-rust/builders.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item8-references&pointer"></div><h1 id="chapter_1-item8-referencespointer-第-8-条熟悉引用和指针类型"><a class="header" href="#chapter_1-item8-referencespointer-第-8-条熟悉引用和指针类型">第 8 条：熟悉引用和指针类型</a></h1>
<p>在一般的编程中，<strong>引用(reference)</strong> 是一种间接访问数据结构的方式，它与拥有该数据结构的变量是分开的。在实践中，<em>引用</em> 通常由 <strong>指针(pointer)</strong> 来实现。<em>指针</em> 是一个数字，它的值是数据结构的变量在内存中的地址。</p>
<p>现代 CPU 通常会对指针施加一些限制：内存地址应该处于有效的内存范围内（虚拟内存或物理内存），并且可能需要对齐（例如，一个4字节的整数值可能只有在其地址是4的倍数时才能访问）。</p>
<p>然而，高级编程语言通常会在其类型系统中编码更多关于指针的信息。在 C 衍生的语言（包括 Rust ）中，指针中有一个类型，该类型表示期望在所指向的内存地址存储哪种类型数据结构。这允许通过代码解释在该地址以及随后内存中的内容。</p>
<p>这种基本的指针信息-假定的内存位置和预期的数据结构布局-在 Rust 中被表示为一个<strong>裸指针(raw point)</strong>。然而，安全的 Rust 代码不使用裸指针，因为 Rust 提供了更丰富的引用和指针类型，这些类型提供了额外的安全保证和约束。这些引用和指针类型是本节的主题；裸指针则留待<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第16条</a>讨论（该节讨论 unsafe 代码）。</p>
<h2 id="chapter_1-item8-referencespointer-rust引用"><a class="header" href="#chapter_1-item8-referencespointer-rust引用">Rust引用</a></h2>
<p>在 Rust 中，最常见的指针类型是 <em>引用</em>，用 <code>&amp;T</code> 表示，其中 <code>T</code> 是任意类型。尽管在底层这是一个指针值，但编译器会确保在使用时遵循一些规则：</p>
<ul>
<li>始终指向有效且对齐正确的类型 <code>T</code> 的实例。</li>
<li>被引用数据的生命周期（在<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第14条</a>中介绍）必须比 <em>引用</em> 本身的生命周期更长。</li>
<li>遵守借用检查规则（在<a href="https://www.lurklurk.org/effective-rust/borrows.html">第15条</a>中解释）。</li>
</ul>
<p>这些额外的约束总是隐含在 Rust 中的 <em>引用</em> 中，因此 <em>裸指针</em> 通常很少出现。</p>
<p>Rust 引用必须指向有效、正确对齐的项的约束,与 C++ 的引用类型相同。然而，C++ 没有生命周期的概念，因此允许使用悬空引用而导致错误<sup class="footnote-reference"><a href="#chapter_1-item8-references&pointer-1">1</a></sup>：</p>
<pre><code class="language-c++ does_not_compile">// C++
const int&amp; dangle() {
  int x = 32; // on the stack, overwritten later
  return x; // return reference to stack variable!
}
</code></pre>
<p>Rust 的借用和生命周期检查会让等价的代码甚至不能编译:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangle() -&gt; &amp;'static i64 {
    let x: i64 = 32; // 在栈上
    &amp;x
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-error">error[E0515]: cannot return reference to local variable `x`
   --&gt; src/main.rs:477:5
    |
477 |     &amp;x
    |     ^^ returns a reference to data owned by the current function
</code></pre>
<p>Rust 的引用 <code>&amp;T</code> 允许只读访问底层元素（大致相当于 C++ 的<code>const T&amp;</code>）。一个允许修改底层元素的可变引用写为 <code>&amp;mut T</code>，同样也遵循第 15 项讨论的借用检查规则。这种命名方式反映了 Rust 和 C++ 之间略微不同的思维方式：</p>
<ul>
<li>在 Rust 中，默认情况下变量是只读的，可写类型需要特别标记（用 <code>mut</code>）。</li>
<li>在 C++ 中，默认情况下引用是可写的，只读类型需要特别标记（用 <code>const</code>）。
编译器会将使用引用的 Rust 代码转换为使用简单指针的机器码，在 64 位平台上这些指针的长度为 8 个字节（本节假设一直如此）。</li>
</ul>
<p>例如，一对局部变量以及对它们的引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Point {
    pub x: u32,
    pub y: u32,
}

let pt = Point { x: 1, y: 2 };
let x = 0u64;
let ref_x = &amp;x;
let ref_pt = &amp;pt;
<span class="boring">}</span></code></pre></pre>
<p>可能最终在栈上布局如图1-2所示。</p>
<img src="chapter_1/../images/item8/stack.svg" alt="img">
图1-2.带有指向局部变量的指针的栈布局
<p>Rust 引用可以指向位于<strong>栈</strong>或<strong>堆</strong>上的元素。Rust 默认情况下会在栈上分配内存，但是 <code>Box&lt;T&gt;</code> 指针类型（大致相当于 C++ 的 <code>std::unique_ptr&lt;T&gt;</code>) 会强制分配到堆上，这意味着分配的元素可以比当前代码块的作用域更长寿。本质上，<code>Box&lt;T&gt;</code> 也是一个简单的8字节指针值（64 位平台）：</p>
<p><strong>注意</strong>：</p>
<ul>
<li>栈是一种快速但有限制的内存区域，函数调用时分配，函数结束后释放。</li>
<li>堆是一种更大但速度较慢的内存区域，程序可以显式分配和释放内存。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let box_pt = Box::new(Point { x: 10, y: 20 });
<span class="boring">}</span></code></pre></pre>
<p>这在图1-3中被描述。
<img src="chapter_1/../images/item8/heap.svg" alt="img">
图1-3.栈上的 <code>Box</code> 指针指向堆上的 <code>struct</code></p>
<h3 id="chapter_1-item8-referencespointer-指针特征"><a class="header" href="#chapter_1-item8-referencespointer-指针特征">指针特征</a></h3>
<p>期望一个引用参数，如 <code>&amp;Point</code> 的方法也可以接受一个 <code>&amp;Box&lt;Point&gt;</code>：</p>
<pre><code class="language-rust ignore">fn show(pt: &amp;Point) {
    println!("({}, {})", pt.x, pt.y);
}
show(ref_pt);
show(&amp;box_pt);</code></pre>
<pre><code class="language-shell">(1, 2)
(10, 20)
</code></pre>
<p>这之所以可能，因为 <code>Box&lt;T&gt;</code> 实现了 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> 特征（<code>Trait</code>），<code>Target = T</code>。某个类型实现这个特征意味着该特征的 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref()</code></a> 方法可以用于创建对 <code>Target</code> 类型的引用。还有一个等效的 <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> 特征，它会生成对 <code>Target</code> 类型的<strong>可变</strong>引用。</p>
<p><code>Deref</code>/<code>DerefMut</code> 特征有点特别，因为Rust编译器在处理实现它们的类型时有特定的行为。当编译器遇到解引用表达式（例如，<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-dereference-operator"><code>*x</code></a>），它会根据解引用是否需要可变访问来查找并使用这些特征的实现。这种 <code>Deref</code> 转换允许各种智能指针类型像普通引用一样工作，它是 Rust 中少数允许隐式类型转换的机制之一（如<a href="#chapter_1-item5-casts">第5条</a>所述）。</p>
<p>作为一个技术细节，理解为什么 <code>Deref</code> 特征不能对目标类型是泛型的（<code>Deref&lt;Target&gt;</code>）是很值得的。如果它们是，那么某些类型 <code>ConfusedPtr</code> 就可以同时实现 <code>Deref&lt;TypeA&gt;</code> 和 <code>Deref&lt;TypeB&gt;</code>，这将使编译器无法为 <code>*x</code> 这样的表达式推导出唯一的类型。因此，目标类型被编码为一个名为 <code>Target</code> 的关联类型。
这种技术细节与另两个标准指针特征 <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a> 形成对比。这些特征不会在编译器中引起特殊行为，但允许通过对其特征函数（<a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref()</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut()</code></a>）的显式调用进行引用或可变引用的转换。转换的目标类型被编码为类型参数（例如，<code>AsRef&lt;Point&gt;</code>），这意味着一个容器类型可以支持多个目标类型。</p>
<p>例如，标准 <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> 类型实现了 <code>Deref</code> 特征，<code>Target = str</code>，这意味着像 <code>&amp;my_string</code> 这样的表达式可以强制转换为类型 <code>&amp;str</code>。但它也实现了以下特征：</p>
<ul>
<li><code>AsRef&lt;[u8]&gt;</code>，允许转换为字节切片 <code>&amp;[u8]</code></li>
<li><code>AsRef&lt;OsStr&gt;</code>，允许转换为OS字符串</li>
<li><code>AsRef&lt;Path&gt;</code>，允许转换为文件系统路径</li>
<li><code>AsRef&lt;str&gt;</code>，允许转换为字符串切片 <code>&amp;str</code>（与 <code>Deref</code> 相同）</li>
</ul>
<h3 id="chapter_1-item8-referencespointer-胖指针类型"><a class="header" href="#chapter_1-item8-referencespointer-胖指针类型">胖指针类型</a></h3>
<p>Rust有两个内置的<strong>胖指针</strong>类型：切片（<code>Slice</code>）和特征（<code>Trait</code>）对象。这些类型的行为像指针，但它们持有关于指向对象的额外信息。</p>
<h4 id="chapter_1-item8-referencespointer-切片"><a class="header" href="#chapter_1-item8-referencespointer-切片">切片</a></h4>
<p>第一种胖指针类型是<strong>切片</strong>：它引用某个连续值集合的子集。切片由一个（没有所有权的）简单指针和一个长度字段组成，因此大小是简单指针的两倍（在 64 位平台上为 16 字节）。切片的类型写为 <code>&amp;[T]</code> - 它表示对 <code>[T]</code> 的引用，<code>[T]</code>是类型 T 的连续值集合的概念类型。</p>
<p>概念类型 <code>[T]</code> 不能被实例化，但是有两种常见的容器实现了它。第一种是<strong>数组</strong>：一个连续的值集合，其大小在编译时是已知的。</p>
<p>一个有5个值的数组将始终有5个值。因此，切片可以引用数组的一个子集（如图1-4所示）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [u64; 5] = [0, 1, 2, 3, 4];
let slice = &amp;array[1..3];
<span class="boring">}</span></code></pre></pre>
<p><img src="chapter_1/../images/item8/arrayslice.svg" alt="img" />
图1-4.指向栈数组的栈切片</p>
<p>连续值的另一种常见容器是 <code>Vec&lt;T&gt;</code>。这像数组一样持有连续的值集合，但与数组不同，<code>Vec</code>中的值的数量可以增长（例如，用 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>push(value)</code></a> ）或缩小（例如，用 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop"><code>pop()</code></a> ）。
<code>Vec</code> 的内容保存在堆上（这允许其大小发生变化），并且总是连续的，因此切片可以引用 <code>Vec</code> 的子集，如图 1-5 所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vector = Vec::&lt;u64&gt;::with_capacity(8);
for i in 0..5 {
    vector.push(i);
}
let vslice = &amp;vector[1..3];
<span class="boring">}</span></code></pre></pre>
<p><img src="chapter_1/../images/item8/vecslice.svg" alt="img" />
图1-5.指向堆上的Vec内容的栈切片</p>
<p>表达式 <code>&amp;vector[1..3]</code> 的底层有很多细节，所以值得将其拆解成d多个部分：</p>
<ul>
<li><code>1..3</code> 部分是一个<a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">范围表达式(range expression)</a>；编译器会将其转换为 <a href="https://doc.rust-lang.org/std/ops/struct.Range.html"><code>Range&lt;usize&gt;</code></a> 类型的实例，该类型包含下限（1）但不包含上限（3）。</li>
<li><code>Range</code> 类型<a href="https://doc.rust-lang.org/std/slice/trait.SliceIndex.html">实现了</a>特征，该特征描述了对任意类型 <code>T</code> 的切片的索引操作（因此<code>Output</code>类型为<code>[T]</code>）。</li>
<li><code>vector[]</code>部分是一个<a href="https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions">索引表达式(indexing expression)</a>；编译器将其转换为在 <code>vector</code> 上调用 <a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a> 特征的 <a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>index</code></a> 方法，并附加一次解引用（即 <code>*vector.index()</code> ）。<sup class="footnote-reference"><a href="#chapter_1-item8-references&pointer-2">2</a></sup></li>
<li><code>vector[1..3]</code>会调用 <code>Vec&lt;T&gt;</code> 的 <code>Index&lt;I&gt;</code> [实现]，它要求 <code>I</code> 是 <code>SliceIndex&lt;[u64]&gt;</code> 的一个实例。这是因为 <code>Range&lt;usize&gt;</code> 对于任何 <code>T</code> 类型来说，包括 <code>u64</code>，都实现了 <code>SliceIndex&lt;[T]&gt;</code> 特征。</li>
<li><code>&amp;vector[1..3]</code> 取消了解引用，最终得到的表达式类型为 <code>&amp;[u64]</code>。</li>
</ul>
<h4 id="chapter_1-item8-referencespointer-特征对象"><a class="header" href="#chapter_1-item8-referencespointer-特征对象">特征对象</a></h4>
<p>第二种内置的胖指针类型是特征对象：它引用实现了特定特征的某个元素。特征对象由一个指向该元素的简单指针和一个指向类型 <a href="https://en.wikipedia.org/wiki/Virtual_method_table"><code>vtable</code></a> 的内部指针共同构成，大小为 16 字节（在 64 位平台上）。类型的 <code>vtable</code> 存储了该类型所实现特征的方法实现的函数指针，从而允许在运行时进行动态分配（<a href="#chapter_1-chapter_2-item12-generics&amp;trait-objects">第12条</a>）。<sup class="footnote-reference"><a href="#chapter_1-item8-references&pointer-3">3</a></sup></p>
<p>例如，定义一个简单的特征：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Calculate {
    fn add(&amp;self, l: u64, r: u64) -&gt; u64;
    fn mul(&amp;self, l: u64, r: u64) -&gt; u64;
}
<span class="boring">}</span></code></pre></pre>
<p>以及一个实现该特征的结构体：</p>
<pre><code class="language-rust ignore">struct Modulo(pub u64);

impl Calculate for Modulo {
    fn add(&amp;self, l: u64, r: u64) -&gt; u64 {
        (l + r) % self.0
    }
    fn mul(&amp;self, l: u64, r: u64) -&gt; u64 {
        (l * r) % self.0
    }
}

let mod3 = Modulo(3);</code></pre>
<p>我们可以将 <code>Modulo </code>转换为特征对象 <a href="https://doc.rust-lang.org/std/keyword.dyn.html"><code>&amp;dyn</code></a> Calculate。<code>dyn</code> 关键字强调了涉及动态分配的事实：</p>
<pre><code class="language-rust ignore">// Need an explicit type to force dynamic dispatch.
let tobj: &amp;dyn Calculate = &amp;mod3;
let result = tobj.add(2, 2);
assert_eq!(result, 1);</code></pre>
<p>如图 1-6 所示的相应内存布局。
<img src="chapter_1/../images/item8/traitobject.svg" alt="img" />
图1-6.指向具体项和 <code>vtable</code> 的 Trait 对象</p>
<p>持有特征对象的代码可以通过 <code>vtable</code> 中的函数指针调用特征的方法，并将元素指针作为 <code>&amp;self</code> 参数传递；有关更多信息和建议，请参考<a href="#chapter_1-chapter_2-item12-generics&amp;trait-objects">第12条</a>。</p>
<h2 id="chapter_1-item8-referencespointer-更多指针特征"><a class="header" href="#chapter_1-item8-referencespointer-更多指针特征">更多指针特征</a></h2>
<p>之前的一节描述了两组特征（<code>Deref</code>/<code>DerefMut</code>、<code>AsRef</code>/<code>AsMut</code>），它们用于处理可以轻松转换为引用的类型。除此之外，还有一些标准特征在处理类似指针的类型时也会发挥作用，这些类型可以来自标准库或用户定义的类型。</p>
<p>其中最简单的是 <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a> 特征，它用于格式化指针值以供输出。这对于底层开发调试很有帮助，编译器在遇到<code>{:p}</code>格式说明符时会自动使用这个特征。</p>
<p>更有趣的是 <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> 和 <a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a> 特征，它们各自只有一个方法（分别为 <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>borrow</code></a> 和 <a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a> ）。这些方法的签名与相应的 <code>AsRef</code>/<code>AsMut</code> 特征方法相同。</p>
<p>通过标准库提供的泛型实现，可以看到这些特征之间的主要意图差异。给定任意Rust引用 <code>&amp;T</code>，标准库都提供了 <code>AsRef</code> 和 <code>Borrow </code>的泛型实现；同样地，对于可变引用 <code>&amp;mut T</code>，也提供了 <code>AsMut</code> 和 <code>BorrowMut</code> 的泛型实现。</p>
<p>然而，<code>Borrow</code> 还有一个针对（非引用）类型的泛型实现：<code>impl&lt;T&gt; Borrow&lt;T&gt; for T</code>。这意味着，一个接受 <code>Borrow</code> 特征的方法可以同样处理 <code>T</code> 的实例以及对 <code>T</code> 的引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_four&lt;T: std::borrow::Borrow&lt;i32&gt;&gt;(v: T) -&gt; i32 {
    v.borrow() + 4
}
assert_eq!(add_four(&amp;2), 6);
assert_eq!(add_four(2), 6);
<span class="boring">}</span></code></pre></pre>
<p>标准库的容器类型有更贴合实际的 <code>Borrow</code> 用法。例如，<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>HashMap::get</code></a> 使用 <code>Borrow</code> 以便无论通过值还是引用作为键，都可以方便地检索条目。</p>
<p><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a> 特征建立在 <code>Borrow</code> 特征的基础上，增加了一个 <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>to_owned()</code></a> 方法，该方法生成一个新的底层类型的所有权项。这是 <code>Clone</code> 特征的泛化: 其中 <code>Clone </code>特征特别要求一个Rust引用 <code>&amp;T</code>，而 <code>ToOwned</code> 则处理实现 <code>Borrow</code> 的内容。</p>
<p>这为以统一的方式处理引用和移动项提供了几种可能性：</p>
<ul>
<li>一个操作某些类型引用的函数可以接受 <code>Borrow</code>，以便它也可以用移动项以及引用调用。</li>
<li>一个操作某些类型拥有项的函数可以接受 <code>ToOwned</code>，以便它也可以用引用项以及移动项调用；传递给它的任何引用都将被复制到本地拥有项中。</li>
</ul>
<p>此时值得一提的是 <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> 类型，虽然它不是指针类型，因为它提供了处理相同情况的替代方式。<code>Cow</code> 是一个枚举，可以持有拥有的数据或对借用数据的引用。这个特殊的名称代表“写入时复制”（clone-on-write）：一个 <code>Cow</code> 输入可以作为借用数据一直保持，直到它需要被修改，但在数据需要被更改的时，它才会变成一个拥有的副本。</p>
<h2 id="chapter_1-item8-referencespointer-智能指针类型"><a class="header" href="#chapter_1-item8-referencespointer-智能指针类型">智能指针类型</a></h2>
<p>Rust 标准库包含多种在某种程度上类似于指针的类型，这些类型在一定程度上充当指针的角色，并由之前描述的标准库特质进行调解。每种智能指针类型都具有一些特定的语义和保证，正确组合它们可以对指针的行为进行细粒度控制，但缺点是由此产生的类型乍一看可能会让人不知所措（比如 <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code>）。</p>
<p>第一个智能指针类型是 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>，它是对某个项的引用计数指针（大致类似于 C++中的 <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr&lt;T&gt;</code></a>）。它实现了所有与指针相关的特征，因此在许多方面的行为类似于 <code>Box&lt;T&gt;</code>。</p>
<p>这对于可以通过不同途径访问同一个项的数据结构很有用，但它消除了 Rust 围绕所有权的核心规则之一，每个项只有一个所有者。放宽这条规则意味着现在可能会发生数据泄漏：如果变量 A 有一个指向变量 B 的 <code>Rc</code> 指针，而变量 B 有一个指向 A 的 <code>Rc</code> 指针，那么这对变量将永远不会被释放。<sup class="footnote-reference"><a href="#chapter_1-item8-references&pointer-4">4</a></sup>换句话说：你需要 <code>Rc</code> 来支持循环数据结构，但缺点是现在你的数据结构中存在循环。</p>
<p>在某些情况下，可以通过使用相关的 <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a> 类型来降低数据泄漏的风险。<code>Weak&lt;T&gt;</code> 持有对底层数据的非所有权引用（弱引用，类似于 C++ 的 <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr&lt;T&gt;</code></a>）。持有弱引用不会阻止底层数据被删除（当所有强引用都被移除时），所以使用 <code>Weak&lt;T&gt; </code>需要升级为 <code>Rc&lt;T&gt;</code> ——这可能会失败。</p>
<p>在底层，<code>Rc</code>（目前）实现为一对引用计数和被引用的项，所有这些都存储在堆上（如图 1-7 所示）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
let rc1: Rc&lt;u64&gt; = Rc::new(42);
let rc2 = rc1.clone();
let wk = Rc::downgrade(&amp;rc1);
<span class="boring">}</span></code></pre></pre>
<p><img src="chapter_1/../images/item8/rc.svg" alt="img" />
图1-7. Rc和Weak指针都指向堆上同一个项</p>
<p>当强引用计数降至零时，底层数据将被释放，但只有弱引用计数也降至零时，才会释放 bookkeeping 结构。</p>
<p>Rc<T> 本身允许你以不同的方式访问一个项，但是当你访问该项时，只有在没有其他方式访问该项时（即，没有其他现存的 <code>Rc</code>或 <code>Weak</code> 引用指向同一项），你才能修改它（通过 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.get_mut"><code>get_mut</code></a>）。这很难协调，因此 <code>Rc</code> 通常与 <code>RefCell</code> 结合使用。</p>
<p>下一个智能指针类型是<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>，它放宽了只能由所有者或持有唯一可变引用的代码修改数据的规则（参考<a href="https://www.lurklurk.org/effective-rust/borrows.html">第15条</a>）。这种内部可变性带来了更大的灵活性，例如允许特征实现修改内部，即使方法签名只允许 <code>&amp;self</code>。然而，这也带来了代价：除了额外的存储开销（需要一个额外的 <code>isize</code> 用于跟踪当前的借用，如图 1-8 所示），正常的借用检查也从编译时转移到了运行时：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
let rc: RefCell&lt;u64&gt; = RefCell::new(42);
let b1 = rc.borrow();
let b2 = rc.borrow(); 
<span class="boring">}</span></code></pre></pre>
<p><img src="chapter_1/../images/item8/refcell.svg" alt="img" />
图1-8. 引用了 RefCell 容器的 Ref 借用</p>
<p>这些运行时的借用检查意味着用户使用 <code>RefCell</code> 时，必须在两个不愉快的选项之间做出选择：</p>
<ul>
<li>接受借用可能失败的操作，并处理来自 <code>try_borrow[_mut]</code> 的 Result 值。</li>
<li>使用所谓不会失败的借用方法 <code>borrow[_mut]</code>，并接受在运行时由于借用规则不合规而引发 panic 的风险（参考<a href="https://www.lurklurk.org/effective-rust/panic.html">第18条</a>）。</li>
</ul>
<p>无论哪种情况，这种运行时检查意味着 <code>RefCell</code> 不实现任何标准指针特征；相反，它的访问操作返回一个实现了这些特征的 <a href="https://doc.rust-lang.org/std/cell/struct.Ref.html"><code>Ref&lt;T&gt;</code></a> 或 <a href="https://doc.rust-lang.org/std/cell/struct.RefMut.html"><code>RefMut&lt;T&gt;</code></a> 智能指针类型。</p>
<p>如果底层类型 <code>T</code> 实现了 <code>Copy</code> 特征（表示按位快速复制生成一个有效的项；参考<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第10条</a>），那么 <code>Cell&lt;T&gt;</code> 类型允许以更少的开销进行内部修改——<code>get(&amp;self)</code> 方法复制出当前值，<code>set(&amp;self, val)</code> 方法设置一个新值进去。<code>Cell</code> 类型在 <code>Rc</code> 和 <code>RefCell</code> 实现中都被内部使用，用于共享跟踪可以修改的计数器，而无需 <code>&amp;mut self</code>。</p>
<p>到目前为止描述的智能指针类型仅适用于单线程使用；它们的实现假设对其内部没有并发访问。如果不是这种情况，则需要包含额外同步开销的智能指针。</p>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> 线程安全 <code>Rc&lt;T&gt;</code> 等价实现，它使用原子计数器来确保引用计数保持准确。与 <code>Rc</code>一样，<code>Arc</code> 实现了所有各种与指针相关的特征。</p>
<p>然而，单独的 <code>Arc</code> 不允许对底层项目进行任何形式的可变访问。这是由 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> 类型引起的，它确保只有一个线程可以访问（无论是可变的还是不可变的）底层项目。与 <code>RefCell</code> 一样，<code>Mutex</code> 本身不实现任何指针特征，但它的 <code>lock()</code> 操作返回一个实现了 <code>Deref[Mut]</code> 的类型的值：<a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a>。</p>
<p>如果读者(读操作线程)可能多于写者(写操作线程)，则更推荐使用 <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> 类型，因为它允许多个读者并行访问底层项目，前提是当前没有（单个）写者。</p>
<p>在任何情况下，Rust 的借用和线程规则都强制在多线程代码中使用这些同步容器中的一个（但这仅能防止共享状态并发的一些问题；参考<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第17条</a>）。</p>
<p>对于其他智能指针类型，有时也可以应用相同的策略——查看编译器拒绝的内容，并替换为它建议的内容。然而，更快、更少挫折的方法是理解不同智能指针的行为含义。借用来自<a href="https://doc.rust-lang.org/1.15.1/book/choosing-your-guarantees.html#composition"><code>Rust编程语言第一版的示例</code></a>:</p>
<ul>
<li><code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> 持有一个具有共享所有权 (<code>Rc</code>) 的 <code>Vec</code>，其中 <code>Vec</code> 可以作为一个整体被修改。</li>
<li><code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code> 也持有具有共享所有权的 <code>Vec</code>，但这里 <code>Vec</code> 中的每个单独的条目都可以独立于其他条目进行修改。</li>
</ul>
<p>涉及的类型精确描述了这些行为。</p>
<h4 id="chapter_1-item8-referencespointer-注释"><a class="header" href="#chapter_1-item8-referencespointer-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_1-item8-references&pointer-1"><sup class="footnote-definition-label">1</sup>
<p>尽管有来自现代编译器的警告</p>
</div>
<div class="footnote-definition" id="chapter_1-item8-references&pointer-2"><sup class="footnote-definition-label">2</sup>
<p>可变表达式的等价特征是<a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a></p>
</div>
<div class="footnote-definition" id="chapter_1-item8-references&pointer-3"><sup class="footnote-definition-label">3</sup>
<p>这是一种简化解释；完整的<code>虚函数表(vtable)</code>还包含类型的尺寸和对齐信息，以及一个<code>drop()</code>函数指针，用于安全地释放底层对象</p>
</div>
<div class="footnote-definition" id="chapter_1-item8-references&pointer-4"><sup class="footnote-definition-label">4</sup>
<p>请注意，这并不影响 Rust 的内存安全保证：项目仍然是安全的，只是无法访问</p>
</div>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_1-item9-iterators"></div><h1 id="chapter_1-item9-iterators-第-9-条考虑使用迭代器转换代替显式循环"><a class="header" href="#chapter_1-item9-iterators-第-9-条考虑使用迭代器转换代替显式循环">第 9 条：考虑使用迭代器转换代替显式循环</a></h1>
<p>编程语言中简陋朴素的循环经历了一段漫长的发展，逐步提高了使用的便利性和抽象性。B 语言（C 语言的前身）当时仅有 <code>while (condition) { ... }</code> 这种结构，但随着 C 语言的到来，<code>for</code> 循环的加入使通过数组下标进行遍历这种高频行为变得越来越方便：</p>
<pre><code class="language-c">// C code
int i;
for (i = 0; i &lt; len; i++) {
  Item item = collection[i];
  // body
}
</code></pre>
<p>C++ 的早期版本通过允许将循环变量的声明嵌入到 <code>for</code> 语句中，进一步提高了便利性（这也被 C 语言的 C99 标准所纳入）：</p>
<pre><code class="language-c++">// C++98 code
for (int i = 0; i &lt; len; i++) {
  Item item = collection[i];
  // ...
}
</code></pre>
<p>大多数现代编程语言把循环的概念做了更进一步的抽象：循环的核心功能通常是移动到某个容器的下一项进行访问。维护访问容器元素所需要的逻辑（<code>index++</code> or <code>++it</code>）通常是无关紧要的细节。基于这种认识，产生了两个核心的概念：</p>
<ul>
<li>迭代器 <code>Iterators</code>：一种类型，它存在的目的是重复地释出容器的下一个元素，直到把容器耗尽<a href="#chapter_1-item9-iterators-footnote-1">1</a>。</li>
<li><code>For-each</code> 循环：一种紧凑的循环表达式，用于迭代容器中的所有元素，表达式会将容器元素绑定到循环变量上，而不是提供一些让你访问到元素的细节信息。</li>
</ul>
<p>这些概念允许循环代码变得更简短，（更重要的是）更加清晰地表明意图：</p>
<pre><code class="language-c++">// C++11 code
for (Item&amp; item : collection) {
  // ...
}
</code></pre>
<p>一旦有了这些可行的概念，它们的强大显而易见，因此它们很快地就被移植到了那些本没有这些概念的语言中（例如，for-each 循环在 <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html">Java 1.5</a> 和 C++11 中被引入）。</p>
<p>Rust 包括迭代器和 <code>for-each</code> 风格的循环，但它还包括了更进一步的抽象：允许整个循环体通过迭代器转换 <code>iterator transform</code>（有时候也被称作迭代器适配器 <code>iterator adaptor</code>）来表达。如我们在 <a href="#chapter_1-item3-transform">第 3 条</a> 中讨论的 <code>Option</code> 和 <code>Reuslt</code> 一样，这条条款会尝试展示如何使用这些迭代器转换来替换显式的循环，并就应该何时使用给出相应的指导。特别要注意的是，迭代器转换或许会比显式的循环更高效，因为编译器可以跳过那些潜在的边界检查。</p>
<p>在看完这条条款后，一个 C 风格的，用于求向量 <code>vector</code> 前五个偶数项的平方和的循环：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values: Vec&lt;u64&gt; = vec![1, 1, 2, 3, 5 /* ... */];

let mut even_sum_squares = 0;
let mut even_count = 0;
for i in 0..values.len() {
    if values[i] % 2 != 0 {
        continue;
    }
    even_sum_squares += values[i] * values[i];
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>应该能被很自然地表达为函数式表达式的样子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let even_sum_squares: u64 = values
    .iter()
    .filter(|x| *x % 2 == 0)
    .take(5)
    .map(|x| x * x)
    .sum();
<span class="boring">}</span></code></pre></pre>
<p>像这样的迭代器转换表达式可以粗略被分解为三个部分：</p>
<ul>
<li>一个源迭代器，来自于一个实现了 Rust 的任意一种 <code>iterator</code> traits 的类型实例；</li>
<li>一个由若干迭代器转换组成的操作序列；</li>
<li>一个最终的消费者方法 <code>consumer method</code> 将迭代的结果合并为最后的值；</li>
</ul>
<p>其中前两部分有效地将循环的内部功能从循环体内移到 <code>for</code> 表达式中，最后一部分则完全消除了对 <code>for</code> 语句的依赖。</p>
<blockquote>
<p>译者注：这里的原文表达的意思有点绕。不熟悉这种编程范式的朋友可以尝试这么理解：<code>for</code> 循环版本代码中的逻辑，通过 <code>filter().take().map()</code> 这一系列调用“表达”了。而 <code>iter()</code> 和 <code>sum()</code> 相当于是这个循环的“启动”和“结束”，对应 <code>for</code> 循环版本中的 <code>for</code> 和 <code>even_sum_squares += ...</code>。于是我们最终摆脱了对 <code>for</code> 这个表达式的使用。</p>
</blockquote>
<h2 id="chapter_1-item9-iterators-iterator-traits-迭代器-traits"><a class="header" href="#chapter_1-item9-iterators-iterator-traits-迭代器-traits">Iterator Traits 迭代器 Traits</a></h2>
<p>标准库中这个核心的 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> trait 有一个十分简单的接口：一个 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next">next</a> 方法用于生成 <code>Some</code> 元素，直到没法再继续生成（返回 <code>None</code>）。迭代过程中生成元素的类型通过 trait 的关联类型 <code>Item</code> 定义。</p>
<p>那些允许用户对其中元素进行遍历的容器——在其他语言中被称为可迭代对象  <code>iterable</code>）——实现了 <a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html">IntoIterator</a> trait；trait 中定义的 <a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a> 方法会消耗掉 <code>Self</code> 并返回一个 <code>Iterator</code>。编译器会自动对以下形式的表达式自动应用这个 trait：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in collection {
    // body
}
<span class="boring">}</span></code></pre></pre>
<p>并高效地转换成类似如下的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = collection.into_iter();
loop {
    let item: Thing = match iter.next() {
        Some(item) =&gt; item,
        None =&gt; break,
    };
    // body
}
<span class="boring">}</span></code></pre></pre>
<p>或者更简洁惯用的形式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = collection.into_iter();
while let Some(item) = iter.next() {
    // body
}
<span class="boring">}</span></code></pre></pre>
<p>为了让不同场景下的使用更流畅，对于任何的 <code>Iterator</code> 都有实现 <code>IntoIterator</code>，而实现就是返回 <code>self</code>；毕竟要把 <code>Iterator</code> 转成 <code>Iterator</code> 不费吹灰之力！</p>
<p>这种初始形式生成的是一个消耗型迭代器，在创建的时候会把容器消耗掉。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
for item in collection {
    println!("Consumed item {item:?}");
}
<span class="boring">}</span></code></pre></pre>
<p>任何在迭代后完成后对容器进行的操作都会失败：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Collection = {collection:?}");
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: borrow of moved value: `collection`
   --&gt; src/main.rs:171:28
    |
163 |   let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    |       ---------- move occurs because `collection` has type `Vec&lt;Thing&gt;`,
    |                  which does not implement the `Copy` trait
164 |   for item in collection {
    |               ---------- `collection` moved due to this implicit call to
    |                           `.into_iter()`
...
171 |   println!("Collection = {collection:?}");
    |                          ^^^^^^^^^^^^^^ value borrowed here after move
    |
note: `into_iter` takes ownership of the receiver `self`, which moves
      `collection`
</code></pre>
<p>虽然容易理解，但这种消耗整个容器的行为通常不是我们想要的；我们需要对被迭代的元素进行某种<em>借用</em>。</p>
<p>为了确保展示内容的清晰，这里的例子使用了一个<em>没有</em>实现 <code>Copy</code>（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>） 的 <code>Thing</code> 类型，因为 <code>Copy</code> 会掩盖掉所有权（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）的问题——编译器会偷偷四处拷贝：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
// Deliberately not `Copy`
// 特地不实现 `Copy`
#[derive(Clone, Debug, Eq, PartialEq)]
struct Thing(u64);

let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
}</code></pre></pre>
<p>如果被迭代的集合以 <code>&amp;</code> 作为前缀：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in &amp;collection {
    println!("{}", item.0);
}
println!("collection still around {collection:?}");
<span class="boring">}</span></code></pre></pre>
<p>那么编译器会寻找 <code>&amp;Collection</code> 类型的 <a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html">IntoIterator</a> 实现。正确设计的集合都会提供这样的一个实现；这个实现仍然会消耗 <code>Self</code>，不过此时 <code>Self</code> 是 <code>&amp;Collection</code> 类型而不是 <code>Collection</code>，并且对应的关联类型 <code>Item</code> 将会是一个引用类型 <code>&amp;Thing</code>。</p>
<p>这使得在迭代之后容器仍然保持完整，等效的扩展代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = (&amp;collection).into_iter();
while let Some(item) = iter.next() {
    println!("{}", item.0);
}
<span class="boring">}</span></code></pre></pre>
<p>在可以遍历可变引用的场景下<a href="#chapter_1-item9-iterators-footnote-2">1</a>，<code>for item in &amp;mut collection</code> 也有类似的模式：编译器寻找 <code>&amp;mut Collection</code> 的 <code>IntoIterator</code> trait，此时关联类型 <code>Item</code> 是 <code>&amp;mut Thing</code> 类型。</p>
<p>按照惯例，标准库容器会提供一个 <code>iter()</code> 方法返回对底层元素的引用，以及如果可以的话，一个等效的 <code>iter_mut()</code> 方法，其行为与上面提到的相同。这些方法可以在 <code>for</code> 循环中使用，但在用作迭代器转换的场景下有更明显的好处：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: u64 = (&amp;collection).into_iter().map(|thing| thing.0).sum();
<span class="boring">}</span></code></pre></pre>
<p>可以变成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: u64 = collection.iter().map(|thing| thing.0).sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_1-item9-iterators-iterator-transforms-迭代器转换"><a class="header" href="#chapter_1-item9-iterators-iterator-transforms-迭代器转换">Iterator Transforms 迭代器转换</a></h2>
<p><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> trait 只有一个必须的 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next">next</a> 方法，但也提供了大量的在迭代器上执行转换计算的默认方法实现（<a href="#chapter_1-chapter_2-item13-use-default-impl">第 13 条</a>）。</p>
<p>其中一些转换会影响到整个迭代的过程：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take">take(n)</a>：限制迭代器最多只能产生 <code>n</code> 个元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip">skip(n)</a>：跳过迭代器的前 <code>n</code> 个元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by">step_by(n)</a>：转换迭代器，让它每隔 <code>n</code> 个元素生成一个元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain">chain(other)</a>：将两个迭代器粘合在一起构造一个组合迭代器，它会在遍历完第一个迭代器的内容后开始遍历第二个迭代器。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cycle">cycle()</a>：将迭代器转换为一个永久循环的迭代器，当遍历到头后再次从头开始遍历。（迭代器需要实现 <code>Clone</code> 来支持这个方法。）</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev">rev()</a>：反转迭代器的方向。（迭代器需要实现 <a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html">DoubleEndedIterator</a> trait，这个 trait 有一个额外的 <a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back">next_back</a> 方法。）</li>
</ul>
<p>其他的转换会影响到 <code>Iterator</code> 对应的 <code>Item</code> 的性质/属性：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map">map(|item| {...})</a>：重复应用闭包依次转换迭代的元素。这是最通用的转换，这个列表中的以下若干个方法都可以用 <code>map</code> 等价地实现。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned">clone()</a>：产生原始迭代器中元素的一个克隆；这个方法在遍历 <code>&amp;Item</code> 这种引用的时候十分有用。（显然这需要底层类型 <code>Item</code> 实现 <code>Clone</code>。）</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.copied">copied()</a>：产生原始迭代器中元素的一个拷贝；这个方法在遍历 <code>&amp;Item</code> 这种引用的时候十分有用。（显然这需要底层类型 <code>Item</code> 实现 <code>Copy</code>，如果是这样的话，那么有可能会比 <code>cloned()</code> 要快一些。）</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate">enumerate()</a>：将迭代器转换成迭代 <code>(usize, Item)</code> 值对的迭代器，提供了迭代器中元素的索引。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip">zip(it)</a>：将一个迭代器和另一个迭代器联结，构建一个组合迭代器，用于产生值对，每一个值对里面的元素分别来自于两个迭代器，组合迭代器会一直产生元素直到元素较少的迭代器迭代完毕。</li>
</ul>
<p>还有一些转换可以对 <code>Iterator</code> 产生的 <code>Item</code> 进行过滤：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter">filter(|item| {...})</a>：对每个元素的引用应用一个返回布尔值的闭包，来判断这个元素是否应该要被迭代器提供。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while">take_while()</a>：基于谓词提供迭代器初始区间中的元素。是 <code>skip_while</code> 的镜像。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip_while">skip_while()</a>：基于谓词提供迭代器末端区间中的元素。是 <code>take_while</code> 的镜像。</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten">flatten</a> 方法用于处理元素类型还是迭代器类型的迭代器，用于展平结果。单就这个方法来看这好像没有什么用，但是我们发现当 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.iter">Option</a> 和 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.iter">Result</a> 类型用作迭代器的时候，这就很有用了：这两个类型会产生零（<code>None</code>，<code>Err(e)</code>）或者一（<code>Some(v)</code>，<code>Ok(v)</code>）。这意味着 <code>flatten</code> 一个 <code>Option</code> 或者 <code>Result</code> 的流是一个提取其中有效值的简单方式。</p>
<p>从整体上看，上面提到的方法允许对迭代器进行转换，以便迭代器精确地生成大多数情况下所需要的元素序列。</p>
<h2 id="chapter_1-item9-iterators-iterator-consumers-迭代器消耗者"><a class="header" href="#chapter_1-item9-iterators-iterator-consumers-迭代器消耗者">Iterator Consumers 迭代器消耗者</a></h2>
<p>前面两节介绍了如何获取迭代器，以及如何对其进行合适的转换来进行精准的迭代。这种目的明确的迭代也可以通过显式循环的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
    even_sum_squares += value * value;
}
<span class="boring">}</span></code></pre></pre>
<p>但同时 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> 提供的方法集里面还包含了许多可以消费整个迭代以获得结果的方法，从而可以让我们消除显式的 <code>for</code> 循环。</p>
<p>这些方法中最常见的是 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each">for_each(|item| {...})</a>，它会对 <code>Iterator</code> 产生的每个元素应用一个闭包。这可以完成<em>绝大多数</em>显式 <code>for</code> 循环可以完成的工作（除了少量例外，我们会在后面的部分中提到）。但它的普适性也让它用起来有点尴尬——闭包需要捕获对外部状态的可变引用才能“返回”结果：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
values
    .iter()
    .filter(|x| *x % 2 == 0)
    .take(5)
    .for_each(|value| {
        // closure needs a mutable reference to state elsewhere
        even_sum_squares += value * value;
    });
<span class="boring">}</span></code></pre></pre>
<p>但是如果 <code>for</code> 循环的循环体跟一些常见的模式之一匹配，那么就有更特化的方法来“消费”迭代器，这些方法往往更清晰、简短且符合惯用法。</p>
<p>这些模式包括从一个集合中生成一个值的便捷方法：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum">sum()</a>：对数值（整型或浮点型）类型的集合求和。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.product">product()</a>：将数值类型集合中的元素相乘。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min">min()</a>：使用 <code>Item</code> 的 <code>Ord</code> 实现，寻找集合中的最小值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max">max()</a>：使用 <code>Item</code> 的 <code>Ord</code> 实现，寻找集合中的最大值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min_by">min_by(f)</a>：使用用户提供的比较函数 <code>f</code>，寻找集合中的最小值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by">max_by(f)</a>：使用用户提供的比较函数 <code>f</code>，寻找集合中的最大值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce">reduce(f)</a>：通过在每次迭代中执行闭包来计算 <code>Item</code> 的求和值，闭包会接收截止目前的求和值和当前遍历的元素作为参数。这是一个更通用的操作，包含（可以用于实现）前面提到的一些方法。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold">fold(f)</a>：通过在每次迭代中执行闭包来计算任意类型（而不限于 <code>Iterator::Item</code> 类型）的求和值，闭包会接收截止目前的求和值和当前遍历的元素作为参数。这是 <code>reduce</code> 的更泛化的版本。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan">scan(init, f)</a>：通过在每次迭代中执行闭包来计算某个特定类型的求和值，闭包会接收某种内部状态的可变引用和当前遍历的元素作为参数。这是一个稍特别的 <code>reduce</code> 的泛化版本。</li>
</ul>
<p>还有一些方法可以用从集合中<em>选择</em>一个值：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find">find(p)</a>：查找第一个满足谓词的元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position">position(p)</a>：也是查找第一个满足谓词的元素，不过返回元素对应的索引。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth">nth(n)</a>：如果有，返回迭代的第 <code>n</code> 的元素。</li>
</ul>
<p>还有一些方法可以针对集合中的每个元素进行测试：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any">any(p)</a>：返回谓词是否对集合中的<em>任一</em>元素成立。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all">all(p)</a>：返回谓词是否对集合中的<em>所有</em>元素成立。</li>
</ul>
<p>对于上面两个方法之一，如果遍历过程中找到一个反例，迭代都会提前终止。</p>
<p>有一些方法允许闭包在对元素操作的时候返回失败。在这种场景下，如果闭包对某个元素的操作返回失败，迭代将终止，并返回第一个导致失败产生的操作：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each">try_for_each(f)</a>：行为类似于 <code>for_each</code>，但闭包操作可能会失败。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold">try_fold(f)</a>：行为类似于 <code>fold</code>，但闭包操作可能会返回失败。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_find">try_find(f)</a>：行为类似于 <code>find</code>，但闭包操作可能会返回失败。</li>
</ul>
<p>最后，还有一些方法可以把所有迭代的元素累积到新的集合中。当中最重要的就是 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect()</a> 方法，它可以用于创建任意一种实现了 <a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html">FromIterator</a> 特征的集合类型。</p>
<p><code>FromIterator</code> traits 在所有的标准库集合类型上都有实现（<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-FromIterator%3CT%3E">Vec</a>,<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-FromIterator%3C(K%2C%20V)%3E">HashMap</a>,<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E">BTreeSet</a> 等），但这种普遍性也意味着你总是要显式地指定集合的类型，否则编译器无法推断出你想要组装一个（比如说）<code>Vec&lt;i32&gt;</code> 还是 <code>HashSet&lt;i32&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

// Build collections of even numbers.  Type must be specified, because
// the expression is the same for either type.
// 创建一个只有偶数的集合。你必须指定集合的类型，因为对于两个集合来说构造的表达式一模一样。
let myvec: Vec&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
let h: HashSet&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
<span class="boring">}</span></code></pre></pre>
<p>这个例子也展示了如何使用范围表达式 <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expressions</a> 来生成要迭代的初始数据。</p>
<p>还有一些其他（更加晦涩）的集合生成方法：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip">unzip()</a>：将一个 pair 的迭代器拆分到两个集合中。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition">partition(p)</a>：通过应用谓词到元素上，把一个迭代器迭代的内容切分到两个集合中。</li>
</ul>
<p>本条款涉及了很多 <code>Iterator</code> 相关的方法，但这仅仅是所有可用方法的子集；要想了解更多，可以参考文档 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator documentation</a> 或者 <em>Programming Rust</em> 第二版（O'Reilly）的 15 章，书里更详细地介绍了各种可能的用法。</p>
<p>丰富的迭代器转换方法集合在日常中就这么触手可及，这些方法可以让代码变得更符合惯用法、更紧凑，同时更好地表达代码的意图。</p>
<p>将循环表达式转换成迭代器转换还有助于生成更高效的代码。为了安全起见，Rust 在访问诸如 vector 和切片这种连续的容器时会对访问执行<em>边界检查</em>；任何尝试访问越界的元素的操作都会导致 panic 而不是访问无效的数据。传统的访问容器值的方法（如 <code>values[i]</code>）<em>可能</em>会受到这些运行时检查的介入，而一个逐步提供值的迭代器可以被认为是不会越界的。</p>
<p>但是，与迭代器转换等效的传统循环表达式也可能<em>不会</em>受到额外的边界检查的影响。Rust 的编译器和优化器很擅长分析切片访问的上下文代码来决定跳过边界检查是否安全可行的；Sergey "Shnatsel" Davidoff 的文章 <a href="https://shnatsel.medium.com/how-to-avoid-bounds-checks-in-rust-without-unsafe-f65e618b4c1e">2023 article</a> 探讨了其中的细节。</p>
<h2 id="chapter_1-item9-iterators-从-result-值构建集合"><a class="header" href="#chapter_1-item9-iterators-从-result-值构建集合">从 Result 值构建集合</a></h2>
<p>上一节我们介绍了如何用 <code>collect()</code> 从迭代器构建集合，但同时 <code>collect()</code> 对于处理 <code>Result</code> 值的场景也有特别有用的特性。</p>
<p>考虑一个例子，将一个 <code>u64</code> 的 vector 转成字节 <code>u8</code>，并期望它们都满足条件：</p>
<div class="ferris"><img src="chapter_1/../images/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In the 2021 edition of Rust, `TryFrom` is in the prelude, so this
// `use` statement is no longer needed.
use std::convert::TryFrom;

let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4];
let result: Vec&lt;u8&gt; = inputs
    .into_iter()
    .map(|v| &lt;u8&gt;::try_from(v).unwrap())
    .collect();
<span class="boring">}</span></code></pre></pre>
<p>这是可以的，直到有一些意外的输入：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4, 512];
<span class="boring">}</span></code></pre></pre>
<p>这将导致运行时的失败：</p>
<pre><code class="language-shell">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:
TryFromIntError(())', iterators/src/main.rs:266:36
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>根据 <a href="#chapter_1-item3-transform">第 3 条</a> 的建议，我们希望保留 <code>Result</code> 类型并且使用 <code>?</code> 运算符让任何一个失败的操作作为调用代码的问题返回。修改让代码返回 <code>Result</code> 达不到我们的目的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: Vec&lt;Result&lt;u8, _&gt;&gt; =
    inputs.into_iter().map(|v| &lt;u8&gt;::try_from(v)).collect();
// Now what?  Still need to iterate to extract results and detect errors.
<span class="boring">}</span></code></pre></pre>
<p>但是还有另一种 <code>collect()</code> 的版本，可以组装一个持有 <code>Vec</code> 的 <code>Result</code>，而不是一个装着 <code>Result</code> 的 <code>Vec</code>。</p>
<p>想要强制使用这个版本就要用到 turbofish 语法（<code>::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;</code>）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: Vec&lt;u8&gt; = inputs
    .into_iter()
    .map(|v| &lt;u8&gt;::try_from(v))
    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
<span class="boring">}</span></code></pre></pre>
<p>将其与问号运算符结合使用实现了一种有用的行为：</p>
<ul>
<li>如果迭代遇到了错误，错误的值会返回到调用方，并且迭代终止。</li>
<li>如果没有遇到错误，则余下代码能处理返回一个合理、类型正确的值的集合。</li>
</ul>
<h2 id="chapter_1-item9-iterators-转换显式循环"><a class="header" href="#chapter_1-item9-iterators-转换显式循环">转换显式循环</a></h2>
<p>这个条款的目的是让你相信很多显式循环都可以被当做基于迭代器的转换。这对于不习惯的程序员来说可能会让人觉得不太自然，所以我们来一步步完成一次转换吧。</p>
<p>我们从一个很 C 语言风格的循环开始，对一个 vector 的头五个偶数项求平方和：</p>
<pre><code class="language-c">let mut even_sum_squares = 0;
let mut even_count = 0;
for i in 0..values.len() {
    if values[i] % 2 != 0 {
        continue;
    }
    even_sum_squares += values[i] * values[i];
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
</code></pre>
<p>第一步是把 vector 的索引换成 for-each 循环的迭代器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
let mut even_count = 0;
for value in values.iter() {
    if value % 2 != 0 {
        continue;
    }
    even_sum_squares += value * value;
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>使用 <code>continue</code> 来跳过某些元素的原始代码分支可以用 <code>filter()</code> 来很自然地表达：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
let mut even_count = 0;
for value in values.iter().filter(|x| *x % 2 == 0) {
    even_sum_squares += value * value;
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>接下来，一旦我们有 5 个元素了，我们就提前退出循环，这里用 <code>take(5)</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
    even_sum_squares += value * value;
}
<span class="boring">}</span></code></pre></pre>
<p>每次迭代我们都只要元素的平方值 <code>value * value</code>，这就是 <code>map()</code> 理想的使用场景：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
for val_sqr in values.iter().filter(|x| *x % 2 == 0).take(5).map(|x| x * x)
{
    even_sum_squares += val_sqr;
}
<span class="boring">}</span></code></pre></pre>
<p>对原始循环的重构最后成为了 <code>sum()</code> 方法大锤下一颗完美的钉子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let even_sum_squares: u64 = values
    .iter()
    .filter(|x| *x % 2 == 0)
    .take(5)
    .map(|x| x * x)
    .sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_1-item9-iterators-什么时候显式循环更好"><a class="header" href="#chapter_1-item9-iterators-什么时候显式循环更好">什么时候显式循环更好</a></h2>
<p>这条条款强调了迭代器转换的又是，特别是在简洁性和清晰度方面。那么什么时候迭代器转换<em>不是</em>那么适合或者不符合惯用法呢？</p>
<ul>
<li>
<p>如果循环体很大、或者功能很多，那么保留在一个显式的循环体里面会比把逻辑压缩到闭包中更合理。</p>
</li>
<li>
<p>如果循环体包含很多会导致功能提前终止的错误条件，最好还是把它们保留在显式的循环体中—— <code>try...()</code> 之类的方法也不会帮上很多忙。但是，<code>collect()</code> 能把一个值类型为 <code>Result</code> 的集合转换成一个持有集合类型的 <code>Result</code> 类型的能力，在配合 <code>?</code> 运算符的场景下还是可以进行错误条件的处理。</p>
</li>
<li>
<p>如果性能至关重要，包含闭包的迭代器转换<em>理应</em>跟显式的代码一样快 <a href="https://doc.rust-lang.org/book/ch13-04-performance.html">just as fast</a>。但如果代码中一个核心的循环很重要，<em>测量</em>不同的实现方法并进行适当的调优。</p>
<ul>
<li>请确保你的测试能反映实际的性能——编译器的优化可能会对测试数据给出过于乐观的结果（如 <a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a> 所述）。</li>
<li><a href="https://rust.godbolt.org/">Godbolt compiler explorer</a> 是一个了不得的工具，你可以看到编译器都生成了什么。</li>
</ul>
</li>
</ul>
<p>最重要的，如果转换的过程是强制的或者生搬硬套的，那么就不要把显式循环转成迭代器转换了。这不过是一种编程风格口味的取向而已——但注意到，随着你对函数式的风格越来越熟悉，你的口味也很可能会发生变化。</p>
<hr />
<p><a id="chapter_1-item9-iterators-footnote-1">1</a>:事实上，迭代器可以更通用——在直到结束之前不停地产生下一个元素，这种想法不必跟某种容器强关联。</p>
<p><a id="chapter_1-item9-iterators-footnote-2">2</a>:如果对容器元素的修改可能会导致容器内部的一些约束被打破，那么这个方法就不能提供了。比如说：导致元素的 <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a> 值发生变化的修改，就可能会导致 <code>HashMap</code> 内部数据结构的失效。</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_2"></div><h1 id="chapter_2-特征traits"><a class="header" href="#chapter_2-特征traits">特征（Traits）</a></h1>
<p>Rust 类型系统的第二个核心支柱是特征（<code>traits</code>）的使用，它允许编码在不同类型之间通用的行为。特征在其他语言中大致等同于接口类型，但它们也与 Rust 的泛型（<a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a>）相关联，允许在不产生运行时开销的情况下重用接口。</p>
<p>本章中的条目描述了 Rust 编译器和 Rust 工具链提供的标准特征，并提供了关于如何设计和使用特征编码行为的建议。</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_2-item10-std-traits"></div><h1 id="chapter_2-item10-std-traits-第-10-条熟悉标准库的-traits"><a class="header" href="#chapter_2-item10-std-traits-第-10-条熟悉标准库的-traits">第 10 条：熟悉标准库的 traits</a></h1>
<p>Rust 通过一系列详细的、描述类型行为的标准库 traits，把类型系统自身的关键行为特征编码到了类型系统本身上（参考 <a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>）。</p>
<p>其中的许多 traits 对于 C++ 程序员来说会感觉很熟悉，类比于拷贝构造函数、析构函数、相等性判断和复制运算符等等。</p>
<p>和在 C++ 中一样，为用户的自定义类型实现标准库当中的多数 traits 是个不错的选择；Rust 编译器会在用户的自定义类型需要某些 traits，而类型又缺少对应实现的时候给出有用的错误信息。</p>
<p>实现这么多的 traits 看起来有点吓人，但当中绝大多数的 traits 都可以通过 <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"><code>derive</code> macros</a> 自动应用到用户的自定义类型上。 <code>derive</code> 宏会基于类型生成相应的实现（例如：对于 <code>struct</code> 的字段逐一进行 <code>Eq</code> 判断）；这通常要求结构体的组成部分也实现了对应的 trait。自动生成的实现<em>通常</em>就是你会需要的，但也有例外，我们会在后面讨论具体 trait 的时候提到。</p>
<p>使用 <code>derive</code> 宏会让类型的定义看着像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
enum MyBooleanOption {
    Off,
    On,
}
<span class="boring">}</span></code></pre></pre>
<p>这里就触发了对于 8 个不同的 trait 实现的自动生成。</p>
<p>这种细粒度的行为规范一开始可能会让人觉得不适应，但熟悉最常见的标准库 traits 非常重要，这样才能快速了解到一个类型的定义中给它赋予的各种可用行为。</p>
<h2 id="chapter_2-item10-std-traits-常见的标准库-traits"><a class="header" href="#chapter_2-item10-std-traits-常见的标准库-traits">常见的标准库 traits</a></h2>
<p>这一节讨论最常遇到的标准库 traits。以下是对这些 traits 粗略的一句话总结：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a>：需要时，该类型的实例可以通过执行用户定义的代码来创建自身的一个副本。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a>：如果编译器对类型实例的内存表示数据执行按比特拷贝，会得到一个有效的新副本。</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a>：可以使用合理的默认值创建该类型的实例。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>：该类型的实例之间存在偏序关系 <a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence relation</a>——任意两个实例可以明确地进行比较，但 <code>x == x</code> 并不总为真。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a>：该类型的实例之间存在等价关系 <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>，——任意两个实例可以明确地进行比较，且 <code>x == x</code> 总为真。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a>：该类型的某些实例之间可以进行比较和排序。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a>：该类型的所有实例之间可以进行比较和排序。</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a>：该类型的实例可以在需要的时候生成一个稳定的散列值（哈希值）。</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a>：该类型的实例可以对程序员显示（调试信息）。</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a>：该类型的实例可以对用户显示。</li>
</ul>
<p>除了 <code>Display</code> （因为与 <code>Debug</code> 功能有重叠）以外，这些 traits 都可以通过 <code>derive</code> 为用户自定义类型派生。然后有些时候手动实现——或者说不实现这些 traits 可能是个更好的选择。</p>
<p>下面的小节会更详细地讨论这些常见的 traits。</p>
<h1 id="chapter_2-item10-std-traits-clone"><a class="header" href="#chapter_2-item10-std-traits-clone"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a></a></h1>
<p><code>Clone</code> trait 表示可以通过调用 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone">clone()</a> 函数来创建一个对象的新副本。这跟 C++ 的拷贝函数大致相同，但是表意更加明确：编译器不会默默地调用这个函数（下一节会更详细地说明）。</p>
<p>如果一个类型的所有字段都实现了 <code>Clone</code> ，那么可以通过 <code>derive</code> 为这个类型自动派生 <code>Clone</code>。<code>derive</code> 派生获得的实现会对类型的每个成员依次执行克隆操作；再说一次，这跟 C++ 的构造函数大致相同。这个 trait 需要显式地启用（通过添加 <code>#[derive(Clone)]</code>），这与 C++ 中需要显式禁止（<code>MyType(const MyType&amp;) = delete;</code>）恰恰相反。</p>
<p>派生 <code>Clone</code> 是一个常见且有用的操作，以至于去考虑是否应该实现 <code>Clone</code>、评估默认派生的实现是否符合实际要求变得更加有意思了。</p>
<ul>
<li>如果一个类型的实例持有某些资源的唯一访问权（例如 RAII 类型 <a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a>），或者有其他原因限制拷贝（例如对象持有了加密密钥），那么你<em>不应该</em>实现 <code>Clone</code>。</li>
<li>如果类型的某些部分不是 <code>Clone</code> 的，那么你也<em>无法</em>实现 <code>Clone</code>：
<ul>
<li>字段是可变引用（<code>&amp;mut T</code>），因为借用检查器（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）在同一时刻只允许一个对同一资源的可变引用的存在。</li>
<li>属于上述类别的标准库类型，例如 <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html">MutexGuard</a>（体现唯一访问权）或者 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex</a>（出于线程安全限制拷贝）。</li>
</ul>
</li>
<li>如果类型的任何部分不能通过（递归的）字段拷贝，或者有生命周期相关的簿记动作需要执行，那么你需要<em>手动</em>实现 <code>Clone</code>。举个例子，考虑一个在运行时跟踪所有实例数量的类型，你需要手动实现 <code>Clone</code> 来保证计数器的准确。</li>
</ul>
<h1 id="chapter_2-item10-std-traits-copy"><a class="header" href="#chapter_2-item10-std-traits-copy"><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a></a></h1>
<p><code>Copy</code> trait 有一个简单的声明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>这个 trait 里面没有方法，这意味这是一个标记 trait <code>marker trait</code>（如同<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>中所述）：这是用来表示对类型的某些约束，而这种约束本身没有在类型系统中表达。</p>
<p>对于 <code>Copy</code> 而言，这个标记表示，对类型实例的内存进行按比特的拷贝，可以得到一个正确的新对象。实际上，这个 trait 是一个标记，表示一个类型是 <a href="https://en.wikipedia.org/wiki/Passive_data_structure">plain old data</a>（POD）类型。</p>
<p>这也意味着 <code>Clone</code> 特性可能会有点令人困惑：尽管实现了 <code>Copy</code> 的类型需要实现 <code>Clone</code>，但是当一个实例被拷贝的时候，<code>clone()</code> 方法并<em>没有</em>被调用——编译器在不使用任何用户定义代码的情况下生成了一个新的对象。</p>
<p>跟其他用户自定义的标记 trait（<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>）相比，<code>Copy</code> 对编译器有着比作为 trait bound 以外更特殊的意义（和其他 <code>std::marker</code> 中的其他几个 trait 一样）——它使编译器在处理类型的时候从<em>移动语意</em>变成<em>拷贝语义</em>。</p>
<p>在移动语义的场景下，赋值运算符会把运算符右侧的内容，拿走并赋值给左边：</p>
<div class="ferris"><img src="chapter_2/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
struct KeyId(u32);

let k = KeyId(42);
let k2 = k; // value moves out of k into k2
println!("k = {k:?}");
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: borrow of moved value: `k`
  --&gt; src/main.rs:60:23
   |
58 |         let k = KeyId(42);
   |             - move occurs because `k` has type `main::KeyId`, which does
   |               not implement the `Copy` trait
59 |         let k2 = k; // value moves out of k into k2
   |                  - value moved here
60 |         println!("k = {k:?}");
   |                       ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl`
help: consider cloning the value if the performance cost is acceptable
   |
59 |         let k2 = k.clone(); // value moves out of k into k2
   |                   ++++++++
</code></pre>
<p>而使用拷贝语义的话，被用于赋值的变量在赋值过后依然存在：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]
struct KeyId(u32);

let k = KeyId(42);
let k2 = k; // value bitwise copied from k to k2
println!("k = {k:?}");
<span class="boring">}</span></code></pre></pre>
<p>这使得 <code>Copy</code> 成为了最需要注意的 trait 之一：它从根本上改变了赋值的行为——包括方法调用时候的传参。</p>
<p>在这方面，这跟 C++ 的拷贝构造函数又有相似了，但是值得强调的一个关键区别在于：在 Rust 里面没有办法让编译器隐式调用用户定义的代码——要调用的话必须显式指定（比如使用 <code>.clone()</code>），或者让编译器执行并非由用户定义的代码（按比特位的拷贝动作）。</p>
<p>因为 <code>Copy</code> 具有 <code>Clone</code> trait 的特性，所以是可以 <code>.clone()</code> 任意一个满足 <code>Copy</code> 的对象的。但是这不是一个好的主义：按位拷贝总是会比调用 trait 方法要快。Clippy（<a href="https://www.lurklurk.org/effective-rust/clippy.html">第 29 条</a>）会提示你：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let k3 = k.clone();
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">warning: using `clone` on type `KeyId` which implements the `Copy` trait
  --&gt; src/main.rs:79:14
   |
79 |     let k3 = k.clone();
   |              ^^^^^^^^^ help: try removing the `clone` call: `k`
   |
</code></pre>
<p>跟讨论 <code>Clone</code> 的时候类似，何时应该或不应该实现 <code>Copy</code> 也是值得探讨的：</p>
<ul>
<li>显而易见：<strong>如果按比特位拷贝不能生成有效的新对象，不要实现 <code>Copy</code></strong>。如果 <code>Clone</code> 需要手动而不是通过 <code>derive</code> 实现，那么很有可能是这种情况。</li>
<li>如果你的类型比较大，实现 <code>Copy</code> 可能是个坏主意。<code>Copy</code> 的基本约定是安比特位拷贝是合法的，然而这也通常隐含一个假设：拷贝是很快速的。如果你的类不符合这样的要求，不实现 <code>Copy</code> 可以阻止意外的耗时拷贝的发生。</li>
<li>如果你的类型中某些部分不是 <code>Copy</code> 的那么你也<em>不能</em>为类型实现 <code>Copy</code>。</li>
<li>如果你的类型中所有部分都是 <code>Copy</code> 的，那么通常也值得为你的类型 derive 一个 <code>Copy</code>。编译器有一个默认的提示项 <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#missing-copy-implementations">missing_copy_implementations</a> 来指出这种情况。</li>
</ul>
<h1 id="chapter_2-item10-std-traits-default"><a class="header" href="#chapter_2-item10-std-traits-default"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a></a></h1>
<p><code>Default</code> trait 通过 <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default()</a> 方法定义了一个<em>默认构造函数</em>。如果用户定义类型的内含类型都有 <code>Default</code> 的实现，那么类型可以通过 <code>derive</code> 来实现这个 trait；如果内含类型并非都实现了 <code>Default</code>，那么用户需要手动为类型实现 这个 trait。还是跟 C++ 做比较：在 Rust 中需要显式地定义默认构造函数——编译器不会自动帮你创建。</p>
<p><code>enum</code> 类型也可以通过 <code>derive</code> 实现 <code>Default</code> trait，只要给编译器提供一个 <code>#[default]</code> 属性来提示编译器哪一个分支是默认值即可：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum IceCreamFlavor {
    Chocolate,
    Strawberry,
    #[default]
    Vanilla,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Default</code> trait 最有用的一个场景是和结构体更新语法 <a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax">struct update syntax</a> 组合使用。这个语法允许 <code>struct</code> 实例通过从同一种 <code>struct</code> 的实例中拷贝或者移动内容来初始化自身尚未尚未显式初始化的字段。要被拷贝的模板在初始化结束的时候给出，放在 <code>..</code> 之后，<code>Default</code> trait 提供了一个理想的模板供使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
    alpha: u8,
}

let c = Color {
    red: 128,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>这使得初始化具有大量字段，但仅有部分字段不是使用默认值的结构体变得更加容易。（构造器模式，<a href="https://www.lurklurk.org/effective-rust/builders.html">第 7 条</a>，或许对于这种场景也是适用的）。</p>
<h2 id="chapter_2-item10-std-traits-partialeq-和-eq"><a class="header" href="#chapter_2-item10-std-traits-partialeq-和-eq"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a> 和 <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a></a></h2>
<p><code>PartialEq</code> 和 <code>Eq</code> trait 允许你为用户定义的类型定义相等性。这些 trait 尤其重要，因为如果这些 trait 被定义了，编译器会自动在相等性（<code>==</code>）判断的时候调用相关逻辑，类比于 C++ 中的 <code>operator==</code>。<code>derive</code> 来的实现会执行逐字段的相等性判断。</p>
<p><code>Eq</code> 版本只是一个标记 trait，用于扩展 <code>PartialEq</code>，它添加了<em>自反性</em>：任何声明了 <code>Eq</code> 的类型 <code>T</code>，对于任意的实例 <code>x: T</code> 都应该保证有 <code>x == x</code>。</p>
<p>这很奇怪，你会立即提出这个问题：什么时候 <code>x == x</code> 是不成立的？对相等性的这种拆分主要跟浮点数 <a href="#chapter_2-item10-std-traits-footnote-1">floating point numbers</a>。 有关，尤其是涉及到“不是数字”这个 NaN 值（对应 Rust 中的 <code>f32:NAN</code>/<code>f64:NAN</code>）。浮点数的标准要求任何东西不会等于 NaN，<em>包括 Nan 自身</em>；<code>PartialEq</code> trait 的存在就是这种要求的连锁反应。</p>
<p>对于没有任何浮点数相关的特性的用户自定义类型，<strong>你应该在实现 <code>PartialEq</code> 的同时也实现 <code>Eq</code></strong>。如果你要把类型当作 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a> 类型的 key，完整的 <code>Eq</code> trait 也是需要实现的（同样还有 <code>Hash</code> trait）。</p>
<p>如果类型包含一些不影响区分相等性的字段（如内部缓存或者其他类型的性能优化），则应该手动实现 <code>PartialEq</code>。如果 <code>Eq</code> 也被定义了，实现也将用于 <code>Eq</code>，因为 <code>Eq</code> 只是一个标记 trait，它内部并没有任何方法。</p>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a> 和 <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a></p>
<p>排序 trait <code>PartialOrd</code> 和 <code>Ord</code> 允许比较同一类型的两个实现，并返回 <code>Less</code>、<code>Greater</code> 或 <code>Equal</code> 之一。这两个 trait 需要对应的相等性 trait 有对应的实现（<code>PartialOrd</code> 要求 <code>PartialEq</code>; <code>Ord</code> 要求 <code>Eq</code>），并且对应的两个必须逻辑自洽（手动实现的时候尤其要注意）。</p>
<p>跟相等性 trait 一样，比较 traits 也很重要，因为编译器会在比较运算中使用到它们（<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>）。</p>
<p><code>derive</code> 产生的默认实现会按照字段（或 <code>enum</code> 的不同 variant）定义的顺序，按照字典序进行比较。如果这不符合预期结果则需要手动实现特征（或者对字段进行重新排序）。</p>
<p>跟 <code>PartialEq</code> 不同的是，<code>PartialOrd</code> trait 确实对应各种真实发生的场景。比如说，它可以用于表示集合之间的子集关系(#footnote-2)：<code>{1, 2}</code> 是 <code>{1, 2, 4}</code> 的子集，但 <code>{1, 3}</code> 不是 <code>{2, 4}</code> 的子集，反之亦然。</p>
<p>但是，即使偏序关系准确地描述了你的类型的行为，<strong>要小心仅仅实现了 <code>PartialOrd</code> 而没有实现 <code>Ord</code> 的场景</strong>（这种情况很少见，它与 <a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a> 中将行为编码到类型系统中的建议相违背）——它可能会导致令人惊讶的结果：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Inherit the `PartialOrd` behavior from `f32`.
// 从 `f32` 继承 `PartialOrd`
#[derive(PartialOrd, PartialEq)]
struct Oddity(f32);

// Input data with NaN values is likely to give unexpected results.
// NaN 值的输入可能会给出意想不到的结果。
let x = Oddity(f32::NAN);
let y = Oddity(f32::NAN);

// A self-comparison looks like it should always be true, but it may not be.
// 一个看起来应该总是成立的自我比较，但也可能不成立。
if x &lt;= x {
    println!("This line doesn't get executed!");
}

// Programmers are also unlikely to write code that covers all possible
// comparison arms; if the types involved implemented `Ord`, then the
// second two arms could be combined.
// 程序员也不太可能写出覆盖所有可能的比较分支；如果涉及的类型实现了 `Ord`，那么后两种情况可以合并。
if x &lt;= y {
    println!("y is bigger"); // Not hit.
} else if y &lt; x {
    println!("x is bigger"); // Not hit.
} else {
    println!("Neither is bigger");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_2-item10-std-traits-hash"><a class="header" href="#chapter_2-item10-std-traits-hash"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a></a></h2>
<p><code>Hash</code> trait 用于给某个对象生成一个大概率与其他对象不相同的值。这个哈希值通常用于一些基于哈希桶的数据结构，比如 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a> 和 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashSet</a>；因此，这些数据结构中的 key 类型必须实现 <code>Hash</code> （和 <code>Eq</code>）。</p>
<p>反过来说，“相同”的项（以 <code>Eq</code> 来说）必须产生一样的的哈希值：如果 <code>x  y</code> （通过 <code>Eq</code>），那么 <code>hash(x)  hash(y)</code> 必须始终为真。**如果你手动实现了 <code>Eq</code>，那么要检查确认你是否也需要手动实现 <code>Hash</code>**以满足上述要求。</p>
<h2 id="chapter_2-item10-std-traits-debug-和-display"><a class="header" href="#chapter_2-item10-std-traits-debug-和-display"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> 和 <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a></a></h2>
<p><code>Debug</code> 和 <code>Display</code> trait 允许类型定义它在输出中应该怎么显示，这包括常规显示（<code>{}</code> 格式化参数）和调试（<code>{:?}</code> 格式化参数）目的，这大致类似于 C++ 中对 <code>iostream</code> 的 <code>operator&lt;&lt;</code> 重载。</p>
<p>这两个 trait 的设计意图差异不仅仅在于格式化占位符的不同，还包括：</p>
<ul>
<li><code>Debug</code> 可以自动派生 <code>derive</code> 获得，而 <code>Display</code> 只能手动实现。</li>
<li><code>Debug</code> 的输出格式在不同的 Rust 版本下可能会不一样。如果输出需要被其他的代码做解析，那么使用 <code>Display</code>。</li>
<li><code>Debug</code> 是面向程序员的， <code>Display</code> 是面向用户的。一个有助于理解这个场景的头脑风暴是：如果程序被本地化到程序作者不懂的语言会发生什么——如果显示的内容应该被翻译，那么使用 <code>Display</code> 是合适的，否则就应该使用 <code>Debug</code>。</li>
</ul>
<p>通常来说，<strong>给你的类型添加一个自动生成的 <code>Debug</code> 实现是个不错的选择</strong>，除非类型里面包含一些敏感信息（个人详细信息、密码相关的内容等）。为了更容易遵守这个规则，Rust 编译器有一个提示 <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#missing-debug-implementations">missing_debug_implementations </a> 可以指出没有实现 <code>Debug</code> 的类型。这个提示默认是禁用的，但可以通过以下任一方式在你的代码中启用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(missing_debug_implementations)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![deny(missing_debug_implementations)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>如果自动生成的 <code>Debug</code> 实现输出了太多细节信息，那么或许手动实现并且汇总一下类型里面的内容会更好一点。</p>
<p>如果你的类型要作为文本向最终用户显示，那么就实现 <code>Display</code>。</p>
<h2 id="chapter_2-item10-std-traits-其他条款描述的标准库-trait"><a class="header" href="#chapter_2-item10-std-traits-其他条款描述的标准库-trait">其他条款描述的标准库 trait</a></h2>
<p>除了前面章节描述的常见 trait，标准库还包含其他没那么常见的 trait。在这些之中，以下是最重要的，但它们都在其他条款中有所介绍，因此这里不会详细地介绍：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a>，<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a>：实现了这些 trait 的对象代表它们是可以被调用的闭包。见<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/error/trait.Error.html">Error</a>：实现了这个 trait 的对象可以向用户或程序员呈现错误信息，并且可能包含嵌套的子错误信息。见<a href="https://www.lurklurk.org/effective-rust/errors.html">第 4 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a>：实现了这个 trait 的对象会在它们被销毁的时候执行动作，这对于 RAII 模式来说是至关重要的。见<a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom</a>：实现了这些 trait 的对象，可以自动从别的类型的实例中转换过来，但后一个 trait 表示转换可能会失败。见<a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html">DerefMut</a>：实现了这些 trait 的对象是类似于指针的对象，它们可以被解引用以获得对内部对象的访问。见<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>。</li>
<li><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> 及相关：实现了这些 trait 的对象表示可以它是一个可以被迭代的集合。见<a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>：实现了这个 trait 的对象可以在多个线程之间安全地传输。见<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>：实现了这个 trait 的对象可以在多个线程之间被安全地引用。见<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>。</li>
</ul>
<p>这些 trait 都不能被直接 <code>derive</code> 获得。</p>
<h2 id="chapter_2-item10-std-traits-运算符重载"><a class="header" href="#chapter_2-item10-std-traits-运算符重载">运算符重载</a></h2>
<p>标准库 trait 的最后一个类别跟运算符重载有关，Rust 允许用户自定义类型通过实现 <a href="https://doc.rust-lang.org/std/ops/index.html">std::ops</a> 模块里面的标准库 trait，对内置的单目和双目运算符进行重载。这些 trait 不能通过 <code>derive</code> 获得，通常仅用于表示“代数”类型的对象，对于这些类型来说这些运算符都有很自然的解释。</p>
<p>然而，C++ 中的经验表明，最好<strong>避免对不相关的类型进行运算符重载</strong>，因为它通常会导致代码难以维护，也可能会出现一些意外的性能问题（比如，一个 <code>x + y</code> 操作调用了一个开销为 O(N) 方法）。</p>
<p>为了遵循最小惊讶原则，如果你实现了任何一个运算符重载，那么你应该<strong>实现一系列相关的运算符的重载</strong>。打个比方，如果 <code>x + y</code> 有一个重载（<a href="https://doc.rust-lang.org/std/ops/trait.Add.html">Add</a>），并且 <code>-y</code>（<a href="https://doc.rust-lang.org/std/ops/trait.Neg.html">Neg</a>）也有，那么你应该实现 <code>x - y</code>（<a href="https://doc.rust-lang.org/std/ops/trait.Sub.html">Sub</a>）并确保它给出和 <code>x + (-y)</code> 一样的结果。</p>
<p>传递给运算符重载 trait 方法的对象会被移动掉，这意味着非 <code>Copy</code> 的类型默认会被消耗掉。为 <code>&amp;'a MyType</code> 实现这些 trait 可以帮助解决这个问题，但需要更多的样板代码来覆盖所有的可能性（比如，对于双目运算符，入参类型可以是引用/非引用，就有 4 = 2 × 2 种可能性）。</p>
<h2 id="chapter_2-item10-std-traits-总结"><a class="header" href="#chapter_2-item10-std-traits-总结">总结</a></h2>
<p>这个条款已经涵盖了很多方便，下面按序给出了一些表格，总结了我们谈论到的标准库 trait。首先，表格 2-1 涵盖了这个条款深入讲述过的 trait，除了 <code>Display</code> 以外，所有这些 trait 都能通过 <code>derive</code> 获得实现。</p>
<p><em>表格 2-1. 常见的标准库 trait</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">编译器使用</th><th style="text-align: center">约束</th><th style="text-align: left">方法</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">clone</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a></td><td style="text-align: center"><code>let y = x;</code></td><td style="text-align: center"><code>Clone</code></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">default</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">eq</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a></td><td style="text-align: center"><code>x &lt; y</code>, <code>x &lt;= y</code>, …</td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html#tymethod.partial_cmp">partial_cmp</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a></td><td style="text-align: center"><code>x &lt; y</code>, <code>x &lt;= y</code>, …</td><td style="text-align: center"><code>Eq</code> + <code>PartialOrd</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html#tymethod.cmp">cmp</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">hash</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a></td><td style="text-align: center"><code>format!("{:?}", x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt">fmt</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a></td><td style="text-align: center"><code>format!("{}", x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt">fmt</a></td></tr>
</tbody></table>
</div>
<p>运算符重载相关的 trait 在表格 2-2 (#footnote-3) 中总结了。它们都不能通过 <code>derive</code> 获得。</p>
<p><em>表格 2-2. 运算符重载 trait</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">编译器使用</th><th style="text-align: center">约束</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html">Add</a></td><td style="text-align: center"><code>x + y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html">add</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">AddAssign</a></td><td style="text-align: center"><code>x += y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html#tymethod.add_assign">add_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html">BitAnd</a></td><td style="text-align: center"><code>x &amp; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html">bitand</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html">BitAndAssign</a></td><td style="text-align: center"><code>x &amp;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html#tymethod.bitand_assign">bitand_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html">BitOr</a></td><td style="text-align: center"><code>x ⎮ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html">bitor</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html">BitOrAssign</a></td><td style="text-align: center"><code>x ⎮= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html#tymethod.bitor_assign">bitor_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html">BitXor</a></td><td style="text-align: center"><code>x ^ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html">bitxor</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html">BitXorAssign</a></td><td style="text-align: center"><code>x ^= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html#tymethod.bitxor_assign">bitxor_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html">Div</a></td><td style="text-align: center"><code>x / y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html">div</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html">DivAssign</a></td><td style="text-align: center"><code>x /= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html#tymethod.div_assign">div_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">Mul</a></td><td style="text-align: center"><code>x * y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">mul</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html">MulAssign</a></td><td style="text-align: center"><code>x *= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html#tymethod.mul_assign">mul_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html">Neg</a></td><td style="text-align: center"><code>-x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html">neg</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html">Not</a></td><td style="text-align: center"><code>!x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html">not</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html">Rem</a></td><td style="text-align: center"><code>x % y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html">rem</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html">RemAssign</a></td><td style="text-align: center"><code>x %= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html#tymethod.rem_assign">rem_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html">Shl</a></td><td style="text-align: center"><code>x &lt;&lt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html">shl</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html">ShlAssign</a></td><td style="text-align: center"><code>x &lt;&lt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html#tymethod.shl_assign">shl_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html">Shr</a></td><td style="text-align: center"><code>x &gt;&gt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html">shr</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html">ShrAssign</a></td><td style="text-align: center"><code>x &gt;&gt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html#tymethod.shr_assign">shr_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html">Sub</a></td><td style="text-align: center"><code>x - y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html">sub</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html">SubAssign</a></td><td style="text-align: center"><code>x -= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html#tymethod.sub_assign">sub_assign</a></td></tr>
</tbody></table>
</div>
<p>为完整起见，在其他条款中提及的 trait 在表格 2-3 中涵盖了。这些 trait 都不能通过 <code>derive</code> 获得（但是 <code>Send</code> 和 <code>Sync</code> 可能由编译器自动实现）。</p>
<p><em>表格 2-3. 在其他条款中提及的 trait</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">条款</th><th style="text-align: center">编译器使用</th><th style="text-align: center">约束</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnMut</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call">call</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnOnce</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html#tymethod.call_mut">call_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#tymethod.call_once">call_once</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/error/trait.Error.html">Error</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/errors.html">第 4 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Display</code> + <code>Debug</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source">source</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.From.html">from</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html#tymethod.try_from">try_from</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.Into.html">into</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html">TryInto</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#tymethod.try_into">try_into</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref">as_ref</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html">AsMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut">as_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">Borrow</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">borrow</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html">BorrowMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Borrow</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut">borrow_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html">ToOwned</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned">to_owned</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">deref</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html">DerefMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;mut x</code></td><td style="text-align: center"><code>Deref</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html#tymethod.deref_mut">deref_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html">Index</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>x[idx]</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html">index</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html">IndexMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>x[idx] = ...</code></td><td style="text-align: center"><code>Index</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html#tymethod.index_mut">index_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html">Pointer</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>format("{:p}", x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt">fmt</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next">next</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html">IntoIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"><code>for y in x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html">FromIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html#tymethod.from_iter">from_iter</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html">ExactSizeIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left">（<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.size_hint">size_hint</a>）</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html">DoubleEndedIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back">next_back</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a></td><td style="text-align: center"><code>}</code> （作用域结束）</td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">drop</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">Sized</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Send.html">Send</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a></td><td style="text-align: center">跨线程传递</td><td style="text-align: center"></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a></td><td style="text-align: center">跨线程使用</td><td style="text-align: center"></td><td style="text-align: left">标记 trait</td></tr>
</tbody></table>
</div>
<p><a id="chapter_2-item10-std-traits-footnote-1">1</a>:当然，比较浮点数总是一个危险的游戏，因为通常情况下没法保证精度舍入计算会产生跟最初设想的数字（按比特值存储）完全相同的结果。</p>
<p><a id="chapter_2-item10-std-traits-footnote-2">2</a>:更一般地说，任何序论中的“格” <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice structure</a> 都具有偏序性质。</p>
<p><a id="chapter_2-item10-std-traits-footnote-3">3</a>:这里的一些名称有点隐晦——例如 <code>Rem</code> 是求余数，<code>Shl</code> 是按位左移——但是 <a href="https://doc.rust-lang.org/std/ops/index.html">std::ops</a> 的文档清楚第说明了它们的预期行为。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_2-item11-impl-drop-for-raii"></div><h1 id="chapter_2-item11-impl-drop-for-raii-第-11-条为raii模式实现drop-trait"><a class="header" href="#chapter_2-item11-impl-drop-for-raii-第-11-条为raii模式实现drop-trait">第 11 条：为RAII模式实现Drop trait</a></h1>
<blockquote>
<p>“永远不要让人去做机器的工作。” —— 史密斯特工（出自电影《黑客帝国》）</p>
</blockquote>
<p>RAII 代表“资源获取即初始化”（Resource Acquisition Is Initialization）是一种编程模式，其中值的生命周期与某些附加资源的生命周期完全相关。 RAII 模式由 C++ 编程语言普及，是 C++ 对编程的最大贡献之一。</p>
<p>值的生命周期与资源的生命周期之间的关联体现在 RAII 类型中：</p>
<ul>
<li>该类型的构造函数获取对某些资源的访问权</li>
<li>该类型的析构函数释放对这些资源的访问权</li>
</ul>
<p>其结果是 RAII 类型具有一个恒定的特性：当且仅当对象存在时，才能访问底层资源。因为编译器确保局部变量在作用域退出时会被销毁，这就意味着底层资源也会在退出作用域时被释放。</p>
<p>这对于程序的可维护性很有帮助：如果对代码的后续改动改变了控制流，对象和资源的生命周期仍然是正确的。为了说明这点，来看一些没有使用 RAII 模式，手动锁定、解锁互斥锁的代码；以下代码是用 C++ 编写的，因为 Rust 的 <code>Mutex</code> 不允许这种易出错的用法！</p>
<pre><code class="language-C++">// C++ code
class ThreadSafeInt {
 public:
  ThreadSafeInt(int v) : value_(v) {}

  void add(int delta) {
    mu_.lock();
    // ... more code here
    value_ += delta;
    // ... more code here
    mu_.unlock();
  }
</code></pre>
<p>如果修改程序以在错误发生时提前退出函数，将会导致互斥锁保持锁定状态：</p>
<div class="ferris"><img src="chapter_2/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><code class="language-C++">// C++ code
void add_with_modification(int delta) { 
  mu_.lock();
  // ... more code here
  value_ += delta;
  // Check for overflow.
  if (value_ &gt; MAX_INT) {
    // Oops, forgot to unlock() before exit
    return;
  }
  // ... more code here
  mu_.unlock();
}
</code></pre>
<p>然而，如果我们把锁定、解锁的行为放到 RAII 类中：</p>
<pre><code class="language-C++">// C++ code (real code should use std::lock_guard or similar)
class MutexLock {
 public:
  MutexLock(Mutex* mu) : mu_(mu) { mu_-&gt;lock(); }
  ~MutexLock()                   { mu_-&gt;unlock(); }
 private:
  Mutex* mu_;
};
</code></pre>
<p>对于同样的改动，代码就是安全的：</p>
<pre><code class="language-C++">// C++ code
void add_with_modification(int delta) {
  MutexLock with_lock(&amp;mu_);
  // ... more code here
  value_ += delta;
  // Check for overflow.
  if (value_ &gt; MAX_INT) {
    return; // Safe, with_lock unlocks on the way out
  }
  // ... more code here
}
</code></pre>
<p>在 C++ 中， RAII 模式最初常用于内存管理，以确保手动分配（ new，malloc() ）和释放（ delete，free() ）操作保持同步。C++11 标准库中加入了一个通用版本的内存管理： std::unique_ptr<T> 类型确保只有一个指针独享内存的“所有权”，但允许指向该内存的指针被“借用”用于临时使用（ptr.get()）。</p>
<p>在 Rust 中，内存指针的这种行为被内置在语言中（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>），但 RAII 的一般原则对于其他类型的资源仍然有用。<strong>我们应该对任何持有必须释放资源的类型实现 <code>Drop</code> trait</strong> ，例如以下情况：</p>
<ul>
<li>访问操作系统资源。对于类 Unix 系统，这通常意味着持有<a href="https://en.wikipedia.org/wiki/File_descriptor">文件描述符</a>的类型对象；未能正确释放这些资源将会占用系统资源（并最终导致程序的每个进程获取文件描述符受限）。</li>
<li>访问同步资源。标准库已经包括内存同步原语，但其他资源（例如文件锁、数据库锁等）可能需要类似的封装。</li>
<li>访问原始内存，对于处理低级内存管理的 <code>unsafe</code> 类型（例如，用于外部函数接口[FFI]功能）。</li>
</ul>
<p>Rust 标准库中最明显的 RAII 实例是由 <code><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock">Mutex::lock()</a></code> 操作返回的 <code><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html">MutexGuard</a></code> ，它通常用于<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>中讨论的通过共享状态实现并行的程序。这大致类似于之前提到的 C++ 示例，但在 Rust 中， <code>MutexGuard</code> 不仅作为持有锁的 RAII 对象，还充当对互斥锁保护的数据的代理：</p>
<pre><code class="language-Rust">use std::sync::Mutex;

struct ThreadSafeInt {
    value: Mutex&lt;i32&gt;,
}

impl ThreadSafeInt {
    fn new(val: i32) -&gt; Self {
        Self {
            value: Mutex::new(val),
        }
    }
    fn add(&amp;self, delta: i32) {
        let mut v = self.value.lock().unwrap();
        *v += delta;
    }
}

</code></pre>
<p><a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>建议不要在大段代码中持有锁；为确保这点，<strong>可以使用代码块来限制 RAII 对象的作用域</strong>。虽然这样会导致奇怪的缩进，但为了增加安全性和确保生命周期的精确性，这是值得的：</p>
<pre><code class="language-Rust">impl ThreadSafeInt {
    fn add_with_extras(&amp;self, delta: i32) {
        // ... more code here that doesn't need the lock
        {
            let mut v = self.value.lock().unwrap();
            *v += delta;
        }
        // ... more code here that doesn't need the lock
    }
}
</code></pre>
<p>在推崇了 RAII 模式的用法之后，有必要解释一下如何实现它。 <code><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a></code> trait 允许你在对象销毁时添加用户自定义的行为。这个 trait 只有一个方法， <code><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">drop</a></code> ，编译器会在释放持有对象的内存之前运行这个方法：</p>
<pre><code class="language-Rust">#[derive(Debug)]
struct MyStruct(i32);

impl Drop for MyStruct {
    fn drop(&amp;mut self) {
        println!("Dropping {self:?}");
        // Code to release resources owned by the item would go here.
    }
}
</code></pre>
<p><code>drop</code> 方法是专门为编译器保留的，不允许手动调用：</p>
<pre><code class="language-Rust">x.drop();
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:70:7
   |
70 |     x.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(x)`
<span class="boring">}</span></code></pre></pre>
<p>在这里，我们需要了解一些技术细节。请注意， <code>Drop::drop</code> 方法的签名是 <code>drop(&amp;mut self)</code> 而不是 <code>drop(self)</code> ：它接收的是对象的可变引用，而不是将对象移动到方法中。如果 <code>Drop::drop</code> 像普通方法那样运行，就意味着对象在方法执行后仍然可用——尽管它的所有内部状态已经被清理完毕，资源也已释放！</p>
<div class="ferris"><img src="chapter_2/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // If calling `drop` were allowed...
    x.drop(); // (does not compile)

    // `x` would still be available afterwards.
    x.0 += 1;
}
// Also, what would happen when `x` goes out of scope?
<span class="boring">}</span></code></pre></pre>
<p>编译器提供了一种简单的替代方案，即调用 <code><a href="https://doc.rust-lang.org/std/mem/fn.drop.html">drop()</a></code> 函数手动销毁对象。该函数接收一个参数移动到函数内，其实 <code>drop(_item: T)</code> 函数的实现只是一个空的函数体<code>{}</code>——所以当该作用域到右括号时，被移动的对象会就被销毁。</p>
<p>另外， <code>drop(&amp;mut self)</code> 方法的签名没有返回类型，这意味着它无法传递失败信息。如果释放资源可能会失败，那么你可能需要一个单独的 <code>release</code> 方法来返回一个 Result ，以便用户检测详情。</p>
<p>无论技术细节如何， <code>drop</code> 方法仍然是实现RAII模式的关键；它是实现释放与对象相关资源的最佳位置。</p>
<p>原文<a href="https://www.lurklurk.org/effective-rust/raii.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_2-item12-generics&trait-objects"></div><h1 id="chapter_2-item12-genericstrait-objects-第-12-条理解泛型和特征对象之间的权衡"><a class="header" href="#chapter_2-item12-genericstrait-objects-第-12-条理解泛型和特征对象之间的权衡">第 12 条：理解泛型和特征对象之间的权衡</a></h1>
<p><a href="#chapter_2-chapter_1-item2-use-types-2">第2条</a>描述了如何使用特征来封装类型系统中的行为，作为相关方法的集合，并观察到有两种使用特征的方法：作为泛型的特征约束( <code>trait bound</code> )或特征对象( <code>trait object</code> )。本条探讨了这两种可能性之间的权衡。</p>
<p>下面是一个运行示例，请考虑一个涵盖显示图形对象的功能的特征：</p>
<pre><code class="language-Rust">#[derive(Debug, Copy, Clone)]
pub struct Point {
    x: i64,
    y: i64,
}

#[derive(Debug, Copy, Clone)]
pub struct Bounds {
    top_left: Point,
    bottom_right: Point,
}

/// Calculate the overlap between two rectangles, or `None` if there is no
/// overlap.
fn overlap(a: Bounds, b: Bounds) -&gt; Option&lt;Bounds&gt; {
    // ...
}

/// Trait for objects that can be drawn graphically.
pub trait Draw {
    /// Return the bounding rectangle that encompasses the object.
    fn bounds(&amp;self) -&gt; Bounds;

    // ...
}
</code></pre>
<h2 id="chapter_2-item12-genericstrait-objects-泛型"><a class="header" href="#chapter_2-item12-genericstrait-objects-泛型">泛型</a></h2>
<p>Rust 的泛型大致等同于 C++ 的模板：它允许程序员编写适用于任意类型 <code>T</code> 的代码，而泛型代码的特定用途会在编译时生成--这一过程在 Rust 中称为<em>单态化(monomorphization)</em>，在 C++ 中称为<em>模板实例化(template instantiation)</em>。与 C++ 不同的是，Rust 在类型系统中以泛型的特质约束的形式明确编码了对 <code>T</code> 类型的期望。</p>
<p>例如，一个使用特征的 <code>bounds()</code> 方法的泛型函数具有显式的 <code>Draw</code> 特征约束：</p>
<pre><code class="language-Rust">/// Indicate whether an object is on-screen.
pub fn on_screen&lt;T&gt;(draw: &amp;T) -&gt; bool
where
    T: Draw,
{
    overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
}
</code></pre>
<p>这也可以通过将特征绑定放在泛型参数之后来更紧凑地编写：</p>
<pre><code class="language-Rust">pub fn on_screen&lt;T: Draw&gt;(draw: &amp;T) -&gt; bool {
    overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
}
</code></pre>
<p>或者使用 <code>impl Trait</code> 作为参数的类型<sup class="footnote-reference"><a href="#chapter_2-item12-generics&trait-objects-1">1</a></sup>：</p>
<pre><code class="language-Rust">pub fn on_screen(draw: &amp;impl Draw) -&gt; bool {
    overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
}
</code></pre>
<p>如果一个类型实现了特征：</p>
<pre><code class="language-Rust">#[derive(Clone)] // no `Debug`
struct Square {
    top_left: Point,
    size: i64,
}

impl Draw for Square {
    fn bounds(&amp;self) -&gt; Bounds {
        Bounds {
            top_left: self.top_left,
            bottom_right: Point {
                x: self.top_left.x + self.size,
                y: self.top_left.y + self.size,
            },
        }
    }
}
</code></pre>
<p>然后该类型的实例可以传递给泛型函数，通过单例化来产生特定于一种特定类型的代码：</p>
<pre><code class="language-Rust">let square = Square {
    top_left: Point { x: 1, y: 2 },
    size: 2,
};
// Calls `on_screen::&lt;Square&gt;(&amp;Square) -&gt; bool`
let visible = on_screen(&amp;square);
</code></pre>
<p>如果将相同的泛型函数用于实现相关特征约束的其他类型：</p>
<pre><code class="language-Rust">#[derive(Clone, Debug)]
struct Circle {
    center: Point,
    radius: i64,
}

impl Draw for Circle {
    fn bounds(&amp;self) -&gt; Bounds {
        // ...
    }
}
</code></pre>
<p>然后使用不同的单态化代码：</p>
<pre><code class="language-Rust">let circle = Circle {
    center: Point { x: 3, y: 4 },
    radius: 1,
};
// Calls `on_screen::&lt;Circle&gt;(&amp;Circle) -&gt; bool`
let visible = on_screen(&amp;circle);
</code></pre>
<p>换句话说，程序员编写了一个单一的泛型函数，但编译器会为每次调用该函数时使用的不同类型输出一个不同的单态化版本的函数。</p>
<h2 id="chapter_2-item12-genericstrait-objects-特征对象"><a class="header" href="#chapter_2-item12-genericstrait-objects-特征对象">特征对象</a></h2>
<p>相比之下，特征对象是一个胖指针(<a href="#chapter_2-chapter_1-item8-references&amp;pointer">第8条</a>)，它将指向底层具体项目的指针与指向虚表（vtable）的指针结合在一起，而虚表又持有特征实现的所有方法的函数指针，如图 2-1 所示：
<img src="chapter_2/../images/item12/draw.svg" alt="图 2-1" title="特征对象布局，包含指向具体项目的指针和指向vtable的指针" />
<em>图 2-1.特征对象布局，包含指向具体项目的指针和指向vtable的指针</em></p>
<p>这意味着接受特征对象的函数不需要泛型，也不需要单态化：程序员使用特征对象编写函数，编译器只输出该函数的一个版本，它可以接受来自多种输入类型的特征对象：</p>
<pre><code class="language-Rust">/// Indicate whether an object is on-screen.
pub fn on_screen(draw: &amp;dyn Draw) -&gt; bool {
    overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
}
</code></pre>
<pre><code class="language-Rust">// Calls `on_screen(&amp;dyn Draw) -&gt; bool`.
let visible = on_screen(&amp;square);
// Also calls `on_screen(&amp;dyn Draw) -&gt; bool`.
let visible = on_screen(&amp;circle);
</code></pre>
<h2 id="chapter_2-item12-genericstrait-objects-基本比较"><a class="header" href="#chapter_2-item12-genericstrait-objects-基本比较">基本比较</a></h2>
<p>这些基本事实已经允许在两种可能性之间进行一些直接比较：</p>
<ul>
<li>泛型可能会导致代码量增大，因为编译器会为每个使用 <code>on_screen</code> 函数泛型版本的 <code>T</code> 类型生成一份全新的代码副本（ <code>on_screen::&lt;T&gt;(&amp;T)</code> ）。相比之下，该函数的特征对象版本（ <code>on_screen(&amp;dyn T)</code> ）只需要生成一个实例。</li>
<li>从泛型中调用特征方法通常比从使用特征对象的代码中调用特征方法要稍微快一些，因为后者需要执行两次反引用来查找代码的位置（特征对象到 vtable，vtable 到实现位置）。</li>
<li>泛型的编译时间可能会更长，因为编译器要编译更多代码，链接器要做更多工作来折叠重复代码。</li>
</ul>
<p>在大多数情况下，这些差异并不显著--只有当你测量了优化的影响并发现它确实会产生影响（速度瓶颈或占用率增加）时，才应将优化相关的问题作为主要的决策驱动因素。</p>
<p>更重要的区别在于，通用特征约束可用于有条件地提供不同的功能，这取决于类型参数是否实现了<em>多个</em>特征：</p>
<pre><code class="language-Rust">// The `area` function is available for all containers holding things
// that implement `Draw`.
fn area&lt;T&gt;(draw: &amp;T) -&gt; i64
where
    T: Draw,
{
    let bounds = draw.bounds();
    (bounds.bottom_right.x - bounds.top_left.x)
        * (bounds.bottom_right.y - bounds.top_left.y)
}

// The `show` method is available only if `Debug` is also implemented.
fn show&lt;T&gt;(draw: &amp;T)
where
    T: Debug + Draw,
{
    println!("{:?} has bounds {:?}", draw, draw.bounds());
}
</code></pre>
<pre><code class="language-Rust">let square = Square {
    top_left: Point { x: 1, y: 2 },
    size: 2,
};
let circle = Circle {
    center: Point { x: 3, y: 4 },
    radius: 1,
};

// Both `Square` and `Circle` implement `Draw`.
println!("area(square) = {}", area(&amp;square));
println!("area(circle) = {}", area(&amp;circle));

// `Circle` implements `Debug`.
show(&amp;circle);

// `Square` does not implement `Debug`, so this wouldn't compile:
// show(&amp;square);
</code></pre>
<p>特征对象只对单个特征的实现虚表进行编码，因此要做与之等价的事情就比较麻烦。例如，可以为 <code>show()</code> 情况定义一个组合 <code>DebugDraw</code> 特征，同时定义一个空白实现，以方便使用：</p>
<pre><code class="language-Rust">trait DebugDraw: Debug + Draw {}

/// Blanket implementation applies whenever the individual traits
/// are implemented.
impl&lt;T: Debug + Draw&gt; DebugDraw for T {}
</code></pre>
<p>但是，如果存在不同特征的多种组合，这种方法的组合学显然会迅速变得臃肿不堪。</p>
<h2 id="chapter_2-item12-genericstrait-objects-更多特征约束"><a class="header" href="#chapter_2-item12-genericstrait-objects-更多特征约束">更多特征约束</a></h2>
<p>除了使用特征约束来限制泛型函数可接受的类型参数外，还可以将其应用于特征定义本身：</p>
<pre><code class="language-Rust">/// Anything that implements `Shape` must also implement `Draw`.
trait Shape: Draw {
    /// Render that portion of the shape that falls within `bounds`.
    fn render_in(&amp;self, bounds: Bounds);

    /// Render the shape.
    fn render(&amp;self) {
        // Default implementation renders that portion of the shape
        // that falls within the screen area.
        if let Some(visible) = overlap(SCREEN_BOUNDS, self.bounds()) {
            self.render_in(visible);
        }
    }
}
</code></pre>
<p>在本例中，<code>render()</code> 方法的默认实现（<a href="#chapter_2-item13-use-default-impl">第13条</a>）使用了特征 <code>bound</code>，依赖于 <code>Draw</code> 中的 <code>bounds()</code> 方法。</p>
<p>来自面向对象语言的程序员经常会混淆特征约束和继承，误以为这样的特征约束意味着 <code>Shape</code> <em>就是</em> <code>Draw</code>。事实并非如此：这两种类型之间的关系最好表述为 <code>Shape</code> <em>也实现了</em> <code>Draw</code>。</p>
<p>从底层来看，那些具有特征约束的特征对象：</p>
<pre><code class="language-Rust">let square = Square {
    top_left: Point { x: 1, y: 2 },
    size: 2,
};
let draw: &amp;dyn Draw = &amp;square;
let shape: &amp;dyn Shape = &amp;square;
</code></pre>
<p>有一个组合的虚表，其中包括顶层特征的方法以及所有特征约束的方法。如图 2-2 所示：<code>Shape</code> 的虚表包括 <code>Draw</code> 特征的 <code>bounds</code> 方法，以及 <code>Shape</code> 特征本身的两个方法。
<img src="chapter_2/../images/item12/traitbounds.svg" alt="图 2-2" title="具有`Draw`与`Shape`两种虚表的具有特征约束的特征对象" />
<em>图 2-2.具有 <code>Draw</code> 与 <code>Shape</code> 两种虚表的具有特征约束的特征对象</em></p>
<p>在撰写本文时（截至Rust 1.70版本），没有办法从 <code>Shape</code> 向上转型到 <code>Draw</code>，因为无法在运行时恢复（纯净的） <code>Draw</code> 虚表；没有办法在相关的特征对象之间进行转换，这反过来又意味着没有<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">里氏替换原则（Liskov substitution）</a>。然而，这种情况很可能在 Rust 的后续版本中发生变化——有关更多信息，请参见<a href="https://www.lurklurk.org/effective-rust/reflection.html">第19条</a>。</p>
<p>用不同的语言重复同样的观点，接受 <code>Shape</code> 特征对象的方法具有以下特征：</p>
<ul>
<li>它可以使用 <code>Draw</code> 的方法（因为 <code>Shape</code> 也实现了 <code>Draw</code>，而且 <code>Shape</code> 虚表中存在相关函数指针）。</li>
<li>它还不能将特征对象传递给另一个期望使用 <code>Draw</code> 特征对象的方法（因为 <code>Shape</code> 不是 <code>Draw</code>，而且 <code>Draw</code> 虚表也不可用）。</li>
</ul>
<p>相比之下，接受实现 <code>Shape</code> 的泛型方法具有以下特征：</p>
<ul>
<li>它可以使用 <code>Draw</code> 方法。</li>
<li>它可以将项目传递给另一个具有 <code>Draw</code> 特征约束的泛型方法，因为特征约束在编译时被单态化为使用具体类型的 <code>Draw</code> 方法。</li>
</ul>
<h2 id="chapter_2-item12-genericstrait-objects-特征对象安全"><a class="header" href="#chapter_2-item12-genericstrait-objects-特征对象安全">特征对象安全</a></h2>
<p>对特征对象的另一个限制是对<a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">对象安全</a>的要求：只有符合以下两条规则的特征才能用作特征对象：</p>
<ul>
<li>特征方法不能是通用的。</li>
<li>特征的方法不能涉及包含 <code>Self</code> 的类型，但接收方（调用方法的对象）除外。</li>
</ul>
<p>第一个限制很容易理解：泛型方法 <code>f</code> 是一组无限多的方法，可能包含 <code>f::&lt;i16&gt;</code>, <code>f::&lt;i32&gt;</code>, <code>f::&lt;i64&gt;</code>, <code>f::&lt;u8&gt;</code> 等。另一方面，特征对象的虚表在很大程度上是指针函数的有限集合，因此不可能将无限的单态实现集放入其中。</p>
<p>第二种限制比较微妙，但往往是在实践中更常遇到的限制--使用 <code>Copy</code> 或 <code>Clone</code> 特征约束（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第10条</a>）的特征会立即受到这条规则的限制，因为它们返回的是 <code>Self</code>。如果代码调用（例如） <code>let y = x.clone()</code>，会发生什么情况？调用代码需要在堆栈中为 <code>y</code> 预留足够的空间，但它不知道 <code>y</code> 的大小，因为 <code>Self</code> 是一个任意类型。因此，提及 <code>Self</code> 的返回类型会导致特征对对象不安全<sup class="footnote-reference"><a href="#chapter_2-item12-generics&trait-objects-2">2</a></sup>。</p>
<p>第二个限制有一个例外。如果 <code>Self</code> 对编译时已知大小的类型有明确的限制，即 <code>Sized</code> 标记特征作为特征，那么返回某种 <code>Self</code> 相关类型的方法就不会影响对象的安全性：</p>
<pre><code class="language-Rust">/// A `Stamp` can be copied and drawn multiple times.
trait Stamp: Draw {
    fn make_copy(&amp;self) -&gt; Self
    where
        Self: Sized;
}
</code></pre>
<pre><code class="language-Rust">let square = Square {
    top_left: Point { x: 1, y: 2 },
    size: 2,
};

// `Square` implements `Stamp`, so it can call `make_copy()`.
let copy = square.make_copy();

// Because the `Self`-returning method has a `Sized` trait bound,
// creating a `Stamp` trait object is possible.
let stamp: &amp;dyn Stamp = &amp;square;
</code></pre>
<p>这种特征约束意味着该方法无论如何都不能与特征对象一起使用，因为特征指的是未知大小的东西（<code>dyn Trait</code>），所以该方法违背了对象安全：</p>
<pre><code class="language-Rust">// However, the method can't be invoked via a trait object.
let copy = stamp.make_copy();
</code></pre>
<pre><code class="language-Rust">error: the `make_copy` method cannot be invoked on a trait object
   --&gt; src/main.rs:397:22
    |
353 |         Self: Sized;
    |               ----- this has a `Sized` requirement
...
397 |     let copy = stamp.make_copy();
    |                      ^^^^^^^^^
</code></pre>
<h2 id="chapter_2-item12-genericstrait-objects-权衡取舍"><a class="header" href="#chapter_2-item12-genericstrait-objects-权衡取舍">权衡取舍</a></h2>
<p>从目前各种因素的权衡来看，你应该更倾向于使用泛型而非特征对象，但在某些情况下，特征对象才是最合适的工具。</p>
<p>首先是实际考虑：如果生成代码的大小或编译时间是个问题，那么特征对象的性能会更好（如本项目前面所述）。</p>
<p>从理论上讲，特征对象从根本上涉及类型擦除：在转换为特征对象的过程中，具体类型的信息会丢失。这可能是一个缺点（见<a href="https://www.lurklurk.org/effective-rust/reflection.html">第19条</a>），但它也可能是有用的，因为它允许异构对象的集合--因为代码只依赖于特质的方法，它可以调用和组合具有不同具体类型的项的方法。</p>
<p>渲染形状列表的传统面向对象例子就是一个例子：在同一个循环中，可以对正方形、圆形、椭圆形和星形使用相同的 <code>render()</code> 方法：</p>
<pre><code class="language-Rust">let shapes: Vec&lt;&amp;dyn Shape&gt; = vec![&amp;square, &amp;circle];
for shape in shapes {
    shape.render()
}
</code></pre>
<p>当编译时还不知道可用类型时，特征对象的潜在优势就显得模糊得多。如果新代码在运行时被动态加载（例如通过<a href="https://man7.org/linux/man-pages/man3/dlopen.3.html">dlopen(3)</a>），那么在新代码中实现特征的项目只能通过特征对象调用，因为没有源代码可以单态化。</p>
<p>原文<a href="https://www.lurklurk.org/effective-rust/generics.html">点这里</a>查看</p>
<h4 id="chapter_2-item12-genericstrait-objects-注释"><a class="header" href="#chapter_2-item12-genericstrait-objects-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_2-item12-generics&trait-objects-1"><sup class="footnote-definition-label">1</sup>
<p>使用<a href="https://doc.rust-lang.org/reference/types/impl-trait.html#anonymous-type-parameters">"impl Trait in argument position"</a>并不完全等同于前两个版本，因为它取消了调用者通过类似<code>on_screen::&lt;Circle&gt;(&amp;c)</code>这样的方式明确指定类型参数的功能。</p>
</div>
<div class="footnote-definition" id="chapter_2-item12-generics&trait-objects-2"><sup class="footnote-definition-label">2</sup>
<p>在撰写本文时，对返回 <code>Self</code> 的方法的限制包括像 <code>Box&lt;Self&gt; </code> 这样可以安全地存储在堆栈中的类型；这一限制将来可能会放宽。</p>
</div>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_2-item13-use-default-impl"></div><h1 id="chapter_2-item13-use-default-impl-第-13-条使用默认实现来减少必需实现的-trait-方法"><a class="header" href="#chapter_2-item13-use-default-impl-第-13-条使用默认实现来减少必需实现的-trait-方法">第 13 条：使用默认实现来减少必需实现的 trait 方法</a></h1>
<p>在设计 trait 时，需要考虑两种不同的受众：实现 trait 的人和使用 trait 的人。在 trait 设计中，这两种受众之间存在一定的冲突：</p>
<ul>
<li>为了让实现者实现 trait 更轻松，最好让 trait 具有实现其目的所需的最少方法。</li>
<li>为了让用户使用 trait 更方便，最好提供一系列覆盖所有常见用法的方法。</li>
</ul>
<p>通过涵盖更多方便用户的方法，同时为那些可以从接口上其他更基础的操作构建的方法提供默认实现，可以缓解这种冲突。</p>
<p>来看一个简单的例子， <code><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html">ExactSizeIterator</a></code> 是一个知道确切迭代内容的 <code>Iterator</code>，它的 <code><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.is_empty">is_empty()</a></code> 方法有一个依赖于 <code><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len">len()</a></code> 方法的默认实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_empty(&amp;self) -&gt; bool {
    self.len() == 0
}
<span class="boring">}</span></code></pre></pre>
<p>存在默认的实现仅仅意味着它有一个默认值。如果 trait 的实现有不同的方法来判断迭代器是否为空，它也可以用自己的 <code>is_empty()</code> 替换默认实现。</p>
<p>这种方法使得 trait 定义具有少量必需的方法，以及大量默认实现的方法。实现者只需实现前者，即可随意使用所有后者。</p>
<p>Rust 标准库广泛采用了这种方法；<code><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a></code> trait 就是一个很好的例子，它只有一个必需方法（ <code><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next">next()</a></code> ），但包含了大量预提供的方法（ <a href="#chapter_2-chapter_1-item9-iterators">第9条</a> ），撰写本文时已经超过50个。</p>
<p>trait 方法可以添加 trait 约束，这意味着只有在相关类型实现特定 trait 时，目标方法才可用。这在结合默认方法实现时非常有用，<code><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a></code> 也印证了这点。例如，<code><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned">cloned()</a></code> 的迭代器方法有一个 trait 约束和一个默认实现：</p>
<pre><code class="language-Rust">fn cloned&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt;
where
    T: 'a + Clone,
    Self: Sized + Iterator&lt;Item = &amp;'a T&gt;,
{
    Cloned::new(self)
}
</code></pre>
<p>换句话说，<code>cloned()</code> 方法只有在 <code>Item</code> 的类型实现了 <code><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a></code> trait 时才可用；一旦实现 <code>Clone</code> trait， <code>clone()</code> 方法也会自动实现。</p>
<p>关于带有默认实现的 trait 方法，最后一个要点是，即使在特征的初始版本发布之后，通常也可以安全地向 trait 添加新方法。只要新方法名不与类型实现的其他 trait 方法名冲突，就能保持向后兼容性（详见 <a href="https://www.lurklurk.org/effective-rust/semver.html">第21条</a>）。</p>
<p>因此，请参照标准库的示例，通过添加带有默认实现的方法（并根据需要添加 trait 约束），为实现者提供最少的 API 接口，但为用户提供方便且全面的 API 。</p>
<p>原文<a href="https://www.lurklurk.org/effective-rust/default-impl.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3"></div><h1 id="chapter_3-概念"><a class="header" href="#chapter_3-概念">概念</a></h1>
<p>本书的前两章涵盖了 <code>Rust</code> 的类型和特征，这有助于提供编写 <code>Rust</code> 代码所需的一些概念词汇 —— 这正是本章的主题。</p>
<p>借用检查器和生命周期检查是 <code>Rust</code> 独特之处的核心；它们也是 <code>Rust</code> 新手常见的绊脚石，因此是本章前两个条目的重点。</p>
<p>本章的其他条目涵盖了一些更容易理解但与其他语言编写代码略有不同的概念。这包括以下内容：</p>
<ul>
<li>关于 <code>Rust</code> 的 <code>unsafe</code> 模式及其避免方法的建议（<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>）</li>
<li>关于在 <code>Rust</code> 中编写多线程代码的好消息和坏消息（<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>）</li>
<li>关于避免运行时终止的建议（<a href="https://www.lurklurk.org/effective-rust/panic.html">第 18 条</a>）</li>
<li>关于 <code>Rust</code> 反射方法的信息（<a href="https://www.lurklurk.org/effective-rust/reflection.html">第 19 条</a>）</li>
<li>关于平衡优化与可维护性的建议（<a href="https://www.lurklurk.org/effective-rust/optimize.html">第 20 条</a>）</li>
</ul>
<p>尝试将你的代码与这些概念的后果对齐是一个好主意。在 <code>Rust</code> 中重现（部分）<code>C/C++</code> 的行为是可能的，但如果你这样做，为什么还要麻烦使用 <code>Rust</code> 呢？</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3-item14-lifetimes"></div><h1 id="chapter_3-item14-lifetimes-第-14-条理解生命周期"><a class="header" href="#chapter_3-item14-lifetimes-第-14-条理解生命周期">第 14 条：理解生命周期</a></h1>
<p>这一条描述了 Rust 的生命周期，这是对先前的编译型语言（像 C 和 C++）中存在的概念的更精确的表述——不仅仅在理论上，更是在实践中。生命周期是<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>中描述的<em>借用检查器</em>的必要标注；总的来说，这些功能构成了 Rust 内存安全保证的核心。</p>
<h2 id="chapter_3-item14-lifetimes-介绍一下栈"><a class="header" href="#chapter_3-item14-lifetimes-介绍一下栈">介绍一下栈</a></h2>
<p>生命周期在根本上跟栈有关，所以快速过一遍栈的知识。</p>
<p>当一个程序运行时，内存会被分成不同的区块，有时被称为<em>段</em>。其中一些块是固定大小的，比如包含程序代码和全局变量的块，但是有两个块——<em>堆</em>和<em>栈</em>——会随着程序运行而改变大小。为了实现这一点，堆和栈通常排列在程序虚拟内存的两端，因此一个可以向下增长，另外一个可以向上增长（至少在你的程序耗尽了内存并崩溃之前），如图 3-1 所示。</p>
<img src="chapter_3/../images/item14/memorylayout.svg" width="300" height="420">
<p><em>图 3-1. 程序内存布局，包括堆向上增长和栈向下增长</em></p>
<p>对于这两个动态大小的块来说，栈用来保存与当前执行的函数相关的状态。该状态可能包含以下元素：</p>
<ul>
<li>传递给函数的参数</li>
<li>函数中的局部变量</li>
<li>函数计算的临时值</li>
<li>函数调用者在代码中的返回地址</li>
</ul>
<p>当调用函数<code>f()</code>，一个新的栈帧(stack frame)会被添加到栈中，当超出栈帧结束的位置时，CPU 通常会更新<em>栈指针</em>寄存器，去指向新的栈帧。</p>
<p>当内部函数<code>f()</code>返回，栈指针会被重置到调用函数之前的位置，也就是调用者的完整且未修改的栈帧。</p>
<p>如果调用者随后调用了一个不同的函数<code>g()</code>，这个过程会再次发生，这意味着<code>g()</code>的栈帧将复用<code>f()</code>先前使用的同一块内存区域（如图 3-2 所示）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn caller() -&gt; u64 {
    let x = 42u64;
    let y = 19u64;
    f(x) + g(y)
}

fn f(f_param: u64) -&gt; u64 {
    let two = 2u64;
    f_param + two
}

fn g(g_param: u64) -&gt; u64 {
    let arr = [2u64, 3u64];
    g_param + arr[1]
}
<span class="boring">}</span></code></pre></pre>
<p><img src="chapter_3/../images/item14/stackuse.svg" alt="图 3-2" /></p>
<p><em>图 3-2. 随着函数调用和返回，栈使用的演变</em></p>
<p>当然，这是实际情况的极大简化之后的版本——将东西放入栈或取出栈需要时间，所以实际上处理器会有很多优化。然而，这个简化的概念图已经足以理解本条的主题。</p>
<h2 id="chapter_3-item14-lifetimes-生命周期的演化"><a class="header" href="#chapter_3-item14-lifetimes-生命周期的演化">生命周期的演化</a></h2>
<p>上一小节解释了参数和局部变量是如何在栈上存储的，同时指出了这些值只是临时存储的。</p>
<p>从历史上来说，这会允许出现一些危险情况：当你持有一个指向这些栈上临时值的指针，会发生什么？</p>
<p>对最开始的 C 来说，返回局部变量的指针是完全可以的（尽管现代编译器会警告）：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><code class="language-c">/* C code. */
struct File {
  int fd;
};

struct File* open_bugged() {
  struct File f = { open("README.md", O_RDONLY) };
  return &amp;f;  /* return address of stack object! */
}
</code></pre>
<p>如果你不幸并且立刻使用了调用代码的返回值，你<em>或许</em>会避开这段代码导致的问题：</p>
<pre><code class="language-c">struct File* f = open_bugged();
printf("in caller: file at %p has fd=%d\n", f, f-&gt;fd);
</code></pre>
<pre><code>in caller: file at 0x7ff7bc019408 has fd=3
</code></pre>
<p>这是不幸的，因为它只是<em>看起来</em>有效。一旦发生任何其他函数调用，栈区域被复用，并且用于保存对象的区域将会被覆盖：</p>
<pre><code class="language-c">investigate_file(f);
</code></pre>
<pre><code class="language-c">/* C code. */
void investigate_file(struct File* f) {
  long array[4] = {1, 2, 3, 4}; // put things on the stack
  printf("in function: file at %p has fd=%d\n", f, f-&gt;fd);
}
</code></pre>
<pre><code>in function: file at 0x7ff7bc019408 has fd=1592262883
</code></pre>
<p>这个示例中，丢弃对象的内容会产生额外的不良副作用：打开的文件对应的文件描述符丢失了，因此程序泄漏了结构体中保存的资源。</p>
<p>发展到 C++后，失去资源访问权的问题通过包含<em>析构函数</em>得到了解决，从而启用了 RAII（参考<a href="#chapter_3-chapter_2-item11-impl-drop-for-raii">第 11 条</a>）。现在，栈上的东西有了自我清理的能力：如果对象持有某种资源，析构函数可以清理它，并且 C++编译器确保了在清理栈帧的过程中调用栈上对象的析构函数：</p>
<pre><code class="language-cpp">// C++ code.
File::~File() {
  std::cout &lt;&lt; "~File(): close fd " &lt;&lt; fd &lt;&lt; "\n";
  close(fd);
  fd = -1;
}
</code></pre>
<p>调用者现在获得了一个指向已被销毁并且它的资源已经被回收的对象的（无效）指针：</p>
<pre><code class="language-cpp">File* f = open_bugged();
printf("in caller: file at %p has fd=%d\n", f, f-&gt;fd);
</code></pre>
<pre><code>~File(): close fd 3
in caller: file at 0x7ff7b6a7c438 has fd=-1
</code></pre>
<p>然而，C++没有采取任何措施来解决悬垂指针的问题：持有一个指向已经销毁对象（通过调用析构函数）的指针仍是可能的：</p>
<pre><code class="language-cpp">// C++ code.
void investigate_file(File* f) {
  long array[4] = {1, 2, 3, 4}; // put things on the stack
  std::cout &lt;&lt; "in function: file at " &lt;&lt; f &lt;&lt; " has fd=" &lt;&lt; f-&gt;fd &lt;&lt; "\n";
}
</code></pre>
<pre><code>in function: file at 0x7ff7b6a7c438 has fd=-183042004
</code></pre>
<p>作为一个 C/C++程序员，取决于你来注意这一点，并确保你不会解引用一个指向已消失内容的指针。或者，如果你是一名攻击者并且发现一个悬垂指针，那么你很可能疯狂地咯咯笑，并且利用该漏洞，兴高采烈地解引用该指针。</p>
<p>对于 Rust 来说。Rust 核心吸引力就是从根本上解决了悬垂指针的问题，这立即解决了一堆安全问题。<sup class="footnote-reference"><a href="#chapter_3-item14-lifetimes-1">1</a></sup></p>
<p>为了这一点需要把生命周期的概念从后台（C/C++程序员只需要知道注意它们，没有任何语言支持）拿到前台来：每个包含<code>&amp;</code>符号的类型都有一个关联的生命周期(<code>'a</code>)，即使编译器允许你在大部分时间忽略它。</p>
<h2 id="chapter_3-item14-lifetimes-生命周期的作用域"><a class="header" href="#chapter_3-item14-lifetimes-生命周期的作用域">生命周期的作用域</a></h2>
<p>一个在栈上的数据的生命周期是保证它在栈上同一个位置的时间段；换句话说，生命周期是保证对该数据的<em>引用</em>（指针）不会变得无效的时间段。</p>
<p>一个数据的生命周期从被创建开始，一直到该数据<em>被 drop</em>（Rust 中与 C++中对象销毁相同的概念）或<em>被移动</em>。</p>
<p>Rust 中生命周期的普遍性有时会让来自 C/C++的程序员惊讶：很多情况下，Rust 将数据从栈上的一个位置移动到另一个位置，或者从栈移动到堆上，或者从堆移动到栈上。</p>
<p>该数据被自动 drop 的确切位置取决于该数据是否有一个名称。</p>
<p>局部变量和函数参数都提供了名称，并且对应的生命周期从该数据有名称开始：</p>
<ul>
<li>对于局部变量：在<code>let var = ...</code>处声明</li>
<li>对于函数参数：作为函数调用执行框架设置的一部分</li>
</ul>
<p>当有名称的数据被移动或者名称超出范围，该命名数据的生命周期就会结束：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
/// 某数据的定义
pub struct Item {
    contents: u32,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let item1 = Item { contents: 1 }; // `item1` 数据 1 在此创建
    let item2 = Item { contents: 2 }; // `item2` 数据 2 在此创建
    println!("item1 = {item1:?}, item2 = {item2:?}");
    consuming_fn(item2); // `item2` 数据 2 在此被移动
} // `item1` 数据 1 在此被drop
<span class="boring">}</span></code></pre></pre>
<p>还可以“即时”地创建一个数据，作为要传入到其他数据的一部分。这些未命名的数据在不再需要时被 drop。考虑这个问题一个简单但有效的方法是想象表达式的每个部分都会展开它自己的块，通过编译器插入临时变量。例如，这样的表达式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = f((a + b) * 2);
<span class="boring">}</span></code></pre></pre>
<p>大致相当于：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {
    let temp1 = a + b;
    {
        let temp2 = temp1 * 2;
        f(temp2)
    } // `temp2` 临时数据 2 在这里drop
}; // `temp1` 临时数据 1 在这里drop
<span class="boring">}</span></code></pre></pre>
<p>当执行到原始行末尾的分号时，临时数据已经全部被 drop。</p>
<p>查看编译器计算数据生命周期的一种方法是插入一个故意的错误，来让借用检查器（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）检测。例如，保留对超出生命周期的数据的引用：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: &amp;Item;
{
    let item = Item { contents: 42 };
    r = &amp;item;
}
println!("r.contents = {}", r.contents);
<span class="boring">}</span></code></pre></pre>
<p>错误消息会指明<code>item</code>的生命周期的确切终点：</p>
<pre><code>error[E0597]: `item` does not live long enough
   --&gt; src/main.rs:190:13
    |
189 |         let item = Item { contents: 42 };
    |             ---- binding `item` declared here
190 |         r = &amp;item;
    |             ^^^^^ borrowed value does not live long enough
191 |     }
    |     - `item` dropped here while still borrowed
192 |     println!("r.contents = {}", r.contents);
    |                                 ---------- borrow later used here
</code></pre>
<p>同样的，对于未命名的临时数据：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
println!("r.contents = {}", r.contents);
<span class="boring">}</span></code></pre></pre>
<p>错误消息显示了表达式末尾的终点：</p>
<pre><code>error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:209:46
    |
209 | let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
    |                                      ^^^^^^^^^^^^^^^^^^^^^ - temporary
    |                                      |           value is freed at the
    |                                      |           end of this statement
    |                                      |
    |                                      creates a temporary value which is
    |                                      freed while still in use
210 | println!("r.contents = {}", r.contents);
    |                             ---------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>关于<em>引用</em>生命周期的最后一点：如果编译器可以自证代码中某处之外没有再使用该引用，那么它将引用的生命周期的末尾端点视为最后使用的位置，而不是在一个中括号范围的末尾。这个特性被称为<a href="https://rust-lang.github.io/rfcs/2094-nll.html">非词法生命周期</a>（NLL），这允许借用检查器更灵活一些：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // `s` 拥有 `String`。
    let mut s: String = "Hello, world".to_string();

    // 创建一个 `String` 的可变引用
    let greeting = &amp;mut s[..5];
    greeting.make_ascii_uppercase();
    // .. 在这之后没再使用 `greeting`

    // 创建一个 `String` 的不可变引用是允许的，
    // 即使这里有一个可变引用还在该中括号范围内
    let r: &amp;str = &amp;s;
    println!("s = '{}'", r); // s = 'HELLO, world'
} // 可变引用 `greeting` 会在这里被drop
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_3-item14-lifetimes-生命周期标注"><a class="header" href="#chapter_3-item14-lifetimes-生命周期标注">生命周期标注</a></h2>
<p>尽管 Rust 中处理引用时生命周期无处不在，但是你不必详细标注——没有人会说：“我正在处理<code>ref.rs</code>从第 17 行延伸到第 32 行的生命周期”。相反，代码中的引用有任意名称的生命周期，通常是<code>'a</code>，<code>'b</code>，<code>'c</code>等等，并且编译器有其自己的内部，不可访问的表示形式，这些表示形式相当于源代码中内容。（唯一例外是<code>'static</code>生命周期，这是一个特殊情况，后续将会介绍。）</p>
<p>你不必对生命周期的名称考虑太多；主要考虑的事情是比较一个名称和另一个名称，或重复名称来标注两个生命周期是“相同的”。</p>
<p>这种生命周期标注最容易用函数签名来说明：如果函数的输入和输出需要处理引用，那么它们的生命周期之间是什么关系？</p>
<p>最常见的情况就是接收单个引用作为输入并返回一个引用的函数。返回的引用必须有一个生命周期，那么是什么呢？这里只有一种可能（除了<code>'static</code>）可供选择：输入的生命周期，这意味着它们共享相同的名称，例如<code>'a</code>。把该名称作为生命周期标注，添加给这两个类型会得到：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn first&lt;'a&gt;(data: &amp;'a [Item]) -&gt; Option&lt;&amp;'a Item&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>因为这种情况非常常见，并且因为（几乎）没有选择关于输出的生命周期应该是什么，Rust 具有<em>生命周期省略</em>规则，这意味着你不必为这种情况显式标注生命周期名称。相同的函数签名更惯用的版本应该是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn first(data: &amp;[Item]) -&gt; Option&lt;&amp;Item&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>所涉及的引用仍具有生命周期——省略规则只是意味着你不必编写任何生命周期名称并在这两个地方使用它。</p>
<p>如果有不止一种输入的生命周期选择可以映射到返回值的生命周期呢？这种情况下，编译器无法弄清楚该怎么做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:56:55
   |
56 | pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {
   |                       -----          -----            ^ expected named
   |                                                     lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
           signature does not say whether it is borrowed from `haystack` or
           `needle`
help: consider introducing a named lifetime parameter
   |
56 | pub fn find&lt;'a&gt;(haystack: &amp;'a [u8], needle: &amp;'a [u8]) -&gt; Option&lt;&amp;'a [u8]&gt; {
   |            ++++            ++                ++                  ++
</code></pre>
<p>基于函数和参数名称的精明的假设是，此处输出的预期生命周期应该和输入的<code>haystack</code>匹配：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find&lt;'a, 'b&gt;(
    haystack: &amp;'a [u8],
    needle: &amp;'b [u8],
) -&gt; Option&lt;&amp;'a [u8]&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>有趣的是，编译器建议了一种不同的替代方式：让函数的两个输入使用<em>相同的</em>生命周期<code>'a</code>。例如，以下这个函数其中的生命周期组合或许会有意义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn smaller&lt;'a&gt;(left: &amp;'a Item, right: &amp;'a Item) -&gt; &amp;'a Item {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>这<em>似乎</em>暗示输入的两个生命周期是“一样的”，但这话用了引号（这里和之前）表明情况并非如此。</p>
<p>设计生命周期的原因就是确保数据的引用不会活得比数据本身更长；考虑这点，输出的生命周期<code>'a</code>与输入的生命周期<code>'a</code>“相同”，只是意味着输入必须比输出活得久。</p>
<p>当两个生命周期都是“相同的”<code>'a</code>时，这仅意味着输出的生命周期必须包含在两个输入的生命周期内。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let outer = Item { contents: 7 };
    {
        let inner = Item { contents: 8 };
        {
            let min = smaller(&amp;inner, &amp;outer);
            println!("smaller of {inner:?} and {outer:?} is {min:?}");
        } // `min` dropped
    } // `inner` dropped
} // `outer` dropped
<span class="boring">}</span></code></pre></pre>
<p>换句话说，输出的生命周期必须包含在两个输入寿命中<em>较小的</em>那一个。</p>
<p>相反，如果生命周期与输入之一的生命周期无关，则不需要这些生命周期嵌套。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let haystack = b"123456789"; // 生命周期 'a 开始
    let found = {
        let needle = b"234"; // 生命周期 'b 开始
        find(haystack, needle)
    }; // 生命周期 'b 结束
    println!("found={:?}", found); // `found` 在 'a 内部， 在 'b 外部使用
} // 声明周期 'a 结束
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_3-item14-lifetimes-生命周期省略规则"><a class="header" href="#chapter_3-item14-lifetimes-生命周期省略规则">生命周期省略规则</a></h2>
<p>除了前面描述的“一入，一出”的省略规则之外，还有另外两种可以省略标注名称的规则。</p>
<p>第一种情况是函数的输出没有引用；这种情况下，输入的引用都会自动获得自己的生命周期，且与其他输入的参数不同。</p>
<p>第二种情况是方法中有<code>self</code>的引用（<code>&amp;self</code>或<code>&amp;mut self</code>）；这种情况下，编译器会假设任何输出的引用的生命周期与<code>self</code>相同，因为这（到目前为止）是最常见的情况。</p>
<p>以下是函数生命周期省略规则的总结：</p>
<ul>
<li>一个输入，一个或者多个输出：假设输入和输出有“相同的”生命周期：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x: &amp;Item) -&gt; (&amp;Item, &amp;Item)
// ... 相当于 ...
fn f&lt;'a&gt;(x: &amp;'a Item) -&gt; (&amp;'a Item, &amp;'a Item)
<span class="boring">}</span></code></pre></pre>
<ul>
<li>多个输入，没有输出：假设所有输入都有不同的生命周期：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x: &amp;Item, y: &amp;Item, z: &amp;Item) -&gt; i32
// ... 相当于 ...
fn f&lt;'a, 'b, 'c&gt;(x: &amp;'a Item, y: &amp;'b Item, z: &amp;'c Item) -&gt; i32
<span class="boring">}</span></code></pre></pre>
<ul>
<li>多个输入，包括<code>&amp;self</code>，一个或多个输入：假设输出的生命周期与<code>&amp;self</code>的生命周期“相同”：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(&amp;self, y: &amp;Item, z: &amp;Item) -&gt; &amp;Thing
// ... 相当于 ...
fn f(&amp;'a self, y: &amp;'b Item, z: &amp;'c Item) -&gt; &amp;'a Thing
<span class="boring">}</span></code></pre></pre>
<p>当然，如果省略的生命周期标注没有达到你的预期，你仍可以显式标注生命周期来指定哪些生命周期彼此相关。实际上，这会导致编译报错，该错误表明省略的生命周期不能匹配函数或调用者涉及的引用。</p>
<h2 id="chapter_3-item14-lifetimes-static生命周期"><a class="header" href="#chapter_3-item14-lifetimes-static生命周期"><code>'static</code>生命周期</a></h2>
<p>上一节描述了函数的输入和输出的引用的生命周期之间的各种可能的映射，但是忽略了一种特殊情况。如果没有输入生命周期，但输出的返回值仍然包含引用会发生什么？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn the_answer() -&gt; &amp;Item {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:471:28
    |
471 |     pub fn the_answer() -&gt; &amp;Item {
    |                            ^ expected named lifetime parameter
    |
    = help: this function's return type contains a borrowed value, but there
            is no value for it to be borrowed from
help: consider using the `'static` lifetime
    |
471 |     pub fn the_answer() -&gt; &amp;'static Item {
    |                             +++++++
</code></pre>
<p>唯一允许的改正是对于返回的引用，有一个生命周期保证永远它不会超出作用范围。这是由特殊的生命周期<code>'static</code>来标注的，它也是唯一一个特定名称而不是任意占位符名称的生命周期。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn the_answer() -&gt; &amp;'static Item {
<span class="boring">}</span></code></pre></pre>
<p>获取有<code>'static</code>生命周期的引用最简单的方法是引用已经标记为<a href="https://doc.rust-lang.org/std/keyword.static.html">static</a>的全局变量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static ANSWER: Item = Item { contents: 42 };

pub fn the_answer() -&gt; &amp;'static Item {
    &amp;ANSWER
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 编译器保证这个<code>static</code>变量在整个程序的持续时间中具有相同的地址并永远不会移动。这意味着<code>static</code>变量具有<code>'static</code>生命周期，从逻辑上来说是这样。</p>
<p>很多情况下，对<code>const</code>变量的引用也会被<a href="https://doc.rust-lang.org/reference/destructors.html#constant-promotion">提升</a>为<code>'static</code>生命周期，但是有一些小的副作用需要注意。首先，如果涉及的类型具有析构函数或者内部可变性，则不会发生此提升：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Wrapper(pub i32);

impl Drop for Wrapper {
    fn drop(&amp;mut self) {}
}

const ANSWER: Wrapper = Wrapper(42);

pub fn the_answer() -&gt; &amp;'static Wrapper {
    // `Wrapper` 有析构函数，所以const变量的引用无法提升到 `'static` 生命周期
    &amp;ANSWER
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0515]: cannot return reference to temporary value
   --&gt; src/main.rs:520:9
    |
520 |         &amp;ANSWER
    |         ^------
    |         ||
    |         |temporary value created here
    |         returns a reference to data owned by the current function
</code></pre>
<p>第二个潜在副作用是，只有<code>const</code>的<em>值</em>才能保证在各处都相同；无论变量在何处被使用，编译器都可以根据需要制作任意份拷贝。如果你正在依赖<code>'static</code>引用背后的底层指针值来做些邪恶事，请注意这可能涉及多个内存位置。</p>
<p>还有一种方法来获取具有<code>'static</code>生命周期的引用。<code>'static</code>主要承诺了该生命周期应该比程序中任何其他生命周期都长；在堆上分配且<em>从未释放</em>的值也满足此约束。</p>
<p>普通的堆上分配<code>Box&lt;T&gt;</code>在此处不起作用，因为不能保证（如下一节所述）该数据不会在超出作用域后被丢弃。</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let boxed = Box::new(Item { contents: 12 });
    let r: &amp;'static Item = &amp;boxed;
    println!("'static item is {:?}", r);
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0597]: `boxed` does not live long enough
   --&gt; src/main.rs:344:32
    |
343 |     let boxed = Box::new(Item { contents: 12 });
    |         ----- binding `boxed` declared here
344 |     let r: &amp;'static Item = &amp;boxed;
    |            -------------   ^^^^^^ borrowed value does not live long enough
    |            |
    |            type annotation requires that `boxed` is borrowed for `'static`
345 |     println!("'static item is {:?}", r);
346 | }
    | - `boxed` dropped here while still borrowed
</code></pre>
<p>然而，<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a>函数可以把已有所有权的<code>Box&lt;T&gt;</code>变为<code>T</code>的可变引用。不再有所有者拥有该值的所有权，因此它将会永远不会被删除——这满足了<code>'static</code>生命周期的要求：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let boxed = Box::new(Item { contents: 12 });

    // `leak()` 销毁了 `Box&lt;T&gt;` 并返回 `&amp;mut T`.
    let r: &amp;'static Item = Box::leak(boxed);

    println!("'static item is {:?}", r);
} // `boxed` 在这里没被drop，因为它被移动进了 `Box::leak()`

// 因为 `r` 没有超出作用域，`Item` 被永远的泄漏了。
<span class="boring">}</span></code></pre></pre>
<p>无法 drop 该数据，也意味着永远无法使用 safe Rust 来回收该数据的内存，这可能会导致永久性的内存泄漏。（注意，这块泄漏的内存并不违反 Rust 的内存安全保证——内存中永远无法访问的数据仍然是安全的。）</p>
<h2 id="chapter_3-item14-lifetimes-生命周期和堆"><a class="header" href="#chapter_3-item14-lifetimes-生命周期和堆">生命周期和堆</a></h2>
<p>到目前为止的讨论集中在栈上数据的生命周期，无论是函数参数，局部变量或临时变量。但堆上的数据又如何呢？</p>
<p>关于堆上的值要认识到关键的事情是每块数据都有一个所有者（除了特殊情况，例如上一节描述的故意泄漏(leak)）。例如，一个简单的<code>Box&lt;T&gt;</code>就可以把<code>T</code>的值放堆上，同时变量也就是所有者拥有<code>Box&lt;T&gt;</code>的所有权。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let b: Box&lt;Item&gt; = Box::new(Item { contents: 42 });
} // `b` 在此drop，那么 `Item` 也drop了。
<span class="boring">}</span></code></pre></pre>
<p>拥有所有权的<code>Box&lt;Item&gt;</code>在超出生命周期范围后 drop 了里面的数据，因此堆上的<code>Item</code>的生命周期与栈上的的<code>Box&lt;Item&gt;</code>相同。</p>
<p>堆上的值的所有者本身可能也在堆上，而不是栈上，那么此时谁拥有该所有者？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let b: Box&lt;Item&gt; = Box::new(Item { contents: 42 });
    let bb: Box&lt;Box&lt;Item&gt;&gt; = Box::new(b); // `b` 被移动到堆上
} // `bb` 在此drop，那么 `Box&lt;Item&gt;` 也drop了，那么 `Item` 也drop了。
<span class="boring">}</span></code></pre></pre>
<p>所有权链必须在某处结束，并只有两种可能性：</p>
<ul>
<li>该链以局部变量或函数参数结束——这种情况下该链中所有数据的生命周期就是栈上变量的生命周期<code>'a</code>。当栈上的变量超出作用域，该链上所有数据也都被 drop。</li>
<li>该链以标记了<code>static</code>的全局变量结束——这种情况下，链中所有的数据的生命周期都是<code>'static</code>的，<code>static</code>变量永远不会超出作用域，所以链中任何内容都不会被自动 drop。</li>
</ul>
<p>总结，堆上数据的生命周期根本上是绑定到栈上的生命周期。</p>
<h2 id="chapter_3-item14-lifetimes-结构体中的生命周期"><a class="header" href="#chapter_3-item14-lifetimes-结构体中的生命周期">结构体中的生命周期</a></h2>
<p>前面关于生命周期的章节集中于函数的输入和输出，但是存储在结构体中的引用也存在类似问题。</p>
<p>如果试图在不使用生命周期标注的情况下，偷偷把引用放到结构体中，编译器会发生尖锐的爆鸣声：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReferenceHolder {
    pub index: usize,
    pub item: &amp;Item,
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:548:19
    |
548 |         pub item: &amp;Item,
    |                   ^ expected named lifetime parameter
    |
help: consider introducing a named lifetime parameter
    |
546 ~     pub struct ReferenceHolder&lt;'a&gt; {
547 |         pub index: usize,
548 ~         pub item: &amp;'a Item,
    |
</code></pre>
<p>像往常一样，编译器错误信息告诉我们应该怎么做。第一部分很简单：为引用类型显式标注一个生命周期<code>'a</code>，因为结构体中使用引用没有生命周期省略规则。</p>
<p>第二部分不太明显，但具有更深层次的影响：结构体本身需要一个生命周期参数<code>&lt;'a&gt;</code>，它与包含的引用的生命周期相匹配：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 由于字段有引用，所以结构体需要有生命周期参数
pub struct ReferenceHolder&lt;'a&gt; {
    pub index: usize,
    pub item: &amp;'a Item,
}
<span class="boring">}</span></code></pre></pre>
<p>结构体的生命周期参数具有传染性：任何结构体包含了该类型也必须获取一个生命周期参数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 由于字段有生命周期参数，所以结构体需要有生命周期参数
pub struct RefHolderHolder&lt;'a&gt; {
    pub inner: ReferenceHolder&lt;'a&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>如果结构体包含切片类型，则也需要生命周期参数，因为它们又是对借用数据的引用。</p>
<p>如果结构体包含多个相互关联的生命周期的字段，那么你必须选择合适的生命周期绑定。在一对字符串内查找公共子串是一个非常好的具有独立生命周期的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一对字符串的公共子串存在的位置
pub struct LargestCommonSubstring&lt;'a, 'b&gt; {
    pub left: &amp;'a str,
    pub right: &amp;'b str,
}

/// 在 `left` 和 `right` 字符串中找到最长公共子串
pub fn find_common&lt;'a, 'b&gt;(
    left: &amp;'a str,
    right: &amp;'b str,
) -&gt; Option&lt;LargestCommonSubstring&lt;'a, 'b&gt;&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>而引用同一字符串的多个位置的结构体，将具有共同的生命周期：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 在一个字符串内重复的两个子串
pub struct RepeatedSubstring&lt;'a&gt; {
    pub first: &amp;'a str,
    pub second: &amp;'a str,
}

/// 找到 `s` 中第一个重复子串。
pub fn find_repeat&lt;'a&gt;(s: &amp;'a str) -&gt; Option&lt;RepeatedSubstring&lt;'a&gt;&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>生命周期参数的传播是有意义的：任何包含引用的东西，无论嵌套多深，都仅在所引用数据的生命周期内有效。如果该数据被移动或 drop，那么整个结构体嵌套链都不再有效。</p>
<p>然而，这也意味着涉及引用的结构体更难使用——结构体的所有者必须保证生命周期全部一致。因此，<strong>尽可能选择拥有其内部数据所有权的结构体</strong>，特别是在代码不需要高度优化(<a href="https://www.lurklurk.org/effective-rust/optimize.html">第 20 条</a>)的情况下。如果做不到这一点，<a href="#chapter_3-chapter_1-item8-references&amp;pointer">第 8 条</a>描述的各种智能指针类型(例如<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>)可以让你生命周期约束中解放出来。</p>
<h1 id="chapter_3-item14-lifetimes-匿名生命周期"><a class="header" href="#chapter_3-item14-lifetimes-匿名生命周期">匿名生命周期</a></h1>
<p>当不能保证一个结构体拥有其数据的所有权时，结构体必然会以生命周期参数结束，如上一节所述。这可能会与本条之前说的生命周期省略规则产生一些不幸。</p>
<p>例如，考虑一个返回带有生命周期参数的结构体的函数。该函数的完全显式标注使涉及的生命周期变得清晰易读：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_one_item&lt;'a&gt;(items: &amp;'a [Item]) -&gt; ReferenceHolder&lt;'a&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>然而，省略生命周期的相同标注可能会有点误导：</p>
<pre><code>pub fn find_one_item(items: &amp;[Item]) -&gt; ReferenceHolder {
    // ...
}
</code></pre>
<p>因为返回类型的生命周期参数被省略，因此阅读代码的人不会得到太多涉及生命周期的提示。</p>
<p>匿名生命周期<code>'_</code>允许你将省略的生命周期标注出来，而无需恢复<em>所有</em>生命周期名称。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_one_item(items: &amp;[Item]) -&gt; ReferenceHolder&lt;'_&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>粗略地说，<code>'_</code>标注要求编译器为我们生成一个唯一的生命周期名称，我们可以在不需要其他地方使用该名称的情况下使用它。</p>
<p>这意味着对于其他生命周期省略场景也很有用。例如，<code>Debug</code> trait 的<code>fmt</code>方法，使用匿名生命周期来指示<code>Formatter</code>实例具有和<code>&amp;self</code>不同的生命周期，但该生命周期是什么名称并不重要：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_3-item14-lifetimes-牢记"><a class="header" href="#chapter_3-item14-lifetimes-牢记">牢记</a></h2>
<ul>
<li>所有的 Rust 引用都有一个关联的生命周期，由生命周期标签(比如<code>'a</code>)指示。在某些常见情况下，函数参数和返回值的生命周期可以省略（但仍然存在）。</li>
<li>任何（传递地）包含引用的结构体都有关联的生命周期参数；因此，使用拥有其数据所有权的结构体通常更容易。</li>
<li><code>'static</code>生命周期用来保证永远不会超出作用域的数据的引用，例如全局数据或堆上已经显式泄漏的数据。</li>
<li>生命周期标签只能指示生命周期是“相同的”，这意味着输出的生命周期被包含在输入的一个（或更多）生命周期内。</li>
<li>匿名生命周期<code>'_</code>可以用在不需要特定生命周期标签的地方。</li>
</ul>
<h4 id="chapter_3-item14-lifetimes-注释"><a class="header" href="#chapter_3-item14-lifetimes-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_3-item14-lifetimes-1"><sup class="footnote-definition-label">1</sup>
<p>例如，Chromium 项目估计<a href="https://www.chromium.org/Home/chromium-security/memory-safety/">70%的安全 bug 都归咎于内存安全。</a></p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3-item15-borrows"></div><h1 id="chapter_3-item15-borrows-第-15-条理解借用检查器"><a class="header" href="#chapter_3-item15-borrows-第-15-条理解借用检查器">第 15 条：理解借用检查器</a></h1>
<p>Rust 中的每一个值都有一个所有者，但该所有者可以将值借用到代码中的其他位置。这种<em>借用</em>机制涉及<em>引用</em>的创建和使用。并遵守<em>借用检查器</em>(本条的主题)的规则。</p>
<p>抛开表面，Rust 引用使用与 C 或 C++代码中相当常见的相同类型<em>指针</em>值（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>），但为了确保避免 C/C++中的错误，这个指针有规则和限制。来快速比较一下：</p>
<ul>
<li>就像 C/C++指针一样，Rust 引用使用&amp;符号创建：<code>&amp;value</code>。</li>
<li>就像 C++ 引用一样，Rust 引用不能为<code>nullptr</code>。</li>
<li>就像 C/C++指针或引用一样，Rust 引用可以在创建后进行修改来引用不同内容。</li>
<li>与 C++ 不同，从值创建的引用总是需要显式（<code>&amp;</code>）传参——如果你看到这样的代码<code>f(value)</code>，你应该意识到<code>f</code>正在接收传入值的所有权。（但是，如果这个<code>value</code>的类型实现了<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>，那么它可能接收的是该数据的<code>copy</code>的所有权——详见<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>。）</li>
<li>与 C/C++ 不同，新创建的可变引用总是显式标明（<code>&amp;mut</code>）。如果你看到了这样的代码<code>f(&amp;value)</code>，你应该意识到<code>value</code>不能被改变（即 C/C++中的<code>const</code>）。只有像<code>f(&amp;mut value)</code>这样的表达式才可能更改<code>value</code>的内容。<sup class="footnote-reference"><a href="#chapter_3-item15-borrows-1">1</a></sup></li>
</ul>
<p>C/C++指针和 Rust 引用之间最重要的区别由术语<em>借用</em> <em>(borrow)</em> 表示：你可以获取某个数据的引用（指针），<em>但是你不能永久持有该引用</em>。特别是，你不能持有它活得比指向数据的生命周期更长，正如编译器所跟踪的生命周期，以及我们在<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中探索过的一样。</p>
<p>这些对引用的限制使得 Rust 能保证其内存安全，但这也意味着你需要接受借用规则的学习成本，并接受它改变你如何设计软件的方式——尤其是存储数据的结构体。</p>
<p>本条会首先描述 Rust 的引用可以做什么，以及使用它们的借用检查器规则。本条的其余部分重点关注使用这些规则后更改代码的措施：如何重构，返工和重新设计代码，以便在与借用检查器斗争中获胜。</p>
<h2 id="chapter_3-item15-borrows-访问控制"><a class="header" href="#chapter_3-item15-borrows-访问控制">访问控制</a></h2>
<p>有三种办法来访问一块 Rust 数据：通过这块数据的<em>所有者</em>(<code>item</code>)，<em>引用</em>(<code>&amp;item</code>)，或<em>可变引用</em>(<code>&amp;mut item</code>)。每种访问数据的方式都有不同的访问权。使用<a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>存储模型（增删改查）来粗略地概括（Rust <em>drop</em> 术语即 <em>delete</em> ）：</p>
<ul>
<li>数据的所有者可以<em>创建</em> <em>(create)</em>，<em>读取</em> <em>(read)</em>，<em>更新</em> <em>(update)</em>，或<em>删除</em> <em>(drop)</em> 它。</li>
<li>可变引用可以从底层数据中<em>读取</em>，或<em>更新</em>它。</li>
<li>（普通）引用只能<em>读取</em>底层数据。</li>
</ul>
<p>这儿有个 Rust 独有的数据访问规则：只有该数据的所有者可以<em>移动</em>该数据。如果你认为移动就是<em>创建</em>（在新位置）并<em>drop</em>这些数据占用的内存（在旧位置）的某种组合，这或许有点道理。</p>
<p>对于一块数据的可变引用的代码，这可能会导致一些奇怪情况。例如，下面替换<code>Option</code>内部值是允许的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 这段代码使用的结构体。
#[derive(Debug)]
pub struct Item {
    pub contents: i64,
}

/// 替换 `item` 的 content 为 `val`.
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) {
    *item = Some(val);
}
<span class="boring">}</span></code></pre></pre>
<p>但是返回之前的值的操作违反了移动限制：<sup class="footnote-reference"><a href="#chapter_3-item15-borrows-2">2</a></sup></p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 替换 `item` 的 content 为 `val`，返回之前的 content
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
    let previous = *item; // 移出所有权
    *item = Some(val); // 替换
    previous
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0507]: cannot move out of `*item` which is behind a mutable reference
  --&gt; src/main.rs:34:24
   |
34 |         let previous = *item; // move out
   |                        ^^^^^ move occurs because `*item` has type
   |                              `Option&lt;inner::Item&gt;`, which does not
   |                              implement the `Copy` trait
   |
help: consider removing the dereference here
   |
34 -         let previous = *item; // move out
34 +         let previous = item; // move out
   |
</code></pre>
<p>尽管从一个可变引用<em>读取</em>是有效的，但这段代码尝试在用新值替换该被移动的值之前，将值<em>移出</em>——并试图避免复制(copy)原始值。借用检查器非常保守，并注意到在两行中间存在一段可变引用未引用有效值的时间段。</p>
<p>对人来说，我们知道这种组合操作——提取旧值并使用新值替换——是既安全又实用的，所以标准库提供了 <a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>std::mem::replace</code></a> 函数。在底层上，<code>replace</code> 使用了 <code>unsafe</code> （参考<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>）来一次性执行交换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 替换 `item` 的 content 为 `val`，返回之前的 content
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
    std::mem::replace(item, Some(val)) // 返回之前的值
}
<span class="boring">}</span></code></pre></pre>
<p>特别对于 <code>Option</code> 类型，由于这是一种非常常见的模式，所以 <code>Option</code> 自己提供了 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.replace"><code>replace</code></a> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 替换 `item` 的 content 为 `val`，返回之前的 content
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
    item.replace(val) // 返回之前的值
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_3-item15-borrows-借用规则"><a class="header" href="#chapter_3-item15-borrows-借用规则">借用规则</a></h2>
<p>Rust 中借用引用时主要有两条关键规则需牢记。</p>
<p>第一条规则是任何引用的作用域必须小于所引用的数据的生命周期。<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>详细讨论了生命周期，但是值得注意的是编译器对于引用生命周期有特殊行为；<em>非词法生命周期</em>特性允许引用生命周期缩短，以便让他们在最后一次使用时结束，而不是在中括号末尾结束。</p>
<p>借用引用的第二条规则是，除了数据的所有者之外，还可以是以下任一一种借用方式：</p>
<ul>
<li>对数据的任意数量不可变引用</li>
<li>对数据的单个可变引用</li>
</ul>
<p>当然，不能同时用两者（在代码中的同一个位置）。</p>
<p>因此，同一个数据的引用可以被传入参数为多个不可变引用的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 判断两个参数是否都为零
fn both_zero(left: &amp;Item, right: &amp;Item) -&gt; bool {
    left.contents == 0 &amp;&amp; right.contents == 0
}

let item = Item { contents: 0 };
assert!(both_zero(&amp;item, &amp;item));
<span class="boring">}</span></code></pre></pre>
<p>但是参数有多个<em>可变</em>引用就不能了：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 判断两个参数是否都为零
fn zero_both(left: &amp;mut Item, right: &amp;mut Item) {
    left.contents = 0;
    right.contents = 0;
}

let mut item = Item { contents: 42 };
zero_both(&amp;mut item, &amp;mut item);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0499]: cannot borrow `item` as mutable more than once at a time
   --&gt; src/main.rs:131:26
    |
131 |     zero_both(&amp;mut item, &amp;mut item);
    |     --------- ---------  ^^^^^^^^^ second mutable borrow occurs here
    |     |         |
    |     |         first mutable borrow occurs here
    |     first borrow later used by call
</code></pre>
<p>对于函数参数有可变引用和不可变引用的混合来说，也有同样的限制：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 把 `left` 的 content 设置为 `right` 的 content。
fn copy_contents(left: &amp;mut Item, right: &amp;Item) {
    left.contents = right.contents;
}

let mut item = Item { contents: 42 };
copy_contents(&amp;mut item, &amp;item);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0502]: cannot borrow `item` as immutable because it is also borrowed
              as mutable
   --&gt; src/main.rs:159:30
    |
159 |     copy_contents(&amp;mut item, &amp;item);
    |     ------------- ---------  ^^^^^ immutable borrow occurs here
    |     |             |
    |     |             mutable borrow occurs here
    |     mutable borrow later used by call
</code></pre>
<p>借用规则允许编译器对数据的<a href="https://en.wikipedia.org/wiki/Aliasing_(computing)">别名</a>作出更好的决策：即跟踪何时两个不同的指针可能或可能不，引用内存中同一个底层数据。如果编译器可以确定（正如 Rust 中那样）一些不可变引用所指向的内存位置，不会通过一个已设置别名的<em>可变</em>引用进行更改，那么编译器可以生成具有以下优点的代码：</p>
<ul>
<li><em>得到更好的优化</em>：例如值可以被缓存到寄存器中，因为已知底层的内存存储的内容不会同时改变。</li>
<li><em>更安全</em>：线程之间对内存的不同步访问（<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>）不会引起数据竞争。</li>
</ul>
<h2 id="chapter_3-item15-borrows-所有者操作"><a class="header" href="#chapter_3-item15-borrows-所有者操作">所有者操作</a></h2>
<p>围绕引用存在的规则导致了一个重要后果，它们还会影响数据所有者可执行的操作。帮助理解这一点的一种方法是想象涉及所有者的操作是通过在幕后创建和使用引用来执行的。</p>
<p>例如，尝试通过数据所有者来更新数据相当于创建了一个临时的可变引用，然后通过这个引用来更新数据。如果另外一个引用已存在，那么这个名义上第二个可变引用将会无法被创建：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut item = Item { contents: 42 };
let r = &amp;item;
item.contents = 0;
// ^^^ 更改这个 item 大概相当于
//   (&amp;mut item).contents = 0;
println!("reference to item is {:?}", r);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0506]: cannot assign to `item.contents` because it is borrowed
   --&gt; src/main.rs:200:5
    |
199 |     let r = &amp;item;
    |             ----- `item.contents` is borrowed here
200 |     item.contents = 0;
    |     ^^^^^^^^^^^^^^^^^ `item.contents` is assigned to here but it was
    |                       already borrowed
...
203 |     println!("reference to item is {:?}", r);
    |                                           - borrow later used here
</code></pre>
<p>另一方面，由于多个<em>不可变</em>引用是被允许的，因此当存在不可变引用时，从所有者读取数据是可以的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = Item { contents: 42 };
let r = &amp;item;
let contents = item.contents;
// ^^^ 从 item 中读取大概相当于
//   let contents = (&amp;item).contents;
println!("reference to item is {:?}", r);
<span class="boring">}</span></code></pre></pre>
<p>但是存在<em>可变引用</em>是不可以的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut item = Item { contents: 42 };
let r = &amp;mut item;
let contents = item.contents; // i64 实现了 `Copy`
r.contents = 0;
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0503]: cannot use `item.contents` because it was mutably borrowed
   --&gt; src/main.rs:231:20
    |
230 |     let r = &amp;mut item;
    |             --------- `item` is borrowed here
231 |     let contents = item.contents; // i64 implements `Copy`
    |                    ^^^^^^^^^^^^^ use of borrowed `item`
232 |     r.contents = 0;
    |     -------------- borrow later used here
</code></pre>
<p>最后，任何处于活动状态的引用都会阻止数据的所有者移动或 drop 数据，因为这样的话，意味着引用将会引用无效的数据：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = Item { contents: 42 };
let r = &amp;item;
let new_item = item; // 移动
println!("reference to item is {:?}", r);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0505]: cannot move out of `item` because it is borrowed
   --&gt; src/main.rs:170:20
    |
168 |     let item = Item { contents: 42 };
    |         ---- binding `item` declared here
169 |     let r = &amp;item;
    |             ----- borrow of `item` occurs here
170 |     let new_item = item; // move
    |                    ^^^^ move out of `item` occurs here
171 |     println!("reference to item is {:?}", r);
    |                                           - borrow later used here
</code></pre>
<p>这种情况下，<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中描述的非词法生命周期非常有用，因为（粗略地说）它在最后一次使用引用后结束了生命周期，而不是在中括号封闭的结尾。在移动发生之前将引用的最终使用提前，意味着不会发生编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = Item { contents: 42 };
let r = &amp;item;
println!("reference to item is {:?}", r);

// 引用 `r` 仍在作用域但是不再使用，所以它被当作该引用已经被 drop
let new_item = item; // 正常进行移动
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_3-item15-borrows-在与借用检查器斗争中获胜"><a class="header" href="#chapter_3-item15-borrows-在与借用检查器斗争中获胜">在与借用检查器斗争中获胜</a></h2>
<p>Rust 新手（甚至更有经验的人！）常常会觉得他们在与借用检查器斗争中花费了太多时间。有什么方法可以帮助你赢得这些斗争？</p>
<h3 id="chapter_3-item15-borrows-本地代码重构"><a class="header" href="#chapter_3-item15-borrows-本地代码重构">本地代码重构</a></h3>
<p>第一个策略是关注编译器的错误信息，因为 Rust 开发者已经付出了大量努力来让它们尽可能有用：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 如果 `needle` 存在于 `haystack` 中， 返回包含它的切片。
pub fn find&lt;'a, 'b&gt;(haystack: &amp;'a str, needle: &amp;'b str) -&gt; Option&lt;&amp;'a str&gt; {
    haystack
        .find(needle)
        .map(|i| &amp;haystack[i..i + needle.len()])
}

// ...

let found = find(&amp;format!("{} to search", "Text"), "ex");
if let Some(text) = found {
    println!("Found '{text}'!");
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:353:23
    |
353 | let found = find(&amp;format!("{} to search", "Text"), "ex");
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       - temporary value
    |                   |                 is freed at the end of this statement
    |                   |
    |                   creates a temporary value which is freed while still in
    |                   use
354 | if let Some(text) = found {
    |                     ----- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>错误消息的第一部分是最重要的部分，因为它描述了编译器认为你违反哪些借用规则和原因。当你遇到足够多这样的错误时——你总会的——你会逐渐建立关于借用检查器的一种直觉，这种直觉与前面叙述的规则中包含的更理论化的版本相吻合。</p>
<p>错误消息的第二部分包括编译器对于如何修改该问题的建议，本例中是很简单的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let haystack = format!("{} to search", "Text");
let found = find(&amp;haystack, "ex");
if let Some(text) = found {
    println!("Found '{text}'!");
}
// `found` 现在引用了 `haystack`，它可以活到函数以外
<span class="boring">}</span></code></pre></pre>
<p>这是两个简单的代码调整实例之一，可以帮助“安抚”借用检查器：</p>
<ul>
<li><em>扩展生命周期</em>：使用 <code>let</code> 将一个临时变量（生命周期只到该表达式结尾）绑定到一个新的被命名的局部变量（生命周期被扩展到该块的末尾）。</li>
<li><em>缩减生命周期</em>：在使用的引用周围添加一个额外的块 <code>{ ... }</code>，以便其生命周期在新块的末尾结束。</li>
</ul>
<p>后者不太常见，因为非词法生命周期的存在：编译器通常可以在引用在块末尾正式释放之前，提前判断出该引用不再被使用。但是，如果你确实发现自己反复在相似的小代码块中周围引入一个人为的中括号块，那么需要考虑是否应该将这些代码封装到一个独立的方法中。</p>
<p>编译器建议的修复对于简单的问题很有帮助，但是当你编写更复杂的代码时，你会发现这些建议不再有用，而且对不符合借用规则之处的解释更难以理解：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

// 调用函数签名 `check_item(item: Option&lt;&amp;Item&gt;)`
check_item(x.as_ref().map(|r| r.borrow().deref()));
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0515]: cannot return reference to temporary value
   --&gt; src/main.rs:293:35
    |
293 |     check_item(x.as_ref().map(|r| r.borrow().deref()));
    |                                   ----------^^^^^^^^
    |                                   |
    |                                   returns a reference to data owned by the
    |                                       current function
    |                                   temporary value created here
</code></pre>
<p>这种情况下，临时引入一些局部变量会很有帮助，每个变量都对应了相应的转化步骤，并且每个变量都有对应的类型注解：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
    Some(Rc::new(RefCell::new(Item { contents: 42 })));

let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
check_item(x3);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0515]: cannot return reference to function parameter `r`
   --&gt; src/main.rs:305:40
    |
305 |     let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    |                                        ^^^^^^^^^ returns a reference to
    |                                      data owned by the current function
</code></pre>
<p>这缩小了编译器报错的精确转换范围，从而允许代码可以重构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
    Some(Rc::new(RefCell::new(Item { contents: 42 })));

let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
match x2 {
    None =&gt; check_item(None),
    Some(r) =&gt; {
        let x3: &amp;Item = r.deref();
        check_item(Some(x3));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>一旦根本问题明确并得到解决，之后你就可以轻松的把局部变量重新组合在一起，然后你就可以假装你是一直这样做对的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

match x.as_ref().map(|r| r.borrow()) {
    None =&gt; check_item(None),
    Some(r) =&gt; check_item(Some(r.deref())),
};
<span class="boring">}</span></code></pre></pre>
<h3 id="chapter_3-item15-borrows-结构体设计"><a class="header" href="#chapter_3-item15-borrows-结构体设计">结构体设计</a></h3>
<p>接下来有助于与借用检查器斗争的是在设计结构体时考虑使用借用检查器。你的结构体拥有所有它需要的数据是万能方法，避免使用任何引用以及随之而来的<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中所描述的生命周期注解的传播。</p>
<p>然而，对于现实世界的结构体来说，这不总是可能的；当数据结构的内部连接成一个比树结构（一个<code>根</code>拥有很多<code>分支</code>，每个分支又拥有它自己的<code>叶子</code>等）更相互关联的图时，那么简单的单一所有权是不可能的。</p>
<p>举一个简单的例子，想象一个简单的来宾详情登记册，记录他们按照顺序到达的时间：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
pub struct Guest {
    name: String,
    address: String,
    // ... many other fields
}

/// Local error type, used later.
#[derive(Clone, Debug)]
pub struct Error(String);

/// Register of guests recorded in order of arrival.
#[derive(Default, Debug)]
pub struct GuestRegister(Vec&lt;Guest&gt;);

impl GuestRegister {
    pub fn register(&amp;mut self, guest: Guest) {
        self.0.push(guest)
    }
    pub fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
        self.0.get(idx)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果此代码<em>也</em>需要根据到达时间和姓名字母表序来有效地查询来宾，那么根本上涉及两个结构体，并且其中一个拥有该数据。</p>
<p>如果涉及的数据很小且不可变，那么仅仅克隆数据就可以是一个快速的解决方案：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod cloned {
    use super::Guest;

    #[derive(Default, Debug)]
    pub struct GuestRegister {
        by_arrival: Vec&lt;Guest&gt;,
        by_name: std::collections::BTreeMap&lt;String, Guest&gt;,
    }

    impl GuestRegister {
        pub fn register(&amp;mut self, guest: Guest) {
            // 需要 `Guest` 来被 `Clone`
            self.by_arrival.push(guest.clone());
            // 为了示例更短，这里没有检查重复的名字
            self.by_name.insert(guest.name.clone(), guest);
        }
        pub fn named(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Guest&gt; {
            self.by_name.get(name)
        }
        pub fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
            self.by_arrival.get(idx)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而，如果数据可以被修改，那么这种克隆方法就显得捉襟见肘。例如，如果要更新 <code>Guest</code> 的地址，你需要找到两个存储的 Guest 的地方并确保这俩地方的数据保持同步。</p>
<p>另一种可能的方法是添加另一层中间层，将 <code>Vec&lt;Guest&gt;</code> 作为所有者，并使用向量索引来名称查找。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod indexed {
    use super::Guest;

    #[derive(Default)]
    pub struct GuestRegister {
        by_arrival: Vec&lt;Guest&gt;,
        // Guest 的 name to 映射到 `by_arrival` 的 index 的索引。
        by_name: std::collections::BTreeMap&lt;String, usize&gt;,
    }

    impl GuestRegister {
        pub fn register(&amp;mut self, guest: Guest) {
            // 为了示例更短，这里没有检查重复的名字
            self.by_name
                .insert(guest.name.clone(), self.by_arrival.len());
            self.by_arrival.push(guest);
        }
        pub fn named(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Guest&gt; {
            let idx = *self.by_name.get(name)?;
            self.nth(idx)
        }
        pub fn named_mut(&amp;mut self, name: &amp;str) -&gt; Option&lt;&amp;mut Guest&gt; {
            let idx = *self.by_name.get(name)?;
            self.nth_mut(idx)
        }
        pub fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
            self.by_arrival.get(idx)
        }
        pub fn nth_mut(&amp;mut self, idx: usize) -&gt; Option&lt;&amp;mut Guest&gt; {
            self.by_arrival.get_mut(idx)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个方法中，每一个来宾都由单个 <code>Guest</code> 数据表示，这允许 <code>named_mut()</code> 方法返回对该数据的可变引用。反过来意味着可以正常更改来宾的地址——（单个） <code>Guest</code> 由 <code>Vec</code> 所有，并且在底层上始终可被访问。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let new_address = "123 Bigger House St";
// 真实情况下，代码不会假设 "Bob" 存在...
ledger.named_mut("Bob").unwrap().address = new_address.to_string();

assert_eq!(ledger.named("Bob").unwrap().address, new_address);
<span class="boring">}</span></code></pre></pre>
<p>但是，如果来宾可以注销，则很容易无意中出现 bug：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 注销位置为 `idx` 的 `Guest`，随后的来宾都往前移
pub fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), super::Error&gt; {
    if idx &gt;= self.by_arrival.len() {
        return Err(super::Error::new("out of bounds"));
    }
    self.by_arrival.remove(idx);

    // 哦，忘记更新了 `by_name`。

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>现在 <code>Vec</code> 可能被打乱，其中的 <code>by_name</code> 索引实际上就像指针一样，但我们引入了一个 bug 会导致这些“指针”指向不存在的内容（超出 <code>Vec</code> 范围）或指向不正确的数据：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ledger.register(alice);
ledger.register(bob);
ledger.register(charlie);
println!("Register starts as: {ledger:?}");

ledger.deregister(0).unwrap();
println!("Register after deregister(0): {ledger:?}");

let also_alice = ledger.named("Alice");
// Alice 的索引仍然是 0，但现在该位置是 Bob
println!("Alice is {also_alice:?}");

let also_bob = ledger.named("Bob");
// Bob 的索引仍然是 1，但现在该位置是 Charlie
println!("Bob is {also_bob:?}");

let also_charlie = ledger.named("Charlie");
// Charlie 的索引仍然是 2，但现在已经超出了 Vec 索引范围
println!("Charlie is {also_charlie:?}");
<span class="boring">}</span></code></pre></pre>
<p>这里的代码使用自定义的 <code>Debug</code> 实现（没展示出来），以减少输出大小；截断的输出如下：</p>
<pre><code>Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {"Alice": 0, "Bob": 1, "Charlie": 2}
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {"Alice": 0, "Bob": 1, "Charlie": 2}
}
Alice is Some(Guest { name: "Bob", address: "234 Bobton" })
Bob is Some(Guest { name: "Charlie", address: "345 Charlieland" })
Charlie is None
</code></pre>
<p>前面的示例展示了 <code>注销</code> 代码的 bug，但是即便修复了这个 bug，也无法防止调用者使用该索引值，并传入 <code>nth()</code> ——从而获得意外或无效结果。</p>
<p>核心问题是两个结构体需要保持同步。处理这种问题的更好方法是使用 Rust 的智能指针（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>）。使用 <code>Rc</code> 和 <code>RefCell</code> 来避免使用索引作为无效指针的问题。更新示例——但是保持该 bug 不变——如下所示：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod rc {
    use super::{Error, Guest};
    use std::{cell::RefCell, rc::Rc};

    #[derive(Default)]
    pub struct GuestRegister {
        by_arrival: Vec&lt;Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
        by_name: std::collections::BTreeMap&lt;String, Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
    }

    impl GuestRegister {
        pub fn register(&amp;mut self, guest: Guest) {
            let name = guest.name.clone();
            let guest = Rc::new(RefCell::new(guest));
            self.by_arrival.push(guest.clone());
            self.by_name.insert(name, guest);
        }
        pub fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
            if idx &gt;= self.by_arrival.len() {
                return Err(Error::new("out of bounds"));
            }
            self.by_arrival.remove(idx);

            // 哦，又忘了更新 `by_name`。

            Ok(())
        }
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><code>Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Alice", {n: 'Alice', ...}), ("Bob", {n: 'Bob', ...}),
            ("Charlie", {n: 'Charlie', ...})]
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Alice", {n: 'Alice', ...}), ("Bob", {n: 'Bob', ...}),
            ("Charlie", {n: 'Charlie', ...})]
}
Alice is Some(RefCell { value: Guest { name: "Alice",
                                       address: "123 Aliceville" } })
Bob is Some(RefCell { value: Guest { name: "Bob",
                                     address: "234 Bobton" } })
Charlie is Some(RefCell { value: Guest { name: "Charlie",
                                         address: "345 Charlieland" } })
</code></pre>
<p>输出不再有不匹配的名称，但是 Alice 挥之不去的数据仍旧存在，直到我们确保两个集合保持同步，才能修复该 bug：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
    if idx &gt;= self.by_arrival.len() {
        return Err(Error::new("out of bounds"));
    }
    let guest: Rc&lt;RefCell&lt;Guest&gt;&gt; = self.by_arrival.remove(idx);
    self.by_name.remove(&amp;guest.borrow().name);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<pre><code>Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Bob", {n: 'Bob', ...}), ("Charlie", {n: 'Charlie', ...})]
}
Alice is None
Bob is Some(RefCell { value: Guest { name: "Bob",
                                     address: "234 Bobton" } })
Charlie is Some(RefCell { value: Guest { name: "Charlie",
                                         address: "345 Charlieland" } })
</code></pre>
<h3 id="chapter_3-item15-borrows-智能指针"><a class="header" href="#chapter_3-item15-borrows-智能指针">智能指针</a></h3>
<p>上一小节最后一个方法是更通用的解决方案的示例：<strong>在互联的结构体中使用 Rust 智能指针</strong>。</p>
<p><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>描述了 Rust 标准库提供的常见的智能指针类型：</p>
<ul>
<li><code>Rc</code> 允许共享所有权，多个变量可以引用同一个数据。<code>Rc</code> 总是和 <code>RefCell</code> 一起使用。</li>
<li><code>RefCell</code> 允许内部可变性，以便在不需要可变引用的情况下更改内部状态。这是将借用检查从编译期移到运行时为代价的。</li>
<li><code>Arc</code> 是 <code>Rc</code> 的多线程版本。</li>
<li><code>Mutex</code> （和 <code>RwLock</code>）允许多线程环境中内部可变性，大概相当于 <code>RefCell</code>。</li>
<li><code>Cell</code> 允许 <code>Copy</code> 类型的内部可变性。</li>
</ul>
<p>对于从 C++转向 Rust 并适应了的程序员来说，最常用的就是 <code>Rc&lt;T&gt;</code>（和它的线程安全版本 <code>Arc&lt;T&gt;</code>），并通常结合 <code>RefCell</code>（或者线程安全的替代 <code>Mutex</code>）使用。将共享指针（甚至是 <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>）简单地转换为 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 实例通常在 Rust 中工作良好，而且借用检查器不会有太多抱怨。</p>
<p>然而，使用该方法意味着你会得不到 Rust 提供的一些保护。特别是，当同一个数据可变借用（通过 <code>borrow_mut()</code>）时，另外一个引用已经存在，会导致运行时 <code>panic!</code>，而不是一个编译期错误。</p>
<p>例如，打破树结构所有权单向流的一种模式是，有一个“所有者”指针从该数据指回这个数据的所有者，如图 3-3 所示。这些<code>所有者</code>链接对于在数据结构中上下移动很有用；例如，向叶子添加新的同级节点，找到涉及该叶子所属的<code>分支</code>。</p>
<img src="chapter_3/../images/item15/treedatastructure.svg" width="600" height="302">
<p><em>图 3-3. 树结构层级关系</em></p>
<p>在 Rust 中实现此模式可以利用 <code>Rc&lt;T&gt;</code> 的精明的伙伴，<a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    cell::RefCell,
    rc::{Rc, Weak},
};

// 对每个标识符类型使用新类型。
struct TreeId(String);
struct BranchId(String);
struct LeafId(String);

struct Tree {
    id: TreeId,
    branches: Vec&lt;Rc&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}

struct Branch {
    id: BranchId,
    leaves: Vec&lt;Rc&lt;RefCell&lt;Leaf&gt;&gt;&gt;,
    owner: Option&lt;Weak&lt;RefCell&lt;Tree&gt;&gt;&gt;,
}

struct Leaf {
    id: LeafId,
    owner: Option&lt;Weak&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Weak</code> 引用不会增加主引用计数，因此必须显式验证所引用的数据是否已经被释放：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Branch {
    fn add_leaf(branch: Rc&lt;RefCell&lt;Branch&gt;&gt;, mut leaf: Leaf) {
        leaf.owner = Some(Rc::downgrade(&amp;branch));
        branch.borrow_mut().leaves.push(Rc::new(RefCell::new(leaf)));
    }

    fn location(&amp;self) -&gt; String {
        match &amp;self.owner {
            None =&gt; format!("&lt;unowned&gt;.{}", self.id.0),
            Some(owner) =&gt; {
                // 升级弱引用所有者指针
                let tree = owner.upgrade().expect("owner gone!");
                format!("{}.{}", tree.borrow().id.0, self.id.0)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果 Rust 的智能指针不能很好的解决你的结构体所需，这里还有终极解决方案，即编写 <code>unsafe</code> 代码并使用裸（并且绝对不智能的）指针。然而，根据<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>，这应该是最后的解决方案——其他人可能已经在安全接口内实现了你想要的功能，你只需要搜索标准库和 <code>crates.io</code>，你或许会找到适合这种情况的工具。</p>
<p>例如，假设你写了一个函数，它有时返回输入的参数之一的引用，有时返回一些新分配的数据。根据<a href="https://www.lurklurk.org/effective-rust/use-types.html">第 1 条</a>，对这两种可能性在类型系统中进行编码的非常自然的方式是写一个 <code>enum</code>，然后你可以实现<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>描述的各种指针 trait。但是你不必这样做：标准库已经提供了<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a>类型，它已经包含了这些情况：</p>
<h3 id="chapter_3-item15-borrows-自引用结构体"><a class="header" href="#chapter_3-item15-borrows-自引用结构体">自引用结构体</a></h3>
<p>有一场与借用检查器的特殊斗争总是阻碍程序员从其他语言转向 Rust：尝试创建自引用结构体，结构体中包含已拥有的数据，和对该已拥有的数据内的引用的混合：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRef {
    text: String,
    // `text` 的切片中有 title 文本。
    title: Option&lt;&amp;str&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>在语法级别上，这段代码无法编译，因为它不符合<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中所述的生命周期规则：引用需要生命周期注解，并且这意味着包含该数据的结构体也需要生命周期参数。但是生命周期是针对此 <code>SelfRef</code> 结构体外部的某些东西而言的，而这里没意义：被引用的数据在结构体内部。</p>
<p>关于此限制在语义层面的原因很值得思考。Rust 中的数据结构是<em>可移动的</em>：从栈到堆上，从堆到栈上，并从一个地方到另一个地方。如果上述情况发生了，"内部" <code>title</code> 指针将不再有效，并且也无法保持同步。</p>
<p>对于这种情况，一个简单的解决办法是使用前面讨论过的索引：对于 <code>text</code> 的一系列的偏移量不会因为移动而失效，并且对于借用检查器来说是不可见的，因为它不涉及引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRefIdx {
    text: String,
    // title 文本的位置对 `text` 的索引
    title: Option&lt;std::ops::Range&lt;usize&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>然而，这种索引方法只适合简单的示例，并且具有前面提到过的相同的缺点：索引本身是一个伪指针，可能会变得不同步，甚至 <code>text</code> 已经不存在之后仍在索引不存在的数据。</p>
<p>当编译器处理<code>异步</code>代码时，会出现常见的自引用问题。<sup class="footnote-reference"><a href="#chapter_3-item15-borrows-4">3</a></sup>粗略地说，编译器将待处理的<code>异步</code>代码整合到闭包中，该闭包会既包含代码，又包含上下文环境中捕获到的需要的变量（如<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>所述）。该捕获环境能够同时包含值和对这些值的引用。这本质上是一种自引用数据结构，因此<code>异步</code>支持是标准库中的 <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> 类型的主要动机。该指针类型可以“固定”值，强制该值保留在内存中的同一位置，从而确保内部自引用保持有效。</p>
<p>因此 <code>Pin</code> 可以作为自引用类型的一种可能解决方法，但如何正确使用该类型很棘手——请务必阅读<a href="https://doc.rust-lang.org/std/pin/index.html">官方文档</a>。</p>
<p>在可能的情况下，<strong>避免使用自引用数据结构</strong>，或者尝试找到能够为此封装的包（例如<a href="https://crates.io/crates/ouroboros"><code>ouroboros</code></a>）。</p>
<h2 id="chapter_3-item15-borrows-牢记"><a class="header" href="#chapter_3-item15-borrows-牢记">牢记</a></h2>
<ul>
<li>Rust 的引用是<em>被借用的</em>，表明他们不能被永久保留。</li>
<li>借用检查器允许对某个数据进行多次不可变借用，或者单次可变借用，但不能同时有两者。由于非词法生命周期，引用的生命周期在引用最后一次被使用之后结束，而不是在中括号封闭范围内末尾。</li>
<li>借用检查器的错误可通过多种方式处理：
<ul>
<li>添加额外的 <code>{ ... }</code> 作用域来减少值的生命周期范围。</li>
<li>把值赋值给已命名的局部变量，可以延长该值的生命周期到该作用域的末尾。</li>
<li>暂时添加多个局部变量可以帮助缩小借用检查器“抱怨”的范围。</li>
</ul>
</li>
<li>Rust 的智能指针提供了绕过借用检查器规则的方法，并且对于互联的结构体非常有用。</li>
<li>然而，自引用结构体在 Rust 中仍难以处理。</li>
</ul>
<h4 id="chapter_3-item15-borrows-注释"><a class="header" href="#chapter_3-item15-borrows-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_3-item15-borrows-1"><sup class="footnote-definition-label">1</sup>
<p>注意，上述提到的可能在这样的表达式失效，比如<code>m!(value)</code>，因为这涉及宏（<a href="https://www.lurklurk.org/effective-rust/macros.html">第 28 条</a>），因为宏可以扩展出任意代码。</p>
</div>
<div class="footnote-definition" id="chapter_3-item15-borrows-2"><sup class="footnote-definition-label">2</sup>
<p>编译器的建议在这里没有任何用处，因为后续行需要 <code>item</code>。</p>
</div>
<div class="footnote-definition" id="chapter_3-item15-borrows-3"><sup class="footnote-definition-label">4</sup>
<p><code>Cow</code> 意思是写时克隆 (clone-on-write)；仅当数据需要对其更改（写入）时才克隆底层数据。</p>
</div>
<div class="footnote-definition" id="chapter_3-item15-borrows-4"><sup class="footnote-definition-label">3</sup>
<p>处理 <code>async</code> 代码已经超出本书的范围；要了解更多关于自引用(self-referential)结构体的更多信息，参考 Jon Gjengset (No Starch Press) 编写的<a href="https://rust-for-rustaceans.com/">《Rust for Rustaceans》</a>的第 8 章节。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/borrows.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3-item16-unsafe"></div><h1 id="chapter_3-item16-unsafe-第-16-条避免写-unsafe-代码"><a class="header" href="#chapter_3-item16-unsafe-第-16-条避免写-unsafe-代码">第 16 条：避免写 <code>unsafe</code> 代码</a></h1>
<p>Rust 独特的卖点就是其内存安全保证（无运行时开销）；这是其他任何主流语言所没有的 Rust 的特性。这种保证是有代价的：写 Rust 需要你重新组织你的代码来通过借用检查器（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）并精确指定你使用的引用类型（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>）。</p>
<p>Unsafe Rust 是 Rust 语言的超集，削弱了一些限制——以及对应的保证。代码块前面加上 <code>unsafe</code> 就可以切换到 unsafe 模式，这会允许通常情况下 Rust 所不支持的操作。特别是，它允许使用<em>裸指针</em>，就像旧式 C 指针一样。这些指针不受借用规则的约束，程序员有责任保证他们在解引用时仍指向有效的内存。</p>
<p>因此浅显地说，本条的建议很简单：如果你只想用 Rust 来编写 C 代码，为什么要用 Rust？然而，在某些情况下，<code>unsafe</code> 代码是必要的：对于底层库或当你的 Rust 代码必须与其他语言代码交互时（<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>）。</p>
<p>所以本条的建议非常明确：<strong>避免写 <code>unsafe</code> 代码</strong>。重点在于“写”，因为大多数时候，你可能需要的 <code>unsafe</code> 代码都已经为你编写好了。</p>
<p>Rust 标准库包含大量 <code>unsafe</code> 代码；快速查找发现 <code>alloc</code> 库中大约有 1000 个<code>unsafe</code>使用，<code>core</code> 中有 1,500 个，<code>std</code> 中最多，有 2,000 个。这些代码都由大佬编写，并在数千个 Rust 代码库中久经考验。</p>
<p>其中一些 <code>unsafe</code> 代码在我们介绍过的标准库功能的底层：</p>
<ul>
<li><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>描述的智能指针类型（<code>Rc</code>，<code>RefCell</code>，<code>Arc</code> 等）在底层上都使用 <code>unsafe</code> 代码（通常是裸指针），以便向用户呈现其特定的语义。</li>
<li><a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>中的同步原语（<code>Mutex</code>，<code>RwLock</code> 和其他相关守卫）在内部使用 <code>unsafe</code> 的系统特定操作代码。如果你想了解这些原语中设计的微妙细节，推荐 Mara Bos (O'Reilly) 的<a href="https://marabos.nl/atomics/">《Rust Atomics and Locks》</a>。</li>
</ul>
<p>标准库中还有一些涵盖了更高级特性的功能，其内部也使用 <code>unsafe</code> 实现：<sup class="footnote-reference"><a href="#chapter_3-item16-unsafe-1">1</a></sup></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>std::pin::Pin</code></a> 强制数据不能在内存中移动（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）。这会允许自引用数据结构，这对于 Rust 新手通常来说是非常令人讨厌的（<a href="https://rust-unofficial.github.io/too-many-lists/">bête noire</a>）。</li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> 提供了写时克隆智能指针：同一个指针可用于读取和写入，并且只当写入时才会发生底层数据的克隆。</li>
<li><a href="https://doc.rust-lang.org/std/mem/index.html"><code>std::mem</code></a> 中的这些函数（<a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>take</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code>swap</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>replace</code></a>）允许操作内存中的数据，而不会与借用检查器发生冲突。</li>
</ul>
<p>这些功能可能仍需要小心一些才能正确使用，但 <code>unsafe</code> 代码已经通过消除该类问题的方式封装起来了。</p>
<p>除了标准库以外，<a href="https://crates.io/"><code>crates.io</code></a> 生态也有很多封装了 <code>unsafe</code> 代码来提供常用功能的 crate：</p>
<ul>
<li><a href="https://docs.rs/once_cell"><code>once_cell</code></a>：提供了一种类似全局变量的方法，只初始化一次。</li>
<li><a href="https://docs.rs/rand"><code>rand</code></a>：提供随机数生成，利用操作系统和 CPU 提供的较低级别的底层功能。</li>
<li><a href="https://docs.rs/byteorder"><code>byteorder</code></a>：允许数据的原始字节（raw bytes）与数字（number）之间进行转换。</li>
<li><a href="https://docs.rs/cxx"><code>cxx</code></a>：允许 C++代码和 Rust 代码互操作（也在<a href="https://www.lurklurk.org/effective-rust/bindgen.html">第 35 条</a>提到）。</li>
</ul>
<p>还有很多其他例子，但是期望的总体思路是清楚的。如果你想做的事情显然不符合 Rust 的约束（尤其对于<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>和<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>），搜索标准库，查看是否已有功能可以满足你的需要。如果你没有找到所需的，也可以尝试在 <code>crates.io</code> 中搜索。毕竟，遇到其他人从来没遇到过的独特问题是不寻常的。</p>
<p>当前，总有一些地方强制使用 <code>unsafe</code>，比如，当你想要通过外部函数接口（FFI）编写的代码进行交互时，正如<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>中讨论的那样。但当必要时，<strong>考虑编写一个包装层来保存所有的 <code>unsafe</code> 代码</strong>，以便其他程序员可以遵循本条给出的建议。这也有助于定位问题：当出现问题时，<code>unsafe</code> 的包装层应是首先被怀疑的对象。</p>
<p>另外，如果你被迫编写 <code>unsafe</code> 代码，注意关键字本身蕴含的警告：此处有龙（<a href="https://en.wikipedia.org/wiki/Here_be_dragons">Hic sunt dracones</a>，中世纪航海术语，用来描述该地域很危险）。</p>
<ul>
<li>添加<a href="https://std-dev-guide.rust-lang.org/policy/safety-comments.html">安全注释</a>，记录 <code>unsafe</code> 代码依赖的前提条件和不变量。Clippy（<a href="https://www.lurklurk.org/effective-rust/clippy.html">第 29 条</a>）有一个<a href="https://rust-lang.github.io/rust-clippy/master/index.html#/missing_safety_doc">警告</a>来提醒您这一点。</li>
<li>最小化使用 <code>unsafe</code> 代码块，以限制错误影响的潜在范围。考虑启用 <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code> lint</a>，以便于执行 <code>unsafe</code> 操作时需要显式的 <code>unsafe</code> 代码块，甚至这些操作是在本身就 <code>unsafe</code> 函数中执行的。</li>
<li>编写比平时更多的测试（<a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>）。</li>
<li>对代码运行附加诊断工具（<a href="https://www.lurklurk.org/effective-rust/use-tools.html">第 31 条</a>）。特别是，<strong>考虑在 <code>unsafe</code> 代码上运行 Miri</strong>——<a href="https://github.com/rust-lang/miri">Miri</a> 会解释编译器中间层的输出，使其能够检测到 Rust 编译器无法察觉到某类错误。</li>
<li>仔细考虑多线程的使用，特别是有共享状态情况下（<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>）。</li>
</ul>
<p>添加 <code>unsafe</code> 标记并不意味着不再有任何规则适用，这意味着<em>你</em>（程序员）现在负责维护 Rust 的安全保证，而不是编译器负责。</p>
<h4 id="chapter_3-item16-unsafe-注释"><a class="header" href="#chapter_3-item16-unsafe-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_3-item16-unsafe-1"><sup class="footnote-definition-label">1</sup>
<p>实际上，大多数 <code>std</code> 功能实际上都由 <code>core</code> 提供，因此可用于 <code>no_std</code> 代码，如<a href="https://www.lurklurk.org/effective-rust/no-std.html">第 33 条</a>所述。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/unsafe.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3-item17-deadlock"></div><h1 id="chapter_3-item17-deadlock-第-17-条对共享状态的并行性保持警惕"><a class="header" href="#chapter_3-item17-deadlock-第-17-条对共享状态的并行性保持警惕">第 17 条：对共享状态的并行性保持警惕</a></h1>
<blockquote>
<p>"即使是最大胆的共享数据形式在 Rust 中也能保证安全。"-<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Aaron Turon</a></p>
</blockquote>
<p>官方文档描述说 Rust 实现了<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">“无畏并发”</a>，但本条将探讨为什么（令人遗憾的是）即使是在 Rust 中，仍有一些理由需要对并发保持警惕。</p>
<p>本条特别关注<em>共享状态</em>的并行性：正在执行的不同线程通过共享内存相互通信。无论是哪种语言，线程之间共享状态通常会带来<em>两个</em>可怕的问题：</p>
<ul>
<li><em>数据竞争</em>：这可能导致数据损坏。</li>
<li><em>死锁</em>：这可能导致你的程序陷入停滞。</li>
</ul>
<p>上述两个问题都很可怕（“引起或可能导致恐慌”），因为他们在实际调试中会变得非常困难：错误的发生是不固定的，并且通常更有可能在有负载的情况下发生——这意味着他们可能不会在单元测试，集成测试或其他任何类型测试中被发现（<a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>），但他们会在生产环境中出现。</p>
<p>Rust 已经向前迈出了一大步，因为它完全解决了上述两个问题之一。然而，正如我们所见，另外一个问题仍然存在。</p>
<h2 id="chapter_3-item17-deadlock-数据竞争"><a class="header" href="#chapter_3-item17-deadlock-数据竞争">数据竞争</a></h2>
<p>让我们先通过探索<em>数据竞争</em>和 Rust 来看一个好消息。数据竞争的精确定义因语言而异，但我们可以将关键部分总结如下：</p>
<blockquote>
<p>当两个不同的线程在以下条件访问内存中同一位置时，会发生数据竞争：</p>
<ul>
<li>至少有一个线程在写入。</li>
<li>没有强制规定访问顺序的同步机制。</li>
</ul>
</blockquote>
<h3 id="chapter_3-item17-deadlock-c-中的数据竞争"><a class="header" href="#chapter_3-item17-deadlock-c-中的数据竞争">C++ 中的数据竞争</a></h3>
<p>通过一个例子可以很好地说明这这些基础知识。考虑一个跟踪银行账户的数据结构：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><code class="language-cpp">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    if (balance_ &lt; 0) {
      std::cerr &lt;&lt; "** Oh no, gone overdrawn: " &lt;&lt; balance_ &lt;&lt; "! **\n";
      std::abort();
    }
    return balance_;
  }
  void deposit(uint32_t amount) {
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    if (balance_ &lt; amount) {
      return false;
    }
    // 如果此时其他线程更改了 `balance_` 会发生什么？
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    balance_ -= amount;
    return true;
  }

 private:
  int64_t balance_;
};
</code></pre>
<p>这个例子用 C++ 写的，不是 Rust，原因很快就会明了。然而，相同的一般概念也适用于许多其他（非 Rust）语言——Java，Go，Python 等。</p>
<p>该类在单线程中工作正常，但是考虑多线程下情况：</p>
<pre><code class="language-cpp">BankAccount account;
account.deposit(1000);

// 启动一个线程，用来监视余额不足的情况，并为账户充值。
std::thread payer(pay_in, &amp;account);

// 启动三个线程，每个线程尝试重复取款。
std::thread taker(take_out, &amp;account);
std::thread taker2(take_out, &amp;account);
std::thread taker3(take_out, &amp;account);
</code></pre>
<p>这里有若干线程反复尝试从账户中取款，并且有一个额外的线程在账户余额不足时为账户充值：</p>
<pre><code class="language-cpp">// 持续监控 `account` 余额，如果余额不足则进行充值。
void pay_in(BankAccount* account) {
  while (true) {
    if (account-&gt;balance() &lt; 200) {
      log("[A] Balance running low, deposit 400");
      account-&gt;deposit(400);
    }
    // (此带有 sleep 的无限循环只是为了示范/模拟耗时操作的目的)
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
  }
}

// 反复尝试从 `account` 取款。
void take_out(BankAccount* account) {
  while (true) {
    if (account-&gt;withdraw(100)) {
      log("[B] Withdrew 100, balance now " +
          std::to_string(account-&gt;balance()));
    } else {
      log("[B] Failed to withdraw 100");
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
  }
}
</code></pre>
<p>最终，程序会出错：</p>
<pre><code>** Oh no, gone overdrawn: -100! **
</code></pre>
<p>这个问题不难发现，特别是 <code>withdraw()</code> 方法写了有用的注释：当涉及多个线程时，余额的值在检查和修改之间可能发生变化。然而，现实世界的此类 bug 会更难被发现——尤其是如果允许编译器在幕后执行各种小技巧以及代码重新排序（如 C++这样）。</p>
<p>包含了 <code>sleep</code> 的调用是为了人为地提高这种错误被命中，并尽早发现的机会；当此类问题实际发生时，他们很可能很少出现或间歇性发生——这使得他们很难被调试。</p>
<p><code>BankAccount</code> 类是<em>线程兼容的</em>，这意味着它可以在多线程环境中使用，但使用该类的人要确保对其访问需要受到某种外部同步机制的控制。</p>
<p>通过添加内部同步操作，可以将该类转换为<em>线程安全</em>类，这意味着可以安全地从多个线程使用该类：<sup class="footnote-reference"><a href="#chapter_3-item17-deadlock-1">1</a></sup></p>
<pre><code class="language-cpp">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    // 对该作用域上锁 mu_。
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    if (balance_ &lt; 0) {
      std::cerr &lt;&lt; "** Oh no, gone overdrawn: " &lt;&lt; balance_ &lt;&lt; " **!\n";
      std::abort();
    }
    return balance_;
  }
  void deposit(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    if (balance_ &lt; amount) {
      return false;
    }
    balance_ -= amount;
    return true;
  }

 private:
  mutable std::mutex mu_; // 保护 balance_
  int64_t balance_;
};
</code></pre>
<p>内部字段 <code>balance_</code> 现在由锁 <code>mu_</code> 进行保护：这是一种可以确保同一时刻只有一个线程可以持有该锁的同步对象。调用者可以通过调用 <code>std::mutex::lock()</code> 来获取锁；第二个以及后续调用者调用 <code>std::mutex::lock()</code> 都会被阻塞，直到最开始的调用者调用了 <code>std::mutex::unlock()</code>，然后被阻塞的线程<em>之一</em>会解除阻塞并继续执行 <code>std::mutex::lock()</code>。</p>
<p>现在，对余额的所有访问都在持有锁的情况下进行，这确保了此值在检查和修改之间保持一致。<a href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a> 也值得强调一下：它是一个 RAII 类（参考<a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a>），创建时调用 <code>lock()</code> 并在销毁时调用 <code>unlock()</code>。这确保了锁在离开作用域时被 unlock，从而减少了在手动调用 <code>lock()</code> 和 <code>unlock()</code> 时出错的概率。</p>
<p>然而，这里的线程安全仍然非常脆弱；摧毁这种安全只需要对类进行一个错误的修改：</p>
<pre><code class="language-cpp">// 添加一个新的 C++ 方法...
void pay_interest(int32_t percent) {
  // ...但是忘记关于 mu_ 的事情了
  int64_t interest = (balance_ * percent) / 100;
  balance_ += interest;
}
</code></pre>
<p>然后线程安全被摧毁了。<sup class="footnote-reference"><a href="#chapter_3-item17-deadlock-2">2</a></sup></p>
<h3 id="chapter_3-item17-deadlock-rust-中的数据竞争"><a class="header" href="#chapter_3-item17-deadlock-rust-中的数据竞争">Rust 中的数据竞争</a></h3>
<p>对于一本关于 Rust 的书来说，本条已经写了够多 C++了，所以考虑将这个类直接转换成 Rust：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BankAccount {
    balance: i64,
}

impl BankAccount {
    pub fn new() -&gt; Self {
        BankAccount { balance: 0 }
    }
    pub fn balance(&amp;self) -&gt; i64 {
        if self.balance &lt; 0 {
            panic!("** Oh no, gone overdrawn: {}", self.balance);
        }
        self.balance
    }
    pub fn deposit(&amp;mut self, amount: i64) {
        self.balance += amount
    }
    pub fn withdraw(&amp;mut self, amount: i64) -&gt; bool {
        if self.balance &lt; amount {
            return false;
        }
        self.balance -= amount;
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以及尝试永久向账户付款或取款的功能：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pay_in(account: &amp;mut BankAccount) {
    loop {
        if account.balance() &lt; 200 {
            println!("[A] Running low, deposit 400");
            account.deposit(400);
        }
        std::thread::sleep(std::time::Duration::from_millis(5));
    }
}

pub fn take_out(account: &amp;mut BankAccount) {
    loop {
        if account.withdraw(100) {
            println!("[B] Withdrew 100, balance now {}", account.balance());
        } else {
            println!("[B] Failed to withdraw 100");
        }
        std::thread::sleep(std::time::Duration::from_millis(20));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这在单线程上下文中工作正常——即使该线程不是主线程：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut account = BankAccount::new();
    let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
    // 在该作用域结尾，`_payer` 线程开始独立运行
    // 并且成为 `BankAccount` 的唯一所有者。
}
<span class="boring">}</span></code></pre></pre>
<p>但如果简单地尝试跨多个线程使用 <code>BankAccount</code>：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut account = BankAccount::new();
    let _taker = std::thread::spawn(move || take_out(&amp;mut account));
    let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
}
<span class="boring">}</span></code></pre></pre>
<p>会立即编译失败：</p>
<pre><code>error[E0382]: use of moved value: `account`
   --&gt; src/main.rs:102:41
    |
100 | let mut account = BankAccount::new();
    |     ----------- move occurs because `account` has type
    |                 `broken::BankAccount`, which does not implement the
    |                 `Copy` trait
101 | let _taker = std::thread::spawn(move || take_out(&amp;mut account));
    |                                 -------               ------- variable
    |                                 |                         moved due to
    |                                 |                         use in closure
    |                                 |
    |                                 value moved into closure here
102 | let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
    |                                 ^^^^^^^             ------- use occurs due
    |                                 |                        to use in closure
    |                                 |
    |                                 value used here after move
</code></pre>
<p>借用检查器规则（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）能告知我们原因：对同一项目有两个可变引用，其中一个超出了允许的范围。借用检查器的规则是，你可以对某个项目有单个可变引用，或者多个（不可变）引用，但是不能同时有二者。</p>
<p>这与本条开头的数据竞争的定义有一个奇怪的相同点：强制只有一个写入者，或多个读取者（但不能两者同时），这意味着不能出现数据竞争。通过强制执行内存安全，<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Rust “免费” 获得了线程安全</a>。</p>
<p>与 C++ 一样，需要某种同步来使得 <code>struct</code> 线程安全。最常见的机制也称为 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> 互斥锁，但 Rust 版本的 Mutex “包装” 受保护的数据，而不是变成一个独立的对象（如 C++中）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BankAccount {
    balance: std::sync::Mutex&lt;i64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Mutex</code> 泛型上的 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock()</code></a> 方法返回具有 RAII 行为的 <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> 对象，如 C++ 的 <code>std::lock_guard</code> 一样：在作用域结束时，guard 被 drop，互斥锁会自动释放。（与 C++ 相比，Rust 的互斥锁并没有手动获取或释放的方法，因为它们会让开发者陷入忘记保持这些调用完全同步的风险中。）</p>
<p>更准确地说，<code>lock()</code> 实际上返回了一个持有 <code>MutexGuard</code> 的 <code>Result</code>，以应对 <code>Mutex</code> 被<em>中毒</em>的可能性。如果线程在持有锁时失败，就会发生中毒，因为这可能意味着任何被互斥锁保护的不变量已经不再可靠。实际上，锁中毒是非常罕见的（并且当它发生时让程序终止是可取的），因此通常会直接调用 <code>.unwarp()</code> 来处理 <code>Result</code>（尽管这与<a href="https://www.lurklurk.org/effective-rust/panic.html">第 18 条</a>相违背）。</p>
<p><code>MutexGuard</code> 对象还通过实现 <code>Deref</code> 和 <code>DerefMut</code> trait <a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>来充当 <code>Mutex</code> 所包含数据的代理，允许它可以进行读取操作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BankAccount {
    pub fn balance(&amp;self) -&gt; i64 {
        let balance = *self.balance.lock().unwrap();
        if balance &lt; 0 {
            panic!("** Oh no, gone overdrawn: {}", balance);
        }
        balance
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于写入操作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BankAccount {
    // 注意：不再需要 `&amp;mut self`。
    pub fn deposit(&amp;self, amount: i64) {
        *self.balance.lock().unwrap() += amount
    }
    pub fn withdraw(&amp;self, amount: i64) -&gt; bool {
        let mut balance = self.balance.lock().unwrap();
        if *balance &lt; amount {
            return false;
        }
        *balance -= amount;
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这些方法的签名中隐藏一个有趣的细节：尽管他们正在修改 <code>BankAccount</code> 的余额，但是这些方法参数是 <code>&amp;self</code> 而不是 <code>&amp;mut self</code>。这是不可避免的：如果多个线程想要保存对同一个 <code>BankAccount</code> 的引用，根据借用检查器规则，这些引用最好是不可变的。这也是<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>中描述的<em>内部可变性</em>模式的另一个实例：借用检查实际上从编译时移动到运行时，但是此处具有了同步跨线程行为。如果可变引用已经存在，则尝试获取第二个引用将被阻止，直到第一个引用已被删除。</p>
<p>把共享状态包装在 <code>Mutex</code> 中可以安抚借用检查器，但仍存在生命周期问题（<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>）需要修复：</p>
<div class="ferris"><img src="chapter_3/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let account = BankAccount::new();
    let taker = std::thread::spawn(|| take_out(&amp;account));
    let payer = std::thread::spawn(|| pay_in(&amp;account));
    // 在该作用域末尾，`account` 被 drop，但是
    // `_taker` 和 `_payer` 线程仍在运行，所以
    // 仍持有对 `account` 的（不可变）引用。
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `account`
              which is owned by the current function
   --&gt; src/main.rs:206:40
    |
206 |     let taker = std::thread::spawn(|| take_out(&amp;account));
    |                                    ^^           ------- `account` is
    |                                    |                     borrowed here
    |                                    |
    |                                    may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; src/main.rs:206:21
    |
206 |     let taker = std::thread::spawn(|| take_out(&amp;account));
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other
      referenced variables), use the `move` keyword
    |
206 |     let taker = std::thread::spawn(move || take_out(&amp;account));
    |                                    ++++
error[E0373]: closure may outlive the current function, but it borrows `account`
              which is owned by the current function
   --&gt; src/main.rs:207:40
    |
207 |     let payer = std::thread::spawn(|| pay_in(&amp;account));
    |                                    ^^         ------- `account` is
    |                                    |                  borrowed here
    |                                    |
    |                                    may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; src/main.rs:207:21
    |
207 |     let payer = std::thread::spawn(|| pay_in(&amp;account));
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other
      referenced variables), use the `move` keyword
    |
207 |     let payer = std::thread::spawn(move || pay_in(&amp;account));
    |                                    ++++
</code></pre>
<p>给出的错误消息清晰展示问题所在：<code>BankAccount</code> 将在该块末尾被 <code>drop</code>，但是这里有两个线程引用了它，并可能在这之后继续运行。（编译器给出关于如何修改的建议并没有太大帮助——如果 <code>BankAccount</code> 数据被移动到第一个闭包中，则第二个闭包将无法再接收对它的引用！）</p>
<p>用来确保对象保持活动状态，直到对它的所有引用都消失，这种标准工具是引用计数指针，Rust 用于多线程使用的变体是 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account = std::sync::Arc::new(BankAccount::new());
account.deposit(1000);

let account2 = account.clone();
let _taker = std::thread::spawn(move || take_out(&amp;account2));

let account3 = account.clone();
let _payer = std::thread::spawn(move || pay_in(&amp;account3));
<span class="boring">}</span></code></pre></pre>
<p>每个线程都会获得自己的引用计数指针的副本，并移动至闭包中，并且仅当引用计数降至零时，才会使底层数据 <code>BankAccount</code> 被 <code>drop</code>。<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 这种组合在使用共享状态并行性的 Rust 程序中很常见。</p>
<p>从技术细节退一步来看，Rust 完全避免了困扰其他语言的多线程编程的数据竞争问题。当然，这个好消息仅限于 <em>safe</em> Rust——<code>unsafe</code> 代码（<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>）和尤其是 FFI 绑定（<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>）可能不会避免数据竞争——但是这仍是一个值得注意的现象。</p>
<h3 id="chapter_3-item17-deadlock-标准库-trait-标记"><a class="header" href="#chapter_3-item17-deadlock-标准库-trait-标记">标准库 trait 标记</a></h3>
<p>有两个标准库 trait 会影响线程之间 Rust 对象的使用。这两个 trait 都是<em>标记 trait</em>（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>），他们没有关联的方法，但在多线程场景中对于编译器具有特殊含义：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> trait 表明某种类型的数据可以安全地跨线程传输；这种类型的数据的所有权可以从一个线程传递到另一个线程。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> trait 表明某种类型的数据可以由多个线程安全地访问，但必须遵守借用检查器规则。</li>
</ul>
<p>换句话说，我们可以发现，<code>Send</code> 意味着 <code>T</code> 可以在线程间传输，<code>Sync</code> 意味着 <code>&amp;T</code> 可以在线程间传输。</p>
<p>这两个 trait 都是<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">自动 trait</a>：编译器会自动把他们派生（derive）为新类型，只需要该类型的组成部分也实现了 <code>Send</code> / <code>Sync</code>。</p>
<p>大多数安全类型都实现了 <code>Send</code> 和 <code>Sync</code>，这些类型太多了，所以我们需要清楚的了解哪些类型<em>没有</em>实现这些 trait（以 <code>impl !Sync for Type</code> 来表示）。</p>
<p>没有实现 <code>Send</code> 的类型只能在单个线程使用。一个典型的例子是非同步引用计数指针 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>）。这种类型在实现上就明确假定使用单线程（为了速度）；它没有尝试同步内部引用计数来供多线程使用。因此，不允许在线程之间传输 <code>Rc&lt;T&gt;</code>；为此应该用 <code>Arc&lt;T&gt;</code>（以及额外性能开销）。</p>
<p>未实现 <code>Sync</code> 的类型无法安全地从多个线程通过<em>非</em><code>mut</code>引用来使用（因为借用检查器会确保永远不会有多个 <code>mut</code> 引用）。典型的例子是，以不同步方式提供<em>内部可变性</em>的类型，例如 <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> 和 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>。使用 <code>Mutex&lt;T&gt;</code> 或 <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> 来在多线程环境中提供内部可变性。</p>
<p>原始指针类型，比如 <code>*const T</code> 和 <code>*mut T</code> 也都没实现 <code>Send</code> 和 <code>Sync</code>；相见<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>和<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>。</p>
<h2 id="chapter_3-item17-deadlock-死锁"><a class="header" href="#chapter_3-item17-deadlock-死锁">死锁</a></h2>
<p>现在有个坏消息。虽然 Rust 已经解决了数据竞争问题（如前所述），但对于具有共享状态的多线程代码来说，它仍会受到<em>第二个</em>可怕问题的影响：<em>死锁</em>。</p>
<p>考虑一个简化的多人服务器，它是用多线程应用来实现的，可以并行地为许多玩家提供服务。有两个核心的数据结构，可能是玩家的集合（按用户名索引），以及正在进行游戏的集合（按某个唯一的标识符进行索引）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameServer {
    // 从玩家名字到玩家信息的映射
    players: Mutex&lt;HashMap&lt;String, Player&gt;&gt;,
    // 当前游戏，由唯一的 game ID 来索引。
    games: Mutex&lt;HashMap&lt;GameId, Game&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这两种数据结构都有 <code>Mutex</code> 来保护，所以不会出现数据竞争。然而，操作<em>这两种</em>数据结构的代码可能有潜在的问题。两者之间的单一交互可以正常运行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GameServer {
    /// 添加新玩家并将他们加入当前游戏。
    fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameId&gt; {
        // 添加新玩家
        let mut players = self.players.lock().unwrap();
        players.insert(username.to_owned(), info);

        // 找到一个未满的游戏房间来让他们加入
        let mut games = self.games.lock().unwrap();
        for (id, game) in games.iter_mut() {
            if game.add_player(username) {
                return Some(id.clone());
            }
        }
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而，两个相互独立且锁定的数据结构之间的第二次交互，就会开始产生问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GameServer {
    /// 通过 `username` 来封禁掉玩家，把他们从任何当前游戏中移除
    fn ban_player(&amp;self, username: &amp;str) {
        // 找到该用户所在所有的游戏房间，并移除。
        let mut games = self.games.lock().unwrap();
        games
            .iter_mut()
            .filter(|(_id, g)| g.has_player(username))
            .for_each(|(_id, g)| g.remove_player(username));

        // 从用户列表删除他们。
        let mut players = self.players.lock().unwrap();
        players.remove(username);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>为了理解该问题，想象有两个单独的线程使用这两种方法，他们的执行顺序如表 3-1 所示。</p>
<p><em>表 3-1. 线程死锁顺序</em></p>
<div class="table-wrapper"><table><thead><tr><th><strong>线程 1</strong></th><th><strong>线程 2</strong></th></tr></thead><tbody>
<tr><td>进入 <code>add_and_join()</code> 并立即获取 <code>players</code> 锁。</td><td></td></tr>
<tr><td></td><td>进入 <code>ban_player()</code> 并立即获取 <code>games</code> 锁。</td></tr>
<tr><td>尝试获取 <code>games</code> 锁；但目前由线程 2 所有，所以线程 1 阻塞。</td><td></td></tr>
<tr><td></td><td>尝试获取 <code>players</code> 锁；但目前由线程 1 所有，所以线程 2 阻塞。</td></tr>
</tbody></table>
</div>
<p>此时，程序陷入死锁：两个线程都不会继续运行，任何其他线程也不会对两个 <code>Mutex</code> 保护的数据结构中的任何一个执行任何操作。</p>
<p>其根本原因是<em>锁反转</em>：一个函数按照 <code>player</code> 然后 <code>games</code> 的顺序获取锁，而另外一个函数使用相反的顺序（<code>games</code> 然后 <code>players</code>）。这只是一个普遍问题的简单示例；更长的嵌套锁链也会出现这种情况（线程 1 取得锁 A，然后 B，然后尝试获取 C；线程 2 获取 C，然后尝试获取 A）以及跨更多线程（线程 1 给 A 上锁，然后 B；线程 2 给 B 上锁，然后 C；线程 3 给 C 上锁，然后 A）。</p>
<p>解决此问题的尝试的简单方法有：缩小锁的范围，因此我没有必要同时持有两个锁。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 添加新玩家，并把他们加入到当前游戏
fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameId&gt; {
    // 添加新玩家。
    {
        let mut players = self.players.lock().unwrap();
        players.insert(username.to_owned(), info);
    }

    // 找到一个未满的游戏房间来让他们加入
    {
        let mut games = self.games.lock().unwrap();
        for (id, game) in games.iter_mut() {
            if game.add_player(username) {
                return Some(id.clone());
            }
        }
    }
    None
}
/// 通过 `username` 来封禁掉玩家，把他们从任何当前游戏中移除
fn ban_player(&amp;self, username: &amp;str) {
    // 找到该用户所在所有的游戏房间，并移除。
    {
        let mut games = self.games.lock().unwrap();
        games
            .iter_mut()
            .filter(|(_id, g)| g.has_player(username))
            .for_each(|(_id, g)| g.remove_player(username));
    }

    // 从用户列表删除他们。
    {
        let mut players = self.players.lock().unwrap();
        players.remove(username);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>（更好的方法是将 <code>players</code> 数据结构的操作封装到 <code>add_player()</code> 和 <code>remove_player()</code> 辅助方法中，来减少忘记关闭作用域范围的可能性。）</p>
<p>这解决了死锁问题，但是又多了数据一致性的问题：如果执行顺序如表 3-2 所示，<code>players</code> 和 <code>games</code> 的数据结构可能会彼此不同步。</p>
<p><em>表 3-2. 状态不一致顺序</em></p>
<div class="table-wrapper"><table><thead><tr><th><strong>线程 1</strong></th><th><strong>线程 2</strong></th></tr></thead><tbody>
<tr><td>进入 <code>add_and_join("Alice")</code> 并且添加 Alice 到 <code>players</code> 数据结构中（然后释放 <code>players</code> 锁）</td><td></td></tr>
<tr><td></td><td>进入 <code>ban_player("Alice")</code> 并且从所有 <code>games</code> 中移除 Alice（然后释放 <code>games</code> 锁）</td></tr>
<tr><td></td><td>从 <code>players</code> 数据结构中删除 Alice；线程 1 已经释放了锁，所以不会阻塞</td></tr>
<tr><td>继续并获取 <code>games</code> 锁（已由线程 2 释放）。持有锁后，添加 "Alice" 到正在进行的游戏中</td><td></td></tr>
</tbody></table>
</div>
<p>此时，根据 <code>player</code> 数据结构，有一个游戏包含不存在的玩家！</p>
<p>问题的核心是，有两个数据结构都需要保持彼此同步。做到这一点的最好方法是使用一个覆盖二者的同步原语：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameState {
    players: HashMap&lt;String, Player&gt;,
    games: HashMap&lt;GameId, Game&gt;,
}

struct GameServer {
    state: Mutex&lt;GameState&gt;,
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_3-item17-deadlock-建议"><a class="header" href="#chapter_3-item17-deadlock-建议">建议</a></h2>
<p>为了避免共享状态并行性所出现的问题，最明显的建议就是避免共享状态的并行性。<a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">Rust 程序设计语言</a>中引用了 <a href="https://golang.org/doc/effective_go.html#concurrency">Go 语言文档</a>：“不用通过共享内存进行通信；相反，通过通信来共享内存。”</p>
<p>Go 语言<a href="https://go.dev/ref/spec#Channel_types">内置了</a>用于这种操作的<em>管道</em>；对 Rust 来说，相同的功能可以在标准库 <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code> 模块</a>中找到：函数 <code>channel()</code> 返回一个 <code>(Sender, Receiver)</code> 元组对，允许特性类型的值在线程之间进行通信。</p>
<p>如果共享状态进行并发无法避免，那么有一些方法可以减少编写容易出现死锁问题的代码：</p>
<ul>
<li><strong>将必须保持一致的数据结构包含在单个互斥锁中。</strong></li>
<li><strong>保持互斥锁的范围越小越明显越好</strong>；尽可能使用辅助方法来获取和设置锁所包含的内容。</li>
<li><strong>避免调用持有锁的闭包</strong>；这会使得代码受到将来可能添加到代码库中的任何闭包的影响。</li>
<li>同样，<strong>避免将 <code>MutexGuard</code> 返回给调用者</strong>：从死锁的角度看，这就像是分发一把已经上膛的枪。</li>
<li>在 CI 系统（<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>）中加入<em>死锁检测工具</em>，例如 <a href="https://docs.rs/no_deadlocks"><code>no_deadlocks</code></a>，<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>，或<a href="https://amanieu.github.io/parking_lot/parking_lot/deadlock/index.html"><code>parking_lot::deadlock</code></a>。</li>
<li>最后手段：设计、记录、测试并严格执行一个<em>上锁的层次结构</em>，该结构描述了允许\需求的锁定顺序。这应该作为最后的手段，因为任何依赖于工程师从不犯错策略从长远来看都很可能失败。</li>
</ul>
<p>更抽象地说，多线程代码应该应用于以下一般建议的理想场所：倾向于编写明显没有错误的简单代码，而不是编写复杂到不明显有错误的代码。</p>
<h4 id="chapter_3-item17-deadlock-注释"><a class="header" href="#chapter_3-item17-deadlock-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_3-item17-deadlock-1"><sup class="footnote-definition-label">1</sup>
<p>第三种类的行为是*线程对立（thread-hostile）*的：<em>即使</em>对它的所有访问都是对外同步的，代码在多线程环境中也是危险的。</p>
</div>
<div class="footnote-definition" id="chapter_3-item17-deadlock-2"><sup class="footnote-definition-label">2</sup>
<p>Clang C++ 编译器包含一个 <a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html"><code>-Wthread-safety</code></a> 选项，有时也称为<em>注释</em>，它允许通过关于哪一个互斥锁保护该数据的信息来注释该数据，并通过关于该函数获取锁的信息来注释该函数。当这些不变量被破坏时，会在编译期产生错误，就像 Rust 一样；然而，并没有强制使用这些注释——例如，当一个线程兼容的库第一个在多线程环境中使用时。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/deadlock.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3-item18-panic"></div><h1 id="chapter_3-item18-panic-不要-panic"><a class="header" href="#chapter_3-item18-panic-不要-panic">不要 panic</a></h1>
<blockquote>
<p>“它看起来非常复杂，这就是为什么它紧凑的塑料盖子上用大大的友好字母写着 DON'T PANIC 的原因之一。”——Douglas Adams</p>
</blockquote>
<p>本条的标题应当更准确的描述为<strong>更应该返回 <code>Result</code> 而不是使用 <code>panic!</code></strong>（但是<strong>不要 panic</strong> 更吸引人）。</p>
<p>Rust 的 panic 机制主要是针对程序中不可恢复的错误而设计的，<em>默认情况</em>下会终止发出 <code>panic!</code> 的线程。然而，除了默认情况还有其他选择。</p>
<p>特别是，来自具有异常系统的语言（例如 Java 或者 C++）的 Rust 新手通常会使用 <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind</code></a> 作为模拟异常的方法，因为这似乎提供了一种在调用栈上捕获 panic 的机制。</p>
<p>考虑一个因无效输入而 panic 的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        panic!("Cowardly refusing to divide by zero!");
    }
    a / b
}
<span class="boring">}</span></code></pre></pre>
<p>尝试用无效输入调用它，会按预期一样报错：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 尝试去计算 0/0 是什么...
let result = divide(0, 0);
<span class="boring">}</span></code></pre></pre>
<pre><code>thread 'main' panicked at 'Cowardly refusing to divide by zero!', main.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>以下包装函数使用 <code>catch_unwind</code> 来捕获 panic：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide_recover(a: i64, b: i64, default: i64) -&gt; i64 {
    let result = std::panic::catch_unwind(|| divide(a, b));
    match result {
        Ok(x) =&gt; x,
        Err(_) =&gt; default,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>似乎</em>可以正常运行并模拟 <code>catch</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = divide_recover(0, 0, 42);
println!("result = {result}");
<span class="boring">}</span></code></pre></pre>
<pre><code>result = 42
</code></pre>
<p>然而，外在具有欺骗性。这种方法的第一个问题是，panic 并不总是被回退（unwind）；有一个<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic">编译器选项</a>（可通过 <em>Cargo.toml</em> <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#panic">配置文件</a>配置）可以改变 panic 后的行为，以便立即终止进程：</p>
<pre><code>thread 'main' panicked at 'Cowardly refusing to divide by zero!', main.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
/bin/sh: line 1: 29100 Abort trap: 6  cargo run --release
</code></pre>
<p>这使得任何尝试模拟异常的方式完全受到整个项目配置文件的支配。还有一种情况是，无论编译器或项目配置如何，某些目标平台（例如，WebAssembly）<em>总会</em>因 panic 而终止。</p>
<p>一个更微妙的问题是，panic 处理引发了<a href="https://en.wikipedia.org/wiki/Exception_safety">异常安全</a>：如果 panic 发生在对数据结构进行操作的过程中，则会消除对数据结构已处于自一致状态的任何保证。自 20 世纪 90 年代以来，在存在异常的情况下保持内部不变量已被证明极其困难；<sup class="footnote-reference"><a href="#chapter_3-item18-panic-1">1</a></sup>这也是为什么 <a href="https://google.github.io/styleguide/cppguide.html#Exceptions">Google （众所周知）禁止在其 C++ 代码中使用异常</a>的主要原因之一。</p>
<p>最后，panic 传播与 FFI（外部函数接口）绑定（<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>）的<a href="https://doc.rust-lang.org/nomicon/ffi.html#ffi-and-unwinding">交互也很差</a>； <em>应使用 <code>catch_unwind</code> 来防止 Rust 代码中的 panic</em> 跨 FFI 绑定<em>传播到非 Rust 调用代码</em>。</p>
<p>那么除了 <code>panic!</code> 之外还有什么方法可以处理错误呢？对于库代码，最好的替代方案就是返回具有合适错误类型的 <code>Result</code>（<a href="https://www.lurklurk.org/effective-rust/errors.html">第 4 条</a>），以此将错误视为<a href="https://en.wikipedia.org/wiki/Somebody_else%27s_problem">其他人的问题</a>。这允许使用该库的人自行决定下一步该做什么——这可能涉及通过 <code>?</code> 运算符将问题传播给队列中的下一个调用者。</p>
<p>错误传播必须在某处停止，如果你可以控制 <code>main</code> 的行为，那么根据经验适当调用 <code>panic!</code> 是可以的（或者 <code>unwrap()</code>，<code>expect()</code> 等等）；此时，就没有其他的调用者可以将错误传播给它了。</p>
<p>即使在库代码中，<code>panic!</code> 另一个合理的用处是在极少数遇到错误的情况下，并且你不希望用户必须通过 <code>.unwrap()</code> 调用来搞乱他们的代码。</p>
<p>如果错误情况<em>应当</em>发生只是因为（比如说）内部数据损坏，而不是由于无效输入，那么触发 <code>panic!</code> 是合理的。</p>
<p>允许无效输入引发的 panic 有时甚至是有用的，但这种无效输入应该是不常见的。这样的方法在相关的入点成对出现时效果最好：</p>
<ul>
<li>“万无一失”函数，其签名意味着它总是会成功运行（如果不能成功就会 panic）</li>
<li>“可能出错”函数，返回一个 <code>Result</code></li>
</ul>
<p>对于前者，Rust 的 <a href="https://rust-lang.github.io/api-guidelines/documentation.html#function-docs-include-error-panic-and-safety-considerations-c-failure">API 指南</a> 建议 <code>panic!</code> 应该记录在内联文档的特定部分中（<a href="https://www.lurklurk.org/effective-rust/documentation.html">第 27 条</a>）。</p>
<p>标准库中的 <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8_unchecked"><code>String::from_utf8_unchecked</code></a> 和 <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a> 的入点是后者的示例（尽管在这种情况下，panic 实际上被推迟到使用无效输入来构造 <code>String</code> 的位置）。</p>
<p>假设你正在尝试遵循本条给出的建议，则需要牢记以下几点。首先，panic 可能以不同形式出现；避免 <code>panic!</code> 的同时也要避免以下情况：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap()</code></a> 和 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err()</code></a></li>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect()</code></a> 和 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err"><code>expect_err()</code></a></li>
<li><a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!()</code></a></li>
</ul>
<p>更难发现的情况如下：</p>
<ul>
<li><code>slice[index]</code> 索引超出范围</li>
<li><code>x / y</code> 当 <code>y</code> 是零时</li>
</ul>
<p>关于避免 panic 的第二种观察是，一个依赖于人类持续保持警觉的计划永远不是一个好主意。</p>
<p>然而，让机器去持续保持警觉是另一回儿事：向你的系统持续集成（详见<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>）检查系统，以发现新的，潜在的 panic 代码要可靠的多。一个简单的版本可以是针对最常见的 panic 入点进行简单地 grep（如前所述）；更彻底的检查可以涉及使用 Rust 生态系统中的其他工具（<a href="https://www.lurklurk.org/effective-rust/use-tools.html">第 31 条</a>），例如设置一个构建变体，并引入 <a href="https://docs.rs/no-panic"><code>no_panic</code></a> crate。</p>
<h4 id="chapter_3-item18-panic-注释"><a class="header" href="#chapter_3-item18-panic-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_3-item18-panic-1"><sup class="footnote-definition-label">1</sup>
<p>Tom Cargill 在 1994 年的<a href="https://ptgmedia.pearsoncmg.com/imprint_downloads/informit/aw/meyerscddemo/DEMO/MAGAZINE/CA_FRAME.HTM">文章《C++ Report》</a>中探讨了保持 C++ 模板代码的异常安全性是多么困难，Herb Sutter 的 <a href="http://www.gotw.ca/gotw/008.htm">Guru of the Week #8</a> 也有类似的讨论。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/panic.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_3-item19-reflection"></div><h1 id="chapter_3-item19-reflection-第-19-条避免反射"><a class="header" href="#chapter_3-item19-reflection-第-19-条避免反射">第 19 条：避免反射</a></h1>
<p>从其他语言转向 Rust 的程序员通常习惯于将反射作为他们工具箱的一部分。他们会浪费大量时间尝试在 Rust 中实现基于反射的设计，结果他们会发现他们尝试做的事情即使能做成，也会很糟糕。本条希望通过描述 Rust 关于反射有的和没有的，以及可以用什么来代替，从而节省探索死胡同所浪费的时间。</p>
<p><em>反射</em>是程序在运行时上检查自身的能力。给运行时丢一个数据，会有以下问题：</p>
<ul>
<li>可以确定有关该数据的类型的哪些信息？</li>
<li>可以利用这些信息做什么？</li>
</ul>
<p>具有完全反射支持的语言对这些问题有很多解答。具有反射的语言通常根据反射信息在运行时上支持以下或全部功能：</p>
<ul>
<li>判断一个数据的类型</li>
<li>发掘其内容</li>
<li>更改其字段</li>
<li>调用其方法</li>
</ul>
<p>具有这种程度的反射支持的语言也<em>往往</em>是动态类型语言（比如 <a href="https://docs.python.org/3/library/types.html#module-types">Python</a>, Ruby），但是还有一些出名的静态类型语言也支持反射，特别是 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html">Java</a> 和 <a href="https://golang.org/pkg/reflect/">Go</a>。</p>
<p>Rust 不支持这种类型的反射，这使得<strong>避免反射</strong>的建议在这种层次上非常容易实现——但其实是不可能的。对于来自完整支持反射的语言的程序员来说，乍一看，反射的缺席似乎是一个重大差距，但 Rust 的其他功能提供了许多解决相同问题的替代方法。</p>
<p>C++ 有一种有限制的反射，称为<em>运行时类型识别</em>（<em>run-time type identification</em>, RTTI）。<a href="https://en.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a> 操作符为<em>多态类型</em>的对象（大概是：有虚函数的类），返回每个类型的独一无二的标识符。</p>
<ul>
<li><code>typeid</code>：可以通过基类引用来恢复对象的具体类</li>
<li><a href="https://en.cppreference.com/w/cpp/language/dynamic_cast"><code>dynamic_cast&lt;T&gt;</code></a>：在安全且正确的情况下，允许将基类转换为派生类</li>
</ul>
<p>Rust 也不支持这种 RTTI 风格的反射，延续了本条建议所遵循的主题。</p>
<p>Rust 确实支持一些在 <a href="https://doc.rust-lang.org/std/any/index.html"><code>std::any</code></a> 模块中提供的<em>类似</em>功能特性，但它们功能受限（接下来将探索的）并且最好避免使用，除非没有其他代替方案。</p>
<p><code>std::any</code> 中第一个类似反射的功能<em>乍一看</em>非常神奇——是一种确定数据类型名字的方法。以下示例使用了用户定义的 <code>tname()</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42u32;
let y = vec![3, 4, 2];
println!("x: {} = {}", tname(&amp;x), x);
println!("y: {} = {:?}", tname(&amp;y), y);
<span class="boring">}</span></code></pre></pre>
<p>输出在值的旁边显示类型：</p>
<pre><code>x: u32 = 42
y: alloc::vec::Vec&lt;i32&gt; = [3, 4, 2]
</code></pre>
<p><code>tname()</code> 的实现揭示了编译器的秘密：这是一个泛型函数（根据<a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a>），所以实际上每次调用都会生成一个不同的函数（<code>tname::&lt;u32&gt;</code> 或 <code>tname::&lt;Square&gt;</code>）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tname&lt;T: ?Sized&gt;(_v: &amp;T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
<span class="boring">}</span></code></pre></pre>
<p>函数的实现由 <a href="https://doc.rust-lang.org/std/any/fn.type_name.html"><code>std::any::type_name&lt;T&gt;</code></a> 库函数提供，也是泛型函数。该函数只能访问<em>编译期</em>信息；没有代码在运行时来确定类型。<a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a>中返回到 trait 对象的类型证实了这一点：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let square = Square::new(1, 2, 2);
let draw: &amp;dyn Draw = &amp;square;
let shape: &amp;dyn Shape = &amp;square;

println!("square: {}", tname(&amp;square));
println!("shape: {}", tname(&amp;shape));
println!("draw: {}", tname(&amp;draw));
<span class="boring">}</span></code></pre></pre>
<p>只有 trait 对象的类型可用，而不是具体底层数据的类型（<code>Square</code>）：</p>
<pre><code>square: reflection::Square
shape: &amp;dyn reflection::Shape
draw: &amp;dyn reflection::Draw
</code></pre>
<p><code>type_name</code> 返回的字符串仅能用于诊断——它显然是一个“尽力了”的助手，其内容可能改变并且可能不唯一——所以<strong>不要尝试解析 <code>type_name</code> 的结果</strong>。如果你需要全局唯一的类型标识符，请使用 <a href="https://en.cppreference.com/w/cpp/language/typeid"><code>TypeId</code></a> 代替：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::TypeId;

fn type_id&lt;T: 'static + ?Sized&gt;(_v: &amp;T) -&gt; TypeId {
    TypeId::of::&lt;T&gt;()
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("x has {:?}", type_id(&amp;x));
println!("y has {:?}", type_id(&amp;y));
<span class="boring">}</span></code></pre></pre>
<pre><code>x has TypeId { t: 18349839772473174998 }
y has TypeId { t: 2366424454607613595 }
</code></pre>
<p>输出对人类来说是不可读的，但唯一性确保结果可以在代码中使用。但是，通常最好不要直接用 <code>TypeId</code>，而是使用 <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>std::any::Any</code></a> trait 来替代，因为标准库有用于处理 <code>Any</code> 实例的附加方法（如下）。</p>
<p><code>Any</code> trait 有一个方法 [<code>type_id()</code>]，对实现了该 trait 的类型返回一个 <code>TypeId</code> 值。不过，你不能自行实现该 trait，因为 <code>Any</code> 已经为大多数任意类型 <code>T</code> 提供了全面的实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: 'static + ?Sized&gt; Any for T {
    fn type_id(&amp;self) -&gt; TypeId {
        TypeId::of::&lt;T&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这种一揽子实现并未覆盖<em>所有</em>类型 <code>T</code>：<code>T: 'static</code> <em>生命周期约束</em>意味着如果 <code>T</code> 包含任何具有非<code>'static</code> 生命周期的引用，那么 <code>TypeId</code> 就没有为 <code>T</code> 实现。这是<a href="https://github.com/rust-lang/rust/issues/41875">有意的限制</a>，因为生命周期并不完全属于该类型：<code>TypdId::of::&lt;&amp;'a T&gt;</code> 与 <code>TypeId::of::&lt;&amp;'b T&gt;</code> 虽然是相同的，但他俩生命周期不同，这增加了混淆和不安全代码的可能性（译者注：意思是 <code>type_id()</code> 对他俩只会返回相同的 <code>TypeId</code>，但是他俩生命周期是不同的，生命周期不是类型的一部分，判断他俩的 <code>id</code> 会导致混淆并且不安全，所以要加限制为 <code>'static</code>）。</p>
<p>回想一下<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>，trait 对象是一个胖指针，存储了指向底层具体数据的指针，以及指向该 trait 实现的虚表的指针。对于 <code>Any</code>，虚表只有一个入点，即用于返回项目类型的 <code>type_id()</code> 方法，如图 3-4 所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x_any: Box&lt;dyn Any&gt; = Box::new(42u64);
let y_any: Box&lt;dyn Any&gt; = Box::new(Square::new(3, 4, 3));
<span class="boring">}</span></code></pre></pre>
<p><img src="chapter_3/../images/item19/anytraitobj.svg" alt="" /></p>
<p><em>图 3-4. <code>Any</code> trait 对象，每个都有指向具体数据以及虚表的指针</em></p>
<p>除了一些间接寻址之外，一个 <code>dyn Any</code> trait 对象实际上就是一个裸指针和一个类型标识符的结合体。这意味着标准库可以为一个 <code>dyn Any</code> trait 对象提供一些附加的已定义的通用方法；这些方法对于某些附加类型 <code>T</code> 是通用的：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.is"><code>is::&lt;T&gt;()</code></a>：指示了 trait 对象是否等于某个特定的其他类型 <code>T</code></li>
<li><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref::&lt;T&gt;()</code></a>：返回对具体类型 <code>T</code> 的引用，前提是 trait 对象的类型与 <code>T</code> 匹配</li>
<li><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_mut"><code>downcast_mut::&lt;T&gt;()</code></a>：返回对具体类型 <code>T</code> 的可变引用，前提是 trait 对象的类型与 <code>T</code> 匹配</li>
</ul>
<p>你会发现 <code>Any</code> trait 只是近似反射的功能：语法选择了（在编译时）显式构建一些东西（<code>&amp;dyn Any</code>）来跟踪该数据的编译时类型以及位置。仅当构建 <code>Any</code> trait 对象的开销已经发生时，（比如）向下转型回原始类型的能力才是可能的。</p>
<p>Rust 中很少有场景会在一个数据上关联不同的编译时类型和运行时类型。其中最主要的就是 <em>trait objects</em>：具体类型为 <code>Square</code> 的数据可以被强制转换为该类型实现的 trait 对象 <code>dyn Shape</code>。这种强制是从一个简单的指针（对象/数据）构建了一个胖指针（对象 + 虚表）。</p>
<p>回想<a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a>，Rust 的 trait 对象并不是真正面向对象的。<code>Square</code> 并不是一个 <code>Shape</code>；只是 <code>Square</code> 实现了 <code>Shape</code> 的接口。对于 trait 约束也是如此：一个 trait 约束 <code>Shape: Draw</code> 并不意味着 <em>is-a</em>；这只意味着<em>也实现了</em>，因为 <code>Shape</code> 的虚表包含了 <code>Draw</code> 的方法的入点。</p>
<p>对于一些简单的 trait 约束：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Draw: Debug {
    fn bounds(&amp;self) -&gt; Bounds;
}

trait Shape: Draw {
    fn render_in(&amp;self, bounds: Bounds);
    fn render(&amp;self) {
        self.render_in(overlap(SCREEN_BOUNDS, self.bounds()));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>等效的 trait 对象：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let square = Square::new(1, 2, 2);
let draw: &amp;dyn Draw = &amp;square;
let shape: &amp;dyn Shape = &amp;square;
<span class="boring">}</span></code></pre></pre>
<p>带有箭头的图片（如图 3-5；与<a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a>重复）使问题变得清晰明了；给定一个 <code>dyn Shape</code> 对象，没有直接的方法来构建 <code>dyn Draw</code> trait 对象，因为没有方法变回 <code>impl Draw for Square</code> 的虚表——即使其内容的相关部分（<code>Square::bounds()</code> 方法的地址）理论上<em>是</em>可以恢复的。（这可能在 Rust 的更高版本中发生变化；请参阅本条最后部分。）</p>
<p><img src="chapter_3/../images/item12/traitbounds.svg" alt="" /></p>
<p><em>图 3-5. 用于 trait 约束的 trait 对象，用于 <code>Draw</code> 和 <code>Shape</code> 的不同虚表</em></p>
<p>与上图对比，显然，显式构造的 <code>&amp;dyn Any</code> trait 对象没有用处。<code>Any</code> 允许恢复底层数据的具体类型，但没有方法可以查看它实现了哪些 trait，或者访问可能允许创建的 trait 对象的相关虚表。</p>
<p>那么可以用什么来替代呢？</p>
<p>最主要的工具是 trait 定义，这与其他语言的建议一致——<em>Effective Java</em>第 65 条建议，“接口比反射更好”。如果代码需要依赖于某个数据的某些行为的可用性，请为该行为编写一个 trait（<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>）。即使所需的行为无法表达为一组方法签名，也可以使用标记 trait 来表明所需行为所需的遵守，这比（例如）检查类名的特定前缀更安全且高效。</p>
<p>需要 trait 对象的代码也可以用于哪些在程序链接时尚未提供支持代码的对象，因为这些代码是在运行时动态加载的（通过 <code>dlopen(3)</code> 或类似方法）——这意味着范型的单态化(<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>)是不可能的。</p>
<p>相关地，反射有时也被用在其他语言中，以允许同一依赖库的多个不兼容版本一次加载到程序中，绕过“只能有一个”的链接约束。这在 Rust 中是不需要的，因为 Cargo 已经可以处理同一个库的多个版本（<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）。</p>
<p>最后，宏——尤其是 <code>derive</code> 宏——可以被用于自动生成在编译期了解数据类型的代码，作为一种更高效、更类型安全的等效代码，相当于在运行时解析数据内容的代码。<a href="https://www.lurklurk.org/effective-rust/macros.html">第 28 条</a>讨论了 Rust 的宏系统。</p>
<h2 id="chapter_3-item19-reflection-rust-未来版本中的向上转型"><a class="header" href="#chapter_3-item19-reflection-rust-未来版本中的向上转型">Rust 未来版本中的向上转型</a></h2>
<p>本条的文本首次于 2021 年编写，期间是一直保持准确的，直到本书准备于 2024 年出版——此时 Rust 将会添加一个新功能，该功能会更改一些细节。</p>
<p><a href="https://github.com/rust-lang/rust/issues/65991">新的“trait 向上转型”功能</a>，当 <code>U</code> 是 <code>T</code> 的父 trait 时（<code>trait T: U {...}</code>），可以将 trait 对象 <code>dyn T</code> 向上转型为 <code>dyn U</code>。该功能在正式发布前已在 <code>#![feature(trait_upcasting)]</code> 开启，预计在 Rust 1.76 版本。</p>
<p>对于之前的示例，这意味着 <code>&amp;dyn Shape</code> trait 对象<em>可以</em>被转型为 <code>&amp;dyn Draw</code> trait 对象，更接近于 <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov 替换</a>原则中的 <em>is-a</em> 关系。允许这种转换会对虚表实现的内部细节产生连锁反应，它们可能会变得比上图所示的版本更复杂。</p>
<p>然而，该数据的核心不受影响——<code>Any</code> trait 没有父 trait，所以其向上转型的能力不会增加任何功能。</p>
<p>原文<a href="https://www.lurklurk.org/effective-rust/reflection.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_4"></div><h1 id="chapter_4-依赖项"><a class="header" href="#chapter_4-依赖项">依赖项</a></h1>
<blockquote>
<p>"当神想要惩罚我们时，他们会满足我们的祈祷。" —— 奥斯卡·王尔德</p>
</blockquote>
<p>几十年来，代码重用的想法仅仅是一个梦想。编写一次代码，打包成库，并在许多不同的应用程序中重用的想法是一个理想，这种理想只实现了少数标准库和公司内部工具。</p>
<p>互联网的增长和开源软件的兴起最终改变了这一切。第一个公开可访问的仓库，它收集了大量的有用库、工具和辅助程序，全部打包以便于重用，这就是 <code>CPAN</code>：综合 <code>Perl</code> 存档网络，自1995年以来在线。今天，几乎每种现代语言都有一个全面的开源库集合，存放在一个包仓库中，这使得添加新依赖项的过程变得简单快捷。<sup class="footnote-reference"><a href="#chapter_4-1">1</a></sup></p>
<p>然而，随着这种便捷、方便和速度，新的问题也随之而来。通常，重用现有代码仍然比自己编写代码容易，但依赖他人的代码会带来潜在的风险和陷阱。本书的这一章将帮助您意识到这些问题。</p>
<p>重点是特别针对 <code>Rust</code>，以及使用 <code>cargo</code> 工具，但许多关注的问题、主题和议题同样适用于其他工具链（和其他语言）。</p>
<hr />
<div class="footnote-definition" id="chapter_4-1"><sup class="footnote-definition-label">1</sup>
<p>显著的例外是C和C++，其中包管理仍然有些碎片化。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_4-item23-wildcard"></div><h1 id="chapter_4-item23-wildcard-第-23-条避免通配符导入"><a class="header" href="#chapter_4-item23-wildcard-第-23-条避免通配符导入">第 23 条：避免通配符导入</a></h1>
<p>Rust 的 <code>use</code> 语句可以从另一个 crate 或者模块中引入一个具名项，使得该项可以在当前模块的代码中不加限定符使用。形如 <code>use somecrate::module::*</code> 的通配符导入 <em>wildcard import</em>（或称 <em>glob import</em>）表示那个模块<em>所有</em>的 public 符号都被添加到了本地的命名空间中。</p>
<p>如 <a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a> 中所述，一个外部 crate 可能会向 API 中添加新的条目作为次要版本升级的一部分；这是一种向后兼容的修改。</p>
<p>这两个场景一旦结合到一起就会产生新的忧虑，依赖项的一个非破坏性更改可能会破坏你的代码：如果依赖项添加了一个与你已经使用的名称冲突的新符号，会发生什么情况？</p>
<p>从最简单的角度来看，这倒不是个问题：通配符导入的符号被视为低优先级，所以在你的代码中使用的匹配的名称都会被优先匹配：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::*;

// Local `Bytes` type does not clash with `bytes::Bytes`.
// 本地定义的 `Bytes` 类型不会跟 `bytes::Bytes` 发生冲突。
struct Bytes(Vec&lt;u8&gt;);
<span class="boring">}</span></code></pre></pre>
<p>不幸的是，仍然存在发生冲突的情况。例如，依赖项添加了一个新的 trait 并且为某些类型实现了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait BytesLeft {
    // Name clashes with the `remaining` method on the wildcard-imported
    // `bytes::Buf` trait.
    // `remaining` 方法跟通配符导入的 `bytes::Buf` trait 冲突了。
    fn remaining(&amp;self) -&gt; usize;
}

impl BytesLeft for &amp;[u8] {
    // Implementation clashes with `impl bytes::Buf for &amp;[u8]`.
    // 实现和 `impl bytes::Buf for &amp;[u8]` 冲突了。
    fn remaining(&amp;self) -&gt; usize {
        self.len()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果新 trait 中任一个方法的名称与该类型现有的方法名称发生冲突，编译器就没法明确地识别出要调用的是哪个方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1u8, 2u8, 3u8];
let v = &amp;arr[1..];

assert_eq!(v.remaining(), 2);
<span class="boring">}</span></code></pre></pre>
<p>就像编译时候的错误显示那样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0034]: multiple applicable items in scope
  --&gt; src/main.rs:40:18
   |
40 |     assert_eq!(v.remaining(), 2);
   |                  ^^^^^^^^^ multiple `remaining` found
   |
note: candidate #1 is defined in an impl of the trait `BytesLeft` for the
      type `&amp;[u8]`
  --&gt; src/main.rs:18:5
   |
18 |     fn remaining(&amp;self) -&gt; usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: candidate #2 is defined in an impl of the trait `bytes::Buf` for the
           type `&amp;[u8]`
help: disambiguate the method for candidate #1
   |
40 |     assert_eq!(BytesLeft::remaining(&amp;v), 2);
   |                ~~~~~~~~~~~~~~~~~~~~~~~~
help: disambiguate the method for candidate #2
   |
40 |     assert_eq!(bytes::Buf::remaining(&amp;v), 2);
   |                ~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="boring">}</span></code></pre></pre>
<p>因此，你应该<strong>避免从你无法控制的 crate 中进行通配符导入</strong>。</p>
<p>如果你可以控制被通配符导入的项目的代码，那么之前提到的问题就消失了。例如，<code>test</code> 模块通常会使用 <code>use super::*;</code>。对于主要通过模块来划分代码的 crate 来说，从内部模块进行通配符导入也是一种可能的场景：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod thing;
pub use thing::*;
<span class="boring">}</span></code></pre></pre>
<p>然而，还有另一种常见的例外情况也是适用通配符导入的。有一些 crate 遵循一个约定，crate 中常见的条目会通过 <em>prelude</em> 模块重新导出，而这个就是特地被用于使用通配符导入的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thing::prelude::*;
<span class="boring">}</span></code></pre></pre>
<p>尽管从理论上来讲这种场景也会出现上面提及过的问题，但实际上这种 prelude 模块大多经过精心的设计，这样使用带来的更高的便利性可能会远超过未来出现问题的小概率风险。</p>
<p>最后，如果你不打断遵循这个条款的建议，<strong>考虑将你使用通配符引入的依赖项固定到一个特定的版本上（见 <a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a>）</strong>，让依赖项不会自动升级次要版本。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_5"></div><h1 id="chapter_5-工具"><a class="header" href="#chapter_5-工具">工具</a></h1>
<p>泰特斯-温特斯（Titus Winters，谷歌 C++ 库开发负责人）将<strong>软件工程</strong>描述为随着时间推移而整合的编程，有时也称为随着时间和人员而整合的编程。在更长的时间尺度和更广泛的团队中，代码库中的内容不仅仅是代码。</p>
<p>包括 Rust 在内的现代语言都意识到了这一点，并建立了一个工具生态系统，而不仅仅是将程序转换为可执行的二进制代码（编译器）。</p>
<p>本章将探讨 Rust 工具生态系统，并提出一些建议关于基础工具的使用建议。比如在开发过程中显而易见的是，需要考虑适度性 —— 对于一个只运行若干次的一次性程序来说，设置 CI、文档构建以及六种类型的验证测试可能是不必要的情况（杀鸡焉用牛刀）。但是，对于本节中描述的大部分内容，通过巧妙的根据项目需求选择合适的工具集成进来，能够提高开发效率，减少错误，并且增强代码质量。适当学工具使用学习的投入，在长远来看会有更大的回报。最终达到"物有所值"的效果。</p>
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_5-item27-document-public-interfaces"></div><h1 id="chapter_5-item27-document-public-interfaces-第-27-条为公共接口撰写文档"><a class="header" href="#chapter_5-item27-document-public-interfaces-第-27-条为公共接口撰写文档">第 27 条：为公共接口撰写文档</a></h1>
<p>如果你的包（crate）会被其他程序员所使用，那么为包中的内容添加文档就是很好的实践，尤其是包中的公共接口。如果你的包不仅仅是随用随丢的代码，那么这个“其他程序员”就包括未来的你，那个已经忘掉了自己代码细节的你。</p>
<p>这个建议并不是 Rust 所独有的，它也并不是一个新的建议 —— 比如，<a href="https://www.oreilly.com/library/view/effective-java-2nd/9780137150021/">Effective Java</a> 第二版（2008年出版）在第 44 条中建议：“为所有导出的 API 元素编写文档注释”。</p>
<p>Rust 文档类型注释的细节 —— 基于 Markdown 格式，以 /// 或者 //! 分割 —— 已经在<a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">Rust book</a>中介绍了，如下为示例：</p>
<pre><code class="language-Rust">/// Calculate the [`BoundingBox`] that exactly encompasses a pair
/// of [`BoundingBox`] objects.
pub fn union(a: &amp;BoundingBox, b: &amp;BoundingBox) -&gt; BoundingBox {
    // ...
}
</code></pre>
<p>然而，关于文档型注释的格式仍有一些值得关注的细节：</p>
<ul>
<li>使用代码格式：对于任何作为源代码的注释，使用反引号来确保在最终的文档中代码会以一种等宽字体来展示，并以此来明确的区分<code>code</code>以及一般的文本。</li>
<li>添加丰富的引用内容：为任何能够给读者提供上下文信息的内容添加 Markdown 链接。特别地，可以使用比较方便的 [<code>SomeThing</code>] 格式的交叉引用标注符语法 —— 括号内的<code>Something</code>将会在最终文档中被添加正确的超链接。</li>
<li>多添加示例代码：如果接口应该如何使用并非一目了然的，那么添加一个使用该接口的<code># Example</code>段落将会很有用。如在<a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">文档注释</a>里的示例代码会在你执行<code>cargo test</code>（详情查看<a href="https://www.lurklurk.org/effective-rust/testing.html">第 13 条</a>）时编译并且运行，这一特性将有助于示例代码和它希望表述的代码保持一致。</li>
<li>为<code>panic</code>和<code>unsafe</code>的代码添加说明文档：如果存在会导致函数<code>panic</code>的输入，在文档（<code># Panics</code>段落）里说明规避<code>panic!</code>的前置条件。同样地，在文档（<code># Safety</code>段落）里说明<code>unsafe</code>代码的使用要求。</li>
</ul>
<p>Rust 的<a href="https://doc.rust-lang.org/std/index.html">标准库</a>是一个能够实践了上述所有细节的优秀示例。</p>
<h2 id="chapter_5-item27-document-public-interfaces-工具"><a class="header" href="#chapter_5-item27-document-public-interfaces-工具">工具</a></h2>
<p>在注释文档中使用 Markdown 格式不仅意味着优美的输出，还意味着需要有一个明确的转换步骤（<code>cargo doc</code>）。而转换也就会增加出现问题的可能性。</p>
<p>对于这个问题，最简单的建议是在写完文档后，运行<code>cargo doc --open</code>（或者<code>cargo doc --no-deps --open</code>，这个指令能够严格约束仅产生当前包中的文档）并来<em>仔细阅读生成的结果</em>。</p>
<p>对于所有生成超链接的有效性，你当然可以人工地去校验它们，或者让机器来完成这项工作 —— 通过<code>broken_intra_dock_links</code>的包特性<sup class="footnote-reference"><a href="#chapter_5-item27-document-public-interfaces-1">1</a></sup>：</p>
<div class="ferris"><img src="chapter_5/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![deny(broken_intra_doc_links)]

<span class="boring">fn main() {
</span>/// The bounding box for a [`Polygone`].
#[derive(Clone, Debug)]
pub struct BoundingBox {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>当特性生效的时候，<code>cargo doc</code>将会找出无效的链接：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error: unresolved link to `Polygone`
 --&gt; docs/src/main.rs:4:30
  |
4 | /// The bounding box for a [`Polygone`].
  |                              ^^^^^^^^ no item named `Polygone` in scope
  |
<span class="boring">}</span></code></pre></pre>
<p>你也可以设置要求文档化，通过在包里设置<code>![warn(missing_docs)]</code>属性。当设置生效的时候，编译器将会给每个未配置文档的公开条目生成警告信息。然而，这样设置也存在着为了解决编译器报错而提供低质量注释文档的风险 —— 当然设置引入的问题不仅如此。</p>
<p>同样地，为了能够及时发现潜在风险，这些工具应该被纳入到你的持续集成系统（<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>）。</p>
<h2 id="chapter_5-item27-document-public-interfaces-其他的文档位置"><a class="header" href="#chapter_5-item27-document-public-interfaces-其他的文档位置">其他的文档位置</a></h2>
<p><code>cargo doc</code>的输出是包中文档所在的主要位置，但并不是唯一的地方 —— 在项目中的其他地方添加注释也可以帮助用户理解如何使用你的代码。</p>
<p>在 Cargo 项目的<code>examples/</code>子目录下可以添加一些方便使用包的示例代码。这些代码可以构建并运行，和集成测试（<a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>）的运行方式非常类似，不同的是这些代码提供的是便于理解包中接口使用的代码。</p>
<p>需要说明的是，<code>tests/</code>子目录下的集成测试代码也可以给用户提供帮助，虽然它们的主要作用是测试包的对外接口。</p>
<h2 id="chapter_5-item27-document-public-interfaces-发布包的文档"><a class="header" href="#chapter_5-item27-document-public-interfaces-发布包的文档">发布包的文档</a></h2>
<p>如果你的包会发布到<code>crates.io</code>，项目的文档就可以在<a href="https://docs.rs/">docs.rs</a>中查看到。docs.rs 是为发布的包构建并提供文档的官方 Rust 网站。</p>
<p>注意，<code>crates.io</code>和<code>docs.rs</code>的受众是不同的：<code>crates.io</code>旨在为选择包的用户提供服务，而<code>docs.rs</code>的受众是那些需要弄明白他们已经引用的包该如何使用的人（很明显的，这两种场景有很大的重叠）。</p>
<p>综上，一个包的主页在不同的地方会展示不同的内容：</p>
<ul>
<li><code>docs.rs</code>：展示<code>cargo doc</code>产出结果的顶层页面，比如从顶层<code>src/lib.rs</code>文件的<code>//!</code>生成的文档。</li>
<li><code>crates.io</code>：展示包含在项目仓库中的任何顶层<em>README.md</em> <sup class="footnote-reference"><a href="#chapter_5-item27-document-public-interfaces-2">2</a></sup>文件内容。</li>
</ul>
<h2 id="chapter_5-item27-document-public-interfaces-不文档化的内容"><a class="header" href="#chapter_5-item27-document-public-interfaces-不文档化的内容">不文档化的内容</a></h2>
<p>当一个项目<em>要求</em>公共条目都需要添加注释的时候，很容易就陷入到给无价值的内容也文档化的陷阱中。编译器的缺少注释文档的警告只是提醒你添加真正需要内容 —— 有用的文档 —— 的一种表现，并且仅仅期望程序员添加必要的内容来消除警告。</p>
<p>好的注释文档是一种能够帮助用户了解他们所使用代码的福利；糟糕的注释文档则增加了代码的维护成本并且让用户在它们不再和代码保持一致的时候变得更加困惑。那么好与不好的区别是什么呢？</p>
<p>最重要的建议是<em>避免重复可以从代码中看出的信息</em>。<a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item1-use-types.html">第 1 条</a>建议你的代码尽量的和 Rust 的类型系统保持一致；一旦你做到了这一点，就通过类型系统来说明这些语意。可以假定使用代码的用户对 Rust 已经熟悉了 —— 可能他们已经读了一些描述了如何高效使用语言的建议 —— 并且不需要重复从代码中的参数类型和函数签名中就能读出来的东西。</p>
<p>回到之前的例子，一个冗余的注释文档可能如下面描述的这样：</p>
<div class="ferris"><img src="chapter_5/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Return a new [`BoundingBox`] object that exactly encompasses a pair
/// of [`BoundingBox`] objects.
///
/// Parameters:
///  - `a`: an immutable reference to a `BoundingBox`
///  - `b`: an immutable reference to a `BoundingBox`
/// Returns: new `BoundingBox` object.
pub fn union(a: &amp;BoundingBox, b: &amp;BoundingBox) -&gt; BoundingBox {
<span class="boring">}</span></code></pre></pre>
<p>这个注释重复了很多从函数签名中就能读到的信息，注释信息毫无益处。</p>
<p>更糟的是，考虑一种代码重构后，将结果存储到其中一个参数（这是一种不兼容的变更；参照<a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a>）。没有编译器或者工具能够发现注释没有随之更新，结果就产生了一个未能和代码逻辑保持一致的注释：</p>
<div class="ferris"><img src="chapter_5/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Return a new [`BoundingBox`] object that exactly encompasses a pair
/// of [`BoundingBox`] objects.
///
/// Parameters:
///  - `a`: an immutable reference to a `BoundingBox`
///  - `b`: an immutable reference to a `BoundingBox`
/// Returns: new `BoundingBox` object.
pub fn union(a: &amp;mut BoundingBox, b: &amp;BoundingBox) {
<span class="boring">}</span></code></pre></pre>
<p>相反地，原本恰当的注释在重构中则可以毫发无损地保留下来，因为它的文本描述的是行为，而非语意本身：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Calculate the [`BoundingBox`] that exactly encompasses a pair
/// of [`BoundingBox`] objects.
pub fn union(a: &amp;mut BoundingBox, b: &amp;BoundingBox) {
<span class="boring">}</span></code></pre></pre>
<p>先前的建议也可以帮助提升文档质量：<em>在文档中包含任何从代码中无法了解的内容</em>。这包含前置条件、可变性、异常、报错条件以及任何可能会让用户感到意外的事情；如果你的代码不能遵守<a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">最小惊讶原则</a>，确保这些意外都被记录在文档里，至少你可以说“我已经告诉过你了”。</p>
<p>另一个常见的失败情形是，注释里描述了其他使用这个方法的代码，而非这个方法做了什么：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Return the intersection of two [`BoundingBox`] objects, returning `None`
/// if there is no intersection. The collision detection code in `hits.rs`
/// uses this to do an initial check to see whether two objects might overlap,
/// before performing the more expensive pixel-by-pixel check in
/// `objects_overlap`.
pub fn intersection(
    a: &amp;BoundingBox,
    b: &amp;BoundingBox,
) -&gt; Option&lt;BoundingBox&gt; {
<span class="boring">}</span></code></pre></pre>
<p>像这样的注释几乎不可能和代码保持一致：当使用了这个方法的代码（比如，<code>hits.rs</code>）变更的时候，这段描述了调用行为的注释相隔甚远而无法保持一致。</p>
<p>应当将注释重新组织以聚焦在<em>为什么</em>这样使用，可以让这段注释更好的适应未来的变更。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Return the intersection of two [`BoundingBox`] objects, returning `None`
/// if there is no intersection.  Note that intersection of bounding boxes
/// is necessary but not sufficient for object collision -- pixel-by-pixel
/// checks are still required on overlap.
pub fn intersection(
    a: &amp;BoundingBox,
    b: &amp;BoundingBox,
) -&gt; Option&lt;BoundingBox&gt; {
<span class="boring">}</span></code></pre></pre>
<p>当编写软件时，“面向未来的编程”<sup class="footnote-reference"><a href="#chapter_5-item27-document-public-interfaces-3">3</a></sup>是一种很好的实践：调整代码结构以适应未来的变更。同样的原则也适用于文档：聚焦在语意，为什么这样做以及为什么不这样做，会让文本在未来的运行中始终是有意义的。</p>
<h2 id="chapter_5-item27-document-public-interfaces-总结"><a class="header" href="#chapter_5-item27-document-public-interfaces-总结">总结</a></h2>
<ul>
<li>给公共的 API 内容添加注释文档。</li>
<li>为那些从代码中无法明确看出的内容添加描述 —— 比如<code>panics</code>以及<code>unsafe</code>的条件。</li>
<li>不要给可以从代码中明确看出的内容重复描述。</li>
<li>通过交叉引用及添加标志符来让导航变得明确。</li>
</ul>
<hr />
<h3 id="chapter_5-item27-document-public-interfaces-注释"><a class="header" href="#chapter_5-item27-document-public-interfaces-注释">注释</a></h3>
<div class="footnote-definition" id="chapter_5-item27-document-public-interfaces-1"><sup class="footnote-definition-label">1</sup>
<p>这个配置也曾称成为<code>intra_doc_link_resolution_failure</code>。</p>
</div>
<div class="footnote-definition" id="chapter_5-item27-document-public-interfaces-2"><sup class="footnote-definition-label">2</sup>
<p>包含 <em>README.md</em> 的引用动作可以被<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-readme-field">Cargo.toml 中的 readme 字段</a>覆盖。</p>
</div>
<div class="footnote-definition" id="chapter_5-item27-document-public-interfaces-3"><sup class="footnote-definition-label">3</sup>
<p>Scott Meyers，More Effective C++ (Addison-Wesley)，第 32 条。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/documentation.html">点这里</a>查看。</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_5-item28-use-macros-judiciously"></div><h1 id="chapter_5-item28-use-macros-judiciously-第-28-条在合适的时候使用宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-第-28-条在合适的时候使用宏">第 28 条：在合适的时候使用宏</a></h1>
<blockquote>
<p>“在一些场景下，我们会很容易来决定应该使用宏（macro）而非函数（function），因为只有宏才能满足我们的需求。” - Paul Graham，“<a href="https://www.paulgraham.com/onlisp.html">On Lisp (Prentice Hall)</a>”</p>
</blockquote>
<p>Rust 的宏能够让你实现元编程（metaprogramming）：在项目中使用代码来生成代码。这一特性在需要编写很多确定性、重复性都很强的“样板代码”时会很有用，不借助宏的话我们就只能手动维护这些代码了。</p>
<p>程序员接触 Rust 之前可能已经预先了解了 C/C++ 中通过预处理（preprocessor）来实现的宏，这种方式是在预处理阶段通过文本替换来展开宏定义。而 Rust 的宏则有一些不同，它是在符号流（parsed tokens of the program）或者在抽象语法树（abstract syntax tree, AST）的基础上实现的宏，而非在文本处理阶段。</p>
<p>这就意味着 Rust 的宏是能够理解代码结构并且规避掉一系列的文本替换方式实现的宏所存在的意外情况。比如说，在接下来的内容中，我们可以看到 Rust 所声明的宏是<a href="https://en.wikipedia.org/wiki/Hygienic_macro">卫生的</a> —— 在宏里不会意外引用（或者捕获）宏所嵌入代码中的变量信息。</p>
<pre><code class="language-c">/* 这段内容较为晦涩。引用一段维基百科上的内容来说明文本替换方式实现的宏所带来的问题。*/
#define INCI(i) { int a=0; ++i; }
int main(void)
{
  int a = 4, b = 8;
  INCI(a);
  INCI(b);
  printf("a is now %d, b is now %d\n", a, b);
  return 0;
}

/* 以上代码中的 INCI 宏期望分别对 a, b 进行加一操作。文本替换后的结果如下所示。*/

int main(void)
{
    int a = 4, b = 8;
    { int a = 0; ++a; }; // 注意这里对 a 进行了重新声明，实际上是对声明的这个 a 进行了自增。
    { int a = 0; ++b; }; 
    printf("a is now %d, b is now %d\n", a, b);
    return 0;
}

/* 最终的结果会输出如下。 
 *
 * a is now 4, b is now 9
 *
 * 这显然是不符合预期的。产生这一结果的原因是由于文本替换过于粗暴，而无法进行实际语意上的理解。
 *
 * 本注释内容为译者添加。
 */

</code></pre>
<p>一种理解宏的方法是将其视为代码的不同抽象方式。函数也是代码的一种简单抽象：它将同一类型的不同值的不同抽象出来，实现了针对这一类型，而非特定的值，会做的操作及方法。而宏中的生成则是另外一个层面的抽象：宏是对符合同一特性的不同类型进行抽象，使用针对这些不同类型所具备的相同特性，而非特性的类型，进行代码的实现。</p>
<p>宏可以对不同程序中扮演相同角色（类型、标记、表达式等）的代码抽象出来，然后这些程序就可以以同一种方式来使用抽象出的逻辑。</p>
<p>Rust 提供了两种方式来定义宏：</p>
<ul>
<li>声明宏，也被成为“示例宏”。声明宏允许将输入到宏中任意的 Rust 程序，基于抽象语法树中的结果，集成到代码中。</li>
<li>过程宏。过程宏同样可以将任意的 Rust 程序集成到代码中，不过是基于源码中的解析符号。<code>derive</code>宏就是常见的过程宏。<code>derive</code>宏可以基于代码的结构定义来展开代码。</li>
</ul>
<h2 id="chapter_5-item28-use-macros-judiciously-声明宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-声明宏">声明宏</a></h2>
<p>虽然这篇文章不是为了重复<a href="https://doc.rust-lang.org/reference/macros-by-example.html">声明宏</a>的内容，但还是有必要来提醒下声明宏中需要关注的内容。</p>
<p>首先，需要注意的是声明宏的作用域范围和直觉上的理解的是不同的（对比 C 里的预处理宏）。如果一个声明宏在源代码中被定义了，就只有<em>跟在</em>宏里的代码能够使用：</p>
<div class="ferris"><img src="chapter_5/../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn before() {
    println!("[before] square {} is {}", 2, square!(2));
}

/// Macro that squares its argument.
macro_rules! square {
    { $e:expr } =&gt; { $e * $e }
}

fn after() {
    println!("[after] square {} is {}", 2, square!(2));
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error: cannot find macro `square` in this scope
 --&gt; src/main.rs:4:45
  |
4 |     println!("[before] square {} is {}", 2, square!(2));
  |                                             ^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module/import?

<span class="boring">}</span></code></pre></pre>
<p><code>#[macro_export]</code>特性让宏可以访问更多的数据，但是也存在一些奇怪的事情：尽管宏并没有在模块中定义，它还是出现在了模块的顶层。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submod {
    #[macro_export]
    macro_rules! cube {
        { $e:expr } =&gt; { $e * $e * $e }
    }
}

mod user {
    pub fn use_macro() {
        // Note: *not* `crate::submod::cube!`
        let cubed = crate::cube!(3);
        println!("cube {} is {}", 3, cubed);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 的声明宏是卫生（hygienic）的：宏内部展开的代码无法使用所在作用域的局部变量。比如，宏内部使用了局部变量 x 时：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a macro that assumes the existence of a local `x`.
macro_rules! increment_x {
    {} =&gt; { x += 1; };
}
<span class="boring">}</span></code></pre></pre>
<p>这样的用法将会造成编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 2;
increment_x!();
println!("x = {}", x);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0425]: cannot find value `x` in this scope
   --&gt; src/main.rs:55:13
    |
55  |     {} =&gt; { x += 1; };
    |             ^ not found in this scope
...
314 |     increment_x!();
    |     -------------- in this macro invocation
    |
    = note: this error originates in the macro `increment_x`
<span class="boring">}</span></code></pre></pre>
<p>这种“卫生”的特性意味着 Rust 的宏比 C 的基于预处理替换的宏要安全很多。然而，仍有一些需要在使用时注意的内容。</p>
<p>第一，尽管一个宏<em>看起来</em>很像是函数的声明，它并不是。宏将会在调用的地方进行代码展开，而且可以随着传入参数的不同进行不同形式的展开：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! inc_item {
    { $x:ident } =&gt; { $x.contents += 1; }
}
<span class="boring">}</span></code></pre></pre>
<p>这就意味着常规意义上的参数被移动（moved）或者 &amp; （被引用）的情形没有发生：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Item { contents: 42 }; // type is not `Copy`

// Item is *not* moved, despite the (x) syntax,
// but the body of the macro *can* modify `x`.
inc_item!(x);

println!("x is {x:?}");
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x is Item { contents: 43 }
<span class="boring">}</span></code></pre></pre>
<p>如果我们还记得宏只是在调用它的地方进行展开的话，上述示例就会变得清楚了 —— 在这个示例中，调用宏的地方只相当于添加了一行增加<code>x.contents</code>值的代码。借助<a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a>可以很清晰地看到编译器将宏进行展开后的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Item { contents: 42 };
x.contents += 1;
{
    ::std::io::_print(format_args!("x is {0:?}\n", x));
};
<span class="boring">}</span></code></pre></pre>
<p>展开的代码中可以看到直接使用了变量本身，而非其引用。（一个有意思的事情是，我们可以看到<code>println!</code>的展开中，依赖了<code>format_args!</code>宏<sup class="footnote-reference"><a href="#chapter_5-item28-use-macros-judiciously-1">1</a></sup>。）</p>
<p>所以，宏里的<code>!</code>起到了一个警示的作用：展开的代码可能会对参数做一些任性的事情。</p>
<p>展开的代码也可能会包含一些在调用代码中无法访问的控制流，可能包括循环、判断、返回值甚至使用<code>?</code>操作符。显然，这里会和[最小惊讶原则]相冲突，所以在使用宏时，应当考虑封装常规的 Rust 语句。（另一方面，如果使用宏的<em>目的</em>是实现一些奇怪的控制流，请确保这些控制流在文档中都给用户提供了！）</p>
<p>举例来说，考虑这样一个宏（用来校验 HTTP 状态码）包含了一个<code>return</code>语句：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Check that an HTTP status is successful; exit function if not.
macro_rules! check_successful {
    { $e:expr } =&gt; {
        if $e.group() != Group::Successful {
            return Err(MyError("HTTP operation failed"));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>用这段宏来校验一些 HTTP 行为的代码可能会以一些很晦涩的控制流来结束：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rc = perform_http_operation();
check_successful!(rc); // may silently exit the function

// ...
<span class="boring">}</span></code></pre></pre>
<p>另一种可以实现上述功能的宏是产生一个<code>Result</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Convert an HTTP status into a `Result&lt;(), MyError&gt;` indicating success.
macro_rules! check_success {
    { $e:expr } =&gt; {
        match $e.group() {
            Group::Successful =&gt; Ok(()),
            _ =&gt; Err(MyError("HTTP operation failed")),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>而这样依赖，代码就很好理解了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rc = perform_http_operation();
check_success!(rc)?; // error flow is visible via `?`

// ...
<span class="boring">}</span></code></pre></pre>
<p>对于声明宏来说，第二件需要注意的事情是和 C 的预编译宏同样的问题：如果宏的参数是一个存在副作用的表达式，当心在宏里多次使用的情况。比如我们在早先定义的<code>square!</code>宏输入了较为随意的表达式来作为参数，然后使用两次，这将会造成奇怪的结果：</p>
<div class="ferris"><img src="chapter_5/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 1;
let y = square!({
    x += 1;
    x
});
println!("x = {x}, y = {y}");
// output: x = 3, y = 6
<span class="boring">}</span></code></pre></pre>
<p>假设这种行为并非有意的，一种修复的方法是尝试仅执行给定的表达式一次，然后将结果赋值给一个本地的变量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! square_once {
    { $e:expr } =&gt; {
        {
            let x = $e;
            x*x // Note: there's a detail here to be explained later...
        }
    }
}
// output now: x = 2, y = 4
<span class="boring">}</span></code></pre></pre>
<p>另一种可选的方案是不允许将表达式作为宏的输入。如果将[expr]替换为<code>indent</code>，那么这个宏就仅会接受标志符作为入参，而使用类似任意的表达式将不再能编译通过。</p>
<h2 id="chapter_5-item28-use-macros-judiciously-格式化参数"><a class="header" href="#chapter_5-item28-use-macros-judiciously-格式化参数">格式化参数</a></h2>
<p>声明宏的一种常见的使用模式将多个值汇聚成一个消息。比如，标准库中的<code>format!</code>用来拼接一个字符串，<code>println!</code>用来输出到标准输出，<code>eprintln!</code>用来输出到标准错误输出。<a href="https://doc.rust-lang.org/std/fmt/index.html">fmt 文档</a>中阐述了<code>format!</code>的语法，和<code>C</code>中的<code>printf</code>使用几乎是相同的。当然，Rust 中的<code>format!</code>参数是类型安全并且会在编译时进行检查的，并且<code>format!</code>宏实现时使用了<code>Display</code>以及<code>Debug</code>特性用来约束宏的参数。<code>Display</code>以及<code>Debug</code>宏的使用参见[第 10 条]<sup class="footnote-reference"><a href="#chapter_5-item28-use-macros-judiciously-2">2</a></sup>。</p>
<p>你可以（同时也建议）在项目中的宏中使用相同的格式化语法。比如，一个<code>log</code>库中的<code>logging</code>宏就可以使用和<code>format!</code>相同的语法。在实践中，使用<code>format_args!</code>来实现参数的格式化而不是重复造轮子。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Log an error including code location, with `format!`-like arguments.
/// Real code would probably use the `log` crate.
macro_rules! my_log {
    { $($arg:tt)+ } =&gt; {
        eprintln!("{}:{}: {}", file!(), line!(), format_args!($($arg)+));
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10u8;
// Format specifiers:
// - `x` says print as hex
// - `#` says prefix with '0x'
// - `04` says add leading zeroes so width is at least 4
//   (this includes the '0x' prefix).
my_log!("x = {:#04x}", x);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src/main.rs:331: x = 0x0a
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_5-item28-use-macros-judiciously-过程宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-过程宏">过程宏</a></h2>
<p>Rust 也支持了<em>过程宏</em>，也被称为<code>proc macros</code>。和声明宏类似，<a href="https://doc.rust-lang.org/reference/procedural-macros.html">过程宏</a>能够任意的 Rust 代码插入到程序的源代码中。不同的时，过程宏的输入不再仅限制在特定的传入参数。过程宏可以访问一些源代码中的解析符号（parsed tokens）。这就过程宏一定程度上类似动态语言，比如 Lisp，的非常富有表达力的能力 —— 但是仍然在编译时进行检查。这也帮助缓解了 Rust 中反射的局限，这在<a href="https://www.lurklurk.org/effective-rust/reflection.html">第 19 条</a>中讨论了。</p>
<p>过程宏需要和其被使用的代码定义在不同的包中（并且包需要被声明为<code>proc_macro</code>），并且包中往往需要引入[proc-macro]（官方工具链中提供）或者[proc-macro2]（由 David Tolnay 提供）的依赖，这两个依赖可以宏能够操作输入的符号。</p>
<p>实际上，有三种不同的过程宏：</p>
<ul>
<li>类函数宏（Function-like macros）：通过传入的参数调用。</li>
<li>类属性宏（Attribute macros）：附加到程序中的某些特定语法的代码中。</li>
<li>派生宏（Derive macros）：附加到特定的数据结构中。</li>
</ul>
<h3 id="chapter_5-item28-use-macros-judiciously-类函数宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-类函数宏">类函数宏</a></h3>
<p>函数式的宏会通过传递参数来调用，宏的实现中可以访问参数的解析符号（parsed tokens），并且返回任意的符号。注意在先前的表述中，我们使用的是单数的参数， —— 即使函数式的宏调用的时候看起来传入了很多参数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>my_func_macro!(15, x + y, f32::consts::PI);
<span class="boring">}</span></code></pre></pre>
<p>但是宏本身只接收到了一个解析后的符号流。一个将符号流输出（在编译时）的宏实现示例如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proc_macro::TokenStream;

// Function-like macro that just prints (at compile time) its input stream.
#[proc_macro]
pub fn my_func_macro(args: TokenStream) -&gt; TokenStream {
    println!("Input TokenStream is:");
    for tt in args {
        println!("  {tt:?}");
    }
    // Return an empty token stream to replace the macro invocation with.
    TokenStream::new()
}
<span class="boring">}</span></code></pre></pre>
<p>其运行结果如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Input TokenStream is:
  Literal { kind: Integer, symbol: "15", suffix: None,
            span: #0 bytes(10976..10978) }
  Punct { ch: ',', spacing: Alone, span: #0 bytes(10978..10979) }
  Ident { ident: "x", span: #0 bytes(10980..10981) }
  Punct { ch: '+', spacing: Alone, span: #0 bytes(10982..10983) }
  Ident { ident: "y", span: #0 bytes(10984..10985) }
  Punct { ch: ',', spacing: Alone, span: #0 bytes(10985..10986) }
  Ident { ident: "f32", span: #0 bytes(10987..10990) }
  Punct { ch: ':', spacing: Joint, span: #0 bytes(10990..10991) }
  Punct { ch: ':', spacing: Alone, span: #0 bytes(10991..10992) }
  Ident { ident: "consts", span: #0 bytes(10992..10998) }
  Punct { ch: ':', spacing: Joint, span: #0 bytes(10998..10999) }
  Punct { ch: ':', spacing: Alone, span: #0 bytes(10999..11000) }
  Ident { ident: "PI", span: #0 bytes(11000..11002) }
<span class="boring">}</span></code></pre></pre>
<p>由于输入流涉及到的底层特性式的这段宏在实现时必须要能够解析所传入的参数。比如，宏中分隔那些需要分隔的参数需要使用<code>TokenTree:Punct</code>。<a href="https://docs.rs/syn/latest/syn/">syn 包</a>（David Tolnay开发）提供了一个解析的库来辅助这些事情，下一节会进行介绍。</p>
<p>正因为这些解析的工作，使用声明宏往往比函数式的过程宏要简单，因为声明宏所处理的是匹配所定义的结构。</p>
<p>这种需要手动处理繁杂的另一面是函数是的宏可以更加灵活的接受那些无法像一般 Rust 代码解析的输入。这种特性并非经常需要的，所以函数式的宏相对较少出现。</p>
<h3 id="chapter_5-item28-use-macros-judiciously-类属性宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-类属性宏">类属性宏</a></h3>
<p>类属性宏通过将其放置在程序的一些片段前调用的，而这些片段的解析符号会被传入到宏的内部进行处理。类属性宏也可以将任意的结果作为返回值，但是一般返回值是对输出的一些转换处理。</p>
<p>比如，下面是一个用来封装函数体的类属性宏：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[log_invocation]
fn add_three(x: u32) -&gt; u32 {
    x + 3
}
<span class="boring">}</span></code></pre></pre>
<p>之后，在调用这个被封装的函数时，就会有日志输出：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let y = add_three(x);
println!("add_three({x}) = {y}");
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>log: calling function 'add_three'
log: called function 'add_three' =&gt; 5
add_three(2) = 5
<span class="boring">}</span></code></pre></pre>
<p>这个宏的实现是极为复杂的，这里并不打算将其细节附上。在实现时，需要校验输入符号的结构以便构建新的输出符号。当然，这一过程仍然可以使用<code>syn</code>包来辅助实现。</p>
<h3 id="chapter_5-item28-use-macros-judiciously-派生宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-派生宏">派生宏</a></h3>
<p>最后一种过程宏是派生宏。派生宏可以为其修饰的数据（struct, enum 或者 union 均可）自动地生成代码。这一点和类属性宏有些像，但是会多一些派生的操作 —— 请注意理解这里的派生概念。</p>
<p>首先，派生宏会附加到输入的符号中，而非将其替换。这就意味着原始的数据结构的定义会被保留，而派生宏将在原始数据结构的基础上附加代码。</p>
<p>其次，派生宏可以用来声明一些辅助性的特征。当数据需要用作一些特殊的处理时，可以使用派生宏来辅助标注。比如，[serde 库]的<a href="https://docs.rs/serde/latest/serde/derive.Deserialize.html">Deserialize</a>派生宏有一个<code>serde</code>的辅助特性，用户可以使用派生宏来声明这些结构体符合某种特性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_value() -&gt; String {
    "unknown".to_string()
}

#[derive(Debug, Deserialize)]
struct MyData {
    // If `value` is missing when deserializing, invoke
    // `generate_value()` to populate the field instead.
    #[serde(default = "generate_value")]
    value: String,
}
<span class="boring">}</span></code></pre></pre>
<p>关于派生宏的最后一个概念是，<a href="https://docs.rs/syn/latest/syn/">syn 包</a>可以完成将输入符号解析到相应的语法树的工作。<a href="https://docs.rs/syn/latest/syn/macro.parse_macro_input.html">syn::parse_macro_input!</a>宏可以将符号转换成<a href="https://docs.rs/syn/latest/syn/struct.DeriveInput.html">syn::DeriveInput</a>数据结构，这种结构描述被修饰对象的主要内容，并且<code>DeriveInput</code>操作起来远比原始的符号流要好处理。</p>
<p>特别地，<code>derive</code>宏是所有过程宏中最常使用的宏 —— 这种逐字段或逐变量操作的能力能够让程序员最简单地实现最多的功能 —— 比如，仅通过添加一行类似<code>#[derive(Debug, Clone, PartialEq, Eq)]</code>的代码，即可实现预期的目的。</p>
<p>由于派生宏的代码插入是自动实现地，这也意味着这些插入的代码可以同时和结构体的实现保持一致。比如，如果你向<code>struct</code>中插入了一个新的字段，如果采用手动实现<code>Debug</code>特征的话，你就需要在插入后对结构体进行更新以使其满足特征的需求。而对于自动插入代码的派生宏来说，你并不需要做任何调整（当然了，如果插入的字段不满足派生宏的实现要求，编译时会报错）。</p>
<h2 id="chapter_5-item28-use-macros-judiciously-什么时候使用宏"><a class="header" href="#chapter_5-item28-use-macros-judiciously-什么时候使用宏">什么时候使用宏</a></h2>
<p>使用宏的首要原因当然是避免重复的代码 —— 尤其是那些需要人工确保和其他代码关联正确性的重复代码。从这一点来说，使用宏仅是编程常用的封装抽象的扩展：</p>
<ul>
<li>如果需要重复一段处理同一类型的不同值的代码，将其封装为一个函数并在所有需要这段逻辑的地方使用它。</li>
<li>如果需要重复一段处理不同类型的代码，构建一个<code>trait</code>并且使用该<code>trait</code>来封装逻辑并在所有满足该特性的要求的地方进行使用。</li>
<li>如果需要重复一段结构相同的代码，将其封装成一个宏并且在所有满足类似结构的代码中进行使用。</li>
</ul>
<p>举例如下：如果希望规避重复处理不同<code>enum</code>的代码，使用宏即可：</p>
<pre><pre class="playground"><code class="language-rust">enum Multi {
    Byte(u8),
    Int(i32),
    Str(String),
}

/// Extract copies of all the values of a specific enum variant.
#[macro_export]
macro_rules! values_of_type {
    { $values:expr, $variant:ident } =&gt; {
        {
            let mut result = Vec::new();
            for val in $values {
                if let Multi::$variant(v) = val {
                    result.push(v.clone());
                }
            }
            result
        }
    }
}

fn main() {
    let values = vec![
        Multi::Byte(1),
        Multi::Int(1000),
        Multi::Str("a string".to_string()),
        Multi::Byte(2),
    ];

    let ints = values_of_type!(&amp;values, Int);
    println!("Integer values: {ints:?}");

    let bytes = values_of_type!(&amp;values, Byte);
    println!("Byte values: {bytes:?}");

    // Output:
    //   Integer values: [1000]
    //   Byte values: [1, 2]
}</code></pre></pre>
<p>另一个宏的使用场景是，规避同一结构体中的数据被分散在代码的不同区域。</p>
<p>比如，假设一个结构体封装了 HTTP 的状态码。通过宏可以避免实现这些信息时代码的分散：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// http.rs module

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Group {
    Informational, // 1xx
    Successful,    // 2xx
    Redirection,   // 3xx
    ClientError,   // 4xx
    ServerError,   // 5xx
}

// Information about HTTP response codes.
http_codes! {
    Continue           =&gt; (100, Informational, "Continue"),
    SwitchingProtocols =&gt; (101, Informational, "Switching Protocols"),
    // ...
    Ok                 =&gt; (200, Successful, "Ok"),
    Created            =&gt; (201, Successful, "Created"),
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>通过使用宏，可以将每个 HTTP 状态码的所有相关联的信息 —— 数值、元组以及描述信息 —— 都聚集起来，看起来就像是使用一种领域特定语言（domain-specifix language, DSL）来保存数据一样。</p>
<p>汇聚之后，宏就可以生成代码。每一行类似<code>$( ... )+</code>中的代码都会被扩展成特定的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! http_codes {
    { $( $name:ident =&gt; ($val:literal, $group:ident, $text:literal), )+ } =&gt; {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(i32)]
        enum Status {
            $( $name = $val, )+
        }
        impl Status {
            fn group(&amp;self) -&gt; Group {
                match self {
                    $( Self::$name =&gt; Group::$group, )+
                }
            }
            fn text(&amp;self) -&gt; &amp;'static str {
                match self {
                    $( Self::$name =&gt; $text, )+
                }
            }
        }
        impl core::convert::TryFrom&lt;i32&gt; for Status {
            type Error = ();
            fn try_from(v: i32) -&gt; Result&lt;Self, Self::Error&gt; {
                match v {
                    $( $val =&gt; Ok(Self::$name), )+
                    _ =&gt; Err(())
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这样处理后，宏就可以依据输入的参数来派生如下的代码：</p>
<ul>
<li>一个<code>enum</code>枚举用来保存所有的数值。</li>
<li>一个<code>group()</code>方法来返回一个 HTTP 状态码的分组归属。</li>
<li>一个<code>text()</code>方法来将状态码映射到对应的文字描述中。</li>
<li>一个<code>TryFrom&lt;i32&gt;</code>的特征实现来将数值转换成<code>enum</code>中的枚举值。</li>
</ul>
<p>如果需要新增一个状态码，只需要添加这样的一行代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ImATeapot =&gt; (418, ClientError, "I'm a teapot"),
<span class="boring">}</span></code></pre></pre>
<p>如果不使用宏的话，就需要对四部分代码分别更新。编译器可能会有一些提示信息（<code>match</code>表达式需要覆盖所有的场景），但是存在一些遗漏 —— <code>TryFrom&lt;i32</code> 就很容易被遗忘。</p>
<p>由于宏可以在调用的地方对代码进行展开，所有它们也可以用来自动生成一些提示信息 —— 尤其是，在使用了标准库中的<a href="https://doc.rust-lang.org/std/macro.file.html">file!()</a>以及<a href="https://doc.rust-lang.org/std/macro.line.html">line!()</a>宏了之后，可以生成代码的位置信息：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! log_failure {
    { $e:expr } =&gt; {
        {
            let result = $e;
            if let Err(err) = &amp;result {
                eprintln!("{}:{}: operation '{}' failed: {:?}",
                          file!(),
                          line!(),
                          stringify!($e),
                          err);
            }
            result
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当报错出现时，日志文件中就会自动地包含报错内容、位置等细节：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;

let x: Result&lt;u8, _&gt; = log_failure!(512.try_into()); // too big for `u8`
let y = log_failure!(std::str::from_utf8(b"\xc3\x28")); // invalid UTF-8
<span class="boring">}</span></code></pre></pre>
<h2 id="chapter_5-item28-use-macros-judiciously-宏的缺点"><a class="header" href="#chapter_5-item28-use-macros-judiciously-宏的缺点">宏的缺点</a></h2>
<p>使用宏的最大缺点是引入之后代码的可读性及可维护性。之前在声明宏小结中介绍了宏允许我们创建一个特定的语言来简明地描述代码及数据的关键特性。但是，这也意味着任何阅读这段代码的人将不得不理解这段使用 Rust 实现的特定的语句 —— 而且这还是使用宏来定义的。比如，在<code>http_codes!</code>宏的示例中使用了一个名为<code>Status</code>的 Rust <code>enum</code>，但是在使用的时候并不能察觉到。</p>
<p>这种使用宏而引入的不可知性远超一般程序员所能带来的影响：很多分析或和 Rust 交互的工具无法理解这样晦涩的代码，因为它不在遵循 Rust 代码交互语法。先前展示的<code>square_once!</code>宏就是一个直观的例子：宏的主体并没有按照<code>rustfmt</code>的规则来格式化：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = $e;
    // The `rustfmt` tool doesn't really cope with code in
    // macros, so this has not been reformatted to `x * x`.
    x*x
}
<span class="boring">}</span></code></pre></pre>
<p>另一个例子是已经提到的<code>http_codes!</code>宏，这里使用了<code>Group</code>枚举了诸如<code>Informational</code>的值，而没有使用<code>Group::</code>前缀或<code>use</code>语句。这一点会让代码的补全工具感到混淆。</p>
<p>甚至编译器本身也无法提供更多的帮助：编译器提供的报错信息没有完全符合宏的定义及使用。当然，还是有一些工具（参照<a href="https://www.lurklurk.org/effective-rust/use-tools.html">第 31 条</a>）可以辅助宏的使用，比如早先使用的 David Tolnay 的 <a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a>。</p>
<p>使用宏也可能会导致代码的膨胀 —— 一个简单的宏调用就可能引入数百行的生成代码，并且在进行代码分析时是无法直观看到的。这在代码第一次编写时可能不会成为问题，因为彼时这些代码是需要的，并且帮助开发者节约了大量的代码编写时间。但是，如果这些代码随后不再需要了，考虑实际生成的数百行代码，仅从数行的宏调用中可能并不能看到将其删除的必要性。</p>
<h2 id="chapter_5-item28-use-macros-judiciously-建议"><a class="header" href="#chapter_5-item28-use-macros-judiciously-建议">建议</a></h2>
<p>尽管上节我们列举了很多宏的缺点，但是当我们需要合并存在一些存在一致性的代码，但是没有其他可用的方式时，使用宏仍然是完成这样工作的正确工具：<em>当宏是确保不同代码保持一致的唯一方式时，使用它！</em></p>
<p>当我们需要合并一些模版化的代码时，宏也是可以使用的工具：<em>使用宏来处理模版代码</em>，当它们无法合并为一个函数或者一个特性时。</p>
<p>为了降低宏对可读性的影响，请尽量避免在宏中使用和 Rust 的一般语法规则相冲突的语法。要么让宏在调用时和一般的代码表现的一致；要么让宏在调用时和一般的代码完全不同，这样就没有用户会混淆宏和一般的代码。特别地，可以遵循如下的准则：</p>
<ul>
<li><em>尽可能的避免向宏传递参数的引用</em> —— 类似<code>my_macro!(list)</code>的使用就比<code>my_macro!(&amp;list)</code>要好。</li>
<li><em>尽量避免在宏中引入非局部的控制流</em>，这样所有阅读这段代码的人都可以在不了解宏的细节的情况下，正确理解上下文中的控制流。</li>
</ul>
<p>这种倾向于类似 Rust 一般代码的可读性偏好有时会影响声明宏或者过程式宏的选择。如果你需要给一个<code>struct</code>的每一个字段或者<code>enum</code>中的每一个枚举值都生成代码，<em>尽量使用派生宏来处理</em>（暂时忽略在上一节中列举的问题） —— 这样会更加符合语言习惯并且读起来更加简单。</p>
<p>然而，如果要添加的派生宏并非是项目中所独有的功能，可以检查下外部的库中是否已经提供了所需要的宏（参照<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）。比如，类似将数值类型转换为合适的 C 风格的枚举值的需求：在<a href="https://docs.rs/enumn/latest/enumn/derive.N.html">enumn::N</a>、[num_enum::TryFromPrimitive]、<a href="https://docs.rs/num-derive/latest/num_derive/derive.FromPrimitive.html">num_derive::FromPrimitive</a>以及<a href="https://docs.rs/strum/latest/strum/derive.FromRepr.html">strum::FromRepr</a>中都一定程度的实现了这个需求。</p>
<hr />
<h3 id="chapter_5-item28-use-macros-judiciously-注释"><a class="header" href="#chapter_5-item28-use-macros-judiciously-注释">注释</a></h3>
<div class="footnote-definition" id="chapter_5-item28-use-macros-judiciously-1"><sup class="footnote-definition-label">1</sup>
<p>眼神儿好的读者可能已经注意到了<code>format_arg!</code>仍然像是一个宏的调用，尽管它在<code>println!</code>宏的展开代码里。这是因为它是编译器的内建宏。</p>
</div>
<div class="footnote-definition" id="chapter_5-item28-use-macros-judiciously-2"><sup class="footnote-definition-label">2</sup>
<p>在<a href="https://doc.rust-lang.org/std/fmt/index.html">std::fmt 模块</a>中也包含了很多其他展示特定格式数据是会使用的特性。比如，当需要一个 x 格式的特殊说明符来输出小写的十六进制输出时，就会使用<a href="https://doc.rust-lang.org/std/fmt/trait.LowerHex.html">LowerHex</a>特性。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/macros.html">点这里</a>查看。</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_5-item29-listen-to-clippy"></div><h1 id="chapter_5-item29-listen-to-clippy-第-29-条遵循-clippy-的建议"><a class="header" href="#chapter_5-item29-listen-to-clippy-第-29-条遵循-clippy-的建议">第 29 条：遵循 Clippy 的建议</a></h1>
<blockquote>
<p>“看起来你在写信。需要什么帮助么？” —— [Microsoft Clippit]</p>
</blockquote>
<p><a href="https://www.lurklurk.org/effective-rust/use-tools.html">第 31 条</a>会描述了 Rust 工具箱中一些很有用的工具。但是其中一个特别有用且重要的工具值的在这里进行进行单独的介绍：<a href="https://github.com/rust-lang/rust-clippy#clippy">Clippy</a>。</p>
<p>Clippy 是 Cargo 的一个附加模块（通过<code>cargo clippy</code>的方式调用）。它可以生成涵盖多种类别的<code>warining</code>信息：</p>
<ul>
<li>正确性：提示常见的编程错误。</li>
<li>风格：提示不完全符合 Rust 标准风格的代码结构。</li>
<li>简洁性：指出能让代码更加简洁的可行变更。</li>
<li>性能：提示能避免无效处理或者内存分配的可选项。</li>
<li>可读性：给出能让代码更易读或者更易懂的建议。</li>
</ul>
<p>比如，如下这段代码编译是正常的：</p>
<div class="ferris"><img src="chapter_5/../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn circle_area(radius: f64) -&gt; f64 {
    let pi = 3.14;
    pi * radius * radius
}
<span class="boring">}</span></code></pre></pre>
<p>但是 Clippy 会指出这里对 π 的近似赋值是没必要且不准确的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:5:18
  |
5 |         let pi = 3.14;
  |                  ^^^^
  |
  = help: consider using the constant directly
  = help: for further information visit
    https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
  = note: `#[deny(clippy::approx_constant)]` on by default
<span class="boring">}</span></code></pre></pre>
<p>链接中的文档解释了问题并且给出了优化代码的方式。上述示例可调整为：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn circle_area(radius: f64) -&gt; f64 {
    std::f64::consts::PI * radius * radius
}
<span class="boring">}</span></code></pre></pre>
<p>正如示例中所展示的，每个 Clippy 警告都会伴随着一个网页的链接来描述问题。链接的网页中会说明为什么目标代码会被认为是不恰当的。这些说明很重要：它们的存在使得你可以自行判断采纳这些建议或者由于特殊的原因而忽略它们。有的时候，说明文本中还会描述一些校验器的已知问题，这些描述会解释一些令人困惑的误报。</p>
<p>如果你认定一些警告信息和自己的代码没有关系，你可以通过添加(#[allow(clippy::some_line)])来忽略关联代码的报错，或者在包的顶层（top level）添加(#![allow(clipy::some_lint)])来忽略整个包中的警告信息。通常情况下，建议调整目标代码而非花费很多时间来确认警告关联的代码是否是一个罕见的误报。</p>
<p>无论你选择了修复或者忽略掉这些警告信息，请<strong>确保你的代码中没有 Clippy-warning 的信息</strong>。</p>
<p>这样，当新的警告信息出现时 —— 无论是由于代码发生了调整还是 Clippy 升级后包含了新的校验信息 —— 我们就能够及时的关注到。Clippy 也应当被纳入你的持续集成系统中（<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>）。</p>
<p>Clippy 的警告信息在你学习 Rust 时特别重要，因为它们可以揭示那些被你忽略的细节，并帮助你熟悉 Rust 的风格。</p>
<p>本书中提到的很多建议，在 Clippy 中均存在相关的警告信息：</p>
<ul>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item1-use-types.html">第 1 条</a>建议使用更具表现力的类型，而非一般的<code>bool</code>类型。Clippy 也指出了在<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/fn_params_excessive_bools">函数参数</a>以及<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/struct_excessive_bools">结构体</a>中使用多个<code>bool</code>类型的问题。</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item3-transform.html">第 3 条</a>包括了一些<code>Option</code>及<code>Result</code>类型的操作。Clippy 指出了一些可行的精简行为，比如：
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/ok_expect">Unnecessarily converting <code>Result</code> to <code>Option</code></a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/unwrap_or_else_default">Opportunities to use <code>unwrap_or_default</code></a>。</li>
</ul>
</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item3-transform.html">第 3 条</a>同样建议了应当将错误返回给调用方。Clippy [指出了应当返回的地方]。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/from_over_into">第 5 条</a>应当实现<code>From</code>特征而非<code>Into</code>。</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item5-casts.html">第 5 条</a>还描述了一些强制转换，而 Clippy 给出了如下的警告（对应的检查项默认是关掉的）：
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/cast_lossless"><code>as</code> casts that could be from instead</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/cast_possible_truncation"><code>as</code> casts that might truncate</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/cast_possible_wrap"><code>as</code> casts that might wrap</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/cast_precision_loss"><code>as</code> casts that lose precision</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/cast_sign_loss"><code>as</code> casts that might convert signed negative numbers to large positive numbers</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/as_conversions">any use of <code>as</code></a>。</li>
</ul>
</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item8-references&amp;pointer.html">第 8 条</a>描述了胖指针类型，并且很多 Clippy 的校验器指出了一些非必要的额外的指针间接访问：
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/box_collection">Holding a heap-allocated collection in a <code>Box</code></a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/vec_box">Holding a heap-allocated collection of <code>Box</code> items</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/borrowed_box">Taking a reference to a <code>Box</code></a>。</li>
</ul>
</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_1/item9-iterators.html">第 9 条</a>描述了操作<code>Iterator</code>实例的诸多方法。Clippy 包含了诸多的可以简化迭代器方法使用的校验器<sup class="footnote-reference"><a href="#chapter_5-item29-listen-to-clippy-1">1</a></sup>。</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_2/item10-std-traits.html">第 10 条</a>描述了 Rust 的标准特性，并且包含了很多 Clippy 会校验到的实现时的要求：
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/derive_ord_xor_partial_ord"><code>Ord</code> must agree with <code>PartialOrd</code></a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/partialeq_ne_impl"><code>PartialEq::ne</code> should not need a nondefault implementation</a>（参照 <a href="https://rustx-labs.github.io/effective-rust-cn/chapter_2/item13-use-default-impl.html">第 13 条</a>）。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/derived_hash_with_manual_eq"><code>Hash</code> and <code>Eq</code> must be consistent</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/expl_impl_clone_on_copy"><code>Clone</code> for <code>Copy</code> types should match</a>。</li>
</ul>
</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_3/item18-panic.html">第 18 条</a>提供了一些关于减少<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/panic"><code>panic!</code></a>或类似<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/expect_used"><code>expect</code></a>的方法，这些建议也会在 Clippy 的校验器中检查到。</li>
<li><a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a>表述了引入通过通配符限定的包是不明智的。Clippy 同样对此<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/wildcard_dependencies">进行了校验</a>。</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_4/item23-wildcard.html">第 23 条</a>及<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>涉及到一种不同版本的包出现在同一个项目的依赖中。Clippy 可以通过配置，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/multiple_crate_versions">在问题出现时给出警告信息</a>。</li>
<li><a href="https://www.lurklurk.org/effective-rust/features.html">第 26 条</a>叙述了 Cargo 特性的一些相加性，而 Clippy 会将与此原则相违背特性提示为<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/negative_feature_names">“否定”的特性</a>。</li>
<li><a href="https://www.lurklurk.org/effective-rust/features.html">第 26 条</a>同样表述了一个包的可选依赖项同样是其特征集的一部分。如果存在<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/redundant_feature_names">需要明确的特性名（如："use-crate-x"形式的命名）</a>时，Clippy 将会提示直接应当使用明确的特性名，而非模糊的。</li>
<li><a href="https://rustx-labs.github.io/effective-rust-cn/chapter_5/item27-document-public-interfaces.html">第 27 条</a>描述了文档注释的约束，Clippy 同时有如下的提示：
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/missing_panics_doc">Missing descriptions of <code>panic!</code>s</a>。</li>
<li><a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/missing_safety_doc">Missing descriptions</a> of <a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/undocumented_unsafe_blocks"><code>unsafe</code> concerns</a>。</li>
</ul>
</li>
</ul>
<p>上述的信息无疑说明了<strong>阅读 <a href="https://rust-lang.github.io/rust-clippy/stable/index.html">Clippy 的警告信息</a>列表</strong>同样是一种有意义的学习方式 —— 包括那些默认被关掉校验的原因，是由于它们太严苛了还是由于它们会产生虚警？尽管你可能并不希望代码中出现这么多的警告信息，领悟这些校验规则出现的原因将会提升你对 Rust 及其风格的理解。</p>
<h3 id="chapter_5-item29-listen-to-clippy-注释"><a class="header" href="#chapter_5-item29-listen-to-clippy-注释">注释</a></h3>
<div class="footnote-definition" id="chapter_5-item29-listen-to-clippy-1"><sup class="footnote-definition-label">1</sup>
<p>部分校验器列举如下。<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/explicit_counter_loop">explicit_counter_loop</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/explicit_iter_loop">explicit_iter_loop</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/explicit_into_iter_loop">explicit_into_iter_loop</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/filter_map_identity">filter_map_identity</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/from_iter_instead_of_collect">from_iter_instead_of_collect</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/into_iter_on_ref">into_iter_on_ref</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/iter_count">iter_count</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/iter_next_loop">iter_next_loop</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/iter_not_returning_iterator">iter_not_returning_iterator</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/manual_filter_map">manual_filter_map</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/manual_find_map">manual_find_map</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/map_clone">map_clone</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/needless_range_loop">needless_range_loop</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/search_is_some">search_is_some</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/skip_while_next">skip_while_next</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/suspicious_map">suspicious_map</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/unnecessary_filter_map">unnecessary_filter_map</a>，<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/unnecessary_fold">unnecessary_fold</a>。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/clippy.html">点这里</a>查看</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_5-item31-use-tools"></div><h1 id="chapter_5-item31-use-tools-第-31-条使用生态系统工具"><a class="header" href="#chapter_5-item31-use-tools-第-31-条使用生态系统工具">第 31 条：使用生态系统工具</a></h1>
<p>Rust 生态系统拥有丰富的附加工具集，它们提供了超出将 Rust 转换为机器代码基本任务的功能。</p>
<p>在设置Rust开发环境时，您可能希望拥有以下基本工具的大多数：<sup class="footnote-reference"><a href="#chapter_5-item31-use-tools-1">1</a></sup></p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/">cargo</a> 工具，用于组织依赖项（<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）并驱动编译器</li>
<li><a href="https://github.com/rust-lang/rustup">rustup</a> 工具，用于管理安装的 Rust 工具链</li>
<li>支持 Rust 的 IDE，或像 <a href="https://github.com/rust-lang/rust-analyzer">rust-analyzer</a> 这样的 IDE/编辑器插件，它允许您快速在 Rust 代码库中导航，并为编写 Rust 代码提供自动补全支持</li>
<li><a href="https://play.rust-lang.org/">Rust playground</a>，用于独立探索 Rust 的语法，并与同事分享结果</li>
<li><a href="https://doc.rust-lang.org/std/">Rust 标准库</a>的文档</li>
</ul>
<p>除了这些基本工具，Rust 还包括许多帮助维护代码库和提高代码库质量的工具。官方 Cargo 工具链中包含的工具涵盖了除 <code>cargo build</code>、<code>cargo test</code> 和 <code>cargo run</code> 基本操作之外的各种基本任务，例如：</p>
<ul>
<li><code>cargo fmt</code>：根据标准约定重新格式化 Rust 代码。</li>
<li><code>cargo check</code>：执行编译检查而不生成机器代码，这有助于快速进行语法检查。</li>
<li><code>cargo clippy</code>：执行代码嗅探检查，检测低效或不地道的代码（<a href="#chapter_5-item29-listen-to-clippy">第 29 条</a>）。</li>
<li><code>cargo doc</code>：生成文档（<a href="#chapter_5-item27-document-public-interfaces">第 27 条</a>）。</li>
<li><code>cargo bench</code>：运行基准测试（<a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>）。</li>
<li><code>cargo update</code>：升级依赖项到最新版本，默认选择符合语义版本控制（<a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a>）的版本。</li>
<li><code>cargo tree</code>：显示依赖关系图（<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>）。</li>
<li><code>cargo metadata</code>：输出工作空间中存在的包及其依赖项的元数据。</li>
</ul>
<p>最后提到的这个工具特别有用，尽管它是间接的：因为有一个工具以明确定义的格式输出关于 <code>crates</code> 的信息，人们更容易生产出其他使用这些信息的工具（通常通过 <code>cargo_metadata crate</code>，它提供了一套 Rust 类型来持有元数据信息）。</p>
<p><a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>描述了一些由这种元数据可用性启用的工具，例如 <code>cargo-udeps</code>（允许检测未使用的依赖项）或 <code>cargo-deny</code>（允许检查许多事情，包括重复的依赖项、允许的许可证和安全建议）。</p>
<p>Rust 工具链的可扩展性不仅限于包元数据；编译器的抽象语法树也可以构建，通常通过 <code>syn crate</code>。这些信息使得过程宏（<a href="#chapter_5-item28-use-macros-judiciously">第 28 条</a>）变得强大，但也为各种其他工具提供了支持：</p>
<ul>
<li><code>cargo-expand</code>：显示宏扩展产生的完整源代码，这对于调试复杂的宏定义至关重要。</li>
<li><code>cargo-tarpaulin</code>：支持生成和跟踪代码覆盖率信息。</li>
</ul>
<p>任何特定工具的列表总是主观的、过时的和不完整的；更一般的观点是探索可用的工具。</p>
<p>例如，搜索 <code>cargo-&lt;something&gt;</code> 工具会得到数十个结果；其中一些可能不合适，一些可能已被放弃，但有些可能正好符合您的需求。</p>
<p>还有各种努力将形式验证应用于 Rust 代码，如果您的代码需要对其正确性有更高层次的保证，这可能会有帮助。</p>
<p>最后，提醒一下：如果一个工具不仅仅是一次性使用，您应该将该工具集成到您的 CI 系统（如<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>所述）。如果该工具快速且没有误报，将其集成到您的编辑器或 IDE 中也是合理的；<code>Rust Tools</code> 页面提供了相关文档的链接。</p>
<h3 id="chapter_5-item31-use-tools-需要记住的工具"><a class="header" href="#chapter_5-item31-use-tools-需要记住的工具">需要记住的工具</a></h3>
<p>除了应该定期和自动运行在您的代码库上的工具（<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>），书中其他地方还提到了各种其他工具。为了参考，这里将它们汇集在一起——但请记住，还有更多的工具存在：</p>
<ul>
<li><a href="#chapter_3-item16-unsafe">第 16 条</a>建议在编写微妙的 <code>unsafe</code> 代码时使用 <code>Miri</code>。</li>
<li><a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a>和<a href="https://www.lurklurk.org/effective-rust/dep-graph.html">第 25 条</a>提到了 <code>Dependabot</code>，用于管理依赖项更新。</li>
<li><a href="https://www.lurklurk.org/effective-rust/semver.html">第 21 条</a>还提到了 <code>cargo-semver-checks</code> 作为检查语义版本控制是否正确完成的可能选项。</li>
<li><a href="#chapter_5-item28-use-macros-judiciously">第 28 条</a>解释了 <code>cargo-expand</code> 在调试宏问题时可以提供帮助。</li>
<li><a href="#chapter_5-item29-listen-to-clippy">第 29 条</a>完全致力于使用 <code>Clippy</code>。</li>
<li><code>Godbolt</code> 编译器探索器允许您探索与您的源代码对应的机器代码，如<a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>所述。</li>
<li><a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>还提到了其他测试工具，例如用于模糊测试的 <code>cargo-fuzz</code> 和用于基准测试的 <code>criterion</code>。</li>
<li><a href="#chapter_5-item31-use-tools">第 35 条</a>涵盖了使用 <code>bindgen</code> 从 <code>C</code> 代码自动生成 <code>Rust FFI</code> 包装器的使用。</li>
</ul>
<h4 id="chapter_5-item31-use-tools-注释"><a class="header" href="#chapter_5-item31-use-tools-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_5-item31-use-tools-1"><sup class="footnote-definition-label">1</sup>
<p>在某些环境中，这个列表可能会减少。例如，在 <code>Android</code> 上进行 <code>Rust</code> 开发有一个集中控制的工具链（所以没有 <code>rustup</code>），并与 <code>Android</code> 的 <code>Soong</code> 构建系统集成（所以没有 <code>cargo</code>）。</p>
</div>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_6"></div><h1 id="chapter_6-超越标准rust"><a class="header" href="#chapter_6-超越标准rust">超越标准Rust</a></h1>
<p><code>Rust</code> 工具链支持的环境范围远比仅仅运行在用户空间的纯 <code>Rust</code> 应用程序代码要广泛：</p>
<ul>
<li>它支持跨平台编译，其中运行工具链的系统（宿主）与编译后的代码将运行的系统（目标）不同，这使得针对嵌入式系统变得简单。</li>
<li>它支持与用非 <code>Rust</code> 语言编译的代码链接，通过内置的 <code>FFI</code> 功能。</li>
<li>它支持没有完整标准库 <code>std</code> 的配置，允许针对没有完整操作系统的系统（例如，没有文件系统，没有网络）。</li>
<li>它甚至支持不支持堆分配而只有栈的配置（通过省略标准 <code>alloc</code> 库的使用）。</li>
</ul>
<p>这些非标准 <code>Rust</code> 环境可能更难工作，可能不那么安全——它们甚至可能不安全——但它们为完成工作提供了更多选项。</p>
<p>本书的这一章仅讨论了在这些环境中工作的基础知识。除了这些基础知识之外，您还需要查阅更多特定环境的文档（例如 <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>）。</p>
<!-- 参考链接 -->
<div style="break-before: page; page-break-before: always;"></div><div id="chapter_6-item35-bindgen"></div><h1 id="chapter_6-item35-bindgen-第-35-条优先使用bindgen而不是手动ffi映射"><a class="header" href="#chapter_6-item35-bindgen-第-35-条优先使用bindgen而不是手动ffi映射">第 35 条：优先使用bindgen而不是手动FFI映射</a></h1>
<p><a href="#chapter_6-%5Bitem5-casts.md%5D(https:-www.lurklurk.org-effective-rust-ffi">第 34 条</a>讨论了从 Rust 程序调用 C 代码的机制，描述了 C 结构和函数的声明需要有一个等效的 Rust 声明，以允许它们通过 FFI 使用。C 和 Rust 的声明需要保持同步，并且<a href="#chapter_6-%5Bitem5-casts.md%5D(https:-www.lurklurk.org-effective-rust-ffi">第 34 条</a>还警告说工具链不会帮助解决这个问题 —— 不匹配将会被默默忽略，隐藏以后会出现的问题。</p>
<p>让两件事情完全同步听起来像是自动化的好目标，Rust 项目为此提供了正确的工具：bindgen。bindgen 的主要功能是解析 C 头文件并生成相应的 Rust 声明。
以<a href="#chapter_6-%5Bitem5-casts.md%5D(https:-www.lurklurk.org-effective-rust-ffi">第 34 条</a>中的一些 C 声明为例：</p>
<pre><code class="language-c">/* File lib.h */
#include &lt;stdint.h&gt;

typedef struct {
    uint8_t byte;
    uint32_t integer;
} FfiStruct;

int add(int x, int y);
uint32_t add32(uint32_t x, uint32_t y);
</code></pre>
<p><code>bindgen</code> 工具可以手动调用（或通过 <code>build.rs</code> <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">构建脚本</a>调用）以创建相应的 Rust 文件：</p>
<pre><code class="language-bash">% bindgen --no-layout-tests \
          --allowlist-function="add.*" \
          --allowlist-type=FfiStruct \
          -o src/generated.rs \
          lib.h
</code></pre>
<p>生成的 Rust 代码与<a href="#chapter_6-%5Bitem5-casts.md%5D(https:-www.lurklurk.org-effective-rust-ffi">第 34 条</a>中手工编写的声明是完全相同的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfiStruct {
    pub byte: u8,
    pub integer: u32,
}
extern "C" {
    pub fn add(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -&gt; ::std::os::raw::c_int;
}
extern "C" {
    pub fn add32(x: u32, y: u32) -&gt; u32;
}
<span class="boring">}</span></code></pre></pre>
<p>并且可以通过源码级别的 <a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code> 宏</a>引入到 Rust 代码中：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Include the auto-generated Rust declarations.
include!("generated.rs");
<span class="boring">}</span></code></pre></pre>
<p>对于任何非最简单的 FFI 声明，请使用 bindgen 为 C 代码生成 Rust 绑定 —— 在这个领域，机器制作的大规模生产代码绝对优于手工精制的声明。如果 C 函数定义发生变化，C 编译器会在 C 声明不再与 C 定义匹配时发出抱怨，但不会有东西抱怨手工编写的 Rust 声明不再与 C 声明匹配；从 C 声明自动生成 Rust 声明可以确保两者保持同步。</p>
<p>这也意味着 bindgen 步骤是理想的候选者，可以包含在 CI 系统（<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>）中；如果生成的代码包含在源码控制中，CI 系统可以在新生成的文件与检入的版本不匹配时报错。</p>
<p>当您处理具有大量 API 的现有 C 代码库时，bindgen 工具才能真正发挥其作用。为一个庞大的 <code>lib_api.h</code> 头文件创建 Rust 等价物是手动且乏味的，因此容易出错 —— 并且如前所述，许多不匹配错误的类别不会被工具链检测到。bindgen 还拥有一系列选项，允许针对 API 的特定子集（比如，之前展示的 -- <code>allowlist-function</code> 和 <code>--allowlist-type</code> 选项）。<sup class="footnote-reference"><a href="#chapter_6-item35-bindgen-1">1</a></sup></p>
<p>这也允许采用分层方法在 Rust 中暴露现有的 C 库；包装某个 xyzzy 库的一个常见约定是拥有以下内容：</p>
<ul>
<li>一个仅包含 bindgen 生成的代码的 <code>xyzzy-sys crate</code> —— 其使用必然是不安全的。</li>
<li>一个 <code>xyzzy crate</code>，它封装了不安全代码，并提供对底层功能的安全 Rust 访问。</li>
</ul>
<p>这将在一个层中集中不安全代码，并允许程序的其他部分遵循<a href="#chapter_3-item16-unsafe">第 16 条</a>的建议。</p>
<h3 id="chapter_6-item35-bindgen-超越c语言"><a class="header" href="#chapter_6-item35-bindgen-超越c语言">超越C语言</a></h3>
<p><code>bindgen</code> 工具能够处理一些 <code>C++</code> 结构，但只是有限的一部分，并且方式有限。为了更好的（尽管仍然有限）集成，可以考虑使用 <code>cxx crate</code> 进行 <code>C++/Rust</code> 交互操作。<code>cxx</code> 不是从 <code>C++</code> 声明生成 <code>Rust</code> 代码，而是采用从公共模式自动生成 <code>Rust</code> 和 <code>C++</code> 代码的方法，允许更紧密的集成。</p>
<h4 id="chapter_6-item35-bindgen-注释"><a class="header" href="#chapter_6-item35-bindgen-注释">注释</a></h4>
<div class="footnote-definition" id="chapter_6-item35-bindgen-1"><sup class="footnote-definition-label">1</sup>
<p>示例还使用了 <code>--no-layout-tests</code> 选项以保持输出简单；默认情况下，生成的代码将包含 <code>#[test]</code> 代码，以检查结构体确实正确布局。</p>
</div>
<!-- 参考链接 -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="style/js/tongji.js"></script>
        <script src="style/js/ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
