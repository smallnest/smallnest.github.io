<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 9 条：考虑使用迭代器转换代替显式循环 - Effective Rust 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="../intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="../intro.html">介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="../chapter_1/item2-use-types-2.html"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="../chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="../chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="../chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="../chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="../chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item9-iterators.html" class="active"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/item10-std-traits.html"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="../chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="../chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="../chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/item14-lifetimes.html"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="../chapter_3/item15-borrows.html"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="../chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="../chapter_3/item17-deadlock.html"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="../chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="../chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="../chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="../chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="../chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-9-条考虑使用迭代器转换代替显式循环"><a class="header" href="#第-9-条考虑使用迭代器转换代替显式循环">第 9 条：考虑使用迭代器转换代替显式循环</a></h1>
<p>编程语言中简陋朴素的循环经历了一段漫长的发展，逐步提高了使用的便利性和抽象性。B 语言（C 语言的前身）当时仅有 <code>while (condition) { ... }</code> 这种结构，但随着 C 语言的到来，<code>for</code> 循环的加入使通过数组下标进行遍历这种高频行为变得越来越方便：</p>
<pre><code class="language-c">// C code
int i;
for (i = 0; i &lt; len; i++) {
  Item item = collection[i];
  // body
}
</code></pre>
<p>C++ 的早期版本通过允许将循环变量的声明嵌入到 <code>for</code> 语句中，进一步提高了便利性（这也被 C 语言的 C99 标准所纳入）：</p>
<pre><code class="language-c++">// C++98 code
for (int i = 0; i &lt; len; i++) {
  Item item = collection[i];
  // ...
}
</code></pre>
<p>大多数现代编程语言把循环的概念做了更进一步的抽象：循环的核心功能通常是移动到某个容器的下一项进行访问。维护访问容器元素所需要的逻辑（<code>index++</code> or <code>++it</code>）通常是无关紧要的细节。基于这种认识，产生了两个核心的概念：</p>
<ul>
<li>迭代器 <code>Iterators</code>：一种类型，它存在的目的是重复地释出容器的下一个元素，直到把容器耗尽<a href="#footnote-1">1</a>。</li>
<li><code>For-each</code> 循环：一种紧凑的循环表达式，用于迭代容器中的所有元素，表达式会将容器元素绑定到循环变量上，而不是提供一些让你访问到元素的细节信息。</li>
</ul>
<p>这些概念允许循环代码变得更简短，（更重要的是）更加清晰地表明意图：</p>
<pre><code class="language-c++">// C++11 code
for (Item&amp; item : collection) {
  // ...
}
</code></pre>
<p>一旦有了这些可行的概念，它们的强大显而易见，因此它们很快地就被移植到了那些本没有这些概念的语言中（例如，for-each 循环在 <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html">Java 1.5</a> 和 C++11 中被引入）。</p>
<p>Rust 包括迭代器和 <code>for-each</code> 风格的循环，但它还包括了更进一步的抽象：允许整个循环体通过迭代器转换 <code>iterator transform</code>（有时候也被称作迭代器适配器 <code>iterator adaptor</code>）来表达。如我们在 <a href="item3-transform.html">第 3 条</a> 中讨论的 <code>Option</code> 和 <code>Reuslt</code> 一样，这条条款会尝试展示如何使用这些迭代器转换来替换显式的循环，并就应该何时使用给出相应的指导。特别要注意的是，迭代器转换或许会比显式的循环更高效，因为编译器可以跳过那些潜在的边界检查。</p>
<p>在看完这条条款后，一个 C 风格的，用于求向量 <code>vector</code> 前五个偶数项的平方和的循环：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values: Vec&lt;u64&gt; = vec![1, 1, 2, 3, 5 /* ... */];

let mut even_sum_squares = 0;
let mut even_count = 0;
for i in 0..values.len() {
    if values[i] % 2 != 0 {
        continue;
    }
    even_sum_squares += values[i] * values[i];
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>应该能被很自然地表达为函数式表达式的样子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let even_sum_squares: u64 = values
    .iter()
    .filter(|x| *x % 2 == 0)
    .take(5)
    .map(|x| x * x)
    .sum();
<span class="boring">}</span></code></pre></pre>
<p>像这样的迭代器转换表达式可以粗略被分解为三个部分：</p>
<ul>
<li>一个源迭代器，来自于一个实现了 Rust 的任意一种 <code>iterator</code> traits 的类型实例；</li>
<li>一个由若干迭代器转换组成的操作序列；</li>
<li>一个最终的消费者方法 <code>consumer method</code> 将迭代的结果合并为最后的值；</li>
</ul>
<p>其中前两部分有效地将循环的内部功能从循环体内移到 <code>for</code> 表达式中，最后一部分则完全消除了对 <code>for</code> 语句的依赖。</p>
<blockquote>
<p>译者注：这里的原文表达的意思有点绕。不熟悉这种编程范式的朋友可以尝试这么理解：<code>for</code> 循环版本代码中的逻辑，通过 <code>filter().take().map()</code> 这一系列调用“表达”了。而 <code>iter()</code> 和 <code>sum()</code> 相当于是这个循环的“启动”和“结束”，对应 <code>for</code> 循环版本中的 <code>for</code> 和 <code>even_sum_squares += ...</code>。于是我们最终摆脱了对 <code>for</code> 这个表达式的使用。</p>
</blockquote>
<h2 id="iterator-traits-迭代器-traits"><a class="header" href="#iterator-traits-迭代器-traits">Iterator Traits 迭代器 Traits</a></h2>
<p>标准库中这个核心的 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> trait 有一个十分简单的接口：一个 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next">next</a> 方法用于生成 <code>Some</code> 元素，直到没法再继续生成（返回 <code>None</code>）。迭代过程中生成元素的类型通过 trait 的关联类型 <code>Item</code> 定义。</p>
<p>那些允许用户对其中元素进行遍历的容器——在其他语言中被称为可迭代对象  <code>iterable</code>）——实现了 <a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html">IntoIterator</a> trait；trait 中定义的 <a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a> 方法会消耗掉 <code>Self</code> 并返回一个 <code>Iterator</code>。编译器会自动对以下形式的表达式自动应用这个 trait：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in collection {
    // body
}
<span class="boring">}</span></code></pre></pre>
<p>并高效地转换成类似如下的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = collection.into_iter();
loop {
    let item: Thing = match iter.next() {
        Some(item) =&gt; item,
        None =&gt; break,
    };
    // body
}
<span class="boring">}</span></code></pre></pre>
<p>或者更简洁惯用的形式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = collection.into_iter();
while let Some(item) = iter.next() {
    // body
}
<span class="boring">}</span></code></pre></pre>
<p>为了让不同场景下的使用更流畅，对于任何的 <code>Iterator</code> 都有实现 <code>IntoIterator</code>，而实现就是返回 <code>self</code>；毕竟要把 <code>Iterator</code> 转成 <code>Iterator</code> 不费吹灰之力！</p>
<p>这种初始形式生成的是一个消耗型迭代器，在创建的时候会把容器消耗掉。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
for item in collection {
    println!("Consumed item {item:?}");
}
<span class="boring">}</span></code></pre></pre>
<p>任何在迭代后完成后对容器进行的操作都会失败：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Collection = {collection:?}");
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: borrow of moved value: `collection`
   --&gt; src/main.rs:171:28
    |
163 |   let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    |       ---------- move occurs because `collection` has type `Vec&lt;Thing&gt;`,
    |                  which does not implement the `Copy` trait
164 |   for item in collection {
    |               ---------- `collection` moved due to this implicit call to
    |                           `.into_iter()`
...
171 |   println!("Collection = {collection:?}");
    |                          ^^^^^^^^^^^^^^ value borrowed here after move
    |
note: `into_iter` takes ownership of the receiver `self`, which moves
      `collection`
</code></pre>
<p>虽然容易理解，但这种消耗整个容器的行为通常不是我们想要的；我们需要对被迭代的元素进行某种<em>借用</em>。</p>
<p>为了确保展示内容的清晰，这里的例子使用了一个<em>没有</em>实现 <code>Copy</code>（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>） 的 <code>Thing</code> 类型，因为 <code>Copy</code> 会掩盖掉所有权（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）的问题——编译器会偷偷四处拷贝：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
// Deliberately not `Copy`
// 特地不实现 `Copy`
#[derive(Clone, Debug, Eq, PartialEq)]
struct Thing(u64);

let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
}</code></pre></pre>
<p>如果被迭代的集合以 <code>&amp;</code> 作为前缀：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for item in &amp;collection {
    println!("{}", item.0);
}
println!("collection still around {collection:?}");
<span class="boring">}</span></code></pre></pre>
<p>那么编译器会寻找 <code>&amp;Collection</code> 类型的 <a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html">IntoIterator</a> 实现。正确设计的集合都会提供这样的一个实现；这个实现仍然会消耗 <code>Self</code>，不过此时 <code>Self</code> 是 <code>&amp;Collection</code> 类型而不是 <code>Collection</code>，并且对应的关联类型 <code>Item</code> 将会是一个引用类型 <code>&amp;Thing</code>。</p>
<p>这使得在迭代之后容器仍然保持完整，等效的扩展代码如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = (&amp;collection).into_iter();
while let Some(item) = iter.next() {
    println!("{}", item.0);
}
<span class="boring">}</span></code></pre></pre>
<p>在可以遍历可变引用的场景下<a href="#footnote-2">1</a>，<code>for item in &amp;mut collection</code> 也有类似的模式：编译器寻找 <code>&amp;mut Collection</code> 的 <code>IntoIterator</code> trait，此时关联类型 <code>Item</code> 是 <code>&amp;mut Thing</code> 类型。</p>
<p>按照惯例，标准库容器会提供一个 <code>iter()</code> 方法返回对底层元素的引用，以及如果可以的话，一个等效的 <code>iter_mut()</code> 方法，其行为与上面提到的相同。这些方法可以在 <code>for</code> 循环中使用，但在用作迭代器转换的场景下有更明显的好处：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: u64 = (&amp;collection).into_iter().map(|thing| thing.0).sum();
<span class="boring">}</span></code></pre></pre>
<p>可以变成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: u64 = collection.iter().map(|thing| thing.0).sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="iterator-transforms-迭代器转换"><a class="header" href="#iterator-transforms-迭代器转换">Iterator Transforms 迭代器转换</a></h2>
<p><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> trait 只有一个必须的 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next">next</a> 方法，但也提供了大量的在迭代器上执行转换计算的默认方法实现（<a href="/chapter_2/item13-use-default-impl.html">第 13 条</a>）。</p>
<p>其中一些转换会影响到整个迭代的过程：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take">take(n)</a>：限制迭代器最多只能产生 <code>n</code> 个元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip">skip(n)</a>：跳过迭代器的前 <code>n</code> 个元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by">step_by(n)</a>：转换迭代器，让它每隔 <code>n</code> 个元素生成一个元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain">chain(other)</a>：将两个迭代器粘合在一起构造一个组合迭代器，它会在遍历完第一个迭代器的内容后开始遍历第二个迭代器。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cycle">cycle()</a>：将迭代器转换为一个永久循环的迭代器，当遍历到头后再次从头开始遍历。（迭代器需要实现 <code>Clone</code> 来支持这个方法。）</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev">rev()</a>：反转迭代器的方向。（迭代器需要实现 <a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html">DoubleEndedIterator</a> trait，这个 trait 有一个额外的 <a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back">next_back</a> 方法。）</li>
</ul>
<p>其他的转换会影响到 <code>Iterator</code> 对应的 <code>Item</code> 的性质/属性：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map">map(|item| {...})</a>：重复应用闭包依次转换迭代的元素。这是最通用的转换，这个列表中的以下若干个方法都可以用 <code>map</code> 等价地实现。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned">clone()</a>：产生原始迭代器中元素的一个克隆；这个方法在遍历 <code>&amp;Item</code> 这种引用的时候十分有用。（显然这需要底层类型 <code>Item</code> 实现 <code>Clone</code>。）</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.copied">copied()</a>：产生原始迭代器中元素的一个拷贝；这个方法在遍历 <code>&amp;Item</code> 这种引用的时候十分有用。（显然这需要底层类型 <code>Item</code> 实现 <code>Copy</code>，如果是这样的话，那么有可能会比 <code>cloned()</code> 要快一些。）</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate">enumerate()</a>：将迭代器转换成迭代 <code>(usize, Item)</code> 值对的迭代器，提供了迭代器中元素的索引。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip">zip(it)</a>：将一个迭代器和另一个迭代器联结，构建一个组合迭代器，用于产生值对，每一个值对里面的元素分别来自于两个迭代器，组合迭代器会一直产生元素直到元素较少的迭代器迭代完毕。</li>
</ul>
<p>还有一些转换可以对 <code>Iterator</code> 产生的 <code>Item</code> 进行过滤：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter">filter(|item| {...})</a>：对每个元素的引用应用一个返回布尔值的闭包，来判断这个元素是否应该要被迭代器提供。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while">take_while()</a>：基于谓词提供迭代器初始区间中的元素。是 <code>skip_while</code> 的镜像。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip_while">skip_while()</a>：基于谓词提供迭代器末端区间中的元素。是 <code>take_while</code> 的镜像。</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten">flatten</a> 方法用于处理元素类型还是迭代器类型的迭代器，用于展平结果。单就这个方法来看这好像没有什么用，但是我们发现当 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.iter">Option</a> 和 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.iter">Result</a> 类型用作迭代器的时候，这就很有用了：这两个类型会产生零（<code>None</code>，<code>Err(e)</code>）或者一（<code>Some(v)</code>，<code>Ok(v)</code>）。这意味着 <code>flatten</code> 一个 <code>Option</code> 或者 <code>Result</code> 的流是一个提取其中有效值的简单方式。</p>
<p>从整体上看，上面提到的方法允许对迭代器进行转换，以便迭代器精确地生成大多数情况下所需要的元素序列。</p>
<h2 id="iterator-consumers-迭代器消耗者"><a class="header" href="#iterator-consumers-迭代器消耗者">Iterator Consumers 迭代器消耗者</a></h2>
<p>前面两节介绍了如何获取迭代器，以及如何对其进行合适的转换来进行精准的迭代。这种目的明确的迭代也可以通过显式循环的方式来实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
    even_sum_squares += value * value;
}
<span class="boring">}</span></code></pre></pre>
<p>但同时 <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> 提供的方法集里面还包含了许多可以消费整个迭代以获得结果的方法，从而可以让我们消除显式的 <code>for</code> 循环。</p>
<p>这些方法中最常见的是 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each">for_each(|item| {...})</a>，它会对 <code>Iterator</code> 产生的每个元素应用一个闭包。这可以完成<em>绝大多数</em>显式 <code>for</code> 循环可以完成的工作（除了少量例外，我们会在后面的部分中提到）。但它的普适性也让它用起来有点尴尬——闭包需要捕获对外部状态的可变引用才能“返回”结果：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
values
    .iter()
    .filter(|x| *x % 2 == 0)
    .take(5)
    .for_each(|value| {
        // closure needs a mutable reference to state elsewhere
        even_sum_squares += value * value;
    });
<span class="boring">}</span></code></pre></pre>
<p>但是如果 <code>for</code> 循环的循环体跟一些常见的模式之一匹配，那么就有更特化的方法来“消费”迭代器，这些方法往往更清晰、简短且符合惯用法。</p>
<p>这些模式包括从一个集合中生成一个值的便捷方法：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum">sum()</a>：对数值（整型或浮点型）类型的集合求和。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.product">product()</a>：将数值类型集合中的元素相乘。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min">min()</a>：使用 <code>Item</code> 的 <code>Ord</code> 实现，寻找集合中的最小值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max">max()</a>：使用 <code>Item</code> 的 <code>Ord</code> 实现，寻找集合中的最大值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min_by">min_by(f)</a>：使用用户提供的比较函数 <code>f</code>，寻找集合中的最小值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by">max_by(f)</a>：使用用户提供的比较函数 <code>f</code>，寻找集合中的最大值。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce">reduce(f)</a>：通过在每次迭代中执行闭包来计算 <code>Item</code> 的求和值，闭包会接收截止目前的求和值和当前遍历的元素作为参数。这是一个更通用的操作，包含（可以用于实现）前面提到的一些方法。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold">fold(f)</a>：通过在每次迭代中执行闭包来计算任意类型（而不限于 <code>Iterator::Item</code> 类型）的求和值，闭包会接收截止目前的求和值和当前遍历的元素作为参数。这是 <code>reduce</code> 的更泛化的版本。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan">scan(init, f)</a>：通过在每次迭代中执行闭包来计算某个特定类型的求和值，闭包会接收某种内部状态的可变引用和当前遍历的元素作为参数。这是一个稍特别的 <code>reduce</code> 的泛化版本。</li>
</ul>
<p>还有一些方法可以用从集合中<em>选择</em>一个值：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find">find(p)</a>：查找第一个满足谓词的元素。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position">position(p)</a>：也是查找第一个满足谓词的元素，不过返回元素对应的索引。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth">nth(n)</a>：如果有，返回迭代的第 <code>n</code> 的元素。</li>
</ul>
<p>还有一些方法可以针对集合中的每个元素进行测试：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any">any(p)</a>：返回谓词是否对集合中的<em>任一</em>元素成立。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all">all(p)</a>：返回谓词是否对集合中的<em>所有</em>元素成立。</li>
</ul>
<p>对于上面两个方法之一，如果遍历过程中找到一个反例，迭代都会提前终止。</p>
<p>有一些方法允许闭包在对元素操作的时候返回失败。在这种场景下，如果闭包对某个元素的操作返回失败，迭代将终止，并返回第一个导致失败产生的操作：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each">try_for_each(f)</a>：行为类似于 <code>for_each</code>，但闭包操作可能会失败。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold">try_fold(f)</a>：行为类似于 <code>fold</code>，但闭包操作可能会返回失败。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_find">try_find(f)</a>：行为类似于 <code>find</code>，但闭包操作可能会返回失败。</li>
</ul>
<p>最后，还有一些方法可以把所有迭代的元素累积到新的集合中。当中最重要的就是 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect()</a> 方法，它可以用于创建任意一种实现了 <a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html">FromIterator</a> 特征的集合类型。</p>
<p><code>FromIterator</code> traits 在所有的标准库集合类型上都有实现（<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-FromIterator%3CT%3E">Vec</a>,<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-FromIterator%3C(K%2C%20V)%3E">HashMap</a>,<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E">BTreeSet</a> 等），但这种普遍性也意味着你总是要显式地指定集合的类型，否则编译器无法推断出你想要组装一个（比如说）<code>Vec&lt;i32&gt;</code> 还是 <code>HashSet&lt;i32&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

// Build collections of even numbers.  Type must be specified, because
// the expression is the same for either type.
// 创建一个只有偶数的集合。你必须指定集合的类型，因为对于两个集合来说构造的表达式一模一样。
let myvec: Vec&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
let h: HashSet&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
<span class="boring">}</span></code></pre></pre>
<p>这个例子也展示了如何使用范围表达式 <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expressions</a> 来生成要迭代的初始数据。</p>
<p>还有一些其他（更加晦涩）的集合生成方法：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip">unzip()</a>：将一个 pair 的迭代器拆分到两个集合中。</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition">partition(p)</a>：通过应用谓词到元素上，把一个迭代器迭代的内容切分到两个集合中。</li>
</ul>
<p>本条款涉及了很多 <code>Iterator</code> 相关的方法，但这仅仅是所有可用方法的子集；要想了解更多，可以参考文档 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator documentation</a> 或者 <em>Programming Rust</em> 第二版（O'Reilly）的 15 章，书里更详细地介绍了各种可能的用法。</p>
<p>丰富的迭代器转换方法集合在日常中就这么触手可及，这些方法可以让代码变得更符合惯用法、更紧凑，同时更好地表达代码的意图。</p>
<p>将循环表达式转换成迭代器转换还有助于生成更高效的代码。为了安全起见，Rust 在访问诸如 vector 和切片这种连续的容器时会对访问执行<em>边界检查</em>；任何尝试访问越界的元素的操作都会导致 panic 而不是访问无效的数据。传统的访问容器值的方法（如 <code>values[i]</code>）<em>可能</em>会受到这些运行时检查的介入，而一个逐步提供值的迭代器可以被认为是不会越界的。</p>
<p>但是，与迭代器转换等效的传统循环表达式也可能<em>不会</em>受到额外的边界检查的影响。Rust 的编译器和优化器很擅长分析切片访问的上下文代码来决定跳过边界检查是否安全可行的；Sergey "Shnatsel" Davidoff 的文章 <a href="https://shnatsel.medium.com/how-to-avoid-bounds-checks-in-rust-without-unsafe-f65e618b4c1e">2023 article</a> 探讨了其中的细节。</p>
<h2 id="从-result-值构建集合"><a class="header" href="#从-result-值构建集合">从 Result 值构建集合</a></h2>
<p>上一节我们介绍了如何用 <code>collect()</code> 从迭代器构建集合，但同时 <code>collect()</code> 对于处理 <code>Result</code> 值的场景也有特别有用的特性。</p>
<p>考虑一个例子，将一个 <code>u64</code> 的 vector 转成字节 <code>u8</code>，并期望它们都满足条件：</p>
<div class="ferris"><img src="../images/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In the 2021 edition of Rust, `TryFrom` is in the prelude, so this
// `use` statement is no longer needed.
use std::convert::TryFrom;

let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4];
let result: Vec&lt;u8&gt; = inputs
    .into_iter()
    .map(|v| &lt;u8&gt;::try_from(v).unwrap())
    .collect();
<span class="boring">}</span></code></pre></pre>
<p>这是可以的，直到有一些意外的输入：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4, 512];
<span class="boring">}</span></code></pre></pre>
<p>这将导致运行时的失败：</p>
<pre><code class="language-shell">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:
TryFromIntError(())', iterators/src/main.rs:266:36
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>根据 <a href="item3-transform.html">第 3 条</a> 的建议，我们希望保留 <code>Result</code> 类型并且使用 <code>?</code> 运算符让任何一个失败的操作作为调用代码的问题返回。修改让代码返回 <code>Result</code> 达不到我们的目的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: Vec&lt;Result&lt;u8, _&gt;&gt; =
    inputs.into_iter().map(|v| &lt;u8&gt;::try_from(v)).collect();
// Now what?  Still need to iterate to extract results and detect errors.
<span class="boring">}</span></code></pre></pre>
<p>但是还有另一种 <code>collect()</code> 的版本，可以组装一个持有 <code>Vec</code> 的 <code>Result</code>，而不是一个装着 <code>Result</code> 的 <code>Vec</code>。</p>
<p>想要强制使用这个版本就要用到 turbofish 语法（<code>::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;</code>）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: Vec&lt;u8&gt; = inputs
    .into_iter()
    .map(|v| &lt;u8&gt;::try_from(v))
    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
<span class="boring">}</span></code></pre></pre>
<p>将其与问号运算符结合使用实现了一种有用的行为：</p>
<ul>
<li>如果迭代遇到了错误，错误的值会返回到调用方，并且迭代终止。</li>
<li>如果没有遇到错误，则余下代码能处理返回一个合理、类型正确的值的集合。</li>
</ul>
<h2 id="转换显式循环"><a class="header" href="#转换显式循环">转换显式循环</a></h2>
<p>这个条款的目的是让你相信很多显式循环都可以被当做基于迭代器的转换。这对于不习惯的程序员来说可能会让人觉得不太自然，所以我们来一步步完成一次转换吧。</p>
<p>我们从一个很 C 语言风格的循环开始，对一个 vector 的头五个偶数项求平方和：</p>
<pre><code class="language-c">let mut even_sum_squares = 0;
let mut even_count = 0;
for i in 0..values.len() {
    if values[i] % 2 != 0 {
        continue;
    }
    even_sum_squares += values[i] * values[i];
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
</code></pre>
<p>第一步是把 vector 的索引换成 for-each 循环的迭代器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
let mut even_count = 0;
for value in values.iter() {
    if value % 2 != 0 {
        continue;
    }
    even_sum_squares += value * value;
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>使用 <code>continue</code> 来跳过某些元素的原始代码分支可以用 <code>filter()</code> 来很自然地表达：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
let mut even_count = 0;
for value in values.iter().filter(|x| *x % 2 == 0) {
    even_sum_squares += value * value;
    even_count += 1;
    if even_count == 5 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>接下来，一旦我们有 5 个元素了，我们就提前退出循环，这里用 <code>take(5)</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
    even_sum_squares += value * value;
}
<span class="boring">}</span></code></pre></pre>
<p>每次迭代我们都只要元素的平方值 <code>value * value</code>，这就是 <code>map()</code> 理想的使用场景：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut even_sum_squares = 0;
for val_sqr in values.iter().filter(|x| *x % 2 == 0).take(5).map(|x| x * x)
{
    even_sum_squares += val_sqr;
}
<span class="boring">}</span></code></pre></pre>
<p>对原始循环的重构最后成为了 <code>sum()</code> 方法大锤下一颗完美的钉子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let even_sum_squares: u64 = values
    .iter()
    .filter(|x| *x % 2 == 0)
    .take(5)
    .map(|x| x * x)
    .sum();
<span class="boring">}</span></code></pre></pre>
<h2 id="什么时候显式循环更好"><a class="header" href="#什么时候显式循环更好">什么时候显式循环更好</a></h2>
<p>这条条款强调了迭代器转换的又是，特别是在简洁性和清晰度方面。那么什么时候迭代器转换<em>不是</em>那么适合或者不符合惯用法呢？</p>
<ul>
<li>
<p>如果循环体很大、或者功能很多，那么保留在一个显式的循环体里面会比把逻辑压缩到闭包中更合理。</p>
</li>
<li>
<p>如果循环体包含很多会导致功能提前终止的错误条件，最好还是把它们保留在显式的循环体中—— <code>try...()</code> 之类的方法也不会帮上很多忙。但是，<code>collect()</code> 能把一个值类型为 <code>Result</code> 的集合转换成一个持有集合类型的 <code>Result</code> 类型的能力，在配合 <code>?</code> 运算符的场景下还是可以进行错误条件的处理。</p>
</li>
<li>
<p>如果性能至关重要，包含闭包的迭代器转换<em>理应</em>跟显式的代码一样快 <a href="https://doc.rust-lang.org/book/ch13-04-performance.html">just as fast</a>。但如果代码中一个核心的循环很重要，<em>测量</em>不同的实现方法并进行适当的调优。</p>
<ul>
<li>请确保你的测试能反映实际的性能——编译器的优化可能会对测试数据给出过于乐观的结果（如 <a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a> 所述）。</li>
<li><a href="https://rust.godbolt.org/">Godbolt compiler explorer</a> 是一个了不得的工具，你可以看到编译器都生成了什么。</li>
</ul>
</li>
</ul>
<p>最重要的，如果转换的过程是强制的或者生搬硬套的，那么就不要把显式循环转成迭代器转换了。这不过是一种编程风格口味的取向而已——但注意到，随着你对函数式的风格越来越熟悉，你的口味也很可能会发生变化。</p>
<hr />
<p><a id="footnote-1">1</a>:事实上，迭代器可以更通用——在直到结束之前不停地产生下一个元素，这种想法不必跟某种容器强关联。</p>
<p><a id="footnote-2">2</a>:如果对容器元素的修改可能会导致容器内部的一些约束被打破，那么这个方法就不能提供了。比如说：导致元素的 <a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a> 值发生变化的修改，就可能会导致 <code>HashMap</code> 内部数据结构的失效。</p>
<!-- 参考链接 -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_1/item8-references&amp;pointer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_1/item8-references&amp;pointer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../style/js/tongji.js"></script>
        <script src="../style/js/ferris.js"></script>


    </div>
    </body>
</html>
