<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 2 条：使用类型系统表达常见行为 - Effective Rust 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="../intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="../intro.html">介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="../chapter_1/item2-use-types-2.html" class="active"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="../chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="../chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="../chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="../chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="../chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item9-iterators.html"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/item10-std-traits.html"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="../chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="../chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="../chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/item14-lifetimes.html"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="../chapter_3/item15-borrows.html"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="../chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="../chapter_3/item17-deadlock.html"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="../chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="../chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="../chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="../chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="../chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-2-条使用类型系统表达常见行为"><a class="header" href="#第-2-条使用类型系统表达常见行为">第 2 条：使用类型系统表达常见行为</a></h1>
<p><a href="item1-use-types.html">第1条</a>讨论了如何在类型系统中表达数据结构；本节继续讨论在 Rust 的类型系统中行为的编码。</p>
<h2 id="方法-methods-"><a class="header" href="#方法-methods-">方法（ Methods ）</a></h2>
<p>在 Rust 的类型系统中，行为首次出现的地方就是将方法添加到数据结构上：这些方法是对该类型实例的操作，通过 <code>self</code> 标识。这种方式以对象导向的方式将相关的数据和代码封装在一起，这与其他语言中的做法相似；然而，在 Rust 中，方法不仅可以添加到<code>结构体</code>类型上，也可以添加到<code>枚举</code>类型上，这与 Rust 枚举的普遍性质相符（<a href="item1-use-types.html">第1条</a>）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Circle { radius: f64 },
}

impl Shape {
    pub fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Circle { radius } =&gt; std::f64::consts::PI * radius * radius,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>方法的名称为其编码的行为提供了一个标签，而方法签名提供了其输入和输出的类型信息。方法的第一个输入是 <code>self</code> 的某种变体，指示该方法可能对数据结构执行的操作：</p>
<ul>
<li><code>&amp;self</code> 参数表示可以从数据结构中读取内容，但不会修改它。</li>
<li><code>&amp;mut self</code> 参数表示该方法可能会修改数据结构的内容。</li>
<li><code>self</code> 参数表示该方法会消耗数据结构。</li>
</ul>
<h2 id="抽象行为"><a class="header" href="#抽象行为">抽象行为</a></h2>
<p>调用方法总是会导致相同的代码被执行；从一次调用到下一次调用所改变的一切就是方法操作的数据。这涵盖了许多可能的情况，但是如果在运行时需要代码发生变化呢？</p>
<p>Rust 在其类型系统中包括了几个特性来适应这种情况，本节将探讨这些特性。</p>
<h3 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h3>
<p>最简单的行为抽象是<a href="https://doc.rust-lang.org/std/primitive.fn.html">函数指针</a>：一个仅指向某些代码的指针，其类型反映了函数的签名。类型在编译时进行检查，所以到程序运行时，这个值只是指针的大小。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum(x: i32, y: i32) -&gt; i32 {
    x + y
}
// Explicit coercion to `fn` type is required...
let op: fn(i32, i32) -&gt; i32 = sum;
<span class="boring">}</span></code></pre></pre>
<p>函数指针没有与之关联的其他数据，因此，可以以各种方式将它们视为值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `fn` types implement `Copy`
let op1 = op;
let op2 = op;
// `fn` types implement `Eq`
assert!(op1 == op2);
// `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.
println!("op = {:p}", op);
// Example output: "op = 0x101e9aeb0"
<span class="boring">}</span></code></pre></pre>
<div class="ferris-border">
<blockquote>
<p>一个需要注意的技术细节：需要显式地将函数强制转换为 <code>fn</code> 类型，因为仅仅使用函数的名称并不能得到 <code>fn</code> 类型的值；</p>
</blockquote>
<p>这段代码无法编译！</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let op1 = sum;
let op2 = sum;
// Both op1 and op2 are of a type that cannot be named in user code,
// and this internal type does not implement `Eq`.
assert!(op1 == op2);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0369]: binary operation `==` cannot be applied to type `fn(i32, i32) -&gt; i32 {main::sum}`
   --&gt; use-types-behaviour/src/main.rs:117:21
    |
117 |         assert!(op1 == op2);
    |                 --- ^^ --- fn(i32, i32) -&gt; i32 {main::sum}
    |                 |
    |                 fn(i32, i32) -&gt; i32 {main::sum}
    |
help: you might have forgotten to call this function
    |
117 |         assert!(op1( /* arguments */ ) == op2);
    |                    +++++++++++++++++++
help: you might have forgotten to call this function
    |
117 |         assert!(op1 == op2( /* arguments */ ));
    |                           +++++++++++++++++++

<span class="boring">}</span></code></pre></pre>
<p>相反，编译器错误表明类型类似于 <code>fn(i32, i32) -&gt; i32 {main::sum}</code>，这是一种完全内部于编译器的类型（即不能在用户代码中编写），它同时标识了特定的函数及其签名。</p>
<p>换句话说，<code>sum</code> 的类型既编码了函数的签名又编码了其位置（出于优化原因）；这种类型可以自动强制转换为 <code>fn</code> 类型（<a href="item6-newtype.html">第6条</a>）。</p>
</div>
<h3 id="闭包"><a class="header" href="#闭包">闭包</a></h3>
<p>裸函数指针的使用是有限的，因为被调用函数唯一可以使用的输入是那些明确作为参数值传递的内容。</p>
<p>例如，考虑一些使用函数指针修改切片中每个元素的代码。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In real code, an `Iterator` method would be more appropriate.
pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
    for value in data {
        *value = mutator(*value);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这对于对切片进行简单的修改是有效的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add2(v: u32) -&gt; u32 {
    v + 2
}
let mut data = vec![1, 2, 3];
modify_all(&amp;mut data, add2);
assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<p>然而，如果修改依赖于任何额外的状态，那么无法隐式地将这些状态传递给函数指针。</p>
<p>这段代码无法编译！</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount_to_add = 3;
fn add_n(v: u32) -&gt; u32 {
    v + amount_to_add
}
let mut data = vec![1, 2, 3];
modify_all(&amp;mut data, add_n);
assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0434]: can't capture dynamic environment in a fn item
   --&gt; use-types-behaviour/src/main.rs:142:17
    |
142 |             v + amount_to_add
    |                 ^^^^^^^^^^^^^
    |
    = help: use the `|| { ... }` closure form instead
<span class="boring">}</span></code></pre></pre>
<p>错误信息指向了正确的工具：闭包。闭包是一段看起来像函数定义体（<code>lambda</code> 表达式）的代码，不同之处在于：</p>
<ul>
<li>它可以作为表达式的一部分构建，因此，不需要与一个名称相关联</li>
<li>输入参数以竖线 <code>|param1, param2|</code> 给出（它们的关联类型通常可以由编译器自动推导）</li>
<li>它可以捕获其周围环境的一部分。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount_to_add = 3;
let add_n = |y| {
    // a closure capturing `amount_to_add`
    y + amount_to_add
};
let z = add_n(5);
assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>为了（大致）理解捕获是如何工作的，可以想象编译器创建了一个一次性的、内部的类型，它包含了 <code>lambda</code> 表达式中提到的环境所有部分。当闭包被创建时，这个临时类型的一个实例被创建来保存相关的值，当闭包被调用时，这个实例被用作额外的上下文。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount_to_add = 3;
// *Rough* equivalent to a capturing closure.
struct InternalContext&lt;'a&gt; {
    // references to captured variables
    amount_to_add: &amp;'a u32,
}
impl&lt;'a&gt; InternalContext&lt;'a&gt; {
    fn internal_op(&amp;self, y: u32) -&gt; u32 {
        // body of the lambda expression
        y + *self.amount_to_add
    }
}
let add_n = InternalContext {
    amount_to_add: &amp;amount_to_add,
};
let z = add_n.internal_op(5);
assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>在这个概念性的上下文中持有的值通常是引用（<a href="item9-iterators.html">第9条</a>），就像这里的例子，但它们也可以是环境中事物的可变引用，或者是通过在输入参数前使用 <code>move</code> 关键字而从环境中完全移出的值。</p>
<p>回到 <code>modify_all</code> 的例子，闭包不能用在期望函数指针的地方。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
   --&gt; use-types-behaviour/src/main.rs:165:31
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                               ^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found closure
    |
    = note: expected fn pointer `fn(u32) -&gt; u32`
                  found closure `[closure@use-types-behaviour/src/main.rs:165:31: 165:52]`
note: closures can only be coerced to `fn` types if they do not capture any variables
   --&gt; use-types-behaviour/src/main.rs:165:39
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                                       ^^^^^^^^^^^^^ `amount_to_add` captured here
<span class="boring">}</span></code></pre></pre>
<p>相反，接收闭包的代码必须接受一个实现了 <code>Fn*</code> 特征的实例。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn modify_all&lt;F&gt;(data: &amp;mut [u32], mut mutator: F)
where
    F: FnMut(u32) -&gt; u32,
{
    for value in data {
        *value = mutator(*value);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 有三种不同的 <code>Fn*</code> 特征，它们之间表达了关于环境捕获行为的一些区别。</p>
<ul>
<li><code>FnOnce</code> 描述了一个只能被调用一次的闭包。如果闭包的环境中有部分被移动到闭包内，那么这种移动只能发生一次 —— 因为源项没有其他副本可以移动 —— 因此，闭包只能被调用一次。</li>
<li><code>FnMut</code> 描述了一个可以被多次调用的闭包，它能够改变其环境，因为它会可变地借用环境。</li>
<li><code>Fn</code> 描述了一个可以被多次调用的闭包，它只从环境中不可变地借用值。</li>
</ul>
<p>编译器会为代码中的任何 <code>lambda</code> 表达式自动实现这些 <code>Fn*</code> 特征的适当子集；不可能手动实现这些特征中的任何一个<sup class="footnote-reference"><a href="#1">1</a></sup>（与 <code>C++</code> 的 <code>operator()</code> 重载不同）。</p>
<p>回到上面关于闭包的粗略心理模型，编译器自动实现的特征大致对应于捕获的环境上下文是否具有：</p>
<ul>
<li><code>FnOnce</code>: 任何被移动的值</li>
<li><code>FnMut</code>: 任何对值的可变引用（<code>&amp;mut T</code>）</li>
<li><code>Fn</code>: 只是对值的普通引用（<code>&amp;T</code>）。</li>
</ul>
<p>上面列表中的后两个特征各自具有前一个特征的特征约束，当你考虑使用闭包时，这是有意义的。</p>
<ul>
<li>如果某事物只期望调用一次闭包（通过接收 <code>FnOnce</code> 表示），那么传递给它一个能够被多次调用的闭包（<code>FnMut</code>）是可以的。</li>
<li>如果某事物期望重复调用一个可能改变其环境的闭包（通过接收 <code>FnMut</code> 表示），那么传递给它一个不需要改变其环境的闭包（<code>Fn</code>）是可以的。</li>
</ul>
<p>裸函数指针类型 <code>fn</code> 也名义上属于这个列表的末尾；任何（非不安全的）<code>fn</code> 类型自动实现所有 <code>Fn*</code> 特征，因为它不借用任何环境。</p>
<p>因此，在编写接受闭包的代码时，<strong>使用最通用的 <code>Fn*</code> 特征，以允许调用者最大的灵活性</strong> —— 例如，对于只使用一次的闭包，接受 <code>FnOnce</code>。同样的推理也导致了<strong>建议优先使用 <code>Fn*</code> 特征约束而不是裸函数指针（<code>fn</code>）</strong>。</p>
<h3 id="特征traits"><a class="header" href="#特征traits">特征（<code>Traits</code>）</a></h3>
<p><code>Fn*</code> 特征比裸函数指针更灵活，但它们仍然只能描述单个函数的行为，并且只能在函数签名的基础上描述。
然而，它们本身就是 Rust 类型系统中描述行为的另一种机制的例子，即特征。特征定义了一组相关的方法，这些方法由一些底层项公开提供。特征中的每个方法也有一个名称，这允许编译器区分具有相同签名的方法，更重要的是，它允许程序员推断方法的目的。</p>
<p>Rust 的特征大致类似于 Go 和 Java 中的“接口”，或者 C++ 中的“抽象类”（所有虚拟方法，没有数据成员）。特征的实施必须提供所有方法（但请注意特征定义可以包括默认实现，<a href="/chapter_2/item13-use-default-impl.html">第13条</a>），并且还可以有相关联的数据，那些实现会使用这些数据。这意味着代码和数据在共同的抽象中以某种面向对象的方式一起封装。</p>
<p>接受结构体并调用其方法的代码被限制只能与特定类型一起工作。如果有多个类型实现了公共行为，那么定义一个特征来封装这种行为，并让代码使用特征的方法而不是特定结构体的方法会更加灵活。</p>
<p>这导致了与其他受面向对象<sup class="footnote-reference"><a href="#2">2</a></sup>影响的语言相同的建议：<strong>如果预期未来需要灵活性，请优先接受特征类型而不是具体类型</strong>。</p>
<p>有时，你希望在某些行为中使用类型系统来区分，但这些行为无法表达为特征定义中的特定方法签名。例如，考虑一个用于排序集合的特征；一个实现可能是稳定的（比较相同的元素在排序前后的顺序不变），但没有办法在排序方法参数中表达这一点。</p>
<p>在这种情况下，使用标记特征（<code>marker trait</code>）在类型系统中跟踪这个要求仍然是值得的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sort {
    /// Re-arrange contents into sorted order.
    fn sort(&amp;mut self);
}

/// Marker trait to indicate that a [`Sortable`] sorts stably.
pub trait StableSort: Sort {}
<span class="boring">}</span></code></pre></pre>
<p>标记特征（<code>marker trait</code>）没有方法，但实现仍然需要声明它正在实现该特征 —— 这被视为实现者的承诺：“我庄严宣誓，我的实现在稳定排序。”依赖于稳定排序的代码可以指定 <code>StableSort</code> 特征约束，依赖荣誉制度来保持其不变量。<strong>使用标记特征来区分无法在特征方法签名中表达的行为</strong>。</p>
<p>一旦行为被封装到 Rust 的类型系统中作为一个特征，它可以以两种方式被使用：</p>
<ul>
<li>作为特征约束（<code>trait bound</code>），它在编译时限制了哪些类型可以接受一个泛型数据类型或方法，或者</li>
<li>作为特征对象（<code>trait object</code>），它在运行时限制了哪些类型可以存储或传递给一个方法。
<a href="/chapter_2/item12-generics&amp;trait-objects.html">第12条</a> 更详细地讨论了这两种方式的权衡。</li>
</ul>
<p>特征约束表明，当某个类型 <code>T</code> 实现了某个特定特征时，参数化为该类型 <code>T</code> 的泛型代码才能被使用。特征约束的存在意味着泛型的实现可以使用来自该特征的方法，确信编译器将确保任何可以编译的 <code>T</code> 确实具有那些方法。这种检查发生在编译时，当泛型被单态化（Rust 对 C++ 中所谓的“模板实例化”的术语）。</p>
<p>对目标类型 <code>T</code> 的这种限制是明确的，编码在特征约束中：只有满足特征约束的类型才能实现该特征。这与 C++ 中的等价情况形成对比，在 C++ 中，<code>template&lt;typename T&gt;</code> 中使用的类型 <code>T</code> 的约束是隐式的<sup class="footnote-reference"><a href="#3">3</a></sup>：C++ 模板代码仍然只有在所有引用的方法在编译时都可用时才会编译，但检查纯粹基于方法和签名。（这种“<a href="https://en.wikipedia.org/wiki/Duck_typing">鸭子类型</a>”可能导致混淆；一个使用 <code>t.pop()</code> 的 C++ 模板可能为 <code>Stack</code> 或 <code>Balloon</code> 的 <code>T</code> 类型参数编译 —— 这不太可能是期望的行为。）</p>
<p>对显式特征约束的需求也意味着大部分泛型使用特征约束。要了解为什么会这样，反过来考虑一下在没有 <code>T</code> 的特征约束的情况下 <code>struct Thing&lt;T&gt;</code> 可以做什么。没有特征约束，<code>Thing</code> 只能执行适用于任何类型 <code>T</code> 的操作；这允许<code>容器</code>、<code>集合</code>和<code>智能指针</code>，但除此之外并不多。任何使用类型 <code>T</code> 的东西都需要一个特征约束。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dump_sorted&lt;T&gt;(mut collection: T)
where
    T: Sort + IntoIterator,
    T::Item: Debug,
{
    // Next line requires `T: Sort` trait bound.
    collection.sort();
    // Next line requires `T: IntoIterator` trait bound.
    for item in collection {
        // Next line requires `T::Item : Debug` trait bound
        println!("{:?}", item);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，这里的建议是使用特征约束来表达对泛型中使用的类型的要求，但这很容易遵循 —— 编译器将迫使你遵守它。</p>
<p>特征对象是利用特征定义的封装的另一种方式，但在这里，不同的特征实现是在运行时而不是编译时选择的。这种动态分派类似于 C++ 中虚拟函数的使用，在底层，Rust 有 '<code>vtable</code>' 对象，它们与 C++ 中的类似。</p>
<p>特征对象的这种动态方面也意味着它们必须始终通过间接方式处理，通过引用（<code>&amp;dyn Trait</code>）或指针（<code>Box&lt;dyn Trait&gt;</code>）。这是因为实现特征的对象大小在编译时是未知的 —— 它可能是一个巨大的结构体或一个微小的枚举 —— 因此无法为裸特征对象分配正确数量的空间。</p>
<p>类似的问题意味着用作特征对象的特征不能有返回 <code>Self</code> 类型的方法，因为预先编译的代码使用特征对象时将无法知道 <code>Self</code> 可能有多大。</p>
<p>具有泛型方法 <code>fn method&lt;T&gt;(t:T)</code> 的特征允许存在无限数量的实现方法，适用于所有可能存在的不同类型 <code>T</code>。这对于用作特征约束的特征来说是可行的，因为无限集合的可能的泛型方法在编译时变为有限的实际调用的泛型方法集合。对于特征对象来说，情况并非如此：编译时可用的代码必须应对运行时可能出现的所有可能的 <code>Ts</code>。（因此trait中不能添加泛型方法，尽管有约束，可以满足约束的类型永远会是无数个）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait foo {
    fn method&lt;T&gt;(&amp;self, t: T);
}

struct Bar;

impl Bar {
    fn new() -&gt; Self {
        Self {}
    }
}

impl foo for Bar {
    fn method&lt;T&gt;(&amp;self, t: T) {
        println!("Bar impl trait foo!");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::hash_map::VacantEntry;

    #[test]
    fn as_trait_bound() {
        let bar = Bar::new();
        bar.method(0u8);
    }

    #[test]
    fn as_trait_obj() {
        let bar = Bar::new();
        let mut v: Vec&lt;&amp;dyn foo&gt; = vec![];
        v.push(&amp;bar);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>fn as_trait_bound() 测试可以通过，没有错误。但是as_trait_obj()会报错：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0038]: the trait `foo` cannot be made into an object
  --&gt; src/lib.rs:33:20
   |
33 |         let mut v: Vec&lt;&amp;dyn foo&gt; = vec![];
   |                    ^^^^^^^^^^^^^ `foo` cannot be made into an object
   |
note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;
  --&gt; src/lib.rs:2:8
   |
1  | trait foo {
   |       --- this trait cannot be made into an object...
2  |     fn method&lt;T&gt;(&amp;self, t: T);
   |        ^^^^^^ ...because method `method` has generic type parameters
   = help: consider moving `method` to another trait
   = help: only type `Bar` implements the trait, consider using it directly instead
<span class="boring">}</span></code></pre></pre>
<p>这两个限制 —— 不能返回 <code>Self</code> 和不能有泛型方法 —— 结合成了对象安全的概念。只有对象安全的特征才能用作特征对象。</p>
<hr />
<h4 id="注释"><a class="header" href="#注释">注释</a></h4>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>至少，在撰写本文时的稳定 Rust 中是这样。实验性功能 <code>unboxed_closures</code> 和 <code>fn_traits</code> 可能在未来改变这一点。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>例如，Effective Java 第64条：通过它们的接口引用对象</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>C++20 中添加的概念允许对模板类型上的约束进行显式指定，但检查仍然只在模板实例化时执行，而不是在声明时执行。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">点这里</a>查看</p>
<!-- 参考链接 -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_1/item1-use-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_1/item3-transform.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_1/item1-use-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_1/item3-transform.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../style/js/tongji.js"></script>
        <script src="../style/js/ferris.js"></script>


    </div>
    </body>
</html>
