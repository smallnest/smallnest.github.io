<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 10 条：熟悉标准库的 traits - Effective Rust 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="../intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="../intro.html">介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="../chapter_1/item2-use-types-2.html"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="../chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="../chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="../chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="../chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="../chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item9-iterators.html"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/item10-std-traits.html" class="active"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="../chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="../chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="../chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/item14-lifetimes.html"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="../chapter_3/item15-borrows.html"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="../chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="../chapter_3/item17-deadlock.html"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="../chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="../chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="../chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="../chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="../chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-10-条熟悉标准库的-traits"><a class="header" href="#第-10-条熟悉标准库的-traits">第 10 条：熟悉标准库的 traits</a></h1>
<p>Rust 通过一系列详细的、描述类型行为的标准库 traits，把类型系统自身的关键行为特征编码到了类型系统本身上（参考 <a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>）。</p>
<p>其中的许多 traits 对于 C++ 程序员来说会感觉很熟悉，类比于拷贝构造函数、析构函数、相等性判断和复制运算符等等。</p>
<p>和在 C++ 中一样，为用户的自定义类型实现标准库当中的多数 traits 是个不错的选择；Rust 编译器会在用户的自定义类型需要某些 traits，而类型又缺少对应实现的时候给出有用的错误信息。</p>
<p>实现这么多的 traits 看起来有点吓人，但当中绝大多数的 traits 都可以通过 <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"><code>derive</code> macros</a> 自动应用到用户的自定义类型上。 <code>derive</code> 宏会基于类型生成相应的实现（例如：对于 <code>struct</code> 的字段逐一进行 <code>Eq</code> 判断）；这通常要求结构体的组成部分也实现了对应的 trait。自动生成的实现<em>通常</em>就是你会需要的，但也有例外，我们会在后面讨论具体 trait 的时候提到。</p>
<p>使用 <code>derive</code> 宏会让类型的定义看着像这样：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
enum MyBooleanOption {
    Off,
    On,
}
<span class="boring">}</span></code></pre></pre>
<p>这里就触发了对于 8 个不同的 trait 实现的自动生成。</p>
<p>这种细粒度的行为规范一开始可能会让人觉得不适应，但熟悉最常见的标准库 traits 非常重要，这样才能快速了解到一个类型的定义中给它赋予的各种可用行为。</p>
<h2 id="常见的标准库-traits"><a class="header" href="#常见的标准库-traits">常见的标准库 traits</a></h2>
<p>这一节讨论最常遇到的标准库 traits。以下是对这些 traits 粗略的一句话总结：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a>：需要时，该类型的实例可以通过执行用户定义的代码来创建自身的一个副本。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a>：如果编译器对类型实例的内存表示数据执行按比特拷贝，会得到一个有效的新副本。</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a>：可以使用合理的默认值创建该类型的实例。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>：该类型的实例之间存在偏序关系 <a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence relation</a>——任意两个实例可以明确地进行比较，但 <code>x == x</code> 并不总为真。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a>：该类型的实例之间存在等价关系 <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a>，——任意两个实例可以明确地进行比较，且 <code>x == x</code> 总为真。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a>：该类型的某些实例之间可以进行比较和排序。</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a>：该类型的所有实例之间可以进行比较和排序。</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a>：该类型的实例可以在需要的时候生成一个稳定的散列值（哈希值）。</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a>：该类型的实例可以对程序员显示（调试信息）。</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a>：该类型的实例可以对用户显示。</li>
</ul>
<p>除了 <code>Display</code> （因为与 <code>Debug</code> 功能有重叠）以外，这些 traits 都可以通过 <code>derive</code> 为用户自定义类型派生。然后有些时候手动实现——或者说不实现这些 traits 可能是个更好的选择。</p>
<p>下面的小节会更详细地讨论这些常见的 traits。</p>
<h1 id="clone"><a class="header" href="#clone"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a></a></h1>
<p><code>Clone</code> trait 表示可以通过调用 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone">clone()</a> 函数来创建一个对象的新副本。这跟 C++ 的拷贝函数大致相同，但是表意更加明确：编译器不会默默地调用这个函数（下一节会更详细地说明）。</p>
<p>如果一个类型的所有字段都实现了 <code>Clone</code> ，那么可以通过 <code>derive</code> 为这个类型自动派生 <code>Clone</code>。<code>derive</code> 派生获得的实现会对类型的每个成员依次执行克隆操作；再说一次，这跟 C++ 的构造函数大致相同。这个 trait 需要显式地启用（通过添加 <code>#[derive(Clone)]</code>），这与 C++ 中需要显式禁止（<code>MyType(const MyType&amp;) = delete;</code>）恰恰相反。</p>
<p>派生 <code>Clone</code> 是一个常见且有用的操作，以至于去考虑是否应该实现 <code>Clone</code>、评估默认派生的实现是否符合实际要求变得更加有意思了。</p>
<ul>
<li>如果一个类型的实例持有某些资源的唯一访问权（例如 RAII 类型 <a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a>），或者有其他原因限制拷贝（例如对象持有了加密密钥），那么你<em>不应该</em>实现 <code>Clone</code>。</li>
<li>如果类型的某些部分不是 <code>Clone</code> 的，那么你也<em>无法</em>实现 <code>Clone</code>：
<ul>
<li>字段是可变引用（<code>&amp;mut T</code>），因为借用检查器（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）在同一时刻只允许一个对同一资源的可变引用的存在。</li>
<li>属于上述类别的标准库类型，例如 <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html">MutexGuard</a>（体现唯一访问权）或者 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex</a>（出于线程安全限制拷贝）。</li>
</ul>
</li>
<li>如果类型的任何部分不能通过（递归的）字段拷贝，或者有生命周期相关的簿记动作需要执行，那么你需要<em>手动</em>实现 <code>Clone</code>。举个例子，考虑一个在运行时跟踪所有实例数量的类型，你需要手动实现 <code>Clone</code> 来保证计数器的准确。</li>
</ul>
<h1 id="copy"><a class="header" href="#copy"><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a></a></h1>
<p><code>Copy</code> trait 有一个简单的声明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>这个 trait 里面没有方法，这意味这是一个标记 trait <code>marker trait</code>（如同<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>中所述）：这是用来表示对类型的某些约束，而这种约束本身没有在类型系统中表达。</p>
<p>对于 <code>Copy</code> 而言，这个标记表示，对类型实例的内存进行按比特的拷贝，可以得到一个正确的新对象。实际上，这个 trait 是一个标记，表示一个类型是 <a href="https://en.wikipedia.org/wiki/Passive_data_structure">plain old data</a>（POD）类型。</p>
<p>这也意味着 <code>Clone</code> 特性可能会有点令人困惑：尽管实现了 <code>Copy</code> 的类型需要实现 <code>Clone</code>，但是当一个实例被拷贝的时候，<code>clone()</code> 方法并<em>没有</em>被调用——编译器在不使用任何用户定义代码的情况下生成了一个新的对象。</p>
<p>跟其他用户自定义的标记 trait（<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>）相比，<code>Copy</code> 对编译器有着比作为 trait bound 以外更特殊的意义（和其他 <code>std::marker</code> 中的其他几个 trait 一样）——它使编译器在处理类型的时候从<em>移动语意</em>变成<em>拷贝语义</em>。</p>
<p>在移动语义的场景下，赋值运算符会把运算符右侧的内容，拿走并赋值给左边：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
struct KeyId(u32);

let k = KeyId(42);
let k2 = k; // value moves out of k into k2
println!("k = {k:?}");
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: borrow of moved value: `k`
  --&gt; src/main.rs:60:23
   |
58 |         let k = KeyId(42);
   |             - move occurs because `k` has type `main::KeyId`, which does
   |               not implement the `Copy` trait
59 |         let k2 = k; // value moves out of k into k2
   |                  - value moved here
60 |         println!("k = {k:?}");
   |                       ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl`
help: consider cloning the value if the performance cost is acceptable
   |
59 |         let k2 = k.clone(); // value moves out of k into k2
   |                   ++++++++
</code></pre>
<p>而使用拷贝语义的话，被用于赋值的变量在赋值过后依然存在：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]
struct KeyId(u32);

let k = KeyId(42);
let k2 = k; // value bitwise copied from k to k2
println!("k = {k:?}");
<span class="boring">}</span></code></pre></pre>
<p>这使得 <code>Copy</code> 成为了最需要注意的 trait 之一：它从根本上改变了赋值的行为——包括方法调用时候的传参。</p>
<p>在这方面，这跟 C++ 的拷贝构造函数又有相似了，但是值得强调的一个关键区别在于：在 Rust 里面没有办法让编译器隐式调用用户定义的代码——要调用的话必须显式指定（比如使用 <code>.clone()</code>），或者让编译器执行并非由用户定义的代码（按比特位的拷贝动作）。</p>
<p>因为 <code>Copy</code> 具有 <code>Clone</code> trait 的特性，所以是可以 <code>.clone()</code> 任意一个满足 <code>Copy</code> 的对象的。但是这不是一个好的主义：按位拷贝总是会比调用 trait 方法要快。Clippy（<a href="https://www.lurklurk.org/effective-rust/clippy.html">第 29 条</a>）会提示你：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let k3 = k.clone();
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">warning: using `clone` on type `KeyId` which implements the `Copy` trait
  --&gt; src/main.rs:79:14
   |
79 |     let k3 = k.clone();
   |              ^^^^^^^^^ help: try removing the `clone` call: `k`
   |
</code></pre>
<p>跟讨论 <code>Clone</code> 的时候类似，何时应该或不应该实现 <code>Copy</code> 也是值得探讨的：</p>
<ul>
<li>显而易见：<strong>如果按比特位拷贝不能生成有效的新对象，不要实现 <code>Copy</code></strong>。如果 <code>Clone</code> 需要手动而不是通过 <code>derive</code> 实现，那么很有可能是这种情况。</li>
<li>如果你的类型比较大，实现 <code>Copy</code> 可能是个坏主意。<code>Copy</code> 的基本约定是安比特位拷贝是合法的，然而这也通常隐含一个假设：拷贝是很快速的。如果你的类不符合这样的要求，不实现 <code>Copy</code> 可以阻止意外的耗时拷贝的发生。</li>
<li>如果你的类型中某些部分不是 <code>Copy</code> 的那么你也<em>不能</em>为类型实现 <code>Copy</code>。</li>
<li>如果你的类型中所有部分都是 <code>Copy</code> 的，那么通常也值得为你的类型 derive 一个 <code>Copy</code>。编译器有一个默认的提示项 <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#missing-copy-implementations">missing_copy_implementations</a> 来指出这种情况。</li>
</ul>
<h1 id="default"><a class="header" href="#default"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a></a></h1>
<p><code>Default</code> trait 通过 <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default()</a> 方法定义了一个<em>默认构造函数</em>。如果用户定义类型的内含类型都有 <code>Default</code> 的实现，那么类型可以通过 <code>derive</code> 来实现这个 trait；如果内含类型并非都实现了 <code>Default</code>，那么用户需要手动为类型实现 这个 trait。还是跟 C++ 做比较：在 Rust 中需要显式地定义默认构造函数——编译器不会自动帮你创建。</p>
<p><code>enum</code> 类型也可以通过 <code>derive</code> 实现 <code>Default</code> trait，只要给编译器提供一个 <code>#[default]</code> 属性来提示编译器哪一个分支是默认值即可：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum IceCreamFlavor {
    Chocolate,
    Strawberry,
    #[default]
    Vanilla,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Default</code> trait 最有用的一个场景是和结构体更新语法 <a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax">struct update syntax</a> 组合使用。这个语法允许 <code>struct</code> 实例通过从同一种 <code>struct</code> 的实例中拷贝或者移动内容来初始化自身尚未尚未显式初始化的字段。要被拷贝的模板在初始化结束的时候给出，放在 <code>..</code> 之后，<code>Default</code> trait 提供了一个理想的模板供使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
    alpha: u8,
}

let c = Color {
    red: 128,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>这使得初始化具有大量字段，但仅有部分字段不是使用默认值的结构体变得更加容易。（构造器模式，<a href="https://www.lurklurk.org/effective-rust/builders.html">第 7 条</a>，或许对于这种场景也是适用的）。</p>
<h2 id="partialeq-和-eq"><a class="header" href="#partialeq-和-eq"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a> 和 <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a></a></h2>
<p><code>PartialEq</code> 和 <code>Eq</code> trait 允许你为用户定义的类型定义相等性。这些 trait 尤其重要，因为如果这些 trait 被定义了，编译器会自动在相等性（<code>==</code>）判断的时候调用相关逻辑，类比于 C++ 中的 <code>operator==</code>。<code>derive</code> 来的实现会执行逐字段的相等性判断。</p>
<p><code>Eq</code> 版本只是一个标记 trait，用于扩展 <code>PartialEq</code>，它添加了<em>自反性</em>：任何声明了 <code>Eq</code> 的类型 <code>T</code>，对于任意的实例 <code>x: T</code> 都应该保证有 <code>x == x</code>。</p>
<p>这很奇怪，你会立即提出这个问题：什么时候 <code>x == x</code> 是不成立的？对相等性的这种拆分主要跟浮点数 <a href="#footnote-1">floating point numbers</a>。 有关，尤其是涉及到“不是数字”这个 NaN 值（对应 Rust 中的 <code>f32:NAN</code>/<code>f64:NAN</code>）。浮点数的标准要求任何东西不会等于 NaN，<em>包括 Nan 自身</em>；<code>PartialEq</code> trait 的存在就是这种要求的连锁反应。</p>
<p>对于没有任何浮点数相关的特性的用户自定义类型，<strong>你应该在实现 <code>PartialEq</code> 的同时也实现 <code>Eq</code></strong>。如果你要把类型当作 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a> 类型的 key，完整的 <code>Eq</code> trait 也是需要实现的（同样还有 <code>Hash</code> trait）。</p>
<p>如果类型包含一些不影响区分相等性的字段（如内部缓存或者其他类型的性能优化），则应该手动实现 <code>PartialEq</code>。如果 <code>Eq</code> 也被定义了，实现也将用于 <code>Eq</code>，因为 <code>Eq</code> 只是一个标记 trait，它内部并没有任何方法。</p>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a> 和 <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a></p>
<p>排序 trait <code>PartialOrd</code> 和 <code>Ord</code> 允许比较同一类型的两个实现，并返回 <code>Less</code>、<code>Greater</code> 或 <code>Equal</code> 之一。这两个 trait 需要对应的相等性 trait 有对应的实现（<code>PartialOrd</code> 要求 <code>PartialEq</code>; <code>Ord</code> 要求 <code>Eq</code>），并且对应的两个必须逻辑自洽（手动实现的时候尤其要注意）。</p>
<p>跟相等性 trait 一样，比较 traits 也很重要，因为编译器会在比较运算中使用到它们（<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>）。</p>
<p><code>derive</code> 产生的默认实现会按照字段（或 <code>enum</code> 的不同 variant）定义的顺序，按照字典序进行比较。如果这不符合预期结果则需要手动实现特征（或者对字段进行重新排序）。</p>
<p>跟 <code>PartialEq</code> 不同的是，<code>PartialOrd</code> trait 确实对应各种真实发生的场景。比如说，它可以用于表示集合之间的子集关系(#footnote-2)：<code>{1, 2}</code> 是 <code>{1, 2, 4}</code> 的子集，但 <code>{1, 3}</code> 不是 <code>{2, 4}</code> 的子集，反之亦然。</p>
<p>但是，即使偏序关系准确地描述了你的类型的行为，<strong>要小心仅仅实现了 <code>PartialOrd</code> 而没有实现 <code>Ord</code> 的场景</strong>（这种情况很少见，它与 <a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a> 中将行为编码到类型系统中的建议相违背）——它可能会导致令人惊讶的结果：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Inherit the `PartialOrd` behavior from `f32`.
// 从 `f32` 继承 `PartialOrd`
#[derive(PartialOrd, PartialEq)]
struct Oddity(f32);

// Input data with NaN values is likely to give unexpected results.
// NaN 值的输入可能会给出意想不到的结果。
let x = Oddity(f32::NAN);
let y = Oddity(f32::NAN);

// A self-comparison looks like it should always be true, but it may not be.
// 一个看起来应该总是成立的自我比较，但也可能不成立。
if x &lt;= x {
    println!("This line doesn't get executed!");
}

// Programmers are also unlikely to write code that covers all possible
// comparison arms; if the types involved implemented `Ord`, then the
// second two arms could be combined.
// 程序员也不太可能写出覆盖所有可能的比较分支；如果涉及的类型实现了 `Ord`，那么后两种情况可以合并。
if x &lt;= y {
    println!("y is bigger"); // Not hit.
} else if y &lt; x {
    println!("x is bigger"); // Not hit.
} else {
    println!("Neither is bigger");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hash"><a class="header" href="#hash"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a></a></h2>
<p><code>Hash</code> trait 用于给某个对象生成一个大概率与其他对象不相同的值。这个哈希值通常用于一些基于哈希桶的数据结构，比如 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a> 和 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashSet</a>；因此，这些数据结构中的 key 类型必须实现 <code>Hash</code> （和 <code>Eq</code>）。</p>
<p>反过来说，“相同”的项（以 <code>Eq</code> 来说）必须产生一样的的哈希值：如果 <code>x  y</code> （通过 <code>Eq</code>），那么 <code>hash(x)  hash(y)</code> 必须始终为真。**如果你手动实现了 <code>Eq</code>，那么要检查确认你是否也需要手动实现 <code>Hash</code>**以满足上述要求。</p>
<h2 id="debug-和-display"><a class="header" href="#debug-和-display"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> 和 <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a></a></h2>
<p><code>Debug</code> 和 <code>Display</code> trait 允许类型定义它在输出中应该怎么显示，这包括常规显示（<code>{}</code> 格式化参数）和调试（<code>{:?}</code> 格式化参数）目的，这大致类似于 C++ 中对 <code>iostream</code> 的 <code>operator&lt;&lt;</code> 重载。</p>
<p>这两个 trait 的设计意图差异不仅仅在于格式化占位符的不同，还包括：</p>
<ul>
<li><code>Debug</code> 可以自动派生 <code>derive</code> 获得，而 <code>Display</code> 只能手动实现。</li>
<li><code>Debug</code> 的输出格式在不同的 Rust 版本下可能会不一样。如果输出需要被其他的代码做解析，那么使用 <code>Display</code>。</li>
<li><code>Debug</code> 是面向程序员的， <code>Display</code> 是面向用户的。一个有助于理解这个场景的头脑风暴是：如果程序被本地化到程序作者不懂的语言会发生什么——如果显示的内容应该被翻译，那么使用 <code>Display</code> 是合适的，否则就应该使用 <code>Debug</code>。</li>
</ul>
<p>通常来说，<strong>给你的类型添加一个自动生成的 <code>Debug</code> 实现是个不错的选择</strong>，除非类型里面包含一些敏感信息（个人详细信息、密码相关的内容等）。为了更容易遵守这个规则，Rust 编译器有一个提示 <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#missing-debug-implementations">missing_debug_implementations </a> 可以指出没有实现 <code>Debug</code> 的类型。这个提示默认是禁用的，但可以通过以下任一方式在你的代码中启用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(missing_debug_implementations)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![deny(missing_debug_implementations)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>如果自动生成的 <code>Debug</code> 实现输出了太多细节信息，那么或许手动实现并且汇总一下类型里面的内容会更好一点。</p>
<p>如果你的类型要作为文本向最终用户显示，那么就实现 <code>Display</code>。</p>
<h2 id="其他条款描述的标准库-trait"><a class="header" href="#其他条款描述的标准库-trait">其他条款描述的标准库 trait</a></h2>
<p>除了前面章节描述的常见 trait，标准库还包含其他没那么常见的 trait。在这些之中，以下是最重要的，但它们都在其他条款中有所介绍，因此这里不会详细地介绍：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a>，<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a>：实现了这些 trait 的对象代表它们是可以被调用的闭包。见<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/error/trait.Error.html">Error</a>：实现了这个 trait 的对象可以向用户或程序员呈现错误信息，并且可能包含嵌套的子错误信息。见<a href="https://www.lurklurk.org/effective-rust/errors.html">第 4 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a>：实现了这个 trait 的对象会在它们被销毁的时候执行动作，这对于 RAII 模式来说是至关重要的。见<a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom</a>：实现了这些 trait 的对象，可以自动从别的类型的实例中转换过来，但后一个 trait 表示转换可能会失败。见<a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html">DerefMut</a>：实现了这些 trait 的对象是类似于指针的对象，它们可以被解引用以获得对内部对象的访问。见<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>。</li>
<li><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a> 及相关：实现了这些 trait 的对象表示可以它是一个可以被迭代的集合。见<a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html">Send</a>：实现了这个 trait 的对象可以在多个线程之间安全地传输。见<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a>：实现了这个 trait 的对象可以在多个线程之间被安全地引用。见<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>。</li>
</ul>
<p>这些 trait 都不能被直接 <code>derive</code> 获得。</p>
<h2 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h2>
<p>标准库 trait 的最后一个类别跟运算符重载有关，Rust 允许用户自定义类型通过实现 <a href="https://doc.rust-lang.org/std/ops/index.html">std::ops</a> 模块里面的标准库 trait，对内置的单目和双目运算符进行重载。这些 trait 不能通过 <code>derive</code> 获得，通常仅用于表示“代数”类型的对象，对于这些类型来说这些运算符都有很自然的解释。</p>
<p>然而，C++ 中的经验表明，最好<strong>避免对不相关的类型进行运算符重载</strong>，因为它通常会导致代码难以维护，也可能会出现一些意外的性能问题（比如，一个 <code>x + y</code> 操作调用了一个开销为 O(N) 方法）。</p>
<p>为了遵循最小惊讶原则，如果你实现了任何一个运算符重载，那么你应该<strong>实现一系列相关的运算符的重载</strong>。打个比方，如果 <code>x + y</code> 有一个重载（<a href="https://doc.rust-lang.org/std/ops/trait.Add.html">Add</a>），并且 <code>-y</code>（<a href="https://doc.rust-lang.org/std/ops/trait.Neg.html">Neg</a>）也有，那么你应该实现 <code>x - y</code>（<a href="https://doc.rust-lang.org/std/ops/trait.Sub.html">Sub</a>）并确保它给出和 <code>x + (-y)</code> 一样的结果。</p>
<p>传递给运算符重载 trait 方法的对象会被移动掉，这意味着非 <code>Copy</code> 的类型默认会被消耗掉。为 <code>&amp;'a MyType</code> 实现这些 trait 可以帮助解决这个问题，但需要更多的样板代码来覆盖所有的可能性（比如，对于双目运算符，入参类型可以是引用/非引用，就有 4 = 2 × 2 种可能性）。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>这个条款已经涵盖了很多方便，下面按序给出了一些表格，总结了我们谈论到的标准库 trait。首先，表格 2-1 涵盖了这个条款深入讲述过的 trait，除了 <code>Display</code> 以外，所有这些 trait 都能通过 <code>derive</code> 获得实现。</p>
<p><em>表格 2-1. 常见的标准库 trait</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">编译器使用</th><th style="text-align: center">约束</th><th style="text-align: left">方法</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">clone</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a></td><td style="text-align: center"><code>let y = x;</code></td><td style="text-align: center"><code>Clone</code></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/default/trait.Default.html">default</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">eq</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a></td><td style="text-align: center"><code>x &lt; y</code>, <code>x &lt;= y</code>, …</td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html#tymethod.partial_cmp">partial_cmp</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a></td><td style="text-align: center"><code>x &lt; y</code>, <code>x &lt;= y</code>, …</td><td style="text-align: center"><code>Eq</code> + <code>PartialOrd</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html#tymethod.cmp">cmp</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">hash</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a></td><td style="text-align: center"><code>format!("{:?}", x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt">fmt</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a></td><td style="text-align: center"><code>format!("{}", x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt">fmt</a></td></tr>
</tbody></table>
</div>
<p>运算符重载相关的 trait 在表格 2-2 (#footnote-3) 中总结了。它们都不能通过 <code>derive</code> 获得。</p>
<p><em>表格 2-2. 运算符重载 trait</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">编译器使用</th><th style="text-align: center">约束</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html">Add</a></td><td style="text-align: center"><code>x + y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html">add</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">AddAssign</a></td><td style="text-align: center"><code>x += y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html#tymethod.add_assign">add_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html">BitAnd</a></td><td style="text-align: center"><code>x &amp; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html">bitand</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html">BitAndAssign</a></td><td style="text-align: center"><code>x &amp;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html#tymethod.bitand_assign">bitand_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html">BitOr</a></td><td style="text-align: center"><code>x ⎮ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html">bitor</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html">BitOrAssign</a></td><td style="text-align: center"><code>x ⎮= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html#tymethod.bitor_assign">bitor_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html">BitXor</a></td><td style="text-align: center"><code>x ^ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html">bitxor</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html">BitXorAssign</a></td><td style="text-align: center"><code>x ^= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html#tymethod.bitxor_assign">bitxor_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html">Div</a></td><td style="text-align: center"><code>x / y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html">div</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html">DivAssign</a></td><td style="text-align: center"><code>x /= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html#tymethod.div_assign">div_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">Mul</a></td><td style="text-align: center"><code>x * y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">mul</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html">MulAssign</a></td><td style="text-align: center"><code>x *= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html#tymethod.mul_assign">mul_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html">Neg</a></td><td style="text-align: center"><code>-x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html">neg</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html">Not</a></td><td style="text-align: center"><code>!x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html">not</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html">Rem</a></td><td style="text-align: center"><code>x % y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html">rem</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html">RemAssign</a></td><td style="text-align: center"><code>x %= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html#tymethod.rem_assign">rem_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html">Shl</a></td><td style="text-align: center"><code>x &lt;&lt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html">shl</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html">ShlAssign</a></td><td style="text-align: center"><code>x &lt;&lt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html#tymethod.shl_assign">shl_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html">Shr</a></td><td style="text-align: center"><code>x &gt;&gt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html">shr</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html">ShrAssign</a></td><td style="text-align: center"><code>x &gt;&gt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html#tymethod.shr_assign">shr_assign</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html">Sub</a></td><td style="text-align: center"><code>x - y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html">sub</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html">SubAssign</a></td><td style="text-align: center"><code>x -= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html#tymethod.sub_assign">sub_assign</a></td></tr>
</tbody></table>
</div>
<p>为完整起见，在其他条款中提及的 trait 在表格 2-3 中涵盖了。这些 trait 都不能通过 <code>derive</code> 获得（但是 <code>Send</code> 和 <code>Sync</code> 可能由编译器自动实现）。</p>
<p><em>表格 2-3. 在其他条款中提及的 trait</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">条款</th><th style="text-align: center">编译器使用</th><th style="text-align: center">约束</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnMut</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call">call</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnOnce</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html#tymethod.call_mut">call_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#tymethod.call_once">call_once</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/error/trait.Error.html">Error</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/errors.html">第 4 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Display</code> + <code>Debug</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source">source</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.From.html">from</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html#tymethod.try_from">try_from</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.Into.html">into</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html">TryInto</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/casts.html">第 5 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#tymethod.try_into">try_into</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref">as_ref</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html">AsMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut">as_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">Borrow</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">borrow</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html">BorrowMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Borrow</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut">borrow_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html">ToOwned</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned">to_owned</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">deref</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html">DerefMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;mut x</code></td><td style="text-align: center"><code>Deref</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html#tymethod.deref_mut">deref_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html">Index</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>x[idx]</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html">index</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html">IndexMut</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>x[idx] = ...</code></td><td style="text-align: center"><code>Index</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html#tymethod.index_mut">index_mut</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html">Pointer</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a></td><td style="text-align: center"><code>format("{:p}", x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt">fmt</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next">next</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html">IntoIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"><code>for y in x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html">FromIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html#tymethod.from_iter">from_iter</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html">ExactSizeIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left">（<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.size_hint">size_hint</a>）</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html">DoubleEndedIterator</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/iterators.html">第 9 条</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back">next_back</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a></td><td style="text-align: center"><code>}</code> （作用域结束）</td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">drop</a></td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">Sized</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/generics.html">第 12 条</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Send.html">Send</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a></td><td style="text-align: center">跨线程传递</td><td style="text-align: center"></td><td style="text-align: left">标记 trait</td></tr>
<tr><td style="text-align: left"><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a></td><td style="text-align: center"><a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a></td><td style="text-align: center">跨线程使用</td><td style="text-align: center"></td><td style="text-align: left">标记 trait</td></tr>
</tbody></table>
</div>
<p><a id="footnote-1">1</a>:当然，比较浮点数总是一个危险的游戏，因为通常情况下没法保证精度舍入计算会产生跟最初设想的数字（按比特值存储）完全相同的结果。</p>
<p><a id="footnote-2">2</a>:更一般地说，任何序论中的“格” <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice structure</a> 都具有偏序性质。</p>
<p><a id="footnote-3">3</a>:这里的一些名称有点隐晦——例如 <code>Rem</code> 是求余数，<code>Shl</code> 是按位左移——但是 <a href="https://doc.rust-lang.org/std/ops/index.html">std::ops</a> 的文档清楚第说明了它们的预期行为。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_2/item11-impl-drop-for-RAII.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_2/item11-impl-drop-for-RAII.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../style/js/tongji.js"></script>
        <script src="../style/js/ferris.js"></script>


    </div>
    </body>
</html>
