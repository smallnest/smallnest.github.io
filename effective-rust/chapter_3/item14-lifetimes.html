<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 14 条：理解生命周期 - Effective Rust 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="../intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="../intro.html">介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="../chapter_1/item2-use-types-2.html"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="../chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="../chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="../chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="../chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="../chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item9-iterators.html"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/item10-std-traits.html"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="../chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="../chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="../chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/item14-lifetimes.html" class="active"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="../chapter_3/item15-borrows.html"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="../chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="../chapter_3/item17-deadlock.html"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="../chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="../chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="../chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="../chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="../chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-14-条理解生命周期"><a class="header" href="#第-14-条理解生命周期">第 14 条：理解生命周期</a></h1>
<p>这一条描述了 Rust 的生命周期，这是对先前的编译型语言（像 C 和 C++）中存在的概念的更精确的表述——不仅仅在理论上，更是在实践中。生命周期是<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>中描述的<em>借用检查器</em>的必要标注；总的来说，这些功能构成了 Rust 内存安全保证的核心。</p>
<h2 id="介绍一下栈"><a class="header" href="#介绍一下栈">介绍一下栈</a></h2>
<p>生命周期在根本上跟栈有关，所以快速过一遍栈的知识。</p>
<p>当一个程序运行时，内存会被分成不同的区块，有时被称为<em>段</em>。其中一些块是固定大小的，比如包含程序代码和全局变量的块，但是有两个块——<em>堆</em>和<em>栈</em>——会随着程序运行而改变大小。为了实现这一点，堆和栈通常排列在程序虚拟内存的两端，因此一个可以向下增长，另外一个可以向上增长（至少在你的程序耗尽了内存并崩溃之前），如图 3-1 所示。</p>
<img src="../images/item14/memorylayout.svg" width="300" height="420">
<p><em>图 3-1. 程序内存布局，包括堆向上增长和栈向下增长</em></p>
<p>对于这两个动态大小的块来说，栈用来保存与当前执行的函数相关的状态。该状态可能包含以下元素：</p>
<ul>
<li>传递给函数的参数</li>
<li>函数中的局部变量</li>
<li>函数计算的临时值</li>
<li>函数调用者在代码中的返回地址</li>
</ul>
<p>当调用函数<code>f()</code>，一个新的栈帧(stack frame)会被添加到栈中，当超出栈帧结束的位置时，CPU 通常会更新<em>栈指针</em>寄存器，去指向新的栈帧。</p>
<p>当内部函数<code>f()</code>返回，栈指针会被重置到调用函数之前的位置，也就是调用者的完整且未修改的栈帧。</p>
<p>如果调用者随后调用了一个不同的函数<code>g()</code>，这个过程会再次发生，这意味着<code>g()</code>的栈帧将复用<code>f()</code>先前使用的同一块内存区域（如图 3-2 所示）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn caller() -&gt; u64 {
    let x = 42u64;
    let y = 19u64;
    f(x) + g(y)
}

fn f(f_param: u64) -&gt; u64 {
    let two = 2u64;
    f_param + two
}

fn g(g_param: u64) -&gt; u64 {
    let arr = [2u64, 3u64];
    g_param + arr[1]
}
<span class="boring">}</span></code></pre></pre>
<p><img src="../images/item14/stackuse.svg" alt="图 3-2" /></p>
<p><em>图 3-2. 随着函数调用和返回，栈使用的演变</em></p>
<p>当然，这是实际情况的极大简化之后的版本——将东西放入栈或取出栈需要时间，所以实际上处理器会有很多优化。然而，这个简化的概念图已经足以理解本条的主题。</p>
<h2 id="生命周期的演化"><a class="header" href="#生命周期的演化">生命周期的演化</a></h2>
<p>上一小节解释了参数和局部变量是如何在栈上存储的，同时指出了这些值只是临时存储的。</p>
<p>从历史上来说，这会允许出现一些危险情况：当你持有一个指向这些栈上临时值的指针，会发生什么？</p>
<p>对最开始的 C 来说，返回局部变量的指针是完全可以的（尽管现代编译器会警告）：</p>
<div class="ferris"><img src="../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><code class="language-c">/* C code. */
struct File {
  int fd;
};

struct File* open_bugged() {
  struct File f = { open("README.md", O_RDONLY) };
  return &amp;f;  /* return address of stack object! */
}
</code></pre>
<p>如果你不幸并且立刻使用了调用代码的返回值，你<em>或许</em>会避开这段代码导致的问题：</p>
<pre><code class="language-c">struct File* f = open_bugged();
printf("in caller: file at %p has fd=%d\n", f, f-&gt;fd);
</code></pre>
<pre><code>in caller: file at 0x7ff7bc019408 has fd=3
</code></pre>
<p>这是不幸的，因为它只是<em>看起来</em>有效。一旦发生任何其他函数调用，栈区域被复用，并且用于保存对象的区域将会被覆盖：</p>
<pre><code class="language-c">investigate_file(f);
</code></pre>
<pre><code class="language-c">/* C code. */
void investigate_file(struct File* f) {
  long array[4] = {1, 2, 3, 4}; // put things on the stack
  printf("in function: file at %p has fd=%d\n", f, f-&gt;fd);
}
</code></pre>
<pre><code>in function: file at 0x7ff7bc019408 has fd=1592262883
</code></pre>
<p>这个示例中，丢弃对象的内容会产生额外的不良副作用：打开的文件对应的文件描述符丢失了，因此程序泄漏了结构体中保存的资源。</p>
<p>发展到 C++后，失去资源访问权的问题通过包含<em>析构函数</em>得到了解决，从而启用了 RAII（参考<a href="/chapter_2/item11-impl-drop-for-RAII.html">第 11 条</a>）。现在，栈上的东西有了自我清理的能力：如果对象持有某种资源，析构函数可以清理它，并且 C++编译器确保了在清理栈帧的过程中调用栈上对象的析构函数：</p>
<pre><code class="language-cpp">// C++ code.
File::~File() {
  std::cout &lt;&lt; "~File(): close fd " &lt;&lt; fd &lt;&lt; "\n";
  close(fd);
  fd = -1;
}
</code></pre>
<p>调用者现在获得了一个指向已被销毁并且它的资源已经被回收的对象的（无效）指针：</p>
<pre><code class="language-cpp">File* f = open_bugged();
printf("in caller: file at %p has fd=%d\n", f, f-&gt;fd);
</code></pre>
<pre><code>~File(): close fd 3
in caller: file at 0x7ff7b6a7c438 has fd=-1
</code></pre>
<p>然而，C++没有采取任何措施来解决悬垂指针的问题：持有一个指向已经销毁对象（通过调用析构函数）的指针仍是可能的：</p>
<pre><code class="language-cpp">// C++ code.
void investigate_file(File* f) {
  long array[4] = {1, 2, 3, 4}; // put things on the stack
  std::cout &lt;&lt; "in function: file at " &lt;&lt; f &lt;&lt; " has fd=" &lt;&lt; f-&gt;fd &lt;&lt; "\n";
}
</code></pre>
<pre><code>in function: file at 0x7ff7b6a7c438 has fd=-183042004
</code></pre>
<p>作为一个 C/C++程序员，取决于你来注意这一点，并确保你不会解引用一个指向已消失内容的指针。或者，如果你是一名攻击者并且发现一个悬垂指针，那么你很可能疯狂地咯咯笑，并且利用该漏洞，兴高采烈地解引用该指针。</p>
<p>对于 Rust 来说。Rust 核心吸引力就是从根本上解决了悬垂指针的问题，这立即解决了一堆安全问题。<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>为了这一点需要把生命周期的概念从后台（C/C++程序员只需要知道注意它们，没有任何语言支持）拿到前台来：每个包含<code>&amp;</code>符号的类型都有一个关联的生命周期(<code>'a</code>)，即使编译器允许你在大部分时间忽略它。</p>
<h2 id="生命周期的作用域"><a class="header" href="#生命周期的作用域">生命周期的作用域</a></h2>
<p>一个在栈上的数据的生命周期是保证它在栈上同一个位置的时间段；换句话说，生命周期是保证对该数据的<em>引用</em>（指针）不会变得无效的时间段。</p>
<p>一个数据的生命周期从被创建开始，一直到该数据<em>被 drop</em>（Rust 中与 C++中对象销毁相同的概念）或<em>被移动</em>。</p>
<p>Rust 中生命周期的普遍性有时会让来自 C/C++的程序员惊讶：很多情况下，Rust 将数据从栈上的一个位置移动到另一个位置，或者从栈移动到堆上，或者从堆移动到栈上。</p>
<p>该数据被自动 drop 的确切位置取决于该数据是否有一个名称。</p>
<p>局部变量和函数参数都提供了名称，并且对应的生命周期从该数据有名称开始：</p>
<ul>
<li>对于局部变量：在<code>let var = ...</code>处声明</li>
<li>对于函数参数：作为函数调用执行框架设置的一部分</li>
</ul>
<p>当有名称的数据被移动或者名称超出范围，该命名数据的生命周期就会结束：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
/// 某数据的定义
pub struct Item {
    contents: u32,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let item1 = Item { contents: 1 }; // `item1` 数据 1 在此创建
    let item2 = Item { contents: 2 }; // `item2` 数据 2 在此创建
    println!("item1 = {item1:?}, item2 = {item2:?}");
    consuming_fn(item2); // `item2` 数据 2 在此被移动
} // `item1` 数据 1 在此被drop
<span class="boring">}</span></code></pre></pre>
<p>还可以“即时”地创建一个数据，作为要传入到其他数据的一部分。这些未命名的数据在不再需要时被 drop。考虑这个问题一个简单但有效的方法是想象表达式的每个部分都会展开它自己的块，通过编译器插入临时变量。例如，这样的表达式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = f((a + b) * 2);
<span class="boring">}</span></code></pre></pre>
<p>大致相当于：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {
    let temp1 = a + b;
    {
        let temp2 = temp1 * 2;
        f(temp2)
    } // `temp2` 临时数据 2 在这里drop
}; // `temp1` 临时数据 1 在这里drop
<span class="boring">}</span></code></pre></pre>
<p>当执行到原始行末尾的分号时，临时数据已经全部被 drop。</p>
<p>查看编译器计算数据生命周期的一种方法是插入一个故意的错误，来让借用检查器（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）检测。例如，保留对超出生命周期的数据的引用：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: &amp;Item;
{
    let item = Item { contents: 42 };
    r = &amp;item;
}
println!("r.contents = {}", r.contents);
<span class="boring">}</span></code></pre></pre>
<p>错误消息会指明<code>item</code>的生命周期的确切终点：</p>
<pre><code>error[E0597]: `item` does not live long enough
   --&gt; src/main.rs:190:13
    |
189 |         let item = Item { contents: 42 };
    |             ---- binding `item` declared here
190 |         r = &amp;item;
    |             ^^^^^ borrowed value does not live long enough
191 |     }
    |     - `item` dropped here while still borrowed
192 |     println!("r.contents = {}", r.contents);
    |                                 ---------- borrow later used here
</code></pre>
<p>同样的，对于未命名的临时数据：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
println!("r.contents = {}", r.contents);
<span class="boring">}</span></code></pre></pre>
<p>错误消息显示了表达式末尾的终点：</p>
<pre><code>error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:209:46
    |
209 | let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
    |                                      ^^^^^^^^^^^^^^^^^^^^^ - temporary
    |                                      |           value is freed at the
    |                                      |           end of this statement
    |                                      |
    |                                      creates a temporary value which is
    |                                      freed while still in use
210 | println!("r.contents = {}", r.contents);
    |                             ---------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>关于<em>引用</em>生命周期的最后一点：如果编译器可以自证代码中某处之外没有再使用该引用，那么它将引用的生命周期的末尾端点视为最后使用的位置，而不是在一个中括号范围的末尾。这个特性被称为<a href="https://rust-lang.github.io/rfcs/2094-nll.html">非词法生命周期</a>（NLL），这允许借用检查器更灵活一些：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // `s` 拥有 `String`。
    let mut s: String = "Hello, world".to_string();

    // 创建一个 `String` 的可变引用
    let greeting = &amp;mut s[..5];
    greeting.make_ascii_uppercase();
    // .. 在这之后没再使用 `greeting`

    // 创建一个 `String` 的不可变引用是允许的，
    // 即使这里有一个可变引用还在该中括号范围内
    let r: &amp;str = &amp;s;
    println!("s = '{}'", r); // s = 'HELLO, world'
} // 可变引用 `greeting` 会在这里被drop
<span class="boring">}</span></code></pre></pre>
<h2 id="生命周期标注"><a class="header" href="#生命周期标注">生命周期标注</a></h2>
<p>尽管 Rust 中处理引用时生命周期无处不在，但是你不必详细标注——没有人会说：“我正在处理<code>ref.rs</code>从第 17 行延伸到第 32 行的生命周期”。相反，代码中的引用有任意名称的生命周期，通常是<code>'a</code>，<code>'b</code>，<code>'c</code>等等，并且编译器有其自己的内部，不可访问的表示形式，这些表示形式相当于源代码中内容。（唯一例外是<code>'static</code>生命周期，这是一个特殊情况，后续将会介绍。）</p>
<p>你不必对生命周期的名称考虑太多；主要考虑的事情是比较一个名称和另一个名称，或重复名称来标注两个生命周期是“相同的”。</p>
<p>这种生命周期标注最容易用函数签名来说明：如果函数的输入和输出需要处理引用，那么它们的生命周期之间是什么关系？</p>
<p>最常见的情况就是接收单个引用作为输入并返回一个引用的函数。返回的引用必须有一个生命周期，那么是什么呢？这里只有一种可能（除了<code>'static</code>）可供选择：输入的生命周期，这意味着它们共享相同的名称，例如<code>'a</code>。把该名称作为生命周期标注，添加给这两个类型会得到：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn first&lt;'a&gt;(data: &amp;'a [Item]) -&gt; Option&lt;&amp;'a Item&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>因为这种情况非常常见，并且因为（几乎）没有选择关于输出的生命周期应该是什么，Rust 具有<em>生命周期省略</em>规则，这意味着你不必为这种情况显式标注生命周期名称。相同的函数签名更惯用的版本应该是这样的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn first(data: &amp;[Item]) -&gt; Option&lt;&amp;Item&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>所涉及的引用仍具有生命周期——省略规则只是意味着你不必编写任何生命周期名称并在这两个地方使用它。</p>
<p>如果有不止一种输入的生命周期选择可以映射到返回值的生命周期呢？这种情况下，编译器无法弄清楚该怎么做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:56:55
   |
56 | pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {
   |                       -----          -----            ^ expected named
   |                                                     lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
           signature does not say whether it is borrowed from `haystack` or
           `needle`
help: consider introducing a named lifetime parameter
   |
56 | pub fn find&lt;'a&gt;(haystack: &amp;'a [u8], needle: &amp;'a [u8]) -&gt; Option&lt;&amp;'a [u8]&gt; {
   |            ++++            ++                ++                  ++
</code></pre>
<p>基于函数和参数名称的精明的假设是，此处输出的预期生命周期应该和输入的<code>haystack</code>匹配：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find&lt;'a, 'b&gt;(
    haystack: &amp;'a [u8],
    needle: &amp;'b [u8],
) -&gt; Option&lt;&amp;'a [u8]&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>有趣的是，编译器建议了一种不同的替代方式：让函数的两个输入使用<em>相同的</em>生命周期<code>'a</code>。例如，以下这个函数其中的生命周期组合或许会有意义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn smaller&lt;'a&gt;(left: &amp;'a Item, right: &amp;'a Item) -&gt; &amp;'a Item {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>这<em>似乎</em>暗示输入的两个生命周期是“一样的”，但这话用了引号（这里和之前）表明情况并非如此。</p>
<p>设计生命周期的原因就是确保数据的引用不会活得比数据本身更长；考虑这点，输出的生命周期<code>'a</code>与输入的生命周期<code>'a</code>“相同”，只是意味着输入必须比输出活得久。</p>
<p>当两个生命周期都是“相同的”<code>'a</code>时，这仅意味着输出的生命周期必须包含在两个输入的生命周期内。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let outer = Item { contents: 7 };
    {
        let inner = Item { contents: 8 };
        {
            let min = smaller(&amp;inner, &amp;outer);
            println!("smaller of {inner:?} and {outer:?} is {min:?}");
        } // `min` dropped
    } // `inner` dropped
} // `outer` dropped
<span class="boring">}</span></code></pre></pre>
<p>换句话说，输出的生命周期必须包含在两个输入寿命中<em>较小的</em>那一个。</p>
<p>相反，如果生命周期与输入之一的生命周期无关，则不需要这些生命周期嵌套。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let haystack = b"123456789"; // 生命周期 'a 开始
    let found = {
        let needle = b"234"; // 生命周期 'b 开始
        find(haystack, needle)
    }; // 生命周期 'b 结束
    println!("found={:?}", found); // `found` 在 'a 内部， 在 'b 外部使用
} // 声明周期 'a 结束
<span class="boring">}</span></code></pre></pre>
<h2 id="生命周期省略规则"><a class="header" href="#生命周期省略规则">生命周期省略规则</a></h2>
<p>除了前面描述的“一入，一出”的省略规则之外，还有另外两种可以省略标注名称的规则。</p>
<p>第一种情况是函数的输出没有引用；这种情况下，输入的引用都会自动获得自己的生命周期，且与其他输入的参数不同。</p>
<p>第二种情况是方法中有<code>self</code>的引用（<code>&amp;self</code>或<code>&amp;mut self</code>）；这种情况下，编译器会假设任何输出的引用的生命周期与<code>self</code>相同，因为这（到目前为止）是最常见的情况。</p>
<p>以下是函数生命周期省略规则的总结：</p>
<ul>
<li>一个输入，一个或者多个输出：假设输入和输出有“相同的”生命周期：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x: &amp;Item) -&gt; (&amp;Item, &amp;Item)
// ... 相当于 ...
fn f&lt;'a&gt;(x: &amp;'a Item) -&gt; (&amp;'a Item, &amp;'a Item)
<span class="boring">}</span></code></pre></pre>
<ul>
<li>多个输入，没有输出：假设所有输入都有不同的生命周期：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(x: &amp;Item, y: &amp;Item, z: &amp;Item) -&gt; i32
// ... 相当于 ...
fn f&lt;'a, 'b, 'c&gt;(x: &amp;'a Item, y: &amp;'b Item, z: &amp;'c Item) -&gt; i32
<span class="boring">}</span></code></pre></pre>
<ul>
<li>多个输入，包括<code>&amp;self</code>，一个或多个输入：假设输出的生命周期与<code>&amp;self</code>的生命周期“相同”：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(&amp;self, y: &amp;Item, z: &amp;Item) -&gt; &amp;Thing
// ... 相当于 ...
fn f(&amp;'a self, y: &amp;'b Item, z: &amp;'c Item) -&gt; &amp;'a Thing
<span class="boring">}</span></code></pre></pre>
<p>当然，如果省略的生命周期标注没有达到你的预期，你仍可以显式标注生命周期来指定哪些生命周期彼此相关。实际上，这会导致编译报错，该错误表明省略的生命周期不能匹配函数或调用者涉及的引用。</p>
<h2 id="static生命周期"><a class="header" href="#static生命周期"><code>'static</code>生命周期</a></h2>
<p>上一节描述了函数的输入和输出的引用的生命周期之间的各种可能的映射，但是忽略了一种特殊情况。如果没有输入生命周期，但输出的返回值仍然包含引用会发生什么？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn the_answer() -&gt; &amp;Item {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:471:28
    |
471 |     pub fn the_answer() -&gt; &amp;Item {
    |                            ^ expected named lifetime parameter
    |
    = help: this function's return type contains a borrowed value, but there
            is no value for it to be borrowed from
help: consider using the `'static` lifetime
    |
471 |     pub fn the_answer() -&gt; &amp;'static Item {
    |                             +++++++
</code></pre>
<p>唯一允许的改正是对于返回的引用，有一个生命周期保证永远它不会超出作用范围。这是由特殊的生命周期<code>'static</code>来标注的，它也是唯一一个特定名称而不是任意占位符名称的生命周期。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn the_answer() -&gt; &amp;'static Item {
<span class="boring">}</span></code></pre></pre>
<p>获取有<code>'static</code>生命周期的引用最简单的方法是引用已经标记为<a href="https://doc.rust-lang.org/std/keyword.static.html">static</a>的全局变量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static ANSWER: Item = Item { contents: 42 };

pub fn the_answer() -&gt; &amp;'static Item {
    &amp;ANSWER
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 编译器保证这个<code>static</code>变量在整个程序的持续时间中具有相同的地址并永远不会移动。这意味着<code>static</code>变量具有<code>'static</code>生命周期，从逻辑上来说是这样。</p>
<p>很多情况下，对<code>const</code>变量的引用也会被<a href="https://doc.rust-lang.org/reference/destructors.html#constant-promotion">提升</a>为<code>'static</code>生命周期，但是有一些小的副作用需要注意。首先，如果涉及的类型具有析构函数或者内部可变性，则不会发生此提升：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Wrapper(pub i32);

impl Drop for Wrapper {
    fn drop(&amp;mut self) {}
}

const ANSWER: Wrapper = Wrapper(42);

pub fn the_answer() -&gt; &amp;'static Wrapper {
    // `Wrapper` 有析构函数，所以const变量的引用无法提升到 `'static` 生命周期
    &amp;ANSWER
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0515]: cannot return reference to temporary value
   --&gt; src/main.rs:520:9
    |
520 |         &amp;ANSWER
    |         ^------
    |         ||
    |         |temporary value created here
    |         returns a reference to data owned by the current function
</code></pre>
<p>第二个潜在副作用是，只有<code>const</code>的<em>值</em>才能保证在各处都相同；无论变量在何处被使用，编译器都可以根据需要制作任意份拷贝。如果你正在依赖<code>'static</code>引用背后的底层指针值来做些邪恶事，请注意这可能涉及多个内存位置。</p>
<p>还有一种方法来获取具有<code>'static</code>生命周期的引用。<code>'static</code>主要承诺了该生命周期应该比程序中任何其他生命周期都长；在堆上分配且<em>从未释放</em>的值也满足此约束。</p>
<p>普通的堆上分配<code>Box&lt;T&gt;</code>在此处不起作用，因为不能保证（如下一节所述）该数据不会在超出作用域后被丢弃。</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let boxed = Box::new(Item { contents: 12 });
    let r: &amp;'static Item = &amp;boxed;
    println!("'static item is {:?}", r);
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0597]: `boxed` does not live long enough
   --&gt; src/main.rs:344:32
    |
343 |     let boxed = Box::new(Item { contents: 12 });
    |         ----- binding `boxed` declared here
344 |     let r: &amp;'static Item = &amp;boxed;
    |            -------------   ^^^^^^ borrowed value does not live long enough
    |            |
    |            type annotation requires that `boxed` is borrowed for `'static`
345 |     println!("'static item is {:?}", r);
346 | }
    | - `boxed` dropped here while still borrowed
</code></pre>
<p>然而，<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a>函数可以把已有所有权的<code>Box&lt;T&gt;</code>变为<code>T</code>的可变引用。不再有所有者拥有该值的所有权，因此它将会永远不会被删除——这满足了<code>'static</code>生命周期的要求：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let boxed = Box::new(Item { contents: 12 });

    // `leak()` 销毁了 `Box&lt;T&gt;` 并返回 `&amp;mut T`.
    let r: &amp;'static Item = Box::leak(boxed);

    println!("'static item is {:?}", r);
} // `boxed` 在这里没被drop，因为它被移动进了 `Box::leak()`

// 因为 `r` 没有超出作用域，`Item` 被永远的泄漏了。
<span class="boring">}</span></code></pre></pre>
<p>无法 drop 该数据，也意味着永远无法使用 safe Rust 来回收该数据的内存，这可能会导致永久性的内存泄漏。（注意，这块泄漏的内存并不违反 Rust 的内存安全保证——内存中永远无法访问的数据仍然是安全的。）</p>
<h2 id="生命周期和堆"><a class="header" href="#生命周期和堆">生命周期和堆</a></h2>
<p>到目前为止的讨论集中在栈上数据的生命周期，无论是函数参数，局部变量或临时变量。但堆上的数据又如何呢？</p>
<p>关于堆上的值要认识到关键的事情是每块数据都有一个所有者（除了特殊情况，例如上一节描述的故意泄漏(leak)）。例如，一个简单的<code>Box&lt;T&gt;</code>就可以把<code>T</code>的值放堆上，同时变量也就是所有者拥有<code>Box&lt;T&gt;</code>的所有权。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let b: Box&lt;Item&gt; = Box::new(Item { contents: 42 });
} // `b` 在此drop，那么 `Item` 也drop了。
<span class="boring">}</span></code></pre></pre>
<p>拥有所有权的<code>Box&lt;Item&gt;</code>在超出生命周期范围后 drop 了里面的数据，因此堆上的<code>Item</code>的生命周期与栈上的的<code>Box&lt;Item&gt;</code>相同。</p>
<p>堆上的值的所有者本身可能也在堆上，而不是栈上，那么此时谁拥有该所有者？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let b: Box&lt;Item&gt; = Box::new(Item { contents: 42 });
    let bb: Box&lt;Box&lt;Item&gt;&gt; = Box::new(b); // `b` 被移动到堆上
} // `bb` 在此drop，那么 `Box&lt;Item&gt;` 也drop了，那么 `Item` 也drop了。
<span class="boring">}</span></code></pre></pre>
<p>所有权链必须在某处结束，并只有两种可能性：</p>
<ul>
<li>该链以局部变量或函数参数结束——这种情况下该链中所有数据的生命周期就是栈上变量的生命周期<code>'a</code>。当栈上的变量超出作用域，该链上所有数据也都被 drop。</li>
<li>该链以标记了<code>static</code>的全局变量结束——这种情况下，链中所有的数据的生命周期都是<code>'static</code>的，<code>static</code>变量永远不会超出作用域，所以链中任何内容都不会被自动 drop。</li>
</ul>
<p>总结，堆上数据的生命周期根本上是绑定到栈上的生命周期。</p>
<h2 id="结构体中的生命周期"><a class="header" href="#结构体中的生命周期">结构体中的生命周期</a></h2>
<p>前面关于生命周期的章节集中于函数的输入和输出，但是存储在结构体中的引用也存在类似问题。</p>
<p>如果试图在不使用生命周期标注的情况下，偷偷把引用放到结构体中，编译器会发生尖锐的爆鸣声：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReferenceHolder {
    pub index: usize,
    pub item: &amp;Item,
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:548:19
    |
548 |         pub item: &amp;Item,
    |                   ^ expected named lifetime parameter
    |
help: consider introducing a named lifetime parameter
    |
546 ~     pub struct ReferenceHolder&lt;'a&gt; {
547 |         pub index: usize,
548 ~         pub item: &amp;'a Item,
    |
</code></pre>
<p>像往常一样，编译器错误信息告诉我们应该怎么做。第一部分很简单：为引用类型显式标注一个生命周期<code>'a</code>，因为结构体中使用引用没有生命周期省略规则。</p>
<p>第二部分不太明显，但具有更深层次的影响：结构体本身需要一个生命周期参数<code>&lt;'a&gt;</code>，它与包含的引用的生命周期相匹配：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 由于字段有引用，所以结构体需要有生命周期参数
pub struct ReferenceHolder&lt;'a&gt; {
    pub index: usize,
    pub item: &amp;'a Item,
}
<span class="boring">}</span></code></pre></pre>
<p>结构体的生命周期参数具有传染性：任何结构体包含了该类型也必须获取一个生命周期参数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 由于字段有生命周期参数，所以结构体需要有生命周期参数
pub struct RefHolderHolder&lt;'a&gt; {
    pub inner: ReferenceHolder&lt;'a&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>如果结构体包含切片类型，则也需要生命周期参数，因为它们又是对借用数据的引用。</p>
<p>如果结构体包含多个相互关联的生命周期的字段，那么你必须选择合适的生命周期绑定。在一对字符串内查找公共子串是一个非常好的具有独立生命周期的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 一对字符串的公共子串存在的位置
pub struct LargestCommonSubstring&lt;'a, 'b&gt; {
    pub left: &amp;'a str,
    pub right: &amp;'b str,
}

/// 在 `left` 和 `right` 字符串中找到最长公共子串
pub fn find_common&lt;'a, 'b&gt;(
    left: &amp;'a str,
    right: &amp;'b str,
) -&gt; Option&lt;LargestCommonSubstring&lt;'a, 'b&gt;&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>而引用同一字符串的多个位置的结构体，将具有共同的生命周期：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 在一个字符串内重复的两个子串
pub struct RepeatedSubstring&lt;'a&gt; {
    pub first: &amp;'a str,
    pub second: &amp;'a str,
}

/// 找到 `s` 中第一个重复子串。
pub fn find_repeat&lt;'a&gt;(s: &amp;'a str) -&gt; Option&lt;RepeatedSubstring&lt;'a&gt;&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>生命周期参数的传播是有意义的：任何包含引用的东西，无论嵌套多深，都仅在所引用数据的生命周期内有效。如果该数据被移动或 drop，那么整个结构体嵌套链都不再有效。</p>
<p>然而，这也意味着涉及引用的结构体更难使用——结构体的所有者必须保证生命周期全部一致。因此，<strong>尽可能选择拥有其内部数据所有权的结构体</strong>，特别是在代码不需要高度优化(<a href="https://www.lurklurk.org/effective-rust/optimize.html">第 20 条</a>)的情况下。如果做不到这一点，<a href="/chapter_1/item8-references&amp;pointer.html">第 8 条</a>描述的各种智能指针类型(例如<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>)可以让你生命周期约束中解放出来。</p>
<h1 id="匿名生命周期"><a class="header" href="#匿名生命周期">匿名生命周期</a></h1>
<p>当不能保证一个结构体拥有其数据的所有权时，结构体必然会以生命周期参数结束，如上一节所述。这可能会与本条之前说的生命周期省略规则产生一些不幸。</p>
<p>例如，考虑一个返回带有生命周期参数的结构体的函数。该函数的完全显式标注使涉及的生命周期变得清晰易读：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_one_item&lt;'a&gt;(items: &amp;'a [Item]) -&gt; ReferenceHolder&lt;'a&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>然而，省略生命周期的相同标注可能会有点误导：</p>
<pre><code>pub fn find_one_item(items: &amp;[Item]) -&gt; ReferenceHolder {
    // ...
}
</code></pre>
<p>因为返回类型的生命周期参数被省略，因此阅读代码的人不会得到太多涉及生命周期的提示。</p>
<p>匿名生命周期<code>'_</code>允许你将省略的生命周期标注出来，而无需恢复<em>所有</em>生命周期名称。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_one_item(items: &amp;[Item]) -&gt; ReferenceHolder&lt;'_&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>粗略地说，<code>'_</code>标注要求编译器为我们生成一个唯一的生命周期名称，我们可以在不需要其他地方使用该名称的情况下使用它。</p>
<p>这意味着对于其他生命周期省略场景也很有用。例如，<code>Debug</code> trait 的<code>fmt</code>方法，使用匿名生命周期来指示<code>Formatter</code>实例具有和<code>&amp;self</code>不同的生命周期，但该生命周期是什么名称并不重要：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="牢记"><a class="header" href="#牢记">牢记</a></h2>
<ul>
<li>所有的 Rust 引用都有一个关联的生命周期，由生命周期标签(比如<code>'a</code>)指示。在某些常见情况下，函数参数和返回值的生命周期可以省略（但仍然存在）。</li>
<li>任何（传递地）包含引用的结构体都有关联的生命周期参数；因此，使用拥有其数据所有权的结构体通常更容易。</li>
<li><code>'static</code>生命周期用来保证永远不会超出作用域的数据的引用，例如全局数据或堆上已经显式泄漏的数据。</li>
<li>生命周期标签只能指示生命周期是“相同的”，这意味着输出的生命周期被包含在输入的一个（或更多）生命周期内。</li>
<li>匿名生命周期<code>'_</code>可以用在不需要特定生命周期标签的地方。</li>
</ul>
<h4 id="注释"><a class="header" href="#注释">注释</a></h4>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>例如，Chromium 项目估计<a href="https://www.chromium.org/Home/chromium-security/memory-safety/">70%的安全 bug 都归咎于内存安全。</a></p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">点这里</a>查看</p>
<!-- 参考链接 -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_3/item15-borrows.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_3/item15-borrows.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../style/js/tongji.js"></script>
        <script src="../style/js/ferris.js"></script>


    </div>
    </body>
</html>
