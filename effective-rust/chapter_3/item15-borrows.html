<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 15 条：理解借用检查器 - Effective Rust 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="../intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="../intro.html">介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="../chapter_1/item2-use-types-2.html"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="../chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="../chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="../chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="../chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="../chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item9-iterators.html"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/item10-std-traits.html"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="../chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="../chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="../chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/item14-lifetimes.html"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="../chapter_3/item15-borrows.html" class="active"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="../chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="../chapter_3/item17-deadlock.html"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="../chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="../chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="../chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="../chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="../chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-15-条理解借用检查器"><a class="header" href="#第-15-条理解借用检查器">第 15 条：理解借用检查器</a></h1>
<p>Rust 中的每一个值都有一个所有者，但该所有者可以将值借用到代码中的其他位置。这种<em>借用</em>机制涉及<em>引用</em>的创建和使用。并遵守<em>借用检查器</em>(本条的主题)的规则。</p>
<p>抛开表面，Rust 引用使用与 C 或 C++代码中相当常见的相同类型<em>指针</em>值（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>），但为了确保避免 C/C++中的错误，这个指针有规则和限制。来快速比较一下：</p>
<ul>
<li>就像 C/C++指针一样，Rust 引用使用&amp;符号创建：<code>&amp;value</code>。</li>
<li>就像 C++ 引用一样，Rust 引用不能为<code>nullptr</code>。</li>
<li>就像 C/C++指针或引用一样，Rust 引用可以在创建后进行修改来引用不同内容。</li>
<li>与 C++ 不同，从值创建的引用总是需要显式（<code>&amp;</code>）传参——如果你看到这样的代码<code>f(value)</code>，你应该意识到<code>f</code>正在接收传入值的所有权。（但是，如果这个<code>value</code>的类型实现了<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>，那么它可能接收的是该数据的<code>copy</code>的所有权——详见<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>。）</li>
<li>与 C/C++ 不同，新创建的可变引用总是显式标明（<code>&amp;mut</code>）。如果你看到了这样的代码<code>f(&amp;value)</code>，你应该意识到<code>value</code>不能被改变（即 C/C++中的<code>const</code>）。只有像<code>f(&amp;mut value)</code>这样的表达式才可能更改<code>value</code>的内容。<sup class="footnote-reference"><a href="#1">1</a></sup></li>
</ul>
<p>C/C++指针和 Rust 引用之间最重要的区别由术语<em>借用</em> <em>(borrow)</em> 表示：你可以获取某个数据的引用（指针），<em>但是你不能永久持有该引用</em>。特别是，你不能持有它活得比指向数据的生命周期更长，正如编译器所跟踪的生命周期，以及我们在<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中探索过的一样。</p>
<p>这些对引用的限制使得 Rust 能保证其内存安全，但这也意味着你需要接受借用规则的学习成本，并接受它改变你如何设计软件的方式——尤其是存储数据的结构体。</p>
<p>本条会首先描述 Rust 的引用可以做什么，以及使用它们的借用检查器规则。本条的其余部分重点关注使用这些规则后更改代码的措施：如何重构，返工和重新设计代码，以便在与借用检查器斗争中获胜。</p>
<h2 id="访问控制"><a class="header" href="#访问控制">访问控制</a></h2>
<p>有三种办法来访问一块 Rust 数据：通过这块数据的<em>所有者</em>(<code>item</code>)，<em>引用</em>(<code>&amp;item</code>)，或<em>可变引用</em>(<code>&amp;mut item</code>)。每种访问数据的方式都有不同的访问权。使用<a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>存储模型（增删改查）来粗略地概括（Rust <em>drop</em> 术语即 <em>delete</em> ）：</p>
<ul>
<li>数据的所有者可以<em>创建</em> <em>(create)</em>，<em>读取</em> <em>(read)</em>，<em>更新</em> <em>(update)</em>，或<em>删除</em> <em>(drop)</em> 它。</li>
<li>可变引用可以从底层数据中<em>读取</em>，或<em>更新</em>它。</li>
<li>（普通）引用只能<em>读取</em>底层数据。</li>
</ul>
<p>这儿有个 Rust 独有的数据访问规则：只有该数据的所有者可以<em>移动</em>该数据。如果你认为移动就是<em>创建</em>（在新位置）并<em>drop</em>这些数据占用的内存（在旧位置）的某种组合，这或许有点道理。</p>
<p>对于一块数据的可变引用的代码，这可能会导致一些奇怪情况。例如，下面替换<code>Option</code>内部值是允许的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 这段代码使用的结构体。
#[derive(Debug)]
pub struct Item {
    pub contents: i64,
}

/// 替换 `item` 的 content 为 `val`.
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) {
    *item = Some(val);
}
<span class="boring">}</span></code></pre></pre>
<p>但是返回之前的值的操作违反了移动限制：<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 替换 `item` 的 content 为 `val`，返回之前的 content
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
    let previous = *item; // 移出所有权
    *item = Some(val); // 替换
    previous
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0507]: cannot move out of `*item` which is behind a mutable reference
  --&gt; src/main.rs:34:24
   |
34 |         let previous = *item; // move out
   |                        ^^^^^ move occurs because `*item` has type
   |                              `Option&lt;inner::Item&gt;`, which does not
   |                              implement the `Copy` trait
   |
help: consider removing the dereference here
   |
34 -         let previous = *item; // move out
34 +         let previous = item; // move out
   |
</code></pre>
<p>尽管从一个可变引用<em>读取</em>是有效的，但这段代码尝试在用新值替换该被移动的值之前，将值<em>移出</em>——并试图避免复制(copy)原始值。借用检查器非常保守，并注意到在两行中间存在一段可变引用未引用有效值的时间段。</p>
<p>对人来说，我们知道这种组合操作——提取旧值并使用新值替换——是既安全又实用的，所以标准库提供了 <a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>std::mem::replace</code></a> 函数。在底层上，<code>replace</code> 使用了 <code>unsafe</code> （参考<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>）来一次性执行交换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 替换 `item` 的 content 为 `val`，返回之前的 content
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
    std::mem::replace(item, Some(val)) // 返回之前的值
}
<span class="boring">}</span></code></pre></pre>
<p>特别对于 <code>Option</code> 类型，由于这是一种非常常见的模式，所以 <code>Option</code> 自己提供了 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.replace"><code>replace</code></a> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 替换 `item` 的 content 为 `val`，返回之前的 content
pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
    item.replace(val) // 返回之前的值
}
<span class="boring">}</span></code></pre></pre>
<h2 id="借用规则"><a class="header" href="#借用规则">借用规则</a></h2>
<p>Rust 中借用引用时主要有两条关键规则需牢记。</p>
<p>第一条规则是任何引用的作用域必须小于所引用的数据的生命周期。<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>详细讨论了生命周期，但是值得注意的是编译器对于引用生命周期有特殊行为；<em>非词法生命周期</em>特性允许引用生命周期缩短，以便让他们在最后一次使用时结束，而不是在中括号末尾结束。</p>
<p>借用引用的第二条规则是，除了数据的所有者之外，还可以是以下任一一种借用方式：</p>
<ul>
<li>对数据的任意数量不可变引用</li>
<li>对数据的单个可变引用</li>
</ul>
<p>当然，不能同时用两者（在代码中的同一个位置）。</p>
<p>因此，同一个数据的引用可以被传入参数为多个不可变引用的函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 判断两个参数是否都为零
fn both_zero(left: &amp;Item, right: &amp;Item) -&gt; bool {
    left.contents == 0 &amp;&amp; right.contents == 0
}

let item = Item { contents: 0 };
assert!(both_zero(&amp;item, &amp;item));
<span class="boring">}</span></code></pre></pre>
<p>但是参数有多个<em>可变</em>引用就不能了：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 判断两个参数是否都为零
fn zero_both(left: &amp;mut Item, right: &amp;mut Item) {
    left.contents = 0;
    right.contents = 0;
}

let mut item = Item { contents: 42 };
zero_both(&amp;mut item, &amp;mut item);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0499]: cannot borrow `item` as mutable more than once at a time
   --&gt; src/main.rs:131:26
    |
131 |     zero_both(&amp;mut item, &amp;mut item);
    |     --------- ---------  ^^^^^^^^^ second mutable borrow occurs here
    |     |         |
    |     |         first mutable borrow occurs here
    |     first borrow later used by call
</code></pre>
<p>对于函数参数有可变引用和不可变引用的混合来说，也有同样的限制：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 把 `left` 的 content 设置为 `right` 的 content。
fn copy_contents(left: &amp;mut Item, right: &amp;Item) {
    left.contents = right.contents;
}

let mut item = Item { contents: 42 };
copy_contents(&amp;mut item, &amp;item);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0502]: cannot borrow `item` as immutable because it is also borrowed
              as mutable
   --&gt; src/main.rs:159:30
    |
159 |     copy_contents(&amp;mut item, &amp;item);
    |     ------------- ---------  ^^^^^ immutable borrow occurs here
    |     |             |
    |     |             mutable borrow occurs here
    |     mutable borrow later used by call
</code></pre>
<p>借用规则允许编译器对数据的<a href="https://en.wikipedia.org/wiki/Aliasing_(computing)">别名</a>作出更好的决策：即跟踪何时两个不同的指针可能或可能不，引用内存中同一个底层数据。如果编译器可以确定（正如 Rust 中那样）一些不可变引用所指向的内存位置，不会通过一个已设置别名的<em>可变</em>引用进行更改，那么编译器可以生成具有以下优点的代码：</p>
<ul>
<li><em>得到更好的优化</em>：例如值可以被缓存到寄存器中，因为已知底层的内存存储的内容不会同时改变。</li>
<li><em>更安全</em>：线程之间对内存的不同步访问（<a href="https://www.lurklurk.org/effective-rust/deadlock.html">第 17 条</a>）不会引起数据竞争。</li>
</ul>
<h2 id="所有者操作"><a class="header" href="#所有者操作">所有者操作</a></h2>
<p>围绕引用存在的规则导致了一个重要后果，它们还会影响数据所有者可执行的操作。帮助理解这一点的一种方法是想象涉及所有者的操作是通过在幕后创建和使用引用来执行的。</p>
<p>例如，尝试通过数据所有者来更新数据相当于创建了一个临时的可变引用，然后通过这个引用来更新数据。如果另外一个引用已存在，那么这个名义上第二个可变引用将会无法被创建：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut item = Item { contents: 42 };
let r = &amp;item;
item.contents = 0;
// ^^^ 更改这个 item 大概相当于
//   (&amp;mut item).contents = 0;
println!("reference to item is {:?}", r);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0506]: cannot assign to `item.contents` because it is borrowed
   --&gt; src/main.rs:200:5
    |
199 |     let r = &amp;item;
    |             ----- `item.contents` is borrowed here
200 |     item.contents = 0;
    |     ^^^^^^^^^^^^^^^^^ `item.contents` is assigned to here but it was
    |                       already borrowed
...
203 |     println!("reference to item is {:?}", r);
    |                                           - borrow later used here
</code></pre>
<p>另一方面，由于多个<em>不可变</em>引用是被允许的，因此当存在不可变引用时，从所有者读取数据是可以的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = Item { contents: 42 };
let r = &amp;item;
let contents = item.contents;
// ^^^ 从 item 中读取大概相当于
//   let contents = (&amp;item).contents;
println!("reference to item is {:?}", r);
<span class="boring">}</span></code></pre></pre>
<p>但是存在<em>可变引用</em>是不可以的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut item = Item { contents: 42 };
let r = &amp;mut item;
let contents = item.contents; // i64 实现了 `Copy`
r.contents = 0;
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0503]: cannot use `item.contents` because it was mutably borrowed
   --&gt; src/main.rs:231:20
    |
230 |     let r = &amp;mut item;
    |             --------- `item` is borrowed here
231 |     let contents = item.contents; // i64 implements `Copy`
    |                    ^^^^^^^^^^^^^ use of borrowed `item`
232 |     r.contents = 0;
    |     -------------- borrow later used here
</code></pre>
<p>最后，任何处于活动状态的引用都会阻止数据的所有者移动或 drop 数据，因为这样的话，意味着引用将会引用无效的数据：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = Item { contents: 42 };
let r = &amp;item;
let new_item = item; // 移动
println!("reference to item is {:?}", r);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0505]: cannot move out of `item` because it is borrowed
   --&gt; src/main.rs:170:20
    |
168 |     let item = Item { contents: 42 };
    |         ---- binding `item` declared here
169 |     let r = &amp;item;
    |             ----- borrow of `item` occurs here
170 |     let new_item = item; // move
    |                    ^^^^ move out of `item` occurs here
171 |     println!("reference to item is {:?}", r);
    |                                           - borrow later used here
</code></pre>
<p>这种情况下，<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中描述的非词法生命周期非常有用，因为（粗略地说）它在最后一次使用引用后结束了生命周期，而不是在中括号封闭的结尾。在移动发生之前将引用的最终使用提前，意味着不会发生编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = Item { contents: 42 };
let r = &amp;item;
println!("reference to item is {:?}", r);

// 引用 `r` 仍在作用域但是不再使用，所以它被当作该引用已经被 drop
let new_item = item; // 正常进行移动
<span class="boring">}</span></code></pre></pre>
<h2 id="在与借用检查器斗争中获胜"><a class="header" href="#在与借用检查器斗争中获胜">在与借用检查器斗争中获胜</a></h2>
<p>Rust 新手（甚至更有经验的人！）常常会觉得他们在与借用检查器斗争中花费了太多时间。有什么方法可以帮助你赢得这些斗争？</p>
<h3 id="本地代码重构"><a class="header" href="#本地代码重构">本地代码重构</a></h3>
<p>第一个策略是关注编译器的错误信息，因为 Rust 开发者已经付出了大量努力来让它们尽可能有用：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 如果 `needle` 存在于 `haystack` 中， 返回包含它的切片。
pub fn find&lt;'a, 'b&gt;(haystack: &amp;'a str, needle: &amp;'b str) -&gt; Option&lt;&amp;'a str&gt; {
    haystack
        .find(needle)
        .map(|i| &amp;haystack[i..i + needle.len()])
}

// ...

let found = find(&amp;format!("{} to search", "Text"), "ex");
if let Some(text) = found {
    println!("Found '{text}'!");
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:353:23
    |
353 | let found = find(&amp;format!("{} to search", "Text"), "ex");
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       - temporary value
    |                   |                 is freed at the end of this statement
    |                   |
    |                   creates a temporary value which is freed while still in
    |                   use
354 | if let Some(text) = found {
    |                     ----- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>错误消息的第一部分是最重要的部分，因为它描述了编译器认为你违反哪些借用规则和原因。当你遇到足够多这样的错误时——你总会的——你会逐渐建立关于借用检查器的一种直觉，这种直觉与前面叙述的规则中包含的更理论化的版本相吻合。</p>
<p>错误消息的第二部分包括编译器对于如何修改该问题的建议，本例中是很简单的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let haystack = format!("{} to search", "Text");
let found = find(&amp;haystack, "ex");
if let Some(text) = found {
    println!("Found '{text}'!");
}
// `found` 现在引用了 `haystack`，它可以活到函数以外
<span class="boring">}</span></code></pre></pre>
<p>这是两个简单的代码调整实例之一，可以帮助“安抚”借用检查器：</p>
<ul>
<li><em>扩展生命周期</em>：使用 <code>let</code> 将一个临时变量（生命周期只到该表达式结尾）绑定到一个新的被命名的局部变量（生命周期被扩展到该块的末尾）。</li>
<li><em>缩减生命周期</em>：在使用的引用周围添加一个额外的块 <code>{ ... }</code>，以便其生命周期在新块的末尾结束。</li>
</ul>
<p>后者不太常见，因为非词法生命周期的存在：编译器通常可以在引用在块末尾正式释放之前，提前判断出该引用不再被使用。但是，如果你确实发现自己反复在相似的小代码块中周围引入一个人为的中括号块，那么需要考虑是否应该将这些代码封装到一个独立的方法中。</p>
<p>编译器建议的修复对于简单的问题很有帮助，但是当你编写更复杂的代码时，你会发现这些建议不再有用，而且对不符合借用规则之处的解释更难以理解：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

// 调用函数签名 `check_item(item: Option&lt;&amp;Item&gt;)`
check_item(x.as_ref().map(|r| r.borrow().deref()));
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0515]: cannot return reference to temporary value
   --&gt; src/main.rs:293:35
    |
293 |     check_item(x.as_ref().map(|r| r.borrow().deref()));
    |                                   ----------^^^^^^^^
    |                                   |
    |                                   returns a reference to data owned by the
    |                                       current function
    |                                   temporary value created here
</code></pre>
<p>这种情况下，临时引入一些局部变量会很有帮助，每个变量都对应了相应的转化步骤，并且每个变量都有对应的类型注解：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
    Some(Rc::new(RefCell::new(Item { contents: 42 })));

let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
check_item(x3);
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0515]: cannot return reference to function parameter `r`
   --&gt; src/main.rs:305:40
    |
305 |     let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    |                                        ^^^^^^^^^ returns a reference to
    |                                      data owned by the current function
</code></pre>
<p>这缩小了编译器报错的精确转换范围，从而允许代码可以重构：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
    Some(Rc::new(RefCell::new(Item { contents: 42 })));

let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
match x2 {
    None =&gt; check_item(None),
    Some(r) =&gt; {
        let x3: &amp;Item = r.deref();
        check_item(Some(x3));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>一旦根本问题明确并得到解决，之后你就可以轻松的把局部变量重新组合在一起，然后你就可以假装你是一直这样做对的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

match x.as_ref().map(|r| r.borrow()) {
    None =&gt; check_item(None),
    Some(r) =&gt; check_item(Some(r.deref())),
};
<span class="boring">}</span></code></pre></pre>
<h3 id="结构体设计"><a class="header" href="#结构体设计">结构体设计</a></h3>
<p>接下来有助于与借用检查器斗争的是在设计结构体时考虑使用借用检查器。你的结构体拥有所有它需要的数据是万能方法，避免使用任何引用以及随之而来的<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中所描述的生命周期注解的传播。</p>
<p>然而，对于现实世界的结构体来说，这不总是可能的；当数据结构的内部连接成一个比树结构（一个<code>根</code>拥有很多<code>分支</code>，每个分支又拥有它自己的<code>叶子</code>等）更相互关联的图时，那么简单的单一所有权是不可能的。</p>
<p>举一个简单的例子，想象一个简单的来宾详情登记册，记录他们按照顺序到达的时间：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
pub struct Guest {
    name: String,
    address: String,
    // ... many other fields
}

/// Local error type, used later.
#[derive(Clone, Debug)]
pub struct Error(String);

/// Register of guests recorded in order of arrival.
#[derive(Default, Debug)]
pub struct GuestRegister(Vec&lt;Guest&gt;);

impl GuestRegister {
    pub fn register(&amp;mut self, guest: Guest) {
        self.0.push(guest)
    }
    pub fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
        self.0.get(idx)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果此代码<em>也</em>需要根据到达时间和姓名字母表序来有效地查询来宾，那么根本上涉及两个结构体，并且其中一个拥有该数据。</p>
<p>如果涉及的数据很小且不可变，那么仅仅克隆数据就可以是一个快速的解决方案：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod cloned {
    use super::Guest;

    #[derive(Default, Debug)]
    pub struct GuestRegister {
        by_arrival: Vec&lt;Guest&gt;,
        by_name: std::collections::BTreeMap&lt;String, Guest&gt;,
    }

    impl GuestRegister {
        pub fn register(&amp;mut self, guest: Guest) {
            // 需要 `Guest` 来被 `Clone`
            self.by_arrival.push(guest.clone());
            // 为了示例更短，这里没有检查重复的名字
            self.by_name.insert(guest.name.clone(), guest);
        }
        pub fn named(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Guest&gt; {
            self.by_name.get(name)
        }
        pub fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
            self.by_arrival.get(idx)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而，如果数据可以被修改，那么这种克隆方法就显得捉襟见肘。例如，如果要更新 <code>Guest</code> 的地址，你需要找到两个存储的 Guest 的地方并确保这俩地方的数据保持同步。</p>
<p>另一种可能的方法是添加另一层中间层，将 <code>Vec&lt;Guest&gt;</code> 作为所有者，并使用向量索引来名称查找。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod indexed {
    use super::Guest;

    #[derive(Default)]
    pub struct GuestRegister {
        by_arrival: Vec&lt;Guest&gt;,
        // Guest 的 name to 映射到 `by_arrival` 的 index 的索引。
        by_name: std::collections::BTreeMap&lt;String, usize&gt;,
    }

    impl GuestRegister {
        pub fn register(&amp;mut self, guest: Guest) {
            // 为了示例更短，这里没有检查重复的名字
            self.by_name
                .insert(guest.name.clone(), self.by_arrival.len());
            self.by_arrival.push(guest);
        }
        pub fn named(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Guest&gt; {
            let idx = *self.by_name.get(name)?;
            self.nth(idx)
        }
        pub fn named_mut(&amp;mut self, name: &amp;str) -&gt; Option&lt;&amp;mut Guest&gt; {
            let idx = *self.by_name.get(name)?;
            self.nth_mut(idx)
        }
        pub fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
            self.by_arrival.get(idx)
        }
        pub fn nth_mut(&amp;mut self, idx: usize) -&gt; Option&lt;&amp;mut Guest&gt; {
            self.by_arrival.get_mut(idx)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个方法中，每一个来宾都由单个 <code>Guest</code> 数据表示，这允许 <code>named_mut()</code> 方法返回对该数据的可变引用。反过来意味着可以正常更改来宾的地址——（单个） <code>Guest</code> 由 <code>Vec</code> 所有，并且在底层上始终可被访问。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let new_address = "123 Bigger House St";
// 真实情况下，代码不会假设 "Bob" 存在...
ledger.named_mut("Bob").unwrap().address = new_address.to_string();

assert_eq!(ledger.named("Bob").unwrap().address, new_address);
<span class="boring">}</span></code></pre></pre>
<p>但是，如果来宾可以注销，则很容易无意中出现 bug：</p>
<div class="ferris"><img src="../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 注销位置为 `idx` 的 `Guest`，随后的来宾都往前移
pub fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), super::Error&gt; {
    if idx &gt;= self.by_arrival.len() {
        return Err(super::Error::new("out of bounds"));
    }
    self.by_arrival.remove(idx);

    // 哦，忘记更新了 `by_name`。

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>现在 <code>Vec</code> 可能被打乱，其中的 <code>by_name</code> 索引实际上就像指针一样，但我们引入了一个 bug 会导致这些“指针”指向不存在的内容（超出 <code>Vec</code> 范围）或指向不正确的数据：</p>
<div class="ferris"><img src="../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ledger.register(alice);
ledger.register(bob);
ledger.register(charlie);
println!("Register starts as: {ledger:?}");

ledger.deregister(0).unwrap();
println!("Register after deregister(0): {ledger:?}");

let also_alice = ledger.named("Alice");
// Alice 的索引仍然是 0，但现在该位置是 Bob
println!("Alice is {also_alice:?}");

let also_bob = ledger.named("Bob");
// Bob 的索引仍然是 1，但现在该位置是 Charlie
println!("Bob is {also_bob:?}");

let also_charlie = ledger.named("Charlie");
// Charlie 的索引仍然是 2，但现在已经超出了 Vec 索引范围
println!("Charlie is {also_charlie:?}");
<span class="boring">}</span></code></pre></pre>
<p>这里的代码使用自定义的 <code>Debug</code> 实现（没展示出来），以减少输出大小；截断的输出如下：</p>
<pre><code>Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {"Alice": 0, "Bob": 1, "Charlie": 2}
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {"Alice": 0, "Bob": 1, "Charlie": 2}
}
Alice is Some(Guest { name: "Bob", address: "234 Bobton" })
Bob is Some(Guest { name: "Charlie", address: "345 Charlieland" })
Charlie is None
</code></pre>
<p>前面的示例展示了 <code>注销</code> 代码的 bug，但是即便修复了这个 bug，也无法防止调用者使用该索引值，并传入 <code>nth()</code> ——从而获得意外或无效结果。</p>
<p>核心问题是两个结构体需要保持同步。处理这种问题的更好方法是使用 Rust 的智能指针（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>）。使用 <code>Rc</code> 和 <code>RefCell</code> 来避免使用索引作为无效指针的问题。更新示例——但是保持该 bug 不变——如下所示：</p>
<div class="ferris"><img src="../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod rc {
    use super::{Error, Guest};
    use std::{cell::RefCell, rc::Rc};

    #[derive(Default)]
    pub struct GuestRegister {
        by_arrival: Vec&lt;Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
        by_name: std::collections::BTreeMap&lt;String, Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
    }

    impl GuestRegister {
        pub fn register(&amp;mut self, guest: Guest) {
            let name = guest.name.clone();
            let guest = Rc::new(RefCell::new(guest));
            self.by_arrival.push(guest.clone());
            self.by_name.insert(name, guest);
        }
        pub fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
            if idx &gt;= self.by_arrival.len() {
                return Err(Error::new("out of bounds"));
            }
            self.by_arrival.remove(idx);

            // 哦，又忘了更新 `by_name`。

            Ok(())
        }
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><code>Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Alice", {n: 'Alice', ...}), ("Bob", {n: 'Bob', ...}),
            ("Charlie", {n: 'Charlie', ...})]
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Alice", {n: 'Alice', ...}), ("Bob", {n: 'Bob', ...}),
            ("Charlie", {n: 'Charlie', ...})]
}
Alice is Some(RefCell { value: Guest { name: "Alice",
                                       address: "123 Aliceville" } })
Bob is Some(RefCell { value: Guest { name: "Bob",
                                     address: "234 Bobton" } })
Charlie is Some(RefCell { value: Guest { name: "Charlie",
                                         address: "345 Charlieland" } })
</code></pre>
<p>输出不再有不匹配的名称，但是 Alice 挥之不去的数据仍旧存在，直到我们确保两个集合保持同步，才能修复该 bug：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
    if idx &gt;= self.by_arrival.len() {
        return Err(Error::new("out of bounds"));
    }
    let guest: Rc&lt;RefCell&lt;Guest&gt;&gt; = self.by_arrival.remove(idx);
    self.by_name.remove(&amp;guest.borrow().name);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<pre><code>Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Bob", {n: 'Bob', ...}), ("Charlie", {n: 'Charlie', ...})]
}
Alice is None
Bob is Some(RefCell { value: Guest { name: "Bob",
                                     address: "234 Bobton" } })
Charlie is Some(RefCell { value: Guest { name: "Charlie",
                                         address: "345 Charlieland" } })
</code></pre>
<h3 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h3>
<p>上一小节最后一个方法是更通用的解决方案的示例：<strong>在互联的结构体中使用 Rust 智能指针</strong>。</p>
<p><a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>描述了 Rust 标准库提供的常见的智能指针类型：</p>
<ul>
<li><code>Rc</code> 允许共享所有权，多个变量可以引用同一个数据。<code>Rc</code> 总是和 <code>RefCell</code> 一起使用。</li>
<li><code>RefCell</code> 允许内部可变性，以便在不需要可变引用的情况下更改内部状态。这是将借用检查从编译期移到运行时为代价的。</li>
<li><code>Arc</code> 是 <code>Rc</code> 的多线程版本。</li>
<li><code>Mutex</code> （和 <code>RwLock</code>）允许多线程环境中内部可变性，大概相当于 <code>RefCell</code>。</li>
<li><code>Cell</code> 允许 <code>Copy</code> 类型的内部可变性。</li>
</ul>
<p>对于从 C++转向 Rust 并适应了的程序员来说，最常用的就是 <code>Rc&lt;T&gt;</code>（和它的线程安全版本 <code>Arc&lt;T&gt;</code>），并通常结合 <code>RefCell</code>（或者线程安全的替代 <code>Mutex</code>）使用。将共享指针（甚至是 <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>）简单地转换为 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 实例通常在 Rust 中工作良好，而且借用检查器不会有太多抱怨。</p>
<p>然而，使用该方法意味着你会得不到 Rust 提供的一些保护。特别是，当同一个数据可变借用（通过 <code>borrow_mut()</code>）时，另外一个引用已经存在，会导致运行时 <code>panic!</code>，而不是一个编译期错误。</p>
<p>例如，打破树结构所有权单向流的一种模式是，有一个“所有者”指针从该数据指回这个数据的所有者，如图 3-3 所示。这些<code>所有者</code>链接对于在数据结构中上下移动很有用；例如，向叶子添加新的同级节点，找到涉及该叶子所属的<code>分支</code>。</p>
<img src="../images/item15/treedatastructure.svg" width="600" height="302">
<p><em>图 3-3. 树结构层级关系</em></p>
<p>在 Rust 中实现此模式可以利用 <code>Rc&lt;T&gt;</code> 的精明的伙伴，<a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    cell::RefCell,
    rc::{Rc, Weak},
};

// 对每个标识符类型使用新类型。
struct TreeId(String);
struct BranchId(String);
struct LeafId(String);

struct Tree {
    id: TreeId,
    branches: Vec&lt;Rc&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}

struct Branch {
    id: BranchId,
    leaves: Vec&lt;Rc&lt;RefCell&lt;Leaf&gt;&gt;&gt;,
    owner: Option&lt;Weak&lt;RefCell&lt;Tree&gt;&gt;&gt;,
}

struct Leaf {
    id: LeafId,
    owner: Option&lt;Weak&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Weak</code> 引用不会增加主引用计数，因此必须显式验证所引用的数据是否已经被释放：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Branch {
    fn add_leaf(branch: Rc&lt;RefCell&lt;Branch&gt;&gt;, mut leaf: Leaf) {
        leaf.owner = Some(Rc::downgrade(&amp;branch));
        branch.borrow_mut().leaves.push(Rc::new(RefCell::new(leaf)));
    }

    fn location(&amp;self) -&gt; String {
        match &amp;self.owner {
            None =&gt; format!("&lt;unowned&gt;.{}", self.id.0),
            Some(owner) =&gt; {
                // 升级弱引用所有者指针
                let tree = owner.upgrade().expect("owner gone!");
                format!("{}.{}", tree.borrow().id.0, self.id.0)
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果 Rust 的智能指针不能很好的解决你的结构体所需，这里还有终极解决方案，即编写 <code>unsafe</code> 代码并使用裸（并且绝对不智能的）指针。然而，根据<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>，这应该是最后的解决方案——其他人可能已经在安全接口内实现了你想要的功能，你只需要搜索标准库和 <code>crates.io</code>，你或许会找到适合这种情况的工具。</p>
<p>例如，假设你写了一个函数，它有时返回输入的参数之一的引用，有时返回一些新分配的数据。根据<a href="https://www.lurklurk.org/effective-rust/use-types.html">第 1 条</a>，对这两种可能性在类型系统中进行编码的非常自然的方式是写一个 <code>enum</code>，然后你可以实现<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>描述的各种指针 trait。但是你不必这样做：标准库已经提供了<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a>类型，它已经包含了这些情况：</p>
<h3 id="自引用结构体"><a class="header" href="#自引用结构体">自引用结构体</a></h3>
<p>有一场与借用检查器的特殊斗争总是阻碍程序员从其他语言转向 Rust：尝试创建自引用结构体，结构体中包含已拥有的数据，和对该已拥有的数据内的引用的混合：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRef {
    text: String,
    // `text` 的切片中有 title 文本。
    title: Option&lt;&amp;str&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>在语法级别上，这段代码无法编译，因为它不符合<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>中所述的生命周期规则：引用需要生命周期注解，并且这意味着包含该数据的结构体也需要生命周期参数。但是生命周期是针对此 <code>SelfRef</code> 结构体外部的某些东西而言的，而这里没意义：被引用的数据在结构体内部。</p>
<p>关于此限制在语义层面的原因很值得思考。Rust 中的数据结构是<em>可移动的</em>：从栈到堆上，从堆到栈上，并从一个地方到另一个地方。如果上述情况发生了，"内部" <code>title</code> 指针将不再有效，并且也无法保持同步。</p>
<p>对于这种情况，一个简单的解决办法是使用前面讨论过的索引：对于 <code>text</code> 的一系列的偏移量不会因为移动而失效，并且对于借用检查器来说是不可见的，因为它不涉及引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRefIdx {
    text: String,
    // title 文本的位置对 `text` 的索引
    title: Option&lt;std::ops::Range&lt;usize&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>然而，这种索引方法只适合简单的示例，并且具有前面提到过的相同的缺点：索引本身是一个伪指针，可能会变得不同步，甚至 <code>text</code> 已经不存在之后仍在索引不存在的数据。</p>
<p>当编译器处理<code>异步</code>代码时，会出现常见的自引用问题。<sup class="footnote-reference"><a href="#4">3</a></sup>粗略地说，编译器将待处理的<code>异步</code>代码整合到闭包中，该闭包会既包含代码，又包含上下文环境中捕获到的需要的变量（如<a href="https://www.lurklurk.org/effective-rust/use-types-2.html">第 2 条</a>所述）。该捕获环境能够同时包含值和对这些值的引用。这本质上是一种自引用数据结构，因此<code>异步</code>支持是标准库中的 <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> 类型的主要动机。该指针类型可以“固定”值，强制该值保留在内存中的同一位置，从而确保内部自引用保持有效。</p>
<p>因此 <code>Pin</code> 可以作为自引用类型的一种可能解决方法，但如何正确使用该类型很棘手——请务必阅读<a href="https://doc.rust-lang.org/std/pin/index.html">官方文档</a>。</p>
<p>在可能的情况下，<strong>避免使用自引用数据结构</strong>，或者尝试找到能够为此封装的包（例如<a href="https://crates.io/crates/ouroboros"><code>ouroboros</code></a>）。</p>
<h2 id="牢记"><a class="header" href="#牢记">牢记</a></h2>
<ul>
<li>Rust 的引用是<em>被借用的</em>，表明他们不能被永久保留。</li>
<li>借用检查器允许对某个数据进行多次不可变借用，或者单次可变借用，但不能同时有两者。由于非词法生命周期，引用的生命周期在引用最后一次被使用之后结束，而不是在中括号封闭范围内末尾。</li>
<li>借用检查器的错误可通过多种方式处理：
<ul>
<li>添加额外的 <code>{ ... }</code> 作用域来减少值的生命周期范围。</li>
<li>把值赋值给已命名的局部变量，可以延长该值的生命周期到该作用域的末尾。</li>
<li>暂时添加多个局部变量可以帮助缩小借用检查器“抱怨”的范围。</li>
</ul>
</li>
<li>Rust 的智能指针提供了绕过借用检查器规则的方法，并且对于互联的结构体非常有用。</li>
<li>然而，自引用结构体在 Rust 中仍难以处理。</li>
</ul>
<h4 id="注释"><a class="header" href="#注释">注释</a></h4>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>注意，上述提到的可能在这样的表达式失效，比如<code>m!(value)</code>，因为这涉及宏（<a href="https://www.lurklurk.org/effective-rust/macros.html">第 28 条</a>），因为宏可以扩展出任意代码。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>编译器的建议在这里没有任何用处，因为后续行需要 <code>item</code>。</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">4</sup>
<p><code>Cow</code> 意思是写时克隆 (clone-on-write)；仅当数据需要对其更改（写入）时才克隆底层数据。</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">3</sup>
<p>处理 <code>async</code> 代码已经超出本书的范围；要了解更多关于自引用(self-referential)结构体的更多信息，参考 Jon Gjengset (No Starch Press) 编写的<a href="https://rust-for-rustaceans.com/">《Rust for Rustaceans》</a>的第 8 章节。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/borrows.html">点这里</a>查看</p>
<!-- 参考链接 -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_3/item14-lifetimes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_3/item16-unsafe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_3/item14-lifetimes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_3/item16-unsafe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../style/js/tongji.js"></script>
        <script src="../style/js/ferris.js"></script>


    </div>
    </body>
</html>
