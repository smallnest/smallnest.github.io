<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第 17 条：对共享状态的并行性保持警惕 - Effective Rust 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../style/css/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover.html">封面</a></li><li class="chapter-item expanded affix "><a href="../intro_zh.html">译著</a></li><li class="chapter-item expanded affix "><a href="../intro.html">介绍</a></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/item1-use-types.html"><strong aria-hidden="true">1.1.</strong> 第 1 条：使用类型系统表达数据结构</a></li><li class="chapter-item expanded "><a href="../chapter_1/item2-use-types-2.html"><strong aria-hidden="true">1.2.</strong> 第 2 条：使用类型系统表达常见行为</a></li><li class="chapter-item expanded "><a href="../chapter_1/item3-transform.html"><strong aria-hidden="true">1.3.</strong> 第 3 条：避免匹配 Option 和 Result</a></li><li class="chapter-item expanded "><a href="../chapter_1/item4-errors.html"><strong aria-hidden="true">1.4.</strong> 第 4 条：优先使用惯用的错误类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item5-casts.html"><strong aria-hidden="true">1.5.</strong> 第 5 条：理解类型转换</a></li><li class="chapter-item expanded "><a href="../chapter_1/item6-newtype.html"><strong aria-hidden="true">1.6.</strong> 第 6 条：拥抱 newtype 模式</a></li><li class="chapter-item expanded "><a href="../chapter_1/item7-builder.html"><strong aria-hidden="true">1.7.</strong> 第 7 条：对于复杂的类型，使用构造器</a></li><li class="chapter-item expanded "><a href="../chapter_1/item8-references&pointer.html"><strong aria-hidden="true">1.8.</strong> 第 8 条：熟悉引用和指针类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/item9-iterators.html"><strong aria-hidden="true">1.9.</strong> 第 9 条：考虑使用迭代器转换代替显式循环</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> 特征（Traits）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/item10-std-traits.html"><strong aria-hidden="true">2.1.</strong> 第 10 条：熟悉标准库的 traits</a></li><li class="chapter-item expanded "><a href="../chapter_2/item11-impl-drop-for-RAII.html"><strong aria-hidden="true">2.2.</strong> 第 11 条：为RAII模式实现Drop trait</a></li><li class="chapter-item expanded "><a href="../chapter_2/item12-generics&trait-objects.html"><strong aria-hidden="true">2.3.</strong> 第 12 条：理解泛型与特征对象之间的权衡</a></li><li class="chapter-item expanded "><a href="../chapter_2/item13-use-default-impl.html"><strong aria-hidden="true">2.4.</strong> 第 13 条：使用默认实现来减少必需实现的 trait 方法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/item14-lifetimes.html"><strong aria-hidden="true">3.1.</strong> 第 14 条：理解生命周期</a></li><li class="chapter-item expanded "><a href="../chapter_3/item15-borrows.html"><strong aria-hidden="true">3.2.</strong> 第 15 条：理解借用检查器</a></li><li class="chapter-item expanded "><a href="../chapter_3/item16-unsafe.html"><strong aria-hidden="true">3.3.</strong> 第 16 条：避免写 unsafe 代码</a></li><li class="chapter-item expanded "><a href="../chapter_3/item17-deadlock.html" class="active"><strong aria-hidden="true">3.4.</strong> 第 17 条：对共享状态的并行性保持警惕</a></li><li class="chapter-item expanded "><a href="../chapter_3/item18-panic.html"><strong aria-hidden="true">3.5.</strong> 第 18 条：不要 panic</a></li><li class="chapter-item expanded "><a href="../chapter_3/item19-reflection.html"><strong aria-hidden="true">3.6.</strong> 第 19 条：避免反射</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> 依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/item23-wildcard.html"><strong aria-hidden="true">4.1.</strong> 第 23 条：避免通配符导入</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/item27-document-public-interfaces.html"><strong aria-hidden="true">5.1.</strong> 第 27 条：为公共接口撰写文档</a></li><li class="chapter-item expanded "><a href="../chapter_5/item28-use-macros-judiciously.html"><strong aria-hidden="true">5.2.</strong> 第 28 条：在合适的时候使用宏</a></li><li class="chapter-item expanded "><a href="../chapter_5/item29-listen-to-clippy.html"><strong aria-hidden="true">5.3.</strong> 第 29 条：遵循 Clippy 的提示</a></li><li class="chapter-item expanded "><a href="../chapter_5/item31-use-tools.html"><strong aria-hidden="true">5.4.</strong> 第 31 条：使用生态系统工具</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_6.html"><strong aria-hidden="true">6.</strong> 超出 Rust 标准</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_6/item35-bindgen.html"><strong aria-hidden="true">6.1.</strong> 第 35 条：优先使用bindgen而不是手动FFI映射</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-17-条对共享状态的并行性保持警惕"><a class="header" href="#第-17-条对共享状态的并行性保持警惕">第 17 条：对共享状态的并行性保持警惕</a></h1>
<blockquote>
<p>"即使是最大胆的共享数据形式在 Rust 中也能保证安全。"-<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Aaron Turon</a></p>
</blockquote>
<p>官方文档描述说 Rust 实现了<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">“无畏并发”</a>，但本条将探讨为什么（令人遗憾的是）即使是在 Rust 中，仍有一些理由需要对并发保持警惕。</p>
<p>本条特别关注<em>共享状态</em>的并行性：正在执行的不同线程通过共享内存相互通信。无论是哪种语言，线程之间共享状态通常会带来<em>两个</em>可怕的问题：</p>
<ul>
<li><em>数据竞争</em>：这可能导致数据损坏。</li>
<li><em>死锁</em>：这可能导致你的程序陷入停滞。</li>
</ul>
<p>上述两个问题都很可怕（“引起或可能导致恐慌”），因为他们在实际调试中会变得非常困难：错误的发生是不固定的，并且通常更有可能在有负载的情况下发生——这意味着他们可能不会在单元测试，集成测试或其他任何类型测试中被发现（<a href="https://www.lurklurk.org/effective-rust/testing.html">第 30 条</a>），但他们会在生产环境中出现。</p>
<p>Rust 已经向前迈出了一大步，因为它完全解决了上述两个问题之一。然而，正如我们所见，另外一个问题仍然存在。</p>
<h2 id="数据竞争"><a class="header" href="#数据竞争">数据竞争</a></h2>
<p>让我们先通过探索<em>数据竞争</em>和 Rust 来看一个好消息。数据竞争的精确定义因语言而异，但我们可以将关键部分总结如下：</p>
<blockquote>
<p>当两个不同的线程在以下条件访问内存中同一位置时，会发生数据竞争：</p>
<ul>
<li>至少有一个线程在写入。</li>
<li>没有强制规定访问顺序的同步机制。</li>
</ul>
</blockquote>
<h3 id="c-中的数据竞争"><a class="header" href="#c-中的数据竞争">C++ 中的数据竞争</a></h3>
<p>通过一个例子可以很好地说明这这些基础知识。考虑一个跟踪银行账户的数据结构：</p>
<div class="ferris"><img src="../images/ferris/not_desired_behavior.svg" width="75" height="75" /></div>
<pre><code class="language-cpp">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    if (balance_ &lt; 0) {
      std::cerr &lt;&lt; "** Oh no, gone overdrawn: " &lt;&lt; balance_ &lt;&lt; "! **\n";
      std::abort();
    }
    return balance_;
  }
  void deposit(uint32_t amount) {
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    if (balance_ &lt; amount) {
      return false;
    }
    // 如果此时其他线程更改了 `balance_` 会发生什么？
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    balance_ -= amount;
    return true;
  }

 private:
  int64_t balance_;
};
</code></pre>
<p>这个例子用 C++ 写的，不是 Rust，原因很快就会明了。然而，相同的一般概念也适用于许多其他（非 Rust）语言——Java，Go，Python 等。</p>
<p>该类在单线程中工作正常，但是考虑多线程下情况：</p>
<pre><code class="language-cpp">BankAccount account;
account.deposit(1000);

// 启动一个线程，用来监视余额不足的情况，并为账户充值。
std::thread payer(pay_in, &amp;account);

// 启动三个线程，每个线程尝试重复取款。
std::thread taker(take_out, &amp;account);
std::thread taker2(take_out, &amp;account);
std::thread taker3(take_out, &amp;account);
</code></pre>
<p>这里有若干线程反复尝试从账户中取款，并且有一个额外的线程在账户余额不足时为账户充值：</p>
<pre><code class="language-cpp">// 持续监控 `account` 余额，如果余额不足则进行充值。
void pay_in(BankAccount* account) {
  while (true) {
    if (account-&gt;balance() &lt; 200) {
      log("[A] Balance running low, deposit 400");
      account-&gt;deposit(400);
    }
    // (此带有 sleep 的无限循环只是为了示范/模拟耗时操作的目的)
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
  }
}

// 反复尝试从 `account` 取款。
void take_out(BankAccount* account) {
  while (true) {
    if (account-&gt;withdraw(100)) {
      log("[B] Withdrew 100, balance now " +
          std::to_string(account-&gt;balance()));
    } else {
      log("[B] Failed to withdraw 100");
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
  }
}
</code></pre>
<p>最终，程序会出错：</p>
<pre><code>** Oh no, gone overdrawn: -100! **
</code></pre>
<p>这个问题不难发现，特别是 <code>withdraw()</code> 方法写了有用的注释：当涉及多个线程时，余额的值在检查和修改之间可能发生变化。然而，现实世界的此类 bug 会更难被发现——尤其是如果允许编译器在幕后执行各种小技巧以及代码重新排序（如 C++这样）。</p>
<p>包含了 <code>sleep</code> 的调用是为了人为地提高这种错误被命中，并尽早发现的机会；当此类问题实际发生时，他们很可能很少出现或间歇性发生——这使得他们很难被调试。</p>
<p><code>BankAccount</code> 类是<em>线程兼容的</em>，这意味着它可以在多线程环境中使用，但使用该类的人要确保对其访问需要受到某种外部同步机制的控制。</p>
<p>通过添加内部同步操作，可以将该类转换为<em>线程安全</em>类，这意味着可以安全地从多个线程使用该类：<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-cpp">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    // 对该作用域上锁 mu_。
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    if (balance_ &lt; 0) {
      std::cerr &lt;&lt; "** Oh no, gone overdrawn: " &lt;&lt; balance_ &lt;&lt; " **!\n";
      std::abort();
    }
    return balance_;
  }
  void deposit(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    if (balance_ &lt; amount) {
      return false;
    }
    balance_ -= amount;
    return true;
  }

 private:
  mutable std::mutex mu_; // 保护 balance_
  int64_t balance_;
};
</code></pre>
<p>内部字段 <code>balance_</code> 现在由锁 <code>mu_</code> 进行保护：这是一种可以确保同一时刻只有一个线程可以持有该锁的同步对象。调用者可以通过调用 <code>std::mutex::lock()</code> 来获取锁；第二个以及后续调用者调用 <code>std::mutex::lock()</code> 都会被阻塞，直到最开始的调用者调用了 <code>std::mutex::unlock()</code>，然后被阻塞的线程<em>之一</em>会解除阻塞并继续执行 <code>std::mutex::lock()</code>。</p>
<p>现在，对余额的所有访问都在持有锁的情况下进行，这确保了此值在检查和修改之间保持一致。<a href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a> 也值得强调一下：它是一个 RAII 类（参考<a href="https://www.lurklurk.org/effective-rust/raii.html">第 11 条</a>），创建时调用 <code>lock()</code> 并在销毁时调用 <code>unlock()</code>。这确保了锁在离开作用域时被 unlock，从而减少了在手动调用 <code>lock()</code> 和 <code>unlock()</code> 时出错的概率。</p>
<p>然而，这里的线程安全仍然非常脆弱；摧毁这种安全只需要对类进行一个错误的修改：</p>
<pre><code class="language-cpp">// 添加一个新的 C++ 方法...
void pay_interest(int32_t percent) {
  // ...但是忘记关于 mu_ 的事情了
  int64_t interest = (balance_ * percent) / 100;
  balance_ += interest;
}
</code></pre>
<p>然后线程安全被摧毁了。<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<h3 id="rust-中的数据竞争"><a class="header" href="#rust-中的数据竞争">Rust 中的数据竞争</a></h3>
<p>对于一本关于 Rust 的书来说，本条已经写了够多 C++了，所以考虑将这个类直接转换成 Rust：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BankAccount {
    balance: i64,
}

impl BankAccount {
    pub fn new() -&gt; Self {
        BankAccount { balance: 0 }
    }
    pub fn balance(&amp;self) -&gt; i64 {
        if self.balance &lt; 0 {
            panic!("** Oh no, gone overdrawn: {}", self.balance);
        }
        self.balance
    }
    pub fn deposit(&amp;mut self, amount: i64) {
        self.balance += amount
    }
    pub fn withdraw(&amp;mut self, amount: i64) -&gt; bool {
        if self.balance &lt; amount {
            return false;
        }
        self.balance -= amount;
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>以及尝试永久向账户付款或取款的功能：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pay_in(account: &amp;mut BankAccount) {
    loop {
        if account.balance() &lt; 200 {
            println!("[A] Running low, deposit 400");
            account.deposit(400);
        }
        std::thread::sleep(std::time::Duration::from_millis(5));
    }
}

pub fn take_out(account: &amp;mut BankAccount) {
    loop {
        if account.withdraw(100) {
            println!("[B] Withdrew 100, balance now {}", account.balance());
        } else {
            println!("[B] Failed to withdraw 100");
        }
        std::thread::sleep(std::time::Duration::from_millis(20));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这在单线程上下文中工作正常——即使该线程不是主线程：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut account = BankAccount::new();
    let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
    // 在该作用域结尾，`_payer` 线程开始独立运行
    // 并且成为 `BankAccount` 的唯一所有者。
}
<span class="boring">}</span></code></pre></pre>
<p>但如果简单地尝试跨多个线程使用 <code>BankAccount</code>：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut account = BankAccount::new();
    let _taker = std::thread::spawn(move || take_out(&amp;mut account));
    let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
}
<span class="boring">}</span></code></pre></pre>
<p>会立即编译失败：</p>
<pre><code>error[E0382]: use of moved value: `account`
   --&gt; src/main.rs:102:41
    |
100 | let mut account = BankAccount::new();
    |     ----------- move occurs because `account` has type
    |                 `broken::BankAccount`, which does not implement the
    |                 `Copy` trait
101 | let _taker = std::thread::spawn(move || take_out(&amp;mut account));
    |                                 -------               ------- variable
    |                                 |                         moved due to
    |                                 |                         use in closure
    |                                 |
    |                                 value moved into closure here
102 | let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
    |                                 ^^^^^^^             ------- use occurs due
    |                                 |                        to use in closure
    |                                 |
    |                                 value used here after move
</code></pre>
<p>借用检查器规则（<a href="https://www.lurklurk.org/effective-rust/borrows.html">第 15 条</a>）能告知我们原因：对同一项目有两个可变引用，其中一个超出了允许的范围。借用检查器的规则是，你可以对某个项目有单个可变引用，或者多个（不可变）引用，但是不能同时有二者。</p>
<p>这与本条开头的数据竞争的定义有一个奇怪的相同点：强制只有一个写入者，或多个读取者（但不能两者同时），这意味着不能出现数据竞争。通过强制执行内存安全，<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Rust “免费” 获得了线程安全</a>。</p>
<p>与 C++ 一样，需要某种同步来使得 <code>struct</code> 线程安全。最常见的机制也称为 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> 互斥锁，但 Rust 版本的 Mutex “包装” 受保护的数据，而不是变成一个独立的对象（如 C++中）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BankAccount {
    balance: std::sync::Mutex&lt;i64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>Mutex</code> 泛型上的 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock()</code></a> 方法返回具有 RAII 行为的 <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> 对象，如 C++ 的 <code>std::lock_guard</code> 一样：在作用域结束时，guard 被 drop，互斥锁会自动释放。（与 C++ 相比，Rust 的互斥锁并没有手动获取或释放的方法，因为它们会让开发者陷入忘记保持这些调用完全同步的风险中。）</p>
<p>更准确地说，<code>lock()</code> 实际上返回了一个持有 <code>MutexGuard</code> 的 <code>Result</code>，以应对 <code>Mutex</code> 被<em>中毒</em>的可能性。如果线程在持有锁时失败，就会发生中毒，因为这可能意味着任何被互斥锁保护的不变量已经不再可靠。实际上，锁中毒是非常罕见的（并且当它发生时让程序终止是可取的），因此通常会直接调用 <code>.unwarp()</code> 来处理 <code>Result</code>（尽管这与<a href="https://www.lurklurk.org/effective-rust/panic.html">第 18 条</a>相违背）。</p>
<p><code>MutexGuard</code> 对象还通过实现 <code>Deref</code> 和 <code>DerefMut</code> trait <a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>来充当 <code>Mutex</code> 所包含数据的代理，允许它可以进行读取操作。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BankAccount {
    pub fn balance(&amp;self) -&gt; i64 {
        let balance = *self.balance.lock().unwrap();
        if balance &lt; 0 {
            panic!("** Oh no, gone overdrawn: {}", balance);
        }
        balance
    }
}
<span class="boring">}</span></code></pre></pre>
<p>对于写入操作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BankAccount {
    // 注意：不再需要 `&amp;mut self`。
    pub fn deposit(&amp;self, amount: i64) {
        *self.balance.lock().unwrap() += amount
    }
    pub fn withdraw(&amp;self, amount: i64) -&gt; bool {
        let mut balance = self.balance.lock().unwrap();
        if *balance &lt; amount {
            return false;
        }
        *balance -= amount;
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这些方法的签名中隐藏一个有趣的细节：尽管他们正在修改 <code>BankAccount</code> 的余额，但是这些方法参数是 <code>&amp;self</code> 而不是 <code>&amp;mut self</code>。这是不可避免的：如果多个线程想要保存对同一个 <code>BankAccount</code> 的引用，根据借用检查器规则，这些引用最好是不可变的。这也是<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>中描述的<em>内部可变性</em>模式的另一个实例：借用检查实际上从编译时移动到运行时，但是此处具有了同步跨线程行为。如果可变引用已经存在，则尝试获取第二个引用将被阻止，直到第一个引用已被删除。</p>
<p>把共享状态包装在 <code>Mutex</code> 中可以安抚借用检查器，但仍存在生命周期问题（<a href="https://www.lurklurk.org/effective-rust/lifetimes.html">第 14 条</a>）需要修复：</p>
<div class="ferris"><img src="../images/ferris/does_not_compile.svg" width="75" height="75" /></div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let account = BankAccount::new();
    let taker = std::thread::spawn(|| take_out(&amp;account));
    let payer = std::thread::spawn(|| pay_in(&amp;account));
    // 在该作用域末尾，`account` 被 drop，但是
    // `_taker` 和 `_payer` 线程仍在运行，所以
    // 仍持有对 `account` 的（不可变）引用。
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `account`
              which is owned by the current function
   --&gt; src/main.rs:206:40
    |
206 |     let taker = std::thread::spawn(|| take_out(&amp;account));
    |                                    ^^           ------- `account` is
    |                                    |                     borrowed here
    |                                    |
    |                                    may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; src/main.rs:206:21
    |
206 |     let taker = std::thread::spawn(|| take_out(&amp;account));
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other
      referenced variables), use the `move` keyword
    |
206 |     let taker = std::thread::spawn(move || take_out(&amp;account));
    |                                    ++++
error[E0373]: closure may outlive the current function, but it borrows `account`
              which is owned by the current function
   --&gt; src/main.rs:207:40
    |
207 |     let payer = std::thread::spawn(|| pay_in(&amp;account));
    |                                    ^^         ------- `account` is
    |                                    |                  borrowed here
    |                                    |
    |                                    may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; src/main.rs:207:21
    |
207 |     let payer = std::thread::spawn(|| pay_in(&amp;account));
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other
      referenced variables), use the `move` keyword
    |
207 |     let payer = std::thread::spawn(move || pay_in(&amp;account));
    |                                    ++++
</code></pre>
<p>给出的错误消息清晰展示问题所在：<code>BankAccount</code> 将在该块末尾被 <code>drop</code>，但是这里有两个线程引用了它，并可能在这之后继续运行。（编译器给出关于如何修改的建议并没有太大帮助——如果 <code>BankAccount</code> 数据被移动到第一个闭包中，则第二个闭包将无法再接收对它的引用！）</p>
<p>用来确保对象保持活动状态，直到对它的所有引用都消失，这种标准工具是引用计数指针，Rust 用于多线程使用的变体是 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account = std::sync::Arc::new(BankAccount::new());
account.deposit(1000);

let account2 = account.clone();
let _taker = std::thread::spawn(move || take_out(&amp;account2));

let account3 = account.clone();
let _payer = std::thread::spawn(move || pay_in(&amp;account3));
<span class="boring">}</span></code></pre></pre>
<p>每个线程都会获得自己的引用计数指针的副本，并移动至闭包中，并且仅当引用计数降至零时，才会使底层数据 <code>BankAccount</code> 被 <code>drop</code>。<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 这种组合在使用共享状态并行性的 Rust 程序中很常见。</p>
<p>从技术细节退一步来看，Rust 完全避免了困扰其他语言的多线程编程的数据竞争问题。当然，这个好消息仅限于 <em>safe</em> Rust——<code>unsafe</code> 代码（<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>）和尤其是 FFI 绑定（<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>）可能不会避免数据竞争——但是这仍是一个值得注意的现象。</p>
<h3 id="标准库-trait-标记"><a class="header" href="#标准库-trait-标记">标准库 trait 标记</a></h3>
<p>有两个标准库 trait 会影响线程之间 Rust 对象的使用。这两个 trait 都是<em>标记 trait</em>（<a href="https://www.lurklurk.org/effective-rust/std-traits.html">第 10 条</a>），他们没有关联的方法，但在多线程场景中对于编译器具有特殊含义：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> trait 表明某种类型的数据可以安全地跨线程传输；这种类型的数据的所有权可以从一个线程传递到另一个线程。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> trait 表明某种类型的数据可以由多个线程安全地访问，但必须遵守借用检查器规则。</li>
</ul>
<p>换句话说，我们可以发现，<code>Send</code> 意味着 <code>T</code> 可以在线程间传输，<code>Sync</code> 意味着 <code>&amp;T</code> 可以在线程间传输。</p>
<p>这两个 trait 都是<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">自动 trait</a>：编译器会自动把他们派生（derive）为新类型，只需要该类型的组成部分也实现了 <code>Send</code> / <code>Sync</code>。</p>
<p>大多数安全类型都实现了 <code>Send</code> 和 <code>Sync</code>，这些类型太多了，所以我们需要清楚的了解哪些类型<em>没有</em>实现这些 trait（以 <code>impl !Sync for Type</code> 来表示）。</p>
<p>没有实现 <code>Send</code> 的类型只能在单个线程使用。一个典型的例子是非同步引用计数指针 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>（<a href="https://www.lurklurk.org/effective-rust/references.html">第 8 条</a>）。这种类型在实现上就明确假定使用单线程（为了速度）；它没有尝试同步内部引用计数来供多线程使用。因此，不允许在线程之间传输 <code>Rc&lt;T&gt;</code>；为此应该用 <code>Arc&lt;T&gt;</code>（以及额外性能开销）。</p>
<p>未实现 <code>Sync</code> 的类型无法安全地从多个线程通过<em>非</em><code>mut</code>引用来使用（因为借用检查器会确保永远不会有多个 <code>mut</code> 引用）。典型的例子是，以不同步方式提供<em>内部可变性</em>的类型，例如 <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> 和 <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>。使用 <code>Mutex&lt;T&gt;</code> 或 <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> 来在多线程环境中提供内部可变性。</p>
<p>原始指针类型，比如 <code>*const T</code> 和 <code>*mut T</code> 也都没实现 <code>Send</code> 和 <code>Sync</code>；相见<a href="https://www.lurklurk.org/effective-rust/unsafe.html">第 16 条</a>和<a href="https://www.lurklurk.org/effective-rust/ffi.html">第 34 条</a>。</p>
<h2 id="死锁"><a class="header" href="#死锁">死锁</a></h2>
<p>现在有个坏消息。虽然 Rust 已经解决了数据竞争问题（如前所述），但对于具有共享状态的多线程代码来说，它仍会受到<em>第二个</em>可怕问题的影响：<em>死锁</em>。</p>
<p>考虑一个简化的多人服务器，它是用多线程应用来实现的，可以并行地为许多玩家提供服务。有两个核心的数据结构，可能是玩家的集合（按用户名索引），以及正在进行游戏的集合（按某个唯一的标识符进行索引）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameServer {
    // 从玩家名字到玩家信息的映射
    players: Mutex&lt;HashMap&lt;String, Player&gt;&gt;,
    // 当前游戏，由唯一的 game ID 来索引。
    games: Mutex&lt;HashMap&lt;GameId, Game&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>这两种数据结构都有 <code>Mutex</code> 来保护，所以不会出现数据竞争。然而，操作<em>这两种</em>数据结构的代码可能有潜在的问题。两者之间的单一交互可以正常运行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GameServer {
    /// 添加新玩家并将他们加入当前游戏。
    fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameId&gt; {
        // 添加新玩家
        let mut players = self.players.lock().unwrap();
        players.insert(username.to_owned(), info);

        // 找到一个未满的游戏房间来让他们加入
        let mut games = self.games.lock().unwrap();
        for (id, game) in games.iter_mut() {
            if game.add_player(username) {
                return Some(id.clone());
            }
        }
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然而，两个相互独立且锁定的数据结构之间的第二次交互，就会开始产生问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl GameServer {
    /// 通过 `username` 来封禁掉玩家，把他们从任何当前游戏中移除
    fn ban_player(&amp;self, username: &amp;str) {
        // 找到该用户所在所有的游戏房间，并移除。
        let mut games = self.games.lock().unwrap();
        games
            .iter_mut()
            .filter(|(_id, g)| g.has_player(username))
            .for_each(|(_id, g)| g.remove_player(username));

        // 从用户列表删除他们。
        let mut players = self.players.lock().unwrap();
        players.remove(username);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>为了理解该问题，想象有两个单独的线程使用这两种方法，他们的执行顺序如表 3-1 所示。</p>
<p><em>表 3-1. 线程死锁顺序</em></p>
<div class="table-wrapper"><table><thead><tr><th><strong>线程 1</strong></th><th><strong>线程 2</strong></th></tr></thead><tbody>
<tr><td>进入 <code>add_and_join()</code> 并立即获取 <code>players</code> 锁。</td><td></td></tr>
<tr><td></td><td>进入 <code>ban_player()</code> 并立即获取 <code>games</code> 锁。</td></tr>
<tr><td>尝试获取 <code>games</code> 锁；但目前由线程 2 所有，所以线程 1 阻塞。</td><td></td></tr>
<tr><td></td><td>尝试获取 <code>players</code> 锁；但目前由线程 1 所有，所以线程 2 阻塞。</td></tr>
</tbody></table>
</div>
<p>此时，程序陷入死锁：两个线程都不会继续运行，任何其他线程也不会对两个 <code>Mutex</code> 保护的数据结构中的任何一个执行任何操作。</p>
<p>其根本原因是<em>锁反转</em>：一个函数按照 <code>player</code> 然后 <code>games</code> 的顺序获取锁，而另外一个函数使用相反的顺序（<code>games</code> 然后 <code>players</code>）。这只是一个普遍问题的简单示例；更长的嵌套锁链也会出现这种情况（线程 1 取得锁 A，然后 B，然后尝试获取 C；线程 2 获取 C，然后尝试获取 A）以及跨更多线程（线程 1 给 A 上锁，然后 B；线程 2 给 B 上锁，然后 C；线程 3 给 C 上锁，然后 A）。</p>
<p>解决此问题的尝试的简单方法有：缩小锁的范围，因此我没有必要同时持有两个锁。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 添加新玩家，并把他们加入到当前游戏
fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameId&gt; {
    // 添加新玩家。
    {
        let mut players = self.players.lock().unwrap();
        players.insert(username.to_owned(), info);
    }

    // 找到一个未满的游戏房间来让他们加入
    {
        let mut games = self.games.lock().unwrap();
        for (id, game) in games.iter_mut() {
            if game.add_player(username) {
                return Some(id.clone());
            }
        }
    }
    None
}
/// 通过 `username` 来封禁掉玩家，把他们从任何当前游戏中移除
fn ban_player(&amp;self, username: &amp;str) {
    // 找到该用户所在所有的游戏房间，并移除。
    {
        let mut games = self.games.lock().unwrap();
        games
            .iter_mut()
            .filter(|(_id, g)| g.has_player(username))
            .for_each(|(_id, g)| g.remove_player(username));
    }

    // 从用户列表删除他们。
    {
        let mut players = self.players.lock().unwrap();
        players.remove(username);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>（更好的方法是将 <code>players</code> 数据结构的操作封装到 <code>add_player()</code> 和 <code>remove_player()</code> 辅助方法中，来减少忘记关闭作用域范围的可能性。）</p>
<p>这解决了死锁问题，但是又多了数据一致性的问题：如果执行顺序如表 3-2 所示，<code>players</code> 和 <code>games</code> 的数据结构可能会彼此不同步。</p>
<p><em>表 3-2. 状态不一致顺序</em></p>
<div class="table-wrapper"><table><thead><tr><th><strong>线程 1</strong></th><th><strong>线程 2</strong></th></tr></thead><tbody>
<tr><td>进入 <code>add_and_join("Alice")</code> 并且添加 Alice 到 <code>players</code> 数据结构中（然后释放 <code>players</code> 锁）</td><td></td></tr>
<tr><td></td><td>进入 <code>ban_player("Alice")</code> 并且从所有 <code>games</code> 中移除 Alice（然后释放 <code>games</code> 锁）</td></tr>
<tr><td></td><td>从 <code>players</code> 数据结构中删除 Alice；线程 1 已经释放了锁，所以不会阻塞</td></tr>
<tr><td>继续并获取 <code>games</code> 锁（已由线程 2 释放）。持有锁后，添加 "Alice" 到正在进行的游戏中</td><td></td></tr>
</tbody></table>
</div>
<p>此时，根据 <code>player</code> 数据结构，有一个游戏包含不存在的玩家！</p>
<p>问题的核心是，有两个数据结构都需要保持彼此同步。做到这一点的最好方法是使用一个覆盖二者的同步原语：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameState {
    players: HashMap&lt;String, Player&gt;,
    games: HashMap&lt;GameId, Game&gt;,
}

struct GameServer {
    state: Mutex&lt;GameState&gt;,
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="建议"><a class="header" href="#建议">建议</a></h2>
<p>为了避免共享状态并行性所出现的问题，最明显的建议就是避免共享状态的并行性。<a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">Rust 程序设计语言</a>中引用了 <a href="https://golang.org/doc/effective_go.html#concurrency">Go 语言文档</a>：“不用通过共享内存进行通信；相反，通过通信来共享内存。”</p>
<p>Go 语言<a href="https://go.dev/ref/spec#Channel_types">内置了</a>用于这种操作的<em>管道</em>；对 Rust 来说，相同的功能可以在标准库 <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code> 模块</a>中找到：函数 <code>channel()</code> 返回一个 <code>(Sender, Receiver)</code> 元组对，允许特性类型的值在线程之间进行通信。</p>
<p>如果共享状态进行并发无法避免，那么有一些方法可以减少编写容易出现死锁问题的代码：</p>
<ul>
<li><strong>将必须保持一致的数据结构包含在单个互斥锁中。</strong></li>
<li><strong>保持互斥锁的范围越小越明显越好</strong>；尽可能使用辅助方法来获取和设置锁所包含的内容。</li>
<li><strong>避免调用持有锁的闭包</strong>；这会使得代码受到将来可能添加到代码库中的任何闭包的影响。</li>
<li>同样，<strong>避免将 <code>MutexGuard</code> 返回给调用者</strong>：从死锁的角度看，这就像是分发一把已经上膛的枪。</li>
<li>在 CI 系统（<a href="https://www.lurklurk.org/effective-rust/ci.html">第 32 条</a>）中加入<em>死锁检测工具</em>，例如 <a href="https://docs.rs/no_deadlocks"><code>no_deadlocks</code></a>，<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>，或<a href="https://amanieu.github.io/parking_lot/parking_lot/deadlock/index.html"><code>parking_lot::deadlock</code></a>。</li>
<li>最后手段：设计、记录、测试并严格执行一个<em>上锁的层次结构</em>，该结构描述了允许\需求的锁定顺序。这应该作为最后的手段，因为任何依赖于工程师从不犯错策略从长远来看都很可能失败。</li>
</ul>
<p>更抽象地说，多线程代码应该应用于以下一般建议的理想场所：倾向于编写明显没有错误的简单代码，而不是编写复杂到不明显有错误的代码。</p>
<h4 id="注释"><a class="header" href="#注释">注释</a></h4>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>第三种类的行为是*线程对立（thread-hostile）*的：<em>即使</em>对它的所有访问都是对外同步的，代码在多线程环境中也是危险的。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Clang C++ 编译器包含一个 <a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html"><code>-Wthread-safety</code></a> 选项，有时也称为<em>注释</em>，它允许通过关于哪一个互斥锁保护该数据的信息来注释该数据，并通过关于该函数获取锁的信息来注释该函数。当这些不变量被破坏时，会在编译期产生错误，就像 Rust 一样；然而，并没有强制使用这些注释——例如，当一个线程兼容的库第一个在多线程环境中使用时。</p>
</div>
<p>原文<a href="https://www.lurklurk.org/effective-rust/deadlock.html">点这里</a>查看</p>
<!-- 参考链接 -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_3/item16-unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_3/item18-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_3/item16-unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_3/item18-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../style/js/tongji.js"></script>
        <script src="../style/js/ferris.js"></script>


    </div>
    </body>
</html>
